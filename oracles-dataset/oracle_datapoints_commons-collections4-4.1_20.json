[
    {
        "id": 6350,
        "oracle": ";",
        "oracleType": "EXCEPT_POST",
        "projectName": "commons-collections4-4.1",
        "packageName": "org.apache.commons.collections4.collection",
        "className": "IndexedCollection",
        "javadocTag": "@throws IllegalArgumentException if the object maps to an existing key and the index\n  enforces a uniqueness constraint",
        "methodJavadoc": "    /**\n     * {@inheritDoc}\n     *\n     * @throws IllegalArgumentException if the object maps to an existing key and the index\n     *   enforces a uniqueness constraint\n     */",
        "methodSourceCode": "public boolean add(final C object){\n    final boolean added = super.add(object);\n    if (added) {\n        addToIndex(object);\n    }\n    return added;\n}",
        "classJavadoc": "/**\n * An IndexedCollection is a Map-like view onto a Collection. It accepts a\n * keyTransformer to define how the keys are converted from the values.\n * <p>\n * Modifications made to this decorator modify the index as well as the\n * decorated {@link Collection}. However, modifications to the underlying\n * {@link Collection} will not update the index and it will get out of sync.\n * <p>\n * If modification of the decorated {@link Collection} is unavoidable, then a\n * call to {@link #reindex()} will update the index to the current contents of\n * the {@link Collection}.\n *\n * @param <K> the type of object in the index.\n * @param <C> the type of object in the collection.\n *\n * @since 4.0\n * @version $Id: IndexedCollection.java 1683018 2015-06-01 22:41:31Z tn $\n */",
        "classSourceCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4.collection;\n\nimport java.util.Collection;\nimport java.util.HashMap;\n\nimport org.apache.commons.collections4.MultiMap;\nimport org.apache.commons.collections4.Transformer;\nimport org.apache.commons.collections4.map.MultiValueMap;\n\n/**\n * An IndexedCollection is a Map-like view onto a Collection. It accepts a\n * keyTransformer to define how the keys are converted from the values.\n * <p>\n * Modifications made to this decorator modify the index as well as the\n * decorated {@link Collection}. However, modifications to the underlying\n * {@link Collection} will not update the index and it will get out of sync.\n * <p>\n * If modification of the decorated {@link Collection} is unavoidable, then a\n * call to {@link #reindex()} will update the index to the current contents of\n * the {@link Collection}.\n *\n * @param <K> the type of object in the index.\n * @param <C> the type of object in the collection.\n *\n * @since 4.0\n * @version $Id: IndexedCollection.java 1683018 2015-06-01 22:41:31Z tn $\n */\npublic class IndexedCollection<K, C> extends AbstractCollectionDecorator<C> {\n\n    // TODO: replace with MultiValuedMap\n\n    /** Serialization version */\n    private static final long serialVersionUID = -5512610452568370038L;\n\n    /** The {@link Transformer} for generating index keys. */\n    private final Transformer<C, K> keyTransformer;\n\n    /** The map of indexes to collected objects. */\n    private final MultiMap<K, C> index;\n\n    /** The uniqueness constraint for the index. */\n    private final boolean uniqueIndex;\n\n    /**\n     * Create an {@link IndexedCollection} for a unique index.\n     * <p>\n     * If an element is added, which maps to an existing key, an {@link IllegalArgumentException}\n     * will be thrown.\n     *\n     * @param <K> the index object type.\n     * @param <C> the collection type.\n     * @param coll the decorated {@link Collection}.\n     * @param keyTransformer the {@link Transformer} for generating index keys.\n     * @return the created {@link IndexedCollection}.\n     */\n    public static <K, C> IndexedCollection<K, C> uniqueIndexedCollection(final Collection<C> coll,\n                                                                         final Transformer<C, K> keyTransformer) {\n        return new IndexedCollection<K, C>(coll, keyTransformer,\n                                           MultiValueMap.<K, C>multiValueMap(new HashMap<K, Collection<C>>()),\n                                           true);\n    }\n\n    /**\n     * Create an {@link IndexedCollection} for a non-unique index.\n     *\n     * @param <K> the index object type.\n     * @param <C> the collection type.\n     * @param coll the decorated {@link Collection}.\n     * @param keyTransformer the {@link Transformer} for generating index keys.\n     * @return the created {@link IndexedCollection}.\n     */\n    public static <K, C> IndexedCollection<K, C> nonUniqueIndexedCollection(final Collection<C> coll,\n                                                                            final Transformer<C, K> keyTransformer) {\n        return new IndexedCollection<K, C>(coll, keyTransformer,\n                                           MultiValueMap.<K, C>multiValueMap(new HashMap<K, Collection<C>>()),\n                                           false);\n    }\n\n    /**\n     * Create a {@link IndexedCollection}.\n     *\n     * @param coll  decorated {@link Collection}\n     * @param keyTransformer  {@link Transformer} for generating index keys\n     * @param map  map to use as index\n     * @param uniqueIndex  if the index shall enforce uniqueness of index keys\n     */\n    public IndexedCollection(final Collection<C> coll, final Transformer<C, K> keyTransformer,\n                             final MultiMap<K, C> map, final boolean uniqueIndex) {\n        super(coll);\n        this.keyTransformer = keyTransformer;\n        this.index = map;\n        this.uniqueIndex = uniqueIndex;\n        reindex();\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * @throws IllegalArgumentException if the object maps to an existing key and the index\n     *   enforces a uniqueness constraint\n     */\n    @Override\n    public boolean add(final C object) {\n        final boolean added = super.add(object);\n        if (added) {\n            addToIndex(object);\n        }\n        return added;\n    }\n\n    @Override\n    public boolean addAll(final Collection<? extends C> coll) {\n        boolean changed = false;\n        for (final C c: coll) {\n            changed |= add(c);\n        }\n        return changed;\n    }\n\n    @Override\n    public void clear() {\n        super.clear();\n        index.clear();\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p>\n     * Note: uses the index for fast lookup\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public boolean contains(final Object object) {\n        return index.containsKey(keyTransformer.transform((C) object));\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p>\n     * Note: uses the index for fast lookup\n     */\n    @Override\n    public boolean containsAll(final Collection<?> coll) {\n        for (final Object o : coll) {\n            if (!contains(o)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Get the element associated with the given key.\n     * <p>\n     * In case of a non-unique index, this method will return the first\n     * value associated with the given key. To retrieve all elements associated\n     * with a key, use {@link #values(Object)}.\n     *\n     * @param key  key to look up\n     * @return element found\n     * @see #values(Object)\n     */\n    public C get(final K key) {\n        @SuppressWarnings(\"unchecked\") // index is a MultiMap which returns a Collection\n        final Collection<C> coll = (Collection<C>) index.get(key);\n        return coll == null ? null : coll.iterator().next();\n    }\n\n    /**\n     * Get all elements associated with the given key.\n     *\n     * @param key  key to look up\n     * @return a collection of elements found, or null if {@code contains(key) == false}\n     */\n    @SuppressWarnings(\"unchecked\") // index is a MultiMap which returns a Collection\n    public Collection<C> values(final K key) {\n        return (Collection<C>) index.get(key);\n    }\n\n    /**\n     * Clears the index and re-indexes the entire decorated {@link Collection}.\n     */\n    public void reindex() {\n        index.clear();\n        for (final C c : decorated()) {\n            addToIndex(c);\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public boolean remove(final Object object) {\n        final boolean removed = super.remove(object);\n        if (removed) {\n            removeFromIndex((C) object);\n        }\n        return removed;\n    }\n\n    @Override\n    public boolean removeAll(final Collection<?> coll) {\n        boolean changed = false;\n        for (final Object o : coll) {\n            changed |= remove(o);\n        }\n        return changed;\n    }\n\n    @Override\n    public boolean retainAll(final Collection<?> coll) {\n        final boolean changed = super.retainAll(coll);\n        if (changed) {\n            reindex();\n        }\n        return changed;\n    }\n\n    //-----------------------------------------------------------------------\n\n    /**\n     * Provides checking for adding the index.\n     *\n     * @param object the object to index\n     * @throws IllegalArgumentException if the object maps to an existing key and the index\n     *   enforces a uniqueness constraint\n     */\n    private void addToIndex(final C object) {\n        final K key = keyTransformer.transform(object);\n        if (uniqueIndex && index.containsKey(key)) {\n            throw new IllegalArgumentException(\"Duplicate key in uniquely indexed collection.\");\n        }\n        index.put(key, object);\n    }\n\n    /**\n     * Removes an object from the index.\n     *\n     * @param object the object to remove\n     */\n    private void removeFromIndex(final C object) {\n        index.remove(keyTransformer.transform(object));\n    }\n\n}\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "BidiMap",
                "org.apache.commons.collections4"
            ],
            [
                "Equator",
                "org.apache.commons.collections4"
            ],
            [
                "MultiSet",
                "org.apache.commons.collections4"
            ],
            [
                "IteratorUtils",
                "org.apache.commons.collections4"
            ],
            [
                "ComparatorUtils",
                "org.apache.commons.collections4"
            ],
            [
                "FunctorException",
                "org.apache.commons.collections4"
            ],
            [
                "AbstractDualBidiMap",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "UnmodifiableBidiMap",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "AbstractOrderedBidiMapDecorator",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "UnmodifiableOrderedBidiMap",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "AbstractBidiMapDecorator",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "DualLinkedHashBidiMap",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "UnmodifiableSortedBidiMap",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "AbstractSortedBidiMapDecorator",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "DualHashBidiMap",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "DualTreeBidiMap",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "TreeBidiMap",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "MultiMapUtils",
                "org.apache.commons.collections4"
            ],
            [
                "BoundedCollection",
                "org.apache.commons.collections4"
            ],
            [
                "UnmodifiableBoundedCollection",
                "org.apache.commons.collections4.collection"
            ],
            [
                "CompositeCollection",
                "org.apache.commons.collections4.collection"
            ],
            [
                "TransformedCollection",
                "org.apache.commons.collections4.collection"
            ],
            [
                "PredicatedCollection",
                "org.apache.commons.collections4.collection"
            ],
            [
                "IndexedCollection",
                "org.apache.commons.collections4.collection"
            ],
            [
                "SynchronizedCollection",
                "org.apache.commons.collections4.collection"
            ],
            [
                "UnmodifiableCollection",
                "org.apache.commons.collections4.collection"
            ],
            [
                "AbstractCollectionDecorator",
                "org.apache.commons.collections4.collection"
            ],
            [
                "OrderedBidiMap",
                "org.apache.commons.collections4"
            ],
            [
                "FactoryUtils",
                "org.apache.commons.collections4"
            ],
            [
                "IterableGet",
                "org.apache.commons.collections4"
            ],
            [
                "ListUtils",
                "org.apache.commons.collections4"
            ],
            [
                "Closure",
                "org.apache.commons.collections4"
            ],
            [
                "IterableSortedMap",
                "org.apache.commons.collections4"
            ],
            [
                "MapUtils",
                "org.apache.commons.collections4"
            ],
            [
                "Transformer",
                "org.apache.commons.collections4"
            ],
            [
                "DefaultEquator",
                "org.apache.commons.collections4.functors"
            ],
            [
                "StringValueTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "PredicateDecorator",
                "org.apache.commons.collections4.functors"
            ],
            [
                "IfTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "IdentityPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ExceptionClosure",
                "org.apache.commons.collections4.functors"
            ],
            [
                "NOPClosure",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ClosureTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "FunctorUtils",
                "org.apache.commons.collections4.functors"
            ],
            [
                "TransformerPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "NullPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ConstantTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "PredicateTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "WhileClosure",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ForClosure",
                "org.apache.commons.collections4.functors"
            ],
            [
                "NullIsTruePredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "TransformedPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "NonePredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ExceptionTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "SwitchTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "TransformerClosure",
                "org.apache.commons.collections4.functors"
            ],
            [
                "OrPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "NOPTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "MapTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ExceptionFactory",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ChainedClosure",
                "org.apache.commons.collections4.functors"
            ],
            [
                "AndPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "PrototypeFactory",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ExceptionPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "AbstractQuantifierPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "InstanceofPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "InvokerTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "FalsePredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "CloneTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "NotPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ConstantFactory",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ChainedTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ComparatorPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "CatchAndRethrowClosure",
                "org.apache.commons.collections4.functors"
            ],
            [
                "AllPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "NullIsFalsePredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "NullIsExceptionPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "AnyPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "TruePredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "FactoryTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "NotNullPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "SwitchClosure",
                "org.apache.commons.collections4.functors"
            ],
            [
                "UniquePredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "InstantiateTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "OnePredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "EqualPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "InstantiateFactory",
                "org.apache.commons.collections4.functors"
            ],
            [
                "IfClosure",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ResettableListIterator",
                "org.apache.commons.collections4"
            ],
            [
                "OrderedIterator",
                "org.apache.commons.collections4"
            ],
            [
                "ComparatorChain",
                "org.apache.commons.collections4.comparators"
            ],
            [
                "BooleanComparator",
                "org.apache.commons.collections4.comparators"
            ],
            [
                "ReverseComparator",
                "org.apache.commons.collections4.comparators"
            ],
            [
                "ComparableComparator",
                "org.apache.commons.collections4.comparators"
            ],
            [
                "TransformingComparator",
                "org.apache.commons.collections4.comparators"
            ],
            [
                "FixedOrderComparator",
                "org.apache.commons.collections4.comparators"
            ],
            [
                "NullComparator",
                "org.apache.commons.collections4.comparators"
            ],
            [
                "CollectionUtils",
                "org.apache.commons.collections4"
            ],
            [
                "ListValuedMap",
                "org.apache.commons.collections4"
            ],
            [
                "AbstractIterableGetMapDecorator",
                "org.apache.commons.collections4.splitmap"
            ],
            [
                "TransformedSplitMap",
                "org.apache.commons.collections4.splitmap"
            ],
            [
                "Factory",
                "org.apache.commons.collections4"
            ],
            [
                "IterableUtils",
                "org.apache.commons.collections4"
            ],
            [
                "Bag",
                "org.apache.commons.collections4"
            ],
            [
                "Predicate",
                "org.apache.commons.collections4"
            ],
            [
                "SortedBag",
                "org.apache.commons.collections4"
            ],
            [
                "TrieUtils",
                "org.apache.commons.collections4"
            ],
            [
                "ClosureUtils",
                "org.apache.commons.collections4"
            ],
            [
                "PatriciaTrie",
                "org.apache.commons.collections4.trie"
            ],
            [
                "UnmodifiableTrie",
                "org.apache.commons.collections4.trie"
            ],
            [
                "KeyAnalyzer",
                "org.apache.commons.collections4.trie"
            ],
            [
                "AbstractPatriciaTrie",
                "org.apache.commons.collections4.trie"
            ],
            [
                "AbstractBitwiseTrie",
                "org.apache.commons.collections4.trie"
            ],
            [
                "StringKeyAnalyzer",
                "org.apache.commons.collections4.trie.analyzer"
            ],
            [
                "TransformedSortedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "AbstractLinkedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "Flat3Map",
                "org.apache.commons.collections4.map"
            ],
            [
                "PredicatedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "FixedSizeSortedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "UnmodifiableSortedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "PredicatedSortedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "DefaultedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "ReferenceIdentityMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "AbstractSortedMapDecorator",
                "org.apache.commons.collections4.map"
            ],
            [
                "AbstractInputCheckedMapDecorator",
                "org.apache.commons.collections4.map"
            ],
            [
                "FixedSizeMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "LazySortedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "UnmodifiableOrderedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "CaseInsensitiveMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "AbstractHashedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "AbstractOrderedMapDecorator",
                "org.apache.commons.collections4.map"
            ],
            [
                "UnmodifiableMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "EntrySetToMapIteratorAdapter",
                "org.apache.commons.collections4.map"
            ],
            [
                "AbstractIterableMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "ListOrderedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "LinkedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "SingletonMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "UnmodifiableEntrySet",
                "org.apache.commons.collections4.map"
            ],
            [
                "StaticBucketMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "AbstractMapDecorator",
                "org.apache.commons.collections4.map"
            ],
            [
                "AbstractReferenceMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "MultiKeyMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "HashedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "LazyMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "PassiveExpiringMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "MultiValueMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "LRUMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "ReferenceMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "TransformedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "CompositeMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "UnmodifiableMapEntry",
                "org.apache.commons.collections4.keyvalue"
            ],
            [
                "MultiKey",
                "org.apache.commons.collections4.keyvalue"
            ],
            [
                "DefaultMapEntry",
                "org.apache.commons.collections4.keyvalue"
            ],
            [
                "DefaultKeyValue",
                "org.apache.commons.collections4.keyvalue"
            ],
            [
                "AbstractMapEntryDecorator",
                "org.apache.commons.collections4.keyvalue"
            ],
            [
                "AbstractKeyValue",
                "org.apache.commons.collections4.keyvalue"
            ],
            [
                "TiedMapEntry",
                "org.apache.commons.collections4.keyvalue"
            ],
            [
                "AbstractMapEntry",
                "org.apache.commons.collections4.keyvalue"
            ],
            [
                "MultiSetUtils",
                "org.apache.commons.collections4"
            ],
            [
                "MapIterator",
                "org.apache.commons.collections4"
            ],
            [
                "AbstractMultiValuedMap",
                "org.apache.commons.collections4.multimap"
            ],
            [
                "UnmodifiableMultiValuedMap",
                "org.apache.commons.collections4.multimap"
            ],
            [
                "HashSetValuedHashMap",
                "org.apache.commons.collections4.multimap"
            ],
            [
                "TransformedMultiValuedMap",
                "org.apache.commons.collections4.multimap"
            ],
            [
                "AbstractSetValuedMap",
                "org.apache.commons.collections4.multimap"
            ],
            [
                "AbstractListValuedMap",
                "org.apache.commons.collections4.multimap"
            ],
            [
                "ArrayListValuedHashMap",
                "org.apache.commons.collections4.multimap"
            ],
            [
                "AbstractMultiValuedMapDecorator",
                "org.apache.commons.collections4.multimap"
            ],
            [
                "LazyList",
                "org.apache.commons.collections4.list"
            ],
            [
                "AbstractSerializableListDecorator",
                "org.apache.commons.collections4.list"
            ],
            [
                "TreeList",
                "org.apache.commons.collections4.list"
            ],
            [
                "SetUniqueList",
                "org.apache.commons.collections4.list"
            ],
            [
                "AbstractListDecorator",
                "org.apache.commons.collections4.list"
            ],
            [
                "NodeCachingLinkedList",
                "org.apache.commons.collections4.list"
            ],
            [
                "UnmodifiableList",
                "org.apache.commons.collections4.list"
            ],
            [
                "FixedSizeList",
                "org.apache.commons.collections4.list"
            ],
            [
                "TransformedList",
                "org.apache.commons.collections4.list"
            ],
            [
                "GrowthList",
                "org.apache.commons.collections4.list"
            ],
            [
                "AbstractLinkedList",
                "org.apache.commons.collections4.list"
            ],
            [
                "CursorableLinkedList",
                "org.apache.commons.collections4.list"
            ],
            [
                "PredicatedList",
                "org.apache.commons.collections4.list"
            ],
            [
                "OrderedMap",
                "org.apache.commons.collections4"
            ],
            [
                "AbstractQueueDecorator",
                "org.apache.commons.collections4.queue"
            ],
            [
                "TransformedQueue",
                "org.apache.commons.collections4.queue"
            ],
            [
                "UnmodifiableQueue",
                "org.apache.commons.collections4.queue"
            ],
            [
                "CircularFifoQueue",
                "org.apache.commons.collections4.queue"
            ],
            [
                "PredicatedQueue",
                "org.apache.commons.collections4.queue"
            ],
            [
                "FluentIterable",
                "org.apache.commons.collections4"
            ],
            [
                "TransformerUtils",
                "org.apache.commons.collections4"
            ],
            [
                "PredicateUtils",
                "org.apache.commons.collections4"
            ],
            [
                "ResettableIterator",
                "org.apache.commons.collections4"
            ],
            [
                "MultiValuedMap",
                "org.apache.commons.collections4"
            ],
            [
                "SetUtils",
                "org.apache.commons.collections4"
            ],
            [
                "SortedBidiMap",
                "org.apache.commons.collections4"
            ],
            [
                "ArrayStack",
                "org.apache.commons.collections4"
            ],
            [
                "Put",
                "org.apache.commons.collections4"
            ],
            [
                "OrderedMapIterator",
                "org.apache.commons.collections4"
            ],
            [
                "TransformedSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "CompositeSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "TransformedNavigableSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "PredicatedNavigableSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "AbstractSetDecorator",
                "org.apache.commons.collections4.set"
            ],
            [
                "ListOrderedSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "UnmodifiableSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "AbstractSerializableSetDecorator",
                "org.apache.commons.collections4.set"
            ],
            [
                "MapBackedSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "UnmodifiableSortedSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "PredicatedSortedSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "AbstractSortedSetDecorator",
                "org.apache.commons.collections4.set"
            ],
            [
                "PredicatedSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "AbstractNavigableSetDecorator",
                "org.apache.commons.collections4.set"
            ],
            [
                "UnmodifiableNavigableSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "TransformedSortedSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "IterableMap",
                "org.apache.commons.collections4"
            ],
            [
                "EnumerationUtils",
                "org.apache.commons.collections4"
            ],
            [
                "DeleteCommand",
                "org.apache.commons.collections4.sequence"
            ],
            [
                "ReplacementsHandler",
                "org.apache.commons.collections4.sequence"
            ],
            [
                "InsertCommand",
                "org.apache.commons.collections4.sequence"
            ],
            [
                "SequencesComparator",
                "org.apache.commons.collections4.sequence"
            ],
            [
                "ReplacementsFinder",
                "org.apache.commons.collections4.sequence"
            ],
            [
                "KeepCommand",
                "org.apache.commons.collections4.sequence"
            ],
            [
                "EditCommand",
                "org.apache.commons.collections4.sequence"
            ],
            [
                "CommandVisitor",
                "org.apache.commons.collections4.sequence"
            ],
            [
                "EditScript",
                "org.apache.commons.collections4.sequence"
            ],
            [
                "QueueUtils",
                "org.apache.commons.collections4"
            ],
            [
                "SetValuedMap",
                "org.apache.commons.collections4"
            ],
            [
                "SynchronizedBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "AbstractMapBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "CollectionBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "UnmodifiableBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "PredicatedSortedBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "UnmodifiableSortedBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "HashBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "AbstractBagDecorator",
                "org.apache.commons.collections4.bag"
            ],
            [
                "TransformedSortedBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "TreeBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "PredicatedBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "SynchronizedSortedBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "CollectionSortedBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "TransformedBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "AbstractSortedBagDecorator",
                "org.apache.commons.collections4.bag"
            ],
            [
                "HashMultiSet",
                "org.apache.commons.collections4.multiset"
            ],
            [
                "AbstractMultiSet",
                "org.apache.commons.collections4.multiset"
            ],
            [
                "PredicatedMultiSet",
                "org.apache.commons.collections4.multiset"
            ],
            [
                "AbstractMultiSetDecorator",
                "org.apache.commons.collections4.multiset"
            ],
            [
                "AbstractMapMultiSet",
                "org.apache.commons.collections4.multiset"
            ],
            [
                "UnmodifiableMultiSet",
                "org.apache.commons.collections4.multiset"
            ],
            [
                "SynchronizedMultiSet",
                "org.apache.commons.collections4.multiset"
            ],
            [
                "BagUtils",
                "org.apache.commons.collections4"
            ],
            [
                "Unmodifiable",
                "org.apache.commons.collections4"
            ],
            [
                "Get",
                "org.apache.commons.collections4"
            ],
            [
                "Trie",
                "org.apache.commons.collections4"
            ],
            [
                "MultiMap",
                "org.apache.commons.collections4"
            ],
            [
                "KeyValue",
                "org.apache.commons.collections4"
            ],
            [
                "IteratorChain",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "EmptyListIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "UnmodifiableOrderedMapIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "AbstractListIteratorDecorator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "ZippingIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "UnmodifiableIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "CollatingIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "UniqueFilterIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "ReverseListIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "BoundedIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "AbstractIteratorDecorator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "TransformIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "AbstractEmptyIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "NodeListIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "ArrayListIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "LazyIteratorChain",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "LoopingListIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "PeekingIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "ObjectGraphIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "ArrayIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "PermutationIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "SingletonListIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "EmptyMapIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "ObjectArrayIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "EnumerationIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "IteratorIterable",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "AbstractEmptyMapIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "LoopingIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "IteratorEnumeration",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "SingletonIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "ListIteratorWrapper",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "SkippingIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "EmptyOrderedIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "AbstractMapIteratorDecorator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "ObjectArrayListIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "UnmodifiableListIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "EmptyOrderedMapIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "UnmodifiableMapIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "EmptyIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "EntrySetMapIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "PushbackIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "FilterIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "AbstractUntypedIteratorDecorator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "AbstractOrderedMapIteratorDecorator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "FilterListIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "SplitMapUtils",
                "org.apache.commons.collections4"
            ],
            [
                "BoundedMap",
                "org.apache.commons.collections4"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "emptyIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Empty\n//-----------------------------------------------------------------------\n/**\n * Gets an empty iterator.\n * <p>\n * This iterator is a valid iterator object that will iterate over nothing.\n *\n * @param <E> the element type\n * @return an iterator over nothing\n */\npublic static <E> ResettableIterator<E> emptyIterator() {\n    return EmptyIterator.<E>resettableEmptyIterator();\n}"
            ],
            [
                "emptyListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an empty list iterator.\n * <p>\n * This iterator is a valid list iterator object that will iterate\n * over nothing.\n *\n * @param <E> the element type\n * @return a list iterator over nothing\n */\npublic static <E> ResettableListIterator<E> emptyListIterator() {\n    return EmptyListIterator.<E>resettableEmptyListIterator();\n}"
            ],
            [
                "emptyOrderedIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an empty ordered iterator.\n * <p>\n * This iterator is a valid iterator object that will iterate\n * over nothing.\n *\n * @param <E> the element type\n * @return an ordered iterator over nothing\n */\npublic static <E> OrderedIterator<E> emptyOrderedIterator() {\n    return EmptyOrderedIterator.<E>emptyOrderedIterator();\n}"
            ],
            [
                "emptyMapIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an empty map iterator.\n * <p>\n * This iterator is a valid map iterator object that will iterate\n * over nothing.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @return a map iterator over nothing\n */\npublic static <K, V> MapIterator<K, V> emptyMapIterator() {\n    return EmptyMapIterator.<K, V>emptyMapIterator();\n}"
            ],
            [
                "emptyOrderedMapIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an empty ordered map iterator.\n * <p>\n * This iterator is a valid map iterator object that will iterate\n * over nothing.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @return a map iterator over nothing\n */\npublic static <K, V> OrderedMapIterator<K, V> emptyOrderedMapIterator() {\n    return EmptyOrderedMapIterator.<K, V>emptyOrderedMapIterator();\n}"
            ],
            [
                "singletonIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Singleton\n//-----------------------------------------------------------------------\n/**\n * Gets a singleton iterator.\n * <p>\n * This iterator is a valid iterator object that will iterate over\n * the specified object.\n *\n * @param <E> the element type\n * @param object  the single object over which to iterate\n * @return a singleton iterator over the object\n */\npublic static <E> ResettableIterator<E> singletonIterator(final E object) {\n    return new SingletonIterator<E>(object);\n}"
            ],
            [
                "singletonListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a singleton list iterator.\n * <p>\n * This iterator is a valid list iterator object that will iterate over\n * the specified object.\n *\n * @param <E> the element type\n * @param object  the single object over which to iterate\n * @return a singleton list iterator over the object\n */\npublic static <E> ListIterator<E> singletonListIterator(final E object) {\n    return new SingletonListIterator<E>(object);\n}"
            ],
            [
                "arrayIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Arrays\n//-----------------------------------------------------------------------\n/**\n * Gets an iterator over an object array.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @return an iterator over the array\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableIterator<E> arrayIterator(final E... array) {\n    return new ObjectArrayIterator<E>(array);\n}"
            ],
            [
                "arrayIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator over an object or primitive array.\n * <p>\n * This method will handle primitive arrays as well as object arrays.\n * The primitives will be wrapped in the appropriate wrapper class.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @return an iterator over the array\n * @throws IllegalArgumentException if the array is not an array\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableIterator<E> arrayIterator(final Object array) {\n    return new ArrayIterator<E>(array);\n}"
            ],
            [
                "arrayIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator over the end part of an object array.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @param start  the index to start iterating at\n * @return an iterator over part of the array\n * @throws IndexOutOfBoundsException if start is less than zero or greater\n *   than the length of the array\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableIterator<E> arrayIterator(final E[] array, final int start) {\n    return new ObjectArrayIterator<E>(array, start);\n}"
            ],
            [
                "arrayIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator over the end part of an object or primitive array.\n * <p>\n * This method will handle primitive arrays as well as object arrays.\n * The primitives will be wrapped in the appropriate wrapper class.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @param start  the index to start iterating at\n * @return an iterator over part of the array\n * @throws IllegalArgumentException if the array is not an array\n * @throws IndexOutOfBoundsException if start is less than zero or greater\n *   than the length of the array\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableIterator<E> arrayIterator(final Object array, final int start) {\n    return new ArrayIterator<E>(array, start);\n}"
            ],
            [
                "arrayIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator over part of an object array.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @param start  the index to start iterating at\n * @param end  the index to finish iterating at\n * @return an iterator over part of the array\n * @throws IndexOutOfBoundsException if array bounds are invalid\n * @throws IllegalArgumentException if end is before start\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableIterator<E> arrayIterator(final E[] array, final int start, final int end) {\n    return new ObjectArrayIterator<E>(array, start, end);\n}"
            ],
            [
                "arrayIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator over part of an object or primitive array.\n * <p>\n * This method will handle primitive arrays as well as object arrays.\n * The primitives will be wrapped in the appropriate wrapper class.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @param start  the index to start iterating at\n * @param end  the index to finish iterating at\n * @return an iterator over part of the array\n * @throws IllegalArgumentException if the array is not an array or end is before start\n * @throws IndexOutOfBoundsException if array bounds are invalid\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableIterator<E> arrayIterator(final Object array, final int start, final int end) {\n    return new ArrayIterator<E>(array, start, end);\n}"
            ],
            [
                "arrayListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "//-----------------------------------------------------------------------\n/**\n * Gets a list iterator over an object array.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @return a list iterator over the array\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableListIterator<E> arrayListIterator(final E... array) {\n    return new ObjectArrayListIterator<E>(array);\n}"
            ],
            [
                "arrayListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a list iterator over an object or primitive array.\n * <p>\n * This method will handle primitive arrays as well as object arrays.\n * The primitives will be wrapped in the appropriate wrapper class.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @return a list iterator over the array\n * @throws IllegalArgumentException if the array is not an array\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableListIterator<E> arrayListIterator(final Object array) {\n    return new ArrayListIterator<E>(array);\n}"
            ],
            [
                "arrayListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a list iterator over the end part of an object array.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @param start  the index to start iterating at\n * @return a list iterator over part of the array\n * @throws IndexOutOfBoundsException if start is less than zero\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableListIterator<E> arrayListIterator(final E[] array, final int start) {\n    return new ObjectArrayListIterator<E>(array, start);\n}"
            ],
            [
                "arrayListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a list iterator over the end part of an object or primitive array.\n * <p>\n * This method will handle primitive arrays as well as object arrays.\n * The primitives will be wrapped in the appropriate wrapper class.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @param start  the index to start iterating at\n * @return a list iterator over part of the array\n * @throws IllegalArgumentException if the array is not an array\n * @throws IndexOutOfBoundsException if start is less than zero\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableListIterator<E> arrayListIterator(final Object array, final int start) {\n    return new ArrayListIterator<E>(array, start);\n}"
            ],
            [
                "arrayListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a list iterator over part of an object array.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @param start  the index to start iterating at\n * @param end  the index to finish iterating at\n * @return a list iterator over part of the array\n * @throws IndexOutOfBoundsException if array bounds are invalid\n * @throws IllegalArgumentException if end is before start\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableListIterator<E> arrayListIterator(final E[] array, final int start, final int end) {\n    return new ObjectArrayListIterator<E>(array, start, end);\n}"
            ],
            [
                "arrayListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a list iterator over part of an object or primitive array.\n * <p>\n * This method will handle primitive arrays as well as object arrays.\n * The primitives will be wrapped in the appropriate wrapper class.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @param start  the index to start iterating at\n * @param end  the index to finish iterating at\n * @return a list iterator over part of the array\n * @throws IllegalArgumentException if the array is not an array or end is before start\n * @throws IndexOutOfBoundsException if array bounds are invalid\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableListIterator<E> arrayListIterator(final Object array, final int start, final int end) {\n    return new ArrayListIterator<E>(array, start, end);\n}"
            ],
            [
                "boundedIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Bounded\n//-----------------------------------------------------------------------\n/**\n * Decorates the specified iterator to return at most the given number\n * of elements.\n *\n * @param <E> the element type\n * @param iterator  the iterator to decorate\n * @param max  the maximum number of elements returned by this iterator\n * @return a new bounded iterator\n * @throws NullPointerException if the iterator is null\n * @throws IllegalArgumentException if max is negative\n * @since 4.1\n */\npublic static <E> BoundedIterator<E> boundedIterator(final Iterator<? extends E> iterator, long max) {\n    return boundedIterator(iterator, 0, max);\n}"
            ],
            [
                "boundedIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Decorates the specified iterator to return at most the given number\n * of elements, skipping all elements until the iterator reaches the\n * position at {@code offset}.\n * <p>\n * The iterator is immediately advanced until it reaches the position at\n * {@code offset}, incurring O(n) time.\n *\n * @param <E> the element type\n * @param iterator  the iterator to decorate\n * @param offset  the index of the first element of the decorated iterator to return\n * @param max  the maximum number of elements returned by this iterator\n * @return a new bounded iterator\n * @throws NullPointerException if the iterator is null\n * @throws IllegalArgumentException if either offset or max is negative\n * @since 4.1\n */\npublic static <E> BoundedIterator<E> boundedIterator(final Iterator<? extends E> iterator, long offset, long max) {\n    return new BoundedIterator<E>(iterator, offset, max);\n}"
            ],
            [
                "unmodifiableIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Unmodifiable\n//-----------------------------------------------------------------------\n/**\n * Gets an immutable version of an {@link Iterator}. The returned object\n * will always throw an {@link UnsupportedOperationException} for\n * the {@link Iterator#remove} method.\n *\n * @param <E> the element type\n * @param iterator  the iterator to make immutable\n * @return an immutable version of the iterator\n */\npublic static <E> Iterator<E> unmodifiableIterator(final Iterator<E> iterator) {\n    return UnmodifiableIterator.unmodifiableIterator(iterator);\n}"
            ],
            [
                "unmodifiableListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an immutable version of a {@link ListIterator}. The returned object\n * will always throw an {@link UnsupportedOperationException} for\n * the {@link Iterator#remove}, {@link ListIterator#add} and\n * {@link ListIterator#set} methods.\n *\n * @param <E> the element type\n * @param listIterator  the iterator to make immutable\n * @return an immutable version of the iterator\n */\npublic static <E> ListIterator<E> unmodifiableListIterator(final ListIterator<E> listIterator) {\n    return UnmodifiableListIterator.umodifiableListIterator(listIterator);\n}"
            ],
            [
                "unmodifiableMapIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an immutable version of a {@link MapIterator}. The returned object\n * will always throw an {@link UnsupportedOperationException} for\n * the {@link Iterator#remove}, {@link MapIterator#setValue(Object)} methods.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param mapIterator  the iterator to make immutable\n * @return an immutable version of the iterator\n */\npublic static <K, V> MapIterator<K, V> unmodifiableMapIterator(final MapIterator<K, V> mapIterator) {\n    return UnmodifiableMapIterator.unmodifiableMapIterator(mapIterator);\n}"
            ],
            [
                "chainedIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Chained\n//-----------------------------------------------------------------------\n/**\n * Gets an iterator that iterates through two {@link Iterator}s\n * one after another.\n *\n * @param <E> the element type\n * @param iterator1  the first iterator to use, not null\n * @param iterator2  the second iterator to use, not null\n * @return a combination iterator over the iterators\n * @throws NullPointerException if either iterator is null\n */\npublic static <E> Iterator<E> chainedIterator(final Iterator<? extends E> iterator1, final Iterator<? extends E> iterator2) {\n    // keep a version with two iterators to avoid the following warning in client code (Java 5 & 6)\n    // \"A generic array of E is created for a varargs parameter\"\n    return new IteratorChain<E>(iterator1, iterator2);\n}"
            ],
            [
                "chainedIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator that iterates through an array of {@link Iterator}s\n * one after another.\n *\n * @param <E> the element type\n * @param iterators  the iterators to use, not null or empty or contain nulls\n * @return a combination iterator over the iterators\n * @throws NullPointerException if iterators array is null or contains a null\n */\npublic static <E> Iterator<E> chainedIterator(final Iterator<? extends E>... iterators) {\n    return new IteratorChain<E>(iterators);\n}"
            ],
            [
                "chainedIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator that iterates through a collections of {@link Iterator}s\n * one after another.\n *\n * @param <E> the element type\n * @param iterators  the iterators to use, not null or empty or contain nulls\n * @return a combination iterator over the iterators\n * @throws NullPointerException if iterators collection is null or contains a null\n * @throws ClassCastException if the iterators collection contains the wrong object type\n */\npublic static <E> Iterator<E> chainedIterator(final Collection<Iterator<? extends E>> iterators) {\n    return new IteratorChain<E>(iterators);\n}"
            ],
            [
                "collatedIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Collated\n//-----------------------------------------------------------------------\n/**\n * Gets an iterator that provides an ordered iteration over the elements\n * contained in a collection of ordered {@link Iterator}s.\n * <p>\n * Given two ordered {@link Iterator}s <code>A</code> and <code>B</code>,\n * the {@link Iterator#next()} method will return the lesser of\n * <code>A.next()</code> and <code>B.next()</code>.\n * <p>\n * The comparator is optional. If null is specified then natural order is used.\n *\n * @param <E> the element type\n * @param comparator  the comparator to use, may be null for natural order\n * @param iterator1  the first iterators to use, not null\n * @param iterator2  the first iterators to use, not null\n * @return a combination iterator over the iterators\n * @throws NullPointerException if either iterator is null\n */\npublic static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator, final Iterator<? extends E> iterator1, final Iterator<? extends E> iterator2) {\n    @SuppressWarnings(\"unchecked\")\n    final Comparator<E> comp = comparator == null ? ComparatorUtils.NATURAL_COMPARATOR : (Comparator<E>) comparator;\n    return new CollatingIterator<E>(comp, iterator1, iterator2);\n}"
            ],
            [
                "collatedIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator that provides an ordered iteration over the elements\n * contained in an array of {@link Iterator}s.\n * <p>\n * Given two ordered {@link Iterator}s <code>A</code> and <code>B</code>,\n * the {@link Iterator#next()} method will return the lesser of\n * <code>A.next()</code> and <code>B.next()</code> and so on.\n * <p>\n * The comparator is optional. If null is specified then natural order is used.\n *\n * @param <E> the element type\n * @param comparator  the comparator to use, may be null for natural order\n * @param iterators  the iterators to use, not null or empty or contain nulls\n * @return a combination iterator over the iterators\n * @throws NullPointerException if iterators array is null or contains a null value\n */\npublic static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator, final Iterator<? extends E>... iterators) {\n    @SuppressWarnings(\"unchecked\")\n    final Comparator<E> comp = comparator == null ? ComparatorUtils.NATURAL_COMPARATOR : (Comparator<E>) comparator;\n    return new CollatingIterator<E>(comp, iterators);\n}"
            ],
            [
                "collatedIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator that provides an ordered iteration over the elements\n * contained in a collection of {@link Iterator}s.\n * <p>\n * Given two ordered {@link Iterator}s <code>A</code> and <code>B</code>,\n * the {@link Iterator#next()} method will return the lesser of\n * <code>A.next()</code> and <code>B.next()</code> and so on.\n * <p>\n * The comparator is optional. If null is specified then natural order is used.\n *\n * @param <E> the element type\n * @param comparator  the comparator to use, may be null for natural order\n * @param iterators  the iterators to use, not null or empty or contain nulls\n * @return a combination iterator over the iterators\n * @throws NullPointerException if iterators collection is null or contains a null\n * @throws ClassCastException if the iterators collection contains the wrong object type\n */\npublic static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator, final Collection<Iterator<? extends E>> iterators) {\n    @SuppressWarnings(\"unchecked\")\n    final Comparator<E> comp = comparator == null ? ComparatorUtils.NATURAL_COMPARATOR : (Comparator<E>) comparator;\n    return new CollatingIterator<E>(comp, iterators);\n}"
            ],
            [
                "objectGraphIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Object Graph\n//-----------------------------------------------------------------------\n/**\n * Gets an iterator that operates over an object graph.\n * <p>\n * This iterator can extract multiple objects from a complex tree-like object graph.\n * The iteration starts from a single root object.\n * It uses a <code>Transformer</code> to extract the iterators and elements.\n * Its main benefit is that no intermediate <code>List</code> is created.\n * <p>\n * For example, consider an object graph:\n * <pre>\n *                 |- Branch -- Leaf\n *                 |         \\- Leaf\n *         |- Tree |         /- Leaf\n *         |       |- Branch -- Leaf\n *  Forest |                 \\- Leaf\n *         |       |- Branch -- Leaf\n *         |       |         \\- Leaf\n *         |- Tree |         /- Leaf\n *                 |- Branch -- Leaf\n *                 |- Branch -- Leaf</pre>\n * The following <code>Transformer</code>, used in this class, will extract all\n * the Leaf objects without creating a combined intermediate list:\n * <pre>\n * public Object transform(Object input) {\n *   if (input instanceof Forest) {\n *     return ((Forest) input).treeIterator();\n *   }\n *   if (input instanceof Tree) {\n *     return ((Tree) input).branchIterator();\n *   }\n *   if (input instanceof Branch) {\n *     return ((Branch) input).leafIterator();\n *   }\n *   if (input instanceof Leaf) {\n *     return input;\n *   }\n *   throw new ClassCastException();\n * }</pre>\n * <p>\n * Internally, iteration starts from the root object. When next is called,\n * the transformer is called to examine the object. The transformer will return\n * either an iterator or an object. If the object is an Iterator, the next element\n * from that iterator is obtained and the process repeats. If the element is an object\n * it is returned.\n * <p>\n * Under many circumstances, linking Iterators together in this manner is\n * more efficient (and convenient) than using nested for loops to extract a list.\n *\n * @param <E> the element type\n * @param root  the root object to start iterating from, null results in an empty iterator\n * @param transformer  the transformer to use, see above, null uses no effect transformer\n * @return a new object graph iterator\n * @since 3.1\n */\npublic static <E> Iterator<E> objectGraphIterator(final E root, final Transformer<? super E, ? extends E> transformer) {\n    return new ObjectGraphIterator<E>(root, transformer);\n}"
            ],
            [
                "transformedIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Transformed\n//-----------------------------------------------------------------------\n/**\n * Gets an iterator that transforms the elements of another iterator.\n * <p>\n * The transformation occurs during the next() method and the underlying\n * iterator is unaffected by the transformation.\n *\n * @param <I> the input type\n * @param <O> the output type\n * @param iterator  the iterator to use, not null\n * @param transform  the transform to use, not null\n * @return a new transforming iterator\n * @throws NullPointerException if either parameter is null\n */\npublic static <I, O> Iterator<O> transformedIterator(final Iterator<? extends I> iterator, final Transformer<? super I, ? extends O> transform) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (transform == null) {\n        throw new NullPointerException(\"Transformer must not be null\");\n    }\n    return new TransformIterator<I, O>(iterator, transform);\n}"
            ],
            [
                "filteredIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Filtered\n//-----------------------------------------------------------------------\n/**\n * Gets an iterator that filters another iterator.\n * <p>\n * The returned iterator will only return objects that match the specified\n * filtering predicate.\n *\n * @param <E> the element type\n * @param iterator  the iterator to use, not null\n * @param predicate  the predicate to use as a filter, not null\n * @return a new filtered iterator\n * @throws NullPointerException if either parameter is null\n */\npublic static <E> Iterator<E> filteredIterator(final Iterator<? extends E> iterator, final Predicate<? super E> predicate) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    return new FilterIterator<E>(iterator, predicate);\n}"
            ],
            [
                "filteredListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a list iterator that filters another list iterator.\n * <p>\n * The returned iterator will only return objects that match the specified\n * filtering predicate.\n *\n * @param <E> the element type\n * @param listIterator  the list iterator to use, not null\n * @param predicate  the predicate to use as a filter, not null\n * @return a new filtered iterator\n * @throws NullPointerException if either parameter is null\n */\npublic static <E> ListIterator<E> filteredListIterator(final ListIterator<? extends E> listIterator, final Predicate<? super E> predicate) {\n    if (listIterator == null) {\n        throw new NullPointerException(\"ListIterator must not be null\");\n    }\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    return new FilterListIterator<E>(listIterator, predicate);\n}"
            ],
            [
                "loopingIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Looping\n//-----------------------------------------------------------------------\n/**\n * Gets an iterator that loops continuously over the supplied collection.\n * <p>\n * The iterator will only stop looping if the remove method is called\n * enough times to empty the collection, or if the collection is empty\n * to start with.\n *\n * @param <E> the element type\n * @param coll  the collection to iterate over, not null\n * @return a new looping iterator\n * @throws NullPointerException if the collection is null\n */\npublic static <E> ResettableIterator<E> loopingIterator(final Collection<? extends E> coll) {\n    if (coll == null) {\n        throw new NullPointerException(\"Collection must not be null\");\n    }\n    return new LoopingIterator<E>(coll);\n}"
            ],
            [
                "loopingListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator that loops continuously over the supplied list.\n * <p>\n * The iterator will only stop looping if the remove method is called\n * enough times to empty the list, or if the list is empty to start with.\n *\n * @param <E> the element type\n * @param list  the list to iterate over, not null\n * @return a new looping iterator\n * @throws NullPointerException if the list is null\n * @since 3.2\n */\npublic static <E> ResettableListIterator<E> loopingListIterator(final List<E> list) {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    return new LoopingListIterator<E>(list);\n}"
            ],
            [
                "nodeListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// org.w3c.dom.NodeList iterators\n//-----------------------------------------------------------------------\n/**\n * Gets an {@link Iterator} that wraps the specified {@link NodeList}.\n * The returned {@link Iterator} can be used for a single iteration.\n *\n * @param nodeList  the node list to use, may not be null\n * @return a new, single use {@link Iterator}\n * @throws NullPointerException if nodeList is null\n * @since 4.0\n */\npublic static NodeListIterator nodeListIterator(final NodeList nodeList) {\n    if (nodeList == null) {\n        throw new NullPointerException(\"NodeList must not be null\");\n    }\n    return new NodeListIterator(nodeList);\n}"
            ],
            [
                "nodeListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an {@link Iterator} that wraps the specified node's childNodes.\n * The returned {@link Iterator} can be used for a single iteration.\n * <p>\n * Convenience method, allows easy iteration over NodeLists:\n * <pre>\n *   Iterator&lt;Node&gt; iterator = IteratorUtils.nodeListIterator(node);\n *   for(Node childNode : IteratorUtils.asIterable(iterator)) {\n *     ...\n *   }\n * </pre>\n *\n * @param node  the node to use, may not be null\n * @return a new, single use {@link Iterator}\n * @throws NullPointerException if node is null\n * @since 4.0\n */\npublic static NodeListIterator nodeListIterator(final Node node) {\n    if (node == null) {\n        throw new NullPointerException(\"Node must not be null\");\n    }\n    return new NodeListIterator(node);\n}"
            ],
            [
                "peekingIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Peeking\n//-----------------------------------------------------------------------\n/**\n * Gets an iterator that supports one-element lookahead.\n *\n * @param <E> the element type\n * @param iterator  the iterator to decorate, not null\n * @return a peeking iterator\n * @throws NullPointerException if the iterator is null\n * @since 4.0\n */\npublic static <E> Iterator<E> peekingIterator(final Iterator<? extends E> iterator) {\n    return PeekingIterator.peekingIterator(iterator);\n}"
            ],
            [
                "pushbackIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Pushback\n//-----------------------------------------------------------------------\n/**\n * Gets an iterator that supports pushback of elements.\n *\n * @param <E> the element type\n * @param iterator  the iterator to decorate, not null\n * @return a pushback iterator\n * @throws NullPointerException if the iterator is null\n * @since 4.0\n */\npublic static <E> Iterator<E> pushbackIterator(final Iterator<? extends E> iterator) {\n    return PushbackIterator.pushbackIterator(iterator);\n}"
            ],
            [
                "skippingIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Skipping\n//-----------------------------------------------------------------------\n/**\n * Decorates the specified iterator to skip the first N elements.\n *\n * @param <E> the element type\n * @param iterator  the iterator to decorate\n * @param offset  the first number of elements to skip\n * @return a new skipping iterator\n * @throws NullPointerException if the iterator is null\n * @throws IllegalArgumentException if offset is negative\n * @since 4.1\n */\npublic static <E> SkippingIterator<E> skippingIterator(final Iterator<E> iterator, long offset) {\n    return new SkippingIterator<E>(iterator, offset);\n}"
            ],
            [
                "zippingIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Zipping\n//-----------------------------------------------------------------------\n/**\n * Returns an iterator that interleaves elements from the decorated iterators.\n *\n * @param <E> the element type\n * @param a  the first iterator to interleave\n * @param b  the second iterator to interleave\n * @return an iterator, interleaving the decorated iterators\n * @throws NullPointerException if any iterator is null\n * @since 4.1\n */\npublic static <E> ZippingIterator<E> zippingIterator(final Iterator<? extends E> a, final Iterator<? extends E> b) {\n    return new ZippingIterator<E>(a, b);\n}"
            ],
            [
                "zippingIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Returns an iterator that interleaves elements from the decorated iterators.\n *\n * @param <E> the element type\n * @param a  the first iterator to interleave\n * @param b  the second iterator to interleave\n * @param c  the third iterator to interleave\n * @return an iterator, interleaving the decorated iterators\n * @throws NullPointerException if any iterator is null\n * @since 4.1\n */\npublic static <E> ZippingIterator<E> zippingIterator(final Iterator<? extends E> a, final Iterator<? extends E> b, final Iterator<? extends E> c) {\n    return new ZippingIterator<E>(a, b, c);\n}"
            ],
            [
                "zippingIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Returns an iterator that interleaves elements from the decorated iterators.\n *\n * @param <E> the element type\n * @param iterators  the array of iterators to interleave\n * @return an iterator, interleaving the decorated iterators\n * @throws NullPointerException if any iterator is null\n * @since 4.1\n */\npublic static <E> ZippingIterator<E> zippingIterator(final Iterator<? extends E>... iterators) {\n    return new ZippingIterator<E>(iterators);\n}"
            ],
            [
                "asIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Views\n//-----------------------------------------------------------------------\n/**\n * Gets an iterator that provides an iterator view of the given enumeration.\n *\n * @param <E> the element type\n * @param enumeration  the enumeration to use, may not be null\n * @return a new iterator\n * @throws NullPointerException if enumeration is null\n */\npublic static <E> Iterator<E> asIterator(final Enumeration<? extends E> enumeration) {\n    if (enumeration == null) {\n        throw new NullPointerException(\"Enumeration must not be null\");\n    }\n    return new EnumerationIterator<E>(enumeration);\n}"
            ],
            [
                "asIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator that provides an iterator view of the given enumeration\n * that will remove elements from the specified collection.\n *\n * @param <E> the element type\n * @param enumeration  the enumeration to use, may not be null\n * @param removeCollection  the collection to remove elements from, may not be null\n * @return a new iterator\n * @throws NullPointerException if enumeration or removeCollection is null\n */\npublic static <E> Iterator<E> asIterator(final Enumeration<? extends E> enumeration, final Collection<? super E> removeCollection) {\n    if (enumeration == null) {\n        throw new NullPointerException(\"Enumeration must not be null\");\n    }\n    if (removeCollection == null) {\n        throw new NullPointerException(\"Collection must not be null\");\n    }\n    return new EnumerationIterator<E>(enumeration, removeCollection);\n}"
            ],
            [
                "asEnumeration",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an enumeration that wraps an iterator.\n *\n * @param <E> the element type\n * @param iterator  the iterator to use, may not be null\n * @return a new enumeration\n * @throws NullPointerException if iterator is null\n */\npublic static <E> Enumeration<E> asEnumeration(final Iterator<? extends E> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorEnumeration<E>(iterator);\n}"
            ],
            [
                "asIterable",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an {@link Iterable} that wraps an iterator.  The returned {@link Iterable} can be\n * used for a single iteration.\n *\n * @param <E> the element type\n * @param iterator  the iterator to use, may not be null\n * @return a new, single use {@link Iterable}\n * @throws NullPointerException if iterator is null\n */\npublic static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}"
            ],
            [
                "asMultipleUseIterable",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterable that wraps an iterator.  The returned iterable can be\n * used for multiple iterations.\n *\n * @param <E> the element type\n * @param iterator  the iterator to use, may not be null\n * @return a new, multiple use iterable\n * @throws NullPointerException if iterator is null\n */\npublic static <E> Iterable<E> asMultipleUseIterable(final Iterator<? extends E> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, true);\n}"
            ],
            [
                "toListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a list iterator based on a simple iterator.\n * <p>\n * As the wrapped Iterator is traversed, a LinkedList of its values is\n * cached, permitting all required operations of ListIterator.\n *\n * @param <E> the element type\n * @param iterator  the iterator to use, may not be null\n * @return a new iterator\n * @throws NullPointerException if iterator parameter is null\n */\npublic static <E> ListIterator<E> toListIterator(final Iterator<? extends E> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new ListIteratorWrapper<E>(iterator);\n}"
            ],
            [
                "toArray",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an array based on an iterator.\n * <p>\n * As the wrapped Iterator is traversed, an ArrayList of its values is\n * created. At the end, this is converted to an array.\n *\n * @param iterator  the iterator to use, not null\n * @return an array of the iterator contents\n * @throws NullPointerException if iterator parameter is null\n */\npublic static Object[] toArray(final Iterator<?> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    final List<?> list = toList(iterator, 100);\n    return list.toArray();\n}"
            ],
            [
                "toArray",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an array based on an iterator.\n * <p>\n * As the wrapped Iterator is traversed, an ArrayList of its values is\n * created. At the end, this is converted to an array.\n *\n * @param <E> the element type\n * @param iterator  the iterator to use, not null\n * @param arrayClass  the class of array to create\n * @return an array of the iterator contents\n * @throws NullPointerException if iterator parameter or arrayClass is null\n * @throws ArrayStoreException if the arrayClass is invalid\n */\npublic static <E> E[] toArray(final Iterator<? extends E> iterator, final Class<E> arrayClass) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (arrayClass == null) {\n        throw new NullPointerException(\"Array class must not be null\");\n    }\n    final List<E> list = toList(iterator, 100);\n    @SuppressWarnings(\"unchecked\")\n    final E[] array = (E[]) Array.newInstance(arrayClass, list.size());\n    return list.toArray(array);\n}"
            ],
            [
                "toList",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a list based on an iterator.\n * <p>\n * As the wrapped Iterator is traversed, an ArrayList of its values is\n * created. At the end, the list is returned.\n *\n * @param <E> the element type\n * @param iterator  the iterator to use, not null\n * @return a list of the iterator contents\n * @throws NullPointerException if iterator parameter is null\n */\npublic static <E> List<E> toList(final Iterator<? extends E> iterator) {\n    return toList(iterator, 10);\n}"
            ],
            [
                "toList",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a list based on an iterator.\n * <p>\n * As the wrapped Iterator is traversed, an ArrayList of its values is\n * created. At the end, the list is returned.\n *\n * @param <E> the element type\n * @param iterator  the iterator to use, not null\n * @param estimatedSize  the initial size of the ArrayList\n * @return a list of the iterator contents\n * @throws NullPointerException if iterator parameter is null\n * @throws IllegalArgumentException if the size is less than 1\n */\npublic static <E> List<E> toList(final Iterator<? extends E> iterator, final int estimatedSize) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (estimatedSize < 1) {\n        throw new IllegalArgumentException(\"Estimated size must be greater than 0\");\n    }\n    final List<E> list = new ArrayList<E>(estimatedSize);\n    while (iterator.hasNext()) {\n        list.add(iterator.next());\n    }\n    return list;\n}"
            ],
            [
                "getIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a suitable Iterator for the given object.\n * <p>\n * This method can handle objects as follows\n * <ul>\n * <li>null - empty iterator\n * <li>Iterator - returned directly\n * <li>Enumeration - wrapped\n * <li>Collection - iterator from collection returned\n * <li>Map - values iterator returned\n * <li>Dictionary - values (elements) enumeration returned as iterator\n * <li>array - iterator over array returned\n * <li>object with iterator() public method accessed by reflection\n * <li>object - singleton iterator\n * <li>NodeList - iterator over the list\n * <li>Node - iterator over the child nodes\n * </ul>\n *\n * @param obj  the object to convert to an iterator\n * @return a suitable iterator, never null\n */\npublic static Iterator<?> getIterator(final Object obj) {\n    if (obj == null) {\n        return emptyIterator();\n    }\n    if (obj instanceof Iterator) {\n        return (Iterator<?>) obj;\n    }\n    if (obj instanceof Iterable) {\n        return ((Iterable<?>) obj).iterator();\n    }\n    if (obj instanceof Object[]) {\n        return new ObjectArrayIterator<Object>((Object[]) obj);\n    }\n    if (obj instanceof Enumeration) {\n        return new EnumerationIterator<Object>((Enumeration<?>) obj);\n    }\n    if (obj instanceof Map) {\n        return ((Map<?, ?>) obj).values().iterator();\n    }\n    if (obj instanceof NodeList) {\n        return new NodeListIterator((NodeList) obj);\n    }\n    if (obj instanceof Node) {\n        return new NodeListIterator((Node) obj);\n    }\n    if (obj instanceof Dictionary) {\n        return new EnumerationIterator<Object>(((Dictionary<?, ?>) obj).elements());\n    } else if (obj.getClass().isArray()) {\n        return new ArrayIterator<Object>(obj);\n    }\n    try {\n        final Method method = obj.getClass().getMethod(\"iterator\", (Class[]) null);\n        if (Iterator.class.isAssignableFrom(method.getReturnType())) {\n            final Iterator<?> it = (Iterator<?>) method.invoke(obj, (Object[]) null);\n            if (it != null) {\n                return it;\n            }\n        }\n    } catch (final RuntimeException e) {\n        // NOPMD\n        // ignore\n    } catch (final NoSuchMethodException e) {\n        // NOPMD\n        // ignore\n    } catch (final IllegalAccessException e) {\n        // NOPMD\n        // ignore\n    } catch (final InvocationTargetException e) {\n        // NOPMD\n        // ignore\n    }\n    return singletonIterator(obj);\n}"
            ],
            [
                "forEachButLast",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Executes the given closure on each but the last element in the iterator.\n * <p>\n * If the input iterator is null no change is made.\n *\n * @param <E> the type of object the {@link Iterator} contains\n * @param iterator  the iterator to get the input from, may be null\n * @param closure  the closure to perform, may not be null\n * @return the last element in the iterator, or null if iterator is null or empty\n * @throws NullPointerException if closure is null\n * @since 4.1\n */\npublic static <E> E forEachButLast(final Iterator<E> iterator, final Closure<? super E> closure) {\n    if (closure == null) {\n        throw new NullPointerException(\"Closure must not be null.\");\n    }\n    if (iterator != null) {\n        while (iterator.hasNext()) {\n            final E element = iterator.next();\n            if (iterator.hasNext()) {\n                closure.execute(element);\n            } else {\n                return element;\n            }\n        }\n    }\n    return null;\n}"
            ],
            [
                "find",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Finds the first element in the given iterator which matches the given predicate.\n * <p>\n * A <code>null</code> or empty iterator returns null.\n *\n * @param <E> the element type\n * @param iterator  the iterator to search, may be null\n * @param predicate  the predicate to use, may not be null\n * @return the first element of the iterator which matches the predicate or null if none could be found\n * @throws NullPointerException if predicate is null\n * @since 4.1\n */\npublic static <E> E find(final Iterator<E> iterator, final Predicate<? super E> predicate) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    if (iterator != null) {\n        while (iterator.hasNext()) {\n            final E element = iterator.next();\n            if (predicate.evaluate(element)) {\n                return element;\n            }\n        }\n    }\n    return null;\n}"
            ],
            [
                "indexOf",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Returns the index of the first element in the specified iterator that\n * matches the given predicate.\n * <p>\n * A <code>null</code> or empty iterator returns -1.\n *\n * @param <E> the element type\n * @param iterator  the iterator to search, may be null\n * @param predicate  the predicate to use, may not be null\n * @return the index of the first element which matches the predicate or -1 if none matches\n * @throws NullPointerException if predicate is null\n * @since 4.1\n */\npublic static <E> int indexOf(final Iterator<E> iterator, final Predicate<? super E> predicate) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    if (iterator != null) {\n        for (int index = 0; iterator.hasNext(); index++) {\n            final E element = iterator.next();\n            if (predicate.evaluate(element)) {\n                return index;\n            }\n        }\n    }\n    return -1;\n}"
            ],
            [
                "matchesAny",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Answers true if a predicate is true for any element of the iterator.\n * <p>\n * A <code>null</code> or empty iterator returns false.\n *\n * @param <E> the type of object the {@link Iterator} contains\n * @param iterator  the {@link Iterator} to use, may be null\n * @param predicate  the predicate to use, may not be null\n * @return true if any element of the collection matches the predicate, false otherwise\n * @throws NullPointerException if predicate is null\n * @since 4.1\n */\npublic static <E> boolean matchesAny(final Iterator<E> iterator, final Predicate<? super E> predicate) {\n    return indexOf(iterator, predicate) != -1;\n}"
            ],
            [
                "matchesAll",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Answers true if a predicate is true for every element of an iterator.\n * <p>\n * A <code>null</code> or empty iterator returns true.\n *\n * @param <E> the type of object the {@link Iterator} contains\n * @param iterator  the {@link Iterator} to use, may be null\n * @param predicate  the predicate to use, may not be null\n * @return true if every element of the collection matches the predicate or if the\n *   collection is empty, false otherwise\n * @throws NullPointerException if predicate is null\n * @since 4.1\n */\npublic static <E> boolean matchesAll(final Iterator<E> iterator, final Predicate<? super E> predicate) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    if (iterator != null) {\n        while (iterator.hasNext()) {\n            final E element = iterator.next();\n            if (!predicate.evaluate(element)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
            ],
            [
                "isEmpty",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Checks if the given iterator is empty.\n * <p>\n * A <code>null</code> or empty iterator returns true.\n *\n * @param iterator  the {@link Iterator} to use, may be null\n * @return true if the iterator is exhausted or null, false otherwise\n * @since 4.1\n */\npublic static boolean isEmpty(final Iterator<?> iterator) {\n    return iterator == null || !iterator.hasNext();\n}"
            ],
            [
                "contains",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Checks if the object is contained in the given iterator.\n * <p>\n * A <code>null</code> or empty iterator returns false.\n *\n * @param <E> the type of object the {@link Iterator} contains\n * @param iterator  the iterator to check, may be null\n * @param object  the object to check\n * @return true if the object is contained in the iterator, false otherwise\n * @since 4.1\n */\npublic static <E> boolean contains(final Iterator<E> iterator, final Object object) {\n    return matchesAny(iterator, EqualPredicate.equalPredicate(object));\n}"
            ],
            [
                "get",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Returns the <code>index</code>-th value in {@link Iterator}, throwing\n * <code>IndexOutOfBoundsException</code> if there is no such element.\n * <p>\n * The Iterator is advanced to <code>index</code> (or to the end, if\n * <code>index</code> exceeds the number of entries) as a side effect of this method.\n *\n * @param <E> the type of object in the {@link Iterator}\n * @param iterator  the iterator to get a value from\n * @param index  the index to get\n * @return the object at the specified index\n * @throws IndexOutOfBoundsException if the index is invalid\n * @since 4.1\n */\npublic static <E> E get(final Iterator<E> iterator, final int index) {\n    int i = index;\n    CollectionUtils.checkIndexBounds(i);\n    while (iterator.hasNext()) {\n        i--;\n        if (i == -1) {\n            return iterator.next();\n        }\n        iterator.next();\n    }\n    throw new IndexOutOfBoundsException(\"Entry does not exist: \" + i);\n}"
            ],
            [
                "size",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Returns the number of elements contained in the given iterator.\n * <p>\n * A <code>null</code> or empty iterator returns {@code 0}.\n *\n * @param iterator  the iterator to check, may be null\n * @return the number of elements contained in the iterator\n * @since 4.1\n */\npublic static int size(final Iterator<?> iterator) {\n    int size = 0;\n    if (iterator != null) {\n        while (iterator.hasNext()) {\n            iterator.next();\n            size++;\n        }\n    }\n    return size;\n}"
            ],
            [
                "toString",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Returns a string representation of the elements of the specified iterator.\n * <p>\n * The string representation consists of a list of the iterator's elements,\n * enclosed in square brackets ({@code \"[]\"}). Adjacent elements are separated\n * by the characters {@code \", \"} (a comma followed by a space). Elements are\n * converted to strings as by {@code String.valueOf(Object)}.\n *\n * @param <E> the element type\n * @param iterator  the iterator to convert to a string, may be null\n * @return a string representation of {@code iterator}\n * @since 4.1\n */\npublic static <E> String toString(final Iterator<E> iterator) {\n    return toString(iterator, TransformerUtils.stringValueTransformer(), DEFAULT_TOSTRING_DELIMITER, DEFAULT_TOSTRING_PREFIX, DEFAULT_TOSTRING_SUFFIX);\n}"
            ],
            [
                "toString",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Returns a string representation of the elements of the specified iterator.\n * <p>\n * The string representation consists of a list of the iterable's elements,\n * enclosed in square brackets ({@code \"[]\"}). Adjacent elements are separated\n * by the characters {@code \", \"} (a comma followed by a space). Elements are\n * converted to strings as by using the provided {@code transformer}.\n *\n * @param <E> the element type\n * @param iterator  the iterator to convert to a string, may be null\n * @param transformer  the transformer used to get a string representation of an element\n * @return a string representation of {@code iterator}\n * @throws NullPointerException if {@code transformer} is null\n * @since 4.1\n */\npublic static <E> String toString(final Iterator<E> iterator, final Transformer<? super E, String> transformer) {\n    return toString(iterator, transformer, DEFAULT_TOSTRING_DELIMITER, DEFAULT_TOSTRING_PREFIX, DEFAULT_TOSTRING_SUFFIX);\n}"
            ],
            [
                "toString",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Returns a string representation of the elements of the specified iterator.\n * <p>\n * The string representation consists of a list of the iterator's elements,\n * enclosed by the provided {@code prefix} and {@code suffix}. Adjacent elements\n * are separated by the provided {@code delimiter}. Elements are converted to\n * strings as by using the provided {@code transformer}.\n *\n * @param <E> the element type\n * @param iterator  the iterator to convert to a string, may be null\n * @param transformer  the transformer used to get a string representation of an element\n * @param delimiter  the string to delimit elements\n * @param prefix  the prefix, prepended to the string representation\n * @param suffix  the suffix, appended to the string representation\n * @return a string representation of {@code iterator}\n * @throws NullPointerException if either transformer, delimiter, prefix or suffix is null\n * @since 4.1\n */\npublic static <E> String toString(final Iterator<E> iterator, final Transformer<? super E, String> transformer, final String delimiter, final String prefix, final String suffix) {\n    if (transformer == null) {\n        throw new NullPointerException(\"transformer may not be null\");\n    }\n    if (delimiter == null) {\n        throw new NullPointerException(\"delimiter may not be null\");\n    }\n    if (prefix == null) {\n        throw new NullPointerException(\"prefix may not be null\");\n    }\n    if (suffix == null) {\n        throw new NullPointerException(\"suffix may not be null\");\n    }\n    final StringBuilder stringBuilder = new StringBuilder(prefix);\n    if (iterator != null) {\n        while (iterator.hasNext()) {\n            final E element = iterator.next();\n            stringBuilder.append(transformer.transform(element));\n            stringBuilder.append(delimiter);\n        }\n        if (stringBuilder.length() > prefix.length()) {\n            stringBuilder.setLength(stringBuilder.length() - delimiter.length());\n        }\n    }\n    stringBuilder.append(suffix);\n    return stringBuilder.toString();\n}"
            ],
            [
                "naturalComparator",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Gets a comparator that uses the natural order of the objects.\n *\n * @param <E>  the object type to compare\n * @return  a comparator which uses natural order\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E extends Comparable<? super E>> Comparator<E> naturalComparator() {\n    return NATURAL_COMPARATOR;\n}"
            ],
            [
                "chainedComparator",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Gets a comparator that compares using an array of {@link Comparator}s, applied\n * in sequence until one returns not equal or the array is exhausted.\n *\n * @param <E>  the object type to compare\n * @param comparators  the comparators to use, not null or empty or containing nulls\n * @return a {@link ComparatorChain} formed from the input comparators\n * @throws NullPointerException if comparators array is null or contains a null\n * @see ComparatorChain\n */\npublic static <E> Comparator<E> chainedComparator(final Comparator<E>... comparators) {\n    final ComparatorChain<E> chain = new ComparatorChain<E>();\n    for (final Comparator<E> comparator : comparators) {\n        if (comparator == null) {\n            throw new NullPointerException(\"Comparator cannot be null\");\n        }\n        chain.addComparator(comparator);\n    }\n    return chain;\n}"
            ],
            [
                "chainedComparator",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Gets a comparator that compares using a collection of {@link Comparator}s,\n * applied in (default iterator) sequence until one returns not equal or the\n * collection is exhausted.\n *\n * @param <E>  the object type to compare\n * @param comparators  the comparators to use, not null or empty or containing nulls\n * @return a {@link ComparatorChain} formed from the input comparators\n * @throws NullPointerException if comparators collection is null or contains a null\n * @throws ClassCastException if the comparators collection contains the wrong object type\n * @see ComparatorChain\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Comparator<E> chainedComparator(final Collection<Comparator<E>> comparators) {\n    return chainedComparator((Comparator<E>[]) comparators.toArray(new Comparator[comparators.size()]));\n}"
            ],
            [
                "reversedComparator",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Gets a comparator that reverses the order of the given comparator.\n *\n * @param <E>  the object type to compare\n * @param comparator  the comparator to reverse\n * @return  a comparator that reverses the order of the input comparator\n * @see ReverseComparator\n */\npublic static <E> Comparator<E> reversedComparator(final Comparator<E> comparator) {\n    return new ReverseComparator<E>(comparator);\n}"
            ],
            [
                "booleanComparator",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Gets a Comparator that can sort Boolean objects.\n * <p>\n * The parameter specifies whether true or false is sorted first.\n * <p>\n * The comparator throws NullPointerException if a null value is compared.\n *\n * @param trueFirst  when <code>true</code>, sort\n *        <code>true</code> {@link Boolean}s before\n *        <code>false</code> {@link Boolean}s.\n * @return  a comparator that sorts booleans\n */\npublic static Comparator<Boolean> booleanComparator(final boolean trueFirst) {\n    return BooleanComparator.booleanComparator(trueFirst);\n}"
            ],
            [
                "nullLowComparator",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Gets a Comparator that controls the comparison of <code>null</code> values.\n * <p>\n * The returned comparator will consider a null value to be less than\n * any nonnull value, and equal to any other null value.  Two nonnull\n * values will be evaluated with the given comparator.\n *\n * @param <E>  the object type to compare\n * @param comparator the comparator that wants to allow nulls\n * @return  a version of that comparator that allows nulls\n * @see NullComparator\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Comparator<E> nullLowComparator(Comparator<E> comparator) {\n    if (comparator == null) {\n        comparator = NATURAL_COMPARATOR;\n    }\n    return new NullComparator<E>(comparator, false);\n}"
            ],
            [
                "nullHighComparator",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Gets a Comparator that controls the comparison of <code>null</code> values.\n * <p>\n * The returned comparator will consider a null value to be greater than\n * any nonnull value, and equal to any other null value.  Two nonnull\n * values will be evaluated with the given comparator.\n *\n * @param <E>  the object type to compare\n * @param comparator the comparator that wants to allow nulls\n * @return  a version of that comparator that allows nulls\n * @see NullComparator\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Comparator<E> nullHighComparator(Comparator<E> comparator) {\n    if (comparator == null) {\n        comparator = NATURAL_COMPARATOR;\n    }\n    return new NullComparator<E>(comparator, true);\n}"
            ],
            [
                "transformedComparator",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Gets a Comparator that passes transformed objects to the given comparator.\n * <p>\n * Objects passed to the returned comparator will first be transformed\n * by the given transformer before they are compared by the given\n * comparator.\n *\n * @param <I>  the input object type of the transformed comparator\n * @param <O>  the object type of the decorated comparator\n * @param comparator  the sort order to use\n * @param transformer  the transformer to use\n * @return  a comparator that transforms its input objects before comparing them\n * @see  TransformingComparator\n */\n@SuppressWarnings(\"unchecked\")\npublic static <I, O> Comparator<I> transformedComparator(Comparator<O> comparator, final Transformer<? super I, ? extends O> transformer) {\n    if (comparator == null) {\n        comparator = NATURAL_COMPARATOR;\n    }\n    return new TransformingComparator<I, O>(transformer, comparator);\n}"
            ],
            [
                "min",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Returns the smaller of the given objects according to the given\n * comparator, returning the second object if the comparator\n * returns equal.\n *\n * @param <E>  the object type to compare\n * @param o1  the first object to compare\n * @param o2  the second object to compare\n * @param comparator  the sort order to use\n * @return  the smaller of the two objects\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> E min(final E o1, final E o2, Comparator<E> comparator) {\n    if (comparator == null) {\n        comparator = NATURAL_COMPARATOR;\n    }\n    final int c = comparator.compare(o1, o2);\n    return c < 0 ? o1 : o2;\n}"
            ],
            [
                "max",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Returns the larger of the given objects according to the given\n * comparator, returning the second object if the comparator\n * returns equal.\n *\n * @param <E>  the object type to compare\n * @param o1  the first object to compare\n * @param o2  the second object to compare\n * @param comparator  the sort order to use\n * @return  the larger of the two objects\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> E max(final E o1, final E o2, Comparator<E> comparator) {\n    if (comparator == null) {\n        comparator = NATURAL_COMPARATOR;\n    }\n    final int c = comparator.compare(o1, o2);\n    return c > 0 ? o1 : o2;\n}"
            ],
            [
                "unmodifiableBidiMap",
                "org.apache.commons.collections4.bidimap",
                "UnmodifiableBidiMap",
                "/**\n * Factory method to create an unmodifiable map.\n * <p>\n * If the map passed in is already unmodifiable, it is returned.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the map to decorate, must not be null\n * @return an unmodifiable BidiMap\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> BidiMap<K, V> unmodifiableBidiMap(final BidiMap<? extends K, ? extends V> map) {\n    if (map instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final BidiMap<K, V> tmpMap = (BidiMap<K, V>) map;\n        return tmpMap;\n    }\n    return new UnmodifiableBidiMap<K, V>(map);\n}"
            ],
            [
                "unmodifiableOrderedBidiMap",
                "org.apache.commons.collections4.bidimap",
                "UnmodifiableOrderedBidiMap",
                "/**\n * Factory method to create an unmodifiable map.\n * <p>\n * If the map passed in is already unmodifiable, it is returned.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the map to decorate, must not be null\n * @return an unmodifiable OrderedBidiMap\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> OrderedBidiMap<K, V> unmodifiableOrderedBidiMap(final OrderedBidiMap<? extends K, ? extends V> map) {\n    if (map instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final OrderedBidiMap<K, V> tmpMap = (OrderedBidiMap<K, V>) map;\n        return tmpMap;\n    }\n    return new UnmodifiableOrderedBidiMap<K, V>(map);\n}"
            ],
            [
                "unmodifiableSortedBidiMap",
                "org.apache.commons.collections4.bidimap",
                "UnmodifiableSortedBidiMap",
                "/**\n * Factory method to create an unmodifiable map.\n * <p>\n * If the map passed in is already unmodifiable, it is returned.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the map to decorate, must not be null\n * @return an unmodifiable SortedBidiMap\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> SortedBidiMap<K, V> unmodifiableSortedBidiMap(final SortedBidiMap<K, ? extends V> map) {\n    if (map instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final SortedBidiMap<K, V> tmpMap = (SortedBidiMap<K, V>) map;\n        return tmpMap;\n    }\n    return new UnmodifiableSortedBidiMap<K, V>(map);\n}"
            ],
            [
                "emptyMultiValuedMap",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "/**\n * Returns immutable EMPTY_MULTI_VALUED_MAP with generic type safety.\n *\n * @param <K> the type of key in the map\n * @param <V> the type of value in the map\n * @return immutable and empty <code>MultiValuedMap</code>\n */\n@SuppressWarnings(\"unchecked\")\npublic static <K, V> MultiValuedMap<K, V> emptyMultiValuedMap() {\n    return EMPTY_MULTI_VALUED_MAP;\n}"
            ],
            [
                "emptyIfNull",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "// Null safe methods\n/**\n * Returns an immutable empty <code>MultiValuedMap</code> if the argument is\n * <code>null</code>, or the argument itself otherwise.\n *\n * @param <K> the type of key in the map\n * @param <V> the type of value in the map\n * @param map  the map, may be null\n * @return an empty {@link MultiValuedMap} if the argument is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <K, V> MultiValuedMap<K, V> emptyIfNull(final MultiValuedMap<K, V> map) {\n    return map == null ? EMPTY_MULTI_VALUED_MAP : map;\n}"
            ],
            [
                "isEmpty",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "/**\n * Null-safe check if the specified <code>MultiValuedMap</code> is empty.\n * <p>\n * If the provided map is null, returns true.\n *\n * @param map  the map to check, may be null\n * @return true if the map is empty or null\n */\npublic static boolean isEmpty(final MultiValuedMap<?, ?> map) {\n    return map == null || map.isEmpty();\n}"
            ],
            [
                "getCollection",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "// Null safe getters\n// -------------------------------------------------------------------------\n/**\n * Gets a Collection from <code>MultiValuedMap</code> in a null-safe manner.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the {@link MultiValuedMap} to use\n * @param key  the key to look up\n * @return the Collection in the {@link MultiValuedMap}, or null if input map is null\n */\npublic static <K, V> Collection<V> getCollection(final MultiValuedMap<K, V> map, final K key) {\n    if (map != null) {\n        return map.get(key);\n    }\n    return null;\n}"
            ],
            [
                "getValuesAsList",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "// TODO: review the getValuesAsXXX methods - depending on the actual MultiValuedMap type, changes\n// to the returned collection might update the backing map. This should be clarified and/or prevented.\n/**\n * Gets a List from <code>MultiValuedMap</code> in a null-safe manner.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the {@link MultiValuedMap} to use\n * @param key  the key to look up\n * @return the Collection in the {@link MultiValuedMap} as List, or null if input map is null\n */\npublic static <K, V> List<V> getValuesAsList(final MultiValuedMap<K, V> map, final K key) {\n    if (map != null) {\n        Collection<V> col = map.get(key);\n        if (col instanceof List) {\n            return (List<V>) col;\n        }\n        return new ArrayList<V>(col);\n    }\n    return null;\n}"
            ],
            [
                "getValuesAsSet",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "/**\n * Gets a Set from <code>MultiValuedMap</code> in a null-safe manner.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the {@link MultiValuedMap} to use\n * @param key  the key to look up\n * @return the Collection in the {@link MultiValuedMap} as Set, or null if input map is null\n */\npublic static <K, V> Set<V> getValuesAsSet(final MultiValuedMap<K, V> map, final K key) {\n    if (map != null) {\n        Collection<V> col = map.get(key);\n        if (col instanceof Set) {\n            return (Set<V>) col;\n        }\n        return new HashSet<V>(col);\n    }\n    return null;\n}"
            ],
            [
                "getValuesAsBag",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "/**\n * Gets a Bag from <code>MultiValuedMap</code> in a null-safe manner.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the {@link MultiValuedMap} to use\n * @param key  the key to look up\n * @return the Collection in the {@link MultiValuedMap} as Bag, or null if input map is null\n */\npublic static <K, V> Bag<V> getValuesAsBag(final MultiValuedMap<K, V> map, final K key) {\n    if (map != null) {\n        Collection<V> col = map.get(key);\n        if (col instanceof Bag) {\n            return (Bag<V>) col;\n        }\n        return new HashBag<V>(col);\n    }\n    return null;\n}"
            ],
            [
                "newListValuedHashMap",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "// Factory Methods\n// -----------------------------------------------------------------------\n/**\n * Creates a {@link ListValuedMap} with an {@link java.util.ArrayList ArrayList} as\n * collection class to store the values mapped to a key.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @return a new <code>ListValuedMap</code>\n */\npublic static <K, V> ListValuedMap<K, V> newListValuedHashMap() {\n    return new ArrayListValuedHashMap<K, V>();\n}"
            ],
            [
                "newSetValuedHashMap",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "/**\n * Creates a {@link SetValuedMap} with an {@link java.util.HashSet HashSet} as\n * collection class to store the values mapped to a key.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @return a new {@link SetValuedMap}\n */\npublic static <K, V> SetValuedMap<K, V> newSetValuedHashMap() {\n    return new HashSetValuedHashMap<K, V>();\n}"
            ],
            [
                "unmodifiableMultiValuedMap",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "// MultiValuedMap Decorators\n// -----------------------------------------------------------------------\n/**\n * Returns an <code>UnmodifiableMultiValuedMap</code> backed by the given\n * map.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the {@link MultiValuedMap} to decorate, must not be null\n * @return an unmodifiable {@link MultiValuedMap} backed by the provided map\n * @throws NullPointerException if map is null\n */\npublic static <K, V> MultiValuedMap<K, V> unmodifiableMultiValuedMap(final MultiValuedMap<? extends K, ? extends V> map) {\n    return UnmodifiableMultiValuedMap.<K, V>unmodifiableMultiValuedMap(map);\n}"
            ],
            [
                "transformedMultiValuedMap",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "/**\n * Returns a <code>TransformedMultiValuedMap</code> backed by the given map.\n * <p>\n * This method returns a new <code>MultiValuedMap</code> (decorating the\n * specified map) that will transform any new entries added to it. Existing\n * entries in the specified map will not be transformed. If you want that\n * behaviour, see {@link TransformedMultiValuedMap#transformedMap}.\n * <p>\n * Each object is passed through the transformers as it is added to the Map.\n * It is important not to use the original map after invoking this method,\n * as it is a back door for adding untransformed objects.\n * <p>\n * If there are any elements already in the map being decorated, they are\n * NOT transformed.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the {@link MultiValuedMap} to transform, must not be null, typically empty\n * @param keyTransformer  the transformer for the map keys, null means no transformation\n * @param valueTransformer  the transformer for the map values, null means no transformation\n * @return a transformed <code>MultiValuedMap</code> backed by the given map\n * @throws NullPointerException if map is null\n */\npublic static <K, V> MultiValuedMap<K, V> transformedMultiValuedMap(final MultiValuedMap<K, V> map, final Transformer<? super K, ? extends K> keyTransformer, final Transformer<? super V, ? extends V> valueTransformer) {\n    return TransformedMultiValuedMap.transformingMap(map, keyTransformer, valueTransformer);\n}"
            ],
            [
                "unmodifiableBoundedCollection",
                "org.apache.commons.collections4.collection",
                "UnmodifiableBoundedCollection",
                "/**\n * Factory method to create an unmodifiable bounded collection.\n *\n * @param <E> the type of the elements in the collection\n * @param coll  the <code>BoundedCollection</code> to decorate, must not be null\n * @return a new unmodifiable bounded collection\n * @throws NullPointerException if {@code coll} is {@code null}\n * @since 4.0\n */\npublic static <E> BoundedCollection<E> unmodifiableBoundedCollection(final BoundedCollection<? extends E> coll) {\n    if (coll instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final BoundedCollection<E> tmpColl = (BoundedCollection<E>) coll;\n        return tmpColl;\n    }\n    return new UnmodifiableBoundedCollection<E>(coll);\n}"
            ],
            [
                "unmodifiableBoundedCollection",
                "org.apache.commons.collections4.collection",
                "UnmodifiableBoundedCollection",
                "/**\n * Factory method to create an unmodifiable bounded collection.\n * <p>\n * This method is capable of drilling down through up to 1000 other decorators\n * to find a suitable BoundedCollection.\n *\n * @param <E> the type of the elements in the collection\n * @param coll  the <code>BoundedCollection</code> to decorate, must not be null\n * @return a new unmodifiable bounded collection\n * @throws NullPointerException if coll is null\n * @throws IllegalArgumentException if coll is not a {@code BoundedCollection}\n * @since 4.0\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> BoundedCollection<E> unmodifiableBoundedCollection(Collection<? extends E> coll) {\n    if (coll == null) {\n        throw new NullPointerException(\"Collection must not be null.\");\n    }\n    // handle decorators\n    for (int i = 0; i < 1000; i++) {\n        // counter to prevent infinite looping\n        if (coll instanceof BoundedCollection) {\n            // normal loop exit\n            break;\n        }\n        if (coll instanceof AbstractCollectionDecorator) {\n            coll = ((AbstractCollectionDecorator<E>) coll).decorated();\n        } else if (coll instanceof SynchronizedCollection) {\n            coll = ((SynchronizedCollection<E>) coll).decorated();\n        }\n    }\n    if (coll instanceof BoundedCollection == false) {\n        throw new IllegalArgumentException(\"Collection is not a bounded collection.\");\n    }\n    return new UnmodifiableBoundedCollection<E>((BoundedCollection<E>) coll);\n}"
            ],
            [
                "transformingCollection",
                "org.apache.commons.collections4.collection",
                "TransformedCollection",
                "/**\n * Factory method to create a transforming collection.\n * <p>\n * If there are any elements already in the collection being decorated, they\n * are NOT transformed.\n * Contrast this with {@link #transformedCollection(Collection, Transformer)}.\n *\n * @param <E> the type of the elements in the collection\n * @param coll  the collection to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed collection\n * @throws NullPointerException if collection or transformer is null\n * @since 4.0\n */\npublic static <E> TransformedCollection<E> transformingCollection(final Collection<E> coll, final Transformer<? super E, ? extends E> transformer) {\n    return new TransformedCollection<E>(coll, transformer);\n}"
            ],
            [
                "transformedCollection",
                "org.apache.commons.collections4.collection",
                "TransformedCollection",
                "/**\n * Factory method to create a transforming collection that will transform\n * existing contents of the specified collection.\n * <p>\n * If there are any elements already in the collection being decorated, they\n * will be transformed by this method.\n * Contrast this with {@link #transformingCollection(Collection, Transformer)}.\n *\n * @param <E> the type of the elements in the collection\n * @param collection  the collection to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed Collection\n * @throws NullPointerException if collection or transformer is null\n * @since 4.0\n */\npublic static <E> TransformedCollection<E> transformedCollection(final Collection<E> collection, final Transformer<? super E, ? extends E> transformer) {\n    final TransformedCollection<E> decorated = new TransformedCollection<E>(collection, transformer);\n    // null collection & transformer are disallowed by the constructor call above\n    if (collection.size() > 0) {\n        // collection is of type E\n        @SuppressWarnings(\"unchecked\")\n        final E[] // NOPMD - false positive for generics\n        values = (E[]) collection.toArray();\n        collection.clear();\n        for (final E value : values) {\n            decorated.decorated().add(transformer.transform(value));\n        }\n    }\n    return decorated;\n}"
            ],
            [
                "builder",
                "org.apache.commons.collections4.collection",
                "PredicatedCollection",
                "/**\n * Returns a Builder with the given predicate.\n *\n * @param <E>  the element type\n * @param predicate  the predicate to use\n * @return a new Builder for predicated collections\n * @since 4.1\n */\npublic static <E> Builder<E> builder(final Predicate<? super E> predicate) {\n    return new Builder<E>(predicate);\n}"
            ],
            [
                "notNullBuilder",
                "org.apache.commons.collections4.collection",
                "PredicatedCollection",
                "/**\n * Returns a Builder with a NotNullPredicate.\n *\n * @param <E>  the element type\n * @return a new Builder for predicated collections that ignores null values.\n * @since 4.1\n */\npublic static <E> Builder<E> notNullBuilder() {\n    return new Builder<E>(NotNullPredicate.<E>notNullPredicate());\n}"
            ],
            [
                "predicatedCollection",
                "org.apache.commons.collections4.collection",
                "PredicatedCollection",
                "/**\n * Factory method to create a predicated (validating) collection.\n * <p>\n * If there are any elements already in the collection being decorated, they\n * are validated.\n *\n * @param <T> the type of the elements in the collection\n * @param coll  the collection to decorate, must not be null\n * @param predicate  the predicate to use for validation, must not be null\n * @return a new predicated collection\n * @throws NullPointerException if collection or predicate is null\n * @throws IllegalArgumentException if the collection contains invalid elements\n * @since 4.0\n */\npublic static <T> PredicatedCollection<T> predicatedCollection(final Collection<T> coll, final Predicate<? super T> predicate) {\n    return new PredicatedCollection<T>(coll, predicate);\n}"
            ],
            [
                "uniqueIndexedCollection",
                "org.apache.commons.collections4.collection",
                "IndexedCollection",
                "/**\n * Create an {@link IndexedCollection} for a unique index.\n * <p>\n * If an element is added, which maps to an existing key, an {@link IllegalArgumentException}\n * will be thrown.\n *\n * @param <K> the index object type.\n * @param <C> the collection type.\n * @param coll the decorated {@link Collection}.\n * @param keyTransformer the {@link Transformer} for generating index keys.\n * @return the created {@link IndexedCollection}.\n */\npublic static <K, C> IndexedCollection<K, C> uniqueIndexedCollection(final Collection<C> coll, final Transformer<C, K> keyTransformer) {\n    return new IndexedCollection<K, C>(coll, keyTransformer, MultiValueMap.<K, C>multiValueMap(new HashMap<K, Collection<C>>()), true);\n}"
            ],
            [
                "nonUniqueIndexedCollection",
                "org.apache.commons.collections4.collection",
                "IndexedCollection",
                "/**\n * Create an {@link IndexedCollection} for a non-unique index.\n *\n * @param <K> the index object type.\n * @param <C> the collection type.\n * @param coll the decorated {@link Collection}.\n * @param keyTransformer the {@link Transformer} for generating index keys.\n * @return the created {@link IndexedCollection}.\n */\npublic static <K, C> IndexedCollection<K, C> nonUniqueIndexedCollection(final Collection<C> coll, final Transformer<C, K> keyTransformer) {\n    return new IndexedCollection<K, C>(coll, keyTransformer, MultiValueMap.<K, C>multiValueMap(new HashMap<K, Collection<C>>()), false);\n}"
            ],
            [
                "synchronizedCollection",
                "org.apache.commons.collections4.collection",
                "SynchronizedCollection",
                "/**\n * Factory method to create a synchronized collection.\n *\n * @param <T> the type of the elements in the collection\n * @param coll  the collection to decorate, must not be null\n * @return a new synchronized collection\n * @throws NullPointerException if collection is null\n * @since 4.0\n */\npublic static <T> SynchronizedCollection<T> synchronizedCollection(final Collection<T> coll) {\n    return new SynchronizedCollection<T>(coll);\n}"
            ],
            [
                "unmodifiableCollection",
                "org.apache.commons.collections4.collection",
                "UnmodifiableCollection",
                "/**\n * Factory method to create an unmodifiable collection.\n * <p>\n * If the collection passed in is already unmodifiable, it is returned.\n *\n * @param <T> the type of the elements in the collection\n * @param coll  the collection to decorate, must not be null\n * @return an unmodifiable collection\n * @throws NullPointerException if collection is null\n * @since 4.0\n */\npublic static <T> Collection<T> unmodifiableCollection(final Collection<? extends T> coll) {\n    if (coll instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final Collection<T> tmpColl = (Collection<T>) coll;\n        return tmpColl;\n    }\n    return new UnmodifiableCollection<T>(coll);\n}"
            ],
            [
                "exceptionFactory",
                "org.apache.commons.collections4",
                "FactoryUtils",
                "/**\n * Gets a Factory that always throws an exception.\n * This could be useful during testing as a placeholder.\n *\n * @see org.apache.commons.collections4.functors.ExceptionFactory\n *\n * @param <T> the type that the factory creates\n * @return the factory\n */\npublic static <T> Factory<T> exceptionFactory() {\n    return ExceptionFactory.<T>exceptionFactory();\n}"
            ],
            [
                "nullFactory",
                "org.apache.commons.collections4",
                "FactoryUtils",
                "/**\n * Gets a Factory that will return null each time the factory is used.\n * This could be useful during testing as a placeholder.\n *\n * @see org.apache.commons.collections4.functors.ConstantFactory\n * @param <T> the \"type\" of null object the factory should return.\n * @return the factory\n */\npublic static <T> Factory<T> nullFactory() {\n    return ConstantFactory.<T>constantFactory(null);\n}"
            ],
            [
                "constantFactory",
                "org.apache.commons.collections4",
                "FactoryUtils",
                "/**\n * Creates a Factory that will return the same object each time the factory\n * is used. No check is made that the object is immutable. In general, only\n * immutable objects should use the constant factory. Mutable objects should\n * use the prototype factory.\n *\n * @see org.apache.commons.collections4.functors.ConstantFactory\n *\n * @param <T> the type that the factory creates\n * @param constantToReturn  the constant object to return each time in the factory\n * @return the <code>constant</code> factory.\n */\npublic static <T> Factory<T> constantFactory(final T constantToReturn) {\n    return ConstantFactory.constantFactory(constantToReturn);\n}"
            ],
            [
                "prototypeFactory",
                "org.apache.commons.collections4",
                "FactoryUtils",
                "/**\n * Creates a Factory that will return a clone of the same prototype object\n * each time the factory is used. The prototype will be cloned using one of these\n * techniques (in order):\n * <ul>\n * <li>public clone method\n * <li>public copy constructor\n * <li>serialization clone\n * <ul>\n *\n * @see org.apache.commons.collections4.functors.PrototypeFactory\n *\n * @param <T> the type that the factory creates\n * @param prototype  the object to clone each time in the factory\n * @return the <code>prototype</code> factory, or a {@link ConstantFactory#NULL_INSTANCE} if\n * the {@code prototype} is {@code null}\n * @throws IllegalArgumentException if the prototype cannot be cloned\n */\npublic static <T> Factory<T> prototypeFactory(final T prototype) {\n    return PrototypeFactory.<T>prototypeFactory(prototype);\n}"
            ],
            [
                "instantiateFactory",
                "org.apache.commons.collections4",
                "FactoryUtils",
                "/**\n * Creates a Factory that can create objects of a specific type using\n * a no-args constructor.\n *\n * @see org.apache.commons.collections4.functors.InstantiateFactory\n *\n * @param <T> the type that the factory creates\n * @param classToInstantiate  the Class to instantiate each time in the factory\n * @return the <code>reflection</code> factory\n * @throws NullPointerException if the classToInstantiate is null\n */\npublic static <T> Factory<T> instantiateFactory(final Class<T> classToInstantiate) {\n    return InstantiateFactory.instantiateFactory(classToInstantiate, null, null);\n}"
            ],
            [
                "instantiateFactory",
                "org.apache.commons.collections4",
                "FactoryUtils",
                "/**\n * Creates a Factory that can create objects of a specific type using\n * the arguments specified to this method.\n *\n * @see org.apache.commons.collections4.functors.InstantiateFactory\n *\n * @param <T> the type that the factory creates\n * @param classToInstantiate  the Class to instantiate each time in the factory\n * @param paramTypes  parameter types for the constructor, can be null\n * @param args  the arguments to pass to the constructor, can be null\n * @return the <code>reflection</code> factory\n * @throws NullPointerException if the classToInstantiate is null\n * @throws IllegalArgumentException if the paramTypes and args don't match\n * @throws IllegalArgumentException if the constructor doesn't exist\n */\npublic static <T> Factory<T> instantiateFactory(final Class<T> classToInstantiate, final Class<?>[] paramTypes, final Object[] args) {\n    return InstantiateFactory.instantiateFactory(classToInstantiate, paramTypes, args);\n}"
            ],
            [
                "emptyIfNull",
                "org.apache.commons.collections4",
                "ListUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns an immutable empty list if the argument is <code>null</code>,\n * or the argument itself otherwise.\n *\n * @param <T> the element type\n * @param list the list, possibly <code>null</code>\n * @return an empty list if the argument is <code>null</code>\n */\npublic static <T> List<T> emptyIfNull(final List<T> list) {\n    return list == null ? Collections.<T>emptyList() : list;\n}"
            ],
            [
                "defaultIfNull",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns either the passed in list, or if the list is {@code null},\n * the value of {@code defaultList}.\n *\n * @param <T> the element type\n * @param list  the list, possibly {@code null}\n * @param defaultList  the returned values if list is {@code null}\n * @return an empty list if the argument is <code>null</code>\n * @since 4.0\n */\npublic static <T> List<T> defaultIfNull(final List<T> list, final List<T> defaultList) {\n    return list == null ? defaultList : list;\n}"
            ],
            [
                "intersection",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns a new list containing all elements that are contained in\n * both given lists.\n *\n * @param <E> the element type\n * @param list1  the first list\n * @param list2  the second list\n * @return  the intersection of those two lists\n * @throws NullPointerException if either list is null\n */\npublic static <E> List<E> intersection(final List<? extends E> list1, final List<? extends E> list2) {\n    final List<E> result = new ArrayList<E>();\n    List<? extends E> smaller = list1;\n    List<? extends E> larger = list2;\n    if (list1.size() > list2.size()) {\n        smaller = list2;\n        larger = list1;\n    }\n    final HashSet<E> hashSet = new HashSet<E>(smaller);\n    for (final E e : larger) {\n        if (hashSet.contains(e)) {\n            result.add(e);\n            hashSet.remove(e);\n        }\n    }\n    return result;\n}"
            ],
            [
                "subtract",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Subtracts all elements in the second list from the first list,\n * placing the results in a new list.\n * <p>\n * This differs from {@link List#removeAll(Collection)} in that\n * cardinality is respected; if <Code>list1</Code> contains two\n * occurrences of <Code>null</Code> and <Code>list2</Code> only\n * contains one occurrence, then the returned list will still contain\n * one occurrence.\n *\n * @param <E> the element type\n * @param list1  the list to subtract from\n * @param list2  the list to subtract\n * @return a new list containing the results\n * @throws NullPointerException if either list is null\n */\npublic static <E> List<E> subtract(final List<E> list1, final List<? extends E> list2) {\n    final ArrayList<E> result = new ArrayList<E>();\n    final HashBag<E> bag = new HashBag<E>(list2);\n    for (final E e : list1) {\n        if (!bag.remove(e, 1)) {\n            result.add(e);\n        }\n    }\n    return result;\n}"
            ],
            [
                "sum",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns the sum of the given lists.  This is their intersection\n * subtracted from their union.\n *\n * @param <E> the element type\n * @param list1  the first list\n * @param list2  the second list\n * @return  a new list containing the sum of those lists\n * @throws NullPointerException if either list is null\n */\npublic static <E> List<E> sum(final List<? extends E> list1, final List<? extends E> list2) {\n    return subtract(union(list1, list2), intersection(list1, list2));\n}"
            ],
            [
                "union",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns a new list containing the second list appended to the\n * first list.  The {@link List#addAll(Collection)} operation is\n * used to append the two given lists into a new list.\n *\n * @param <E> the element type\n * @param list1  the first list\n * @param list2  the second list\n * @return a new list containing the union of those lists\n * @throws NullPointerException if either list is null\n */\npublic static <E> List<E> union(final List<? extends E> list1, final List<? extends E> list2) {\n    final ArrayList<E> result = new ArrayList<E>(list1);\n    result.addAll(list2);\n    return result;\n}"
            ],
            [
                "select",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Selects all elements from input collection which match the given\n * predicate into an output list.\n * <p>\n * A <code>null</code> predicate matches no elements.\n *\n * @param <E> the element type\n * @param inputCollection  the collection to get the input from, may not be null\n * @param predicate  the predicate to use, may be null\n * @return the elements matching the predicate (new list)\n * @throws NullPointerException if the input list is null\n *\n * @since 4.0\n * @see CollectionUtils#select(Iterable, Predicate)\n */\npublic static <E> List<E> select(final Collection<? extends E> inputCollection, final Predicate<? super E> predicate) {\n    return CollectionUtils.select(inputCollection, predicate, new ArrayList<E>(inputCollection.size()));\n}"
            ],
            [
                "selectRejected",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Selects all elements from inputCollection which don't match the given\n * predicate into an output collection.\n * <p>\n * If the input predicate is <code>null</code>, the result is an empty list.\n *\n * @param <E> the element type\n * @param inputCollection the collection to get the input from, may not be null\n * @param predicate the predicate to use, may be null\n * @return the elements <b>not</b> matching the predicate (new list)\n * @throws NullPointerException if the input collection is null\n *\n * @since 4.0\n * @see CollectionUtils#selectRejected(Iterable, Predicate)\n */\npublic static <E> List<E> selectRejected(final Collection<? extends E> inputCollection, final Predicate<? super E> predicate) {\n    return CollectionUtils.selectRejected(inputCollection, predicate, new ArrayList<E>(inputCollection.size()));\n}"
            ],
            [
                "isEqualList",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Tests two lists for value-equality as per the equality contract in\n * {@link java.util.List#equals(java.lang.Object)}.\n * <p>\n * This method is useful for implementing <code>List</code> when you cannot\n * extend AbstractList. The method takes Collection instances to enable other\n * collection types to use the List implementation algorithm.\n * <p>\n * The relevant text (slightly paraphrased as this is a static method) is:\n * <blockquote>\n * Compares the two list objects for equality.  Returns\n * {@code true} if and only if both\n * lists have the same size, and all corresponding pairs of elements in\n * the two lists are <i>equal</i>.  (Two elements {@code e1} and\n * {@code e2} are <i>equal</i> if <tt>(e1==null ? e2==null :\n * e1.equals(e2))</tt>.)  In other words, two lists are defined to be\n * equal if they contain the same elements in the same order.  This\n * definition ensures that the equals method works properly across\n * different implementations of the {@code List} interface.\n * </blockquote>\n *\n * <b>Note:</b> The behaviour of this method is undefined if the lists are\n * modified during the equals comparison.\n *\n * @see java.util.List\n * @param list1  the first list, may be null\n * @param list2  the second list, may be null\n * @return whether the lists are equal by value comparison\n */\npublic static boolean isEqualList(final Collection<?> list1, final Collection<?> list2) {\n    if (list1 == list2) {\n        return true;\n    }\n    if (list1 == null || list2 == null || list1.size() != list2.size()) {\n        return false;\n    }\n    final Iterator<?> it1 = list1.iterator();\n    final Iterator<?> it2 = list2.iterator();\n    Object obj1 = null;\n    Object obj2 = null;\n    while (it1.hasNext() && it2.hasNext()) {\n        obj1 = it1.next();\n        obj2 = it2.next();\n        if (!(obj1 == null ? obj2 == null : obj1.equals(obj2))) {\n            return false;\n        }\n    }\n    return !(it1.hasNext() || it2.hasNext());\n}"
            ],
            [
                "hashCodeForList",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Generates a hash code using the algorithm specified in\n * {@link java.util.List#hashCode()}.\n * <p>\n * This method is useful for implementing <code>List</code> when you cannot\n * extend AbstractList. The method takes Collection instances to enable other\n * collection types to use the List implementation algorithm.\n *\n * @see java.util.List#hashCode()\n * @param list  the list to generate the hashCode for, may be null\n * @return the hash code\n */\npublic static int hashCodeForList(final Collection<?> list) {\n    if (list == null) {\n        return 0;\n    }\n    int hashCode = 1;\n    final Iterator<?> it = list.iterator();\n    while (it.hasNext()) {\n        final Object obj = it.next();\n        hashCode = 31 * hashCode + (obj == null ? 0 : obj.hashCode());\n    }\n    return hashCode;\n}"
            ],
            [
                "retainAll",
                "org.apache.commons.collections4",
                "ListUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns a List containing all the elements in <code>collection</code>\n * that are also in <code>retain</code>. The cardinality of an element <code>e</code>\n * in the returned list is the same as the cardinality of <code>e</code>\n * in <code>collection</code> unless <code>retain</code> does not contain <code>e</code>, in which\n * case the cardinality is zero. This method is useful if you do not wish to modify\n * the collection <code>c</code> and thus cannot call <code>collection.retainAll(retain);</code>.\n * <p>\n * This implementation iterates over <code>collection</code>, checking each element in\n * turn to see if it's contained in <code>retain</code>. If it's contained, it's added\n * to the returned list. As a consequence, it is advised to use a collection type for\n * <code>retain</code> that provides a fast (e.g. O(1)) implementation of\n * {@link Collection#contains(Object)}.\n *\n * @param <E>  the element type\n * @param collection  the collection whose contents are the target of the #retailAll operation\n * @param retain  the collection containing the elements to be retained in the returned collection\n * @return a <code>List</code> containing all the elements of <code>c</code>\n * that occur at least once in <code>retain</code>.\n * @throws NullPointerException if either parameter is null\n * @since 3.2\n */\npublic static <E> List<E> retainAll(final Collection<E> collection, final Collection<?> retain) {\n    final List<E> list = new ArrayList<E>(Math.min(collection.size(), retain.size()));\n    for (final E obj : collection) {\n        if (retain.contains(obj)) {\n            list.add(obj);\n        }\n    }\n    return list;\n}"
            ],
            [
                "removeAll",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Removes the elements in <code>remove</code> from <code>collection</code>. That is, this\n * method returns a list containing all the elements in <code>collection</code>\n * that are not in <code>remove</code>. The cardinality of an element <code>e</code>\n * in the returned collection is the same as the cardinality of <code>e</code>\n * in <code>collection</code> unless <code>remove</code> contains <code>e</code>, in which\n * case the cardinality is zero. This method is useful if you do not wish to modify\n * <code>collection</code> and thus cannot call <code>collection.removeAll(remove);</code>.\n * <p>\n * This implementation iterates over <code>collection</code>, checking each element in\n * turn to see if it's contained in <code>remove</code>. If it's not contained, it's added\n * to the returned list. As a consequence, it is advised to use a collection type for\n * <code>remove</code> that provides a fast (e.g. O(1)) implementation of\n * {@link Collection#contains(Object)}.\n *\n * @param <E>  the element type\n * @param collection  the collection from which items are removed (in the returned collection)\n * @param remove  the items to be removed from the returned <code>collection</code>\n * @return a <code>List</code> containing all the elements of <code>c</code> except\n * any elements that also occur in <code>remove</code>.\n * @throws NullPointerException if either parameter is null\n * @since 3.2\n */\npublic static <E> List<E> removeAll(final Collection<E> collection, final Collection<?> remove) {\n    final List<E> list = new ArrayList<E>();\n    for (final E obj : collection) {\n        if (!remove.contains(obj)) {\n            list.add(obj);\n        }\n    }\n    return list;\n}"
            ],
            [
                "synchronizedList",
                "org.apache.commons.collections4",
                "ListUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns a synchronized list backed by the given list.\n * <p>\n * You must manually synchronize on the returned list's iterator to\n * avoid non-deterministic behavior:\n *\n * <pre>\n * List list = ListUtils.synchronizedList(myList);\n * synchronized (list) {\n *     Iterator i = list.iterator();\n *     while (i.hasNext()) {\n *         process (i.next());\n *     }\n * }\n * </pre>\n *\n * This method is just a wrapper for {@link Collections#synchronizedList(List)}.\n *\n * @param <E> the element type\n * @param list  the list to synchronize, must not be null\n * @return a synchronized list backed by the given list\n * @throws NullPointerException if the list is null\n */\npublic static <E> List<E> synchronizedList(final List<E> list) {\n    return Collections.synchronizedList(list);\n}"
            ],
            [
                "unmodifiableList",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns an unmodifiable list backed by the given list.\n * <p>\n * This method uses the implementation in the decorators subpackage.\n *\n * @param <E>  the element type\n * @param list  the list to make unmodifiable, must not be null\n * @return an unmodifiable list backed by the given list\n * @throws NullPointerException if the list is null\n */\npublic static <E> List<E> unmodifiableList(final List<? extends E> list) {\n    return UnmodifiableList.unmodifiableList(list);\n}"
            ],
            [
                "predicatedList",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns a predicated (validating) list backed by the given list.\n * <p>\n * Only objects that pass the test in the given predicate can be added to the list.\n * Trying to add an invalid object results in an IllegalArgumentException.\n * It is important not to use the original list after invoking this method,\n * as it is a backdoor for adding invalid objects.\n *\n * @param <E> the element type\n * @param list  the list to predicate, must not be null\n * @param predicate  the predicate for the list, must not be null\n * @return a predicated list backed by the given list\n * @throws NullPointerException if the List or Predicate is null\n */\npublic static <E> List<E> predicatedList(final List<E> list, final Predicate<E> predicate) {\n    return PredicatedList.predicatedList(list, predicate);\n}"
            ],
            [
                "transformedList",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns a transformed list backed by the given list.\n * <p>\n * This method returns a new list (decorating the specified list) that\n * will transform any new entries added to it.\n * Existing entries in the specified list will not be transformed.\n * <p>\n * Each object is passed through the transformer as it is added to the\n * List. It is important not to use the original list after invoking this\n * method, as it is a backdoor for adding untransformed objects.\n * <p>\n * Existing entries in the specified list will not be transformed.\n * If you want that behaviour, see {@link TransformedList#transformedList}.\n *\n * @param <E> the element type\n * @param list  the list to predicate, must not be null\n * @param transformer  the transformer for the list, must not be null\n * @return a transformed list backed by the given list\n * @throws NullPointerException if the List or Transformer is null\n */\npublic static <E> List<E> transformedList(final List<E> list, final Transformer<? super E, ? extends E> transformer) {\n    return TransformedList.transformingList(list, transformer);\n}"
            ],
            [
                "lazyList",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns a \"lazy\" list whose elements will be created on demand.\n * <p>\n * When the index passed to the returned list's {@link List#get(int) get}\n * method is greater than the list's size, then the factory will be used\n * to create a new object and that object will be inserted at that index.\n * <p>\n * For instance:\n *\n * <pre>\n * Factory&lt;Date&gt; factory = new Factory&lt;Date&gt;() {\n *     public Date create() {\n *         return new Date();\n *     }\n * }\n * List&lt;Date&gt; lazy = ListUtils.lazyList(new ArrayList&lt;Date&gt;(), factory);\n * Date date = lazy.get(3);\n * </pre>\n *\n * After the above code is executed, <code>date</code> will refer to\n * a new <code>Date</code> instance.  Furthermore, that <code>Date</code>\n * instance is the fourth element in the list.  The first, second,\n * and third element are all set to <code>null</code>.\n *\n * @param <E> the element type\n * @param list  the list to make lazy, must not be null\n * @param factory  the factory for creating new objects, must not be null\n * @return a lazy list backed by the given list\n * @throws NullPointerException if the List or Factory is null\n */\npublic static <E> List<E> lazyList(final List<E> list, final Factory<? extends E> factory) {\n    return LazyList.lazyList(list, factory);\n}"
            ],
            [
                "fixedSizeList",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns a fixed-sized list backed by the given list.\n * Elements may not be added or removed from the returned list, but\n * existing elements can be changed (for instance, via the\n * {@link List#set(int, Object)} method).\n *\n * @param <E>  the element type\n * @param list  the list whose size to fix, must not be null\n * @return a fixed-size list backed by that list\n * @throws NullPointerException  if the List is null\n */\npublic static <E> List<E> fixedSizeList(final List<E> list) {\n    return FixedSizeList.fixedSizeList(list);\n}"
            ],
            [
                "indexOf",
                "org.apache.commons.collections4",
                "ListUtils",
                "//-----------------------------------------------------------------------\n/**\n * Finds the first index in the given List which matches the given predicate.\n * <p>\n * If the input List or predicate is null, or no element of the List\n * matches the predicate, -1 is returned.\n *\n * @param <E>  the element type\n * @param list the List to search, may be null\n * @param predicate  the predicate to use, may be null\n * @return the first index of an Object in the List which matches the predicate or -1 if none could be found\n */\npublic static <E> int indexOf(final List<E> list, final Predicate<E> predicate) {\n    if (list != null && predicate != null) {\n        for (int i = 0; i < list.size(); i++) {\n            final E item = list.get(i);\n            if (predicate.evaluate(item)) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}"
            ],
            [
                "longestCommonSubsequence",
                "org.apache.commons.collections4",
                "ListUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns the longest common subsequence (LCS) of two sequences (lists).\n *\n * @param <E>  the element type\n * @param a  the first list\n * @param b  the second list\n * @return the longest common subsequence\n * @throws NullPointerException if either list is {@code null}\n * @since 4.0\n */\npublic static <E> List<E> longestCommonSubsequence(final List<E> a, final List<E> b) {\n    return longestCommonSubsequence(a, b, DefaultEquator.defaultEquator());\n}"
            ],
            [
                "longestCommonSubsequence",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns the longest common subsequence (LCS) of two sequences (lists).\n *\n * @param <E>  the element type\n * @param a  the first list\n * @param b  the second list\n * @param equator  the equator used to test object equality\n * @return the longest common subsequence\n * @throws NullPointerException if either list or the equator is {@code null}\n * @since 4.0\n */\npublic static <E> List<E> longestCommonSubsequence(final List<E> a, final List<E> b, final Equator<? super E> equator) {\n    if (a == null || b == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (equator == null) {\n        throw new NullPointerException(\"Equator must not be null\");\n    }\n    final SequencesComparator<E> comparator = new SequencesComparator<E>(a, b, equator);\n    final EditScript<E> script = comparator.getScript();\n    final LcsVisitor<E> visitor = new LcsVisitor<E>();\n    script.visit(visitor);\n    return visitor.getSubSequence();\n}"
            ],
            [
                "longestCommonSubsequence",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns the longest common subsequence (LCS) of two {@link CharSequence} objects.\n * <p>\n * This is a convenience method for using {@link #longestCommonSubsequence(List, List)}\n * with {@link CharSequence} instances.\n *\n * @param a  the first sequence\n * @param b  the second sequence\n * @return the longest common subsequence as {@link String}\n * @throws NullPointerException if either sequence is {@code null}\n * @since 4.0\n */\npublic static String longestCommonSubsequence(final CharSequence a, final CharSequence b) {\n    if (a == null || b == null) {\n        throw new NullPointerException(\"CharSequence must not be null\");\n    }\n    final List<Character> lcs = longestCommonSubsequence(new CharSequenceAsList(a), new CharSequenceAsList(b));\n    final StringBuilder sb = new StringBuilder();\n    for (Character ch : lcs) {\n        sb.append(ch);\n    }\n    return sb.toString();\n}"
            ],
            [
                "partition",
                "org.apache.commons.collections4",
                "ListUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns consecutive {@link List#subList(int, int) sublists} of a\n * list, each of the same size (the final list may be smaller). For example,\n * partitioning a list containing {@code [a, b, c, d, e]} with a partition\n * size of 3 yields {@code [[a, b, c], [d, e]]} -- an outer list containing\n * two inner lists of three and two elements, all in the original order.\n * <p>\n * The outer list is unmodifiable, but reflects the latest state of the\n * source list. The inner lists are sublist views of the original list,\n * produced on demand using {@link List#subList(int, int)}, and are subject\n * to all the usual caveats about modification as explained in that API.\n * <p>\n * Adapted from http://code.google.com/p/guava-libraries/\n *\n * @param <T> the element type\n * @param list  the list to return consecutive sublists of\n * @param size  the desired size of each sublist (the last may be smaller)\n * @return a list of consecutive sublists\n * @throws NullPointerException if list is null\n * @throws IllegalArgumentException if size is not strictly positive\n * @since 4.0\n */\npublic static <T> List<List<T>> partition(final List<T> list, final int size) {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (size <= 0) {\n        throw new IllegalArgumentException(\"Size must be greater than 0\");\n    }\n    return new Partition<T>(list, size);\n}"
            ],
            [
                "getObject",
                "org.apache.commons.collections4",
                "MapUtils",
                "// Type safe getters\n//-------------------------------------------------------------------------\n/**\n * Gets from a Map in a null-safe manner.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map, <code>null</code> if null map input\n */\npublic static <K, V> V getObject(final Map<? super K, V> map, final K key) {\n    if (map != null) {\n        return map.get(key);\n    }\n    return null;\n}"
            ],
            [
                "getString",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a String from a Map in a null-safe manner.\n * <p>\n * The String is obtained via <code>toString</code>.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a String, <code>null</code> if null map input\n */\npublic static <K> String getString(final Map<? super K, ?> map, final K key) {\n    if (map != null) {\n        final Object answer = map.get(key);\n        if (answer != null) {\n            return answer.toString();\n        }\n    }\n    return null;\n}"
            ],
            [
                "getBoolean",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a Boolean from a Map in a null-safe manner.\n * <p>\n * If the value is a <code>Boolean</code> it is returned directly.\n * If the value is a <code>String</code> and it equals 'true' ignoring case\n * then <code>true</code> is returned, otherwise <code>false</code>.\n * If the value is a <code>Number</code> an integer zero value returns\n * <code>false</code> and non-zero returns <code>true</code>.\n * Otherwise, <code>null</code> is returned.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a Boolean, <code>null</code> if null map input\n */\npublic static <K> Boolean getBoolean(final Map<? super K, ?> map, final K key) {\n    if (map != null) {\n        final Object answer = map.get(key);\n        if (answer != null) {\n            if (answer instanceof Boolean) {\n                return (Boolean) answer;\n            }\n            if (answer instanceof String) {\n                return Boolean.valueOf((String) answer);\n            }\n            if (answer instanceof Number) {\n                final Number n = (Number) answer;\n                return n.intValue() != 0 ? Boolean.TRUE : Boolean.FALSE;\n            }\n        }\n    }\n    return null;\n}"
            ],
            [
                "getNumber",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a Number from a Map in a null-safe manner.\n * <p>\n * If the value is a <code>Number</code> it is returned directly.\n * If the value is a <code>String</code> it is converted using\n * {@link NumberFormat#parse(String)} on the system default formatter\n * returning <code>null</code> if the conversion fails.\n * Otherwise, <code>null</code> is returned.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a Number, <code>null</code> if null map input\n */\npublic static <K> Number getNumber(final Map<? super K, ?> map, final K key) {\n    if (map != null) {\n        final Object answer = map.get(key);\n        if (answer != null) {\n            if (answer instanceof Number) {\n                return (Number) answer;\n            }\n            if (answer instanceof String) {\n                try {\n                    final String text = (String) answer;\n                    return NumberFormat.getInstance().parse(text);\n                } catch (final ParseException e) {\n                    // NOPMD\n                    // failure means null is returned\n                }\n            }\n        }\n    }\n    return null;\n}"
            ],
            [
                "getByte",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a Byte from a Map in a null-safe manner.\n * <p>\n * The Byte is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a Byte, <code>null</code> if null map input\n */\npublic static <K> Byte getByte(final Map<? super K, ?> map, final K key) {\n    final Number answer = getNumber(map, key);\n    if (answer == null) {\n        return null;\n    }\n    if (answer instanceof Byte) {\n        return (Byte) answer;\n    }\n    return Byte.valueOf(answer.byteValue());\n}"
            ],
            [
                "getShort",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a Short from a Map in a null-safe manner.\n * <p>\n * The Short is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a Short, <code>null</code> if null map input\n */\npublic static <K> Short getShort(final Map<? super K, ?> map, final K key) {\n    final Number answer = getNumber(map, key);\n    if (answer == null) {\n        return null;\n    }\n    if (answer instanceof Short) {\n        return (Short) answer;\n    }\n    return Short.valueOf(answer.shortValue());\n}"
            ],
            [
                "getInteger",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a Integer from a Map in a null-safe manner.\n * <p>\n * The Integer is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a Integer, <code>null</code> if null map input\n */\npublic static <K> Integer getInteger(final Map<? super K, ?> map, final K key) {\n    final Number answer = getNumber(map, key);\n    if (answer == null) {\n        return null;\n    }\n    if (answer instanceof Integer) {\n        return (Integer) answer;\n    }\n    return Integer.valueOf(answer.intValue());\n}"
            ],
            [
                "getLong",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a Long from a Map in a null-safe manner.\n * <p>\n * The Long is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a Long, <code>null</code> if null map input\n */\npublic static <K> Long getLong(final Map<? super K, ?> map, final K key) {\n    final Number answer = getNumber(map, key);\n    if (answer == null) {\n        return null;\n    }\n    if (answer instanceof Long) {\n        return (Long) answer;\n    }\n    return Long.valueOf(answer.longValue());\n}"
            ],
            [
                "getFloat",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a Float from a Map in a null-safe manner.\n * <p>\n * The Float is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a Float, <code>null</code> if null map input\n */\npublic static <K> Float getFloat(final Map<? super K, ?> map, final K key) {\n    final Number answer = getNumber(map, key);\n    if (answer == null) {\n        return null;\n    }\n    if (answer instanceof Float) {\n        return (Float) answer;\n    }\n    return Float.valueOf(answer.floatValue());\n}"
            ],
            [
                "getDouble",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a Double from a Map in a null-safe manner.\n * <p>\n * The Double is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a Double, <code>null</code> if null map input\n */\npublic static <K> Double getDouble(final Map<? super K, ?> map, final K key) {\n    final Number answer = getNumber(map, key);\n    if (answer == null) {\n        return null;\n    }\n    if (answer instanceof Double) {\n        return (Double) answer;\n    }\n    return Double.valueOf(answer.doubleValue());\n}"
            ],
            [
                "getMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a Map from a Map in a null-safe manner.\n * <p>\n * If the value returned from the specified map is not a Map then\n * <code>null</code> is returned.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a Map, <code>null</code> if null map input\n */\npublic static <K> Map<?, ?> getMap(final Map<? super K, ?> map, final K key) {\n    if (map != null) {\n        final Object answer = map.get(key);\n        if (answer != null && answer instanceof Map) {\n            return (Map<?, ?>) answer;\n        }\n    }\n    return null;\n}"
            ],
            [
                "getObject",
                "org.apache.commons.collections4",
                "MapUtils",
                "// Type safe getters with default values\n//-------------------------------------------------------------------------\n/**\n * Looks up the given key in the given map, converting null into the\n * given default value.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null\n * @return  the value in the map, or defaultValue if the original value\n *   is null or the map is null\n */\npublic static <K, V> V getObject(final Map<K, V> map, final K key, final V defaultValue) {\n    if (map != null) {\n        final V answer = map.get(key);\n        if (answer != null) {\n            return answer;\n        }\n    }\n    return defaultValue;\n}"
            ],
            [
                "getString",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Looks up the given key in the given map, converting the result into\n * a string, using the default value if the the conversion fails.\n *\n * @param <K>  the key type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null or if the\n *   conversion fails\n * @return  the value in the map as a string, or defaultValue if the\n *   original value is null, the map is null or the string conversion fails\n */\npublic static <K> String getString(final Map<? super K, ?> map, final K key, final String defaultValue) {\n    String answer = getString(map, key);\n    if (answer == null) {\n        answer = defaultValue;\n    }\n    return answer;\n}"
            ],
            [
                "getBoolean",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Looks up the given key in the given map, converting the result into\n * a boolean, using the default value if the the conversion fails.\n *\n * @param <K>  the key type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null or if the\n *   conversion fails\n * @return  the value in the map as a boolean, or defaultValue if the\n *   original value is null, the map is null or the boolean conversion fails\n */\npublic static <K> Boolean getBoolean(final Map<? super K, ?> map, final K key, final Boolean defaultValue) {\n    Boolean answer = getBoolean(map, key);\n    if (answer == null) {\n        answer = defaultValue;\n    }\n    return answer;\n}"
            ],
            [
                "getNumber",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Looks up the given key in the given map, converting the result into\n * a number, using the default value if the the conversion fails.\n *\n * @param <K>  the key type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null or if the\n *   conversion fails\n * @return  the value in the map as a number, or defaultValue if the\n *   original value is null, the map is null or the number conversion fails\n */\npublic static <K> Number getNumber(final Map<? super K, ?> map, final K key, final Number defaultValue) {\n    Number answer = getNumber(map, key);\n    if (answer == null) {\n        answer = defaultValue;\n    }\n    return answer;\n}"
            ],
            [
                "getByte",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Looks up the given key in the given map, converting the result into\n * a byte, using the default value if the the conversion fails.\n *\n * @param <K>  the key type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null or if the\n *   conversion fails\n * @return  the value in the map as a number, or defaultValue if the\n *   original value is null, the map is null or the number conversion fails\n */\npublic static <K> Byte getByte(final Map<? super K, ?> map, final K key, final Byte defaultValue) {\n    Byte answer = getByte(map, key);\n    if (answer == null) {\n        answer = defaultValue;\n    }\n    return answer;\n}"
            ],
            [
                "getShort",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Looks up the given key in the given map, converting the result into\n * a short, using the default value if the the conversion fails.\n *\n * @param <K>  the key type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null or if the\n *   conversion fails\n * @return  the value in the map as a number, or defaultValue if the\n *   original value is null, the map is null or the number conversion fails\n */\npublic static <K> Short getShort(final Map<? super K, ?> map, final K key, final Short defaultValue) {\n    Short answer = getShort(map, key);\n    if (answer == null) {\n        answer = defaultValue;\n    }\n    return answer;\n}"
            ],
            [
                "getInteger",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Looks up the given key in the given map, converting the result into\n * an integer, using the default value if the the conversion fails.\n *\n * @param <K>  the key type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null or if the\n *   conversion fails\n * @return  the value in the map as a number, or defaultValue if the\n *   original value is null, the map is null or the number conversion fails\n */\npublic static <K> Integer getInteger(final Map<? super K, ?> map, final K key, final Integer defaultValue) {\n    Integer answer = getInteger(map, key);\n    if (answer == null) {\n        answer = defaultValue;\n    }\n    return answer;\n}"
            ],
            [
                "getLong",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Looks up the given key in the given map, converting the result into\n * a long, using the default value if the the conversion fails.\n *\n * @param <K>  the key type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null or if the\n *   conversion fails\n * @return  the value in the map as a number, or defaultValue if the\n *   original value is null, the map is null or the number conversion fails\n */\npublic static <K> Long getLong(final Map<? super K, ?> map, final K key, final Long defaultValue) {\n    Long answer = getLong(map, key);\n    if (answer == null) {\n        answer = defaultValue;\n    }\n    return answer;\n}"
            ],
            [
                "getFloat",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Looks up the given key in the given map, converting the result into\n * a float, using the default value if the the conversion fails.\n *\n * @param <K>  the key type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null or if the\n *   conversion fails\n * @return  the value in the map as a number, or defaultValue if the\n *   original value is null, the map is null or the number conversion fails\n */\npublic static <K> Float getFloat(final Map<? super K, ?> map, final K key, final Float defaultValue) {\n    Float answer = getFloat(map, key);\n    if (answer == null) {\n        answer = defaultValue;\n    }\n    return answer;\n}"
            ],
            [
                "getDouble",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Looks up the given key in the given map, converting the result into\n * a double, using the default value if the the conversion fails.\n *\n * @param <K>  the key type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null or if the\n *   conversion fails\n * @return  the value in the map as a number, or defaultValue if the\n *   original value is null, the map is null or the number conversion fails\n */\npublic static <K> Double getDouble(final Map<? super K, ?> map, final K key, final Double defaultValue) {\n    Double answer = getDouble(map, key);\n    if (answer == null) {\n        answer = defaultValue;\n    }\n    return answer;\n}"
            ],
            [
                "getMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Looks up the given key in the given map, converting the result into\n * a map, using the default value if the the conversion fails.\n *\n * @param <K>  the key type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null or if the\n *   conversion fails\n * @return  the value in the map as a number, or defaultValue if the\n *   original value is null, the map is null or the map conversion fails\n */\npublic static <K> Map<?, ?> getMap(final Map<? super K, ?> map, final K key, final Map<?, ?> defaultValue) {\n    Map<?, ?> answer = getMap(map, key);\n    if (answer == null) {\n        answer = defaultValue;\n    }\n    return answer;\n}"
            ],
            [
                "getBooleanValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "// Type safe primitive getters\n//-------------------------------------------------------------------------\n/**\n * Gets a boolean from a Map in a null-safe manner.\n * <p>\n * If the value is a <code>Boolean</code> its value is returned.\n * If the value is a <code>String</code> and it equals 'true' ignoring case\n * then <code>true</code> is returned, otherwise <code>false</code>.\n * If the value is a <code>Number</code> an integer zero value returns\n * <code>false</code> and non-zero returns <code>true</code>.\n * Otherwise, <code>false</code> is returned.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a Boolean, <code>false</code> if null map input\n */\npublic static <K> boolean getBooleanValue(final Map<? super K, ?> map, final K key) {\n    return Boolean.TRUE.equals(getBoolean(map, key));\n}"
            ],
            [
                "getByteValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a byte from a Map in a null-safe manner.\n * <p>\n * The byte is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a byte, <code>0</code> if null map input\n */\npublic static <K> byte getByteValue(final Map<? super K, ?> map, final K key) {\n    final Byte byteObject = getByte(map, key);\n    if (byteObject == null) {\n        return 0;\n    }\n    return byteObject.byteValue();\n}"
            ],
            [
                "getShortValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a short from a Map in a null-safe manner.\n * <p>\n * The short is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a short, <code>0</code> if null map input\n */\npublic static <K> short getShortValue(final Map<? super K, ?> map, final K key) {\n    final Short shortObject = getShort(map, key);\n    if (shortObject == null) {\n        return 0;\n    }\n    return shortObject.shortValue();\n}"
            ],
            [
                "getIntValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets an int from a Map in a null-safe manner.\n * <p>\n * The int is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as an int, <code>0</code> if null map input\n */\npublic static <K> int getIntValue(final Map<? super K, ?> map, final K key) {\n    final Integer integerObject = getInteger(map, key);\n    if (integerObject == null) {\n        return 0;\n    }\n    return integerObject.intValue();\n}"
            ],
            [
                "getLongValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a long from a Map in a null-safe manner.\n * <p>\n * The long is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a long, <code>0L</code> if null map input\n */\npublic static <K> long getLongValue(final Map<? super K, ?> map, final K key) {\n    final Long longObject = getLong(map, key);\n    if (longObject == null) {\n        return 0L;\n    }\n    return longObject.longValue();\n}"
            ],
            [
                "getFloatValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a float from a Map in a null-safe manner.\n * <p>\n * The float is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a float, <code>0.0F</code> if null map input\n */\npublic static <K> float getFloatValue(final Map<? super K, ?> map, final K key) {\n    final Float floatObject = getFloat(map, key);\n    if (floatObject == null) {\n        return 0f;\n    }\n    return floatObject.floatValue();\n}"
            ],
            [
                "getDoubleValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a double from a Map in a null-safe manner.\n * <p>\n * The double is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a double, <code>0.0</code> if null map input\n */\npublic static <K> double getDoubleValue(final Map<? super K, ?> map, final K key) {\n    final Double doubleObject = getDouble(map, key);\n    if (doubleObject == null) {\n        return 0d;\n    }\n    return doubleObject.doubleValue();\n}"
            ],
            [
                "getBooleanValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "// Type safe primitive getters with default values\n//-------------------------------------------------------------------------\n/**\n * Gets a boolean from a Map in a null-safe manner,\n * using the default value if the the conversion fails.\n * <p>\n * If the value is a <code>Boolean</code> its value is returned.\n * If the value is a <code>String</code> and it equals 'true' ignoring case\n * then <code>true</code> is returned, otherwise <code>false</code>.\n * If the value is a <code>Number</code> an integer zero value returns\n * <code>false</code> and non-zero returns <code>true</code>.\n * Otherwise, <code>defaultValue</code> is returned.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @param defaultValue  return if the value is null or if the conversion fails\n * @return the value in the Map as a Boolean, <code>defaultValue</code> if null map input\n */\npublic static <K> boolean getBooleanValue(final Map<? super K, ?> map, final K key, final boolean defaultValue) {\n    final Boolean booleanObject = getBoolean(map, key);\n    if (booleanObject == null) {\n        return defaultValue;\n    }\n    return booleanObject.booleanValue();\n}"
            ],
            [
                "getByteValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a byte from a Map in a null-safe manner,\n * using the default value if the the conversion fails.\n * <p>\n * The byte is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @param defaultValue  return if the value is null or if the conversion fails\n * @return the value in the Map as a byte, <code>defaultValue</code> if null map input\n */\npublic static <K> byte getByteValue(final Map<? super K, ?> map, final K key, final byte defaultValue) {\n    final Byte byteObject = getByte(map, key);\n    if (byteObject == null) {\n        return defaultValue;\n    }\n    return byteObject.byteValue();\n}"
            ],
            [
                "getShortValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a short from a Map in a null-safe manner,\n * using the default value if the the conversion fails.\n * <p>\n * The short is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @param defaultValue  return if the value is null or if the conversion fails\n * @return the value in the Map as a short, <code>defaultValue</code> if null map input\n */\npublic static <K> short getShortValue(final Map<? super K, ?> map, final K key, final short defaultValue) {\n    final Short shortObject = getShort(map, key);\n    if (shortObject == null) {\n        return defaultValue;\n    }\n    return shortObject.shortValue();\n}"
            ],
            [
                "getIntValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets an int from a Map in a null-safe manner,\n * using the default value if the the conversion fails.\n * <p>\n * The int is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @param defaultValue  return if the value is null or if the conversion fails\n * @return the value in the Map as an int, <code>defaultValue</code> if null map input\n */\npublic static <K> int getIntValue(final Map<? super K, ?> map, final K key, final int defaultValue) {\n    final Integer integerObject = getInteger(map, key);\n    if (integerObject == null) {\n        return defaultValue;\n    }\n    return integerObject.intValue();\n}"
            ],
            [
                "getLongValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a long from a Map in a null-safe manner,\n * using the default value if the the conversion fails.\n * <p>\n * The long is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @param defaultValue  return if the value is null or if the conversion fails\n * @return the value in the Map as a long, <code>defaultValue</code> if null map input\n */\npublic static <K> long getLongValue(final Map<? super K, ?> map, final K key, final long defaultValue) {\n    final Long longObject = getLong(map, key);\n    if (longObject == null) {\n        return defaultValue;\n    }\n    return longObject.longValue();\n}"
            ],
            [
                "getFloatValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a float from a Map in a null-safe manner,\n * using the default value if the the conversion fails.\n * <p>\n * The float is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @param defaultValue  return if the value is null or if the conversion fails\n * @return the value in the Map as a float, <code>defaultValue</code> if null map input\n */\npublic static <K> float getFloatValue(final Map<? super K, ?> map, final K key, final float defaultValue) {\n    final Float floatObject = getFloat(map, key);\n    if (floatObject == null) {\n        return defaultValue;\n    }\n    return floatObject.floatValue();\n}"
            ],
            [
                "getDoubleValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a double from a Map in a null-safe manner,\n * using the default value if the the conversion fails.\n * <p>\n * The double is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @param defaultValue  return if the value is null or if the conversion fails\n * @return the value in the Map as a double, <code>defaultValue</code> if null map input\n */\npublic static <K> double getDoubleValue(final Map<? super K, ?> map, final K key, final double defaultValue) {\n    final Double doubleObject = getDouble(map, key);\n    if (doubleObject == null) {\n        return defaultValue;\n    }\n    return doubleObject.doubleValue();\n}"
            ],
            [
                "toProperties",
                "org.apache.commons.collections4",
                "MapUtils",
                "// Conversion methods\n//-------------------------------------------------------------------------\n/**\n * Gets a new Properties object initialised with the values from a Map.\n * A null input will return an empty properties object.\n * <p>\n * A Properties object may only store non-null keys and values, thus if\n * the provided map contains either a key or value which is {@code null},\n * a {@link NullPointerException} will be thrown.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to convert to a Properties object\n * @return the properties object\n * @throws NullPointerException if a key or value in the provided map is {@code null}\n */\npublic static <K, V> Properties toProperties(final Map<K, V> map) {\n    final Properties answer = new Properties();\n    if (map != null) {\n        for (final Entry<K, V> entry2 : map.entrySet()) {\n            final Map.Entry<?, ?> entry = entry2;\n            final Object key = entry.getKey();\n            final Object value = entry.getValue();\n            answer.put(key, value);\n        }\n    }\n    return answer;\n}"
            ],
            [
                "toMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Creates a new HashMap using data copied from a ResourceBundle.\n *\n * @param resourceBundle  the resource bundle to convert, may not be null\n * @return the hashmap containing the data\n * @throws NullPointerException if the bundle is null\n */\npublic static Map<String, Object> toMap(final ResourceBundle resourceBundle) {\n    final Enumeration<String> enumeration = resourceBundle.getKeys();\n    final Map<String, Object> map = new HashMap<String, Object>();\n    while (enumeration.hasMoreElements()) {\n        final String key = enumeration.nextElement();\n        final Object value = resourceBundle.getObject(key);\n        map.put(key, value);\n    }\n    return map;\n}"
            ],
            [
                "invertMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "// Misc\n//-----------------------------------------------------------------------\n/**\n * Inverts the supplied map returning a new HashMap such that the keys of\n * the input are swapped with the values.\n * <p>\n * This operation assumes that the inverse mapping is well defined.\n * If the input map had multiple entries with the same value mapped to\n * different keys, the returned map will map one of those keys to the\n * value, but the exact key which will be mapped is undefined.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to invert, may not be null\n * @return a new HashMap containing the inverted data\n * @throws NullPointerException if the map is null\n */\npublic static <K, V> Map<V, K> invertMap(final Map<K, V> map) {\n    final Map<V, K> out = new HashMap<V, K>(map.size());\n    for (final Entry<K, V> entry : map.entrySet()) {\n        out.put(entry.getValue(), entry.getKey());\n    }\n    return out;\n}"
            ],
            [
                "putAll",
                "org.apache.commons.collections4",
                "MapUtils",
                "//-----------------------------------------------------------------------\n/**\n * Puts all the keys and values from the specified array into the map.\n * <p>\n * This method is an alternative to the {@link java.util.Map#putAll(java.util.Map)}\n * method and constructors. It allows you to build a map from an object array\n * of various possible styles.\n * <p>\n * If the first entry in the object array implements {@link java.util.Map.Entry}\n * or {@link KeyValue} then the key and value are added from that object.\n * If the first entry in the object array is an object array itself, then\n * it is assumed that index 0 in the sub-array is the key and index 1 is the value.\n * Otherwise, the array is treated as keys and values in alternate indices.\n * <p>\n * For example, to create a color map:\n * <pre>\n * Map colorMap = MapUtils.putAll(new HashMap(), new String[][] {\n *     {\"RED\", \"#FF0000\"},\n *     {\"GREEN\", \"#00FF00\"},\n *     {\"BLUE\", \"#0000FF\"}\n * });\n * </pre>\n * or:\n * <pre>\n * Map colorMap = MapUtils.putAll(new HashMap(), new String[] {\n *     \"RED\", \"#FF0000\",\n *     \"GREEN\", \"#00FF00\",\n *     \"BLUE\", \"#0000FF\"\n * });\n * </pre>\n * or:\n * <pre>\n * Map colorMap = MapUtils.putAll(new HashMap(), new Map.Entry[] {\n *     new DefaultMapEntry(\"RED\", \"#FF0000\"),\n *     new DefaultMapEntry(\"GREEN\", \"#00FF00\"),\n *     new DefaultMapEntry(\"BLUE\", \"#0000FF\")\n * });\n * </pre>\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to populate, must not be null\n * @param array  an array to populate from, null ignored\n * @return the input map\n * @throws NullPointerException  if map is null\n * @throws IllegalArgumentException  if sub-array or entry matching used and an entry is invalid\n * @throws ClassCastException if the array contents is mixed\n * @since 3.2\n */\n// As per Javadoc throws CCE for invalid array contents\n@SuppressWarnings(\"unchecked\")\npublic static <K, V> Map<K, V> putAll(final Map<K, V> map, final Object[] array) {\n    if (map == null) {\n        throw new NullPointerException(\"The map must not be null\");\n    }\n    if (array == null || array.length == 0) {\n        return map;\n    }\n    final Object obj = array[0];\n    if (obj instanceof Map.Entry) {\n        for (final Object element : array) {\n            // cast ok here, type is checked above\n            final Map.Entry<K, V> entry = (Map.Entry<K, V>) element;\n            map.put(entry.getKey(), entry.getValue());\n        }\n    } else if (obj instanceof KeyValue) {\n        for (final Object element : array) {\n            // cast ok here, type is checked above\n            final KeyValue<K, V> keyval = (KeyValue<K, V>) element;\n            map.put(keyval.getKey(), keyval.getValue());\n        }\n    } else if (obj instanceof Object[]) {\n        for (int i = 0; i < array.length; i++) {\n            final Object[] sub = (Object[]) array[i];\n            if (sub == null || sub.length < 2) {\n                throw new IllegalArgumentException(\"Invalid array element: \" + i);\n            }\n            // these casts can fail if array has incorrect types\n            map.put((K) sub[0], (V) sub[1]);\n        }\n    } else {\n        for (int i = 0; i < array.length - 1; ) {\n            // these casts can fail if array has incorrect types\n            map.put((K) array[i++], (V) array[i++]);\n        }\n    }\n    return map;\n}"
            ],
            [
                "emptyIfNull",
                "org.apache.commons.collections4",
                "MapUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns an immutable empty map if the argument is <code>null</code>,\n * or the argument itself otherwise.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map the map, possibly <code>null</code>\n * @return an empty map if the argument is <code>null</code>\n */\npublic static <K, V> Map<K, V> emptyIfNull(final Map<K, V> map) {\n    return map == null ? Collections.<K, V>emptyMap() : map;\n}"
            ],
            [
                "isEmpty",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Null-safe check if the specified map is empty.\n * <p>\n * Null returns true.\n *\n * @param map  the map to check, may be null\n * @return true if empty or null\n * @since 3.2\n */\npublic static boolean isEmpty(final Map<?, ?> map) {\n    return map == null || map.isEmpty();\n}"
            ],
            [
                "isNotEmpty",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Null-safe check if the specified map is not empty.\n * <p>\n * Null returns false.\n *\n * @param map  the map to check, may be null\n * @return true if non-null and non-empty\n * @since 3.2\n */\npublic static boolean isNotEmpty(final Map<?, ?> map) {\n    return !MapUtils.isEmpty(map);\n}"
            ],
            [
                "synchronizedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "// Map decorators\n//-----------------------------------------------------------------------\n/**\n * Returns a synchronized map backed by the given map.\n * <p>\n * You must manually synchronize on the returned buffer's iterator to\n * avoid non-deterministic behavior:\n *\n * <pre>\n * Map m = MapUtils.synchronizedMap(myMap);\n * Set s = m.keySet();  // outside synchronized block\n * synchronized (m) {  // synchronized on MAP!\n *     Iterator i = s.iterator();\n *     while (i.hasNext()) {\n *         process (i.next());\n *     }\n * }\n * </pre>\n *\n * This method uses the implementation in {@link java.util.Collections Collections}.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to synchronize, must not be null\n * @return a synchronized map backed by the given map\n */\npublic static <K, V> Map<K, V> synchronizedMap(final Map<K, V> map) {\n    return Collections.synchronizedMap(map);\n}"
            ],
            [
                "unmodifiableMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns an unmodifiable map backed by the given map.\n * <p>\n * This method uses the implementation in the decorators subpackage.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to make unmodifiable, must not be null\n * @return an unmodifiable map backed by the given map\n * @throws NullPointerException  if the map is null\n */\npublic static <K, V> Map<K, V> unmodifiableMap(final Map<? extends K, ? extends V> map) {\n    return UnmodifiableMap.unmodifiableMap(map);\n}"
            ],
            [
                "predicatedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a predicated (validating) map backed by the given map.\n * <p>\n * Only objects that pass the tests in the given predicates can be added to the map.\n * Trying to add an invalid object results in an IllegalArgumentException.\n * Keys must pass the key predicate, values must pass the value predicate.\n * It is important not to use the original map after invoking this method,\n * as it is a backdoor for adding invalid objects.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to predicate, must not be null\n * @param keyPred  the predicate for keys, null means no check\n * @param valuePred  the predicate for values, null means no check\n * @return a predicated map backed by the given map\n * @throws NullPointerException  if the Map is null\n */\npublic static <K, V> IterableMap<K, V> predicatedMap(final Map<K, V> map, final Predicate<? super K> keyPred, final Predicate<? super V> valuePred) {\n    return PredicatedMap.predicatedMap(map, keyPred, valuePred);\n}"
            ],
            [
                "transformedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a transformed map backed by the given map.\n * <p>\n * This method returns a new map (decorating the specified map) that\n * will transform any new entries added to it.\n * Existing entries in the specified map will not be transformed.\n * If you want that behaviour, see {@link TransformedMap#transformedMap}.\n * <p>\n * Each object is passed through the transformers as it is added to the\n * Map. It is important not to use the original map after invoking this\n * method, as it is a backdoor for adding untransformed objects.\n * <p>\n * If there are any elements already in the map being decorated, they\n * are NOT transformed.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to transform, must not be null, typically empty\n * @param keyTransformer  the transformer for the map keys, null means no transformation\n * @param valueTransformer  the transformer for the map values, null means no transformation\n * @return a transformed map backed by the given map\n * @throws NullPointerException  if the Map is null\n */\npublic static <K, V> IterableMap<K, V> transformedMap(final Map<K, V> map, final Transformer<? super K, ? extends K> keyTransformer, final Transformer<? super V, ? extends V> valueTransformer) {\n    return TransformedMap.transformingMap(map, keyTransformer, valueTransformer);\n}"
            ],
            [
                "fixedSizeMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a fixed-sized map backed by the given map.\n * Elements may not be added or removed from the returned map, but\n * existing elements can be changed (for instance, via the\n * {@link Map#put(Object,Object)} method).\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map whose size to fix, must not be null\n * @return a fixed-size map backed by that map\n * @throws NullPointerException  if the Map is null\n */\npublic static <K, V> IterableMap<K, V> fixedSizeMap(final Map<K, V> map) {\n    return FixedSizeMap.fixedSizeMap(map);\n}"
            ],
            [
                "lazyMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a \"lazy\" map whose values will be created on demand.\n * <p>\n * When the key passed to the returned map's {@link Map#get(Object)}\n * method is not present in the map, then the factory will be used\n * to create a new object and that object will become the value\n * associated with that key.\n * <p>\n * For instance:\n * <pre>\n * Factory factory = new Factory() {\n *     public Object create() {\n *         return new Date();\n *     }\n * }\n * Map lazyMap = MapUtils.lazyMap(new HashMap(), factory);\n * Object obj = lazyMap.get(\"test\");\n * </pre>\n *\n * After the above code is executed, <code>obj</code> will contain\n * a new <code>Date</code> instance.  Furthermore, that <code>Date</code>\n * instance is the value for the <code>\"test\"</code> key in the map.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to make lazy, must not be null\n * @param factory  the factory for creating new objects, must not be null\n * @return a lazy map backed by the given map\n * @throws NullPointerException  if the Map or Factory is null\n */\npublic static <K, V> IterableMap<K, V> lazyMap(final Map<K, V> map, final Factory<? extends V> factory) {\n    return LazyMap.lazyMap(map, factory);\n}"
            ],
            [
                "lazyMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a \"lazy\" map whose values will be created on demand.\n * <p>\n * When the key passed to the returned map's {@link Map#get(Object)}\n * method is not present in the map, then the factory will be used\n * to create a new object and that object will become the value\n * associated with that key. The factory is a {@link Transformer}\n * that will be passed the key which it must transform into the value.\n * <p>\n * For instance:\n * <pre>\n * Transformer factory = new Transformer() {\n *     public Object transform(Object mapKey) {\n *         return new File(mapKey);\n *     }\n * }\n * Map lazyMap = MapUtils.lazyMap(new HashMap(), factory);\n * Object obj = lazyMap.get(\"C:/dev\");\n * </pre>\n *\n * After the above code is executed, <code>obj</code> will contain\n * a new <code>File</code> instance for the C drive dev directory.\n * Furthermore, that <code>File</code> instance is the value for the\n * <code>\"C:/dev\"</code> key in the map.\n * <p>\n * If a lazy map is wrapped by a synchronized map, the result is a simple\n * synchronized cache. When an object is not is the cache, the cache itself\n * calls back to the factory Transformer to populate itself, all within the\n * same synchronized block.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to make lazy, must not be null\n * @param transformerFactory  the factory for creating new objects, must not be null\n * @return a lazy map backed by the given map\n * @throws NullPointerException  if the Map or Transformer is null\n */\npublic static <K, V> IterableMap<K, V> lazyMap(final Map<K, V> map, final Transformer<? super K, ? extends V> transformerFactory) {\n    return LazyMap.lazyMap(map, transformerFactory);\n}"
            ],
            [
                "orderedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a map that maintains the order of keys that are added\n * backed by the given map.\n * <p>\n * If a key is added twice, the order is determined by the first add.\n * The order is observed through the keySet, values and entrySet.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to order, must not be null\n * @return an ordered map backed by the given map\n * @throws NullPointerException  if the Map is null\n */\npublic static <K, V> OrderedMap<K, V> orderedMap(final Map<K, V> map) {\n    return ListOrderedMap.listOrderedMap(map);\n}"
            ],
            [
                "multiValueMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Creates a mult-value map backed by the given map which returns\n * collections of type ArrayList.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate\n * @return a multi-value map backed by the given map which returns ArrayLists of values.\n * @see MultiValueMap\n * @since 3.2\n * @deprecated since 4.1, use {@link MultiValuedMap} instead\n */\n@Deprecated\npublic static <K, V> MultiValueMap<K, V> multiValueMap(final Map<K, ? super Collection<V>> map) {\n    return MultiValueMap.<K, V>multiValueMap(map);\n}"
            ],
            [
                "multiValueMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Creates a multi-value map backed by the given map which returns\n * collections of the specified type.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param <C>  the collection class type\n * @param map  the map to decorate\n * @param collectionClass  the type of collections to return from the map\n *   (must contain public no-arg constructor and extend Collection)\n * @return a multi-value map backed by the given map which returns collections of the specified type\n * @see MultiValueMap\n * @since 3.2\n * @deprecated since 4.1, use {@link MultiValuedMap} instead\n */\n@Deprecated\npublic static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(final Map<K, C> map, final Class<C> collectionClass) {\n    return MultiValueMap.multiValueMap(map, collectionClass);\n}"
            ],
            [
                "multiValueMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Creates a multi-value map backed by the given map which returns\n * collections created by the specified collection factory.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param <C>  the collection class type\n * @param map  the map to decorate\n * @param collectionFactory  a factor which creates collection objects\n * @return a multi-value map backed by the given map which returns collections\n *   created by the specified collection factory\n * @see MultiValueMap\n * @since 3.2\n * @deprecated since 4.1, use {@link MultiValuedMap} instead\n */\n@Deprecated\npublic static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(final Map<K, C> map, final Factory<C> collectionFactory) {\n    return MultiValueMap.multiValueMap(map, collectionFactory);\n}"
            ],
            [
                "synchronizedSortedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "// SortedMap decorators\n//-----------------------------------------------------------------------\n/**\n * Returns a synchronized sorted map backed by the given sorted map.\n * <p>\n * You must manually synchronize on the returned buffer's iterator to\n * avoid non-deterministic behavior:\n *\n * <pre>\n * Map m = MapUtils.synchronizedSortedMap(myMap);\n * Set s = m.keySet();  // outside synchronized block\n * synchronized (m) {  // synchronized on MAP!\n *     Iterator i = s.iterator();\n *     while (i.hasNext()) {\n *         process (i.next());\n *     }\n * }\n * </pre>\n *\n * This method uses the implementation in {@link java.util.Collections Collections}.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to synchronize, must not be null\n * @return a synchronized map backed by the given map\n * @throws NullPointerException  if the map is null\n */\npublic static <K, V> SortedMap<K, V> synchronizedSortedMap(final SortedMap<K, V> map) {\n    return Collections.synchronizedSortedMap(map);\n}"
            ],
            [
                "unmodifiableSortedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns an unmodifiable sorted map backed by the given sorted map.\n * <p>\n * This method uses the implementation in the decorators subpackage.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the sorted map to make unmodifiable, must not be null\n * @return an unmodifiable map backed by the given map\n * @throws NullPointerException  if the map is null\n */\npublic static <K, V> SortedMap<K, V> unmodifiableSortedMap(final SortedMap<K, ? extends V> map) {\n    return UnmodifiableSortedMap.unmodifiableSortedMap(map);\n}"
            ],
            [
                "predicatedSortedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a predicated (validating) sorted map backed by the given map.\n * <p>\n * Only objects that pass the tests in the given predicates can be added to the map.\n * Trying to add an invalid object results in an IllegalArgumentException.\n * Keys must pass the key predicate, values must pass the value predicate.\n * It is important not to use the original map after invoking this method,\n * as it is a backdoor for adding invalid objects.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to predicate, must not be null\n * @param keyPred  the predicate for keys, null means no check\n * @param valuePred  the predicate for values, null means no check\n * @return a predicated map backed by the given map\n * @throws NullPointerException  if the SortedMap is null\n */\npublic static <K, V> SortedMap<K, V> predicatedSortedMap(final SortedMap<K, V> map, final Predicate<? super K> keyPred, final Predicate<? super V> valuePred) {\n    return PredicatedSortedMap.predicatedSortedMap(map, keyPred, valuePred);\n}"
            ],
            [
                "transformedSortedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a transformed sorted map backed by the given map.\n * <p>\n * This method returns a new sorted map (decorating the specified map) that\n * will transform any new entries added to it.\n * Existing entries in the specified map will not be transformed.\n * If you want that behaviour, see {@link TransformedSortedMap#transformedSortedMap}.\n * <p>\n * Each object is passed through the transformers as it is added to the\n * Map. It is important not to use the original map after invoking this\n * method, as it is a backdoor for adding untransformed objects.\n * <p>\n * If there are any elements already in the map being decorated, they\n * are NOT transformed.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to transform, must not be null, typically empty\n * @param keyTransformer  the transformer for the map keys, null means no transformation\n * @param valueTransformer  the transformer for the map values, null means no transformation\n * @return a transformed map backed by the given map\n * @throws NullPointerException  if the SortedMap is null\n */\npublic static <K, V> SortedMap<K, V> transformedSortedMap(final SortedMap<K, V> map, final Transformer<? super K, ? extends K> keyTransformer, final Transformer<? super V, ? extends V> valueTransformer) {\n    return TransformedSortedMap.transformingSortedMap(map, keyTransformer, valueTransformer);\n}"
            ],
            [
                "fixedSizeSortedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a fixed-sized sorted map backed by the given sorted map.\n * Elements may not be added or removed from the returned map, but\n * existing elements can be changed (for instance, via the\n * {@link Map#put(Object,Object)} method).\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map whose size to fix, must not be null\n * @return a fixed-size map backed by that map\n * @throws NullPointerException  if the SortedMap is null\n */\npublic static <K, V> SortedMap<K, V> fixedSizeSortedMap(final SortedMap<K, V> map) {\n    return FixedSizeSortedMap.fixedSizeSortedMap(map);\n}"
            ],
            [
                "lazySortedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a \"lazy\" sorted map whose values will be created on demand.\n * <p>\n * When the key passed to the returned map's {@link Map#get(Object)}\n * method is not present in the map, then the factory will be used\n * to create a new object and that object will become the value\n * associated with that key.\n * <p>\n * For instance:\n *\n * <pre>\n * Factory factory = new Factory() {\n *     public Object create() {\n *         return new Date();\n *     }\n * }\n * SortedMap lazy = MapUtils.lazySortedMap(new TreeMap(), factory);\n * Object obj = lazy.get(\"test\");\n * </pre>\n *\n * After the above code is executed, <code>obj</code> will contain\n * a new <code>Date</code> instance.  Furthermore, that <code>Date</code>\n * instance is the value for the <code>\"test\"</code> key.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to make lazy, must not be null\n * @param factory  the factory for creating new objects, must not be null\n * @return a lazy map backed by the given map\n * @throws NullPointerException  if the SortedMap or Factory is null\n */\npublic static <K, V> SortedMap<K, V> lazySortedMap(final SortedMap<K, V> map, final Factory<? extends V> factory) {\n    return LazySortedMap.lazySortedMap(map, factory);\n}"
            ],
            [
                "lazySortedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a \"lazy\" sorted map whose values will be created on demand.\n * <p>\n * When the key passed to the returned map's {@link Map#get(Object)}\n * method is not present in the map, then the factory will be used\n * to create a new object and that object will become the value\n * associated with that key. The factory is a {@link Transformer}\n * that will be passed the key which it must transform into the value.\n * <p>\n * For instance:\n * <pre>\n * Transformer factory = new Transformer() {\n *     public Object transform(Object mapKey) {\n *         return new File(mapKey);\n *     }\n * }\n * SortedMap lazy = MapUtils.lazySortedMap(new TreeMap(), factory);\n * Object obj = lazy.get(\"C:/dev\");\n * </pre>\n *\n * After the above code is executed, <code>obj</code> will contain\n * a new <code>File</code> instance for the C drive dev directory.\n * Furthermore, that <code>File</code> instance is the value for the\n * <code>\"C:/dev\"</code> key in the map.\n * <p>\n * If a lazy map is wrapped by a synchronized map, the result is a simple\n * synchronized cache. When an object is not is the cache, the cache itself\n * calls back to the factory Transformer to populate itself, all within the\n * same synchronized block.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to make lazy, must not be null\n * @param transformerFactory  the factory for creating new objects, must not be null\n * @return a lazy map backed by the given map\n * @throws NullPointerException  if the Map or Transformer is null\n */\npublic static <K, V> SortedMap<K, V> lazySortedMap(final SortedMap<K, V> map, final Transformer<? super K, ? extends V> transformerFactory) {\n    return LazySortedMap.lazySortedMap(map, transformerFactory);\n}"
            ],
            [
                "iterableMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Get the specified {@link Map} as an {@link IterableMap}.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map to wrap if necessary.\n * @return IterableMap<K, V>\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> IterableMap<K, V> iterableMap(final Map<K, V> map) {\n    if (map == null) {\n        throw new NullPointerException(\"Map must not be null\");\n    }\n    return map instanceof IterableMap ? (IterableMap<K, V>) map : new AbstractMapDecorator<K, V>(map) {\n    };\n}"
            ],
            [
                "iterableSortedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Get the specified {@link SortedMap} as an {@link IterableSortedMap}.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param sortedMap to wrap if necessary\n * @return {@link IterableSortedMap}<K, V>\n * @throws NullPointerException if sortedMap is null\n * @since 4.0\n */\npublic static <K, V> IterableSortedMap<K, V> iterableSortedMap(final SortedMap<K, V> sortedMap) {\n    if (sortedMap == null) {\n        throw new NullPointerException(\"Map must not be null\");\n    }\n    return sortedMap instanceof IterableSortedMap ? (IterableSortedMap<K, V>) sortedMap : new AbstractSortedMapDecorator<K, V>(sortedMap) {\n    };\n}"
            ],
            [
                "defaultEquator",
                "org.apache.commons.collections4.functors",
                "DefaultEquator",
                "/**\n * Factory returning the typed singleton instance.\n *\n * @param <T>  the object type\n * @return the singleton instance\n */\n// the static instance works for all types\n@SuppressWarnings(\"unchecked\")\npublic static <T> DefaultEquator<T> defaultEquator() {\n    return (DefaultEquator<T>) DefaultEquator.INSTANCE;\n}"
            ],
            [
                "stringValueTransformer",
                "org.apache.commons.collections4.functors",
                "StringValueTransformer",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <T>  the input type\n * @return the singleton instance\n * @since 3.1\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Transformer<T, String> stringValueTransformer() {\n    return (Transformer<T, String>) INSTANCE;\n}"
            ],
            [
                "ifTransformer",
                "org.apache.commons.collections4.functors",
                "IfTransformer",
                "/**\n * Factory method that performs validation.\n *\n * @param <I>  input type for the transformer\n * @param <O>  output type for the transformer\n * @param predicate  predicate to switch on\n * @param trueTransformer  transformer used if true\n * @param falseTransformer  transformer used if false\n * @return the <code>if</code> transformer\n * @throws NullPointerException if either argument is null\n */\npublic static <I, O> Transformer<I, O> ifTransformer(final Predicate<? super I> predicate, final Transformer<? super I, ? extends O> trueTransformer, final Transformer<? super I, ? extends O> falseTransformer) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    if (trueTransformer == null || falseTransformer == null) {\n        throw new NullPointerException(\"Transformers must not be null\");\n    }\n    return new IfTransformer<I, O>(predicate, trueTransformer, falseTransformer);\n}"
            ],
            [
                "ifTransformer",
                "org.apache.commons.collections4.functors",
                "IfTransformer",
                "/**\n * Factory method that performs validation.\n * <p>\n * This factory creates a transformer that just returns the input object when\n * the predicate is false.\n *\n * @param <T>  input and output type for the transformer\n * @param predicate  predicate to switch on\n * @param trueTransformer  transformer used if true\n * @return the <code>if</code> transformer\n * @throws NullPointerException if either argument is null\n */\npublic static <T> Transformer<T, T> ifTransformer(final Predicate<? super T> predicate, final Transformer<? super T, ? extends T> trueTransformer) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    if (trueTransformer == null) {\n        throw new NullPointerException(\"Transformer must not be null\");\n    }\n    return new IfTransformer<T, T>(predicate, trueTransformer, NOPTransformer.<T>nopTransformer());\n}"
            ],
            [
                "identityPredicate",
                "org.apache.commons.collections4.functors",
                "IdentityPredicate",
                "/**\n * Factory to create the identity predicate.\n *\n * @param <T> the type that the predicate queries\n * @param object  the object to compare to\n * @return the predicate\n */\npublic static <T> Predicate<T> identityPredicate(final T object) {\n    if (object == null) {\n        return NullPredicate.<T>nullPredicate();\n    }\n    return new IdentityPredicate<T>(object);\n}"
            ],
            [
                "exceptionClosure",
                "org.apache.commons.collections4.functors",
                "ExceptionClosure",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <E> the type that the closure acts on\n * @return the singleton instance\n * @since 3.1\n */\n// the static instance works for all types\n@SuppressWarnings(\"unchecked\")\npublic static <E> Closure<E> exceptionClosure() {\n    return (Closure<E>) INSTANCE;\n}"
            ],
            [
                "nopClosure",
                "org.apache.commons.collections4.functors",
                "NOPClosure",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <E> the type that the closure acts on\n * @return the singleton instance\n * @since 3.1\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Closure<E> nopClosure() {\n    return (Closure<E>) INSTANCE;\n}"
            ],
            [
                "closureTransformer",
                "org.apache.commons.collections4.functors",
                "ClosureTransformer",
                "/**\n * Factory method that performs validation.\n *\n * @param <T>  the type of the object to transform\n * @param closure  the closure to call, not null\n * @return the <code>closure</code> transformer\n * @throws NullPointerException if the closure is null\n */\npublic static <T> Transformer<T, T> closureTransformer(final Closure<? super T> closure) {\n    if (closure == null) {\n        throw new NullPointerException(\"Closure must not be null\");\n    }\n    return new ClosureTransformer<T>(closure);\n}"
            ],
            [
                "copy",
                "org.apache.commons.collections4.functors",
                "FunctorUtils",
                "/**\n * Clone the predicates to ensure that the internal reference can't be messed with.\n * Due to the {@link Predicate#evaluate(T)} method, Predicate<? super T> is\n * able to be coerced to Predicate<T> without casting issues.\n *\n * @param predicates  the predicates to copy\n * @return the cloned predicates\n */\n@SuppressWarnings(\"unchecked\")\nstatic <T> Predicate<T>[] copy(final Predicate<? super T>... predicates) {\n    if (predicates == null) {\n        return null;\n    }\n    return (Predicate<T>[]) predicates.clone();\n}"
            ],
            [
                "coerce",
                "org.apache.commons.collections4.functors",
                "FunctorUtils",
                "/**\n * A very simple method that coerces Predicate<? super T> to Predicate<T>.\n * Due to the {@link Predicate#evaluate(T)} method, Predicate<? super T> is\n * able to be coerced to Predicate<T> without casting issues.\n * <p>This method exists\n * simply as centralised documentation and atomic unchecked warning\n * suppression.\n *\n * @param <T> the type of object the returned predicate should \"accept\"\n * @param predicate the predicate to coerce.\n * @return the coerced predicate.\n */\n@SuppressWarnings(\"unchecked\")\nstatic <T> Predicate<T> coerce(final Predicate<? super T> predicate) {\n    return (Predicate<T>) predicate;\n}"
            ],
            [
                "validate",
                "org.apache.commons.collections4.functors",
                "FunctorUtils",
                "/**\n * Validate the predicates to ensure that all is well.\n *\n * @param predicates  the predicates to validate\n * @return predicate array\n */\nstatic <T> Predicate<? super T>[] validate(final Collection<? extends Predicate<? super T>> predicates) {\n    if (predicates == null) {\n        throw new NullPointerException(\"The predicate collection must not be null\");\n    }\n    // convert to array like this to guarantee iterator() ordering\n    // OK\n    @SuppressWarnings(\"unchecked\")\n    final Predicate<? super T>[] preds = new Predicate[predicates.size()];\n    int i = 0;\n    for (final Predicate<? super T> predicate : predicates) {\n        preds[i] = predicate;\n        if (preds[i] == null) {\n            throw new NullPointerException(\"The predicate collection must not contain a null predicate, index \" + i + \" was null\");\n        }\n        i++;\n    }\n    return preds;\n}"
            ],
            [
                "copy",
                "org.apache.commons.collections4.functors",
                "FunctorUtils",
                "/**\n * Clone the closures to ensure that the internal reference can't be messed with.\n *\n * @param closures  the closures to copy\n * @return the cloned closures\n */\n@SuppressWarnings(\"unchecked\")\nstatic <E> Closure<E>[] copy(final Closure<? super E>... closures) {\n    if (closures == null) {\n        return null;\n    }\n    return (Closure<E>[]) closures.clone();\n}"
            ],
            [
                "coerce",
                "org.apache.commons.collections4.functors",
                "FunctorUtils",
                "/**\n * A very simple method that coerces Closure<? super T> to Closure<T>.\n * <p>This method exists\n * simply as centralised documentation and atomic unchecked warning\n * suppression.\n *\n * @param <T> the type of object the returned closure should \"accept\"\n * @param closure the closure to coerce.\n * @return the coerced closure.\n */\n@SuppressWarnings(\"unchecked\")\nstatic <T> Closure<T> coerce(final Closure<? super T> closure) {\n    return (Closure<T>) closure;\n}"
            ],
            [
                "copy",
                "org.apache.commons.collections4.functors",
                "FunctorUtils",
                "/**\n * Copy method\n *\n * @param transformers  the transformers to copy\n * @return a clone of the transformers\n */\n@SuppressWarnings(\"unchecked\")\nstatic <I, O> Transformer<I, O>[] copy(final Transformer<? super I, ? extends O>... transformers) {\n    if (transformers == null) {\n        return null;\n    }\n    return (Transformer<I, O>[]) transformers.clone();\n}"
            ],
            [
                "coerce",
                "org.apache.commons.collections4.functors",
                "FunctorUtils",
                "/**\n * A very simple method that coerces Transformer<? super I, ? extends O> to Transformer<I, O>.\n * <p>This method exists\n * simply as centralised documentation and atomic unchecked warning\n * suppression.\n *\n * @param <T> the type of object the returned transformer should \"accept\"\n * @param transformer the transformer to coerce.\n * @return the coerced transformer.\n */\n@SuppressWarnings(\"unchecked\")\nstatic <I, O> Transformer<I, O> coerce(final Transformer<? super I, ? extends O> transformer) {\n    return (Transformer<I, O>) transformer;\n}"
            ],
            [
                "transformerPredicate",
                "org.apache.commons.collections4.functors",
                "TransformerPredicate",
                "/**\n * Factory to create the predicate.\n *\n * @param <T> the type that the predicate queries\n * @param transformer  the transformer to decorate\n * @return the predicate\n * @throws NullPointerException if the transformer is null\n */\npublic static <T> Predicate<T> transformerPredicate(final Transformer<? super T, Boolean> transformer) {\n    if (transformer == null) {\n        throw new NullPointerException(\"The transformer to call must not be null\");\n    }\n    return new TransformerPredicate<T>(transformer);\n}"
            ],
            [
                "nullPredicate",
                "org.apache.commons.collections4.functors",
                "NullPredicate",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <T> the type that the predicate queries\n * @return the singleton instance\n * @since 3.1\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Predicate<T> nullPredicate() {\n    return (Predicate<T>) INSTANCE;\n}"
            ],
            [
                "nullTransformer",
                "org.apache.commons.collections4.functors",
                "ConstantTransformer",
                "/**\n * Get a typed null instance.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @return Transformer<I, O> that always returns null.\n */\n// The null transformer works for all object types\n@SuppressWarnings(\"unchecked\")\npublic static <I, O> Transformer<I, O> nullTransformer() {\n    return (Transformer<I, O>) NULL_INSTANCE;\n}"
            ],
            [
                "constantTransformer",
                "org.apache.commons.collections4.functors",
                "ConstantTransformer",
                "/**\n * Transformer method that performs validation.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param constantToReturn  the constant object to return each time in the factory\n * @return the <code>constant</code> factory.\n */\npublic static <I, O> Transformer<I, O> constantTransformer(final O constantToReturn) {\n    if (constantToReturn == null) {\n        return nullTransformer();\n    }\n    return new ConstantTransformer<I, O>(constantToReturn);\n}"
            ],
            [
                "predicateTransformer",
                "org.apache.commons.collections4.functors",
                "PredicateTransformer",
                "/**\n * Factory method that performs validation.\n *\n * @param <T>  the input type\n * @param predicate  the predicate to call, not null\n * @return the <code>predicate</code> transformer\n * @throws IllegalArgumentException if the predicate is null\n */\npublic static <T> Transformer<T, Boolean> predicateTransformer(final Predicate<? super T> predicate) {\n    if (predicate == null) {\n        throw new IllegalArgumentException(\"Predicate must not be null\");\n    }\n    return new PredicateTransformer<T>(predicate);\n}"
            ],
            [
                "whileClosure",
                "org.apache.commons.collections4.functors",
                "WhileClosure",
                "/**\n * Factory method that performs validation.\n *\n * @param <E> the type that the closure acts on\n * @param predicate  the predicate used to evaluate when the loop terminates, not null\n * @param closure  the closure the execute, not null\n * @param doLoop  true to act as a do-while loop, always executing the closure once\n * @return the <code>while</code> closure\n * @throws NullPointerException if the predicate or closure is null\n */\npublic static <E> Closure<E> whileClosure(final Predicate<? super E> predicate, final Closure<? super E> closure, final boolean doLoop) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    if (closure == null) {\n        throw new NullPointerException(\"Closure must not be null\");\n    }\n    return new WhileClosure<E>(predicate, closure, doLoop);\n}"
            ],
            [
                "forClosure",
                "org.apache.commons.collections4.functors",
                "ForClosure",
                "/**\n * Factory method that performs validation.\n * <p>\n * A null closure or zero count returns the <code>NOPClosure</code>.\n * A count of one returns the specified closure.\n *\n * @param <E> the type that the closure acts on\n * @param count  the number of times to execute the closure\n * @param closure  the closure to execute, not null\n * @return the <code>for</code> closure\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Closure<E> forClosure(final int count, final Closure<? super E> closure) {\n    if (count <= 0 || closure == null) {\n        return NOPClosure.<E>nopClosure();\n    }\n    if (count == 1) {\n        return (Closure<E>) closure;\n    }\n    return new ForClosure<E>(count, closure);\n}"
            ],
            [
                "nullIsTruePredicate",
                "org.apache.commons.collections4.functors",
                "NullIsTruePredicate",
                "/**\n * Factory to create the null true predicate.\n *\n * @param <T> the type that the predicate queries\n * @param predicate  the predicate to decorate, not null\n * @return the predicate\n * @throws NullPointerException if the predicate is null\n */\npublic static <T> Predicate<T> nullIsTruePredicate(final Predicate<? super T> predicate) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    return new NullIsTruePredicate<T>(predicate);\n}"
            ],
            [
                "transformedPredicate",
                "org.apache.commons.collections4.functors",
                "TransformedPredicate",
                "/**\n * Factory to create the predicate.\n *\n * @param <T> the type that the predicate queries\n * @param transformer  the transformer to call\n * @param predicate  the predicate to call with the result of the transform\n * @return the predicate\n * @throws NullPointerException if the transformer or the predicate is null\n */\npublic static <T> Predicate<T> transformedPredicate(final Transformer<? super T, ? extends T> transformer, final Predicate<? super T> predicate) {\n    if (transformer == null) {\n        throw new NullPointerException(\"The transformer to call must not be null\");\n    }\n    if (predicate == null) {\n        throw new NullPointerException(\"The predicate to call must not be null\");\n    }\n    return new TransformedPredicate<T>(transformer, predicate);\n}"
            ],
            [
                "nonePredicate",
                "org.apache.commons.collections4.functors",
                "NonePredicate",
                "/**\n * Factory to create the predicate.\n * <p>\n * If the array is size zero, the predicate always returns true.\n *\n * @param <T> the type that the predicate queries\n * @param predicates  the predicates to check, cloned, not null\n * @return the <code>any</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n */\npublic static <T> Predicate<T> nonePredicate(final Predicate<? super T>... predicates) {\n    FunctorUtils.validate(predicates);\n    if (predicates.length == 0) {\n        return TruePredicate.<T>truePredicate();\n    }\n    return new NonePredicate<T>(FunctorUtils.copy(predicates));\n}"
            ],
            [
                "nonePredicate",
                "org.apache.commons.collections4.functors",
                "NonePredicate",
                "/**\n * Factory to create the predicate.\n * <p>\n * If the collection is size zero, the predicate always returns true.\n *\n * @param <T> the type that the predicate queries\n * @param predicates  the predicates to check, cloned, not null\n * @return the <code>one</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n */\npublic static <T> Predicate<T> nonePredicate(final Collection<? extends Predicate<? super T>> predicates) {\n    final Predicate<? super T>[] preds = FunctorUtils.validate(predicates);\n    if (preds.length == 0) {\n        return TruePredicate.<T>truePredicate();\n    }\n    return new NonePredicate<T>(preds);\n}"
            ],
            [
                "exceptionTransformer",
                "org.apache.commons.collections4.functors",
                "ExceptionTransformer",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @return the singleton instance\n * @since 3.1\n */\n// the static instance works for all types\n@SuppressWarnings(\"unchecked\")\npublic static <I, O> Transformer<I, O> exceptionTransformer() {\n    return (Transformer<I, O>) INSTANCE;\n}"
            ],
            [
                "switchTransformer",
                "org.apache.commons.collections4.functors",
                "SwitchTransformer",
                "/**\n * Factory method that performs validation and copies the parameter arrays.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param predicates  array of predicates, cloned, no nulls\n * @param transformers  matching array of transformers, cloned, no nulls\n * @param defaultTransformer  the transformer to use if no match, null means return null\n * @return the <code>chained</code> transformer\n * @throws NullPointerException if array is null\n * @throws NullPointerException if any element in the array is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <I, O> Transformer<I, O> switchTransformer(final Predicate<? super I>[] predicates, final Transformer<? super I, ? extends O>[] transformers, final Transformer<? super I, ? extends O> defaultTransformer) {\n    FunctorUtils.validate(predicates);\n    FunctorUtils.validate(transformers);\n    if (predicates.length != transformers.length) {\n        throw new IllegalArgumentException(\"The predicate and transformer arrays must be the same size\");\n    }\n    if (predicates.length == 0) {\n        return (Transformer<I, O>) (defaultTransformer == null ? ConstantTransformer.<I, O>nullTransformer() : defaultTransformer);\n    }\n    return new SwitchTransformer<I, O>(predicates, transformers, defaultTransformer);\n}"
            ],
            [
                "switchTransformer",
                "org.apache.commons.collections4.functors",
                "SwitchTransformer",
                "/**\n * Create a new Transformer that calls one of the transformers depending\n * on the predicates.\n * <p>\n * The Map consists of Predicate keys and Transformer values. A transformer\n * is called if its matching predicate returns true. Each predicate is evaluated\n * until one returns true. If no predicates evaluate to true, the default\n * transformer is called. The default transformer is set in the map with a\n * null key. The ordering is that of the iterator() method on the entryset\n * collection of the map.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param map  a map of predicates to transformers\n * @return the <code>switch</code> transformer\n * @throws NullPointerException if the map is null\n * @throws NullPointerException if any transformer in the map is null\n * @throws ClassCastException  if the map elements are of the wrong type\n */\n@SuppressWarnings(\"unchecked\")\npublic static <I, O> Transformer<I, O> switchTransformer(final Map<? extends Predicate<? super I>, ? extends Transformer<? super I, ? extends O>> map) {\n    if (map == null) {\n        throw new NullPointerException(\"The predicate and transformer map must not be null\");\n    }\n    if (map.size() == 0) {\n        return ConstantTransformer.<I, O>nullTransformer();\n    }\n    // convert to array like this to guarantee iterator() ordering\n    final Transformer<? super I, ? extends O> defaultTransformer = map.remove(null);\n    final int size = map.size();\n    if (size == 0) {\n        return (Transformer<I, O>) (defaultTransformer == null ? ConstantTransformer.<I, O>nullTransformer() : defaultTransformer);\n    }\n    final Transformer<? super I, ? extends O>[] transformers = new Transformer[size];\n    final Predicate<? super I>[] preds = new Predicate[size];\n    int i = 0;\n    for (final Map.Entry<? extends Predicate<? super I>, ? extends Transformer<? super I, ? extends O>> entry : map.entrySet()) {\n        preds[i] = entry.getKey();\n        transformers[i] = entry.getValue();\n        i++;\n    }\n    return new SwitchTransformer<I, O>(false, preds, transformers, defaultTransformer);\n}"
            ],
            [
                "transformerClosure",
                "org.apache.commons.collections4.functors",
                "TransformerClosure",
                "/**\n * Factory method that performs validation.\n * <p>\n * A null transformer will return the <code>NOPClosure</code>.\n *\n * @param <E> the type that the closure acts on\n * @param transformer  the transformer to call, null means nop\n * @return the <code>transformer</code> closure\n */\npublic static <E> Closure<E> transformerClosure(final Transformer<? super E, ?> transformer) {\n    if (transformer == null) {\n        return NOPClosure.<E>nopClosure();\n    }\n    return new TransformerClosure<E>(transformer);\n}"
            ],
            [
                "orPredicate",
                "org.apache.commons.collections4.functors",
                "OrPredicate",
                "/**\n * Factory to create the predicate.\n *\n * @param <T> the type that the predicate queries\n * @param predicate1  the first predicate to check, not null\n * @param predicate2  the second predicate to check, not null\n * @return the <code>and</code> predicate\n * @throws NullPointerException if either predicate is null\n */\npublic static <T> Predicate<T> orPredicate(final Predicate<? super T> predicate1, final Predicate<? super T> predicate2) {\n    if (predicate1 == null || predicate2 == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    return new OrPredicate<T>(predicate1, predicate2);\n}"
            ],
            [
                "nopTransformer",
                "org.apache.commons.collections4.functors",
                "NOPTransformer",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <T>  the input/output type\n * @return the singleton instance\n * @since 3.1\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Transformer<T, T> nopTransformer() {\n    return (Transformer<T, T>) INSTANCE;\n}"
            ],
            [
                "mapTransformer",
                "org.apache.commons.collections4.functors",
                "MapTransformer",
                "/**\n * Factory to create the transformer.\n * <p>\n * If the map is null, a transformer that always returns null is returned.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param map the map, not cloned\n * @return the transformer\n */\npublic static <I, O> Transformer<I, O> mapTransformer(final Map<? super I, ? extends O> map) {\n    if (map == null) {\n        return ConstantTransformer.<I, O>nullTransformer();\n    }\n    return new MapTransformer<I, O>(map);\n}"
            ],
            [
                "exceptionFactory",
                "org.apache.commons.collections4.functors",
                "ExceptionFactory",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <T>  the type the factory creates\n * @return the singleton instance\n * @since 3.1\n */\n// the static instance works for all types\n@SuppressWarnings(\"unchecked\")\npublic static <T> Factory<T> exceptionFactory() {\n    return (Factory<T>) INSTANCE;\n}"
            ],
            [
                "chainedClosure",
                "org.apache.commons.collections4.functors",
                "ChainedClosure",
                "/**\n * Factory method that performs validation and copies the parameter array.\n *\n * @param <E> the type that the closure acts on\n * @param closures  the closures to chain, copied, no nulls\n * @return the <code>chained</code> closure\n * @throws NullPointerException if the closures array is null\n * @throws NullPointerException if any closure in the array is null\n */\npublic static <E> Closure<E> chainedClosure(final Closure<? super E>... closures) {\n    FunctorUtils.validate(closures);\n    if (closures.length == 0) {\n        return NOPClosure.<E>nopClosure();\n    }\n    return new ChainedClosure<E>(closures);\n}"
            ],
            [
                "chainedClosure",
                "org.apache.commons.collections4.functors",
                "ChainedClosure",
                "/**\n * Create a new Closure that calls each closure in turn, passing the\n * result into the next closure. The ordering is that of the iterator()\n * method on the collection.\n *\n * @param <E> the type that the closure acts on\n * @param closures  a collection of closures to chain\n * @return the <code>chained</code> closure\n * @throws NullPointerException if the closures collection is null\n * @throws NullPointerException if any closure in the collection is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Closure<E> chainedClosure(final Collection<? extends Closure<? super E>> closures) {\n    if (closures == null) {\n        throw new NullPointerException(\"Closure collection must not be null\");\n    }\n    if (closures.size() == 0) {\n        return NOPClosure.<E>nopClosure();\n    }\n    // convert to array like this to guarantee iterator() ordering\n    final Closure<? super E>[] cmds = new Closure[closures.size()];\n    int i = 0;\n    for (final Closure<? super E> closure : closures) {\n        cmds[i++] = closure;\n    }\n    FunctorUtils.validate(cmds);\n    return new ChainedClosure<E>(false, cmds);\n}"
            ],
            [
                "andPredicate",
                "org.apache.commons.collections4.functors",
                "AndPredicate",
                "/**\n * Factory to create the predicate.\n *\n * @param <T> the type that the predicate queries\n * @param predicate1  the first predicate to check, not null\n * @param predicate2  the second predicate to check, not null\n * @return the <code>and</code> predicate\n * @throws NullPointerException if either predicate is null\n */\npublic static <T> Predicate<T> andPredicate(final Predicate<? super T> predicate1, final Predicate<? super T> predicate2) {\n    if (predicate1 == null || predicate2 == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    return new AndPredicate<T>(predicate1, predicate2);\n}"
            ],
            [
                "prototypeFactory",
                "org.apache.commons.collections4.functors",
                "PrototypeFactory",
                "/**\n * Factory method that performs validation.\n * <p>\n * Creates a Factory that will return a clone of the same prototype object\n * each time the factory is used. The prototype will be cloned using one of these\n * techniques (in order):\n * <ul>\n * <li>public clone method\n * <li>public copy constructor\n * <li>serialization clone\n * <ul>\n *\n * @param <T>  the type the factory creates\n * @param prototype  the object to clone each time in the factory\n * @return the <code>prototype</code> factory, or a {@link ConstantFactory#NULL_INSTANCE} if\n * the {@code prototype} is {@code null}\n * @throws IllegalArgumentException if the prototype cannot be cloned\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Factory<T> prototypeFactory(final T prototype) {\n    if (prototype == null) {\n        return ConstantFactory.<T>constantFactory(null);\n    }\n    try {\n        final Method method = prototype.getClass().getMethod(\"clone\", (Class[]) null);\n        return new PrototypeCloneFactory<T>(prototype, method);\n    } catch (final NoSuchMethodException ex) {\n        try {\n            prototype.getClass().getConstructor(new Class<?>[] { prototype.getClass() });\n            return new InstantiateFactory<T>((Class<T>) prototype.getClass(), new Class<?>[] { prototype.getClass() }, new Object[] { prototype });\n        } catch (final NoSuchMethodException ex2) {\n            if (prototype instanceof Serializable) {\n                return (Factory<T>) new PrototypeSerializationFactory<Serializable>((Serializable) prototype);\n            }\n        }\n    }\n    throw new IllegalArgumentException(\"The prototype must be cloneable via a public clone method\");\n}"
            ],
            [
                "exceptionPredicate",
                "org.apache.commons.collections4.functors",
                "ExceptionPredicate",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <T>  the object type\n * @return the singleton instance\n * @since 3.1\n */\n// the static instance works for all types\n@SuppressWarnings(\"unchecked\")\npublic static <T> Predicate<T> exceptionPredicate() {\n    return (Predicate<T>) INSTANCE;\n}"
            ],
            [
                "instanceOfPredicate",
                "org.apache.commons.collections4.functors",
                "InstanceofPredicate",
                "/**\n * Factory to create the identity predicate.\n *\n * @param type  the type to check for, may not be null\n * @return the predicate\n * @throws NullPointerException if the class is null\n */\npublic static Predicate<Object> instanceOfPredicate(final Class<?> type) {\n    if (type == null) {\n        throw new NullPointerException(\"The type to check instanceof must not be null\");\n    }\n    return new InstanceofPredicate(type);\n}"
            ],
            [
                "invokerTransformer",
                "org.apache.commons.collections4.functors",
                "InvokerTransformer",
                "/**\n * Gets an instance of this transformer calling a specific method with no arguments.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param methodName  the method name to call\n * @return an invoker transformer\n * @throws NullPointerException if methodName is null\n * @since 3.1\n */\npublic static <I, O> Transformer<I, O> invokerTransformer(final String methodName) {\n    if (methodName == null) {\n        throw new NullPointerException(\"The method to invoke must not be null\");\n    }\n    return new InvokerTransformer<I, O>(methodName);\n}"
            ],
            [
                "invokerTransformer",
                "org.apache.commons.collections4.functors",
                "InvokerTransformer",
                "/**\n * Gets an instance of this transformer calling a specific method with specific values.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param methodName  the method name to call\n * @param paramTypes  the parameter types of the method\n * @param args  the arguments to pass to the method\n * @return an invoker transformer\n * @throws NullPointerException if methodName is null\n * @throws IllegalArgumentException if paramTypes does not match args\n */\npublic static <I, O> Transformer<I, O> invokerTransformer(final String methodName, final Class<?>[] paramTypes, final Object[] args) {\n    if (methodName == null) {\n        throw new NullPointerException(\"The method to invoke must not be null\");\n    }\n    if (((paramTypes == null) && (args != null)) || ((paramTypes != null) && (args == null)) || ((paramTypes != null) && (args != null) && (paramTypes.length != args.length))) {\n        throw new IllegalArgumentException(\"The parameter types must match the arguments\");\n    }\n    if (paramTypes == null || paramTypes.length == 0) {\n        return new InvokerTransformer<I, O>(methodName);\n    }\n    return new InvokerTransformer<I, O>(methodName, paramTypes, args);\n}"
            ],
            [
                "falsePredicate",
                "org.apache.commons.collections4.functors",
                "FalsePredicate",
                "/**\n * Get a typed instance.\n *\n * @param <T> the type that the predicate queries\n * @return the singleton instance\n * @since 4.0\n */\n// the static instance works for all types\n@SuppressWarnings(\"unchecked\")\npublic static <T> Predicate<T> falsePredicate() {\n    return (Predicate<T>) INSTANCE;\n}"
            ],
            [
                "cloneTransformer",
                "org.apache.commons.collections4.functors",
                "CloneTransformer",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <T>  the type of the objects to be cloned\n * @return the singleton instance\n * @since 3.1\n */\n// the singleton instance works for all types\n@SuppressWarnings(\"unchecked\")\npublic static <T> Transformer<T, T> cloneTransformer() {\n    return INSTANCE;\n}"
            ],
            [
                "notPredicate",
                "org.apache.commons.collections4.functors",
                "NotPredicate",
                "/**\n * Factory to create the not predicate.\n *\n * @param <T> the type that the predicate queries\n * @param predicate  the predicate to decorate, not null\n * @return the predicate\n * @throws NullPointerException if the predicate is null\n */\npublic static <T> Predicate<T> notPredicate(final Predicate<? super T> predicate) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    return new NotPredicate<T>(predicate);\n}"
            ],
            [
                "constantFactory",
                "org.apache.commons.collections4.functors",
                "ConstantFactory",
                "/**\n * Factory method that performs validation.\n *\n * @param <T>  the type of the constant\n * @param constantToReturn  the constant object to return each time in the factory\n * @return the <code>constant</code> factory.\n */\n// The null factory works for all object types\n@SuppressWarnings(\"unchecked\")\npublic static <T> Factory<T> constantFactory(final T constantToReturn) {\n    if (constantToReturn == null) {\n        return (Factory<T>) NULL_INSTANCE;\n    }\n    return new ConstantFactory<T>(constantToReturn);\n}"
            ],
            [
                "chainedTransformer",
                "org.apache.commons.collections4.functors",
                "ChainedTransformer",
                "/**\n * Factory method that performs validation and copies the parameter array.\n *\n * @param <T>  the object type\n * @param transformers  the transformers to chain, copied, no nulls\n * @return the <code>chained</code> transformer\n * @throws NullPointerException if the transformers array is null\n * @throws NullPointerException if any transformer in the array is null\n */\npublic static <T> Transformer<T, T> chainedTransformer(final Transformer<? super T, ? extends T>... transformers) {\n    FunctorUtils.validate(transformers);\n    if (transformers.length == 0) {\n        return NOPTransformer.<T>nopTransformer();\n    }\n    return new ChainedTransformer<T>(transformers);\n}"
            ],
            [
                "chainedTransformer",
                "org.apache.commons.collections4.functors",
                "ChainedTransformer",
                "/**\n * Create a new Transformer that calls each transformer in turn, passing the\n * result into the next transformer. The ordering is that of the iterator()\n * method on the collection.\n *\n * @param <T>  the object type\n * @param transformers  a collection of transformers to chain\n * @return the <code>chained</code> transformer\n * @throws NullPointerException if the transformers collection is null\n * @throws NullPointerException if any transformer in the collection is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Transformer<T, T> chainedTransformer(final Collection<? extends Transformer<? super T, ? extends T>> transformers) {\n    if (transformers == null) {\n        throw new NullPointerException(\"Transformer collection must not be null\");\n    }\n    if (transformers.size() == 0) {\n        return NOPTransformer.<T>nopTransformer();\n    }\n    // convert to array like this to guarantee iterator() ordering\n    final Transformer<T, T>[] cmds = transformers.toArray(new Transformer[transformers.size()]);\n    FunctorUtils.validate(cmds);\n    return new ChainedTransformer<T>(false, cmds);\n}"
            ],
            [
                "comparatorPredicate",
                "org.apache.commons.collections4.functors",
                "ComparatorPredicate",
                "/**\n * Factory to create the comparator predicate\n *\n * @param <T> the type that the predicate queries\n * @param object  the object to compare to\n * @param comparator  the comparator to use for comparison\n * @return the predicate\n * @throws NullPointerException if comparator is null\n */\npublic static <T> Predicate<T> comparatorPredicate(final T object, final Comparator<T> comparator) {\n    return comparatorPredicate(object, comparator, Criterion.EQUAL);\n}"
            ],
            [
                "comparatorPredicate",
                "org.apache.commons.collections4.functors",
                "ComparatorPredicate",
                "/**\n * Factory to create the comparator predicate\n *\n * @param <T> the type that the predicate queries\n * @param object  the object to compare to\n * @param comparator  the comparator to use for comparison\n * @param criterion  the criterion to use to evaluate comparison\n * @return the predicate\n * @throws NullPointerException if comparator or criterion is null\n */\npublic static <T> Predicate<T> comparatorPredicate(final T object, final Comparator<T> comparator, final Criterion criterion) {\n    if (comparator == null) {\n        throw new NullPointerException(\"Comparator must not be null.\");\n    }\n    if (criterion == null) {\n        throw new NullPointerException(\"Criterion must not be null.\");\n    }\n    return new ComparatorPredicate<T>(object, comparator, criterion);\n}"
            ],
            [
                "allPredicate",
                "org.apache.commons.collections4.functors",
                "AllPredicate",
                "/**\n * Factory to create the predicate.\n * <p>\n * If the array is size zero, the predicate always returns true.\n * If the array is size one, then that predicate is returned.\n *\n * @param <T> the type that the predicate queries\n * @param predicates  the predicates to check, cloned, not null\n * @return the <code>all</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n */\npublic static <T> Predicate<T> allPredicate(final Predicate<? super T>... predicates) {\n    FunctorUtils.validate(predicates);\n    if (predicates.length == 0) {\n        return truePredicate();\n    }\n    if (predicates.length == 1) {\n        return coerce(predicates[0]);\n    }\n    return new AllPredicate<T>(FunctorUtils.copy(predicates));\n}"
            ],
            [
                "allPredicate",
                "org.apache.commons.collections4.functors",
                "AllPredicate",
                "/**\n * Factory to create the predicate.\n * <p>\n * If the collection is size zero, the predicate always returns true.\n * If the collection is size one, then that predicate is returned.\n *\n * @param <T> the type that the predicate queries\n * @param predicates  the predicates to check, cloned, not null\n * @return the <code>all</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n */\npublic static <T> Predicate<T> allPredicate(final Collection<? extends Predicate<? super T>> predicates) {\n    final Predicate<? super T>[] preds = validate(predicates);\n    if (preds.length == 0) {\n        return truePredicate();\n    }\n    if (preds.length == 1) {\n        return coerce(preds[0]);\n    }\n    return new AllPredicate<T>(preds);\n}"
            ],
            [
                "nullIsFalsePredicate",
                "org.apache.commons.collections4.functors",
                "NullIsFalsePredicate",
                "/**\n * Factory to create the null false predicate.\n *\n * @param <T> the type that the predicate queries\n * @param predicate  the predicate to decorate, not null\n * @return the predicate\n * @throws NullPointerException if the predicate is null\n */\npublic static <T> Predicate<T> nullIsFalsePredicate(final Predicate<? super T> predicate) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    return new NullIsFalsePredicate<T>(predicate);\n}"
            ],
            [
                "nullIsExceptionPredicate",
                "org.apache.commons.collections4.functors",
                "NullIsExceptionPredicate",
                "/**\n * Factory to create the null exception predicate.\n *\n * @param <T> the type that the predicate queries\n * @param predicate  the predicate to decorate, not null\n * @return the predicate\n * @throws NullPointerException if the predicate is null\n */\npublic static <T> Predicate<T> nullIsExceptionPredicate(final Predicate<? super T> predicate) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    return new NullIsExceptionPredicate<T>(predicate);\n}"
            ],
            [
                "anyPredicate",
                "org.apache.commons.collections4.functors",
                "AnyPredicate",
                "/**\n * Factory to create the predicate.\n * <p>\n * If the array is size zero, the predicate always returns false.\n * If the array is size one, then that predicate is returned.\n *\n * @param <T> the type that the predicate queries\n * @param predicates  the predicates to check, cloned, not null\n * @return the <code>any</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Predicate<T> anyPredicate(final Predicate<? super T>... predicates) {\n    FunctorUtils.validate(predicates);\n    if (predicates.length == 0) {\n        return FalsePredicate.<T>falsePredicate();\n    }\n    if (predicates.length == 1) {\n        return (Predicate<T>) predicates[0];\n    }\n    return new AnyPredicate<T>(FunctorUtils.copy(predicates));\n}"
            ],
            [
                "anyPredicate",
                "org.apache.commons.collections4.functors",
                "AnyPredicate",
                "/**\n * Factory to create the predicate.\n * <p>\n * If the collection is size zero, the predicate always returns false.\n * If the collection is size one, then that predicate is returned.\n *\n * @param <T> the type that the predicate queries\n * @param predicates  the predicates to check, cloned, not null\n * @return the <code>all</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Predicate<T> anyPredicate(final Collection<? extends Predicate<? super T>> predicates) {\n    final Predicate<? super T>[] preds = FunctorUtils.validate(predicates);\n    if (preds.length == 0) {\n        return FalsePredicate.<T>falsePredicate();\n    }\n    if (preds.length == 1) {\n        return (Predicate<T>) preds[0];\n    }\n    return new AnyPredicate<T>(preds);\n}"
            ],
            [
                "truePredicate",
                "org.apache.commons.collections4.functors",
                "TruePredicate",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <T> the type that the predicate queries\n * @return the singleton instance\n * @since 3.1\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Predicate<T> truePredicate() {\n    return (Predicate<T>) INSTANCE;\n}"
            ],
            [
                "factoryTransformer",
                "org.apache.commons.collections4.functors",
                "FactoryTransformer",
                "/**\n * Factory method that performs validation.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param factory  the factory to call, not null\n * @return the <code>factory</code> transformer\n * @throws NullPointerException if the factory is null\n */\npublic static <I, O> Transformer<I, O> factoryTransformer(final Factory<? extends O> factory) {\n    if (factory == null) {\n        throw new NullPointerException(\"Factory must not be null\");\n    }\n    return new FactoryTransformer<I, O>(factory);\n}"
            ],
            [
                "notNullPredicate",
                "org.apache.commons.collections4.functors",
                "NotNullPredicate",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <T> the type that the predicate queries\n * @return the singleton instance\n * @since 3.1\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Predicate<T> notNullPredicate() {\n    return (Predicate<T>) INSTANCE;\n}"
            ],
            [
                "switchClosure",
                "org.apache.commons.collections4.functors",
                "SwitchClosure",
                "/**\n * Factory method that performs validation and copies the parameter arrays.\n *\n * @param <E> the type that the closure acts on\n * @param predicates  array of predicates, cloned, no nulls\n * @param closures  matching array of closures, cloned, no nulls\n * @param defaultClosure  the closure to use if no match, null means nop\n * @return the <code>chained</code> closure\n * @throws NullPointerException if array is null\n * @throws NullPointerException if any element in the array is null\n * @throws IllegalArgumentException if the array lengths of predicates and closures do not match\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Closure<E> switchClosure(final Predicate<? super E>[] predicates, final Closure<? super E>[] closures, final Closure<? super E> defaultClosure) {\n    FunctorUtils.validate(predicates);\n    FunctorUtils.validate(closures);\n    if (predicates.length != closures.length) {\n        throw new IllegalArgumentException(\"The predicate and closure arrays must be the same size\");\n    }\n    if (predicates.length == 0) {\n        return (Closure<E>) (defaultClosure == null ? NOPClosure.<E>nopClosure() : defaultClosure);\n    }\n    return new SwitchClosure<E>(predicates, closures, defaultClosure);\n}"
            ],
            [
                "switchClosure",
                "org.apache.commons.collections4.functors",
                "SwitchClosure",
                "/**\n * Create a new Closure that calls one of the closures depending\n * on the predicates.\n * <p>\n * The Map consists of Predicate keys and Closure values. A closure\n * is called if its matching predicate returns true. Each predicate is evaluated\n * until one returns true. If no predicates evaluate to true, the default\n * closure is called. The default closure is set in the map with a\n * null key. The ordering is that of the iterator() method on the entryset\n * collection of the map.\n *\n * @param <E> the type that the closure acts on\n * @param predicatesAndClosures  a map of predicates to closures\n * @return the <code>switch</code> closure\n * @throws NullPointerException if the map is null\n * @throws NullPointerException if any closure in the map is null\n * @throws ClassCastException  if the map elements are of the wrong type\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Closure<E> switchClosure(final Map<Predicate<E>, Closure<E>> predicatesAndClosures) {\n    if (predicatesAndClosures == null) {\n        throw new NullPointerException(\"The predicate and closure map must not be null\");\n    }\n    // convert to array like this to guarantee iterator() ordering\n    final Closure<? super E> defaultClosure = predicatesAndClosures.remove(null);\n    final int size = predicatesAndClosures.size();\n    if (size == 0) {\n        return (Closure<E>) (defaultClosure == null ? NOPClosure.<E>nopClosure() : defaultClosure);\n    }\n    final Closure<E>[] closures = new Closure[size];\n    final Predicate<E>[] preds = new Predicate[size];\n    int i = 0;\n    for (final Map.Entry<Predicate<E>, Closure<E>> entry : predicatesAndClosures.entrySet()) {\n        preds[i] = entry.getKey();\n        closures[i] = entry.getValue();\n        i++;\n    }\n    return new SwitchClosure<E>(false, preds, closures, defaultClosure);\n}"
            ],
            [
                "uniquePredicate",
                "org.apache.commons.collections4.functors",
                "UniquePredicate",
                "/**\n * Factory to create the predicate.\n *\n * @param <T> the type that the predicate queries\n * @return the predicate\n * @throws IllegalArgumentException if the predicate is null\n */\npublic static <T> Predicate<T> uniquePredicate() {\n    return new UniquePredicate<T>();\n}"
            ],
            [
                "instantiateTransformer",
                "org.apache.commons.collections4.functors",
                "InstantiateTransformer",
                "/**\n * Get a typed no-arg instance.\n *\n * @param <T>  the type of the objects to be created\n * @return Transformer<Class<? extends T>, T>\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Transformer<Class<? extends T>, T> instantiateTransformer() {\n    return NO_ARG_INSTANCE;\n}"
            ],
            [
                "instantiateTransformer",
                "org.apache.commons.collections4.functors",
                "InstantiateTransformer",
                "/**\n * Transformer method that performs validation.\n *\n * @param <T>  the type of the objects to be created\n * @param paramTypes  the constructor parameter types\n * @param args  the constructor arguments\n * @return an instantiate transformer\n * @throws IllegalArgumentException if paramTypes does not match args\n */\npublic static <T> Transformer<Class<? extends T>, T> instantiateTransformer(final Class<?>[] paramTypes, final Object[] args) {\n    if (((paramTypes == null) && (args != null)) || ((paramTypes != null) && (args == null)) || ((paramTypes != null) && (args != null) && (paramTypes.length != args.length))) {\n        throw new IllegalArgumentException(\"Parameter types must match the arguments\");\n    }\n    if (paramTypes == null || paramTypes.length == 0) {\n        return new InstantiateTransformer<T>();\n    }\n    return new InstantiateTransformer<T>(paramTypes, args);\n}"
            ],
            [
                "onePredicate",
                "org.apache.commons.collections4.functors",
                "OnePredicate",
                "/**\n * Factory to create the predicate.\n * <p>\n * If the array is size zero, the predicate always returns false.\n * If the array is size one, then that predicate is returned.\n *\n * @param <T> the type that the predicate queries\n * @param predicates  the predicates to check, cloned, not null\n * @return the <code>any</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Predicate<T> onePredicate(final Predicate<? super T>... predicates) {\n    FunctorUtils.validate(predicates);\n    if (predicates.length == 0) {\n        return FalsePredicate.<T>falsePredicate();\n    }\n    if (predicates.length == 1) {\n        return (Predicate<T>) predicates[0];\n    }\n    return new OnePredicate<T>(FunctorUtils.copy(predicates));\n}"
            ],
            [
                "onePredicate",
                "org.apache.commons.collections4.functors",
                "OnePredicate",
                "/**\n * Factory to create the predicate.\n *\n * @param <T> the type that the predicate queries\n * @param predicates  the predicates to check, cloned, not null\n * @return the <code>one</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n */\npublic static <T> Predicate<T> onePredicate(final Collection<? extends Predicate<? super T>> predicates) {\n    final Predicate<? super T>[] preds = FunctorUtils.validate(predicates);\n    return new OnePredicate<T>(preds);\n}"
            ],
            [
                "equalPredicate",
                "org.apache.commons.collections4.functors",
                "EqualPredicate",
                "/**\n * Factory to create the predicate.\n *\n * @param <T> the type that the predicate queries\n * @param object  the object to compare to\n * @return the predicate\n */\npublic static <T> Predicate<T> equalPredicate(final T object) {\n    if (object == null) {\n        return NullPredicate.nullPredicate();\n    }\n    return new EqualPredicate<T>(object);\n}"
            ],
            [
                "equalPredicate",
                "org.apache.commons.collections4.functors",
                "EqualPredicate",
                "/**\n * Factory to create the identity predicate.\n *\n * @param <T> the type that the predicate queries\n * @param object  the object to compare to\n * @param equator  the equator to use for comparison\n * @return the predicate\n * @since 4.0\n */\npublic static <T> Predicate<T> equalPredicate(final T object, final Equator<T> equator) {\n    if (object == null) {\n        return NullPredicate.nullPredicate();\n    }\n    return new EqualPredicate<T>(object, equator);\n}"
            ],
            [
                "instantiateFactory",
                "org.apache.commons.collections4.functors",
                "InstantiateFactory",
                "/**\n * Factory method that performs validation.\n *\n * @param <T>  the type the factory creates\n * @param classToInstantiate  the class to instantiate, not null\n * @param paramTypes  the constructor parameter types, cloned\n * @param args  the constructor arguments, cloned\n * @return a new instantiate factory\n * @throws NullPointerException if classToInstantiate is null\n * @throws IllegalArgumentException if paramTypes does not match args\n */\npublic static <T> Factory<T> instantiateFactory(final Class<T> classToInstantiate, final Class<?>[] paramTypes, final Object[] args) {\n    if (classToInstantiate == null) {\n        throw new NullPointerException(\"Class to instantiate must not be null\");\n    }\n    if (paramTypes == null && args != null || paramTypes != null && args == null || paramTypes != null && args != null && paramTypes.length != args.length) {\n        throw new IllegalArgumentException(\"Parameter types must match the arguments\");\n    }\n    if (paramTypes == null || paramTypes.length == 0) {\n        return new InstantiateFactory<T>(classToInstantiate);\n    }\n    return new InstantiateFactory<T>(classToInstantiate, paramTypes, args);\n}"
            ],
            [
                "ifClosure",
                "org.apache.commons.collections4.functors",
                "IfClosure",
                "/**\n * Factory method that performs validation.\n * <p>\n * This factory creates a closure that performs no action when\n * the predicate is false.\n *\n * @param <E> the type that the closure acts on\n * @param predicate  predicate to switch on\n * @param trueClosure  closure used if true\n * @return the <code>if</code> closure\n * @throws NullPointerException if either argument is null\n * @since 3.2\n */\npublic static <E> Closure<E> ifClosure(final Predicate<? super E> predicate, final Closure<? super E> trueClosure) {\n    return IfClosure.<E>ifClosure(predicate, trueClosure, NOPClosure.<E>nopClosure());\n}"
            ],
            [
                "ifClosure",
                "org.apache.commons.collections4.functors",
                "IfClosure",
                "/**\n * Factory method that performs validation.\n *\n * @param <E> the type that the closure acts on\n * @param predicate  predicate to switch on\n * @param trueClosure  closure used if true\n * @param falseClosure  closure used if false\n * @return the <code>if</code> closure\n * @throws NullPointerException if any argument is null\n */\npublic static <E> Closure<E> ifClosure(final Predicate<? super E> predicate, final Closure<? super E> trueClosure, final Closure<? super E> falseClosure) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    if (trueClosure == null || falseClosure == null) {\n        throw new NullPointerException(\"Closures must not be null\");\n    }\n    return new IfClosure<E>(predicate, trueClosure, falseClosure);\n}"
            ],
            [
                "getTrueFirstComparator",
                "org.apache.commons.collections4.comparators",
                "BooleanComparator",
                "//-----------------------------------------------------------------------\n/**\n * Returns a BooleanComparator instance that sorts\n * <code>true</code> values before <code>false</code> values.\n * <p />\n * Clients are encouraged to use the value returned from\n * this method instead of constructing a new instance\n * to reduce allocation and garbage collection overhead when\n * multiple BooleanComparators may be used in the same\n * virtual machine.\n *\n * @return the true first singleton BooleanComparator\n */\npublic static BooleanComparator getTrueFirstComparator() {\n    return TRUE_FIRST;\n}"
            ],
            [
                "getFalseFirstComparator",
                "org.apache.commons.collections4.comparators",
                "BooleanComparator",
                "/**\n * Returns a BooleanComparator instance that sorts\n * <code>false</code> values before <code>true</code> values.\n * <p />\n * Clients are encouraged to use the value returned from\n * this method instead of constructing a new instance\n * to reduce allocation and garbage collection overhead when\n * multiple BooleanComparators may be used in the same\n * virtual machine.\n *\n * @return the false first singleton BooleanComparator\n */\npublic static BooleanComparator getFalseFirstComparator() {\n    return FALSE_FIRST;\n}"
            ],
            [
                "booleanComparator",
                "org.apache.commons.collections4.comparators",
                "BooleanComparator",
                "/**\n * Returns a BooleanComparator instance that sorts\n * <code><i>trueFirst</i></code> values before\n * <code>&#x21;<i>trueFirst</i></code> values.\n * <p />\n * Clients are encouraged to use the value returned from\n * this method instead of constructing a new instance\n * to reduce allocation and garbage collection overhead when\n * multiple BooleanComparators may be used in the same\n * virtual machine.\n *\n * @param trueFirst when <code>true</code>, sort\n * <code>true</code> <code>Boolean</code>s before <code>false</code>\n * @return a singleton BooleanComparator instance\n * @since 4.0\n */\npublic static BooleanComparator booleanComparator(final boolean trueFirst) {\n    return trueFirst ? TRUE_FIRST : FALSE_FIRST;\n}"
            ],
            [
                "comparableComparator",
                "org.apache.commons.collections4.comparators",
                "ComparableComparator",
                "//-----------------------------------------------------------------------\n/**\n * Gets the singleton instance of a ComparableComparator.\n * <p>\n * Developers are encouraged to use the comparator returned from this method\n * instead of constructing a new instance to reduce allocation and GC overhead\n * when multiple comparable comparators may be used in the same VM.\n *\n * @param <E>  the element type\n * @return the singleton ComparableComparator\n * @since 4.0\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E extends Comparable<? super E>> ComparableComparator<E> comparableComparator() {\n    return INSTANCE;\n}"
            ],
            [
                "emptyCollection",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns the immutable EMPTY_COLLECTION with generic type safety.\n *\n * @see #EMPTY_COLLECTION\n * @since 4.0\n * @param <T> the element type\n * @return immutable empty collection\n */\n// OK, empty collection is compatible with any type\n@SuppressWarnings(\"unchecked\")\npublic static <T> Collection<T> emptyCollection() {\n    return EMPTY_COLLECTION;\n}"
            ],
            [
                "emptyIfNull",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns an immutable empty collection if the argument is <code>null</code>,\n * or the argument itself otherwise.\n *\n * @param <T> the element type\n * @param collection the collection, possibly <code>null</code>\n * @return an empty collection if the argument is <code>null</code>\n */\n// OK, empty collection is compatible with any type\n@SuppressWarnings(\"unchecked\")\npublic static <T> Collection<T> emptyIfNull(final Collection<T> collection) {\n    return collection == null ? EMPTY_COLLECTION : collection;\n}"
            ],
            [
                "union",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns a {@link Collection} containing the union of the given\n * {@link Iterable}s.\n * <p>\n * The cardinality of each element in the returned {@link Collection} will\n * be equal to the maximum of the cardinality of that element in the two\n * given {@link Iterable}s.\n *\n * @param a the first collection, must not be null\n * @param b the second collection, must not be null\n * @param <O> the generic type that is able to represent the types contained\n *        in both input collections.\n * @return the union of the two collections\n * @see Collection#addAll\n */\npublic static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}"
            ],
            [
                "intersection",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns a {@link Collection} containing the intersection of the given\n * {@link Iterable}s.\n * <p>\n * The cardinality of each element in the returned {@link Collection} will\n * be equal to the minimum of the cardinality of that element in the two\n * given {@link Iterable}s.\n *\n * @param a the first collection, must not be null\n * @param b the second collection, must not be null\n * @param <O> the generic type that is able to represent the types contained\n *        in both input collections.\n * @return the intersection of the two collections\n * @see Collection#retainAll\n * @see #containsAny\n */\npublic static <O> Collection<O> intersection(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.min(obj));\n    }\n    return helper.list();\n}"
            ],
            [
                "disjunction",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns a {@link Collection} containing the exclusive disjunction\n * (symmetric difference) of the given {@link Iterable}s.\n * <p>\n * The cardinality of each element <i>e</i> in the returned\n * {@link Collection} will be equal to\n * <tt>max(cardinality(<i>e</i>,<i>a</i>),cardinality(<i>e</i>,<i>b</i>)) - min(cardinality(<i>e</i>,<i>a</i>),\n * cardinality(<i>e</i>,<i>b</i>))</tt>.\n * <p>\n * This is equivalent to\n * {@code {@link #subtract subtract}({@link #union union(a,b)},{@link #intersection intersection(a,b)})}\n * or\n * {@code {@link #union union}({@link #subtract subtract(a,b)},{@link #subtract subtract(b,a)})}.\n *\n * @param a the first collection, must not be null\n * @param b the second collection, must not be null\n * @param <O> the generic type that is able to represent the types contained\n *        in both input collections.\n * @return the symmetric difference of the two collections\n */\npublic static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}"
            ],
            [
                "subtract",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns a new {@link Collection} containing {@code <i>a</i> - <i>b</i>}.\n * The cardinality of each element <i>e</i> in the returned {@link Collection}\n * will be the cardinality of <i>e</i> in <i>a</i> minus the cardinality\n * of <i>e</i> in <i>b</i>, or zero, whichever is greater.\n *\n * @param a  the collection to subtract from, must not be null\n * @param b  the collection to subtract, must not be null\n * @param <O> the generic type that is able to represent the types contained\n *        in both input collections.\n * @return a new collection with the results\n * @see Collection#removeAll\n */\npublic static <O> Collection<O> subtract(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n    final Predicate<O> p = TruePredicate.truePredicate();\n    return subtract(a, b, p);\n}"
            ],
            [
                "subtract",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns a new {@link Collection} containing <i>a</i> minus a subset of\n * <i>b</i>.  Only the elements of <i>b</i> that satisfy the predicate\n * condition, <i>p</i> are subtracted from <i>a</i>.\n *\n * <p>The cardinality of each element <i>e</i> in the returned {@link Collection}\n * that satisfies the predicate condition will be the cardinality of <i>e</i> in <i>a</i>\n * minus the cardinality of <i>e</i> in <i>b</i>, or zero, whichever is greater.</p>\n * <p>The cardinality of each element <i>e</i> in the returned {@link Collection} that does <b>not</b>\n * satisfy the predicate condition will be equal to the cardinality of <i>e</i> in <i>a</i>.</p>\n *\n * @param a  the collection to subtract from, must not be null\n * @param b  the collection to subtract, must not be null\n * @param p  the condition used to determine which elements of <i>b</i> are\n *        subtracted.\n * @param <O> the generic type that is able to represent the types contained\n *        in both input collections.\n * @return a new collection with the results\n * @since 4.0\n * @see Collection#removeAll\n */\npublic static <O> Collection<O> subtract(final Iterable<? extends O> a, final Iterable<? extends O> b, final Predicate<O> p) {\n    final ArrayList<O> list = new ArrayList<O>();\n    final HashBag<O> bag = new HashBag<O>();\n    for (final O element : b) {\n        if (p.evaluate(element)) {\n            bag.add(element);\n        }\n    }\n    for (final O element : a) {\n        if (!bag.remove(element, 1)) {\n            list.add(element);\n        }\n    }\n    return list;\n}"
            ],
            [
                "containsAll",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns <code>true</code> iff all elements of {@code coll2} are also contained\n * in {@code coll1}. The cardinality of values in {@code coll2} is not taken into account,\n * which is the same behavior as {@link Collection#containsAll(Collection)}.\n * <p>\n * In other words, this method returns <code>true</code> iff the\n * {@link #intersection} of <i>coll1</i> and <i>coll2</i> has the same cardinality as\n * the set of unique values from {@code coll2}. In case {@code coll2} is empty, {@code true}\n * will be returned.\n * <p>\n * This method is intended as a replacement for {@link Collection#containsAll(Collection)}\n * with a guaranteed runtime complexity of {@code O(n + m)}. Depending on the type of\n * {@link Collection} provided, this method will be much faster than calling\n * {@link Collection#containsAll(Collection)} instead, though this will come at the\n * cost of an additional space complexity O(n).\n *\n * @param coll1  the first collection, must not be null\n * @param coll2  the second collection, must not be null\n * @return <code>true</code> iff the intersection of the collections has the same cardinality\n *   as the set of unique elements from the second collection\n * @since 4.0\n */\npublic static boolean containsAll(final Collection<?> coll1, final Collection<?> coll2) {\n    if (coll2.isEmpty()) {\n        return true;\n    } else {\n        final Iterator<?> it = coll1.iterator();\n        final Set<Object> elementsAlreadySeen = new HashSet<Object>();\n        for (final Object nextElement : coll2) {\n            if (elementsAlreadySeen.contains(nextElement)) {\n                continue;\n            }\n            boolean foundCurrentElement = false;\n            while (it.hasNext()) {\n                final Object p = it.next();\n                elementsAlreadySeen.add(p);\n                if (nextElement == null ? p == null : nextElement.equals(p)) {\n                    foundCurrentElement = true;\n                    break;\n                }\n            }\n            if (foundCurrentElement) {\n                continue;\n            } else {\n                return false;\n            }\n        }\n        return true;\n    }\n}"
            ],
            [
                "containsAny",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns <code>true</code> iff at least one element is in both collections.\n * <p>\n * In other words, this method returns <code>true</code> iff the\n * {@link #intersection} of <i>coll1</i> and <i>coll2</i> is not empty.\n *\n * @param coll1  the first collection, must not be null\n * @param coll2  the second collection, must not be null\n * @return <code>true</code> iff the intersection of the collections is non-empty\n * @since 2.1\n * @see #intersection\n */\npublic static boolean containsAny(final Collection<?> coll1, final Collection<?> coll2) {\n    if (coll1.size() < coll2.size()) {\n        for (final Object aColl1 : coll1) {\n            if (coll2.contains(aColl1)) {\n                return true;\n            }\n        }\n    } else {\n        for (final Object aColl2 : coll2) {\n            if (coll1.contains(aColl2)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}"
            ],
            [
                "getCardinalityMap",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns a {@link Map} mapping each unique element in the given\n * {@link Collection} to an {@link Integer} representing the number\n * of occurrences of that element in the {@link Collection}.\n * <p>\n * Only those elements present in the collection will appear as\n * keys in the map.\n *\n * @param <O>  the type of object in the returned {@link Map}. This is a super type of <I>.\n * @param coll  the collection to get the cardinality map for, must not be null\n * @return the populated cardinality map\n */\npublic static <O> Map<O, Integer> getCardinalityMap(final Iterable<? extends O> coll) {\n    final Map<O, Integer> count = new HashMap<O, Integer>();\n    for (final O obj : coll) {\n        final Integer c = count.get(obj);\n        if (c == null) {\n            count.put(obj, Integer.valueOf(1));\n        } else {\n            count.put(obj, Integer.valueOf(c.intValue() + 1));\n        }\n    }\n    return count;\n}"
            ],
            [
                "isSubCollection",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns {@code true} iff <i>a</i> is a sub-collection of <i>b</i>,\n * that is, iff the cardinality of <i>e</i> in <i>a</i> is less than or\n * equal to the cardinality of <i>e</i> in <i>b</i>, for each element <i>e</i>\n * in <i>a</i>.\n *\n * @param a the first (sub?) collection, must not be null\n * @param b the second (super?) collection, must not be null\n * @return <code>true</code> iff <i>a</i> is a sub-collection of <i>b</i>\n * @see #isProperSubCollection\n * @see Collection#containsAll\n */\npublic static boolean isSubCollection(final Collection<?> a, final Collection<?> b) {\n    final CardinalityHelper<Object> helper = new CardinalityHelper<Object>(a, b);\n    for (final Object obj : a) {\n        if (helper.freqA(obj) > helper.freqB(obj)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isProperSubCollection",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns {@code true} iff <i>a</i> is a <i>proper</i> sub-collection of <i>b</i>,\n * that is, iff the cardinality of <i>e</i> in <i>a</i> is less\n * than or equal to the cardinality of <i>e</i> in <i>b</i>,\n * for each element <i>e</i> in <i>a</i>, and there is at least one\n * element <i>f</i> such that the cardinality of <i>f</i> in <i>b</i>\n * is strictly greater than the cardinality of <i>f</i> in <i>a</i>.\n * <p>\n * The implementation assumes\n * <ul>\n *    <li><code>a.size()</code> and <code>b.size()</code> represent the\n *    total cardinality of <i>a</i> and <i>b</i>, resp. </li>\n *    <li><code>a.size() < Integer.MAXVALUE</code></li>\n * </ul>\n *\n * @param a  the first (sub?) collection, must not be null\n * @param b  the second (super?) collection, must not be null\n * @return <code>true</code> iff <i>a</i> is a <i>proper</i> sub-collection of <i>b</i>\n * @see #isSubCollection\n * @see Collection#containsAll\n */\npublic static boolean isProperSubCollection(final Collection<?> a, final Collection<?> b) {\n    return a.size() < b.size() && CollectionUtils.isSubCollection(a, b);\n}"
            ],
            [
                "isEqualCollection",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns {@code true} iff the given {@link Collection}s contain\n * exactly the same elements with exactly the same cardinalities.\n * <p>\n * That is, iff the cardinality of <i>e</i> in <i>a</i> is\n * equal to the cardinality of <i>e</i> in <i>b</i>,\n * for each element <i>e</i> in <i>a</i> or <i>b</i>.\n *\n * @param a  the first collection, must not be null\n * @param b  the second collection, must not be null\n * @return <code>true</code> iff the collections contain the same elements with the same cardinalities.\n */\npublic static boolean isEqualCollection(final Collection<?> a, final Collection<?> b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n    final CardinalityHelper<Object> helper = new CardinalityHelper<Object>(a, b);\n    if (helper.cardinalityA.size() != helper.cardinalityB.size()) {\n        return false;\n    }\n    for (final Object obj : helper.cardinalityA.keySet()) {\n        if (helper.freqA(obj) != helper.freqB(obj)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isEqualCollection",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns {@code true} iff the given {@link Collection}s contain\n * exactly the same elements with exactly the same cardinalities.\n * <p>\n * That is, iff the cardinality of <i>e</i> in <i>a</i> is\n * equal to the cardinality of <i>e</i> in <i>b</i>,\n * for each element <i>e</i> in <i>a</i> or <i>b</i>.\n * <p>\n * <b>Note:</b> from version 4.1 onwards this method requires the input\n * collections and equator to be of compatible type (using bounded wildcards).\n * Providing incompatible arguments (e.g. by casting to their rawtypes)\n * will result in a {@code ClassCastException} thrown at runtime.\n *\n * @param <E>  the element type\n * @param a  the first collection, must not be null\n * @param b  the second collection, must not be null\n * @param equator  the Equator used for testing equality\n * @return <code>true</code> iff the collections contain the same elements with the same cardinalities.\n * @throws NullPointerException if the equator is null\n * @since 4.0\n */\npublic static <E> boolean isEqualCollection(final Collection<? extends E> a, final Collection<? extends E> b, final Equator<? super E> equator) {\n    if (equator == null) {\n        throw new NullPointerException(\"Equator must not be null.\");\n    }\n    if (a.size() != b.size()) {\n        return false;\n    }\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    final Transformer<E, ?> transformer = new Transformer() {\n\n        public EquatorWrapper<?> transform(final Object input) {\n            return new EquatorWrapper(equator, input);\n        }\n    };\n    return isEqualCollection(collect(a, transformer), collect(b, transformer));\n}"
            ],
            [
                "cardinality",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns the number of occurrences of <i>obj</i> in <i>coll</i>.\n *\n * @param obj the object to find the cardinality of\n * @param coll the {@link Iterable} to search\n * @param <O> the type of object that the {@link Iterable} may contain.\n * @return the the number of occurrences of obj in coll\n * @throws NullPointerException if coll is null\n * @deprecated since 4.1, use {@link IterableUtils#frequency(Iterable, Object)} instead.\n *   Be aware that the order of parameters has changed.\n */\n@Deprecated\npublic static <O> int cardinality(final O obj, final Iterable<? super O> coll) {\n    if (coll == null) {\n        throw new NullPointerException(\"coll must not be null.\");\n    }\n    return IterableUtils.frequency(coll, obj);\n}"
            ],
            [
                "find",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Finds the first element in the given collection which matches the given predicate.\n * <p>\n * If the input collection or predicate is null, or no element of the collection\n * matches the predicate, null is returned.\n *\n * @param <T>  the type of object the {@link Iterable} contains\n * @param collection  the collection to search, may be null\n * @param predicate  the predicate to use, may be null\n * @return the first element of the collection which matches the predicate or null if none could be found\n * @deprecated since 4.1, use {@link IterableUtils#find(Iterable, Predicate)} instead\n */\n@Deprecated\npublic static <T> T find(final Iterable<T> collection, final Predicate<? super T> predicate) {\n    return predicate != null ? IterableUtils.find(collection, predicate) : null;\n}"
            ],
            [
                "forAllDo",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Executes the given closure on each element in the collection.\n * <p>\n * If the input collection or closure is null, there is no change made.\n *\n * @param <T>  the type of object the {@link Iterable} contains\n * @param <C>  the closure type\n * @param collection  the collection to get the input from, may be null\n * @param closure  the closure to perform, may be null\n * @return closure\n * @deprecated since 4.1, use {@link IterableUtils#forEach(Iterable, Closure)} instead\n */\n@Deprecated\npublic static <T, C extends Closure<? super T>> C forAllDo(final Iterable<T> collection, final C closure) {\n    if (closure != null) {\n        IterableUtils.forEach(collection, closure);\n    }\n    return closure;\n}"
            ],
            [
                "forAllDo",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Executes the given closure on each element in the collection.\n * <p>\n * If the input collection or closure is null, there is no change made.\n *\n * @param <T>  the type of object the {@link Iterator} contains\n * @param <C>  the closure type\n * @param iterator  the iterator to get the input from, may be null\n * @param closure  the closure to perform, may be null\n * @return closure\n * @since 4.0\n * @deprecated since 4.1, use {@link IteratorUtils#forEach(Iterator, Closure)} instead\n */\n@Deprecated\npublic static <T, C extends Closure<? super T>> C forAllDo(final Iterator<T> iterator, final C closure) {\n    if (closure != null) {\n        IteratorUtils.forEach(iterator, closure);\n    }\n    return closure;\n}"
            ],
            [
                "forAllButLastDo",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Executes the given closure on each but the last element in the collection.\n * <p>\n * If the input collection or closure is null, there is no change made.\n *\n * @param <T>  the type of object the {@link Iterable} contains\n * @param <C>  the closure type\n * @param collection  the collection to get the input from, may be null\n * @param closure  the closure to perform, may be null\n * @return the last element in the collection, or null if either collection or closure is null\n * @since 4.0\n * @deprecated since 4.1, use {@link IterableUtils#forEachButLast(Iterable, Closure)} instead\n */\n@Deprecated\npublic static <T, C extends Closure<? super T>> T forAllButLastDo(final Iterable<T> collection, final C closure) {\n    return closure != null ? IterableUtils.forEachButLast(collection, closure) : null;\n}"
            ],
            [
                "forAllButLastDo",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Executes the given closure on each but the last element in the collection.\n * <p>\n * If the input collection or closure is null, there is no change made.\n *\n * @param <T>  the type of object the {@link Collection} contains\n * @param <C>  the closure type\n * @param iterator  the iterator to get the input from, may be null\n * @param closure  the closure to perform, may be null\n * @return the last element in the collection, or null if either iterator or closure is null\n * @since 4.0\n * @deprecated since 4.1, use {@link IteratorUtils#forEachButLast(Iterator, Closure)} instead\n */\n@Deprecated\npublic static <T, C extends Closure<? super T>> T forAllButLastDo(final Iterator<T> iterator, final C closure) {\n    return closure != null ? IteratorUtils.forEachButLast(iterator, closure) : null;\n}"
            ],
            [
                "filter",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Filter the collection by applying a Predicate to each element. If the\n * predicate returns false, remove the element.\n * <p>\n * If the input collection or predicate is null, there is no change made.\n *\n * @param <T>  the type of object the {@link Iterable} contains\n * @param collection  the collection to get the input from, may be null\n * @param predicate  the predicate to use as a filter, may be null\n * @return true if the collection is modified by this call, false otherwise.\n */\npublic static <T> boolean filter(final Iterable<T> collection, final Predicate<? super T> predicate) {\n    boolean result = false;\n    if (collection != null && predicate != null) {\n        for (final Iterator<T> it = collection.iterator(); it.hasNext(); ) {\n            if (!predicate.evaluate(it.next())) {\n                it.remove();\n                result = true;\n            }\n        }\n    }\n    return result;\n}"
            ],
            [
                "filterInverse",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Filter the collection by applying a Predicate to each element. If the\n * predicate returns true, remove the element.\n * <p>\n * This is equivalent to <pre>filter(collection, PredicateUtils.notPredicate(predicate))</pre>\n * if predicate is != null.\n * <p>\n * If the input collection or predicate is null, there is no change made.\n *\n * @param <T>  the type of object the {@link Iterable} contains\n * @param collection  the collection to get the input from, may be null\n * @param predicate  the predicate to use as a filter, may be null\n * @return true if the collection is modified by this call, false otherwise.\n */\npublic static <T> boolean filterInverse(final Iterable<T> collection, final Predicate<? super T> predicate) {\n    return filter(collection, predicate == null ? null : PredicateUtils.notPredicate(predicate));\n}"
            ],
            [
                "countMatches",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Counts the number of elements in the input collection that match the\n * predicate.\n * <p>\n * A <code>null</code> collection or predicate matches no elements.\n *\n * @param <C>  the type of object the {@link Iterable} contains\n * @param input  the {@link Iterable} to get the input from, may be null\n * @param predicate  the predicate to use, may be null\n * @return the number of matches for the predicate in the collection\n * @deprecated since 4.1, use {@link IterableUtils#countMatches(Iterable, Predicate)} instead\n */\n@Deprecated\npublic static <C> int countMatches(final Iterable<C> input, final Predicate<? super C> predicate) {\n    return predicate == null ? 0 : (int) IterableUtils.countMatches(input, predicate);\n}"
            ],
            [
                "exists",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Answers true if a predicate is true for at least one element of a\n * collection.\n * <p>\n * A <code>null</code> collection or predicate returns false.\n *\n * @param <C>  the type of object the {@link Iterable} contains\n * @param input  the {@link Iterable} to get the input from, may be null\n * @param predicate  the predicate to use, may be null\n * @return true if at least one element of the collection matches the predicate\n * @deprecated since 4.1, use {@link IterableUtils#matchesAny(Iterable, Predicate)} instead\n */\n@Deprecated\npublic static <C> boolean exists(final Iterable<C> input, final Predicate<? super C> predicate) {\n    return predicate == null ? false : IterableUtils.matchesAny(input, predicate);\n}"
            ],
            [
                "matchesAll",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Answers true if a predicate is true for every element of a\n * collection.\n * <p>\n * A <code>null</code> predicate returns false.<br/>\n * A <code>null</code> or empty collection returns true.\n *\n * @param <C>  the type of object the {@link Iterable} contains\n * @param input  the {@link Iterable} to get the input from, may be null\n * @param predicate  the predicate to use, may be null\n * @return true if every element of the collection matches the predicate or if the\n * collection is empty, false otherwise\n * @since 4.0\n * @deprecated since 4.1, use {@link IterableUtils#matchesAll(Iterable, Predicate)} instead\n */\n@Deprecated\npublic static <C> boolean matchesAll(final Iterable<C> input, final Predicate<? super C> predicate) {\n    return predicate == null ? false : IterableUtils.matchesAll(input, predicate);\n}"
            ],
            [
                "select",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Selects all elements from input collection which match the given\n * predicate into an output collection.\n * <p>\n * A <code>null</code> predicate matches no elements.\n *\n * @param <O>  the type of object the {@link Iterable} contains\n * @param inputCollection  the collection to get the input from, may not be null\n * @param predicate  the predicate to use, may be null\n * @return the elements matching the predicate (new list)\n * @throws NullPointerException if the input collection is null\n */\npublic static <O> Collection<O> select(final Iterable<? extends O> inputCollection, final Predicate<? super O> predicate) {\n    final Collection<O> answer = inputCollection instanceof Collection<?> ? new ArrayList<O>(((Collection<?>) inputCollection).size()) : new ArrayList<O>();\n    return select(inputCollection, predicate, answer);\n}"
            ],
            [
                "select",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Selects all elements from input collection which match the given\n * predicate and adds them to outputCollection.\n * <p>\n * If the input collection or predicate is null, there is no change to the\n * output collection.\n *\n * @param <O>  the type of object the {@link Iterable} contains\n * @param <R>  the type of the output {@link Collection}\n * @param inputCollection  the collection to get the input from, may be null\n * @param predicate  the predicate to use, may be null\n * @param outputCollection  the collection to output into, may not be null if the inputCollection\n *   and predicate or not null\n * @return the outputCollection\n */\npublic static <O, R extends Collection<? super O>> R select(final Iterable<? extends O> inputCollection, final Predicate<? super O> predicate, final R outputCollection) {\n    if (inputCollection != null && predicate != null) {\n        for (final O item : inputCollection) {\n            if (predicate.evaluate(item)) {\n                outputCollection.add(item);\n            }\n        }\n    }\n    return outputCollection;\n}"
            ],
            [
                "select",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Selects all elements from inputCollection into an output and rejected collection,\n * based on the evaluation of the given predicate.\n * <p>\n * Elements matching the predicate are added to the <code>outputCollection</code>,\n * all other elements are added to the <code>rejectedCollection</code>.\n * <p>\n * If the input predicate is <code>null</code>, no elements are added to\n * <code>outputCollection</code> or <code>rejectedCollection</code>.\n * <p>\n * Note: calling the method is equivalent to the following code snippet:\n * <pre>\n *   select(inputCollection, predicate, outputCollection);\n *   selectRejected(inputCollection, predicate, rejectedCollection);\n * </pre>\n *\n * @param <O>  the type of object the {@link Iterable} contains\n * @param <R>  the type of the output {@link Collection}\n * @param inputCollection  the collection to get the input from, may be null\n * @param predicate  the predicate to use, may be null\n * @param outputCollection  the collection to output selected elements into, may not be null if the\n *   inputCollection and predicate are not null\n * @param rejectedCollection  the collection to output rejected elements into, may not be null if the\n *   inputCollection or predicate are not null\n * @return the outputCollection\n * @since 4.1\n */\npublic static <O, R extends Collection<? super O>> R select(final Iterable<? extends O> inputCollection, final Predicate<? super O> predicate, R outputCollection, R rejectedCollection) {\n    if (inputCollection != null && predicate != null) {\n        for (final O element : inputCollection) {\n            if (predicate.evaluate(element)) {\n                outputCollection.add(element);\n            } else {\n                rejectedCollection.add(element);\n            }\n        }\n    }\n    return outputCollection;\n}"
            ],
            [
                "selectRejected",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Selects all elements from inputCollection which don't match the given\n * predicate into an output collection.\n * <p>\n * If the input predicate is <code>null</code>, the result is an empty\n * list.\n *\n * @param <O>  the type of object the {@link Iterable} contains\n * @param inputCollection  the collection to get the input from, may not be null\n * @param predicate  the predicate to use, may be null\n * @return the elements <b>not</b> matching the predicate (new list)\n * @throws NullPointerException if the input collection is null\n */\npublic static <O> Collection<O> selectRejected(final Iterable<? extends O> inputCollection, final Predicate<? super O> predicate) {\n    final Collection<O> answer = inputCollection instanceof Collection<?> ? new ArrayList<O>(((Collection<?>) inputCollection).size()) : new ArrayList<O>();\n    return selectRejected(inputCollection, predicate, answer);\n}"
            ],
            [
                "selectRejected",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Selects all elements from inputCollection which don't match the given\n * predicate and adds them to outputCollection.\n * <p>\n * If the input predicate is <code>null</code>, no elements are added to\n * <code>outputCollection</code>.\n *\n * @param <O>  the type of object the {@link Iterable} contains\n * @param <R>  the type of the output {@link Collection}\n * @param inputCollection  the collection to get the input from, may be null\n * @param predicate  the predicate to use, may be null\n * @param outputCollection  the collection to output into, may not be null if the inputCollection\n *   and predicate or not null\n * @return outputCollection\n */\npublic static <O, R extends Collection<? super O>> R selectRejected(final Iterable<? extends O> inputCollection, final Predicate<? super O> predicate, final R outputCollection) {\n    if (inputCollection != null && predicate != null) {\n        for (final O item : inputCollection) {\n            if (!predicate.evaluate(item)) {\n                outputCollection.add(item);\n            }\n        }\n    }\n    return outputCollection;\n}"
            ],
            [
                "collect",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns a new Collection containing all elements of the input collection\n * transformed by the given transformer.\n * <p>\n * If the input collection or transformer is null, the result is an empty list.\n *\n * @param <I>  the type of object in the input collection\n * @param <O>  the type of object in the output collection\n * @param inputCollection  the collection to get the input from, may not be null\n * @param transformer  the transformer to use, may be null\n * @return the transformed result (new list)\n * @throws NullPointerException if the input collection is null\n */\npublic static <I, O> Collection<O> collect(final Iterable<I> inputCollection, final Transformer<? super I, ? extends O> transformer) {\n    final Collection<O> answer = inputCollection instanceof Collection<?> ? new ArrayList<O>(((Collection<?>) inputCollection).size()) : new ArrayList<O>();\n    return collect(inputCollection, transformer, answer);\n}"
            ],
            [
                "collect",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Transforms all elements from the input iterator with the given transformer\n * and adds them to the output collection.\n * <p>\n * If the input iterator or transformer is null, the result is an empty list.\n *\n * @param <I>  the type of object in the input collection\n * @param <O>  the type of object in the output collection\n * @param inputIterator  the iterator to get the input from, may be null\n * @param transformer  the transformer to use, may be null\n * @return the transformed result (new list)\n */\npublic static <I, O> Collection<O> collect(final Iterator<I> inputIterator, final Transformer<? super I, ? extends O> transformer) {\n    return collect(inputIterator, transformer, new ArrayList<O>());\n}"
            ],
            [
                "collect",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Transforms all elements from input collection with the given transformer\n * and adds them to the output collection.\n * <p>\n * If the input collection or transformer is null, there is no change to the\n * output collection.\n *\n * @param <I>  the type of object in the input collection\n * @param <O>  the type of object in the output collection\n * @param <R>  the type of the output collection\n * @param inputCollection  the collection to get the input from, may be null\n * @param transformer  the transformer to use, may be null\n * @param outputCollection  the collection to output into, may not be null if inputCollection\n *   and transformer are not null\n * @return the output collection with the transformed input added\n * @throws NullPointerException if the outputCollection is null and both, inputCollection and\n *   transformer are not null\n */\npublic static <I, O, R extends Collection<? super O>> R collect(final Iterable<? extends I> inputCollection, final Transformer<? super I, ? extends O> transformer, final R outputCollection) {\n    if (inputCollection != null) {\n        return collect(inputCollection.iterator(), transformer, outputCollection);\n    }\n    return outputCollection;\n}"
            ],
            [
                "collect",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Transforms all elements from the input iterator with the given transformer\n * and adds them to the output collection.\n * <p>\n * If the input iterator or transformer is null, there is no change to the\n * output collection.\n *\n * @param <I>  the type of object in the input collection\n * @param <O>  the type of object in the output collection\n * @param <R>  the type of the output collection\n * @param inputIterator  the iterator to get the input from, may be null\n * @param transformer  the transformer to use, may be null\n * @param outputCollection  the collection to output into, may not be null if inputIterator\n *   and transformer are not null\n * @return the outputCollection with the transformed input added\n * @throws NullPointerException if the output collection is null and both, inputIterator and\n *   transformer are not null\n */\npublic static <I, O, R extends Collection<? super O>> R collect(final Iterator<? extends I> inputIterator, final Transformer<? super I, ? extends O> transformer, final R outputCollection) {\n    if (inputIterator != null && transformer != null) {\n        while (inputIterator.hasNext()) {\n            final I item = inputIterator.next();\n            final O value = transformer.transform(item);\n            outputCollection.add(value);\n        }\n    }\n    return outputCollection;\n}"
            ],
            [
                "addIgnoreNull",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "//-----------------------------------------------------------------------\n/**\n * Adds an element to the collection unless the element is null.\n *\n * @param <T>  the type of object the {@link Collection} contains\n * @param collection  the collection to add to, must not be null\n * @param object  the object to add, if null it will not be added\n * @return true if the collection changed\n * @throws NullPointerException if the collection is null\n * @since 3.2\n */\npublic static <T> boolean addIgnoreNull(final Collection<T> collection, final T object) {\n    if (collection == null) {\n        throw new NullPointerException(\"The collection must not be null\");\n    }\n    return object != null && collection.add(object);\n}"
            ],
            [
                "addAll",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Adds all elements in the {@link Iterable} to the given collection. If the\n * {@link Iterable} is a {@link Collection} then it is cast and will be\n * added using {@link Collection#addAll(Collection)} instead of iterating.\n *\n * @param <C>  the type of object the {@link Collection} contains\n * @param collection  the collection to add to, must not be null\n * @param iterable  the iterable of elements to add, must not be null\n * @return a boolean indicating whether the collection has changed or not.\n * @throws NullPointerException if the collection or iterator is null\n */\npublic static <C> boolean addAll(final Collection<C> collection, final Iterable<? extends C> iterable) {\n    if (iterable instanceof Collection<?>) {\n        return collection.addAll((Collection<? extends C>) iterable);\n    }\n    return addAll(collection, iterable.iterator());\n}"
            ],
            [
                "addAll",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Adds all elements in the iteration to the given collection.\n *\n * @param <C>  the type of object the {@link Collection} contains\n * @param collection  the collection to add to, must not be null\n * @param iterator  the iterator of elements to add, must not be null\n * @return a boolean indicating whether the collection has changed or not.\n * @throws NullPointerException if the collection or iterator is null\n */\npublic static <C> boolean addAll(final Collection<C> collection, final Iterator<? extends C> iterator) {\n    boolean changed = false;\n    while (iterator.hasNext()) {\n        changed |= collection.add(iterator.next());\n    }\n    return changed;\n}"
            ],
            [
                "addAll",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Adds all elements in the enumeration to the given collection.\n *\n * @param <C>  the type of object the {@link Collection} contains\n * @param collection  the collection to add to, must not be null\n * @param enumeration  the enumeration of elements to add, must not be null\n * @return {@code true} if the collections was changed, {@code false} otherwise\n * @throws NullPointerException if the collection or enumeration is null\n */\npublic static <C> boolean addAll(final Collection<C> collection, final Enumeration<? extends C> enumeration) {\n    boolean changed = false;\n    while (enumeration.hasMoreElements()) {\n        changed |= collection.add(enumeration.nextElement());\n    }\n    return changed;\n}"
            ],
            [
                "addAll",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Adds all elements in the array to the given collection.\n *\n * @param <C>  the type of object the {@link Collection} contains\n * @param collection  the collection to add to, must not be null\n * @param elements  the array of elements to add, must not be null\n * @return {@code true} if the collection was changed, {@code false} otherwise\n * @throws NullPointerException if the collection or array is null\n */\npublic static <C> boolean addAll(final Collection<C> collection, final C[] elements) {\n    boolean changed = false;\n    for (final C element : elements) {\n        changed |= collection.add(element);\n    }\n    return changed;\n}"
            ],
            [
                "get",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns the <code>index</code>-th value in {@link Iterator}, throwing\n * <code>IndexOutOfBoundsException</code> if there is no such element.\n * <p>\n * The Iterator is advanced to <code>index</code> (or to the end, if\n * <code>index</code> exceeds the number of entries) as a side effect of this method.\n *\n * @param iterator  the iterator to get a value from\n * @param index  the index to get\n * @param <T> the type of object in the {@link Iterator}\n * @return the object at the specified index\n * @throws IndexOutOfBoundsException if the index is invalid\n * @throws IllegalArgumentException if the object type is invalid\n * @deprecated since 4.1, use {@code IteratorUtils.get(Iterator, int)} instead\n */\n@Deprecated\npublic static <T> T get(final Iterator<T> iterator, final int index) {\n    return IteratorUtils.get(iterator, index);\n}"
            ],
            [
                "get",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns the <code>index</code>-th value in the <code>iterable</code>'s {@link Iterator}, throwing\n * <code>IndexOutOfBoundsException</code> if there is no such element.\n * <p>\n * If the {@link Iterable} is a {@link List}, then it will use {@link List#get(int)}.\n *\n * @param iterable  the {@link Iterable} to get a value from\n * @param index  the index to get\n * @param <T> the type of object in the {@link Iterable}.\n * @return the object at the specified index\n * @throws IndexOutOfBoundsException if the index is invalid\n * @deprecated since 4.1, use {@code IterableUtils.get(Iterable, int)} instead\n */\n@Deprecated\npublic static <T> T get(final Iterable<T> iterable, final int index) {\n    return IterableUtils.get(iterable, index);\n}"
            ],
            [
                "get",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns the <code>index</code>-th value in <code>object</code>, throwing\n * <code>IndexOutOfBoundsException</code> if there is no such element or\n * <code>IllegalArgumentException</code> if <code>object</code> is not an\n * instance of one of the supported types.\n * <p>\n * The supported types, and associated semantics are:\n * <ul>\n * <li> Map -- the value returned is the <code>Map.Entry</code> in position\n *      <code>index</code> in the map's <code>entrySet</code> iterator,\n *      if there is such an entry.</li>\n * <li> List -- this method is equivalent to the list's get method.</li>\n * <li> Array -- the <code>index</code>-th array entry is returned,\n *      if there is such an entry; otherwise an <code>IndexOutOfBoundsException</code>\n *      is thrown.</li>\n * <li> Collection -- the value returned is the <code>index</code>-th object\n *      returned by the collection's default iterator, if there is such an element.</li>\n * <li> Iterator or Enumeration -- the value returned is the\n *      <code>index</code>-th object in the Iterator/Enumeration, if there\n *      is such an element.  The Iterator/Enumeration is advanced to\n *      <code>index</code> (or to the end, if <code>index</code> exceeds the\n *      number of entries) as a side effect of this method.</li>\n * </ul>\n *\n * @param object  the object to get a value from\n * @param index  the index to get\n * @return the object at the specified index\n * @throws IndexOutOfBoundsException if the index is invalid\n * @throws IllegalArgumentException if the object type is invalid\n */\npublic static Object get(final Object object, final int index) {\n    int i = index;\n    if (i < 0) {\n        throw new IndexOutOfBoundsException(\"Index cannot be negative: \" + i);\n    }\n    if (object instanceof Map<?, ?>) {\n        final Map<?, ?> map = (Map<?, ?>) object;\n        final Iterator<?> iterator = map.entrySet().iterator();\n        return IteratorUtils.get(iterator, i);\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object)[i];\n    } else if (object instanceof Iterator<?>) {\n        final Iterator<?> it = (Iterator<?>) object;\n        return IteratorUtils.get(it, i);\n    } else if (object instanceof Iterable<?>) {\n        final Iterable<?> iterable = (Iterable<?>) object;\n        return IterableUtils.get(iterable, i);\n    } else if (object instanceof Collection<?>) {\n        final Iterator<?> iterator = ((Collection<?>) object).iterator();\n        return IteratorUtils.get(iterator, i);\n    } else if (object instanceof Enumeration<?>) {\n        final Enumeration<?> it = (Enumeration<?>) object;\n        return EnumerationUtils.get(it, i);\n    } else if (object == null) {\n        throw new IllegalArgumentException(\"Unsupported object type: null\");\n    } else {\n        try {\n            return Array.get(object, i);\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}"
            ],
            [
                "get",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns the <code>index</code>-th <code>Map.Entry</code> in the <code>map</code>'s <code>entrySet</code>,\n * throwing <code>IndexOutOfBoundsException</code> if there is no such element.\n *\n * @param <K>  the key type in the {@link Map}\n * @param <V>  the key type in the {@link Map}\n * @param map  the object to get a value from\n * @param index  the index to get\n * @return the object at the specified index\n * @throws IndexOutOfBoundsException if the index is invalid\n */\npublic static <K, V> Map.Entry<K, V> get(final Map<K, V> map, final int index) {\n    checkIndexBounds(index);\n    return get(map.entrySet(), index);\n}"
            ],
            [
                "size",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Gets the size of the collection/iterator specified.\n * <p>\n * This method can handles objects as follows\n * <ul>\n * <li>Collection - the collection size\n * <li>Map - the map size\n * <li>Array - the array size\n * <li>Iterator - the number of elements remaining in the iterator\n * <li>Enumeration - the number of elements remaining in the enumeration\n * </ul>\n *\n * @param object  the object to get the size of, may be null\n * @return the size of the specified collection or 0 if the object was null\n * @throws IllegalArgumentException thrown if object is not recognised\n * @since 3.1\n */\npublic static int size(final Object object) {\n    if (object == null) {\n        return 0;\n    }\n    int total = 0;\n    if (object instanceof Map<?, ?>) {\n        total = ((Map<?, ?>) object).size();\n    } else if (object instanceof Collection<?>) {\n        total = ((Collection<?>) object).size();\n    } else if (object instanceof Iterable<?>) {\n        total = IterableUtils.size((Iterable<?>) object);\n    } else if (object instanceof Object[]) {\n        total = ((Object[]) object).length;\n    } else if (object instanceof Iterator<?>) {\n        total = IteratorUtils.size((Iterator<?>) object);\n    } else if (object instanceof Enumeration<?>) {\n        final Enumeration<?> it = (Enumeration<?>) object;\n        while (it.hasMoreElements()) {\n            total++;\n            it.nextElement();\n        }\n    } else {\n        try {\n            total = Array.getLength(object);\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n    return total;\n}"
            ],
            [
                "sizeIsEmpty",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Checks if the specified collection/array/iterator is empty.\n * <p>\n * This method can handles objects as follows\n * <ul>\n * <li>Collection - via collection isEmpty\n * <li>Map - via map isEmpty\n * <li>Array - using array size\n * <li>Iterator - via hasNext\n * <li>Enumeration - via hasMoreElements\n * </ul>\n * <p>\n * Note: This method is named to avoid clashing with\n * {@link #isEmpty(Collection)}.\n *\n * @param object  the object to get the size of, may be null\n * @return true if empty or null\n * @throws IllegalArgumentException thrown if object is not recognised\n * @since 3.2\n */\npublic static boolean sizeIsEmpty(final Object object) {\n    if (object == null) {\n        return true;\n    } else if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Iterable<?>) {\n        return IterableUtils.isEmpty((Iterable<?>) object);\n    } else if (object instanceof Map<?, ?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return ((Iterator<?>) object).hasNext() == false;\n    } else if (object instanceof Enumeration<?>) {\n        return ((Enumeration<?>) object).hasMoreElements() == false;\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}"
            ],
            [
                "isEmpty",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "//-----------------------------------------------------------------------\n/**\n * Null-safe check if the specified collection is empty.\n * <p>\n * Null returns true.\n *\n * @param coll  the collection to check, may be null\n * @return true if empty or null\n * @since 3.2\n */\npublic static boolean isEmpty(final Collection<?> coll) {\n    return coll == null || coll.isEmpty();\n}"
            ],
            [
                "isNotEmpty",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Null-safe check if the specified collection is not empty.\n * <p>\n * Null returns false.\n *\n * @param coll  the collection to check, may be null\n * @return true if non-null and non-empty\n * @since 3.2\n */\npublic static boolean isNotEmpty(final Collection<?> coll) {\n    return !isEmpty(coll);\n}"
            ],
            [
                "isFull",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns true if no more elements can be added to the Collection.\n * <p>\n * This method uses the {@link BoundedCollection} interface to determine the\n * full status. If the collection does not implement this interface then\n * false is returned.\n * <p>\n * The collection does not have to implement this interface directly.\n * If the collection has been decorated using the decorators subpackage\n * then these will be removed to access the BoundedCollection.\n *\n * @param coll  the collection to check\n * @return true if the BoundedCollection is full\n * @throws NullPointerException if the collection is null\n */\npublic static boolean isFull(final Collection<? extends Object> coll) {\n    if (coll == null) {\n        throw new NullPointerException(\"The collection must not be null\");\n    }\n    if (coll instanceof BoundedCollection) {\n        return ((BoundedCollection<?>) coll).isFull();\n    }\n    try {\n        final BoundedCollection<?> bcoll = UnmodifiableBoundedCollection.unmodifiableBoundedCollection(coll);\n        return bcoll.isFull();\n    } catch (final IllegalArgumentException ex) {\n        return false;\n    }\n}"
            ],
            [
                "maxSize",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Get the maximum number of elements that the Collection can contain.\n * <p>\n * This method uses the {@link BoundedCollection} interface to determine the\n * maximum size. If the collection does not implement this interface then\n * -1 is returned.\n * <p>\n * The collection does not have to implement this interface directly.\n * If the collection has been decorated using the decorators subpackage\n * then these will be removed to access the BoundedCollection.\n *\n * @param coll  the collection to check\n * @return the maximum size of the BoundedCollection, -1 if no maximum size\n * @throws NullPointerException if the collection is null\n */\npublic static int maxSize(final Collection<? extends Object> coll) {\n    if (coll == null) {\n        throw new NullPointerException(\"The collection must not be null\");\n    }\n    if (coll instanceof BoundedCollection) {\n        return ((BoundedCollection<?>) coll).maxSize();\n    }\n    try {\n        final BoundedCollection<?> bcoll = UnmodifiableBoundedCollection.unmodifiableBoundedCollection(coll);\n        return bcoll.maxSize();\n    } catch (final IllegalArgumentException ex) {\n        return -1;\n    }\n}"
            ],
            [
                "collate",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "//-----------------------------------------------------------------------\n/**\n * Merges two sorted Collections, a and b, into a single, sorted List\n * such that the natural ordering of the elements is retained.\n * <p>\n * Uses the standard O(n) merge algorithm for combining two sorted lists.\n *\n * @param <O>  the element type\n * @param a  the first collection, must not be null\n * @param b  the second collection, must not be null\n * @return a new sorted List, containing the elements of Collection a and b\n * @throws NullPointerException if either collection is null\n * @since 4.0\n */\npublic static <O extends Comparable<? super O>> List<O> collate(Iterable<? extends O> a, Iterable<? extends O> b) {\n    return collate(a, b, ComparatorUtils.<O>naturalComparator(), true);\n}"
            ],
            [
                "collate",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Merges two sorted Collections, a and b, into a single, sorted List\n * such that the natural ordering of the elements is retained.\n * <p>\n * Uses the standard O(n) merge algorithm for combining two sorted lists.\n *\n * @param <O>  the element type\n * @param a  the first collection, must not be null\n * @param b  the second collection, must not be null\n * @param includeDuplicates  if {@code true} duplicate elements will be retained, otherwise\n *   they will be removed in the output collection\n * @return a new sorted List, containing the elements of Collection a and b\n * @throws NullPointerException if either collection is null\n * @since 4.0\n */\npublic static <O extends Comparable<? super O>> List<O> collate(final Iterable<? extends O> a, final Iterable<? extends O> b, final boolean includeDuplicates) {\n    return collate(a, b, ComparatorUtils.<O>naturalComparator(), includeDuplicates);\n}"
            ],
            [
                "collate",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Merges two sorted Collections, a and b, into a single, sorted List\n * such that the ordering of the elements according to Comparator c is retained.\n * <p>\n * Uses the standard O(n) merge algorithm for combining two sorted lists.\n *\n * @param <O>  the element type\n * @param a  the first collection, must not be null\n * @param b  the second collection, must not be null\n * @param c  the comparator to use for the merge.\n * @return a new sorted List, containing the elements of Collection a and b\n * @throws NullPointerException if either collection or the comparator is null\n * @since 4.0\n */\npublic static <O> List<O> collate(final Iterable<? extends O> a, final Iterable<? extends O> b, final Comparator<? super O> c) {\n    return collate(a, b, c, true);\n}"
            ],
            [
                "collate",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Merges two sorted Collections, a and b, into a single, sorted List\n * such that the ordering of the elements according to Comparator c is retained.\n * <p>\n * Uses the standard O(n) merge algorithm for combining two sorted lists.\n *\n * @param <O>  the element type\n * @param a  the first collection, must not be null\n * @param b  the second collection, must not be null\n * @param c  the comparator to use for the merge.\n * @param includeDuplicates  if {@code true} duplicate elements will be retained, otherwise\n *   they will be removed in the output collection\n * @return a new sorted List, containing the elements of Collection a and b\n * @throws NullPointerException if either collection or the comparator is null\n * @since 4.0\n */\npublic static <O> List<O> collate(final Iterable<? extends O> a, final Iterable<? extends O> b, final Comparator<? super O> c, final boolean includeDuplicates) {\n    if (a == null || b == null) {\n        throw new NullPointerException(\"The collections must not be null\");\n    }\n    if (c == null) {\n        throw new NullPointerException(\"The comparator must not be null\");\n    }\n    // if both Iterables are a Collection, we can estimate the size\n    final int totalSize = a instanceof Collection<?> && b instanceof Collection<?> ? Math.max(1, ((Collection<?>) a).size() + ((Collection<?>) b).size()) : 10;\n    final Iterator<O> iterator = new CollatingIterator<O>(c, a.iterator(), b.iterator());\n    if (includeDuplicates) {\n        return IteratorUtils.toList(iterator, totalSize);\n    } else {\n        final ArrayList<O> mergedList = new ArrayList<O>(totalSize);\n        O lastItem = null;\n        while (iterator.hasNext()) {\n            final O item = iterator.next();\n            if (lastItem == null || !lastItem.equals(item)) {\n                mergedList.add(item);\n            }\n            lastItem = item;\n        }\n        mergedList.trimToSize();\n        return mergedList;\n    }\n}"
            ],
            [
                "permutations",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns a {@link Collection} of all the permutations of the input collection.\n * <p>\n * NOTE: the number of permutations of a given collection is equal to n!, where\n * n is the size of the collection. Thus, the resulting collection will become\n * <b>very</b> large for collections &gt; 10 (e.g. 10! = 3628800, 15! = 1307674368000).\n * <p>\n * For larger collections it is advised to use a {@link PermutationIterator} to\n * iterate over all permutations.\n *\n * @see PermutationIterator\n *\n * @param <E>  the element type\n * @param collection  the collection to create permutations for, may not be null\n * @return an unordered collection of all permutations of the input collection\n * @throws NullPointerException if collection is null\n * @since 4.0\n */\npublic static <E> Collection<List<E>> permutations(final Collection<E> collection) {\n    final PermutationIterator<E> it = new PermutationIterator<E>(collection);\n    final Collection<List<E>> result = new LinkedList<List<E>>();\n    while (it.hasNext()) {\n        result.add(it.next());\n    }\n    return result;\n}"
            ],
            [
                "retainAll",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns a collection containing all the elements in <code>collection</code>\n * that are also in <code>retain</code>. The cardinality of an element <code>e</code>\n * in the returned collection is the same as the cardinality of <code>e</code>\n * in <code>collection</code> unless <code>retain</code> does not contain <code>e</code>, in which\n * case the cardinality is zero. This method is useful if you do not wish to modify\n * the collection <code>c</code> and thus cannot call <code>c.retainAll(retain);</code>.\n * <p>\n * This implementation iterates over <code>collection</code>, checking each element in\n * turn to see if it's contained in <code>retain</code>. If it's contained, it's added\n * to the returned list. As a consequence, it is advised to use a collection type for\n * <code>retain</code> that provides a fast (e.g. O(1)) implementation of\n * {@link Collection#contains(Object)}.\n *\n * @param <C>  the type of object the {@link Collection} contains\n * @param collection  the collection whose contents are the target of the #retailAll operation\n * @param retain  the collection containing the elements to be retained in the returned collection\n * @return a <code>Collection</code> containing all the elements of <code>collection</code>\n * that occur at least once in <code>retain</code>.\n * @throws NullPointerException if either parameter is null\n * @since 3.2\n */\npublic static <C> Collection<C> retainAll(final Collection<C> collection, final Collection<?> retain) {\n    return ListUtils.retainAll(collection, retain);\n}"
            ],
            [
                "retainAll",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns a collection containing all the elements in\n * <code>collection</code> that are also in <code>retain</code>. The\n * cardinality of an element <code>e</code> in the returned collection is\n * the same as the cardinality of <code>e</code> in <code>collection</code>\n * unless <code>retain</code> does not contain <code>e</code>, in which case\n * the cardinality is zero. This method is useful if you do not wish to\n * modify the collection <code>c</code> and thus cannot call\n * <code>c.retainAll(retain);</code>.\n * <p>\n * Moreover this method uses an {@link Equator} instead of\n * {@link Object#equals(Object)} to determine the equality of the elements\n * in <code>collection</code> and <code>retain</code>. Hence this method is\n * useful in cases where the equals behavior of an object needs to be\n * modified without changing the object itself.\n *\n * @param <E> the type of object the {@link Collection} contains\n * @param collection the collection whose contents are the target of the {@code retainAll} operation\n * @param retain the collection containing the elements to be retained in the returned collection\n * @param equator the Equator used for testing equality\n * @return a <code>Collection</code> containing all the elements of <code>collection</code>\n * that occur at least once in <code>retain</code> according to the <code>equator</code>\n * @throws NullPointerException if any of the parameters is null\n * @since 4.1\n */\npublic static <E> Collection<E> retainAll(final Iterable<E> collection, final Iterable<? extends E> retain, final Equator<? super E> equator) {\n    final Transformer<E, EquatorWrapper<E>> transformer = new Transformer<E, EquatorWrapper<E>>() {\n\n        public EquatorWrapper<E> transform(E input) {\n            return new EquatorWrapper<E>(equator, input);\n        }\n    };\n    final Set<EquatorWrapper<E>> retainSet = collect(retain, transformer, new HashSet<EquatorWrapper<E>>());\n    final List<E> list = new ArrayList<E>();\n    for (final E element : collection) {\n        if (retainSet.contains(new EquatorWrapper<E>(equator, element))) {\n            list.add(element);\n        }\n    }\n    return list;\n}"
            ],
            [
                "removeAll",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Removes the elements in <code>remove</code> from <code>collection</code>. That is, this\n * method returns a collection containing all the elements in <code>c</code>\n * that are not in <code>remove</code>. The cardinality of an element <code>e</code>\n * in the returned collection is the same as the cardinality of <code>e</code>\n * in <code>collection</code> unless <code>remove</code> contains <code>e</code>, in which\n * case the cardinality is zero. This method is useful if you do not wish to modify\n * the collection <code>c</code> and thus cannot call <code>collection.removeAll(remove);</code>.\n * <p>\n * This implementation iterates over <code>collection</code>, checking each element in\n * turn to see if it's contained in <code>remove</code>. If it's not contained, it's added\n * to the returned list. As a consequence, it is advised to use a collection type for\n * <code>remove</code> that provides a fast (e.g. O(1)) implementation of\n * {@link Collection#contains(Object)}.\n *\n * @param <E>  the type of object the {@link Collection} contains\n * @param collection  the collection from which items are removed (in the returned collection)\n * @param remove  the items to be removed from the returned <code>collection</code>\n * @return a <code>Collection</code> containing all the elements of <code>collection</code> except\n * any elements that also occur in <code>remove</code>.\n * @throws NullPointerException if either parameter is null\n * @since 4.0 (method existed in 3.2 but was completely broken)\n */\npublic static <E> Collection<E> removeAll(final Collection<E> collection, final Collection<?> remove) {\n    return ListUtils.removeAll(collection, remove);\n}"
            ],
            [
                "removeAll",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Removes all elements in <code>remove</code> from <code>collection</code>.\n * That is, this method returns a collection containing all the elements in\n * <code>collection</code> that are not in <code>remove</code>. The\n * cardinality of an element <code>e</code> in the returned collection is\n * the same as the cardinality of <code>e</code> in <code>collection</code>\n * unless <code>remove</code> contains <code>e</code>, in which case the\n * cardinality is zero. This method is useful if you do not wish to modify\n * the collection <code>c</code> and thus cannot call\n * <code>collection.removeAll(remove)</code>.\n * <p>\n * Moreover this method uses an {@link Equator} instead of\n * {@link Object#equals(Object)} to determine the equality of the elements\n * in <code>collection</code> and <code>remove</code>. Hence this method is\n * useful in cases where the equals behavior of an object needs to be\n * modified without changing the object itself.\n *\n * @param <E> the type of object the {@link Collection} contains\n * @param collection the collection from which items are removed (in the returned collection)\n * @param remove the items to be removed from the returned collection\n * @param equator the Equator used for testing equality\n * @return a <code>Collection</code> containing all the elements of <code>collection</code>\n * except any element that if equal according to the <code>equator</code>\n * @throws NullPointerException if any of the parameters is null\n * @since 4.1\n */\npublic static <E> Collection<E> removeAll(final Iterable<E> collection, final Iterable<? extends E> remove, final Equator<? super E> equator) {\n    final Transformer<E, EquatorWrapper<E>> transformer = new Transformer<E, EquatorWrapper<E>>() {\n\n        public EquatorWrapper<E> transform(E input) {\n            return new EquatorWrapper<E>(equator, input);\n        }\n    };\n    final Set<EquatorWrapper<E>> removeSet = collect(remove, transformer, new HashSet<EquatorWrapper<E>>());\n    final List<E> list = new ArrayList<E>();\n    for (final E element : collection) {\n        if (!removeSet.contains(new EquatorWrapper<E>(equator, element))) {\n            list.add(element);\n        }\n    }\n    return list;\n}"
            ],
            [
                "synchronizedCollection",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns a synchronized collection backed by the given collection.\n * <p>\n * You must manually synchronize on the returned buffer's iterator to\n * avoid non-deterministic behavior:\n *\n * <pre>\n * Collection c = CollectionUtils.synchronizedCollection(myCollection);\n * synchronized (c) {\n *     Iterator i = c.iterator();\n *     while (i.hasNext()) {\n *         process (i.next());\n *     }\n * }\n * </pre>\n *\n * This method uses the implementation in the decorators subpackage.\n *\n * @param <C>  the type of object the {@link Collection} contains\n * @param collection  the collection to synchronize, must not be null\n * @return a synchronized collection backed by the given collection\n * @throws NullPointerException if the collection is null\n * @deprecated since 4.1, use {@link java.util.Collections#synchronizedCollection(Collection)} instead\n */\n@Deprecated\npublic static <C> Collection<C> synchronizedCollection(final Collection<C> collection) {\n    return SynchronizedCollection.synchronizedCollection(collection);\n}"
            ],
            [
                "unmodifiableCollection",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns an unmodifiable collection backed by the given collection.\n * <p>\n * This method uses the implementation in the decorators subpackage.\n *\n * @param <C>  the type of object the {@link Collection} contains\n * @param collection  the collection to make unmodifiable, must not be null\n * @return an unmodifiable collection backed by the given collection\n * @throws NullPointerException if the collection is null\n * @deprecated since 4.1, use {@link java.util.Collections#unmodifiableCollection(Collection)} instead\n */\n@Deprecated\npublic static <C> Collection<C> unmodifiableCollection(final Collection<? extends C> collection) {\n    return UnmodifiableCollection.unmodifiableCollection(collection);\n}"
            ],
            [
                "predicatedCollection",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns a predicated (validating) collection backed by the given collection.\n * <p>\n * Only objects that pass the test in the given predicate can be added to the collection.\n * Trying to add an invalid object results in an IllegalArgumentException.\n * It is important not to use the original collection after invoking this method,\n * as it is a backdoor for adding invalid objects.\n *\n * @param <C> the type of objects in the Collection.\n * @param collection  the collection to predicate, must not be null\n * @param predicate  the predicate for the collection, must not be null\n * @return a predicated collection backed by the given collection\n * @throws NullPointerException if the Collection is null\n */\npublic static <C> Collection<C> predicatedCollection(final Collection<C> collection, final Predicate<? super C> predicate) {\n    return PredicatedCollection.predicatedCollection(collection, predicate);\n}"
            ],
            [
                "transformingCollection",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns a transformed bag backed by the given collection.\n * <p>\n * Each object is passed through the transformer as it is added to the\n * Collection. It is important not to use the original collection after invoking this\n * method, as it is a backdoor for adding untransformed objects.\n * <p>\n * Existing entries in the specified collection will not be transformed.\n * If you want that behaviour, see {@link TransformedCollection#transformedCollection}.\n *\n * @param <E> the type of object the {@link Collection} contains\n * @param collection  the collection to predicate, must not be null\n * @param transformer  the transformer for the collection, must not be null\n * @return a transformed collection backed by the given collection\n * @throws NullPointerException if the Collection or Transformer is null\n */\npublic static <E> Collection<E> transformingCollection(final Collection<E> collection, final Transformer<? super E, ? extends E> transformer) {\n    return TransformedCollection.transformingCollection(collection, transformer);\n}"
            ],
            [
                "extractSingleton",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Extract the lone element of the specified Collection.\n * @param <E> collection type\n * @param collection to read\n * @return sole member of collection\n * @throws NullPointerException if collection is null\n * @throws IllegalArgumentException if collection is empty or contains more than one element\n * @since 4.0\n */\npublic static <E> E extractSingleton(final Collection<E> collection) {\n    if (collection == null) {\n        throw new NullPointerException(\"Collection must not be null.\");\n    }\n    if (collection.size() != 1) {\n        throw new IllegalArgumentException(\"Can extract singleton only when collection size == 1\");\n    }\n    return collection.iterator().next();\n}"
            ],
            [
                "transformingMap",
                "org.apache.commons.collections4.splitmap",
                "TransformedSplitMap",
                "/**\n * Factory method to create a transforming map.\n * <p>\n * If there are any elements already in the map being decorated, they are\n * NOT transformed.\n *\n * @param <J>  the input key type\n * @param <K>  the output key type\n * @param <U>  the input value type\n * @param <V>  the output value type\n * @param map the map to decorate, must not be null\n * @param keyTransformer the transformer to use for key conversion, must not be null\n * @param valueTransformer the transformer to use for value conversion, must not be null\n * @return a new transformed map\n * @throws NullPointerException if map or either of the transformers is null\n */\npublic static <J, K, U, V> TransformedSplitMap<J, K, U, V> transformingMap(final Map<K, V> map, final Transformer<? super J, ? extends K> keyTransformer, final Transformer<? super U, ? extends V> valueTransformer) {\n    return new TransformedSplitMap<J, K, U, V>(map, keyTransformer, valueTransformer);\n}"
            ],
            [
                "emptyIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Empty\n// ----------------------------------------------------------------------\n/**\n * Gets an empty iterable.\n * <p>\n * This iterable does not contain any elements.\n *\n * @param <E> the element type\n * @return an empty iterable\n */\n// OK, empty collection is compatible with any type\n@SuppressWarnings(\"unchecked\")\npublic static <E> Iterable<E> emptyIterable() {\n    return EMPTY_ITERABLE;\n}"
            ],
            [
                "chainedIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Chained\n// ----------------------------------------------------------------------\n/**\n * Combines two iterables into a single iterable.\n * <p>\n * The returned iterable has an iterator that traverses the elements in {@code a},\n * followed by the elements in {@code b}. The source iterators are not polled until\n * necessary.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the corresponding\n * input iterator supports it.\n *\n * @param <E> the element type\n * @param a  the first iterable, may not be null\n * @param b  the second iterable, may not be null\n * @return a new iterable, combining the provided iterables\n * @throws NullPointerException if either a or b is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Iterable<E> chainedIterable(final Iterable<? extends E> a, final Iterable<? extends E> b) {\n    return chainedIterable(new Iterable[] { a, b });\n}"
            ],
            [
                "chainedIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Combines three iterables into a single iterable.\n * <p>\n * The returned iterable has an iterator that traverses the elements in {@code a},\n * followed by the elements in {@code b} and {@code c}. The source iterators are\n * not polled until necessary.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the corresponding\n * input iterator supports it.\n *\n * @param <E> the element type\n * @param a  the first iterable, may not be null\n * @param b  the second iterable, may not be null\n * @param c  the third iterable, may not be null\n * @return a new iterable, combining the provided iterables\n * @throws NullPointerException if either of the provided iterables is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Iterable<E> chainedIterable(final Iterable<? extends E> a, final Iterable<? extends E> b, final Iterable<? extends E> c) {\n    return chainedIterable(new Iterable[] { a, b, c });\n}"
            ],
            [
                "chainedIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Combines four iterables into a single iterable.\n * <p>\n * The returned iterable has an iterator that traverses the elements in {@code a},\n * followed by the elements in {@code b}, {@code c} and {@code d}. The source\n * iterators are not polled until necessary.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the corresponding\n * input iterator supports it.\n *\n * @param <E> the element type\n * @param a  the first iterable, may not be null\n * @param b  the second iterable, may not be null\n * @param c  the third iterable, may not be null\n * @param d  the fourth iterable, may not be null\n * @return a new iterable, combining the provided iterables\n * @throws NullPointerException if either of the provided iterables is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Iterable<E> chainedIterable(final Iterable<? extends E> a, final Iterable<? extends E> b, final Iterable<? extends E> c, final Iterable<? extends E> d) {\n    return chainedIterable(new Iterable[] { a, b, c, d });\n}"
            ],
            [
                "chainedIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Combines the provided iterables into a single iterable.\n * <p>\n * The returned iterable has an iterator that traverses the elements in the order\n * of the arguments, i.e. iterables[0], iterables[1], .... The source iterators\n * are not polled until necessary.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the corresponding\n * input iterator supports it.\n *\n * @param <E> the element type\n * @param iterables  the iterables to combine, may not be null\n * @return a new iterable, combining the provided iterables\n * @throws NullPointerException if either of the provided iterables is null\n */\npublic static <E> Iterable<E> chainedIterable(final Iterable<? extends E>... iterables) {\n    checkNotNull(iterables);\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            return new LazyIteratorChain<E>() {\n\n                @Override\n                protected Iterator<? extends E> nextIterator(int count) {\n                    if (count > iterables.length) {\n                        return null;\n                    } else {\n                        return iterables[count - 1].iterator();\n                    }\n                }\n            };\n        }\n    };\n}"
            ],
            [
                "collatedIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Collated\n// ----------------------------------------------------------------------\n/**\n * Combines the two provided iterables into an ordered iterable using\n * natural ordering.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the\n * corresponding input iterator supports it.\n *\n * @param <E> the element type\n * @param a  the first iterable, may not be null\n * @param b  the second iterable, may not be null\n * @return a filtered view on the specified iterable\n * @throws NullPointerException if either of the provided iterables is null\n */\npublic static <E> Iterable<E> collatedIterable(final Iterable<? extends E> a, final Iterable<? extends E> b) {\n    checkNotNull(a, b);\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            return IteratorUtils.collatedIterator(null, a.iterator(), b.iterator());\n        }\n    };\n}"
            ],
            [
                "collatedIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Combines the two provided iterables into an ordered iterable using the\n * provided comparator. If the comparator is null, natural ordering will be\n * used.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the\n * corresponding input iterator supports it.\n *\n * @param <E> the element type\n * @param comparator  the comparator defining an ordering over the elements,\n *   may be null, in which case natural ordering will be used\n * @param a  the first iterable, may not be null\n * @param b  the second iterable, may not be null\n * @return a filtered view on the specified iterable\n * @throws NullPointerException if either of the provided iterables is null\n */\npublic static <E> Iterable<E> collatedIterable(final Comparator<? super E> comparator, final Iterable<? extends E> a, final Iterable<? extends E> b) {\n    checkNotNull(a, b);\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            return IteratorUtils.collatedIterator(comparator, a.iterator(), b.iterator());\n        }\n    };\n}"
            ],
            [
                "filteredIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Filtered\n// ----------------------------------------------------------------------\n/**\n * Returns a view of the given iterable that only contains elements matching\n * the provided predicate.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the\n * corresponding input iterator supports it.\n *\n * @param <E> the element type\n * @param iterable  the iterable to filter, may not be null\n * @param predicate  the predicate used to filter elements, may not be null\n * @return a filtered view on the specified iterable\n * @throws NullPointerException if either iterable or predicate is null\n */\npublic static <E> Iterable<E> filteredIterable(final Iterable<E> iterable, final Predicate<? super E> predicate) {\n    checkNotNull(iterable);\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null.\");\n    }\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            return IteratorUtils.filteredIterator(emptyIteratorIfNull(iterable), predicate);\n        }\n    };\n}"
            ],
            [
                "boundedIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Bounded\n// ----------------------------------------------------------------------\n/**\n * Returns a view of the given iterable that contains at most the given number\n * of elements.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the corresponding\n * input iterator supports it.\n *\n * @param <E> the element type\n * @param iterable  the iterable to limit, may not be null\n * @param maxSize  the maximum number of elements, must not be negative\n * @return a bounded view on the specified iterable\n * @throws IllegalArgumentException if maxSize is negative\n * @throws NullPointerException if iterable is null\n */\npublic static <E> Iterable<E> boundedIterable(final Iterable<E> iterable, final long maxSize) {\n    checkNotNull(iterable);\n    if (maxSize < 0) {\n        throw new IllegalArgumentException(\"MaxSize parameter must not be negative.\");\n    }\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            return IteratorUtils.boundedIterator(iterable.iterator(), maxSize);\n        }\n    };\n}"
            ],
            [
                "loopingIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Looping\n// ----------------------------------------------------------------------\n/**\n * Returns a view of the given iterable which will cycle infinitely over\n * its elements.\n * <p>\n * The returned iterable's iterator supports {@code remove()} if\n * {@code iterable.iterator()} does. After {@code remove()} is called, subsequent\n * cycles omit the removed element, which is no longer in {@code iterable}. The\n * iterator's {@code hasNext()} method returns {@code true} until {@code iterable}\n * is empty.\n *\n * @param <E> the element type\n * @param iterable  the iterable to loop, may not be null\n * @return a view of the iterable, providing an infinite loop over its elements\n * @throws NullPointerException if iterable is null\n */\npublic static <E> Iterable<E> loopingIterable(final Iterable<E> iterable) {\n    checkNotNull(iterable);\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            return new LazyIteratorChain<E>() {\n\n                @Override\n                protected Iterator<? extends E> nextIterator(int count) {\n                    if (IterableUtils.isEmpty(iterable)) {\n                        return null;\n                    } else {\n                        return iterable.iterator();\n                    }\n                }\n            };\n        }\n    };\n}"
            ],
            [
                "reversedIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Reversed\n// ----------------------------------------------------------------------\n/**\n * Returns a reversed view of the given iterable.\n * <p>\n * In case the provided iterable is a {@link List} instance, a\n * {@link ReverseListIterator} will be used to reverse the traversal\n * order, otherwise an intermediate {@link List} needs to be created.\n * <p>\n * The returned iterable's iterator supports {@code remove()} if the\n * provided iterable is a {@link List} instance.\n *\n * @param <E> the element type\n * @param iterable  the iterable to use, may not be null\n * @return a reversed view of the specified iterable\n * @throws NullPointerException if iterable is null\n * @see ReverseListIterator\n */\npublic static <E> Iterable<E> reversedIterable(final Iterable<E> iterable) {\n    checkNotNull(iterable);\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            final List<E> list = (iterable instanceof List<?>) ? (List<E>) iterable : IteratorUtils.toList(iterable.iterator());\n            return new ReverseListIterator<E>(list);\n        }\n    };\n}"
            ],
            [
                "skippingIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Skipping\n// ----------------------------------------------------------------------\n/**\n * Returns a view of the given iterable that skips the first N elements.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the corresponding\n * input iterator supports it.\n *\n * @param <E> the element type\n * @param iterable  the iterable to use, may not be null\n * @param elementsToSkip  the number of elements to skip from the start, must not be negative\n * @return a view of the specified iterable, skipping the first N elements\n * @throws IllegalArgumentException if elementsToSkip is negative\n * @throws NullPointerException if iterable is null\n */\npublic static <E> Iterable<E> skippingIterable(final Iterable<E> iterable, final long elementsToSkip) {\n    checkNotNull(iterable);\n    if (elementsToSkip < 0) {\n        throw new IllegalArgumentException(\"ElementsToSkip parameter must not be negative.\");\n    }\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            return IteratorUtils.skippingIterator(iterable.iterator(), elementsToSkip);\n        }\n    };\n}"
            ],
            [
                "transformedIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Transformed\n// ----------------------------------------------------------------------\n/**\n * Returns a transformed view of the given iterable where all of its elements\n * have been transformed by the provided transformer.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the corresponding\n * input iterator supports it.\n *\n * @param <I>  the input element type\n * @param <O>  the output element type\n * @param iterable  the iterable to transform, may not be null\n * @param transformer  the transformer, must not be null\n * @return a transformed view of the specified iterable\n * @throws NullPointerException if either iterable or transformer is null\n */\npublic static <I, O> Iterable<O> transformedIterable(final Iterable<I> iterable, final Transformer<? super I, ? extends O> transformer) {\n    checkNotNull(iterable);\n    if (transformer == null) {\n        throw new NullPointerException(\"Transformer must not be null.\");\n    }\n    return new FluentIterable<O>() {\n\n        @Override\n        public Iterator<O> iterator() {\n            return IteratorUtils.transformedIterator(iterable.iterator(), transformer);\n        }\n    };\n}"
            ],
            [
                "uniqueIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Unique\n// ----------------------------------------------------------------------\n/**\n * Returns a unique view of the given iterable.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the\n * corresponding input iterator supports it. Calling {@code remove()}\n * will only remove a single element from the underlying iterator.\n *\n * @param <E> the element type\n * @param iterable  the iterable to use, may not be null\n * @return a unique view of the specified iterable\n * @throws NullPointerException if iterable is null\n */\npublic static <E> Iterable<E> uniqueIterable(final Iterable<E> iterable) {\n    checkNotNull(iterable);\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            return new UniqueFilterIterator<E>(iterable.iterator());\n        }\n    };\n}"
            ],
            [
                "unmodifiableIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Unmodifiable\n// ----------------------------------------------------------------------\n/**\n * Returns an unmodifiable view of the given iterable.\n * <p>\n * The returned iterable's iterator does not support {@code remove()}.\n *\n * @param <E> the element type\n * @param iterable  the iterable to use, may not be null\n * @return an unmodifiable view of the specified iterable\n * @throws NullPointerException if iterable is null\n */\npublic static <E> Iterable<E> unmodifiableIterable(final Iterable<E> iterable) {\n    checkNotNull(iterable);\n    if (iterable instanceof UnmodifiableIterable<?>) {\n        return iterable;\n    }\n    return new UnmodifiableIterable<E>(iterable);\n}"
            ],
            [
                "zippingIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Zipping\n// ----------------------------------------------------------------------\n/**\n * Interleaves two iterables into a single iterable.\n * <p>\n * The returned iterable has an iterator that traverses the elements in {@code a}\n * and {@code b} in alternating order. The source iterators are not polled until\n * necessary.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the corresponding\n * input iterator supports it.\n *\n * @param <E> the element type\n * @param a  the first iterable, may not be null\n * @param b  the second iterable, may not be null\n * @return a new iterable, interleaving the provided iterables\n * @throws NullPointerException if either a or b is null\n */\npublic static <E> Iterable<E> zippingIterable(final Iterable<? extends E> a, final Iterable<? extends E> b) {\n    checkNotNull(a);\n    checkNotNull(b);\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            return IteratorUtils.zippingIterator(a.iterator(), b.iterator());\n        }\n    };\n}"
            ],
            [
                "zippingIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Interleaves two iterables into a single iterable.\n * <p>\n * The returned iterable has an iterator that traverses the elements in {@code a}\n * and {@code b} in alternating order. The source iterators are not polled until\n * necessary.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the corresponding\n * input iterator supports it.\n *\n * @param <E> the element type\n * @param first  the first iterable, may not be null\n * @param others  the array of iterables to interleave, may not be null\n * @return a new iterable, interleaving the provided iterables\n * @throws NullPointerException if either of the provided iterables is null\n */\npublic static <E> Iterable<E> zippingIterable(final Iterable<? extends E> first, final Iterable<? extends E>... others) {\n    checkNotNull(first);\n    checkNotNull(others);\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            // safe\n            @SuppressWarnings(\"unchecked\")\n            Iterator<? extends E>[] iterators = new Iterator[others.length + 1];\n            iterators[0] = first.iterator();\n            for (int i = 0; i < others.length; i++) {\n                iterators[i + 1] = others[i].iterator();\n            }\n            return IteratorUtils.zippingIterator(iterators);\n        }\n    };\n}"
            ],
            [
                "emptyIfNull",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Utility methods\n// ----------------------------------------------------------------------\n/**\n * Returns an immutable empty iterable if the argument is null,\n * or the argument itself otherwise.\n *\n * @param <E> the element type\n * @param iterable  the iterable, may be null\n * @return an empty iterable if the argument is null\n */\npublic static <E> Iterable<E> emptyIfNull(final Iterable<E> iterable) {\n    return iterable == null ? IterableUtils.<E>emptyIterable() : iterable;\n}"
            ],
            [
                "forEachButLast",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Executes the given closure on each but the last element in the iterable.\n * <p>\n * If the input iterable is null no change is made.\n *\n * @param <E> the type of object the {@link Iterable} contains\n * @param iterable  the iterable to get the input from, may be null\n * @param closure  the closure to perform, may not be null\n * @return the last element in the iterable, or null if iterable is null or empty\n */\npublic static <E> E forEachButLast(final Iterable<E> iterable, final Closure<? super E> closure) {\n    return IteratorUtils.forEachButLast(emptyIteratorIfNull(iterable), closure);\n}"
            ],
            [
                "find",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Finds the first element in the given iterable which matches the given predicate.\n * <p>\n * A <code>null</code> or empty iterator returns null.\n *\n * @param <E> the element type\n * @param iterable  the iterable to search, may be null\n * @param predicate  the predicate to use, may not be null\n * @return the first element of the iterable which matches the predicate or null if none could be found\n * @throws NullPointerException if predicate is null\n */\npublic static <E> E find(final Iterable<E> iterable, final Predicate<? super E> predicate) {\n    return IteratorUtils.find(emptyIteratorIfNull(iterable), predicate);\n}"
            ],
            [
                "indexOf",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Returns the index of the first element in the specified iterable that\n * matches the given predicate.\n * <p>\n * A <code>null</code> or empty iterable returns -1.\n *\n * @param <E> the element type\n * @param iterable  the iterable to search, may be null\n * @param predicate  the predicate to use, may not be null\n * @return the index of the first element which matches the predicate or -1 if none matches\n * @throws NullPointerException if predicate is null\n */\npublic static <E> int indexOf(final Iterable<E> iterable, final Predicate<? super E> predicate) {\n    return IteratorUtils.indexOf(emptyIteratorIfNull(iterable), predicate);\n}"
            ],
            [
                "matchesAll",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Answers true if a predicate is true for every element of an iterable.\n * <p>\n * A <code>null</code> or empty iterable returns true.\n *\n * @param <E> the type of object the {@link Iterable} contains\n * @param iterable  the {@link Iterable} to use, may be null\n * @param predicate  the predicate to use, may not be null\n * @return true if every element of the collection matches the predicate or if the\n *   collection is empty, false otherwise\n * @throws NullPointerException if predicate is null\n */\npublic static <E> boolean matchesAll(final Iterable<E> iterable, final Predicate<? super E> predicate) {\n    return IteratorUtils.matchesAll(emptyIteratorIfNull(iterable), predicate);\n}"
            ],
            [
                "matchesAny",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Answers true if a predicate is true for any element of the iterable.\n * <p>\n * A <code>null</code> or empty iterable returns false.\n *\n * @param <E> the type of object the {@link Iterable} contains\n * @param iterable  the {@link Iterable} to use, may be null\n * @param predicate  the predicate to use, may not be null\n * @return true if any element of the collection matches the predicate, false otherwise\n * @throws NullPointerException if predicate is null\n */\npublic static <E> boolean matchesAny(final Iterable<E> iterable, final Predicate<? super E> predicate) {\n    return IteratorUtils.matchesAny(emptyIteratorIfNull(iterable), predicate);\n}"
            ],
            [
                "countMatches",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Counts the number of elements in the input iterable that match the predicate.\n * <p>\n * A <code>null</code> iterable matches no elements.\n *\n * @param <E> the type of object the {@link Iterable} contains\n * @param input  the {@link Iterable} to get the input from, may be null\n * @param predicate  the predicate to use, may not be null\n * @return the number of matches for the predicate in the collection\n * @throws NullPointerException if predicate is null\n */\npublic static <E> long countMatches(final Iterable<E> input, final Predicate<? super E> predicate) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null.\");\n    }\n    return size(filteredIterable(emptyIfNull(input), predicate));\n}"
            ],
            [
                "isEmpty",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Answers true if the provided iterable is empty.\n * <p>\n * A <code>null</code> iterable returns true.\n *\n * @param iterable  the {@link Iterable to use}, may be null\n * @return true if the iterable is null or empty, false otherwise\n */\npublic static boolean isEmpty(final Iterable<?> iterable) {\n    if (iterable instanceof Collection<?>) {\n        return ((Collection<?>) iterable).isEmpty();\n    } else {\n        return IteratorUtils.isEmpty(emptyIteratorIfNull(iterable));\n    }\n}"
            ],
            [
                "contains",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Checks if the object is contained in the given iterable.\n * <p>\n * A <code>null</code> or empty iterable returns false.\n *\n * @param <E> the type of object the {@link Iterable} contains\n * @param iterable  the iterable to check, may be null\n * @param object  the object to check\n * @return true if the object is contained in the iterable, false otherwise\n */\npublic static <E> boolean contains(final Iterable<E> iterable, final Object object) {\n    if (iterable instanceof Collection<?>) {\n        return ((Collection<E>) iterable).contains(object);\n    } else {\n        return IteratorUtils.contains(emptyIteratorIfNull(iterable), object);\n    }\n}"
            ],
            [
                "contains",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Checks if the object is contained in the given iterable. Object equality\n * is tested with an {@code equator} unlike {@link #contains(Iterable, Object)}\n * which uses {@link Object#equals(Object)}.\n * <p>\n * A <code>null</code> or empty iterable returns false.\n * A <code>null</code> object will not be passed to the equator, instead a\n * {@link org.apache.commons.collections4.functors.NullPredicate NullPredicate}\n * will be used.\n *\n * @param <E> the type of object the {@link Iterable} contains\n * @param iterable  the iterable to check, may be null\n * @param object  the object to check\n * @param equator  the equator to use to check, may not be null\n * @return true if the object is contained in the iterable, false otherwise\n * @throws NullPointerException if equator is null\n */\npublic static <E> boolean contains(final Iterable<? extends E> iterable, final E object, final Equator<? super E> equator) {\n    if (equator == null) {\n        throw new NullPointerException(\"Equator must not be null.\");\n    }\n    return matchesAny(iterable, EqualPredicate.equalPredicate(object, equator));\n}"
            ],
            [
                "frequency",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Returns the number of occurrences of the provided object in the iterable.\n *\n * @param <E> the element type that the {@link Iterable} may contain\n * @param <T> the element type of the object to find\n * @param iterable  the {@link Iterable} to search\n * @param obj  the object to find the cardinality of\n * @return the the number of occurrences of obj in iterable\n */\npublic static <E, T extends E> int frequency(final Iterable<E> iterable, final T obj) {\n    if (iterable instanceof Set<?>) {\n        return ((Set<E>) iterable).contains(obj) ? 1 : 0;\n    }\n    if (iterable instanceof Bag<?>) {\n        return ((Bag<E>) iterable).getCount(obj);\n    }\n    return size(filteredIterable(emptyIfNull(iterable), EqualPredicate.<E>equalPredicate(obj)));\n}"
            ],
            [
                "get",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Returns the <code>index</code>-th value in the <code>iterable</code>'s {@link Iterator}, throwing\n * <code>IndexOutOfBoundsException</code> if there is no such element.\n * <p>\n * If the {@link Iterable} is a {@link List}, then it will use {@link List#get(int)}.\n *\n * @param <T> the type of object in the {@link Iterable}.\n * @param iterable  the {@link Iterable} to get a value from, may be null\n * @param index  the index to get\n * @return the object at the specified index\n * @throws IndexOutOfBoundsException if the index is invalid\n */\npublic static <T> T get(final Iterable<T> iterable, final int index) {\n    CollectionUtils.checkIndexBounds(index);\n    if (iterable instanceof List<?>) {\n        return ((List<T>) iterable).get(index);\n    }\n    return IteratorUtils.get(emptyIteratorIfNull(iterable), index);\n}"
            ],
            [
                "size",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Returns the number of elements contained in the given iterator.\n * <p>\n * A <code>null</code> or empty iterator returns {@code 0}.\n *\n * @param iterable  the iterable to check, may be null\n * @return the number of elements contained in the iterable\n */\npublic static int size(final Iterable<?> iterable) {\n    if (iterable instanceof Collection<?>) {\n        return ((Collection<?>) iterable).size();\n    } else {\n        return IteratorUtils.size(emptyIteratorIfNull(iterable));\n    }\n}"
            ],
            [
                "partition",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Partitions all elements from iterable into separate output collections,\n * based on the evaluation of the given predicate.\n * <p>\n * For each predicate, the result will contain a list holding all elements of the\n * input iterable matching the predicate. The last list will hold all elements\n * which didn't match any predicate:\n * <pre>\n *  [C1, R] = partition(I, P1) with\n *  I = input\n *  P1 = first predicate\n *  C1 = collection of elements matching P1\n *  R = collection of elements rejected by all predicates\n * </pre>\n * <p>\n * If the input iterable is <code>null</code>, the same is returned as for an\n * empty iterable.\n * <p>\n * Example: for an input list [1, 2, 3, 4, 5] calling partition with a predicate [x &lt; 3]\n * will result in the following output: [[1, 2], [3, 4, 5]].\n *\n * @param <O>  the type of object the {@link Iterable} contains\n * @param iterable  the iterable to partition, may be null\n * @param predicate  the predicate to use, may not be null\n * @return a list containing the output collections\n * @throws NullPointerException if predicate is null\n */\npublic static <O> List<List<O>> partition(final Iterable<? extends O> iterable, final Predicate<? super O> predicate) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null.\");\n    }\n    // safe\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    final Factory<List<O>> factory = FactoryUtils.instantiateFactory((Class) ArrayList.class);\n    // safe\n    @SuppressWarnings(\"unchecked\")\n    final Predicate<? super O>[] predicates = new Predicate[] { predicate };\n    return partition(iterable, factory, predicates);\n}"
            ],
            [
                "partition",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Partitions all elements from iterable into separate output collections,\n * based on the evaluation of the given predicates.\n * <p>\n * For each predicate, the result will contain a list holding all elements of the\n * input iterable matching the predicate. The last list will hold all elements\n * which didn't match any predicate:\n * <pre>\n *  [C1, C2, R] = partition(I, P1, P2) with\n *  I = input\n *  P1 = first predicate\n *  P2 = second predicate\n *  C1 = collection of elements matching P1\n *  C2 = collection of elements matching P2\n *  R = collection of elements rejected by all predicates\n * </pre>\n * <p>\n * <b>Note</b>: elements are only added to the output collection of the first matching\n * predicate, determined by the order of arguments.\n * <p>\n * If the input iterable is <code>null</code>, the same is returned as for an\n * empty iterable.\n * <p>\n * Example: for an input list [1, 2, 3, 4, 5] calling partition with predicates [x &lt; 3]\n * and [x &lt; 5] will result in the following output: [[1, 2], [3, 4], [5]].\n *\n * @param <O>  the type of object the {@link Iterable} contains\n * @param iterable  the collection to get the input from, may be null\n * @param predicates  the predicates to use, may not be null\n * @return a list containing the output collections\n * @throws NullPointerException if any predicate is null\n */\npublic static <O> List<List<O>> partition(final Iterable<? extends O> iterable, final Predicate<? super O>... predicates) {\n    // safe\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    final Factory<List<O>> factory = FactoryUtils.instantiateFactory((Class) ArrayList.class);\n    return partition(iterable, factory, predicates);\n}"
            ],
            [
                "partition",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Partitions all elements from iterable into separate output collections,\n * based on the evaluation of the given predicates.\n * <p>\n * For each predicate, the returned list will contain a collection holding\n * all elements of the input iterable matching the predicate. The last collection\n * contained in the list will hold all elements which didn't match any predicate:\n * <pre>\n *  [C1, C2, R] = partition(I, P1, P2) with\n *  I = input\n *  P1 = first predicate\n *  P2 = second predicate\n *  C1 = collection of elements matching P1\n *  C2 = collection of elements matching P2\n *  R = collection of elements rejected by all predicates\n * </pre>\n * <p>\n * <b>Note</b>: elements are only added to the output collection of the first matching\n * predicate, determined by the order of arguments.\n * <p>\n * If the input iterable is <code>null</code>, the same is returned as for an\n * empty iterable.\n * If no predicates have been provided, all elements of the input collection\n * will be added to the rejected collection.\n * <p>\n * Example: for an input list [1, 2, 3, 4, 5] calling partition with predicates [x &lt; 3]\n * and [x &lt; 5] will result in the following output: [[1, 2], [3, 4], [5]].\n *\n * @param <O>  the type of object the {@link Iterable} contains\n * @param <R>  the type of the output {@link Collection}\n * @param iterable  the collection to get the input from, may be null\n * @param partitionFactory  the factory used to create the output collections\n * @param predicates  the predicates to use, may not be null\n * @return a list containing the output collections\n * @throws NullPointerException if any predicate is null\n */\npublic static <O, R extends Collection<O>> List<R> partition(final Iterable<? extends O> iterable, final Factory<R> partitionFactory, final Predicate<? super O>... predicates) {\n    if (iterable == null) {\n        final Iterable<O> empty = emptyIterable();\n        return partition(empty, partitionFactory, predicates);\n    }\n    if (predicates == null) {\n        throw new NullPointerException(\"Predicates must not be null.\");\n    }\n    for (Predicate<?> p : predicates) {\n        if (p == null) {\n            throw new NullPointerException(\"Predicate must not be null.\");\n        }\n    }\n    if (predicates.length < 1) {\n        // return the entire input collection as a single partition\n        final R singlePartition = partitionFactory.create();\n        CollectionUtils.addAll(singlePartition, iterable);\n        return Collections.singletonList(singlePartition);\n    }\n    // create the empty partitions\n    final int numberOfPredicates = predicates.length;\n    final int numberOfPartitions = numberOfPredicates + 1;\n    final List<R> partitions = new ArrayList<R>(numberOfPartitions);\n    for (int i = 0; i < numberOfPartitions; ++i) {\n        partitions.add(partitionFactory.create());\n    }\n    // for each element in inputCollection:\n    // find the first predicate that evaluates to true.\n    // if there is a predicate, add the element to the corresponding partition.\n    // if there is no predicate, add it to the last, catch-all partition.\n    for (final O element : iterable) {\n        boolean elementAssigned = false;\n        for (int i = 0; i < numberOfPredicates; ++i) {\n            if (predicates[i].evaluate(element)) {\n                partitions.get(i).add(element);\n                elementAssigned = true;\n                break;\n            }\n        }\n        if (!elementAssigned) {\n            // no predicates evaluated to true\n            // add element to last partition\n            partitions.get(numberOfPredicates).add(element);\n        }\n    }\n    return partitions;\n}"
            ],
            [
                "toList",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Gets a new list with the contents of the provided iterable.\n *\n * @param <E> the element type\n * @param iterable  the iterable to use, may be null\n * @return a list of the iterator contents\n */\npublic static <E> List<E> toList(final Iterable<E> iterable) {\n    return IteratorUtils.toList(emptyIteratorIfNull(iterable));\n}"
            ],
            [
                "toString",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Returns a string representation of the elements of the specified iterable.\n * <p>\n * The string representation consists of a list of the iterable's elements,\n * enclosed in square brackets ({@code \"[]\"}). Adjacent elements are separated\n * by the characters {@code \", \"} (a comma followed by a space). Elements are\n * converted to strings as by {@code String.valueOf(Object)}.\n *\n * @param <E> the element type\n * @param iterable  the iterable to convert to a string, may be null\n * @return a string representation of {@code iterable}\n */\npublic static <E> String toString(final Iterable<E> iterable) {\n    return IteratorUtils.toString(emptyIteratorIfNull(iterable));\n}"
            ],
            [
                "toString",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Returns a string representation of the elements of the specified iterable.\n * <p>\n * The string representation consists of a list of the iterable's elements,\n * enclosed in square brackets ({@code \"[]\"}). Adjacent elements are separated\n * by the characters {@code \", \"} (a comma followed by a space). Elements are\n * converted to strings as by using the provided {@code transformer}.\n *\n * @param <E> the element type\n * @param iterable  the iterable to convert to a string, may be null\n * @param transformer  the transformer used to get a string representation of an element\n * @return a string representation of {@code iterable}\n * @throws NullPointerException if {@code transformer} is null\n */\npublic static <E> String toString(final Iterable<E> iterable, final Transformer<? super E, String> transformer) {\n    if (transformer == null) {\n        throw new NullPointerException(\"Transformer must not be null.\");\n    }\n    return IteratorUtils.toString(emptyIteratorIfNull(iterable), transformer);\n}"
            ],
            [
                "toString",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Returns a string representation of the elements of the specified iterable.\n * <p>\n * The string representation consists of a list of the iterable's elements,\n * enclosed by the provided {@code prefix} and {@code suffix}. Adjacent elements\n * are separated by the provided {@code delimiter}. Elements are converted to\n * strings as by using the provided {@code transformer}.\n *\n * @param <E> the element type\n * @param iterable  the iterable to convert to a string, may be null\n * @param transformer  the transformer used to get a string representation of an element\n * @param delimiter  the string to delimit elements\n * @param prefix  the prefix, prepended to the string representation\n * @param suffix  the suffix, appended to the string representation\n * @return a string representation of {@code iterable}\n * @throws NullPointerException if either transformer, delimiter, prefix or suffix is null\n */\npublic static <E> String toString(final Iterable<E> iterable, final Transformer<? super E, String> transformer, final String delimiter, final String prefix, final String suffix) {\n    return IteratorUtils.toString(emptyIteratorIfNull(iterable), transformer, delimiter, prefix, suffix);\n}"
            ],
            [
                "unmodifiableTrie",
                "org.apache.commons.collections4",
                "TrieUtils",
                "/**\n * Returns an unmodifiable instance of a {@link Trie}\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param trie  the trie to make unmodifiable, must not be null\n * @return an unmodifiable trie backed by the given trie\n * @throws NullPointerException if trie is null\n *\n * @see java.util.Collections#unmodifiableMap(java.util.Map)\n */\npublic static <K, V> Trie<K, V> unmodifiableTrie(final Trie<K, ? extends V> trie) {\n    return UnmodifiableTrie.unmodifiableTrie(trie);\n}"
            ],
            [
                "exceptionClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Gets a Closure that always throws an exception.\n * This could be useful during testing as a placeholder.\n *\n * @see org.apache.commons.collections4.functors.ExceptionClosure\n *\n * @param <E>  the type that the closure acts on\n * @return the closure\n */\npublic static <E> Closure<E> exceptionClosure() {\n    return ExceptionClosure.<E>exceptionClosure();\n}"
            ],
            [
                "nopClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Gets a Closure that will do nothing.\n * This could be useful during testing as a placeholder.\n *\n * @see org.apache.commons.collections4.functors.NOPClosure\n *\n * @param <E>  the type that the closure acts on\n * @return the closure\n */\npublic static <E> Closure<E> nopClosure() {\n    return NOPClosure.<E>nopClosure();\n}"
            ],
            [
                "asClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Creates a Closure that calls a Transformer each time it is called.\n * The transformer will be called using the closure's input object.\n * The transformer's result will be ignored.\n *\n * @see org.apache.commons.collections4.functors.TransformerClosure\n *\n * @param <E>  the type that the closure acts on\n * @param transformer  the transformer to run each time in the closure, null means nop\n * @return the closure\n */\npublic static <E> Closure<E> asClosure(final Transformer<? super E, ?> transformer) {\n    return TransformerClosure.transformerClosure(transformer);\n}"
            ],
            [
                "forClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Creates a Closure that will call the closure <code>count</code> times.\n * <p>\n * A null closure or zero count returns the <code>NOPClosure</code>.\n *\n * @see org.apache.commons.collections4.functors.ForClosure\n *\n * @param <E>  the type that the closure acts on\n * @param count  the number of times to loop\n * @param closure  the closure to call repeatedly\n * @return the <code>for</code> closure\n */\npublic static <E> Closure<E> forClosure(final int count, final Closure<? super E> closure) {\n    return ForClosure.forClosure(count, closure);\n}"
            ],
            [
                "whileClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Creates a Closure that will call the closure repeatedly until the\n * predicate returns false.\n *\n * @see org.apache.commons.collections4.functors.WhileClosure\n *\n * @param <E>  the type that the closure acts on\n * @param predicate  the predicate to use as an end of loop test, not null\n * @param closure  the closure to call repeatedly, not null\n * @return the <code>while</code> closure\n * @throws NullPointerException if either argument is null\n */\npublic static <E> Closure<E> whileClosure(final Predicate<? super E> predicate, final Closure<? super E> closure) {\n    return WhileClosure.<E>whileClosure(predicate, closure, false);\n}"
            ],
            [
                "doWhileClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Creates a Closure that will call the closure once and then repeatedly\n * until the predicate returns false.\n *\n * @see org.apache.commons.collections4.functors.WhileClosure\n *\n * @param <E>  the type that the closure acts on\n * @param closure  the closure to call repeatedly, not null\n * @param predicate  the predicate to use as an end of loop test, not null\n * @return the <code>do-while</code> closure\n * @throws NullPointerException if either argument is null\n */\npublic static <E> Closure<E> doWhileClosure(final Closure<? super E> closure, final Predicate<? super E> predicate) {\n    return WhileClosure.<E>whileClosure(predicate, closure, true);\n}"
            ],
            [
                "invokerClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Creates a Closure that will invoke a specific method on the closure's\n * input object by reflection.\n *\n * @see org.apache.commons.collections4.functors.InvokerTransformer\n * @see org.apache.commons.collections4.functors.TransformerClosure\n *\n * @param <E>  the type that the closure acts on\n * @param methodName  the name of the method\n * @return the <code>invoker</code> closure\n * @throws NullPointerException if the method name is null\n */\npublic static <E> Closure<E> invokerClosure(final String methodName) {\n    // reuse transformer as it has caching - this is lazy really, should have inner class here\n    return asClosure(InvokerTransformer.<E, Object>invokerTransformer(methodName));\n}"
            ],
            [
                "invokerClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Creates a Closure that will invoke a specific method on the closure's\n * input object by reflection.\n *\n * @see org.apache.commons.collections4.functors.InvokerTransformer\n * @see org.apache.commons.collections4.functors.TransformerClosure\n *\n * @param <E>  the type that the closure acts on\n * @param methodName  the name of the method\n * @param paramTypes  the parameter types\n * @param args  the arguments\n * @return the <code>invoker</code> closure\n * @throws NullPointerException if the method name is null\n * @throws IllegalArgumentException if the paramTypes and args don't match\n */\npublic static <E> Closure<E> invokerClosure(final String methodName, final Class<?>[] paramTypes, final Object[] args) {\n    // reuse transformer as it has caching - this is lazy really, should have inner class here\n    return asClosure(InvokerTransformer.<E, Object>invokerTransformer(methodName, paramTypes, args));\n}"
            ],
            [
                "chainedClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Create a new Closure that calls each closure in turn, passing the\n * result into the next closure.\n *\n * @see org.apache.commons.collections4.functors.ChainedClosure\n *\n * @param <E>  the type that the closure acts on\n * @param closures  an array of closures to chain\n * @return the <code>chained</code> closure\n * @throws NullPointerException if the closures array is null\n * @throws NullPointerException if any closure in the array is null\n */\npublic static <E> Closure<E> chainedClosure(final Closure<? super E>... closures) {\n    return ChainedClosure.chainedClosure(closures);\n}"
            ],
            [
                "chainedClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Create a new Closure that calls each closure in turn, passing the\n * result into the next closure. The ordering is that of the iterator()\n * method on the collection.\n *\n * @see org.apache.commons.collections4.functors.ChainedClosure\n *\n * @param <E>  the type that the closure acts on\n * @param closures  a collection of closures to chain\n * @return the <code>chained</code> closure\n * @throws NullPointerException if the closures collection is null\n * @throws NullPointerException if any closure in the collection is null\n * @throws IllegalArgumentException if the closures collection is empty\n */\npublic static <E> Closure<E> chainedClosure(final Collection<? extends Closure<? super E>> closures) {\n    return ChainedClosure.chainedClosure(closures);\n}"
            ],
            [
                "ifClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Create a new Closure that calls another closure based on the\n * result of the specified predicate.\n *\n * @see org.apache.commons.collections4.functors.IfClosure\n *\n * @param <E>  the type that the closure acts on\n * @param predicate  the validating predicate\n * @param trueClosure  the closure called if the predicate is true\n * @return the <code>if</code> closure\n * @throws NullPointerException if the predicate or closure is null\n * @since 3.2\n */\npublic static <E> Closure<E> ifClosure(final Predicate<? super E> predicate, final Closure<? super E> trueClosure) {\n    return IfClosure.<E>ifClosure(predicate, trueClosure);\n}"
            ],
            [
                "ifClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Create a new Closure that calls one of two closures depending\n * on the specified predicate.\n *\n * @see org.apache.commons.collections4.functors.IfClosure\n *\n * @param <E>  the type that the closure acts on\n * @param predicate  the predicate to switch on\n * @param trueClosure  the closure called if the predicate is true\n * @param falseClosure  the closure called if the predicate is false\n * @return the <code>switch</code> closure\n * @throws NullPointerException if the predicate or either closure is null\n */\npublic static <E> Closure<E> ifClosure(final Predicate<? super E> predicate, final Closure<? super E> trueClosure, final Closure<? super E> falseClosure) {\n    return IfClosure.<E>ifClosure(predicate, trueClosure, falseClosure);\n}"
            ],
            [
                "switchClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Create a new Closure that calls one of the closures depending\n * on the predicates.\n * <p>\n * The closure at array location 0 is called if the predicate at array\n * location 0 returned true. Each predicate is evaluated\n * until one returns true.\n *\n * @see org.apache.commons.collections4.functors.SwitchClosure\n *\n * @param <E>  the type that the closure acts on\n * @param predicates  an array of predicates to check, not null\n * @param closures  an array of closures to call, not null\n * @return the <code>switch</code> closure\n * @throws NullPointerException if the either array is null\n * @throws NullPointerException if any element in the arrays is null\n * @throws IllegalArgumentException if the arrays have different sizes\n */\npublic static <E> Closure<E> switchClosure(final Predicate<? super E>[] predicates, final Closure<? super E>[] closures) {\n    return SwitchClosure.<E>switchClosure(predicates, closures, null);\n}"
            ],
            [
                "switchClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Create a new Closure that calls one of the closures depending\n * on the predicates.\n * <p>\n * The closure at array location 0 is called if the predicate at array\n * location 0 returned true. Each predicate is evaluated\n * until one returns true. If no predicates evaluate to true, the default\n * closure is called.\n *\n * @see org.apache.commons.collections4.functors.SwitchClosure\n *\n * @param <E>  the type that the closure acts on\n * @param predicates  an array of predicates to check, not null\n * @param closures  an array of closures to call, not null\n * @param defaultClosure  the default to call if no predicate matches\n * @return the <code>switch</code> closure\n * @throws NullPointerException if the either array is null\n * @throws NullPointerException if any element in the arrays is null\n * @throws IllegalArgumentException if the arrays are different sizes\n */\npublic static <E> Closure<E> switchClosure(final Predicate<? super E>[] predicates, final Closure<? super E>[] closures, final Closure<? super E> defaultClosure) {\n    return SwitchClosure.<E>switchClosure(predicates, closures, defaultClosure);\n}"
            ],
            [
                "switchClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Create a new Closure that calls one of the closures depending\n * on the predicates.\n * <p>\n * The Map consists of Predicate keys and Closure values. A closure\n * is called if its matching predicate returns true. Each predicate is evaluated\n * until one returns true. If no predicates evaluate to true, the default\n * closure is called. The default closure is set in the map with a\n * null key. The ordering is that of the iterator() method on the entryset\n * collection of the map.\n *\n * @see org.apache.commons.collections4.functors.SwitchClosure\n *\n * @param <E>  the type that the closure acts on\n * @param predicatesAndClosures  a map of predicates to closures\n * @return the <code>switch</code> closure\n * @throws NullPointerException if the map is null\n * @throws NullPointerException if any closure in the map is null\n * @throws IllegalArgumentException if the map is empty\n * @throws ClassCastException  if the map elements are of the wrong type\n */\npublic static <E> Closure<E> switchClosure(final Map<Predicate<E>, Closure<E>> predicatesAndClosures) {\n    return SwitchClosure.switchClosure(predicatesAndClosures);\n}"
            ],
            [
                "switchMapClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Create a new Closure that uses the input object as a key to find the\n * closure to call.\n * <p>\n * The Map consists of object keys and Closure values. A closure\n * is called if the input object equals the key. If there is no match, the\n * default closure is called. The default closure is set in the map\n * using a null key.\n *\n * @see org.apache.commons.collections4.functors.SwitchClosure\n *\n * @param <E>  the type that the closure acts on\n * @param objectsAndClosures  a map of objects to closures\n * @return the closure\n * @throws NullPointerException if the map is null\n * @throws NullPointerException if any closure in the map is null\n * @throws IllegalArgumentException if the map is empty\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Closure<E> switchMapClosure(final Map<? extends E, Closure<E>> objectsAndClosures) {\n    if (objectsAndClosures == null) {\n        throw new NullPointerException(\"The object and closure map must not be null\");\n    }\n    final Closure<? super E> def = objectsAndClosures.remove(null);\n    final int size = objectsAndClosures.size();\n    final Closure<? super E>[] trs = new Closure[size];\n    final Predicate<E>[] preds = new Predicate[size];\n    int i = 0;\n    for (final Map.Entry<? extends E, Closure<E>> entry : objectsAndClosures.entrySet()) {\n        preds[i] = EqualPredicate.<E>equalPredicate(entry.getKey());\n        trs[i] = entry.getValue();\n        i++;\n    }\n    return ClosureUtils.<E>switchClosure(preds, trs, def);\n}"
            ],
            [
                "unmodifiableTrie",
                "org.apache.commons.collections4.trie",
                "UnmodifiableTrie",
                "/**\n * Factory method to create a unmodifiable trie.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param trie  the trie to decorate, must not be null\n * @return a new unmodifiable trie\n * @throws NullPointerException if trie is null\n */\npublic static <K, V> Trie<K, V> unmodifiableTrie(final Trie<K, ? extends V> trie) {\n    if (trie instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final Trie<K, V> tmpTrie = (Trie<K, V>) trie;\n        return tmpTrie;\n    }\n    return new UnmodifiableTrie<K, V>(trie);\n}"
            ],
            [
                "isOutOfBoundsIndex",
                "org.apache.commons.collections4.trie",
                "KeyAnalyzer",
                "/**\n * Returns true if bitIndex is a {@link KeyAnalyzer#OUT_OF_BOUNDS_BIT_KEY}.\n */\nstatic boolean isOutOfBoundsIndex(final int bitIndex) {\n    return bitIndex == OUT_OF_BOUNDS_BIT_KEY;\n}"
            ],
            [
                "isEqualBitKey",
                "org.apache.commons.collections4.trie",
                "KeyAnalyzer",
                "/**\n * Returns true if bitIndex is a {@link KeyAnalyzer#EQUAL_BIT_KEY}.\n */\nstatic boolean isEqualBitKey(final int bitIndex) {\n    return bitIndex == EQUAL_BIT_KEY;\n}"
            ],
            [
                "isNullBitKey",
                "org.apache.commons.collections4.trie",
                "KeyAnalyzer",
                "/**\n * Returns true if bitIndex is a {@link KeyAnalyzer#NULL_BIT_KEY}.\n */\nstatic boolean isNullBitKey(final int bitIndex) {\n    return bitIndex == NULL_BIT_KEY;\n}"
            ],
            [
                "isValidBitIndex",
                "org.apache.commons.collections4.trie",
                "KeyAnalyzer",
                "/**\n * Returns true if the given bitIndex is valid.\n * Indices are considered valid if they're between 0 and {@link Integer#MAX_VALUE}\n */\nstatic boolean isValidBitIndex(final int bitIndex) {\n    return bitIndex >= 0;\n}"
            ],
            [
                "isValidUplink",
                "org.apache.commons.collections4.trie",
                "AbstractPatriciaTrie",
                "/**\n * Returns true if 'next' is a valid uplink coming from 'from'.\n */\nstatic boolean isValidUplink(final TrieEntry<?, ?> next, final TrieEntry<?, ?> from) {\n    return next != null && next.bitIndex <= from.bitIndex && !next.isEmpty();\n}"
            ],
            [
                "compare",
                "org.apache.commons.collections4.trie",
                "AbstractBitwiseTrie",
                "/**\n * Returns true if both values are either null or equal.\n */\nstatic boolean compare(final Object a, final Object b) {\n    return a == null ? b == null : a.equals(b);\n}"
            ],
            [
                "transformingSortedMap",
                "org.apache.commons.collections4.map",
                "TransformedSortedMap",
                "/**\n * Factory method to create a transforming sorted map.\n * <p>\n * If there are any elements already in the map being decorated, they are NOT transformed.\n * Contrast this with {@link #transformedSortedMap(SortedMap, Transformer, Transformer)}.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param keyTransformer  the predicate to validate the keys, null means no transformation\n * @param valueTransformer  the predicate to validate to values, null means no transformation\n * @return a new transformed sorted map\n * @throws NullPointerException if the map is null\n * @since 4.0\n */\npublic static <K, V> TransformedSortedMap<K, V> transformingSortedMap(final SortedMap<K, V> map, final Transformer<? super K, ? extends K> keyTransformer, final Transformer<? super V, ? extends V> valueTransformer) {\n    return new TransformedSortedMap<K, V>(map, keyTransformer, valueTransformer);\n}"
            ],
            [
                "transformedSortedMap",
                "org.apache.commons.collections4.map",
                "TransformedSortedMap",
                "/**\n * Factory method to create a transforming sorted map that will transform\n * existing contents of the specified map.\n * <p>\n * If there are any elements already in the map being decorated, they\n * will be transformed by this method.\n * Contrast this with {@link #transformingSortedMap(SortedMap, Transformer, Transformer)}.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param keyTransformer  the transformer to use for key conversion, null means no transformation\n * @param valueTransformer  the transformer to use for value conversion, null means no transformation\n * @return a new transformed sorted map\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> TransformedSortedMap<K, V> transformedSortedMap(final SortedMap<K, V> map, final Transformer<? super K, ? extends K> keyTransformer, final Transformer<? super V, ? extends V> valueTransformer) {\n    final TransformedSortedMap<K, V> decorated = new TransformedSortedMap<K, V>(map, keyTransformer, valueTransformer);\n    if (map.size() > 0) {\n        final Map<K, V> transformed = decorated.transformMap(map);\n        decorated.clear();\n        // avoids double transformation\n        decorated.decorated().putAll(transformed);\n    }\n    return decorated;\n}"
            ],
            [
                "predicatedMap",
                "org.apache.commons.collections4.map",
                "PredicatedMap",
                "/**\n * Factory method to create a predicated (validating) map.\n * <p>\n * If there are any elements already in the list being decorated, they\n * are validated.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param keyPredicate  the predicate to validate the keys, null means no check\n * @param valuePredicate  the predicate to validate to values, null means no check\n * @return a new predicated map\n * @throws NullPointerException if the map is null\n * @since 4.0\n */\npublic static <K, V> PredicatedMap<K, V> predicatedMap(final Map<K, V> map, final Predicate<? super K> keyPredicate, final Predicate<? super V> valuePredicate) {\n    return new PredicatedMap<K, V>(map, keyPredicate, valuePredicate);\n}"
            ],
            [
                "fixedSizeSortedMap",
                "org.apache.commons.collections4.map",
                "FixedSizeSortedMap",
                "/**\n * Factory method to create a fixed size sorted map.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @return a new fixed size sorted map\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> FixedSizeSortedMap<K, V> fixedSizeSortedMap(final SortedMap<K, V> map) {\n    return new FixedSizeSortedMap<K, V>(map);\n}"
            ],
            [
                "unmodifiableSortedMap",
                "org.apache.commons.collections4.map",
                "UnmodifiableSortedMap",
                "/**\n * Factory method to create an unmodifiable sorted map.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @return a new unmodifiable sorted map\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> SortedMap<K, V> unmodifiableSortedMap(final SortedMap<K, ? extends V> map) {\n    if (map instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final SortedMap<K, V> tmpMap = (SortedMap<K, V>) map;\n        return tmpMap;\n    }\n    return new UnmodifiableSortedMap<K, V>(map);\n}"
            ],
            [
                "predicatedSortedMap",
                "org.apache.commons.collections4.map",
                "PredicatedSortedMap",
                "/**\n * Factory method to create a predicated (validating) sorted map.\n * <p>\n * If there are any elements already in the list being decorated, they\n * are validated.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param keyPredicate  the predicate to validate the keys, null means no check\n * @param valuePredicate  the predicate to validate to values, null means no check\n * @return a new predicated sorted map\n * @throws NullPointerException if the map is null\n * @since 4.0\n */\npublic static <K, V> PredicatedSortedMap<K, V> predicatedSortedMap(final SortedMap<K, V> map, final Predicate<? super K> keyPredicate, final Predicate<? super V> valuePredicate) {\n    return new PredicatedSortedMap<K, V>(map, keyPredicate, valuePredicate);\n}"
            ],
            [
                "defaultedMap",
                "org.apache.commons.collections4.map",
                "DefaultedMap",
                "//-----------------------------------------------------------------------\n/**\n * Factory method to create a defaulting map.\n * <p>\n * The value specified is returned when a missing key is found.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param defaultValue  the default value to return when the key is not found\n * @return a new defaulting map\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> DefaultedMap<K, V> defaultedMap(final Map<K, V> map, final V defaultValue) {\n    return new DefaultedMap<K, V>(map, ConstantTransformer.constantTransformer(defaultValue));\n}"
            ],
            [
                "defaultedMap",
                "org.apache.commons.collections4.map",
                "DefaultedMap",
                "/**\n * Factory method to create a defaulting map.\n * <p>\n * The factory specified is called when a missing key is found.\n * The result will be returned as the result of the map get(key) method.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param factory  the factory to use to create entries, must not be null\n * @return a new defaulting map\n * @throws NullPointerException if map or factory is null\n * @since 4.0\n */\npublic static <K, V> DefaultedMap<K, V> defaultedMap(final Map<K, V> map, final Factory<? extends V> factory) {\n    if (factory == null) {\n        throw new IllegalArgumentException(\"Factory must not be null\");\n    }\n    return new DefaultedMap<K, V>(map, FactoryTransformer.factoryTransformer(factory));\n}"
            ],
            [
                "defaultedMap",
                "org.apache.commons.collections4.map",
                "DefaultedMap",
                "/**\n * Factory method to create a defaulting map.\n * <p>\n * The transformer specified is called when a missing key is found.\n * The key is passed to the transformer as the input, and the result\n * will be returned as the result of the map get(key) method.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param transformer  the transformer to use as a factory to create entries, must not be null\n * @return a new defaulting map\n * @throws NullPointerException if map or factory is null\n * @since 4.0\n */\npublic static <K, V> Map<K, V> defaultedMap(final Map<K, V> map, final Transformer<? super K, ? extends V> transformer) {\n    if (transformer == null) {\n        throw new IllegalArgumentException(\"Transformer must not be null\");\n    }\n    return new DefaultedMap<K, V>(map, transformer);\n}"
            ],
            [
                "fixedSizeMap",
                "org.apache.commons.collections4.map",
                "FixedSizeMap",
                "/**\n * Factory method to create a fixed size map.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @return a new fixed size map\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> FixedSizeMap<K, V> fixedSizeMap(final Map<K, V> map) {\n    return new FixedSizeMap<K, V>(map);\n}"
            ],
            [
                "lazySortedMap",
                "org.apache.commons.collections4.map",
                "LazySortedMap",
                "/**\n * Factory method to create a lazily instantiated sorted map.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param factory  the factory to use, must not be null\n * @return a new lazy sorted map\n * @throws NullPointerException if map or factory is null\n * @since 4.0\n */\npublic static <K, V> LazySortedMap<K, V> lazySortedMap(final SortedMap<K, V> map, final Factory<? extends V> factory) {\n    return new LazySortedMap<K, V>(map, factory);\n}"
            ],
            [
                "lazySortedMap",
                "org.apache.commons.collections4.map",
                "LazySortedMap",
                "/**\n * Factory method to create a lazily instantiated sorted map.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param factory  the factory to use, must not be null\n * @return a new lazy sorted map\n * @throws NullPointerException if map or factory is null\n * @since 4.0\n */\npublic static <K, V> LazySortedMap<K, V> lazySortedMap(final SortedMap<K, V> map, final Transformer<? super K, ? extends V> factory) {\n    return new LazySortedMap<K, V>(map, factory);\n}"
            ],
            [
                "unmodifiableOrderedMap",
                "org.apache.commons.collections4.map",
                "UnmodifiableOrderedMap",
                "/**\n * Factory method to create an unmodifiable sorted map.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @return a new ordered map\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> OrderedMap<K, V> unmodifiableOrderedMap(final OrderedMap<? extends K, ? extends V> map) {\n    if (map instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final OrderedMap<K, V> tmpMap = (OrderedMap<K, V>) map;\n        return tmpMap;\n    }\n    return new UnmodifiableOrderedMap<K, V>(map);\n}"
            ],
            [
                "unmodifiableMap",
                "org.apache.commons.collections4.map",
                "UnmodifiableMap",
                "/**\n * Factory method to create an unmodifiable map.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @return a new unmodifiable map\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> Map<K, V> unmodifiableMap(final Map<? extends K, ? extends V> map) {\n    if (map instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final Map<K, V> tmpMap = (Map<K, V>) map;\n        return tmpMap;\n    }\n    return new UnmodifiableMap<K, V>(map);\n}"
            ],
            [
                "listOrderedMap",
                "org.apache.commons.collections4.map",
                "ListOrderedMap",
                "/**\n * Factory method to create an ordered map.\n * <p>\n * An <code>ArrayList</code> is used to retain order.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @return a new list ordered map\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> ListOrderedMap<K, V> listOrderedMap(final Map<K, V> map) {\n    return new ListOrderedMap<K, V>(map);\n}"
            ],
            [
                "unmodifiableEntrySet",
                "org.apache.commons.collections4.map",
                "UnmodifiableEntrySet",
                "/**\n * Factory method to create an unmodifiable set of Map Entry objects.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param set  the set to decorate, must not be null\n * @return a new unmodifiable entry set\n * @throws NullPointerException if set is null\n * @since 4.0\n */\npublic static <K, V> Set<Map.Entry<K, V>> unmodifiableEntrySet(final Set<Map.Entry<K, V>> set) {\n    if (set instanceof Unmodifiable) {\n        return set;\n    }\n    return new UnmodifiableEntrySet<K, V>(set);\n}"
            ],
            [
                "resolve",
                "org.apache.commons.collections4.map",
                "AbstractReferenceMap",
                "/**\n * Resolve enum from int.\n * @param value  the int value\n * @return ReferenceType\n * @throws IllegalArgumentException if the specified value is invalid.\n */\npublic static ReferenceStrength resolve(final int value) {\n    switch(value) {\n        case 0:\n            return HARD;\n        case 1:\n            return SOFT;\n        case 2:\n            return WEAK;\n        default:\n            throw new IllegalArgumentException();\n    }\n}"
            ],
            [
                "resolve",
                "org.apache.commons.collections4.map",
                "ReferenceStrength",
                "/**\n * Resolve enum from int.\n * @param value  the int value\n * @return ReferenceType\n * @throws IllegalArgumentException if the specified value is invalid.\n */\npublic static ReferenceStrength resolve(final int value) {\n    switch(value) {\n        case 0:\n            return HARD;\n        case 1:\n            return SOFT;\n        case 2:\n            return WEAK;\n        default:\n            throw new IllegalArgumentException();\n    }\n}"
            ],
            [
                "multiKeyMap",
                "org.apache.commons.collections4.map",
                "MultiKeyMap",
                "//-----------------------------------------------------------------------\n/**\n * Decorates the specified map to add the MultiKeyMap API and fast query.\n * The map must not be null and must be empty.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, not null\n * @return a new multi key map\n * @throws NullPointerException if map is null\n * @throws IllegalArgumentException if the map is not empty\n * @since 4.0\n */\npublic static <K, V> MultiKeyMap<K, V> multiKeyMap(final AbstractHashedMap<MultiKey<? extends K>, V> map) {\n    if (map == null) {\n        throw new NullPointerException(\"Map must not be null\");\n    }\n    if (map.size() > 0) {\n        throw new IllegalArgumentException(\"Map must be empty\");\n    }\n    return new MultiKeyMap<K, V>(map);\n}"
            ],
            [
                "lazyMap",
                "org.apache.commons.collections4.map",
                "LazyMap",
                "/**\n * Factory method to create a lazily instantiated map.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param factory  the factory to use, must not be null\n * @return a new lazy map\n * @throws NullPointerException if map or factory is null\n * @since 4.0\n */\npublic static <K, V> LazyMap<K, V> lazyMap(final Map<K, V> map, final Factory<? extends V> factory) {\n    return new LazyMap<K, V>(map, factory);\n}"
            ],
            [
                "lazyMap",
                "org.apache.commons.collections4.map",
                "LazyMap",
                "/**\n * Factory method to create a lazily instantiated map.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param factory  the factory to use, must not be null\n * @return a new lazy map\n * @throws NullPointerException if map or factory is null\n * @since 4.0\n */\npublic static <V, K> LazyMap<K, V> lazyMap(final Map<K, V> map, final Transformer<? super K, ? extends V> factory) {\n    return new LazyMap<K, V>(map, factory);\n}"
            ],
            [
                "multiValueMap",
                "org.apache.commons.collections4.map",
                "MultiValueMap",
                "/**\n * Creates a map which wraps the given map and\n * maps keys to ArrayLists.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to wrap\n * @return a new multi-value map\n * @since 4.0\n */\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\npublic static <K, V> MultiValueMap<K, V> multiValueMap(final Map<K, ? super Collection<V>> map) {\n    return MultiValueMap.<K, V, ArrayList>multiValueMap((Map<K, ? super Collection>) map, ArrayList.class);\n}"
            ],
            [
                "multiValueMap",
                "org.apache.commons.collections4.map",
                "MultiValueMap",
                "/**\n * Creates a map which decorates the given <code>map</code> and\n * maps keys to collections of type <code>collectionClass</code>.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param <C>  the collection class type\n * @param map  the map to wrap\n * @param collectionClass  the type of the collection class\n * @return a new multi-value map\n * @since 4.0\n */\npublic static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(final Map<K, ? super C> map, final Class<C> collectionClass) {\n    return new MultiValueMap<K, V>(map, new ReflectionFactory<C>(collectionClass));\n}"
            ],
            [
                "multiValueMap",
                "org.apache.commons.collections4.map",
                "MultiValueMap",
                "/**\n * Creates a map which decorates the given <code>map</code> and\n * creates the value collections using the supplied <code>collectionFactory</code>.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param <C>  the collection class type\n * @param map  the map to decorate\n * @param collectionFactory  the collection factory (must return a Collection object).\n * @return a new multi-value map\n * @since 4.0\n */\npublic static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(final Map<K, ? super C> map, final Factory<C> collectionFactory) {\n    return new MultiValueMap<K, V>(map, collectionFactory);\n}"
            ],
            [
                "transformingMap",
                "org.apache.commons.collections4.map",
                "TransformedMap",
                "/**\n * Factory method to create a transforming map.\n * <p>\n * If there are any elements already in the map being decorated, they\n * are NOT transformed.\n * Contrast this with {@link #transformedMap(Map, Transformer, Transformer)}.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param keyTransformer  the transformer to use for key conversion, null means no transformation\n * @param valueTransformer  the transformer to use for value conversion, null means no transformation\n * @return a new transformed map\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> TransformedMap<K, V> transformingMap(final Map<K, V> map, final Transformer<? super K, ? extends K> keyTransformer, final Transformer<? super V, ? extends V> valueTransformer) {\n    return new TransformedMap<K, V>(map, keyTransformer, valueTransformer);\n}"
            ],
            [
                "transformedMap",
                "org.apache.commons.collections4.map",
                "TransformedMap",
                "/**\n * Factory method to create a transforming map that will transform\n * existing contents of the specified map.\n * <p>\n * If there are any elements already in the map being decorated, they\n * will be transformed by this method.\n * Contrast this with {@link #transformingMap(Map, Transformer, Transformer)}.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param keyTransformer  the transformer to use for key conversion, null means no transformation\n * @param valueTransformer  the transformer to use for value conversion, null means no transformation\n * @return a new transformed map\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> TransformedMap<K, V> transformedMap(final Map<K, V> map, final Transformer<? super K, ? extends K> keyTransformer, final Transformer<? super V, ? extends V> valueTransformer) {\n    final TransformedMap<K, V> decorated = new TransformedMap<K, V>(map, keyTransformer, valueTransformer);\n    if (map.size() > 0) {\n        final Map<K, V> transformed = decorated.transformMap(map);\n        decorated.clear();\n        // avoids double transformation\n        decorated.decorated().putAll(transformed);\n    }\n    return decorated;\n}"
            ],
            [
                "synchronizedMultiSet",
                "org.apache.commons.collections4",
                "MultiSetUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns a synchronized (thread-safe) multiset backed by the given multiset.\n * In order to guarantee serial access, it is critical that all access to the\n * backing multiset is accomplished through the returned multiset.\n * <p>\n * It is imperative that the user manually synchronize on the returned multiset\n * when iterating over it:\n *\n * <pre>\n * MultiSet multiset = MultiSetUtils.synchronizedMultiSet(new HashMultiSet());\n * ...\n * synchronized(multiset) {\n *     Iterator i = multiset.iterator(); // Must be in synchronized block\n *     while (i.hasNext())\n *         foo(i.next());\n *     }\n * }\n * </pre>\n *\n * Failure to follow this advice may result in non-deterministic behavior.\n *\n * @param <E> the element type\n * @param multiset the multiset to synchronize, must not be null\n * @return a synchronized multiset backed by that multiset\n * @throws NullPointerException if the MultiSet is null\n */\npublic static <E> MultiSet<E> synchronizedMultiSet(final MultiSet<E> multiset) {\n    return SynchronizedMultiSet.synchronizedMultiSet(multiset);\n}"
            ],
            [
                "unmodifiableMultiSet",
                "org.apache.commons.collections4",
                "MultiSetUtils",
                "/**\n * Returns an unmodifiable view of the given multiset. Any modification attempts\n * to the returned multiset will raise an {@link UnsupportedOperationException}.\n *\n * @param <E> the element type\n * @param multiset the multiset whose unmodifiable view is to be returned, must not be null\n * @return an unmodifiable view of that multiset\n * @throws NullPointerException if the MultiSet is null\n */\npublic static <E> MultiSet<E> unmodifiableMultiSet(final MultiSet<? extends E> multiset) {\n    return UnmodifiableMultiSet.unmodifiableMultiSet(multiset);\n}"
            ],
            [
                "predicatedMultiSet",
                "org.apache.commons.collections4",
                "MultiSetUtils",
                "/**\n * Returns a predicated (validating) multiset backed by the given multiset.\n * <p>\n * Only objects that pass the test in the given predicate can be added to\n * the multiset. Trying to add an invalid object results in an\n * IllegalArgumentException. It is important not to use the original multiset\n * after invoking this method, as it is a backdoor for adding invalid\n * objects.\n *\n * @param <E> the element type\n * @param multiset the multiset to predicate, must not be null\n * @param predicate the predicate for the multiset, must not be null\n * @return a predicated multiset backed by the given multiset\n * @throws NullPointerException if the MultiSet or Predicate is null\n */\npublic static <E> MultiSet<E> predicatedMultiSet(final MultiSet<E> multiset, final Predicate<? super E> predicate) {\n    return PredicatedMultiSet.predicatedMultiSet(multiset, predicate);\n}"
            ],
            [
                "emptyMultiSet",
                "org.apache.commons.collections4",
                "MultiSetUtils",
                "/**\n * Get an empty <code>MultiSet</code>.\n *\n * @param <E> the element type\n * @return an empty MultiSet\n */\n// OK, empty multiset is compatible with any type\n@SuppressWarnings(\"unchecked\")\npublic static <E> MultiSet<E> emptyMultiSet() {\n    return EMPTY_MULTISET;\n}"
            ],
            [
                "unmodifiableMultiValuedMap",
                "org.apache.commons.collections4.multimap",
                "UnmodifiableMultiValuedMap",
                "/**\n * Factory method to create an unmodifiable MultiValuedMap.\n * <p>\n * If the map passed in is already unmodifiable, it is returned.\n *\n * @param <K> the type of key elements\n * @param <V> the type of value elements\n * @param map  the map to decorate, may not be null\n * @return an unmodifiable MultiValuedMap\n * @throws NullPointerException if map is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <K, V> UnmodifiableMultiValuedMap<K, V> unmodifiableMultiValuedMap(MultiValuedMap<? extends K, ? extends V> map) {\n    if (map instanceof Unmodifiable) {\n        return (UnmodifiableMultiValuedMap<K, V>) map;\n    }\n    return new UnmodifiableMultiValuedMap<K, V>(map);\n}"
            ],
            [
                "transformingMap",
                "org.apache.commons.collections4.multimap",
                "TransformedMultiValuedMap",
                "/**\n * Factory method to create a transforming MultiValuedMap.\n * <p>\n * If there are any elements already in the map being decorated, they are\n * NOT transformed. Contrast this with\n * {@link #transformedMap(MultiValuedMap, Transformer, Transformer)}.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the MultiValuedMap to decorate, may not be null\n * @param keyTransformer  the transformer to use for key conversion, null means no conversion\n * @param valueTransformer  the transformer to use for value conversion, null means no conversion\n * @return a new transformed MultiValuedMap\n * @throws NullPointerException if map is null\n */\npublic static <K, V> TransformedMultiValuedMap<K, V> transformingMap(final MultiValuedMap<K, V> map, final Transformer<? super K, ? extends K> keyTransformer, final Transformer<? super V, ? extends V> valueTransformer) {\n    return new TransformedMultiValuedMap<K, V>(map, keyTransformer, valueTransformer);\n}"
            ],
            [
                "transformedMap",
                "org.apache.commons.collections4.multimap",
                "TransformedMultiValuedMap",
                "/**\n * Factory method to create a transforming MultiValuedMap that will\n * transform existing contents of the specified map.\n * <p>\n * If there are any elements already in the map being decorated, they will\n * be transformed by this method. Contrast this with\n * {@link #transformingMap(MultiValuedMap, Transformer, Transformer)}.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the MultiValuedMap to decorate, may not be null\n * @param keyTransformer  the transformer to use for key conversion, null means no conversion\n * @param valueTransformer  the transformer to use for value conversion, null means no conversion\n * @return a new transformed MultiValuedMap\n * @throws NullPointerException if map is null\n */\npublic static <K, V> TransformedMultiValuedMap<K, V> transformedMap(final MultiValuedMap<K, V> map, final Transformer<? super K, ? extends K> keyTransformer, final Transformer<? super V, ? extends V> valueTransformer) {\n    final TransformedMultiValuedMap<K, V> decorated = new TransformedMultiValuedMap<K, V>(map, keyTransformer, valueTransformer);\n    if (!map.isEmpty()) {\n        final MultiValuedMap<K, V> mapCopy = new ArrayListValuedHashMap<K, V>(map);\n        decorated.clear();\n        decorated.putAll(mapCopy);\n    }\n    return decorated;\n}"
            ],
            [
                "lazyList",
                "org.apache.commons.collections4.list",
                "LazyList",
                "/**\n * Factory method to create a lazily instantiating list.\n *\n * @param <E> the type of the elements in the list\n * @param list  the list to decorate, must not be null\n * @param factory  the factory to use for creation, must not be null\n * @return a new lazy list\n * @throws NullPointerException if list or factory is null\n * @since 4.0\n */\npublic static <E> LazyList<E> lazyList(final List<E> list, final Factory<? extends E> factory) {\n    return new LazyList<E>(list, factory);\n}"
            ],
            [
                "setUniqueList",
                "org.apache.commons.collections4.list",
                "SetUniqueList",
                "/**\n * Factory method to create a SetList using the supplied list to retain order.\n * <p>\n * If the list contains duplicates, these are removed (first indexed one\n * kept). A <code>HashSet</code> is used for the set behaviour.\n *\n * @param <E>  the element type\n * @param list  the list to decorate, must not be null\n * @return a new {@link SetUniqueList}\n * @throws NullPointerException if list is null\n * @since 4.0\n */\npublic static <E> SetUniqueList<E> setUniqueList(final List<E> list) {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) {\n        return new SetUniqueList<E>(list, new HashSet<E>());\n    }\n    final List<E> temp = new ArrayList<E>(list);\n    list.clear();\n    final SetUniqueList<E> sl = new SetUniqueList<E>(list, new HashSet<E>());\n    sl.addAll(temp);\n    return sl;\n}"
            ],
            [
                "unmodifiableList",
                "org.apache.commons.collections4.list",
                "UnmodifiableList",
                "/**\n * Factory method to create an unmodifiable list.\n *\n * @param <E> the type of the elements in the list\n * @param list  the list to decorate, must not be null\n * @return a new unmodifiable list\n * @throws NullPointerException if list is null\n * @since 4.0\n */\npublic static <E> List<E> unmodifiableList(final List<? extends E> list) {\n    if (list instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final List<E> tmpList = (List<E>) list;\n        return tmpList;\n    }\n    return new UnmodifiableList<E>(list);\n}"
            ],
            [
                "fixedSizeList",
                "org.apache.commons.collections4.list",
                "FixedSizeList",
                "/**\n * Factory method to create a fixed size list.\n *\n * @param <E> the type of the elements in the list\n * @param list  the list to decorate, must not be null\n * @return a new fixed size list\n * @throws NullPointerException if list is null\n * @since 4.0\n */\npublic static <E> FixedSizeList<E> fixedSizeList(final List<E> list) {\n    return new FixedSizeList<E>(list);\n}"
            ],
            [
                "transformingList",
                "org.apache.commons.collections4.list",
                "TransformedList",
                "/**\n * Factory method to create a transforming list.\n * <p>\n * If there are any elements already in the list being decorated, they\n * are NOT transformed.\n * Contrast this with {@link #transformedList(List, Transformer)}.\n *\n * @param <E> the type of the elements in the list\n * @param list  the list to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed list\n * @throws NullPointerException if list or transformer is null\n * @since 4.0\n */\npublic static <E> TransformedList<E> transformingList(final List<E> list, final Transformer<? super E, ? extends E> transformer) {\n    return new TransformedList<E>(list, transformer);\n}"
            ],
            [
                "transformedList",
                "org.apache.commons.collections4.list",
                "TransformedList",
                "/**\n * Factory method to create a transforming list that will transform\n * existing contents of the specified list.\n * <p>\n * If there are any elements already in the list being decorated, they\n * will be transformed by this method.\n * Contrast this with {@link #transformingList(List, Transformer)}.\n *\n * @param <E> the type of the elements in the list\n * @param list  the list to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed List\n * @throws NullPointerException if list or transformer is null\n * @since 4.0\n */\npublic static <E> TransformedList<E> transformedList(final List<E> list, final Transformer<? super E, ? extends E> transformer) {\n    final TransformedList<E> decorated = new TransformedList<E>(list, transformer);\n    if (list.size() > 0) {\n        // list is of type E\n        @SuppressWarnings(\"unchecked\")\n        final E[] // NOPMD - false positive for generics\n        values = (E[]) list.toArray();\n        list.clear();\n        for (final E value : values) {\n            decorated.decorated().add(transformer.transform(value));\n        }\n    }\n    return decorated;\n}"
            ],
            [
                "growthList",
                "org.apache.commons.collections4.list",
                "GrowthList",
                "/**\n * Factory method to create a growth list.\n *\n * @param <E> the type of the elements in the list\n * @param list  the list to decorate, must not be null\n * @return a new growth list\n * @throws NullPointerException if list is null\n * @since 4.0\n */\npublic static <E> GrowthList<E> growthList(final List<E> list) {\n    return new GrowthList<E>(list);\n}"
            ],
            [
                "predicatedList",
                "org.apache.commons.collections4.list",
                "PredicatedList",
                "/**\n * Factory method to create a predicated (validating) list.\n * <p>\n * If there are any elements already in the list being decorated, they\n * are validated.\n *\n * @param <T> the type of the elements in the list\n * @param list  the list to decorate, must not be null\n * @param predicate  the predicate to use for validation, must not be null\n * @return a new predicated list\n * @throws NullPointerException if list or predicate is null\n * @throws IllegalArgumentException if the list contains invalid elements\n * @since 4.0\n */\npublic static <T> PredicatedList<T> predicatedList(final List<T> list, final Predicate<? super T> predicate) {\n    return new PredicatedList<T>(list, predicate);\n}"
            ],
            [
                "transformingQueue",
                "org.apache.commons.collections4.queue",
                "TransformedQueue",
                "/**\n * Factory method to create a transforming queue.\n * <p>\n * If there are any elements already in the queue being decorated, they\n * are NOT transformed.\n * Contrast this with {@link #transformedQueue(Queue, Transformer)}.\n *\n * @param <E> the type of the elements in the queue\n * @param queue  the queue to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed Queue\n * @throws NullPointerException if queue or transformer is null\n */\npublic static <E> TransformedQueue<E> transformingQueue(final Queue<E> queue, final Transformer<? super E, ? extends E> transformer) {\n    return new TransformedQueue<E>(queue, transformer);\n}"
            ],
            [
                "transformedQueue",
                "org.apache.commons.collections4.queue",
                "TransformedQueue",
                "/**\n * Factory method to create a transforming queue that will transform\n * existing contents of the specified queue.\n * <p>\n * If there are any elements already in the queue being decorated, they\n * will be transformed by this method.\n * Contrast this with {@link #transformingQueue(Queue, Transformer)}.\n *\n * @param <E> the type of the elements in the queue\n * @param queue  the queue to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed Queue\n * @throws NullPointerException if queue or transformer is null\n * @since 4.0\n */\npublic static <E> TransformedQueue<E> transformedQueue(final Queue<E> queue, final Transformer<? super E, ? extends E> transformer) {\n    // throws IAE if queue or transformer is null\n    final TransformedQueue<E> decorated = new TransformedQueue<E>(queue, transformer);\n    if (queue.size() > 0) {\n        // queue is type <E>\n        @SuppressWarnings(\"unchecked\")\n        final E[] // NOPMD - false positive for generics\n        values = (E[]) queue.toArray();\n        queue.clear();\n        for (final E value : values) {\n            decorated.decorated().add(transformer.transform(value));\n        }\n    }\n    return decorated;\n}"
            ],
            [
                "unmodifiableQueue",
                "org.apache.commons.collections4.queue",
                "UnmodifiableQueue",
                "/**\n * Factory method to create an unmodifiable queue.\n * <p>\n * If the queue passed in is already unmodifiable, it is returned.\n *\n * @param <E> the type of the elements in the queue\n * @param queue  the queue to decorate, must not be null\n * @return an unmodifiable Queue\n * @throws NullPointerException if queue is null\n */\npublic static <E> Queue<E> unmodifiableQueue(final Queue<? extends E> queue) {\n    if (queue instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final Queue<E> tmpQueue = (Queue<E>) queue;\n        return tmpQueue;\n    }\n    return new UnmodifiableQueue<E>(queue);\n}"
            ],
            [
                "predicatedQueue",
                "org.apache.commons.collections4.queue",
                "PredicatedQueue",
                "/**\n * Factory method to create a predicated (validating) queue.\n * <p>\n * If there are any elements already in the queue being decorated, they\n * are validated.\n *\n * @param <E> the type of the elements in the queue\n * @param Queue  the queue to decorate, must not be null\n * @param predicate  the predicate to use for validation, must not be null\n * @return a new predicated queue\n * @throws NullPointerException if queue or predicate is null\n * @throws IllegalArgumentException if the queue contains invalid elements\n */\npublic static <E> PredicatedQueue<E> predicatedQueue(final Queue<E> Queue, final Predicate<? super E> predicate) {\n    return new PredicatedQueue<E>(Queue, predicate);\n}"
            ],
            [
                "empty",
                "org.apache.commons.collections4",
                "FluentIterable",
                "// Static factory methods\n// ----------------------------------------------------------------------\n/**\n * Creates a new empty FluentIterable.\n *\n * @param <T>  the element type\n * @return a new empty FluentIterable\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> FluentIterable<T> empty() {\n    return IterableUtils.EMPTY_ITERABLE;\n}"
            ],
            [
                "of",
                "org.apache.commons.collections4",
                "FluentIterable",
                "/**\n * Creates a new FluentIterable of the single provided element.\n * <p>\n * The returned iterable's iterator does not support {@code remove()}.\n *\n * @param <T>  the element type\n * @param singleton  the singleton element\n * @return a new FluentIterable containing the singleton\n */\npublic static <T> FluentIterable<T> of(final T singleton) {\n    return of(IteratorUtils.asIterable(new SingletonIterator<T>(singleton, false)));\n}"
            ],
            [
                "of",
                "org.apache.commons.collections4",
                "FluentIterable",
                "/**\n * Creates a new FluentIterable from the provided elements.\n * <p>\n * The returned iterable's iterator does not support {@code remove()}.\n *\n * @param <T>  the element type\n * @param elements  the elements to be contained in the FluentIterable\n * @return a new FluentIterable containing the provided elements\n */\npublic static <T> FluentIterable<T> of(final T... elements) {\n    return of(Arrays.asList(elements));\n}"
            ],
            [
                "of",
                "org.apache.commons.collections4",
                "FluentIterable",
                "/**\n * Construct a new FluentIterable from the provided iterable. If the\n * iterable is already an instance of FluentIterable, the instance\n * will be returned instead.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the\n * corresponding input iterator supports it.\n *\n * @param <T>  the element type\n * @param iterable  the iterable to wrap into a FluentIterable, may not be null\n * @return a new FluentIterable wrapping the provided iterable\n * @throws NullPointerException if iterable is null\n */\npublic static <T> FluentIterable<T> of(final Iterable<T> iterable) {\n    IterableUtils.checkNotNull(iterable);\n    if (iterable instanceof FluentIterable<?>) {\n        return (FluentIterable<T>) iterable;\n    } else {\n        return new FluentIterable<T>(iterable);\n    }\n}"
            ],
            [
                "exceptionTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Gets a transformer that always throws an exception.\n * This could be useful during testing as a placeholder.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @return the transformer\n * @see ExceptionTransformer\n */\npublic static <I, O> Transformer<I, O> exceptionTransformer() {\n    return ExceptionTransformer.exceptionTransformer();\n}"
            ],
            [
                "nullTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Gets a transformer that always returns null.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @return the transformer\n * @see ConstantTransformer\n */\npublic static <I, O> Transformer<I, O> nullTransformer() {\n    return ConstantTransformer.nullTransformer();\n}"
            ],
            [
                "nopTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Gets a transformer that returns the input object.\n * The input object should be immutable to maintain the\n * contract of Transformer (although this is not checked).\n *\n * @param <T>  the input/output type\n * @return the transformer\n * @see NOPTransformer\n */\npublic static <T> Transformer<T, T> nopTransformer() {\n    return NOPTransformer.nopTransformer();\n}"
            ],
            [
                "cloneTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Gets a transformer that returns a clone of the input object.\n * The input object will be cloned using one of these techniques (in order):\n * <ul>\n * <li>public clone method\n * <li>public copy constructor\n * <li>serialization clone\n * <ul>\n *\n * @param <T>  the input/output type\n * @return the transformer\n * @see CloneTransformer\n */\npublic static <T> Transformer<T, T> cloneTransformer() {\n    return CloneTransformer.cloneTransformer();\n}"
            ],
            [
                "constantTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Creates a Transformer that will return the same object each time the\n * transformer is used.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param constantToReturn  the constant object to return each time in the transformer\n * @return the transformer.\n * @see ConstantTransformer\n */\npublic static <I, O> Transformer<I, O> constantTransformer(final O constantToReturn) {\n    return ConstantTransformer.constantTransformer(constantToReturn);\n}"
            ],
            [
                "asTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Creates a Transformer that calls a Closure each time the transformer is used.\n * The transformer returns the input object.\n *\n * @param <T>  the input/output type\n * @param closure  the closure to run each time in the transformer, not null\n * @return the transformer\n * @throws NullPointerException if the closure is null\n * @see ClosureTransformer\n */\npublic static <T> Transformer<T, T> asTransformer(final Closure<? super T> closure) {\n    return ClosureTransformer.closureTransformer(closure);\n}"
            ],
            [
                "asTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Creates a Transformer that calls a Predicate each time the transformer is used.\n * The transformer will return either Boolean.TRUE or Boolean.FALSE.\n *\n * @param <T>  the input type\n * @param predicate  the predicate to run each time in the transformer, not null\n * @return the transformer\n * @throws NullPointerException if the predicate is null\n * @see PredicateTransformer\n */\npublic static <T> Transformer<T, Boolean> asTransformer(final Predicate<? super T> predicate) {\n    return PredicateTransformer.predicateTransformer(predicate);\n}"
            ],
            [
                "asTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Creates a Transformer that calls a Factory each time the transformer is used.\n * The transformer will return the value returned by the factory.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param factory  the factory to run each time in the transformer, not null\n * @return the transformer\n * @throws NullPointerException if the factory is null\n * @see FactoryTransformer\n */\npublic static <I, O> Transformer<I, O> asTransformer(final Factory<? extends O> factory) {\n    return FactoryTransformer.factoryTransformer(factory);\n}"
            ],
            [
                "chainedTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Create a new Transformer that calls each transformer in turn, passing the\n * result into the next transformer.\n *\n * @param <T>  the input/output type\n * @param transformers  an array of transformers to chain\n * @return the transformer\n * @throws NullPointerException if the transformers array or any of the transformers is null\n * @see ChainedTransformer\n */\npublic static <T> Transformer<T, T> chainedTransformer(final Transformer<? super T, ? extends T>... transformers) {\n    return ChainedTransformer.chainedTransformer(transformers);\n}"
            ],
            [
                "chainedTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Create a new Transformer that calls each transformer in turn, passing the\n * result into the next transformer. The ordering is that of the iterator()\n * method on the collection.\n *\n * @param <T>  the input/output type\n * @param transformers  a collection of transformers to chain\n * @return the transformer\n * @throws NullPointerException if the transformers collection or any of the transformers is null\n * @see ChainedTransformer\n */\npublic static <T> Transformer<T, T> chainedTransformer(final Collection<? extends Transformer<? super T, ? extends T>> transformers) {\n    return ChainedTransformer.chainedTransformer(transformers);\n}"
            ],
            [
                "ifTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Create a new Transformer that calls the transformer if the predicate is true,\n * otherwise the input object is returned unchanged.\n *\n * @param <T>  the input / output type\n * @param predicate  the predicate to switch on\n * @param trueTransformer  the transformer called if the predicate is true\n * @return the transformer\n * @throws NullPointerException if either the predicate or transformer is null\n * @see IfTransformer\n * @since 4.1\n */\npublic static <T> Transformer<T, T> ifTransformer(final Predicate<? super T> predicate, final Transformer<? super T, ? extends T> trueTransformer) {\n    return IfTransformer.ifTransformer(predicate, trueTransformer);\n}"
            ],
            [
                "ifTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Create a new Transformer that calls one of two transformers depending\n * on the specified predicate.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param predicate  the predicate to switch on\n * @param trueTransformer  the transformer called if the predicate is true\n * @param falseTransformer  the transformer called if the predicate is false\n * @return the transformer\n * @throws NullPointerException if either the predicate or transformer is null\n * @see IfTransformer\n * @since 4.1\n */\npublic static <I, O> Transformer<I, O> ifTransformer(final Predicate<? super I> predicate, final Transformer<? super I, ? extends O> trueTransformer, final Transformer<? super I, ? extends O> falseTransformer) {\n    return IfTransformer.ifTransformer(predicate, trueTransformer, falseTransformer);\n}"
            ],
            [
                "switchTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Create a new Transformer that calls one of two transformers depending\n * on the specified predicate.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param predicate  the predicate to switch on\n * @param trueTransformer  the transformer called if the predicate is true\n * @param falseTransformer  the transformer called if the predicate is false\n * @return the transformer\n * @throws NullPointerException if either the predicate or transformer is null\n * @see SwitchTransformer\n * @deprecated as of 4.1, use {@link #ifTransformer(Predicate, Transformer, Transformer))\n */\n@SuppressWarnings(\"unchecked\")\n@Deprecated\npublic static <I, O> Transformer<I, O> switchTransformer(final Predicate<? super I> predicate, final Transformer<? super I, ? extends O> trueTransformer, final Transformer<? super I, ? extends O> falseTransformer) {\n    return SwitchTransformer.switchTransformer(new Predicate[] { predicate }, new Transformer[] { trueTransformer }, falseTransformer);\n}"
            ],
            [
                "switchTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Create a new Transformer that calls one of the transformers depending\n * on the predicates. The transformer at array location 0 is called if the\n * predicate at array location 0 returned true. Each predicate is evaluated\n * until one returns true. If no predicates evaluate to true, null is returned.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param predicates  an array of predicates to check\n * @param transformers  an array of transformers to call\n * @return the transformer\n * @throws NullPointerException if the either array is null\n * @throws NullPointerException if any element in the arrays is null\n * @throws IllegalArgumentException if the arrays have different sizes\n * @see SwitchTransformer\n */\npublic static <I, O> Transformer<I, O> switchTransformer(final Predicate<? super I>[] predicates, final Transformer<? super I, ? extends O>[] transformers) {\n    return SwitchTransformer.switchTransformer(predicates, transformers, null);\n}"
            ],
            [
                "switchTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Create a new Transformer that calls one of the transformers depending\n * on the predicates. The transformer at array location 0 is called if the\n * predicate at array location 0 returned true. Each predicate is evaluated\n * until one returns true. If no predicates evaluate to true, the default\n * transformer is called. If the default transformer is null, null is returned.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param predicates  an array of predicates to check\n * @param transformers  an array of transformers to call\n * @param defaultTransformer  the default to call if no predicate matches, null means return null\n * @return the transformer\n * @throws NullPointerException if the either array is null\n * @throws NullPointerException if any element in the arrays is null\n * @throws IllegalArgumentException if the arrays have different sizes\n * @see SwitchTransformer\n */\npublic static <I, O> Transformer<I, O> switchTransformer(final Predicate<? super I>[] predicates, final Transformer<? super I, ? extends O>[] transformers, final Transformer<? super I, ? extends O> defaultTransformer) {\n    return SwitchTransformer.switchTransformer(predicates, transformers, defaultTransformer);\n}"
            ],
            [
                "switchTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Create a new Transformer that calls one of the transformers depending\n * on the predicates.\n * <p>\n * The Map consists of Predicate keys and Transformer values. A transformer\n * is called if its matching predicate returns true. Each predicate is evaluated\n * until one returns true. If no predicates evaluate to true, the default\n * transformer is called. The default transformer is set in the map with a\n * null key. If no default transformer is set, null will be returned in a default\n * case. The ordering is that of the iterator() method on the entryset collection\n * of the map.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param predicatesAndTransformers  a map of predicates to transformers\n * @return the transformer\n * @throws NullPointerException if the map is null\n * @throws NullPointerException if any transformer in the map is null\n * @throws ClassCastException  if the map elements are of the wrong type\n * @see SwitchTransformer\n */\npublic static <I, O> Transformer<I, O> switchTransformer(final Map<Predicate<I>, Transformer<I, O>> predicatesAndTransformers) {\n    return SwitchTransformer.switchTransformer(predicatesAndTransformers);\n}"
            ],
            [
                "switchMapTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Create a new Transformer that uses the input object as a key to find the\n * transformer to call.\n * <p>\n * The Map consists of object keys and Transformer values. A transformer\n * is called if the input object equals the key. If there is no match, the\n * default transformer is called. The default transformer is set in the map\n * using a null key. If no default is set, null will be returned in a default case.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param objectsAndTransformers  a map of objects to transformers\n * @return the transformer\n * @throws NullPointerException if the map is null\n * @throws NullPointerException if any transformer in the map is null\n * @see SwitchTransformer\n */\n@SuppressWarnings(\"unchecked\")\npublic static <I, O> Transformer<I, O> switchMapTransformer(final Map<I, Transformer<I, O>> objectsAndTransformers) {\n    if (objectsAndTransformers == null) {\n        throw new NullPointerException(\"The object and transformer map must not be null\");\n    }\n    final Transformer<? super I, ? extends O> def = objectsAndTransformers.remove(null);\n    final int size = objectsAndTransformers.size();\n    final Transformer<? super I, ? extends O>[] trs = new Transformer[size];\n    final Predicate<I>[] preds = new Predicate[size];\n    int i = 0;\n    for (final Map.Entry<I, Transformer<I, O>> entry : objectsAndTransformers.entrySet()) {\n        preds[i] = EqualPredicate.<I>equalPredicate(entry.getKey());\n        trs[i++] = entry.getValue();\n    }\n    return TransformerUtils.switchTransformer(preds, trs, def);\n}"
            ],
            [
                "instantiateTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Gets a Transformer that expects an input Class object that it will instantiate.\n *\n * @param <T>  the output type\n * @return the transformer\n * @see InstantiateTransformer\n */\npublic static <T> Transformer<Class<? extends T>, T> instantiateTransformer() {\n    return InstantiateTransformer.instantiateTransformer();\n}"
            ],
            [
                "instantiateTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Creates a Transformer that expects an input Class object that it will\n * instantiate. The constructor used is determined by the arguments specified\n * to this method.\n *\n * @param <T>  the output type\n * @param paramTypes  parameter types for the constructor, can be null\n * @param args  the arguments to pass to the constructor, can be null\n * @return the transformer\n * @throws IllegalArgumentException if the paramTypes and args don't match\n * @see InstantiateTransformer\n */\npublic static <T> Transformer<Class<? extends T>, T> instantiateTransformer(final Class<?>[] paramTypes, final Object[] args) {\n    return InstantiateTransformer.instantiateTransformer(paramTypes, args);\n}"
            ],
            [
                "mapTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Creates a Transformer that uses the passed in Map to transform the input\n * object (as a simple lookup).\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param map  the map to use to transform the objects\n * @return the transformer, or {@link ConstantTransformer#nullTransformer()} if the\n *   {@code map} is {@code null}\n * @see MapTransformer\n */\npublic static <I, O> Transformer<I, O> mapTransformer(final Map<? super I, ? extends O> map) {\n    return MapTransformer.mapTransformer(map);\n}"
            ],
            [
                "invokerTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Gets a Transformer that invokes a method on the input object.\n * The method must have no parameters. If the input object is null,\n * null is returned.\n * <p>\n * For example, <code>TransformerUtils.invokerTransformer(\"getName\");</code>\n * will call the <code>getName/code> method on the input object to\n * determine the transformer result.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param methodName  the method name to call on the input object, may not be null\n * @return the transformer\n * @throws NullPointerException if the methodName is null.\n * @see InvokerTransformer\n */\npublic static <I, O> Transformer<I, O> invokerTransformer(final String methodName) {\n    return InvokerTransformer.invokerTransformer(methodName, null, null);\n}"
            ],
            [
                "invokerTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Gets a Transformer that invokes a method on the input object.\n * The method parameters are specified. If the input object is {@code null},\n * {@code null} is returned.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param methodName  the name of the method\n * @param paramTypes  the parameter types\n * @param args  the arguments\n * @return the transformer\n * @throws NullPointerException if the method name is null\n * @throws IllegalArgumentException if the paramTypes and args don't match\n * @see InvokerTransformer\n */\npublic static <I, O> Transformer<I, O> invokerTransformer(final String methodName, final Class<?>[] paramTypes, final Object[] args) {\n    return InvokerTransformer.invokerTransformer(methodName, paramTypes, args);\n}"
            ],
            [
                "stringValueTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Gets a transformer that returns a <code>java.lang.String</code>\n * representation of the input object. This is achieved via the\n * <code>toString</code> method, <code>null</code> returns 'null'.\n *\n * @param <T>  the input type\n * @return the transformer\n * @see StringValueTransformer\n */\npublic static <T> Transformer<T, String> stringValueTransformer() {\n    return StringValueTransformer.stringValueTransformer();\n}"
            ],
            [
                "exceptionPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "// Simple predicates\n//-----------------------------------------------------------------------------\n/**\n * Gets a Predicate that always throws an exception.\n * This could be useful during testing as a placeholder.\n *\n * @param <T>  the type that the predicate queries\n * @return the predicate\n * @see ExceptionPredicate\n */\npublic static <T> Predicate<T> exceptionPredicate() {\n    return ExceptionPredicate.exceptionPredicate();\n}"
            ],
            [
                "truePredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Gets a Predicate that always returns true.\n *\n * @param <T>  the type that the predicate queries\n * @return the predicate\n * @see TruePredicate\n */\npublic static <T> Predicate<T> truePredicate() {\n    return TruePredicate.truePredicate();\n}"
            ],
            [
                "falsePredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Gets a Predicate that always returns false.\n *\n * @param <T>  the type that the predicate queries\n * @return the predicate\n * @see FalsePredicate\n */\npublic static <T> Predicate<T> falsePredicate() {\n    return FalsePredicate.falsePredicate();\n}"
            ],
            [
                "nullPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Gets a Predicate that checks if the input object passed in is null.\n *\n * @param <T>  the type that the predicate queries\n * @return the predicate\n * @see NullPredicate\n */\npublic static <T> Predicate<T> nullPredicate() {\n    return NullPredicate.nullPredicate();\n}"
            ],
            [
                "notNullPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Gets a Predicate that checks if the input object passed in is not null.\n *\n * @param <T>  the type that the predicate queries\n * @return the predicate\n * @see NotNullPredicate\n */\npublic static <T> Predicate<T> notNullPredicate() {\n    return NotNullPredicate.notNullPredicate();\n}"
            ],
            [
                "equalPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Creates a Predicate that checks if the input object is equal to the\n * specified object using equals().\n *\n * @param <T>  the type that the predicate queries\n * @param value  the value to compare against\n * @return the predicate\n * @see EqualPredicate\n */\npublic static <T> Predicate<T> equalPredicate(final T value) {\n    return EqualPredicate.equalPredicate(value);\n}"
            ],
            [
                "identityPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Creates a Predicate that checks if the input object is equal to the\n * specified object by identity.\n *\n * @param <T>  the type that the predicate queries\n * @param value  the value to compare against\n * @return the predicate\n * @see IdentityPredicate\n */\npublic static <T> Predicate<T> identityPredicate(final T value) {\n    return IdentityPredicate.identityPredicate(value);\n}"
            ],
            [
                "instanceofPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Creates a Predicate that checks if the object passed in is of\n * a particular type, using instanceof. A <code>null</code> input\n * object will return <code>false</code>.\n *\n * @param type  the type to check for, may not be null\n * @return the predicate\n * @throws NullPointerException if the class is null\n * @see InstanceofPredicate\n */\npublic static Predicate<Object> instanceofPredicate(final Class<?> type) {\n    return InstanceofPredicate.instanceOfPredicate(type);\n}"
            ],
            [
                "uniquePredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Creates a Predicate that returns true the first time an object is\n * encountered, and false if the same object is received\n * again. The comparison is by equals(). A <code>null</code> input object\n * is accepted and will return true the first time, and false subsequently\n * as well.\n *\n * @param <T>  the type that the predicate queries\n * @return the predicate\n * @see UniquePredicate\n */\npublic static <T> Predicate<T> uniquePredicate() {\n    // must return new instance each time\n    return UniquePredicate.uniquePredicate();\n}"
            ],
            [
                "invokerPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Creates a Predicate that invokes a method on the input object.\n * The method must return either a boolean or a non-null Boolean,\n * and have no parameters. If the input object is null, a\n * PredicateException is thrown.\n * <p>\n * For example, <code>PredicateUtils.invokerPredicate(\"isEmpty\");</code>\n * will call the <code>isEmpty</code> method on the input object to\n * determine the predicate result.\n *\n * @param <T>  the type that the predicate queries\n * @param methodName  the method name to call on the input object, may not be null\n * @return the predicate\n * @throws NullPointerException if the methodName is null.\n * @see InvokerTransformer\n * @see TransformerPredicate\n */\npublic static <T> Predicate<T> invokerPredicate(final String methodName) {\n    // reuse transformer as it has caching - this is lazy really, should have inner class here\n    return asPredicate(InvokerTransformer.<Object, Boolean>invokerTransformer(methodName));\n}"
            ],
            [
                "invokerPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Creates a Predicate that invokes a method on the input object.\n * The method must return either a boolean or a non-null Boolean,\n * and have no parameters. If the input object is null, a\n * PredicateException is thrown.\n * <p>\n * For example, <code>PredicateUtils.invokerPredicate(\"isEmpty\");</code>\n * will call the <code>isEmpty</code> method on the input object to\n * determine the predicate result.\n *\n * @param <T>  the type that the predicate queries\n * @param methodName  the method name to call on the input object, may not be null\n * @param paramTypes  the parameter types\n * @param args  the arguments\n * @return the predicate\n * @throws NullPointerException if the method name is null\n * @throws IllegalArgumentException if the paramTypes and args don't match\n * @see InvokerTransformer\n * @see TransformerPredicate\n */\npublic static <T> Predicate<T> invokerPredicate(final String methodName, final Class<?>[] paramTypes, final Object[] args) {\n    // reuse transformer as it has caching - this is lazy really, should have inner class here\n    return asPredicate(InvokerTransformer.<Object, Boolean>invokerTransformer(methodName, paramTypes, args));\n}"
            ],
            [
                "andPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "// Boolean combinations\n//-----------------------------------------------------------------------------\n/**\n * Create a new Predicate that returns true only if both of the specified\n * predicates are true.\n *\n * @param <T>  the type that the predicate queries\n * @param predicate1  the first predicate, may not be null\n * @param predicate2  the second predicate, may not be null\n * @return the <code>and</code> predicate\n * @throws NullPointerException if either predicate is null\n * @see AndPredicate\n */\npublic static <T> Predicate<T> andPredicate(final Predicate<? super T> predicate1, final Predicate<? super T> predicate2) {\n    return AndPredicate.andPredicate(predicate1, predicate2);\n}"
            ],
            [
                "allPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true only if all of the specified\n * predicates are true.\n * If the array of predicates is empty, then this predicate returns true.\n *\n * @param <T>  the type that the predicate queries\n * @param predicates  an array of predicates to check, may not be null\n * @return the <code>all</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n * @see AllPredicate\n */\npublic static <T> Predicate<T> allPredicate(final Predicate<? super T>... predicates) {\n    return AllPredicate.allPredicate(predicates);\n}"
            ],
            [
                "allPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true only if all of the specified\n * predicates are true. The predicates are checked in iterator order.\n * If the collection of predicates is empty, then this predicate returns true.\n *\n * @param <T>  the type that the predicate queries\n * @param predicates  a collection of predicates to check, may not be null\n * @return the <code>all</code> predicate\n * @throws NullPointerException if the predicates collection is null\n * @throws NullPointerException if any predicate in the collection is null\n * @see AllPredicate\n */\npublic static <T> Predicate<T> allPredicate(final Collection<? extends Predicate<? super T>> predicates) {\n    return AllPredicate.allPredicate(predicates);\n}"
            ],
            [
                "orPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true if either of the specified\n * predicates are true.\n *\n * @param <T>  the type that the predicate queries\n * @param predicate1  the first predicate, may not be null\n * @param predicate2  the second predicate, may not be null\n * @return the <code>or</code> predicate\n * @throws NullPointerException if either predicate is null\n * @see OrPredicate\n */\npublic static <T> Predicate<T> orPredicate(final Predicate<? super T> predicate1, final Predicate<? super T> predicate2) {\n    return OrPredicate.orPredicate(predicate1, predicate2);\n}"
            ],
            [
                "anyPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true if any of the specified\n * predicates are true.\n * If the array of predicates is empty, then this predicate returns false.\n *\n * @param <T>  the type that the predicate queries\n * @param predicates  an array of predicates to check, may not be null\n * @return the <code>any</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n * @see AnyPredicate\n */\npublic static <T> Predicate<T> anyPredicate(final Predicate<? super T>... predicates) {\n    return AnyPredicate.anyPredicate(predicates);\n}"
            ],
            [
                "anyPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true if any of the specified\n * predicates are true. The predicates are checked in iterator order.\n * If the collection of predicates is empty, then this predicate returns false.\n *\n * @param <T>  the type that the predicate queries\n * @param predicates  a collection of predicates to check, may not be null\n * @return the <code>any</code> predicate\n * @throws NullPointerException if the predicates collection is null\n * @throws NullPointerException if any predicate in the collection is null\n * @see AnyPredicate\n */\npublic static <T> Predicate<T> anyPredicate(final Collection<? extends Predicate<? super T>> predicates) {\n    return AnyPredicate.anyPredicate(predicates);\n}"
            ],
            [
                "eitherPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true if one, but not both, of the\n * specified predicates are true. XOR\n *\n * @param <T>  the type that the predicate queries\n * @param predicate1  the first predicate, may not be null\n * @param predicate2  the second predicate, may not be null\n * @return the <code>either</code> predicate\n * @throws NullPointerException if either predicate is null\n * @see OnePredicate\n */\npublic static <T> Predicate<T> eitherPredicate(final Predicate<? super T> predicate1, final Predicate<? super T> predicate2) {\n    @SuppressWarnings(\"unchecked\")\n    final Predicate<T> onePredicate = PredicateUtils.onePredicate(predicate1, predicate2);\n    return onePredicate;\n}"
            ],
            [
                "onePredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true if only one of the specified\n * predicates are true.\n * If the array of predicates is empty, then this predicate returns false.\n *\n * @param <T>  the type that the predicate queries\n * @param predicates  an array of predicates to check, may not be null\n * @return the <code>one</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n * @see OnePredicate\n */\npublic static <T> Predicate<T> onePredicate(final Predicate<? super T>... predicates) {\n    return OnePredicate.onePredicate(predicates);\n}"
            ],
            [
                "onePredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true if only one of the specified\n * predicates are true. The predicates are checked in iterator order.\n * If the collection of predicates is empty, then this predicate returns false.\n *\n * @param <T>  the type that the predicate queries\n * @param predicates  a collection of predicates to check, may not be null\n * @return the <code>one</code> predicate\n * @throws NullPointerException if the predicates collection is null\n * @throws NullPointerException if any predicate in the collection is null\n * @see OnePredicate\n */\npublic static <T> Predicate<T> onePredicate(final Collection<? extends Predicate<? super T>> predicates) {\n    return OnePredicate.onePredicate(predicates);\n}"
            ],
            [
                "neitherPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true if neither of the specified\n * predicates are true.\n *\n * @param <T>  the type that the predicate queries\n * @param predicate1  the first predicate, may not be null\n * @param predicate2  the second predicate, may not be null\n * @return the <code>neither</code> predicate\n * @throws NullPointerException if either predicate is null\n * @see NonePredicate\n */\npublic static <T> Predicate<T> neitherPredicate(final Predicate<? super T> predicate1, final Predicate<? super T> predicate2) {\n    @SuppressWarnings(\"unchecked\")\n    final Predicate<T> nonePredicate = PredicateUtils.nonePredicate(predicate1, predicate2);\n    return nonePredicate;\n}"
            ],
            [
                "nonePredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true if none of the specified\n * predicates are true.\n * If the array of predicates is empty, then this predicate returns true.\n *\n * @param <T>  the type that the predicate queries\n * @param predicates  an array of predicates to check, may not be null\n * @return the <code>none</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n * @see NonePredicate\n */\npublic static <T> Predicate<T> nonePredicate(final Predicate<? super T>... predicates) {\n    return NonePredicate.nonePredicate(predicates);\n}"
            ],
            [
                "nonePredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true if none of the specified\n * predicates are true. The predicates are checked in iterator order.\n * If the collection of predicates is empty, then this predicate returns true.\n *\n * @param <T>  the type that the predicate queries\n * @param predicates  a collection of predicates to check, may not be null\n * @return the <code>none</code> predicate\n * @throws NullPointerException if the predicates collection is null\n * @throws NullPointerException if any predicate in the collection is null\n * @see NonePredicate\n */\npublic static <T> Predicate<T> nonePredicate(final Collection<? extends Predicate<? super T>> predicates) {\n    return NonePredicate.nonePredicate(predicates);\n}"
            ],
            [
                "notPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true if the specified predicate\n * returns false and vice versa.\n *\n * @param <T>  the type that the predicate queries\n * @param predicate  the predicate to not\n * @return the <code>not</code> predicate\n * @throws NullPointerException if the predicate is null\n * @see NotPredicate\n */\npublic static <T> Predicate<T> notPredicate(final Predicate<? super T> predicate) {\n    return NotPredicate.notPredicate(predicate);\n}"
            ],
            [
                "asPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "// Adaptors\n//-----------------------------------------------------------------------------\n/**\n * Create a new Predicate that wraps a Transformer. The Transformer must\n * return either Boolean.TRUE or Boolean.FALSE otherwise a PredicateException\n * will be thrown.\n *\n * @param <T>  the type that the predicate queries\n * @param transformer  the transformer to wrap, may not be null\n * @return the transformer wrapping predicate\n * @throws NullPointerException if the transformer is null\n * @see TransformerPredicate\n */\npublic static <T> Predicate<T> asPredicate(final Transformer<? super T, Boolean> transformer) {\n    return TransformerPredicate.transformerPredicate(transformer);\n}"
            ],
            [
                "nullIsExceptionPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "// Null handlers\n//-----------------------------------------------------------------------------\n/**\n * Gets a Predicate that throws an exception if the input object is null,\n * otherwise it calls the specified Predicate. This allows null handling\n * behaviour to be added to Predicates that don't support nulls.\n *\n * @param <T>  the type that the predicate queries\n * @param predicate  the predicate to wrap, may not be null\n * @return the predicate\n * @throws NullPointerException if the predicate is null.\n * @see NullIsExceptionPredicate\n */\npublic static <T> Predicate<T> nullIsExceptionPredicate(final Predicate<? super T> predicate) {\n    return NullIsExceptionPredicate.nullIsExceptionPredicate(predicate);\n}"
            ],
            [
                "nullIsFalsePredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Gets a Predicate that returns false if the input object is null, otherwise\n * it calls the specified Predicate. This allows null handling behaviour to\n * be added to Predicates that don't support nulls.\n *\n * @param <T>  the type that the predicate queries\n * @param predicate  the predicate to wrap, may not be null\n * @return the predicate\n * @throws NullPointerException if the predicate is null.\n * @see NullIsFalsePredicate\n */\npublic static <T> Predicate<T> nullIsFalsePredicate(final Predicate<? super T> predicate) {\n    return NullIsFalsePredicate.nullIsFalsePredicate(predicate);\n}"
            ],
            [
                "nullIsTruePredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Gets a Predicate that returns true if the input object is null, otherwise\n * it calls the specified Predicate. This allows null handling behaviour to\n * be added to Predicates that don't support nulls.\n *\n * @param <T>  the type that the predicate queries\n * @param predicate  the predicate to wrap, may not be null\n * @return the predicate\n * @throws NullPointerException if the predicate is null.\n * @see NullIsTruePredicate\n */\npublic static <T> Predicate<T> nullIsTruePredicate(final Predicate<? super T> predicate) {\n    return NullIsTruePredicate.nullIsTruePredicate(predicate);\n}"
            ],
            [
                "transformedPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "// Transformed\n//-----------------------------------------------------------------------\n/**\n * Creates a predicate that transforms the input object before passing it\n * to the predicate.\n *\n * @param <T>  the type that the predicate queries\n * @param transformer  the transformer to call first\n * @param predicate  the predicate to call with the result of the transform\n * @return the predicate\n * @throws NullPointerException if the transformer or the predicate is null\n * @see TransformedPredicate\n * @since 3.1\n */\npublic static <T> Predicate<T> transformedPredicate(final Transformer<? super T, ? extends T> transformer, final Predicate<? super T> predicate) {\n    return TransformedPredicate.transformedPredicate(transformer, predicate);\n}"
            ],
            [
                "emptySet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Get a typed empty unmodifiable Set.\n * @param <E> the element type\n * @return an empty Set\n */\npublic static <E> Set<E> emptySet() {\n    return Collections.<E>emptySet();\n}"
            ],
            [
                "emptySortedSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Get a typed empty unmodifiable sorted set.\n * @param <E> the element type\n * @return an empty sorted Set\n */\n// empty set is OK for any type\n@SuppressWarnings(\"unchecked\")\npublic static <E> SortedSet<E> emptySortedSet() {\n    return EMPTY_SORTED_SET;\n}"
            ],
            [
                "emptyIfNull",
                "org.apache.commons.collections4",
                "SetUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns an immutable empty set if the argument is <code>null</code>,\n * or the argument itself otherwise.\n *\n * @param <T> the element type\n * @param set the set, possibly <code>null</code>\n * @return an empty set if the argument is <code>null</code>\n */\npublic static <T> Set<T> emptyIfNull(final Set<T> set) {\n    return set == null ? Collections.<T>emptySet() : set;\n}"
            ],
            [
                "isEqualSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Tests two sets for equality as per the <code>equals()</code> contract\n * in {@link java.util.Set#equals(java.lang.Object)}.\n * <p>\n * This method is useful for implementing <code>Set</code> when you cannot\n * extend AbstractSet. The method takes Collection instances to enable other\n * collection types to use the Set implementation algorithm.\n * <p>\n * The relevant text (slightly paraphrased as this is a static method) is:\n * <blockquote>\n * <p>Two sets are considered equal if they have\n * the same size, and every member of the first set is contained in\n * the second. This ensures that the {@code equals} method works\n * properly across different implementations of the {@code Set}\n * interface.</p>\n *\n * <p>\n * This implementation first checks if the two sets are the same object:\n * if so it returns {@code true}.  Then, it checks if the two sets are\n * identical in size; if not, it returns false. If so, it returns\n * {@code a.containsAll((Collection) b)}.</p>\n * </blockquote>\n *\n * @see java.util.Set\n * @param set1  the first set, may be null\n * @param set2  the second set, may be null\n * @return whether the sets are equal by value comparison\n */\npublic static boolean isEqualSet(final Collection<?> set1, final Collection<?> set2) {\n    if (set1 == set2) {\n        return true;\n    }\n    if (set1 == null || set2 == null || set1.size() != set2.size()) {\n        return false;\n    }\n    return set1.containsAll(set2);\n}"
            ],
            [
                "hashCodeForSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Generates a hash code using the algorithm specified in\n * {@link java.util.Set#hashCode()}.\n * <p>\n * This method is useful for implementing <code>Set</code> when you cannot\n * extend AbstractSet. The method takes Collection instances to enable other\n * collection types to use the Set implementation algorithm.\n *\n * @param <T> the element type\n * @see java.util.Set#hashCode()\n * @param set  the set to calculate the hash code for, may be null\n * @return the hash code\n */\npublic static <T> int hashCodeForSet(final Collection<T> set) {\n    if (set == null) {\n        return 0;\n    }\n    int hashCode = 0;\n    for (final T obj : set) {\n        if (obj != null) {\n            hashCode += obj.hashCode();\n        }\n    }\n    return hashCode;\n}"
            ],
            [
                "newIdentityHashSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a new hash set that matches elements based on <code>==</code> not\n * <code>equals()</code>.\n * <p>\n * <strong>This set will violate the detail of various Set contracts.</note>\n * As a general rule, don't compare this set to other sets. In particular, you can't\n * use decorators like {@link ListOrderedSet} on it, which silently assume that these\n * contracts are fulfilled.</strong>\n * <p>\n * <strong>Note that the returned set is not synchronized and is not thread-safe.</strong>\n * If you wish to use this set from multiple threads concurrently, you must use\n * appropriate synchronization. The simplest approach is to wrap this map\n * using {@link java.util.Collections#synchronizedSet(Set)}. This class may throw\n * exceptions when accessed by concurrent threads without synchronization.\n *\n * @param <E>  the element type\n * @return a new identity hash set\n * @since 4.1\n */\npublic static <E> Set<E> newIdentityHashSet() {\n    return Collections.newSetFromMap(new IdentityHashMap<E, Boolean>());\n}"
            ],
            [
                "synchronizedSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "// Set\n//-----------------------------------------------------------------------\n/**\n * Returns a synchronized set backed by the given set.\n * <p>\n * You must manually synchronize on the returned set's iterator to\n * avoid non-deterministic behavior:\n *\n * <pre>\n * Set s = SetUtils.synchronizedSet(mySet);\n * synchronized (s) {\n *     Iterator i = s.iterator();\n *     while (i.hasNext()) {\n *         process (i.next());\n *     }\n * }\n * </pre>\n *\n * This method is just a wrapper for {@link Collections#synchronizedSet(Set)}.\n *\n * @param <E> the element type\n * @param set  the set to synchronize, must not be null\n * @return a synchronized set backed by the given set\n * @throws NullPointerException if the set is null\n */\npublic static <E> Set<E> synchronizedSet(final Set<E> set) {\n    return Collections.synchronizedSet(set);\n}"
            ],
            [
                "unmodifiableSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns an unmodifiable set backed by the given set.\n * <p>\n * This method uses the implementation in the decorators subpackage.\n *\n * @param <E> the element type\n * @param set  the set to make unmodifiable, must not be null\n * @return an unmodifiable set backed by the given set\n * @throws NullPointerException if the set is null\n */\npublic static <E> Set<E> unmodifiableSet(final Set<? extends E> set) {\n    return UnmodifiableSet.unmodifiableSet(set);\n}"
            ],
            [
                "predicatedSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a predicated (validating) set backed by the given set.\n * <p>\n * Only objects that pass the test in the given predicate can be added to the set.\n * Trying to add an invalid object results in an IllegalArgumentException.\n * It is important not to use the original set after invoking this method,\n * as it is a backdoor for adding invalid objects.\n *\n * @param <E> the element type\n * @param set  the set to predicate, must not be null\n * @param predicate  the predicate for the set, must not be null\n * @return a predicated set backed by the given set\n * @throws NullPointerException if the set or predicate is null\n */\npublic static <E> Set<E> predicatedSet(final Set<E> set, final Predicate<? super E> predicate) {\n    return PredicatedSet.predicatedSet(set, predicate);\n}"
            ],
            [
                "transformedSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a transformed set backed by the given set.\n * <p>\n * Each object is passed through the transformer as it is added to the\n * Set. It is important not to use the original set after invoking this\n * method, as it is a backdoor for adding untransformed objects.\n * <p>\n * Existing entries in the specified set will not be transformed.\n * If you want that behaviour, see {@link TransformedSet#transformedSet}.\n *\n * @param <E> the element type\n * @param set  the set to transform, must not be null\n * @param transformer  the transformer for the set, must not be null\n * @return a transformed set backed by the given set\n * @throws NullPointerException if the set or transformer is null\n */\npublic static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer) {\n    return TransformedSet.transformingSet(set, transformer);\n}"
            ],
            [
                "orderedSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a set that maintains the order of elements that are added\n * backed by the given set.\n * <p>\n * If an element is added twice, the order is determined by the first add.\n * The order is observed through the iterator or toArray.\n *\n * @param <E> the element type\n * @param set  the set to order, must not be null\n * @return an ordered set backed by the given set\n * @throws NullPointerException if the set is null\n */\npublic static <E> Set<E> orderedSet(final Set<E> set) {\n    return ListOrderedSet.listOrderedSet(set);\n}"
            ],
            [
                "synchronizedSortedSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "// SortedSet\n//-----------------------------------------------------------------------\n/**\n * Returns a synchronized sorted set backed by the given sorted set.\n * <p>\n * You must manually synchronize on the returned set's iterator to\n * avoid non-deterministic behavior:\n *\n * <pre>\n * Set s = SetUtils.synchronizedSortedSet(mySet);\n * synchronized (s) {\n *     Iterator i = s.iterator();\n *     while (i.hasNext()) {\n *         process (i.next());\n *     }\n * }\n * </pre>\n *\n * This method is just a wrapper for {@link Collections#synchronizedSortedSet(SortedSet)}.\n *\n * @param <E> the element type\n * @param set  the sorted set to synchronize, must not be null\n * @return a synchronized set backed by the given set\n * @throws NullPointerException if the set is null\n */\npublic static <E> SortedSet<E> synchronizedSortedSet(final SortedSet<E> set) {\n    return Collections.synchronizedSortedSet(set);\n}"
            ],
            [
                "unmodifiableSortedSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns an unmodifiable sorted set backed by the given sorted set.\n * <p>\n * This method uses the implementation in the decorators subpackage.\n *\n * @param <E> the element type\n * @param set  the sorted set to make unmodifiable, must not be null\n * @return an unmodifiable set backed by the given set\n * @throws NullPointerException if the set is null\n */\npublic static <E> SortedSet<E> unmodifiableSortedSet(final SortedSet<E> set) {\n    return UnmodifiableSortedSet.unmodifiableSortedSet(set);\n}"
            ],
            [
                "predicatedSortedSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a predicated (validating) sorted set backed by the given sorted set.\n * <p>\n * Only objects that pass the test in the given predicate can be added to the set.\n * Trying to add an invalid object results in an IllegalArgumentException.\n * It is important not to use the original set after invoking this method,\n * as it is a backdoor for adding invalid objects.\n *\n * @param <E> the element type\n * @param set  the sorted set to predicate, must not be null\n * @param predicate  the predicate for the sorted set, must not be null\n * @return a predicated sorted set backed by the given sorted set\n * @throws NullPointerException if the set or predicate is null\n */\npublic static <E> SortedSet<E> predicatedSortedSet(final SortedSet<E> set, final Predicate<? super E> predicate) {\n    return PredicatedSortedSet.predicatedSortedSet(set, predicate);\n}"
            ],
            [
                "transformedSortedSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a transformed sorted set backed by the given set.\n * <p>\n * Each object is passed through the transformer as it is added to the\n * Set. It is important not to use the original set after invoking this\n * method, as it is a backdoor for adding untransformed objects.\n * <p>\n * Existing entries in the specified set will not be transformed.\n * If you want that behaviour, see {@link TransformedSortedSet#transformedSortedSet}.\n *\n * @param <E> the element type\n * @param set  the set to transform, must not be null\n * @param transformer  the transformer for the set, must not be null\n * @return a transformed set backed by the given set\n * @throws NullPointerException if the set or transformer is null\n */\npublic static <E> SortedSet<E> transformedSortedSet(final SortedSet<E> set, final Transformer<? super E, ? extends E> transformer) {\n    return TransformedSortedSet.transformingSortedSet(set, transformer);\n}"
            ],
            [
                "unmodifiableNavigableSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "// NavigableSet\n//-----------------------------------------------------------------------\n/**\n * Returns an unmodifiable navigable set backed by the given navigable set.\n * <p>\n * This method uses the implementation in the decorators subpackage.\n *\n * @param <E> the element type\n * @param set  the navigable set to make unmodifiable, must not be null\n * @return an unmodifiable set backed by the given set\n * @throws NullPointerException if the set is null\n * @since 4.1\n */\npublic static <E> SortedSet<E> unmodifiableNavigableSet(final NavigableSet<E> set) {\n    return UnmodifiableNavigableSet.unmodifiableNavigableSet(set);\n}"
            ],
            [
                "predicatedNavigableSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a predicated (validating) navigable set backed by the given navigable set.\n * <p>\n * Only objects that pass the test in the given predicate can be added to the set.\n * Trying to add an invalid object results in an IllegalArgumentException.\n * It is important not to use the original set after invoking this method,\n * as it is a backdoor for adding invalid objects.\n *\n * @param <E> the element type\n * @param set  the navigable set to predicate, must not be null\n * @param predicate  the predicate for the navigable set, must not be null\n * @return a predicated navigable set backed by the given navigable set\n * @throws NullPointerException if the set or predicate is null\n * @since 4.1\n */\npublic static <E> SortedSet<E> predicatedNavigableSet(final NavigableSet<E> set, final Predicate<? super E> predicate) {\n    return PredicatedNavigableSet.predicatedNavigableSet(set, predicate);\n}"
            ],
            [
                "transformedNavigableSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a transformed navigable set backed by the given navigable set.\n * <p>\n * Each object is passed through the transformer as it is added to the\n * Set. It is important not to use the original set after invoking this\n * method, as it is a backdoor for adding untransformed objects.\n * <p>\n * Existing entries in the specified set will not be transformed.\n * If you want that behaviour, see {@link TransformedNavigableSet#transformedNavigableSet}.\n *\n * @param <E> the element type\n * @param set  the navigable set to transform, must not be null\n * @param transformer  the transformer for the set, must not be null\n * @return a transformed set backed by the given set\n * @throws NullPointerException if the set or transformer is null\n * @since 4.1\n */\npublic static <E> SortedSet<E> transformedNavigableSet(final NavigableSet<E> set, final Transformer<? super E, ? extends E> transformer) {\n    return TransformedNavigableSet.transformingNavigableSet(set, transformer);\n}"
            ],
            [
                "union",
                "org.apache.commons.collections4",
                "SetUtils",
                "// Set operations\n//-----------------------------------------------------------------------\n/**\n * Returns a unmodifiable <b>view</b> of the union of the given {@link Set}s.\n * <p>\n * The returned view contains all elements of {@code a} and {@code b}.\n *\n * @param <E> the generic type that is able to represent the types contained\n *   in both input sets.\n * @param a  the first set, must not be null\n * @param b  the second set, must not be null\n * @return a view of the union of the two set\n * @throws NullPointerException if either input set is null\n * @since 4.1\n */\npublic static <E> SetView<E> union(final Set<? extends E> a, final Set<? extends E> b) {\n    if (a == null || b == null) {\n        throw new NullPointerException(\"Sets must not be null.\");\n    }\n    final SetView<E> bMinusA = difference(b, a);\n    return new SetView<E>() {\n\n        @Override\n        public boolean contains(Object o) {\n            return a.contains(o) || b.contains(o);\n        }\n\n        @Override\n        public Iterator<E> createIterator() {\n            return IteratorUtils.chainedIterator(a.iterator(), bMinusA.iterator());\n        }\n\n        @Override\n        public boolean isEmpty() {\n            return a.isEmpty() && b.isEmpty();\n        }\n\n        @Override\n        public int size() {\n            return a.size() + bMinusA.size();\n        }\n    };\n}"
            ],
            [
                "difference",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a unmodifiable <b>view</b> containing the difference of the given\n * {@link Set}s, denoted by {@code a \\ b} (or {@code a - b}).\n * <p>\n * The returned view contains all elements of {@code a} that are not a member\n * of {@code b}.\n *\n * @param <E> the generic type that is able to represent the types contained\n *   in both input sets.\n * @param a  the set to subtract from, must not be null\n * @param b  the set to subtract, must not be null\n * @return a view of the relative complement of  of the two sets\n * @since 4.1\n */\npublic static <E> SetView<E> difference(final Set<? extends E> a, final Set<? extends E> b) {\n    if (a == null || b == null) {\n        throw new NullPointerException(\"Sets must not be null.\");\n    }\n    final Predicate<E> notContainedInB = new Predicate<E>() {\n\n        @Override\n        public boolean evaluate(E object) {\n            return !b.contains(object);\n        }\n    };\n    return new SetView<E>() {\n\n        @Override\n        public boolean contains(Object o) {\n            return a.contains(o) && !b.contains(o);\n        }\n\n        @Override\n        public Iterator<E> createIterator() {\n            return IteratorUtils.filteredIterator(a.iterator(), notContainedInB);\n        }\n    };\n}"
            ],
            [
                "intersection",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a unmodifiable <b>view</b> of the intersection of the given {@link Set}s.\n * <p>\n * The returned view contains all elements that are members of both input sets\n * ({@code a} and {@code b}).\n *\n * @param <E> the generic type that is able to represent the types contained\n *   in both input sets.\n * @param a  the first set, must not be null\n * @param b  the second set, must not be null\n * @return a view of the intersection of the two sets\n * @since 4.1\n */\npublic static <E> SetView<E> intersection(final Set<? extends E> a, final Set<? extends E> b) {\n    if (a == null || b == null) {\n        throw new NullPointerException(\"Sets must not be null.\");\n    }\n    final Predicate<E> containedInB = new Predicate<E>() {\n\n        @Override\n        public boolean evaluate(E object) {\n            return b.contains(object);\n        }\n    };\n    return new SetView<E>() {\n\n        @Override\n        public boolean contains(Object o) {\n            return a.contains(o) && b.contains(o);\n        }\n\n        @Override\n        public Iterator<E> createIterator() {\n            return IteratorUtils.filteredIterator(a.iterator(), containedInB);\n        }\n    };\n}"
            ],
            [
                "disjunction",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a unmodifiable <b>view</b> of the symmetric difference of the given\n * {@link Set}s.\n * <p>\n * The returned view contains all elements of {@code a} and {@code b} that are\n * not a member of the other set.\n * <p>\n * This is equivalent to {@code union(difference(a, b), difference(b, a))}.\n *\n * @param <E> the generic type that is able to represent the types contained\n *   in both input sets.\n * @param a  the first set, must not be null\n * @param b  the second set, must not be null\n * @return a view of the symmetric difference of the two sets\n * @since 4.1\n */\npublic static <E> SetView<E> disjunction(final Set<? extends E> a, final Set<? extends E> b) {\n    if (a == null || b == null) {\n        throw new NullPointerException(\"Sets must not be null.\");\n    }\n    final SetView<E> aMinusB = difference(a, b);\n    final SetView<E> bMinusA = difference(b, a);\n    return new SetView<E>() {\n\n        @Override\n        public boolean contains(Object o) {\n            return a.contains(o) ^ b.contains(o);\n        }\n\n        @Override\n        public Iterator<E> createIterator() {\n            return IteratorUtils.chainedIterator(aMinusB.iterator(), bMinusA.iterator());\n        }\n\n        @Override\n        public boolean isEmpty() {\n            return aMinusB.isEmpty() && bMinusA.isEmpty();\n        }\n\n        @Override\n        public int size() {\n            return aMinusB.size() + bMinusA.size();\n        }\n    };\n}"
            ],
            [
                "transformingSet",
                "org.apache.commons.collections4.set",
                "TransformedSet",
                "/**\n * Factory method to create a transforming set.\n * <p>\n * If there are any elements already in the set being decorated, they\n * are NOT transformed.\n * Contrast this with {@link #transformedSet(Set, Transformer)}.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed set\n * @throws NullPointerException if set or transformer is null\n * @since 4.0\n */\npublic static <E> TransformedSet<E> transformingSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer) {\n    return new TransformedSet<E>(set, transformer);\n}"
            ],
            [
                "transformedSet",
                "org.apache.commons.collections4.set",
                "TransformedSet",
                "/**\n * Factory method to create a transforming set that will transform\n * existing contents of the specified set.\n * <p>\n * If there are any elements already in the set being decorated, they\n * will be transformed by this method.\n * Contrast this with {@link #transformingSet(Set, Transformer)}.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed set\n * @throws NullPointerException if set or transformer is null\n * @since 4.0\n */\npublic static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer) {\n    final TransformedSet<E> decorated = new TransformedSet<E>(set, transformer);\n    if (set.size() > 0) {\n        // set is type E\n        @SuppressWarnings(\"unchecked\")\n        final E[] // NOPMD - false positive for generics\n        values = (E[]) set.toArray();\n        set.clear();\n        for (final E value : values) {\n            decorated.decorated().add(transformer.transform(value));\n        }\n    }\n    return decorated;\n}"
            ],
            [
                "transformingNavigableSet",
                "org.apache.commons.collections4.set",
                "TransformedNavigableSet",
                "/**\n * Factory method to create a transforming navigable set.\n * <p>\n * If there are any elements already in the set being decorated, they\n * are NOT transformed.\n * Contrast this with {@link #transformedNavigableSet(NavigableSet, Transformer)}.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed {@link NavigableSet}\n * @throws NullPointerException if set or transformer is null\n */\npublic static <E> TransformedNavigableSet<E> transformingNavigableSet(final NavigableSet<E> set, final Transformer<? super E, ? extends E> transformer) {\n    return new TransformedNavigableSet<E>(set, transformer);\n}"
            ],
            [
                "transformedNavigableSet",
                "org.apache.commons.collections4.set",
                "TransformedNavigableSet",
                "/**\n * Factory method to create a transforming navigable set that will transform\n * existing contents of the specified navigable set.\n * <p>\n * If there are any elements already in the set being decorated, they\n * will be transformed by this method.\n * Contrast this with {@link #transformingNavigableSet(NavigableSet, Transformer)}.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed {@link NavigableSet}\n * @throws NullPointerException if set or transformer is null\n */\npublic static <E> TransformedNavigableSet<E> transformedNavigableSet(final NavigableSet<E> set, final Transformer<? super E, ? extends E> transformer) {\n    final TransformedNavigableSet<E> decorated = new TransformedNavigableSet<E>(set, transformer);\n    if (set.size() > 0) {\n        // set is type E\n        @SuppressWarnings(\"unchecked\")\n        final E[] // NOPMD - false positive for generics\n        values = (E[]) set.toArray();\n        set.clear();\n        for (final E value : values) {\n            decorated.decorated().add(transformer.transform(value));\n        }\n    }\n    return decorated;\n}"
            ],
            [
                "predicatedNavigableSet",
                "org.apache.commons.collections4.set",
                "PredicatedNavigableSet",
                "/**\n * Factory method to create a predicated (validating) navigable set.\n * <p>\n * If there are any elements already in the set being decorated, they\n * are validated.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @param predicate  the predicate to use for validation, must not be null\n * @return a new predicated navigable set.\n * @throws NullPointerException if set or predicate is null\n * @throws IllegalArgumentException if the set contains invalid elements\n * @since 4.0\n */\npublic static <E> PredicatedNavigableSet<E> predicatedNavigableSet(final NavigableSet<E> set, final Predicate<? super E> predicate) {\n    return new PredicatedNavigableSet<E>(set, predicate);\n}"
            ],
            [
                "listOrderedSet",
                "org.apache.commons.collections4.set",
                "ListOrderedSet",
                "/**\n * Factory method to create an ordered set specifying the list and set to use.\n * <p>\n * The list and set must both be empty.\n *\n * @param <E> the element type\n * @param set the set to decorate, must be empty and not null\n * @param list the list to decorate, must be empty and not null\n * @return a new ordered set\n * @throws NullPointerException if set or list is null\n * @throws IllegalArgumentException if either the set or list is not empty\n * @since 4.0\n */\npublic static <E> ListOrderedSet<E> listOrderedSet(final Set<E> set, final List<E> list) {\n    if (set == null) {\n        throw new NullPointerException(\"Set must not be null\");\n    }\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (set.size() > 0 || list.size() > 0) {\n        throw new IllegalArgumentException(\"Set and List must be empty\");\n    }\n    return new ListOrderedSet<E>(set, list);\n}"
            ],
            [
                "listOrderedSet",
                "org.apache.commons.collections4.set",
                "ListOrderedSet",
                "/**\n * Factory method to create an ordered set.\n * <p>\n * An <code>ArrayList</code> is used to retain order.\n *\n * @param <E> the element type\n * @param set the set to decorate, must not be null\n * @return a new ordered set\n * @throws NullPointerException if set is null\n * @since 4.0\n */\npublic static <E> ListOrderedSet<E> listOrderedSet(final Set<E> set) {\n    return new ListOrderedSet<E>(set);\n}"
            ],
            [
                "listOrderedSet",
                "org.apache.commons.collections4.set",
                "ListOrderedSet",
                "/**\n * Factory method to create an ordered set using the supplied list to retain order.\n * <p>\n * A <code>HashSet</code> is used for the set behaviour.\n * <p>\n * NOTE: If the list contains duplicates, the duplicates are removed,\n * altering the specified list.\n *\n * @param <E> the element type\n * @param list the list to decorate, must not be null\n * @return a new ordered set\n * @throws NullPointerException if list is null\n * @since 4.0\n */\npublic static <E> ListOrderedSet<E> listOrderedSet(final List<E> list) {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n    return new ListOrderedSet<E>(set, list);\n}"
            ],
            [
                "unmodifiableSet",
                "org.apache.commons.collections4.set",
                "UnmodifiableSet",
                "/**\n * Factory method to create an unmodifiable set.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @return a new unmodifiable set\n * @throws NullPointerException if set is null\n * @since 4.0\n */\npublic static <E> Set<E> unmodifiableSet(final Set<? extends E> set) {\n    if (set instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final Set<E> tmpSet = (Set<E>) set;\n        return tmpSet;\n    }\n    return new UnmodifiableSet<E>(set);\n}"
            ],
            [
                "mapBackedSet",
                "org.apache.commons.collections4.set",
                "MapBackedSet",
                "/**\n * Factory method to create a set from a map.\n *\n * @param <E> the element type\n * @param <V> the dummy value type in the map\n * @param map  the map to decorate, must not be null\n * @return a new map backed set\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <E, V> MapBackedSet<E, V> mapBackedSet(final Map<E, ? super V> map) {\n    return mapBackedSet(map, null);\n}"
            ],
            [
                "mapBackedSet",
                "org.apache.commons.collections4.set",
                "MapBackedSet",
                "/**\n * Factory method to create a set from a map.\n *\n * @param <E> the element type\n * @param <V> the dummy value type in the map\n * @param map  the map to decorate, must not be null\n * @param dummyValue  the dummy value to use\n * @return a new map backed set\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <E, V> MapBackedSet<E, V> mapBackedSet(final Map<E, ? super V> map, final V dummyValue) {\n    return new MapBackedSet<E, V>(map, dummyValue);\n}"
            ],
            [
                "unmodifiableSortedSet",
                "org.apache.commons.collections4.set",
                "UnmodifiableSortedSet",
                "/**\n * Factory method to create an unmodifiable set.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @return a new unmodifiable {@link SortedSet}\n * @throws NullPointerException if set is null\n * @since 4.0\n */\npublic static <E> SortedSet<E> unmodifiableSortedSet(final SortedSet<E> set) {\n    if (set instanceof Unmodifiable) {\n        return set;\n    }\n    return new UnmodifiableSortedSet<E>(set);\n}"
            ],
            [
                "predicatedSortedSet",
                "org.apache.commons.collections4.set",
                "PredicatedSortedSet",
                "/**\n * Factory method to create a predicated (validating) sorted set.\n * <p>\n * If there are any elements already in the set being decorated, they\n * are validated.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @param predicate  the predicate to use for validation, must not be null\n * @return a new predicated sorted set.\n * @throws NullPointerException if set or predicate is null\n * @throws IllegalArgumentException if the set contains invalid elements\n * @since 4.0\n */\npublic static <E> PredicatedSortedSet<E> predicatedSortedSet(final SortedSet<E> set, final Predicate<? super E> predicate) {\n    return new PredicatedSortedSet<E>(set, predicate);\n}"
            ],
            [
                "predicatedSet",
                "org.apache.commons.collections4.set",
                "PredicatedSet",
                "/**\n * Factory method to create a predicated (validating) set.\n * <p>\n * If there are any elements already in the set being decorated, they\n * are validated.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @param predicate  the predicate to use for validation, must not be null\n * @return a decorated set\n * @throws NullPointerException if set or predicate is null\n * @throws IllegalArgumentException if the set contains invalid elements\n * @since 4.0\n */\npublic static <E> PredicatedSet<E> predicatedSet(final Set<E> set, final Predicate<? super E> predicate) {\n    return new PredicatedSet<E>(set, predicate);\n}"
            ],
            [
                "unmodifiableNavigableSet",
                "org.apache.commons.collections4.set",
                "UnmodifiableNavigableSet",
                "/**\n * Factory method to create an unmodifiable set.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @return a new unmodifiable {@link NavigableSet}\n * @throws NullPointerException if set is null\n */\npublic static <E> NavigableSet<E> unmodifiableNavigableSet(final NavigableSet<E> set) {\n    if (set instanceof Unmodifiable) {\n        return set;\n    }\n    return new UnmodifiableNavigableSet<E>(set);\n}"
            ],
            [
                "transformingSortedSet",
                "org.apache.commons.collections4.set",
                "TransformedSortedSet",
                "/**\n * Factory method to create a transforming sorted set.\n * <p>\n * If there are any elements already in the set being decorated, they\n * are NOT transformed.\n * Contrast this with {@link #transformedSortedSet(SortedSet, Transformer)}.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed {@link SortedSet}\n * @throws NullPointerException if set or transformer is null\n * @since 4.0\n */\npublic static <E> TransformedSortedSet<E> transformingSortedSet(final SortedSet<E> set, final Transformer<? super E, ? extends E> transformer) {\n    return new TransformedSortedSet<E>(set, transformer);\n}"
            ],
            [
                "transformedSortedSet",
                "org.apache.commons.collections4.set",
                "TransformedSortedSet",
                "/**\n * Factory method to create a transforming sorted set that will transform\n * existing contents of the specified sorted set.\n * <p>\n * If there are any elements already in the set being decorated, they\n * will be transformed by this method.\n * Contrast this with {@link #transformingSortedSet(SortedSet, Transformer)}.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed {@link SortedSet}\n * @throws NullPointerException if set or transformer is null\n * @since 4.0\n */\npublic static <E> TransformedSortedSet<E> transformedSortedSet(final SortedSet<E> set, final Transformer<? super E, ? extends E> transformer) {\n    final TransformedSortedSet<E> decorated = new TransformedSortedSet<E>(set, transformer);\n    if (set.size() > 0) {\n        // set is type E\n        @SuppressWarnings(\"unchecked\")\n        final E[] // NOPMD - false positive for generics\n        values = (E[]) set.toArray();\n        set.clear();\n        for (final E value : values) {\n            decorated.decorated().add(transformer.transform(value));\n        }\n    }\n    return decorated;\n}"
            ],
            [
                "get",
                "org.apache.commons.collections4",
                "EnumerationUtils",
                "/**\n * Returns the <code>index</code>-th value in the {@link Enumeration}, throwing\n * <code>IndexOutOfBoundsException</code> if there is no such element.\n * <p>\n * The Enumeration is advanced to <code>index</code> (or to the end, if\n * <code>index</code> exceeds the number of entries) as a side effect of this method.\n *\n * @param e  the enumeration to get a value from\n * @param index  the index to get\n * @param <T> the type of object in the {@link Enumeration}\n * @return the object at the specified index\n * @throws IndexOutOfBoundsException if the index is invalid\n * @throws IllegalArgumentException if the object type is invalid\n * @since 4.1\n */\npublic static <T> T get(final Enumeration<T> e, final int index) {\n    int i = index;\n    CollectionUtils.checkIndexBounds(i);\n    while (e.hasMoreElements()) {\n        i--;\n        if (i == -1) {\n            return e.nextElement();\n        } else {\n            e.nextElement();\n        }\n    }\n    throw new IndexOutOfBoundsException(\"Entry does not exist: \" + i);\n}"
            ],
            [
                "toList",
                "org.apache.commons.collections4",
                "EnumerationUtils",
                "/**\n * Creates a list based on an enumeration.\n *\n * <p>As the enumeration is traversed, an ArrayList of its values is\n * created. The new list is returned.</p>\n *\n * @param <E> the element type\n * @param enumeration  the enumeration to traverse, which should not be <code>null</code>.\n * @return a list containing all elements of the given enumeration\n * @throws NullPointerException if the enumeration parameter is <code>null</code>.\n */\npublic static <E> List<E> toList(final Enumeration<? extends E> enumeration) {\n    return IteratorUtils.toList(new EnumerationIterator<E>(enumeration));\n}"
            ],
            [
                "toList",
                "org.apache.commons.collections4",
                "EnumerationUtils",
                "/**\n * Override toList(Enumeration) for StringTokenizer as it implements Enumeration&lt;Object&gt;\n * for the sake of backward compatibility.\n *\n * @param stringTokenizer  the tokenizer to convert to a {@link List}&lt;{@link String}&gt;\n * @return a list containing all tokens of the given StringTokenizer\n */\npublic static List<String> toList(final StringTokenizer stringTokenizer) {\n    final List<String> result = new ArrayList<String>(stringTokenizer.countTokens());\n    while (stringTokenizer.hasMoreTokens()) {\n        result.add(stringTokenizer.nextToken());\n    }\n    return result;\n}"
            ],
            [
                "unmodifiableQueue",
                "org.apache.commons.collections4",
                "QueueUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns an unmodifiable queue backed by the given queue.\n *\n * @param <E> the type of the elements in the queue\n * @param queue  the queue to make unmodifiable, must not be null\n * @return an unmodifiable queue backed by that queue\n * @throws NullPointerException if the queue is null\n */\npublic static <E> Queue<E> unmodifiableQueue(final Queue<? extends E> queue) {\n    return UnmodifiableQueue.unmodifiableQueue(queue);\n}"
            ],
            [
                "predicatedQueue",
                "org.apache.commons.collections4",
                "QueueUtils",
                "/**\n * Returns a predicated (validating) queue backed by the given queue.\n * <p>\n * Only objects that pass the test in the given predicate can be added to the queue.\n * Trying to add an invalid object results in an IllegalArgumentException.\n * It is important not to use the original queue after invoking this method,\n * as it is a backdoor for adding invalid objects.\n *\n * @param <E> the type of the elements in the queue\n * @param queue  the queue to predicate, must not be null\n * @param predicate  the predicate used to evaluate new elements, must not be null\n * @return a predicated queue\n * @throws NullPointerException if the queue or predicate is null\n */\npublic static <E> Queue<E> predicatedQueue(final Queue<E> queue, final Predicate<? super E> predicate) {\n    return PredicatedQueue.predicatedQueue(queue, predicate);\n}"
            ],
            [
                "transformingQueue",
                "org.apache.commons.collections4",
                "QueueUtils",
                "/**\n * Returns a transformed queue backed by the given queue.\n * <p>\n * Each object is passed through the transformer as it is added to the\n * Queue. It is important not to use the original queue after invoking this\n * method, as it is a backdoor for adding untransformed objects.\n * <p>\n * Existing entries in the specified queue will not be transformed.\n * If you want that behaviour, see {@link TransformedQueue#transformedQueue}.\n *\n * @param <E> the type of the elements in the queue\n * @param queue  the queue to predicate, must not be null\n * @param transformer  the transformer for the queue, must not be null\n * @return a transformed queue backed by the given queue\n * @throws NullPointerException if the queue or transformer is null\n */\npublic static <E> Queue<E> transformingQueue(final Queue<E> queue, final Transformer<? super E, ? extends E> transformer) {\n    return TransformedQueue.transformingQueue(queue, transformer);\n}"
            ],
            [
                "emptyQueue",
                "org.apache.commons.collections4",
                "QueueUtils",
                "/**\n * Get an empty <code>Queue</code>.\n *\n * @param <E> the type of the elements in the queue\n * @return an empty {@link Queue}\n */\n// OK, empty queue is compatible with any type\n@SuppressWarnings(\"unchecked\")\npublic static <E> Queue<E> emptyQueue() {\n    return (Queue<E>) EMPTY_QUEUE;\n}"
            ],
            [
                "synchronizedBag",
                "org.apache.commons.collections4.bag",
                "SynchronizedBag",
                "/**\n * Factory method to create a synchronized bag.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @return a new synchronized Bag\n * @throws NullPointerException if bag is null\n * @since 4.0\n */\npublic static <E> SynchronizedBag<E> synchronizedBag(final Bag<E> bag) {\n    return new SynchronizedBag<E>(bag);\n}"
            ],
            [
                "collectionBag",
                "org.apache.commons.collections4.bag",
                "CollectionBag",
                "/**\n * Factory method to create a bag that complies to the Collection contract.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @return a Bag that complies to the Collection contract\n * @throws NullPointerException if bag is null\n */\npublic static <E> Bag<E> collectionBag(final Bag<E> bag) {\n    return new CollectionBag<E>(bag);\n}"
            ],
            [
                "unmodifiableBag",
                "org.apache.commons.collections4.bag",
                "UnmodifiableBag",
                "/**\n * Factory method to create an unmodifiable bag.\n * <p>\n * If the bag passed in is already unmodifiable, it is returned.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @return an unmodifiable Bag\n * @throws NullPointerException if bag is null\n * @since 4.0\n */\npublic static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n    if (bag instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final Bag<E> tmpBag = (Bag<E>) bag;\n        return tmpBag;\n    }\n    return new UnmodifiableBag<E>(bag);\n}"
            ],
            [
                "predicatedSortedBag",
                "org.apache.commons.collections4.bag",
                "PredicatedSortedBag",
                "/**\n * Factory method to create a predicated (validating) bag.\n * <p>\n * If there are any elements already in the bag being decorated, they\n * are validated.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @param predicate  the predicate to use for validation, must not be null\n * @return a new predicated SortedBag\n * @throws NullPointerException if bag or predicate is null\n * @throws IllegalArgumentException if the bag contains invalid elements\n * @since 4.0\n */\npublic static <E> PredicatedSortedBag<E> predicatedSortedBag(final SortedBag<E> bag, final Predicate<? super E> predicate) {\n    return new PredicatedSortedBag<E>(bag, predicate);\n}"
            ],
            [
                "unmodifiableSortedBag",
                "org.apache.commons.collections4.bag",
                "UnmodifiableSortedBag",
                "/**\n * Factory method to create an unmodifiable bag.\n * <p>\n * If the bag passed in is already unmodifiable, it is returned.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @return an unmodifiable SortedBag\n * @throws NullPointerException if bag is null\n * @since 4.0\n */\npublic static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n    if (bag instanceof Unmodifiable) {\n        return bag;\n    }\n    return new UnmodifiableSortedBag<E>(bag);\n}"
            ],
            [
                "transformingSortedBag",
                "org.apache.commons.collections4.bag",
                "TransformedSortedBag",
                "/**\n * Factory method to create a transforming sorted bag.\n * <p>\n * If there are any elements already in the bag being decorated, they\n * are NOT transformed. Contrast this with {@link #transformedSortedBag(SortedBag, Transformer)}.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed SortedBag\n * @throws NullPointerException if bag or transformer is null\n * @since 4.0\n */\npublic static <E> TransformedSortedBag<E> transformingSortedBag(final SortedBag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n    return new TransformedSortedBag<E>(bag, transformer);\n}"
            ],
            [
                "transformedSortedBag",
                "org.apache.commons.collections4.bag",
                "TransformedSortedBag",
                "/**\n * Factory method to create a transforming sorted bag that will transform\n * existing contents of the specified sorted bag.\n * <p>\n * If there are any elements already in the bag being decorated, they\n * will be transformed by this method.\n * Contrast this with {@link #transformingSortedBag(SortedBag, Transformer)}.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed SortedBag\n * @throws NullPointerException if bag or transformer is null\n * @since 4.0\n */\npublic static <E> TransformedSortedBag<E> transformedSortedBag(final SortedBag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n    final TransformedSortedBag<E> decorated = new TransformedSortedBag<E>(bag, transformer);\n    if (bag.size() > 0) {\n        // bag is type E\n        @SuppressWarnings(\"unchecked\")\n        final E[] // NOPMD - false positive for generics\n        values = (E[]) bag.toArray();\n        bag.clear();\n        for (final E value : values) {\n            decorated.decorated().add(transformer.transform(value));\n        }\n    }\n    return decorated;\n}"
            ],
            [
                "predicatedBag",
                "org.apache.commons.collections4.bag",
                "PredicatedBag",
                "/**\n * Factory method to create a predicated (validating) bag.\n * <p>\n * If there are any elements already in the bag being decorated, they\n * are validated.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @param predicate  the predicate to use for validation, must not be null\n * @return a new predicated Bag\n * @throws NullPointerException if bag or predicate is null\n * @throws IllegalArgumentException if the bag contains invalid elements\n * @since 4.0\n */\npublic static <E> PredicatedBag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n    return new PredicatedBag<E>(bag, predicate);\n}"
            ],
            [
                "synchronizedSortedBag",
                "org.apache.commons.collections4.bag",
                "SynchronizedSortedBag",
                "/**\n * Factory method to create a synchronized sorted bag.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @return a new synchronized SortedBag\n * @throws NullPointerException if bag is null\n * @since 4.0\n */\npublic static <E> SynchronizedSortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n    return new SynchronizedSortedBag<E>(bag);\n}"
            ],
            [
                "collectionSortedBag",
                "org.apache.commons.collections4.bag",
                "CollectionSortedBag",
                "/**\n * Factory method to create a sorted bag that complies to the Collection contract.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the sorted bag to decorate, must not be null\n * @return a SortedBag that complies to the Collection contract\n * @throws NullPointerException if bag is null\n */\npublic static <E> SortedBag<E> collectionSortedBag(final SortedBag<E> bag) {\n    return new CollectionSortedBag<E>(bag);\n}"
            ],
            [
                "transformingBag",
                "org.apache.commons.collections4.bag",
                "TransformedBag",
                "/**\n * Factory method to create a transforming bag.\n * <p>\n * If there are any elements already in the bag being decorated, they\n * are NOT transformed. Contrast this with {@link #transformedBag(Bag, Transformer)}.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed Bag\n * @throws NullPointerException if bag or transformer is null\n * @since 4.0\n */\npublic static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n    return new TransformedBag<E>(bag, transformer);\n}"
            ],
            [
                "transformedBag",
                "org.apache.commons.collections4.bag",
                "TransformedBag",
                "/**\n * Factory method to create a transforming bag that will transform\n * existing contents of the specified bag.\n * <p>\n * If there are any elements already in the bag being decorated, they\n * will be transformed by this method.\n * Contrast this with {@link #transformingBag(Bag, Transformer)}.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed Bag\n * @throws NullPointerException if bag or transformer is null\n * @since 4.0\n */\npublic static <E> Bag<E> transformedBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n    final TransformedBag<E> decorated = new TransformedBag<E>(bag, transformer);\n    if (bag.size() > 0) {\n        // Bag is of type E\n        @SuppressWarnings(\"unchecked\")\n        final E[] // NOPMD - false positive for generics\n        values = (E[]) bag.toArray();\n        bag.clear();\n        for (final E value : values) {\n            decorated.decorated().add(transformer.transform(value));\n        }\n    }\n    return decorated;\n}"
            ],
            [
                "predicatedMultiSet",
                "org.apache.commons.collections4.multiset",
                "PredicatedMultiSet",
                "/**\n * Factory method to create a predicated (validating) multiset.\n * <p>\n * If there are any elements already in the multiset being decorated, they\n * are validated.\n *\n * @param <E> the type of the elements in the multiset\n * @param multiset  the multiset to decorate, must not be null\n * @param predicate  the predicate to use for validation, must not be null\n * @return a new predicated MultiSet\n * @throws NullPointerException if multiset or predicate is null\n * @throws IllegalArgumentException if the multiset contains invalid elements\n */\npublic static <E> PredicatedMultiSet<E> predicatedMultiSet(final MultiSet<E> multiset, final Predicate<? super E> predicate) {\n    return new PredicatedMultiSet<E>(multiset, predicate);\n}"
            ],
            [
                "unmodifiableMultiSet",
                "org.apache.commons.collections4.multiset",
                "UnmodifiableMultiSet",
                "/**\n * Factory method to create an unmodifiable multiset.\n * <p>\n * If the multiset passed in is already unmodifiable, it is returned.\n *\n * @param <E>  the type of the elements in the multiset\n * @param multiset  the multiset to decorate, may not be null\n * @return an unmodifiable MultiSet\n * @throws NullPointerException if multiset is null\n */\npublic static <E> MultiSet<E> unmodifiableMultiSet(final MultiSet<? extends E> multiset) {\n    if (multiset instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final MultiSet<E> tmpMultiSet = (MultiSet<E>) multiset;\n        return tmpMultiSet;\n    }\n    return new UnmodifiableMultiSet<E>(multiset);\n}"
            ],
            [
                "synchronizedMultiSet",
                "org.apache.commons.collections4.multiset",
                "SynchronizedMultiSet",
                "/**\n * Factory method to create a synchronized multiset.\n *\n * @param <E> the type of the elements in the multiset\n * @param multiset  the multiset to decorate, must not be null\n * @return a new synchronized MultiSet\n * @throws NullPointerException if multiset is null\n */\npublic static <E> SynchronizedMultiSet<E> synchronizedMultiSet(final MultiSet<E> multiset) {\n    return new SynchronizedMultiSet<E>(multiset);\n}"
            ],
            [
                "synchronizedBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns a synchronized (thread-safe) bag backed by the given bag. In\n * order to guarantee serial access, it is critical that all access to the\n * backing bag is accomplished through the returned bag.\n * <p>\n * It is imperative that the user manually synchronize on the returned bag\n * when iterating over it:\n *\n * <pre>\n * Bag bag = BagUtils.synchronizedBag(new HashBag());\n * ...\n * synchronized(bag) {\n *     Iterator i = bag.iterator(); // Must be in synchronized block\n *     while (i.hasNext())\n *         foo(i.next());\n *     }\n * }\n * </pre>\n *\n * Failure to follow this advice may result in non-deterministic behavior.\n *\n * @param <E> the element type\n * @param bag the bag to synchronize, must not be null\n * @return a synchronized bag backed by that bag\n * @throws NullPointerException if the Bag is null\n */\npublic static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n    return SynchronizedBag.synchronizedBag(bag);\n}"
            ],
            [
                "unmodifiableBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * Returns an unmodifiable view of the given bag. Any modification attempts\n * to the returned bag will raise an {@link UnsupportedOperationException}.\n *\n * @param <E> the element type\n * @param bag the bag whose unmodifiable view is to be returned, must not be null\n * @return an unmodifiable view of that bag\n * @throws NullPointerException if the Bag is null\n */\npublic static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n    return UnmodifiableBag.unmodifiableBag(bag);\n}"
            ],
            [
                "predicatedBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * Returns a predicated (validating) bag backed by the given bag.\n * <p>\n * Only objects that pass the test in the given predicate can be added to\n * the bag. Trying to add an invalid object results in an\n * IllegalArgumentException. It is important not to use the original bag\n * after invoking this method, as it is a backdoor for adding invalid\n * objects.\n *\n * @param <E> the element type\n * @param bag the bag to predicate, must not be null\n * @param predicate the predicate for the bag, must not be null\n * @return a predicated bag backed by the given bag\n * @throws NullPointerException if the Bag or Predicate is null\n */\npublic static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n    return PredicatedBag.predicatedBag(bag, predicate);\n}"
            ],
            [
                "transformingBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * Returns a transformed bag backed by the given bag.\n * <p>\n * Each object is passed through the transformer as it is added to the Bag.\n * It is important not to use the original bag after invoking this method,\n * as it is a backdoor for adding untransformed objects.\n * <p>\n * Existing entries in the specified bag will not be transformed.\n * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n *\n * @param <E> the element type\n * @param bag the bag to predicate, must not be null\n * @param transformer the transformer for the bag, must not be null\n * @return a transformed bag backed by the given bag\n * @throws NullPointerException if the Bag or Transformer is null\n */\npublic static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n    return TransformedBag.transformingBag(bag, transformer);\n}"
            ],
            [
                "collectionBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * Returns a bag that complies to the Collection contract, backed by the given bag.\n *\n * @param <E> the element type\n * @param bag the bag to decorate, must not be null\n * @return a Bag that complies to the Collection contract\n * @throws NullPointerException if bag is null\n * @since 4.0\n */\npublic static <E> Bag<E> collectionBag(final Bag<E> bag) {\n    return CollectionBag.collectionBag(bag);\n}"
            ],
            [
                "synchronizedSortedBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns a synchronized (thread-safe) sorted bag backed by the given\n * sorted bag. In order to guarantee serial access, it is critical that all\n * access to the backing bag is accomplished through the returned bag.\n * <p>\n * It is imperative that the user manually synchronize on the returned bag\n * when iterating over it:\n *\n * <pre>\n * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n * ...\n * synchronized(bag) {\n *     Iterator i = bag.iterator(); // Must be in synchronized block\n *     while (i.hasNext())\n *         foo(i.next());\n *     }\n * }\n * </pre>\n *\n * Failure to follow this advice may result in non-deterministic behavior.\n *\n * @param <E> the element type\n * @param bag the bag to synchronize, must not be null\n * @return a synchronized bag backed by that bag\n * @throws NullPointerException if the SortedBag is null\n */\npublic static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n    return SynchronizedSortedBag.synchronizedSortedBag(bag);\n}"
            ],
            [
                "unmodifiableSortedBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * Returns an unmodifiable view of the given sorted bag. Any modification\n * attempts to the returned bag will raise an\n * {@link UnsupportedOperationException}.\n *\n * @param <E> the element type\n * @param bag the bag whose unmodifiable view is to be returned, must not be null\n * @return an unmodifiable view of that bag\n * @throws NullPointerException if the SortedBag is null\n */\npublic static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n    return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n}"
            ],
            [
                "predicatedSortedBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * Returns a predicated (validating) sorted bag backed by the given sorted\n * bag.\n * <p>\n * Only objects that pass the test in the given predicate can be added to\n * the bag. Trying to add an invalid object results in an\n * IllegalArgumentException. It is important not to use the original bag\n * after invoking this method, as it is a backdoor for adding invalid\n * objects.\n *\n * @param <E> the element type\n * @param bag the sorted bag to predicate, must not be null\n * @param predicate the predicate for the bag, must not be null\n * @return a predicated bag backed by the given bag\n * @throws NullPointerException if the SortedBag or Predicate is null\n */\npublic static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag, final Predicate<? super E> predicate) {\n    return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n}"
            ],
            [
                "transformingSortedBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * Returns a transformed sorted bag backed by the given bag.\n * <p>\n * Each object is passed through the transformer as it is added to the Bag.\n * It is important not to use the original bag after invoking this method,\n * as it is a backdoor for adding untransformed objects.\n * <p>\n * Existing entries in the specified bag will not be transformed.\n * If you want that behaviour, see\n * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n *\n * @param <E> the element type\n * @param bag the bag to predicate, must not be null\n * @param transformer the transformer for the bag, must not be null\n * @return a transformed bag backed by the given bag\n * @throws NullPointerException if the Bag or Transformer is null\n */\npublic static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n    return TransformedSortedBag.transformingSortedBag(bag, transformer);\n}"
            ],
            [
                "emptyBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * Get an empty <code>Bag</code>.\n *\n * @param <E> the element type\n * @return an empty Bag\n */\n// OK, empty bag is compatible with any type\n@SuppressWarnings(\"unchecked\")\npublic static <E> Bag<E> emptyBag() {\n    return (Bag<E>) EMPTY_BAG;\n}"
            ],
            [
                "emptySortedBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * Get an empty <code>SortedBag</code>.\n *\n * @param <E> the element type\n * @return an empty sorted Bag\n */\n// OK, empty bag is compatible with any type\n@SuppressWarnings(\"unchecked\")\npublic static <E> SortedBag<E> emptySortedBag() {\n    return (SortedBag<E>) EMPTY_SORTED_BAG;\n}"
            ],
            [
                "resettableEmptyListIterator",
                "org.apache.commons.collections4.iterators",
                "EmptyListIterator",
                "/**\n * Get a typed instance of the iterator.\n * @param <E> the element type\n * @return {@link ResettableListIterator}<E>\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> ResettableListIterator<E> resettableEmptyListIterator() {\n    return (ResettableListIterator<E>) RESETTABLE_INSTANCE;\n}"
            ],
            [
                "emptyListIterator",
                "org.apache.commons.collections4.iterators",
                "EmptyListIterator",
                "/**\n * Get a typed instance of the iterator.\n * @param <E> the element type\n * @return {@link ListIterator}<E>\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> ListIterator<E> emptyListIterator() {\n    return (ListIterator<E>) INSTANCE;\n}"
            ],
            [
                "unmodifiableOrderedMapIterator",
                "org.apache.commons.collections4.iterators",
                "UnmodifiableOrderedMapIterator",
                "//-----------------------------------------------------------------------\n/**\n * Decorates the specified iterator such that it cannot be modified.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param iterator  the iterator to decorate\n * @return a new unmodifiable ordered map iterator\n * @throws NullPointerException if the iterator is null\n */\npublic static <K, V> OrderedMapIterator<K, V> unmodifiableOrderedMapIterator(final OrderedMapIterator<K, ? extends V> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"OrderedMapIterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final OrderedMapIterator<K, V> tmpIterator = (OrderedMapIterator<K, V>) iterator;\n        return tmpIterator;\n    }\n    return new UnmodifiableOrderedMapIterator<K, V>(iterator);\n}"
            ],
            [
                "unmodifiableIterator",
                "org.apache.commons.collections4.iterators",
                "UnmodifiableIterator",
                "//-----------------------------------------------------------------------\n/**\n * Decorates the specified iterator such that it cannot be modified.\n * <p>\n * If the iterator is already unmodifiable it is returned directly.\n *\n * @param <E>  the element type\n * @param iterator  the iterator to decorate\n * @return a new unmodifiable iterator\n * @throws NullPointerException if the iterator is null\n */\npublic static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final Iterator<E> tmpIterator = (Iterator<E>) iterator;\n        return tmpIterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}"
            ],
            [
                "peekingIterator",
                "org.apache.commons.collections4.iterators",
                "PeekingIterator",
                "//-----------------------------------------------------------------------\n/**\n * Decorates the specified iterator to support one-element lookahead.\n * <p>\n * If the iterator is already a {@link PeekingIterator} it is returned directly.\n *\n * @param <E>  the element type\n * @param iterator  the iterator to decorate\n * @return a new peeking iterator\n * @throws NullPointerException if the iterator is null\n */\npublic static <E> PeekingIterator<E> peekingIterator(final Iterator<? extends E> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof PeekingIterator<?>) {\n        // safe cast\n        @SuppressWarnings(\"unchecked\")\n        final PeekingIterator<E> it = (PeekingIterator<E>) iterator;\n        return it;\n    }\n    return new PeekingIterator<E>(iterator);\n}"
            ],
            [
                "emptyMapIterator",
                "org.apache.commons.collections4.iterators",
                "EmptyMapIterator",
                "/**\n * Get a typed instance of the iterator.\n * @param <K> the key type\n * @param <V> the value type\n * @return {@link MapIterator}<K, V>\n */\n@SuppressWarnings(\"unchecked\")\npublic static <K, V> MapIterator<K, V> emptyMapIterator() {\n    return (MapIterator<K, V>) INSTANCE;\n}"
            ],
            [
                "emptyOrderedIterator",
                "org.apache.commons.collections4.iterators",
                "EmptyOrderedIterator",
                "/**\n * Typed instance of the iterator.\n * @param <E> the element type\n * @return OrderedIterator<E>\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> OrderedIterator<E> emptyOrderedIterator() {\n    return (OrderedIterator<E>) INSTANCE;\n}"
            ],
            [
                "umodifiableListIterator",
                "org.apache.commons.collections4.iterators",
                "UnmodifiableListIterator",
                "//-----------------------------------------------------------------------\n/**\n * Decorates the specified iterator such that it cannot be modified.\n *\n * @param <E>  the element type\n * @param iterator  the iterator to decorate\n * @return a new unmodifiable list iterator\n * @throws NullPointerException if the iterator is null\n */\npublic static <E> ListIterator<E> umodifiableListIterator(final ListIterator<? extends E> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"ListIterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final ListIterator<E> tmpIterator = (ListIterator<E>) iterator;\n        return tmpIterator;\n    }\n    return new UnmodifiableListIterator<E>(iterator);\n}"
            ],
            [
                "emptyOrderedMapIterator",
                "org.apache.commons.collections4.iterators",
                "EmptyOrderedMapIterator",
                "/**\n * Get a typed instance of the iterator.\n * @param <K> the key type\n * @param <V> the value type\n * @return {@link OrderedMapIterator}<K, V>\n */\n@SuppressWarnings(\"unchecked\")\npublic static <K, V> OrderedMapIterator<K, V> emptyOrderedMapIterator() {\n    return (OrderedMapIterator<K, V>) INSTANCE;\n}"
            ],
            [
                "unmodifiableMapIterator",
                "org.apache.commons.collections4.iterators",
                "UnmodifiableMapIterator",
                "//-----------------------------------------------------------------------\n/**\n * Decorates the specified iterator such that it cannot be modified.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param iterator  the iterator to decorate\n * @return a new unmodifiable map iterator\n * @throws NullPointerException if the iterator is null\n */\npublic static <K, V> MapIterator<K, V> unmodifiableMapIterator(final MapIterator<? extends K, ? extends V> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"MapIterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final MapIterator<K, V> tmpIterator = (MapIterator<K, V>) iterator;\n        return tmpIterator;\n    }\n    return new UnmodifiableMapIterator<K, V>(iterator);\n}"
            ],
            [
                "resettableEmptyIterator",
                "org.apache.commons.collections4.iterators",
                "EmptyIterator",
                "/**\n * Get a typed resettable empty iterator instance.\n * @param <E> the element type\n * @return ResettableIterator<E>\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> ResettableIterator<E> resettableEmptyIterator() {\n    return (ResettableIterator<E>) RESETTABLE_INSTANCE;\n}"
            ],
            [
                "emptyIterator",
                "org.apache.commons.collections4.iterators",
                "EmptyIterator",
                "/**\n * Get a typed empty iterator instance.\n * @param <E> the element type\n * @return Iterator<E>\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Iterator<E> emptyIterator() {\n    return (Iterator<E>) INSTANCE;\n}"
            ],
            [
                "pushbackIterator",
                "org.apache.commons.collections4.iterators",
                "PushbackIterator",
                "//-----------------------------------------------------------------------\n/**\n * Decorates the specified iterator to support one-element lookahead.\n * <p>\n * If the iterator is already a {@link PushbackIterator} it is returned directly.\n *\n * @param <E>  the element type\n * @param iterator  the iterator to decorate\n * @return a new peeking iterator\n * @throws NullPointerException if the iterator is null\n */\npublic static <E> PushbackIterator<E> pushbackIterator(final Iterator<? extends E> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof PushbackIterator<?>) {\n        // safe cast\n        @SuppressWarnings(\"unchecked\")\n        final PushbackIterator<E> it = (PushbackIterator<E>) iterator;\n        return it;\n    }\n    return new PushbackIterator<E>(iterator);\n}"
            ],
            [
                "readableMap",
                "org.apache.commons.collections4",
                "SplitMapUtils",
                "//-----------------------------------------------------------------------\n/**\n * Get the specified {@link Get} as an instance of {@link IterableMap}.\n * If <code>get</code> implements {@link IterableMap} directly, no conversion will take place.\n * If <code>get</code> implements {@link Map} but not {@link IterableMap} it will be decorated.\n * Otherwise an {@link Unmodifiable} {@link IterableMap} will be returned.\n * @param <K> the key type\n * @param <V> the value type\n * @param get to wrap, must not be null\n * @return {@link IterableMap}\n * @throws NullPointerException if the argument is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <K, V> IterableMap<K, V> readableMap(final Get<K, V> get) {\n    if (get == null) {\n        throw new NullPointerException(\"Get must not be null\");\n    }\n    if (get instanceof Map) {\n        return get instanceof IterableMap ? ((IterableMap<K, V>) get) : MapUtils.iterableMap((Map<K, V>) get);\n    }\n    return new WrappedGet<K, V>(get);\n}"
            ],
            [
                "writableMap",
                "org.apache.commons.collections4",
                "SplitMapUtils",
                "/**\n * Get the specified {@link Put} as an instanceof {@link Map}.\n * If <code>put</code> implements {@link Map} directly, no conversion will take place.\n * Otherwise a <em>write-only</em> {@link Map} will be returned.  On such a {@link Map}\n * it is recommended that the result of #put(K, V) be discarded as it likely will not\n * match <code>V</code> at runtime.\n *\n * @param <K> the key type\n * @param <V> the element type\n * @param put to wrap, must not be null\n * @return {@link Map}\n * @throws NullPointerException if the argument is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <K, V> Map<K, V> writableMap(final Put<K, V> put) {\n    if (put == null) {\n        throw new NullPointerException(\"Put must not be null\");\n    }\n    if (put instanceof Map) {\n        return (Map<K, V>) put;\n    }\n    return new WrappedPut<K, V>(put);\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "EMPTY_ITERATOR",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// validation is done in this class in certain cases because the\n// public classes allow invalid states\n/**\n * An iterator over no elements.\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final ResettableIterator EMPTY_ITERATOR = EmptyIterator.RESETTABLE_INSTANCE;"
            ],
            [
                "EMPTY_LIST_ITERATOR",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * A list iterator over no elements.\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final ResettableListIterator EMPTY_LIST_ITERATOR = EmptyListIterator.RESETTABLE_INSTANCE;"
            ],
            [
                "EMPTY_ORDERED_ITERATOR",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * An ordered iterator over no elements.\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final OrderedIterator EMPTY_ORDERED_ITERATOR = EmptyOrderedIterator.INSTANCE;"
            ],
            [
                "EMPTY_MAP_ITERATOR",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * A map iterator over no elements.\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final MapIterator EMPTY_MAP_ITERATOR = EmptyMapIterator.INSTANCE;"
            ],
            [
                "EMPTY_ORDERED_MAP_ITERATOR",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * An ordered map iterator over no elements.\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final OrderedMapIterator EMPTY_ORDERED_MAP_ITERATOR = EmptyOrderedMapIterator.INSTANCE;"
            ],
            [
                "NATURAL_COMPARATOR",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Comparator for natural sort order.\n *\n * @see ComparableComparator#comparableComparator()\n */\n// explicit type needed for Java 1.5 compilation\n@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\npublic static final Comparator NATURAL_COMPARATOR = ComparableComparator.<Comparable>comparableComparator();"
            ],
            [
                "EMPTY_MULTI_VALUED_MAP",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "/**\n * An empty {@link UnmodifiableMultiValuedMap}.\n */\n@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\npublic static final MultiValuedMap EMPTY_MULTI_VALUED_MAP = UnmodifiableMultiValuedMap.unmodifiableMultiValuedMap(new ArrayListValuedHashMap(0, 0));"
            ],
            [
                "EMPTY_SORTED_MAP",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * An empty unmodifiable sorted map.\n * This is not provided in the JDK.\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final SortedMap EMPTY_SORTED_MAP = UnmodifiableSortedMap.unmodifiableSortedMap(new TreeMap<Object, Object>());"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "DefaultEquator",
                "/**\n * Static instance\n */\n// the static instance works for all types\n@SuppressWarnings(\"rawtypes\")\npublic static final DefaultEquator INSTANCE = new DefaultEquator<Object>();"
            ],
            [
                "HASHCODE_NULL",
                "org.apache.commons.collections4.functors",
                "DefaultEquator",
                "/**\n * Hashcode used for <code>null</code> objects.\n */\npublic static final int HASHCODE_NULL = -1;"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "ExceptionClosure",
                "/**\n * Singleton predicate instance\n */\n// the static instance works for all types\n@SuppressWarnings(\"rawtypes\")\npublic static final Closure INSTANCE = new ExceptionClosure<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "NOPClosure",
                "/**\n * Singleton predicate instance\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final Closure INSTANCE = new NOPClosure<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "NullPredicate",
                "/**\n * Singleton predicate instance\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final Predicate INSTANCE = new NullPredicate<Object>();"
            ],
            [
                "NULL_INSTANCE",
                "org.apache.commons.collections4.functors",
                "ConstantTransformer",
                "/**\n * Returns null each time\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final Transformer NULL_INSTANCE = new ConstantTransformer<Object, Object>(null);"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "ExceptionTransformer",
                "/**\n * Singleton predicate instance\n */\n// the static instance works for all types\n@SuppressWarnings(\"rawtypes\")\npublic static final Transformer INSTANCE = new ExceptionTransformer<Object, Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "NOPTransformer",
                "/**\n * Singleton predicate instance\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final Transformer INSTANCE = new NOPTransformer<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "ExceptionFactory",
                "/**\n * Singleton predicate instance\n */\n// the static instance works for all types\n@SuppressWarnings(\"rawtypes\")\npublic static final Factory INSTANCE = new ExceptionFactory<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "ExceptionPredicate",
                "/**\n * Singleton predicate instance\n */\n// the static instance works for all types\n@SuppressWarnings(\"rawtypes\")\npublic static final Predicate INSTANCE = new ExceptionPredicate<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "FalsePredicate",
                "/**\n * Singleton predicate instance\n */\n// the static instance works for all types\n@SuppressWarnings(\"rawtypes\")\npublic static final Predicate INSTANCE = new FalsePredicate<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "CloneTransformer",
                "/**\n * Singleton predicate instance\n */\n// the singleton instance works for all types\n@SuppressWarnings(\"rawtypes\")\npublic static final Transformer INSTANCE = new CloneTransformer<Object>();"
            ],
            [
                "NULL_INSTANCE",
                "org.apache.commons.collections4.functors",
                "ConstantFactory",
                "/**\n * Returns null each time\n */\n// The null factory works for all object types\n@SuppressWarnings(\"rawtypes\")\npublic static final Factory NULL_INSTANCE = new ConstantFactory<Object>(null);"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "TruePredicate",
                "/**\n * Singleton predicate instance\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final Predicate INSTANCE = new TruePredicate<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "NotNullPredicate",
                "/**\n * Singleton predicate instance\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final Predicate INSTANCE = new NotNullPredicate<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.comparators",
                "ComparableComparator",
                "/**\n * The singleton instance.\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final ComparableComparator INSTANCE = new ComparableComparator();"
            ],
            [
                "EMPTY_COLLECTION",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * An empty unmodifiable collection.\n * The JDK provides empty Set and List implementations which could be used for\n * this purpose. However they could be cast to Set or List which might be\n * undesirable. This implementation only implements Collection.\n */\n// we deliberately use the raw type here\n@SuppressWarnings(\"rawtypes\")\npublic static final Collection EMPTY_COLLECTION = UnmodifiableCollection.unmodifiableCollection(new ArrayList<Object>());"
            ],
            [
                "EMPTY_ITERABLE",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * An empty iterable.\n */\n@SuppressWarnings(\"rawtypes\")\nstatic final FluentIterable EMPTY_ITERABLE = new FluentIterable<Object>() {\n\n    @Override\n    public Iterator<Object> iterator() {\n        return IteratorUtils.emptyIterator();\n    }\n};"
            ],
            [
                "NULL_BIT_KEY",
                "org.apache.commons.collections4.trie",
                "KeyAnalyzer",
                "/**\n * Returned by {@link #bitIndex(Object, int, int, Object, int, int)}\n * if key's bits are all 0.\n */\npublic static final int NULL_BIT_KEY = -1;"
            ],
            [
                "EQUAL_BIT_KEY",
                "org.apache.commons.collections4.trie",
                "KeyAnalyzer",
                "/**\n * Returned by {@link #bitIndex(Object, int, int, Object, int, int)} if key and found key are equal.\n * This is a very very specific case and shouldn't happen on a regular basis.\n */\npublic static final int EQUAL_BIT_KEY = -2;"
            ],
            [
                "OUT_OF_BOUNDS_BIT_KEY",
                "org.apache.commons.collections4.trie",
                "KeyAnalyzer",
                "public static final int OUT_OF_BOUNDS_BIT_KEY = -3;"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.trie.analyzer",
                "StringKeyAnalyzer",
                "/**\n * A singleton instance of {@link StringKeyAnalyzer}.\n */\npublic static final StringKeyAnalyzer INSTANCE = new StringKeyAnalyzer();"
            ],
            [
                "LENGTH",
                "org.apache.commons.collections4.trie.analyzer",
                "StringKeyAnalyzer",
                "/**\n * The number of bits per {@link Character}.\n */\npublic static final int LENGTH = Character.SIZE;"
            ],
            [
                "NO_NEXT_ENTRY",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "protected static final String NO_NEXT_ENTRY = \"No next() entry in the iteration\";"
            ],
            [
                "NO_PREVIOUS_ENTRY",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "protected static final String NO_PREVIOUS_ENTRY = \"No previous() entry in the iteration\";"
            ],
            [
                "REMOVE_INVALID",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "protected static final String REMOVE_INVALID = \"remove() can only be called once after next()\";"
            ],
            [
                "GETKEY_INVALID",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "protected static final String GETKEY_INVALID = \"getKey() can only be called after next() and before remove()\";"
            ],
            [
                "GETVALUE_INVALID",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "protected static final String GETVALUE_INVALID = \"getValue() can only be called after next() and before remove()\";"
            ],
            [
                "SETVALUE_INVALID",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "protected static final String SETVALUE_INVALID = \"setValue() can only be called after next() and before remove()\";"
            ],
            [
                "DEFAULT_CAPACITY",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "/**\n * The default capacity to use\n */\nprotected static final int DEFAULT_CAPACITY = 16;"
            ],
            [
                "DEFAULT_THRESHOLD",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "/**\n * The default threshold to use\n */\nprotected static final int DEFAULT_THRESHOLD = 12;"
            ],
            [
                "DEFAULT_LOAD_FACTOR",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "/**\n * The default load factor to use\n */\nprotected static final float DEFAULT_LOAD_FACTOR = 0.75f;"
            ],
            [
                "MAXIMUM_CAPACITY",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "/**\n * The maximum capacity allowed\n */\nprotected static final int MAXIMUM_CAPACITY = 1 << 30;"
            ],
            [
                "NULL",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "/**\n * An object for masking null\n */\nprotected static final Object NULL = new Object();"
            ],
            [
                "DEFAULT_MAX_SIZE",
                "org.apache.commons.collections4.map",
                "LRUMap",
                "/**\n * Default maximum size\n */\nprotected static final int DEFAULT_MAX_SIZE = 100;"
            ],
            [
                "EMPTY_MULTISET",
                "org.apache.commons.collections4",
                "MultiSetUtils",
                "/**\n * An empty unmodifiable multiset.\n */\n// OK, empty multiset is compatible with any type\n@SuppressWarnings(\"rawtypes\")\npublic static final MultiSet EMPTY_MULTISET = UnmodifiableMultiSet.unmodifiableMultiSet(new HashMultiSet<Object>());"
            ],
            [
                "EMPTY_SORTED_SET",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * An empty unmodifiable sorted set.\n * This is not provided in the JDK.\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final SortedSet EMPTY_SORTED_SET = UnmodifiableSortedSet.unmodifiableSortedSet(new TreeSet<Object>());"
            ],
            [
                "EMPTY_QUEUE",
                "org.apache.commons.collections4",
                "QueueUtils",
                "/**\n * An empty unmodifiable queue.\n */\n// OK, empty queue is compatible with any type\n@SuppressWarnings(\"rawtypes\")\npublic static final Queue EMPTY_QUEUE = UnmodifiableQueue.unmodifiableQueue(new LinkedList<Object>());"
            ],
            [
                "EMPTY_BAG",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * An empty unmodifiable bag.\n */\n// OK, empty bag is compatible with any type\n@SuppressWarnings(\"rawtypes\")\npublic static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());"
            ],
            [
                "EMPTY_SORTED_BAG",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * An empty unmodifiable sorted bag.\n */\n// OK, empty bag is compatible with any type\n@SuppressWarnings(\"rawtypes\")\npublic static final Bag EMPTY_SORTED_BAG = UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());"
            ],
            [
                "RESETTABLE_INSTANCE",
                "org.apache.commons.collections4.iterators",
                "EmptyListIterator",
                "/**\n * Singleton instance of the iterator.\n * @since 3.1\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final ResettableListIterator RESETTABLE_INSTANCE = new EmptyListIterator<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.iterators",
                "EmptyListIterator",
                "/**\n * Singleton instance of the iterator.\n * @since 2.1.1 and 3.1\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final ListIterator INSTANCE = RESETTABLE_INSTANCE;"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.iterators",
                "EmptyMapIterator",
                "/**\n * Singleton instance of the iterator.\n * @since 3.1\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final MapIterator INSTANCE = new EmptyMapIterator<Object, Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.iterators",
                "EmptyOrderedIterator",
                "/**\n * Singleton instance of the iterator.\n * @since 3.1\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final OrderedIterator INSTANCE = new EmptyOrderedIterator<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.iterators",
                "EmptyOrderedMapIterator",
                "/**\n * Singleton instance of the iterator.\n * @since 3.1\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final OrderedMapIterator INSTANCE = new EmptyOrderedMapIterator<Object, Object>();"
            ],
            [
                "RESETTABLE_INSTANCE",
                "org.apache.commons.collections4.iterators",
                "EmptyIterator",
                "/**\n * Singleton instance of the iterator.\n * @since 3.1\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final ResettableIterator RESETTABLE_INSTANCE = new EmptyIterator<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.iterators",
                "EmptyIterator",
                "/**\n * Singleton instance of the iterator.\n * @since 2.1.1 and 3.1\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final Iterator INSTANCE = RESETTABLE_INSTANCE;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [
            [
                "object",
                "",
                "C"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "containsAll",
                "org.apache.commons.collections4.collection",
                "IndexedCollection",
                "/**\n * {@inheritDoc}\n * <p>\n * Note: uses the index for fast lookup\n */\n@Override\npublic boolean containsAll(final Collection<?> coll) {\n    for (final Object o : coll) {\n        if (!contains(o)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "iterator",
                "org.apache.commons.collections4.collection",
                "AbstractCollectionDecorator",
                "public Iterator<E> iterator()"
            ],
            [
                "retainAll",
                "java.util",
                "Collection",
                "public abstract boolean retainAll(Collection<? extends Object> arg0)"
            ],
            [
                "retainAll",
                "org.apache.commons.collections4.collection",
                "IndexedCollection",
                "@Override\npublic boolean retainAll(final Collection<?> coll) {\n    final boolean changed = super.retainAll(coll);\n    if (changed) {\n        reindex();\n    }\n    return changed;\n}"
            ],
            [
                "toArray",
                "org.apache.commons.collections4.collection",
                "AbstractCollectionDecorator",
                "public <T> T[] toArray(T[] arg0)"
            ],
            [
                "get",
                "org.apache.commons.collections4.collection",
                "IndexedCollection",
                "/**\n * Get the element associated with the given key.\n * <p>\n * In case of a non-unique index, this method will return the first\n * value associated with the given key. To retrieve all elements associated\n * with a key, use {@link #values(Object)}.\n *\n * @param key  key to look up\n * @return element found\n * @see #values(Object)\n */\npublic C get(final K key) {\n    // index is a MultiMap which returns a Collection\n    @SuppressWarnings(\"unchecked\")\n    final Collection<C> coll = (Collection<C>) index.get(key);\n    return coll == null ? null : coll.iterator().next();\n}"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "removeIf",
                "org.apache.commons.collections4.collection",
                "AbstractCollectionDecorator",
                "public boolean removeIf(Predicate<? super E> arg0)"
            ],
            [
                "isEmpty",
                "org.apache.commons.collections4.collection",
                "AbstractCollectionDecorator",
                "public boolean isEmpty()"
            ],
            [
                "toArray",
                "org.apache.commons.collections4.collection",
                "AbstractCollectionDecorator",
                "public Object[] toArray()"
            ],
            [
                "contains",
                "org.apache.commons.collections4.collection",
                "IndexedCollection",
                "/**\n * {@inheritDoc}\n * <p>\n * Note: uses the index for fast lookup\n */\n@SuppressWarnings(\"unchecked\")\n@Override\npublic boolean contains(final Object object) {\n    return index.containsKey(keyTransformer.transform((C) object));\n}"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "addAll",
                "org.apache.commons.collections4.collection",
                "IndexedCollection",
                "@Override\npublic boolean addAll(final Collection<? extends C> coll) {\n    boolean changed = false;\n    for (final C c : coll) {\n        changed |= add(c);\n    }\n    return changed;\n}"
            ],
            [
                "iterator",
                "java.lang",
                "Iterable",
                "public abstract Iterator<T> iterator()"
            ],
            [
                "add",
                "org.apache.commons.collections4.collection",
                "IndexedCollection",
                "/**\n * {@inheritDoc}\n *\n * @throws IllegalArgumentException if the object maps to an existing key and the index\n *   enforces a uniqueness constraint\n */\n@Override\npublic boolean add(final C object) {\n    final boolean added = super.add(object);\n    if (added) {\n        addToIndex(object);\n    }\n    return added;\n}"
            ],
            [
                "values",
                "org.apache.commons.collections4.collection",
                "IndexedCollection",
                "/**\n * Get all elements associated with the given key.\n *\n * @param key  key to look up\n * @return a collection of elements found, or null if {@code contains(key) == false}\n */\n// index is a MultiMap which returns a Collection\n@SuppressWarnings(\"unchecked\")\npublic Collection<C> values(final K key) {\n    return (Collection<C>) index.get(key);\n}"
            ],
            [
                "removeAll",
                "java.util",
                "Collection",
                "public abstract boolean removeAll(Collection<? extends Object> arg0)"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "size",
                "org.apache.commons.collections4.collection",
                "AbstractCollectionDecorator",
                "public int size()"
            ],
            [
                "spliterator",
                "java.lang",
                "Iterable",
                "public default Spliterator<T> spliterator()"
            ],
            [
                "remove",
                "org.apache.commons.collections4.collection",
                "IndexedCollection",
                "@SuppressWarnings(\"unchecked\")\n@Override\npublic boolean remove(final Object object) {\n    final boolean removed = super.remove(object);\n    if (removed) {\n        removeFromIndex((C) object);\n    }\n    return removed;\n}"
            ],
            [
                "toString",
                "org.apache.commons.collections4.collection",
                "AbstractCollectionDecorator",
                "public String toString()"
            ],
            [
                "decorated",
                "org.apache.commons.collections4.collection",
                "AbstractCollectionDecorator",
                "protected Collection<E> decorated()"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "stream",
                "java.util",
                "Collection",
                "public default Stream<E> stream()"
            ],
            [
                "toArray",
                "java.util",
                "Collection",
                "public default <T> T[] toArray(IntFunction<T[]> arg0)"
            ],
            [
                "spliterator",
                "java.util",
                "Collection",
                "public default Spliterator<E> spliterator()"
            ],
            [
                "parallelStream",
                "java.util",
                "Collection",
                "public default Stream<E> parallelStream()"
            ],
            [
                "containsAll",
                "java.util",
                "Collection",
                "public abstract boolean containsAll(Collection<? extends Object> arg0)"
            ],
            [
                "removeAll",
                "org.apache.commons.collections4.collection",
                "IndexedCollection",
                "@Override\npublic boolean removeAll(final Collection<?> coll) {\n    boolean changed = false;\n    for (final Object o : coll) {\n        changed |= remove(o);\n    }\n    return changed;\n}"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 6359,
        "oracle": ";",
        "oracleType": "PRE",
        "projectName": "commons-collections4-4.1",
        "packageName": "org.apache.commons.collections4.collection",
        "className": "IndexedCollection",
        "javadocTag": "@param keyTransformer {@link Transformer} for generating index keys",
        "methodJavadoc": "    /**\n     * Create a {@link IndexedCollection}.\n     *\n     * @param coll  decorated {@link Collection}\n     * @param keyTransformer  {@link Transformer} for generating index keys\n     * @param map  map to use as index\n     * @param uniqueIndex  if the index shall enforce uniqueness of index keys\n     */",
        "methodSourceCode": "public IndexedCollection(final Collection<C> coll, final Transformer<C, K> keyTransformer, final MultiMap<K, C> map, final boolean uniqueIndex){\n    super(coll);\n    this.keyTransformer = keyTransformer;\n    this.index = map;\n    this.uniqueIndex = uniqueIndex;\n    reindex();\n}",
        "classJavadoc": "/**\n * An IndexedCollection is a Map-like view onto a Collection. It accepts a\n * keyTransformer to define how the keys are converted from the values.\n * <p>\n * Modifications made to this decorator modify the index as well as the\n * decorated {@link Collection}. However, modifications to the underlying\n * {@link Collection} will not update the index and it will get out of sync.\n * <p>\n * If modification of the decorated {@link Collection} is unavoidable, then a\n * call to {@link #reindex()} will update the index to the current contents of\n * the {@link Collection}.\n *\n * @param <K> the type of object in the index.\n * @param <C> the type of object in the collection.\n *\n * @since 4.0\n * @version $Id: IndexedCollection.java 1683018 2015-06-01 22:41:31Z tn $\n */",
        "classSourceCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4.collection;\n\nimport java.util.Collection;\nimport java.util.HashMap;\n\nimport org.apache.commons.collections4.MultiMap;\nimport org.apache.commons.collections4.Transformer;\nimport org.apache.commons.collections4.map.MultiValueMap;\n\n/**\n * An IndexedCollection is a Map-like view onto a Collection. It accepts a\n * keyTransformer to define how the keys are converted from the values.\n * <p>\n * Modifications made to this decorator modify the index as well as the\n * decorated {@link Collection}. However, modifications to the underlying\n * {@link Collection} will not update the index and it will get out of sync.\n * <p>\n * If modification of the decorated {@link Collection} is unavoidable, then a\n * call to {@link #reindex()} will update the index to the current contents of\n * the {@link Collection}.\n *\n * @param <K> the type of object in the index.\n * @param <C> the type of object in the collection.\n *\n * @since 4.0\n * @version $Id: IndexedCollection.java 1683018 2015-06-01 22:41:31Z tn $\n */\npublic class IndexedCollection<K, C> extends AbstractCollectionDecorator<C> {\n\n    // TODO: replace with MultiValuedMap\n\n    /** Serialization version */\n    private static final long serialVersionUID = -5512610452568370038L;\n\n    /** The {@link Transformer} for generating index keys. */\n    private final Transformer<C, K> keyTransformer;\n\n    /** The map of indexes to collected objects. */\n    private final MultiMap<K, C> index;\n\n    /** The uniqueness constraint for the index. */\n    private final boolean uniqueIndex;\n\n    /**\n     * Create an {@link IndexedCollection} for a unique index.\n     * <p>\n     * If an element is added, which maps to an existing key, an {@link IllegalArgumentException}\n     * will be thrown.\n     *\n     * @param <K> the index object type.\n     * @param <C> the collection type.\n     * @param coll the decorated {@link Collection}.\n     * @param keyTransformer the {@link Transformer} for generating index keys.\n     * @return the created {@link IndexedCollection}.\n     */\n    public static <K, C> IndexedCollection<K, C> uniqueIndexedCollection(final Collection<C> coll,\n                                                                         final Transformer<C, K> keyTransformer) {\n        return new IndexedCollection<K, C>(coll, keyTransformer,\n                                           MultiValueMap.<K, C>multiValueMap(new HashMap<K, Collection<C>>()),\n                                           true);\n    }\n\n    /**\n     * Create an {@link IndexedCollection} for a non-unique index.\n     *\n     * @param <K> the index object type.\n     * @param <C> the collection type.\n     * @param coll the decorated {@link Collection}.\n     * @param keyTransformer the {@link Transformer} for generating index keys.\n     * @return the created {@link IndexedCollection}.\n     */\n    public static <K, C> IndexedCollection<K, C> nonUniqueIndexedCollection(final Collection<C> coll,\n                                                                            final Transformer<C, K> keyTransformer) {\n        return new IndexedCollection<K, C>(coll, keyTransformer,\n                                           MultiValueMap.<K, C>multiValueMap(new HashMap<K, Collection<C>>()),\n                                           false);\n    }\n\n    /**\n     * Create a {@link IndexedCollection}.\n     *\n     * @param coll  decorated {@link Collection}\n     * @param keyTransformer  {@link Transformer} for generating index keys\n     * @param map  map to use as index\n     * @param uniqueIndex  if the index shall enforce uniqueness of index keys\n     */\n    public IndexedCollection(final Collection<C> coll, final Transformer<C, K> keyTransformer,\n                             final MultiMap<K, C> map, final boolean uniqueIndex) {\n        super(coll);\n        this.keyTransformer = keyTransformer;\n        this.index = map;\n        this.uniqueIndex = uniqueIndex;\n        reindex();\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * @throws IllegalArgumentException if the object maps to an existing key and the index\n     *   enforces a uniqueness constraint\n     */\n    @Override\n    public boolean add(final C object) {\n        final boolean added = super.add(object);\n        if (added) {\n            addToIndex(object);\n        }\n        return added;\n    }\n\n    @Override\n    public boolean addAll(final Collection<? extends C> coll) {\n        boolean changed = false;\n        for (final C c: coll) {\n            changed |= add(c);\n        }\n        return changed;\n    }\n\n    @Override\n    public void clear() {\n        super.clear();\n        index.clear();\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p>\n     * Note: uses the index for fast lookup\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public boolean contains(final Object object) {\n        return index.containsKey(keyTransformer.transform((C) object));\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p>\n     * Note: uses the index for fast lookup\n     */\n    @Override\n    public boolean containsAll(final Collection<?> coll) {\n        for (final Object o : coll) {\n            if (!contains(o)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Get the element associated with the given key.\n     * <p>\n     * In case of a non-unique index, this method will return the first\n     * value associated with the given key. To retrieve all elements associated\n     * with a key, use {@link #values(Object)}.\n     *\n     * @param key  key to look up\n     * @return element found\n     * @see #values(Object)\n     */\n    public C get(final K key) {\n        @SuppressWarnings(\"unchecked\") // index is a MultiMap which returns a Collection\n        final Collection<C> coll = (Collection<C>) index.get(key);\n        return coll == null ? null : coll.iterator().next();\n    }\n\n    /**\n     * Get all elements associated with the given key.\n     *\n     * @param key  key to look up\n     * @return a collection of elements found, or null if {@code contains(key) == false}\n     */\n    @SuppressWarnings(\"unchecked\") // index is a MultiMap which returns a Collection\n    public Collection<C> values(final K key) {\n        return (Collection<C>) index.get(key);\n    }\n\n    /**\n     * Clears the index and re-indexes the entire decorated {@link Collection}.\n     */\n    public void reindex() {\n        index.clear();\n        for (final C c : decorated()) {\n            addToIndex(c);\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public boolean remove(final Object object) {\n        final boolean removed = super.remove(object);\n        if (removed) {\n            removeFromIndex((C) object);\n        }\n        return removed;\n    }\n\n    @Override\n    public boolean removeAll(final Collection<?> coll) {\n        boolean changed = false;\n        for (final Object o : coll) {\n            changed |= remove(o);\n        }\n        return changed;\n    }\n\n    @Override\n    public boolean retainAll(final Collection<?> coll) {\n        final boolean changed = super.retainAll(coll);\n        if (changed) {\n            reindex();\n        }\n        return changed;\n    }\n\n    //-----------------------------------------------------------------------\n\n    /**\n     * Provides checking for adding the index.\n     *\n     * @param object the object to index\n     * @throws IllegalArgumentException if the object maps to an existing key and the index\n     *   enforces a uniqueness constraint\n     */\n    private void addToIndex(final C object) {\n        final K key = keyTransformer.transform(object);\n        if (uniqueIndex && index.containsKey(key)) {\n            throw new IllegalArgumentException(\"Duplicate key in uniquely indexed collection.\");\n        }\n        index.put(key, object);\n    }\n\n    /**\n     * Removes an object from the index.\n     *\n     * @param object the object to remove\n     */\n    private void removeFromIndex(final C object) {\n        index.remove(keyTransformer.transform(object));\n    }\n\n}\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "BidiMap",
                "org.apache.commons.collections4"
            ],
            [
                "Equator",
                "org.apache.commons.collections4"
            ],
            [
                "MultiSet",
                "org.apache.commons.collections4"
            ],
            [
                "IteratorUtils",
                "org.apache.commons.collections4"
            ],
            [
                "ComparatorUtils",
                "org.apache.commons.collections4"
            ],
            [
                "FunctorException",
                "org.apache.commons.collections4"
            ],
            [
                "AbstractDualBidiMap",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "UnmodifiableBidiMap",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "AbstractOrderedBidiMapDecorator",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "UnmodifiableOrderedBidiMap",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "AbstractBidiMapDecorator",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "DualLinkedHashBidiMap",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "UnmodifiableSortedBidiMap",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "AbstractSortedBidiMapDecorator",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "DualHashBidiMap",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "DualTreeBidiMap",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "TreeBidiMap",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "MultiMapUtils",
                "org.apache.commons.collections4"
            ],
            [
                "BoundedCollection",
                "org.apache.commons.collections4"
            ],
            [
                "UnmodifiableBoundedCollection",
                "org.apache.commons.collections4.collection"
            ],
            [
                "CompositeCollection",
                "org.apache.commons.collections4.collection"
            ],
            [
                "TransformedCollection",
                "org.apache.commons.collections4.collection"
            ],
            [
                "PredicatedCollection",
                "org.apache.commons.collections4.collection"
            ],
            [
                "IndexedCollection",
                "org.apache.commons.collections4.collection"
            ],
            [
                "SynchronizedCollection",
                "org.apache.commons.collections4.collection"
            ],
            [
                "UnmodifiableCollection",
                "org.apache.commons.collections4.collection"
            ],
            [
                "AbstractCollectionDecorator",
                "org.apache.commons.collections4.collection"
            ],
            [
                "OrderedBidiMap",
                "org.apache.commons.collections4"
            ],
            [
                "FactoryUtils",
                "org.apache.commons.collections4"
            ],
            [
                "IterableGet",
                "org.apache.commons.collections4"
            ],
            [
                "ListUtils",
                "org.apache.commons.collections4"
            ],
            [
                "Closure",
                "org.apache.commons.collections4"
            ],
            [
                "IterableSortedMap",
                "org.apache.commons.collections4"
            ],
            [
                "MapUtils",
                "org.apache.commons.collections4"
            ],
            [
                "Transformer",
                "org.apache.commons.collections4"
            ],
            [
                "DefaultEquator",
                "org.apache.commons.collections4.functors"
            ],
            [
                "StringValueTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "PredicateDecorator",
                "org.apache.commons.collections4.functors"
            ],
            [
                "IfTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "IdentityPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ExceptionClosure",
                "org.apache.commons.collections4.functors"
            ],
            [
                "NOPClosure",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ClosureTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "FunctorUtils",
                "org.apache.commons.collections4.functors"
            ],
            [
                "TransformerPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "NullPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ConstantTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "PredicateTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "WhileClosure",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ForClosure",
                "org.apache.commons.collections4.functors"
            ],
            [
                "NullIsTruePredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "TransformedPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "NonePredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ExceptionTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "SwitchTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "TransformerClosure",
                "org.apache.commons.collections4.functors"
            ],
            [
                "OrPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "NOPTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "MapTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ExceptionFactory",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ChainedClosure",
                "org.apache.commons.collections4.functors"
            ],
            [
                "AndPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "PrototypeFactory",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ExceptionPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "AbstractQuantifierPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "InstanceofPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "InvokerTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "FalsePredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "CloneTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "NotPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ConstantFactory",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ChainedTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ComparatorPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "CatchAndRethrowClosure",
                "org.apache.commons.collections4.functors"
            ],
            [
                "AllPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "NullIsFalsePredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "NullIsExceptionPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "AnyPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "TruePredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "FactoryTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "NotNullPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "SwitchClosure",
                "org.apache.commons.collections4.functors"
            ],
            [
                "UniquePredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "InstantiateTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "OnePredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "EqualPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "InstantiateFactory",
                "org.apache.commons.collections4.functors"
            ],
            [
                "IfClosure",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ResettableListIterator",
                "org.apache.commons.collections4"
            ],
            [
                "OrderedIterator",
                "org.apache.commons.collections4"
            ],
            [
                "ComparatorChain",
                "org.apache.commons.collections4.comparators"
            ],
            [
                "BooleanComparator",
                "org.apache.commons.collections4.comparators"
            ],
            [
                "ReverseComparator",
                "org.apache.commons.collections4.comparators"
            ],
            [
                "ComparableComparator",
                "org.apache.commons.collections4.comparators"
            ],
            [
                "TransformingComparator",
                "org.apache.commons.collections4.comparators"
            ],
            [
                "FixedOrderComparator",
                "org.apache.commons.collections4.comparators"
            ],
            [
                "NullComparator",
                "org.apache.commons.collections4.comparators"
            ],
            [
                "CollectionUtils",
                "org.apache.commons.collections4"
            ],
            [
                "ListValuedMap",
                "org.apache.commons.collections4"
            ],
            [
                "AbstractIterableGetMapDecorator",
                "org.apache.commons.collections4.splitmap"
            ],
            [
                "TransformedSplitMap",
                "org.apache.commons.collections4.splitmap"
            ],
            [
                "Factory",
                "org.apache.commons.collections4"
            ],
            [
                "IterableUtils",
                "org.apache.commons.collections4"
            ],
            [
                "Bag",
                "org.apache.commons.collections4"
            ],
            [
                "Predicate",
                "org.apache.commons.collections4"
            ],
            [
                "SortedBag",
                "org.apache.commons.collections4"
            ],
            [
                "TrieUtils",
                "org.apache.commons.collections4"
            ],
            [
                "ClosureUtils",
                "org.apache.commons.collections4"
            ],
            [
                "PatriciaTrie",
                "org.apache.commons.collections4.trie"
            ],
            [
                "UnmodifiableTrie",
                "org.apache.commons.collections4.trie"
            ],
            [
                "KeyAnalyzer",
                "org.apache.commons.collections4.trie"
            ],
            [
                "AbstractPatriciaTrie",
                "org.apache.commons.collections4.trie"
            ],
            [
                "AbstractBitwiseTrie",
                "org.apache.commons.collections4.trie"
            ],
            [
                "StringKeyAnalyzer",
                "org.apache.commons.collections4.trie.analyzer"
            ],
            [
                "TransformedSortedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "AbstractLinkedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "Flat3Map",
                "org.apache.commons.collections4.map"
            ],
            [
                "PredicatedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "FixedSizeSortedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "UnmodifiableSortedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "PredicatedSortedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "DefaultedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "ReferenceIdentityMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "AbstractSortedMapDecorator",
                "org.apache.commons.collections4.map"
            ],
            [
                "AbstractInputCheckedMapDecorator",
                "org.apache.commons.collections4.map"
            ],
            [
                "FixedSizeMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "LazySortedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "UnmodifiableOrderedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "CaseInsensitiveMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "AbstractHashedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "AbstractOrderedMapDecorator",
                "org.apache.commons.collections4.map"
            ],
            [
                "UnmodifiableMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "EntrySetToMapIteratorAdapter",
                "org.apache.commons.collections4.map"
            ],
            [
                "AbstractIterableMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "ListOrderedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "LinkedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "SingletonMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "UnmodifiableEntrySet",
                "org.apache.commons.collections4.map"
            ],
            [
                "StaticBucketMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "AbstractMapDecorator",
                "org.apache.commons.collections4.map"
            ],
            [
                "AbstractReferenceMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "MultiKeyMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "HashedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "LazyMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "PassiveExpiringMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "MultiValueMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "LRUMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "ReferenceMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "TransformedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "CompositeMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "UnmodifiableMapEntry",
                "org.apache.commons.collections4.keyvalue"
            ],
            [
                "MultiKey",
                "org.apache.commons.collections4.keyvalue"
            ],
            [
                "DefaultMapEntry",
                "org.apache.commons.collections4.keyvalue"
            ],
            [
                "DefaultKeyValue",
                "org.apache.commons.collections4.keyvalue"
            ],
            [
                "AbstractMapEntryDecorator",
                "org.apache.commons.collections4.keyvalue"
            ],
            [
                "AbstractKeyValue",
                "org.apache.commons.collections4.keyvalue"
            ],
            [
                "TiedMapEntry",
                "org.apache.commons.collections4.keyvalue"
            ],
            [
                "AbstractMapEntry",
                "org.apache.commons.collections4.keyvalue"
            ],
            [
                "MultiSetUtils",
                "org.apache.commons.collections4"
            ],
            [
                "MapIterator",
                "org.apache.commons.collections4"
            ],
            [
                "AbstractMultiValuedMap",
                "org.apache.commons.collections4.multimap"
            ],
            [
                "UnmodifiableMultiValuedMap",
                "org.apache.commons.collections4.multimap"
            ],
            [
                "HashSetValuedHashMap",
                "org.apache.commons.collections4.multimap"
            ],
            [
                "TransformedMultiValuedMap",
                "org.apache.commons.collections4.multimap"
            ],
            [
                "AbstractSetValuedMap",
                "org.apache.commons.collections4.multimap"
            ],
            [
                "AbstractListValuedMap",
                "org.apache.commons.collections4.multimap"
            ],
            [
                "ArrayListValuedHashMap",
                "org.apache.commons.collections4.multimap"
            ],
            [
                "AbstractMultiValuedMapDecorator",
                "org.apache.commons.collections4.multimap"
            ],
            [
                "LazyList",
                "org.apache.commons.collections4.list"
            ],
            [
                "AbstractSerializableListDecorator",
                "org.apache.commons.collections4.list"
            ],
            [
                "TreeList",
                "org.apache.commons.collections4.list"
            ],
            [
                "SetUniqueList",
                "org.apache.commons.collections4.list"
            ],
            [
                "AbstractListDecorator",
                "org.apache.commons.collections4.list"
            ],
            [
                "NodeCachingLinkedList",
                "org.apache.commons.collections4.list"
            ],
            [
                "UnmodifiableList",
                "org.apache.commons.collections4.list"
            ],
            [
                "FixedSizeList",
                "org.apache.commons.collections4.list"
            ],
            [
                "TransformedList",
                "org.apache.commons.collections4.list"
            ],
            [
                "GrowthList",
                "org.apache.commons.collections4.list"
            ],
            [
                "AbstractLinkedList",
                "org.apache.commons.collections4.list"
            ],
            [
                "CursorableLinkedList",
                "org.apache.commons.collections4.list"
            ],
            [
                "PredicatedList",
                "org.apache.commons.collections4.list"
            ],
            [
                "OrderedMap",
                "org.apache.commons.collections4"
            ],
            [
                "AbstractQueueDecorator",
                "org.apache.commons.collections4.queue"
            ],
            [
                "TransformedQueue",
                "org.apache.commons.collections4.queue"
            ],
            [
                "UnmodifiableQueue",
                "org.apache.commons.collections4.queue"
            ],
            [
                "CircularFifoQueue",
                "org.apache.commons.collections4.queue"
            ],
            [
                "PredicatedQueue",
                "org.apache.commons.collections4.queue"
            ],
            [
                "FluentIterable",
                "org.apache.commons.collections4"
            ],
            [
                "TransformerUtils",
                "org.apache.commons.collections4"
            ],
            [
                "PredicateUtils",
                "org.apache.commons.collections4"
            ],
            [
                "ResettableIterator",
                "org.apache.commons.collections4"
            ],
            [
                "MultiValuedMap",
                "org.apache.commons.collections4"
            ],
            [
                "SetUtils",
                "org.apache.commons.collections4"
            ],
            [
                "SortedBidiMap",
                "org.apache.commons.collections4"
            ],
            [
                "ArrayStack",
                "org.apache.commons.collections4"
            ],
            [
                "Put",
                "org.apache.commons.collections4"
            ],
            [
                "OrderedMapIterator",
                "org.apache.commons.collections4"
            ],
            [
                "TransformedSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "CompositeSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "TransformedNavigableSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "PredicatedNavigableSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "AbstractSetDecorator",
                "org.apache.commons.collections4.set"
            ],
            [
                "ListOrderedSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "UnmodifiableSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "AbstractSerializableSetDecorator",
                "org.apache.commons.collections4.set"
            ],
            [
                "MapBackedSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "UnmodifiableSortedSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "PredicatedSortedSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "AbstractSortedSetDecorator",
                "org.apache.commons.collections4.set"
            ],
            [
                "PredicatedSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "AbstractNavigableSetDecorator",
                "org.apache.commons.collections4.set"
            ],
            [
                "UnmodifiableNavigableSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "TransformedSortedSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "IterableMap",
                "org.apache.commons.collections4"
            ],
            [
                "EnumerationUtils",
                "org.apache.commons.collections4"
            ],
            [
                "DeleteCommand",
                "org.apache.commons.collections4.sequence"
            ],
            [
                "ReplacementsHandler",
                "org.apache.commons.collections4.sequence"
            ],
            [
                "InsertCommand",
                "org.apache.commons.collections4.sequence"
            ],
            [
                "SequencesComparator",
                "org.apache.commons.collections4.sequence"
            ],
            [
                "ReplacementsFinder",
                "org.apache.commons.collections4.sequence"
            ],
            [
                "KeepCommand",
                "org.apache.commons.collections4.sequence"
            ],
            [
                "EditCommand",
                "org.apache.commons.collections4.sequence"
            ],
            [
                "CommandVisitor",
                "org.apache.commons.collections4.sequence"
            ],
            [
                "EditScript",
                "org.apache.commons.collections4.sequence"
            ],
            [
                "QueueUtils",
                "org.apache.commons.collections4"
            ],
            [
                "SetValuedMap",
                "org.apache.commons.collections4"
            ],
            [
                "SynchronizedBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "AbstractMapBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "CollectionBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "UnmodifiableBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "PredicatedSortedBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "UnmodifiableSortedBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "HashBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "AbstractBagDecorator",
                "org.apache.commons.collections4.bag"
            ],
            [
                "TransformedSortedBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "TreeBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "PredicatedBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "SynchronizedSortedBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "CollectionSortedBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "TransformedBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "AbstractSortedBagDecorator",
                "org.apache.commons.collections4.bag"
            ],
            [
                "HashMultiSet",
                "org.apache.commons.collections4.multiset"
            ],
            [
                "AbstractMultiSet",
                "org.apache.commons.collections4.multiset"
            ],
            [
                "PredicatedMultiSet",
                "org.apache.commons.collections4.multiset"
            ],
            [
                "AbstractMultiSetDecorator",
                "org.apache.commons.collections4.multiset"
            ],
            [
                "AbstractMapMultiSet",
                "org.apache.commons.collections4.multiset"
            ],
            [
                "UnmodifiableMultiSet",
                "org.apache.commons.collections4.multiset"
            ],
            [
                "SynchronizedMultiSet",
                "org.apache.commons.collections4.multiset"
            ],
            [
                "BagUtils",
                "org.apache.commons.collections4"
            ],
            [
                "Unmodifiable",
                "org.apache.commons.collections4"
            ],
            [
                "Get",
                "org.apache.commons.collections4"
            ],
            [
                "Trie",
                "org.apache.commons.collections4"
            ],
            [
                "MultiMap",
                "org.apache.commons.collections4"
            ],
            [
                "KeyValue",
                "org.apache.commons.collections4"
            ],
            [
                "IteratorChain",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "EmptyListIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "UnmodifiableOrderedMapIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "AbstractListIteratorDecorator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "ZippingIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "UnmodifiableIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "CollatingIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "UniqueFilterIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "ReverseListIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "BoundedIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "AbstractIteratorDecorator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "TransformIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "AbstractEmptyIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "NodeListIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "ArrayListIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "LazyIteratorChain",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "LoopingListIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "PeekingIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "ObjectGraphIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "ArrayIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "PermutationIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "SingletonListIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "EmptyMapIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "ObjectArrayIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "EnumerationIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "IteratorIterable",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "AbstractEmptyMapIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "LoopingIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "IteratorEnumeration",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "SingletonIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "ListIteratorWrapper",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "SkippingIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "EmptyOrderedIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "AbstractMapIteratorDecorator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "ObjectArrayListIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "UnmodifiableListIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "EmptyOrderedMapIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "UnmodifiableMapIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "EmptyIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "EntrySetMapIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "PushbackIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "FilterIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "AbstractUntypedIteratorDecorator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "AbstractOrderedMapIteratorDecorator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "FilterListIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "SplitMapUtils",
                "org.apache.commons.collections4"
            ],
            [
                "BoundedMap",
                "org.apache.commons.collections4"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "emptyIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Empty\n//-----------------------------------------------------------------------\n/**\n * Gets an empty iterator.\n * <p>\n * This iterator is a valid iterator object that will iterate over nothing.\n *\n * @param <E> the element type\n * @return an iterator over nothing\n */\npublic static <E> ResettableIterator<E> emptyIterator() {\n    return EmptyIterator.<E>resettableEmptyIterator();\n}"
            ],
            [
                "emptyListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an empty list iterator.\n * <p>\n * This iterator is a valid list iterator object that will iterate\n * over nothing.\n *\n * @param <E> the element type\n * @return a list iterator over nothing\n */\npublic static <E> ResettableListIterator<E> emptyListIterator() {\n    return EmptyListIterator.<E>resettableEmptyListIterator();\n}"
            ],
            [
                "emptyOrderedIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an empty ordered iterator.\n * <p>\n * This iterator is a valid iterator object that will iterate\n * over nothing.\n *\n * @param <E> the element type\n * @return an ordered iterator over nothing\n */\npublic static <E> OrderedIterator<E> emptyOrderedIterator() {\n    return EmptyOrderedIterator.<E>emptyOrderedIterator();\n}"
            ],
            [
                "emptyMapIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an empty map iterator.\n * <p>\n * This iterator is a valid map iterator object that will iterate\n * over nothing.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @return a map iterator over nothing\n */\npublic static <K, V> MapIterator<K, V> emptyMapIterator() {\n    return EmptyMapIterator.<K, V>emptyMapIterator();\n}"
            ],
            [
                "emptyOrderedMapIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an empty ordered map iterator.\n * <p>\n * This iterator is a valid map iterator object that will iterate\n * over nothing.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @return a map iterator over nothing\n */\npublic static <K, V> OrderedMapIterator<K, V> emptyOrderedMapIterator() {\n    return EmptyOrderedMapIterator.<K, V>emptyOrderedMapIterator();\n}"
            ],
            [
                "singletonIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Singleton\n//-----------------------------------------------------------------------\n/**\n * Gets a singleton iterator.\n * <p>\n * This iterator is a valid iterator object that will iterate over\n * the specified object.\n *\n * @param <E> the element type\n * @param object  the single object over which to iterate\n * @return a singleton iterator over the object\n */\npublic static <E> ResettableIterator<E> singletonIterator(final E object) {\n    return new SingletonIterator<E>(object);\n}"
            ],
            [
                "singletonListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a singleton list iterator.\n * <p>\n * This iterator is a valid list iterator object that will iterate over\n * the specified object.\n *\n * @param <E> the element type\n * @param object  the single object over which to iterate\n * @return a singleton list iterator over the object\n */\npublic static <E> ListIterator<E> singletonListIterator(final E object) {\n    return new SingletonListIterator<E>(object);\n}"
            ],
            [
                "arrayIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Arrays\n//-----------------------------------------------------------------------\n/**\n * Gets an iterator over an object array.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @return an iterator over the array\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableIterator<E> arrayIterator(final E... array) {\n    return new ObjectArrayIterator<E>(array);\n}"
            ],
            [
                "arrayIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator over an object or primitive array.\n * <p>\n * This method will handle primitive arrays as well as object arrays.\n * The primitives will be wrapped in the appropriate wrapper class.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @return an iterator over the array\n * @throws IllegalArgumentException if the array is not an array\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableIterator<E> arrayIterator(final Object array) {\n    return new ArrayIterator<E>(array);\n}"
            ],
            [
                "arrayIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator over the end part of an object array.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @param start  the index to start iterating at\n * @return an iterator over part of the array\n * @throws IndexOutOfBoundsException if start is less than zero or greater\n *   than the length of the array\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableIterator<E> arrayIterator(final E[] array, final int start) {\n    return new ObjectArrayIterator<E>(array, start);\n}"
            ],
            [
                "arrayIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator over the end part of an object or primitive array.\n * <p>\n * This method will handle primitive arrays as well as object arrays.\n * The primitives will be wrapped in the appropriate wrapper class.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @param start  the index to start iterating at\n * @return an iterator over part of the array\n * @throws IllegalArgumentException if the array is not an array\n * @throws IndexOutOfBoundsException if start is less than zero or greater\n *   than the length of the array\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableIterator<E> arrayIterator(final Object array, final int start) {\n    return new ArrayIterator<E>(array, start);\n}"
            ],
            [
                "arrayIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator over part of an object array.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @param start  the index to start iterating at\n * @param end  the index to finish iterating at\n * @return an iterator over part of the array\n * @throws IndexOutOfBoundsException if array bounds are invalid\n * @throws IllegalArgumentException if end is before start\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableIterator<E> arrayIterator(final E[] array, final int start, final int end) {\n    return new ObjectArrayIterator<E>(array, start, end);\n}"
            ],
            [
                "arrayIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator over part of an object or primitive array.\n * <p>\n * This method will handle primitive arrays as well as object arrays.\n * The primitives will be wrapped in the appropriate wrapper class.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @param start  the index to start iterating at\n * @param end  the index to finish iterating at\n * @return an iterator over part of the array\n * @throws IllegalArgumentException if the array is not an array or end is before start\n * @throws IndexOutOfBoundsException if array bounds are invalid\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableIterator<E> arrayIterator(final Object array, final int start, final int end) {\n    return new ArrayIterator<E>(array, start, end);\n}"
            ],
            [
                "arrayListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "//-----------------------------------------------------------------------\n/**\n * Gets a list iterator over an object array.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @return a list iterator over the array\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableListIterator<E> arrayListIterator(final E... array) {\n    return new ObjectArrayListIterator<E>(array);\n}"
            ],
            [
                "arrayListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a list iterator over an object or primitive array.\n * <p>\n * This method will handle primitive arrays as well as object arrays.\n * The primitives will be wrapped in the appropriate wrapper class.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @return a list iterator over the array\n * @throws IllegalArgumentException if the array is not an array\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableListIterator<E> arrayListIterator(final Object array) {\n    return new ArrayListIterator<E>(array);\n}"
            ],
            [
                "arrayListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a list iterator over the end part of an object array.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @param start  the index to start iterating at\n * @return a list iterator over part of the array\n * @throws IndexOutOfBoundsException if start is less than zero\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableListIterator<E> arrayListIterator(final E[] array, final int start) {\n    return new ObjectArrayListIterator<E>(array, start);\n}"
            ],
            [
                "arrayListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a list iterator over the end part of an object or primitive array.\n * <p>\n * This method will handle primitive arrays as well as object arrays.\n * The primitives will be wrapped in the appropriate wrapper class.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @param start  the index to start iterating at\n * @return a list iterator over part of the array\n * @throws IllegalArgumentException if the array is not an array\n * @throws IndexOutOfBoundsException if start is less than zero\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableListIterator<E> arrayListIterator(final Object array, final int start) {\n    return new ArrayListIterator<E>(array, start);\n}"
            ],
            [
                "arrayListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a list iterator over part of an object array.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @param start  the index to start iterating at\n * @param end  the index to finish iterating at\n * @return a list iterator over part of the array\n * @throws IndexOutOfBoundsException if array bounds are invalid\n * @throws IllegalArgumentException if end is before start\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableListIterator<E> arrayListIterator(final E[] array, final int start, final int end) {\n    return new ObjectArrayListIterator<E>(array, start, end);\n}"
            ],
            [
                "arrayListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a list iterator over part of an object or primitive array.\n * <p>\n * This method will handle primitive arrays as well as object arrays.\n * The primitives will be wrapped in the appropriate wrapper class.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @param start  the index to start iterating at\n * @param end  the index to finish iterating at\n * @return a list iterator over part of the array\n * @throws IllegalArgumentException if the array is not an array or end is before start\n * @throws IndexOutOfBoundsException if array bounds are invalid\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableListIterator<E> arrayListIterator(final Object array, final int start, final int end) {\n    return new ArrayListIterator<E>(array, start, end);\n}"
            ],
            [
                "boundedIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Bounded\n//-----------------------------------------------------------------------\n/**\n * Decorates the specified iterator to return at most the given number\n * of elements.\n *\n * @param <E> the element type\n * @param iterator  the iterator to decorate\n * @param max  the maximum number of elements returned by this iterator\n * @return a new bounded iterator\n * @throws NullPointerException if the iterator is null\n * @throws IllegalArgumentException if max is negative\n * @since 4.1\n */\npublic static <E> BoundedIterator<E> boundedIterator(final Iterator<? extends E> iterator, long max) {\n    return boundedIterator(iterator, 0, max);\n}"
            ],
            [
                "boundedIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Decorates the specified iterator to return at most the given number\n * of elements, skipping all elements until the iterator reaches the\n * position at {@code offset}.\n * <p>\n * The iterator is immediately advanced until it reaches the position at\n * {@code offset}, incurring O(n) time.\n *\n * @param <E> the element type\n * @param iterator  the iterator to decorate\n * @param offset  the index of the first element of the decorated iterator to return\n * @param max  the maximum number of elements returned by this iterator\n * @return a new bounded iterator\n * @throws NullPointerException if the iterator is null\n * @throws IllegalArgumentException if either offset or max is negative\n * @since 4.1\n */\npublic static <E> BoundedIterator<E> boundedIterator(final Iterator<? extends E> iterator, long offset, long max) {\n    return new BoundedIterator<E>(iterator, offset, max);\n}"
            ],
            [
                "unmodifiableIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Unmodifiable\n//-----------------------------------------------------------------------\n/**\n * Gets an immutable version of an {@link Iterator}. The returned object\n * will always throw an {@link UnsupportedOperationException} for\n * the {@link Iterator#remove} method.\n *\n * @param <E> the element type\n * @param iterator  the iterator to make immutable\n * @return an immutable version of the iterator\n */\npublic static <E> Iterator<E> unmodifiableIterator(final Iterator<E> iterator) {\n    return UnmodifiableIterator.unmodifiableIterator(iterator);\n}"
            ],
            [
                "unmodifiableListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an immutable version of a {@link ListIterator}. The returned object\n * will always throw an {@link UnsupportedOperationException} for\n * the {@link Iterator#remove}, {@link ListIterator#add} and\n * {@link ListIterator#set} methods.\n *\n * @param <E> the element type\n * @param listIterator  the iterator to make immutable\n * @return an immutable version of the iterator\n */\npublic static <E> ListIterator<E> unmodifiableListIterator(final ListIterator<E> listIterator) {\n    return UnmodifiableListIterator.umodifiableListIterator(listIterator);\n}"
            ],
            [
                "unmodifiableMapIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an immutable version of a {@link MapIterator}. The returned object\n * will always throw an {@link UnsupportedOperationException} for\n * the {@link Iterator#remove}, {@link MapIterator#setValue(Object)} methods.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param mapIterator  the iterator to make immutable\n * @return an immutable version of the iterator\n */\npublic static <K, V> MapIterator<K, V> unmodifiableMapIterator(final MapIterator<K, V> mapIterator) {\n    return UnmodifiableMapIterator.unmodifiableMapIterator(mapIterator);\n}"
            ],
            [
                "chainedIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Chained\n//-----------------------------------------------------------------------\n/**\n * Gets an iterator that iterates through two {@link Iterator}s\n * one after another.\n *\n * @param <E> the element type\n * @param iterator1  the first iterator to use, not null\n * @param iterator2  the second iterator to use, not null\n * @return a combination iterator over the iterators\n * @throws NullPointerException if either iterator is null\n */\npublic static <E> Iterator<E> chainedIterator(final Iterator<? extends E> iterator1, final Iterator<? extends E> iterator2) {\n    // keep a version with two iterators to avoid the following warning in client code (Java 5 & 6)\n    // \"A generic array of E is created for a varargs parameter\"\n    return new IteratorChain<E>(iterator1, iterator2);\n}"
            ],
            [
                "chainedIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator that iterates through an array of {@link Iterator}s\n * one after another.\n *\n * @param <E> the element type\n * @param iterators  the iterators to use, not null or empty or contain nulls\n * @return a combination iterator over the iterators\n * @throws NullPointerException if iterators array is null or contains a null\n */\npublic static <E> Iterator<E> chainedIterator(final Iterator<? extends E>... iterators) {\n    return new IteratorChain<E>(iterators);\n}"
            ],
            [
                "chainedIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator that iterates through a collections of {@link Iterator}s\n * one after another.\n *\n * @param <E> the element type\n * @param iterators  the iterators to use, not null or empty or contain nulls\n * @return a combination iterator over the iterators\n * @throws NullPointerException if iterators collection is null or contains a null\n * @throws ClassCastException if the iterators collection contains the wrong object type\n */\npublic static <E> Iterator<E> chainedIterator(final Collection<Iterator<? extends E>> iterators) {\n    return new IteratorChain<E>(iterators);\n}"
            ],
            [
                "collatedIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Collated\n//-----------------------------------------------------------------------\n/**\n * Gets an iterator that provides an ordered iteration over the elements\n * contained in a collection of ordered {@link Iterator}s.\n * <p>\n * Given two ordered {@link Iterator}s <code>A</code> and <code>B</code>,\n * the {@link Iterator#next()} method will return the lesser of\n * <code>A.next()</code> and <code>B.next()</code>.\n * <p>\n * The comparator is optional. If null is specified then natural order is used.\n *\n * @param <E> the element type\n * @param comparator  the comparator to use, may be null for natural order\n * @param iterator1  the first iterators to use, not null\n * @param iterator2  the first iterators to use, not null\n * @return a combination iterator over the iterators\n * @throws NullPointerException if either iterator is null\n */\npublic static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator, final Iterator<? extends E> iterator1, final Iterator<? extends E> iterator2) {\n    @SuppressWarnings(\"unchecked\")\n    final Comparator<E> comp = comparator == null ? ComparatorUtils.NATURAL_COMPARATOR : (Comparator<E>) comparator;\n    return new CollatingIterator<E>(comp, iterator1, iterator2);\n}"
            ],
            [
                "collatedIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator that provides an ordered iteration over the elements\n * contained in an array of {@link Iterator}s.\n * <p>\n * Given two ordered {@link Iterator}s <code>A</code> and <code>B</code>,\n * the {@link Iterator#next()} method will return the lesser of\n * <code>A.next()</code> and <code>B.next()</code> and so on.\n * <p>\n * The comparator is optional. If null is specified then natural order is used.\n *\n * @param <E> the element type\n * @param comparator  the comparator to use, may be null for natural order\n * @param iterators  the iterators to use, not null or empty or contain nulls\n * @return a combination iterator over the iterators\n * @throws NullPointerException if iterators array is null or contains a null value\n */\npublic static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator, final Iterator<? extends E>... iterators) {\n    @SuppressWarnings(\"unchecked\")\n    final Comparator<E> comp = comparator == null ? ComparatorUtils.NATURAL_COMPARATOR : (Comparator<E>) comparator;\n    return new CollatingIterator<E>(comp, iterators);\n}"
            ],
            [
                "collatedIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator that provides an ordered iteration over the elements\n * contained in a collection of {@link Iterator}s.\n * <p>\n * Given two ordered {@link Iterator}s <code>A</code> and <code>B</code>,\n * the {@link Iterator#next()} method will return the lesser of\n * <code>A.next()</code> and <code>B.next()</code> and so on.\n * <p>\n * The comparator is optional. If null is specified then natural order is used.\n *\n * @param <E> the element type\n * @param comparator  the comparator to use, may be null for natural order\n * @param iterators  the iterators to use, not null or empty or contain nulls\n * @return a combination iterator over the iterators\n * @throws NullPointerException if iterators collection is null or contains a null\n * @throws ClassCastException if the iterators collection contains the wrong object type\n */\npublic static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator, final Collection<Iterator<? extends E>> iterators) {\n    @SuppressWarnings(\"unchecked\")\n    final Comparator<E> comp = comparator == null ? ComparatorUtils.NATURAL_COMPARATOR : (Comparator<E>) comparator;\n    return new CollatingIterator<E>(comp, iterators);\n}"
            ],
            [
                "objectGraphIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Object Graph\n//-----------------------------------------------------------------------\n/**\n * Gets an iterator that operates over an object graph.\n * <p>\n * This iterator can extract multiple objects from a complex tree-like object graph.\n * The iteration starts from a single root object.\n * It uses a <code>Transformer</code> to extract the iterators and elements.\n * Its main benefit is that no intermediate <code>List</code> is created.\n * <p>\n * For example, consider an object graph:\n * <pre>\n *                 |- Branch -- Leaf\n *                 |         \\- Leaf\n *         |- Tree |         /- Leaf\n *         |       |- Branch -- Leaf\n *  Forest |                 \\- Leaf\n *         |       |- Branch -- Leaf\n *         |       |         \\- Leaf\n *         |- Tree |         /- Leaf\n *                 |- Branch -- Leaf\n *                 |- Branch -- Leaf</pre>\n * The following <code>Transformer</code>, used in this class, will extract all\n * the Leaf objects without creating a combined intermediate list:\n * <pre>\n * public Object transform(Object input) {\n *   if (input instanceof Forest) {\n *     return ((Forest) input).treeIterator();\n *   }\n *   if (input instanceof Tree) {\n *     return ((Tree) input).branchIterator();\n *   }\n *   if (input instanceof Branch) {\n *     return ((Branch) input).leafIterator();\n *   }\n *   if (input instanceof Leaf) {\n *     return input;\n *   }\n *   throw new ClassCastException();\n * }</pre>\n * <p>\n * Internally, iteration starts from the root object. When next is called,\n * the transformer is called to examine the object. The transformer will return\n * either an iterator or an object. If the object is an Iterator, the next element\n * from that iterator is obtained and the process repeats. If the element is an object\n * it is returned.\n * <p>\n * Under many circumstances, linking Iterators together in this manner is\n * more efficient (and convenient) than using nested for loops to extract a list.\n *\n * @param <E> the element type\n * @param root  the root object to start iterating from, null results in an empty iterator\n * @param transformer  the transformer to use, see above, null uses no effect transformer\n * @return a new object graph iterator\n * @since 3.1\n */\npublic static <E> Iterator<E> objectGraphIterator(final E root, final Transformer<? super E, ? extends E> transformer) {\n    return new ObjectGraphIterator<E>(root, transformer);\n}"
            ],
            [
                "transformedIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Transformed\n//-----------------------------------------------------------------------\n/**\n * Gets an iterator that transforms the elements of another iterator.\n * <p>\n * The transformation occurs during the next() method and the underlying\n * iterator is unaffected by the transformation.\n *\n * @param <I> the input type\n * @param <O> the output type\n * @param iterator  the iterator to use, not null\n * @param transform  the transform to use, not null\n * @return a new transforming iterator\n * @throws NullPointerException if either parameter is null\n */\npublic static <I, O> Iterator<O> transformedIterator(final Iterator<? extends I> iterator, final Transformer<? super I, ? extends O> transform) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (transform == null) {\n        throw new NullPointerException(\"Transformer must not be null\");\n    }\n    return new TransformIterator<I, O>(iterator, transform);\n}"
            ],
            [
                "filteredIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Filtered\n//-----------------------------------------------------------------------\n/**\n * Gets an iterator that filters another iterator.\n * <p>\n * The returned iterator will only return objects that match the specified\n * filtering predicate.\n *\n * @param <E> the element type\n * @param iterator  the iterator to use, not null\n * @param predicate  the predicate to use as a filter, not null\n * @return a new filtered iterator\n * @throws NullPointerException if either parameter is null\n */\npublic static <E> Iterator<E> filteredIterator(final Iterator<? extends E> iterator, final Predicate<? super E> predicate) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    return new FilterIterator<E>(iterator, predicate);\n}"
            ],
            [
                "filteredListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a list iterator that filters another list iterator.\n * <p>\n * The returned iterator will only return objects that match the specified\n * filtering predicate.\n *\n * @param <E> the element type\n * @param listIterator  the list iterator to use, not null\n * @param predicate  the predicate to use as a filter, not null\n * @return a new filtered iterator\n * @throws NullPointerException if either parameter is null\n */\npublic static <E> ListIterator<E> filteredListIterator(final ListIterator<? extends E> listIterator, final Predicate<? super E> predicate) {\n    if (listIterator == null) {\n        throw new NullPointerException(\"ListIterator must not be null\");\n    }\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    return new FilterListIterator<E>(listIterator, predicate);\n}"
            ],
            [
                "loopingIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Looping\n//-----------------------------------------------------------------------\n/**\n * Gets an iterator that loops continuously over the supplied collection.\n * <p>\n * The iterator will only stop looping if the remove method is called\n * enough times to empty the collection, or if the collection is empty\n * to start with.\n *\n * @param <E> the element type\n * @param coll  the collection to iterate over, not null\n * @return a new looping iterator\n * @throws NullPointerException if the collection is null\n */\npublic static <E> ResettableIterator<E> loopingIterator(final Collection<? extends E> coll) {\n    if (coll == null) {\n        throw new NullPointerException(\"Collection must not be null\");\n    }\n    return new LoopingIterator<E>(coll);\n}"
            ],
            [
                "loopingListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator that loops continuously over the supplied list.\n * <p>\n * The iterator will only stop looping if the remove method is called\n * enough times to empty the list, or if the list is empty to start with.\n *\n * @param <E> the element type\n * @param list  the list to iterate over, not null\n * @return a new looping iterator\n * @throws NullPointerException if the list is null\n * @since 3.2\n */\npublic static <E> ResettableListIterator<E> loopingListIterator(final List<E> list) {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    return new LoopingListIterator<E>(list);\n}"
            ],
            [
                "nodeListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// org.w3c.dom.NodeList iterators\n//-----------------------------------------------------------------------\n/**\n * Gets an {@link Iterator} that wraps the specified {@link NodeList}.\n * The returned {@link Iterator} can be used for a single iteration.\n *\n * @param nodeList  the node list to use, may not be null\n * @return a new, single use {@link Iterator}\n * @throws NullPointerException if nodeList is null\n * @since 4.0\n */\npublic static NodeListIterator nodeListIterator(final NodeList nodeList) {\n    if (nodeList == null) {\n        throw new NullPointerException(\"NodeList must not be null\");\n    }\n    return new NodeListIterator(nodeList);\n}"
            ],
            [
                "nodeListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an {@link Iterator} that wraps the specified node's childNodes.\n * The returned {@link Iterator} can be used for a single iteration.\n * <p>\n * Convenience method, allows easy iteration over NodeLists:\n * <pre>\n *   Iterator&lt;Node&gt; iterator = IteratorUtils.nodeListIterator(node);\n *   for(Node childNode : IteratorUtils.asIterable(iterator)) {\n *     ...\n *   }\n * </pre>\n *\n * @param node  the node to use, may not be null\n * @return a new, single use {@link Iterator}\n * @throws NullPointerException if node is null\n * @since 4.0\n */\npublic static NodeListIterator nodeListIterator(final Node node) {\n    if (node == null) {\n        throw new NullPointerException(\"Node must not be null\");\n    }\n    return new NodeListIterator(node);\n}"
            ],
            [
                "peekingIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Peeking\n//-----------------------------------------------------------------------\n/**\n * Gets an iterator that supports one-element lookahead.\n *\n * @param <E> the element type\n * @param iterator  the iterator to decorate, not null\n * @return a peeking iterator\n * @throws NullPointerException if the iterator is null\n * @since 4.0\n */\npublic static <E> Iterator<E> peekingIterator(final Iterator<? extends E> iterator) {\n    return PeekingIterator.peekingIterator(iterator);\n}"
            ],
            [
                "pushbackIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Pushback\n//-----------------------------------------------------------------------\n/**\n * Gets an iterator that supports pushback of elements.\n *\n * @param <E> the element type\n * @param iterator  the iterator to decorate, not null\n * @return a pushback iterator\n * @throws NullPointerException if the iterator is null\n * @since 4.0\n */\npublic static <E> Iterator<E> pushbackIterator(final Iterator<? extends E> iterator) {\n    return PushbackIterator.pushbackIterator(iterator);\n}"
            ],
            [
                "skippingIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Skipping\n//-----------------------------------------------------------------------\n/**\n * Decorates the specified iterator to skip the first N elements.\n *\n * @param <E> the element type\n * @param iterator  the iterator to decorate\n * @param offset  the first number of elements to skip\n * @return a new skipping iterator\n * @throws NullPointerException if the iterator is null\n * @throws IllegalArgumentException if offset is negative\n * @since 4.1\n */\npublic static <E> SkippingIterator<E> skippingIterator(final Iterator<E> iterator, long offset) {\n    return new SkippingIterator<E>(iterator, offset);\n}"
            ],
            [
                "zippingIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Zipping\n//-----------------------------------------------------------------------\n/**\n * Returns an iterator that interleaves elements from the decorated iterators.\n *\n * @param <E> the element type\n * @param a  the first iterator to interleave\n * @param b  the second iterator to interleave\n * @return an iterator, interleaving the decorated iterators\n * @throws NullPointerException if any iterator is null\n * @since 4.1\n */\npublic static <E> ZippingIterator<E> zippingIterator(final Iterator<? extends E> a, final Iterator<? extends E> b) {\n    return new ZippingIterator<E>(a, b);\n}"
            ],
            [
                "zippingIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Returns an iterator that interleaves elements from the decorated iterators.\n *\n * @param <E> the element type\n * @param a  the first iterator to interleave\n * @param b  the second iterator to interleave\n * @param c  the third iterator to interleave\n * @return an iterator, interleaving the decorated iterators\n * @throws NullPointerException if any iterator is null\n * @since 4.1\n */\npublic static <E> ZippingIterator<E> zippingIterator(final Iterator<? extends E> a, final Iterator<? extends E> b, final Iterator<? extends E> c) {\n    return new ZippingIterator<E>(a, b, c);\n}"
            ],
            [
                "zippingIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Returns an iterator that interleaves elements from the decorated iterators.\n *\n * @param <E> the element type\n * @param iterators  the array of iterators to interleave\n * @return an iterator, interleaving the decorated iterators\n * @throws NullPointerException if any iterator is null\n * @since 4.1\n */\npublic static <E> ZippingIterator<E> zippingIterator(final Iterator<? extends E>... iterators) {\n    return new ZippingIterator<E>(iterators);\n}"
            ],
            [
                "asIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Views\n//-----------------------------------------------------------------------\n/**\n * Gets an iterator that provides an iterator view of the given enumeration.\n *\n * @param <E> the element type\n * @param enumeration  the enumeration to use, may not be null\n * @return a new iterator\n * @throws NullPointerException if enumeration is null\n */\npublic static <E> Iterator<E> asIterator(final Enumeration<? extends E> enumeration) {\n    if (enumeration == null) {\n        throw new NullPointerException(\"Enumeration must not be null\");\n    }\n    return new EnumerationIterator<E>(enumeration);\n}"
            ],
            [
                "asIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator that provides an iterator view of the given enumeration\n * that will remove elements from the specified collection.\n *\n * @param <E> the element type\n * @param enumeration  the enumeration to use, may not be null\n * @param removeCollection  the collection to remove elements from, may not be null\n * @return a new iterator\n * @throws NullPointerException if enumeration or removeCollection is null\n */\npublic static <E> Iterator<E> asIterator(final Enumeration<? extends E> enumeration, final Collection<? super E> removeCollection) {\n    if (enumeration == null) {\n        throw new NullPointerException(\"Enumeration must not be null\");\n    }\n    if (removeCollection == null) {\n        throw new NullPointerException(\"Collection must not be null\");\n    }\n    return new EnumerationIterator<E>(enumeration, removeCollection);\n}"
            ],
            [
                "asEnumeration",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an enumeration that wraps an iterator.\n *\n * @param <E> the element type\n * @param iterator  the iterator to use, may not be null\n * @return a new enumeration\n * @throws NullPointerException if iterator is null\n */\npublic static <E> Enumeration<E> asEnumeration(final Iterator<? extends E> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorEnumeration<E>(iterator);\n}"
            ],
            [
                "asIterable",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an {@link Iterable} that wraps an iterator.  The returned {@link Iterable} can be\n * used for a single iteration.\n *\n * @param <E> the element type\n * @param iterator  the iterator to use, may not be null\n * @return a new, single use {@link Iterable}\n * @throws NullPointerException if iterator is null\n */\npublic static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}"
            ],
            [
                "asMultipleUseIterable",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterable that wraps an iterator.  The returned iterable can be\n * used for multiple iterations.\n *\n * @param <E> the element type\n * @param iterator  the iterator to use, may not be null\n * @return a new, multiple use iterable\n * @throws NullPointerException if iterator is null\n */\npublic static <E> Iterable<E> asMultipleUseIterable(final Iterator<? extends E> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, true);\n}"
            ],
            [
                "toListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a list iterator based on a simple iterator.\n * <p>\n * As the wrapped Iterator is traversed, a LinkedList of its values is\n * cached, permitting all required operations of ListIterator.\n *\n * @param <E> the element type\n * @param iterator  the iterator to use, may not be null\n * @return a new iterator\n * @throws NullPointerException if iterator parameter is null\n */\npublic static <E> ListIterator<E> toListIterator(final Iterator<? extends E> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new ListIteratorWrapper<E>(iterator);\n}"
            ],
            [
                "toArray",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an array based on an iterator.\n * <p>\n * As the wrapped Iterator is traversed, an ArrayList of its values is\n * created. At the end, this is converted to an array.\n *\n * @param iterator  the iterator to use, not null\n * @return an array of the iterator contents\n * @throws NullPointerException if iterator parameter is null\n */\npublic static Object[] toArray(final Iterator<?> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    final List<?> list = toList(iterator, 100);\n    return list.toArray();\n}"
            ],
            [
                "toArray",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an array based on an iterator.\n * <p>\n * As the wrapped Iterator is traversed, an ArrayList of its values is\n * created. At the end, this is converted to an array.\n *\n * @param <E> the element type\n * @param iterator  the iterator to use, not null\n * @param arrayClass  the class of array to create\n * @return an array of the iterator contents\n * @throws NullPointerException if iterator parameter or arrayClass is null\n * @throws ArrayStoreException if the arrayClass is invalid\n */\npublic static <E> E[] toArray(final Iterator<? extends E> iterator, final Class<E> arrayClass) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (arrayClass == null) {\n        throw new NullPointerException(\"Array class must not be null\");\n    }\n    final List<E> list = toList(iterator, 100);\n    @SuppressWarnings(\"unchecked\")\n    final E[] array = (E[]) Array.newInstance(arrayClass, list.size());\n    return list.toArray(array);\n}"
            ],
            [
                "toList",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a list based on an iterator.\n * <p>\n * As the wrapped Iterator is traversed, an ArrayList of its values is\n * created. At the end, the list is returned.\n *\n * @param <E> the element type\n * @param iterator  the iterator to use, not null\n * @return a list of the iterator contents\n * @throws NullPointerException if iterator parameter is null\n */\npublic static <E> List<E> toList(final Iterator<? extends E> iterator) {\n    return toList(iterator, 10);\n}"
            ],
            [
                "toList",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a list based on an iterator.\n * <p>\n * As the wrapped Iterator is traversed, an ArrayList of its values is\n * created. At the end, the list is returned.\n *\n * @param <E> the element type\n * @param iterator  the iterator to use, not null\n * @param estimatedSize  the initial size of the ArrayList\n * @return a list of the iterator contents\n * @throws NullPointerException if iterator parameter is null\n * @throws IllegalArgumentException if the size is less than 1\n */\npublic static <E> List<E> toList(final Iterator<? extends E> iterator, final int estimatedSize) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (estimatedSize < 1) {\n        throw new IllegalArgumentException(\"Estimated size must be greater than 0\");\n    }\n    final List<E> list = new ArrayList<E>(estimatedSize);\n    while (iterator.hasNext()) {\n        list.add(iterator.next());\n    }\n    return list;\n}"
            ],
            [
                "getIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a suitable Iterator for the given object.\n * <p>\n * This method can handle objects as follows\n * <ul>\n * <li>null - empty iterator\n * <li>Iterator - returned directly\n * <li>Enumeration - wrapped\n * <li>Collection - iterator from collection returned\n * <li>Map - values iterator returned\n * <li>Dictionary - values (elements) enumeration returned as iterator\n * <li>array - iterator over array returned\n * <li>object with iterator() public method accessed by reflection\n * <li>object - singleton iterator\n * <li>NodeList - iterator over the list\n * <li>Node - iterator over the child nodes\n * </ul>\n *\n * @param obj  the object to convert to an iterator\n * @return a suitable iterator, never null\n */\npublic static Iterator<?> getIterator(final Object obj) {\n    if (obj == null) {\n        return emptyIterator();\n    }\n    if (obj instanceof Iterator) {\n        return (Iterator<?>) obj;\n    }\n    if (obj instanceof Iterable) {\n        return ((Iterable<?>) obj).iterator();\n    }\n    if (obj instanceof Object[]) {\n        return new ObjectArrayIterator<Object>((Object[]) obj);\n    }\n    if (obj instanceof Enumeration) {\n        return new EnumerationIterator<Object>((Enumeration<?>) obj);\n    }\n    if (obj instanceof Map) {\n        return ((Map<?, ?>) obj).values().iterator();\n    }\n    if (obj instanceof NodeList) {\n        return new NodeListIterator((NodeList) obj);\n    }\n    if (obj instanceof Node) {\n        return new NodeListIterator((Node) obj);\n    }\n    if (obj instanceof Dictionary) {\n        return new EnumerationIterator<Object>(((Dictionary<?, ?>) obj).elements());\n    } else if (obj.getClass().isArray()) {\n        return new ArrayIterator<Object>(obj);\n    }\n    try {\n        final Method method = obj.getClass().getMethod(\"iterator\", (Class[]) null);\n        if (Iterator.class.isAssignableFrom(method.getReturnType())) {\n            final Iterator<?> it = (Iterator<?>) method.invoke(obj, (Object[]) null);\n            if (it != null) {\n                return it;\n            }\n        }\n    } catch (final RuntimeException e) {\n        // NOPMD\n        // ignore\n    } catch (final NoSuchMethodException e) {\n        // NOPMD\n        // ignore\n    } catch (final IllegalAccessException e) {\n        // NOPMD\n        // ignore\n    } catch (final InvocationTargetException e) {\n        // NOPMD\n        // ignore\n    }\n    return singletonIterator(obj);\n}"
            ],
            [
                "forEachButLast",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Executes the given closure on each but the last element in the iterator.\n * <p>\n * If the input iterator is null no change is made.\n *\n * @param <E> the type of object the {@link Iterator} contains\n * @param iterator  the iterator to get the input from, may be null\n * @param closure  the closure to perform, may not be null\n * @return the last element in the iterator, or null if iterator is null or empty\n * @throws NullPointerException if closure is null\n * @since 4.1\n */\npublic static <E> E forEachButLast(final Iterator<E> iterator, final Closure<? super E> closure) {\n    if (closure == null) {\n        throw new NullPointerException(\"Closure must not be null.\");\n    }\n    if (iterator != null) {\n        while (iterator.hasNext()) {\n            final E element = iterator.next();\n            if (iterator.hasNext()) {\n                closure.execute(element);\n            } else {\n                return element;\n            }\n        }\n    }\n    return null;\n}"
            ],
            [
                "find",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Finds the first element in the given iterator which matches the given predicate.\n * <p>\n * A <code>null</code> or empty iterator returns null.\n *\n * @param <E> the element type\n * @param iterator  the iterator to search, may be null\n * @param predicate  the predicate to use, may not be null\n * @return the first element of the iterator which matches the predicate or null if none could be found\n * @throws NullPointerException if predicate is null\n * @since 4.1\n */\npublic static <E> E find(final Iterator<E> iterator, final Predicate<? super E> predicate) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    if (iterator != null) {\n        while (iterator.hasNext()) {\n            final E element = iterator.next();\n            if (predicate.evaluate(element)) {\n                return element;\n            }\n        }\n    }\n    return null;\n}"
            ],
            [
                "indexOf",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Returns the index of the first element in the specified iterator that\n * matches the given predicate.\n * <p>\n * A <code>null</code> or empty iterator returns -1.\n *\n * @param <E> the element type\n * @param iterator  the iterator to search, may be null\n * @param predicate  the predicate to use, may not be null\n * @return the index of the first element which matches the predicate or -1 if none matches\n * @throws NullPointerException if predicate is null\n * @since 4.1\n */\npublic static <E> int indexOf(final Iterator<E> iterator, final Predicate<? super E> predicate) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    if (iterator != null) {\n        for (int index = 0; iterator.hasNext(); index++) {\n            final E element = iterator.next();\n            if (predicate.evaluate(element)) {\n                return index;\n            }\n        }\n    }\n    return -1;\n}"
            ],
            [
                "matchesAny",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Answers true if a predicate is true for any element of the iterator.\n * <p>\n * A <code>null</code> or empty iterator returns false.\n *\n * @param <E> the type of object the {@link Iterator} contains\n * @param iterator  the {@link Iterator} to use, may be null\n * @param predicate  the predicate to use, may not be null\n * @return true if any element of the collection matches the predicate, false otherwise\n * @throws NullPointerException if predicate is null\n * @since 4.1\n */\npublic static <E> boolean matchesAny(final Iterator<E> iterator, final Predicate<? super E> predicate) {\n    return indexOf(iterator, predicate) != -1;\n}"
            ],
            [
                "matchesAll",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Answers true if a predicate is true for every element of an iterator.\n * <p>\n * A <code>null</code> or empty iterator returns true.\n *\n * @param <E> the type of object the {@link Iterator} contains\n * @param iterator  the {@link Iterator} to use, may be null\n * @param predicate  the predicate to use, may not be null\n * @return true if every element of the collection matches the predicate or if the\n *   collection is empty, false otherwise\n * @throws NullPointerException if predicate is null\n * @since 4.1\n */\npublic static <E> boolean matchesAll(final Iterator<E> iterator, final Predicate<? super E> predicate) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    if (iterator != null) {\n        while (iterator.hasNext()) {\n            final E element = iterator.next();\n            if (!predicate.evaluate(element)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
            ],
            [
                "isEmpty",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Checks if the given iterator is empty.\n * <p>\n * A <code>null</code> or empty iterator returns true.\n *\n * @param iterator  the {@link Iterator} to use, may be null\n * @return true if the iterator is exhausted or null, false otherwise\n * @since 4.1\n */\npublic static boolean isEmpty(final Iterator<?> iterator) {\n    return iterator == null || !iterator.hasNext();\n}"
            ],
            [
                "contains",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Checks if the object is contained in the given iterator.\n * <p>\n * A <code>null</code> or empty iterator returns false.\n *\n * @param <E> the type of object the {@link Iterator} contains\n * @param iterator  the iterator to check, may be null\n * @param object  the object to check\n * @return true if the object is contained in the iterator, false otherwise\n * @since 4.1\n */\npublic static <E> boolean contains(final Iterator<E> iterator, final Object object) {\n    return matchesAny(iterator, EqualPredicate.equalPredicate(object));\n}"
            ],
            [
                "get",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Returns the <code>index</code>-th value in {@link Iterator}, throwing\n * <code>IndexOutOfBoundsException</code> if there is no such element.\n * <p>\n * The Iterator is advanced to <code>index</code> (or to the end, if\n * <code>index</code> exceeds the number of entries) as a side effect of this method.\n *\n * @param <E> the type of object in the {@link Iterator}\n * @param iterator  the iterator to get a value from\n * @param index  the index to get\n * @return the object at the specified index\n * @throws IndexOutOfBoundsException if the index is invalid\n * @since 4.1\n */\npublic static <E> E get(final Iterator<E> iterator, final int index) {\n    int i = index;\n    CollectionUtils.checkIndexBounds(i);\n    while (iterator.hasNext()) {\n        i--;\n        if (i == -1) {\n            return iterator.next();\n        }\n        iterator.next();\n    }\n    throw new IndexOutOfBoundsException(\"Entry does not exist: \" + i);\n}"
            ],
            [
                "size",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Returns the number of elements contained in the given iterator.\n * <p>\n * A <code>null</code> or empty iterator returns {@code 0}.\n *\n * @param iterator  the iterator to check, may be null\n * @return the number of elements contained in the iterator\n * @since 4.1\n */\npublic static int size(final Iterator<?> iterator) {\n    int size = 0;\n    if (iterator != null) {\n        while (iterator.hasNext()) {\n            iterator.next();\n            size++;\n        }\n    }\n    return size;\n}"
            ],
            [
                "toString",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Returns a string representation of the elements of the specified iterator.\n * <p>\n * The string representation consists of a list of the iterator's elements,\n * enclosed in square brackets ({@code \"[]\"}). Adjacent elements are separated\n * by the characters {@code \", \"} (a comma followed by a space). Elements are\n * converted to strings as by {@code String.valueOf(Object)}.\n *\n * @param <E> the element type\n * @param iterator  the iterator to convert to a string, may be null\n * @return a string representation of {@code iterator}\n * @since 4.1\n */\npublic static <E> String toString(final Iterator<E> iterator) {\n    return toString(iterator, TransformerUtils.stringValueTransformer(), DEFAULT_TOSTRING_DELIMITER, DEFAULT_TOSTRING_PREFIX, DEFAULT_TOSTRING_SUFFIX);\n}"
            ],
            [
                "toString",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Returns a string representation of the elements of the specified iterator.\n * <p>\n * The string representation consists of a list of the iterable's elements,\n * enclosed in square brackets ({@code \"[]\"}). Adjacent elements are separated\n * by the characters {@code \", \"} (a comma followed by a space). Elements are\n * converted to strings as by using the provided {@code transformer}.\n *\n * @param <E> the element type\n * @param iterator  the iterator to convert to a string, may be null\n * @param transformer  the transformer used to get a string representation of an element\n * @return a string representation of {@code iterator}\n * @throws NullPointerException if {@code transformer} is null\n * @since 4.1\n */\npublic static <E> String toString(final Iterator<E> iterator, final Transformer<? super E, String> transformer) {\n    return toString(iterator, transformer, DEFAULT_TOSTRING_DELIMITER, DEFAULT_TOSTRING_PREFIX, DEFAULT_TOSTRING_SUFFIX);\n}"
            ],
            [
                "toString",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Returns a string representation of the elements of the specified iterator.\n * <p>\n * The string representation consists of a list of the iterator's elements,\n * enclosed by the provided {@code prefix} and {@code suffix}. Adjacent elements\n * are separated by the provided {@code delimiter}. Elements are converted to\n * strings as by using the provided {@code transformer}.\n *\n * @param <E> the element type\n * @param iterator  the iterator to convert to a string, may be null\n * @param transformer  the transformer used to get a string representation of an element\n * @param delimiter  the string to delimit elements\n * @param prefix  the prefix, prepended to the string representation\n * @param suffix  the suffix, appended to the string representation\n * @return a string representation of {@code iterator}\n * @throws NullPointerException if either transformer, delimiter, prefix or suffix is null\n * @since 4.1\n */\npublic static <E> String toString(final Iterator<E> iterator, final Transformer<? super E, String> transformer, final String delimiter, final String prefix, final String suffix) {\n    if (transformer == null) {\n        throw new NullPointerException(\"transformer may not be null\");\n    }\n    if (delimiter == null) {\n        throw new NullPointerException(\"delimiter may not be null\");\n    }\n    if (prefix == null) {\n        throw new NullPointerException(\"prefix may not be null\");\n    }\n    if (suffix == null) {\n        throw new NullPointerException(\"suffix may not be null\");\n    }\n    final StringBuilder stringBuilder = new StringBuilder(prefix);\n    if (iterator != null) {\n        while (iterator.hasNext()) {\n            final E element = iterator.next();\n            stringBuilder.append(transformer.transform(element));\n            stringBuilder.append(delimiter);\n        }\n        if (stringBuilder.length() > prefix.length()) {\n            stringBuilder.setLength(stringBuilder.length() - delimiter.length());\n        }\n    }\n    stringBuilder.append(suffix);\n    return stringBuilder.toString();\n}"
            ],
            [
                "naturalComparator",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Gets a comparator that uses the natural order of the objects.\n *\n * @param <E>  the object type to compare\n * @return  a comparator which uses natural order\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E extends Comparable<? super E>> Comparator<E> naturalComparator() {\n    return NATURAL_COMPARATOR;\n}"
            ],
            [
                "chainedComparator",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Gets a comparator that compares using an array of {@link Comparator}s, applied\n * in sequence until one returns not equal or the array is exhausted.\n *\n * @param <E>  the object type to compare\n * @param comparators  the comparators to use, not null or empty or containing nulls\n * @return a {@link ComparatorChain} formed from the input comparators\n * @throws NullPointerException if comparators array is null or contains a null\n * @see ComparatorChain\n */\npublic static <E> Comparator<E> chainedComparator(final Comparator<E>... comparators) {\n    final ComparatorChain<E> chain = new ComparatorChain<E>();\n    for (final Comparator<E> comparator : comparators) {\n        if (comparator == null) {\n            throw new NullPointerException(\"Comparator cannot be null\");\n        }\n        chain.addComparator(comparator);\n    }\n    return chain;\n}"
            ],
            [
                "chainedComparator",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Gets a comparator that compares using a collection of {@link Comparator}s,\n * applied in (default iterator) sequence until one returns not equal or the\n * collection is exhausted.\n *\n * @param <E>  the object type to compare\n * @param comparators  the comparators to use, not null or empty or containing nulls\n * @return a {@link ComparatorChain} formed from the input comparators\n * @throws NullPointerException if comparators collection is null or contains a null\n * @throws ClassCastException if the comparators collection contains the wrong object type\n * @see ComparatorChain\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Comparator<E> chainedComparator(final Collection<Comparator<E>> comparators) {\n    return chainedComparator((Comparator<E>[]) comparators.toArray(new Comparator[comparators.size()]));\n}"
            ],
            [
                "reversedComparator",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Gets a comparator that reverses the order of the given comparator.\n *\n * @param <E>  the object type to compare\n * @param comparator  the comparator to reverse\n * @return  a comparator that reverses the order of the input comparator\n * @see ReverseComparator\n */\npublic static <E> Comparator<E> reversedComparator(final Comparator<E> comparator) {\n    return new ReverseComparator<E>(comparator);\n}"
            ],
            [
                "booleanComparator",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Gets a Comparator that can sort Boolean objects.\n * <p>\n * The parameter specifies whether true or false is sorted first.\n * <p>\n * The comparator throws NullPointerException if a null value is compared.\n *\n * @param trueFirst  when <code>true</code>, sort\n *        <code>true</code> {@link Boolean}s before\n *        <code>false</code> {@link Boolean}s.\n * @return  a comparator that sorts booleans\n */\npublic static Comparator<Boolean> booleanComparator(final boolean trueFirst) {\n    return BooleanComparator.booleanComparator(trueFirst);\n}"
            ],
            [
                "nullLowComparator",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Gets a Comparator that controls the comparison of <code>null</code> values.\n * <p>\n * The returned comparator will consider a null value to be less than\n * any nonnull value, and equal to any other null value.  Two nonnull\n * values will be evaluated with the given comparator.\n *\n * @param <E>  the object type to compare\n * @param comparator the comparator that wants to allow nulls\n * @return  a version of that comparator that allows nulls\n * @see NullComparator\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Comparator<E> nullLowComparator(Comparator<E> comparator) {\n    if (comparator == null) {\n        comparator = NATURAL_COMPARATOR;\n    }\n    return new NullComparator<E>(comparator, false);\n}"
            ],
            [
                "nullHighComparator",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Gets a Comparator that controls the comparison of <code>null</code> values.\n * <p>\n * The returned comparator will consider a null value to be greater than\n * any nonnull value, and equal to any other null value.  Two nonnull\n * values will be evaluated with the given comparator.\n *\n * @param <E>  the object type to compare\n * @param comparator the comparator that wants to allow nulls\n * @return  a version of that comparator that allows nulls\n * @see NullComparator\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Comparator<E> nullHighComparator(Comparator<E> comparator) {\n    if (comparator == null) {\n        comparator = NATURAL_COMPARATOR;\n    }\n    return new NullComparator<E>(comparator, true);\n}"
            ],
            [
                "transformedComparator",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Gets a Comparator that passes transformed objects to the given comparator.\n * <p>\n * Objects passed to the returned comparator will first be transformed\n * by the given transformer before they are compared by the given\n * comparator.\n *\n * @param <I>  the input object type of the transformed comparator\n * @param <O>  the object type of the decorated comparator\n * @param comparator  the sort order to use\n * @param transformer  the transformer to use\n * @return  a comparator that transforms its input objects before comparing them\n * @see  TransformingComparator\n */\n@SuppressWarnings(\"unchecked\")\npublic static <I, O> Comparator<I> transformedComparator(Comparator<O> comparator, final Transformer<? super I, ? extends O> transformer) {\n    if (comparator == null) {\n        comparator = NATURAL_COMPARATOR;\n    }\n    return new TransformingComparator<I, O>(transformer, comparator);\n}"
            ],
            [
                "min",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Returns the smaller of the given objects according to the given\n * comparator, returning the second object if the comparator\n * returns equal.\n *\n * @param <E>  the object type to compare\n * @param o1  the first object to compare\n * @param o2  the second object to compare\n * @param comparator  the sort order to use\n * @return  the smaller of the two objects\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> E min(final E o1, final E o2, Comparator<E> comparator) {\n    if (comparator == null) {\n        comparator = NATURAL_COMPARATOR;\n    }\n    final int c = comparator.compare(o1, o2);\n    return c < 0 ? o1 : o2;\n}"
            ],
            [
                "max",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Returns the larger of the given objects according to the given\n * comparator, returning the second object if the comparator\n * returns equal.\n *\n * @param <E>  the object type to compare\n * @param o1  the first object to compare\n * @param o2  the second object to compare\n * @param comparator  the sort order to use\n * @return  the larger of the two objects\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> E max(final E o1, final E o2, Comparator<E> comparator) {\n    if (comparator == null) {\n        comparator = NATURAL_COMPARATOR;\n    }\n    final int c = comparator.compare(o1, o2);\n    return c > 0 ? o1 : o2;\n}"
            ],
            [
                "unmodifiableBidiMap",
                "org.apache.commons.collections4.bidimap",
                "UnmodifiableBidiMap",
                "/**\n * Factory method to create an unmodifiable map.\n * <p>\n * If the map passed in is already unmodifiable, it is returned.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the map to decorate, must not be null\n * @return an unmodifiable BidiMap\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> BidiMap<K, V> unmodifiableBidiMap(final BidiMap<? extends K, ? extends V> map) {\n    if (map instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final BidiMap<K, V> tmpMap = (BidiMap<K, V>) map;\n        return tmpMap;\n    }\n    return new UnmodifiableBidiMap<K, V>(map);\n}"
            ],
            [
                "unmodifiableOrderedBidiMap",
                "org.apache.commons.collections4.bidimap",
                "UnmodifiableOrderedBidiMap",
                "/**\n * Factory method to create an unmodifiable map.\n * <p>\n * If the map passed in is already unmodifiable, it is returned.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the map to decorate, must not be null\n * @return an unmodifiable OrderedBidiMap\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> OrderedBidiMap<K, V> unmodifiableOrderedBidiMap(final OrderedBidiMap<? extends K, ? extends V> map) {\n    if (map instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final OrderedBidiMap<K, V> tmpMap = (OrderedBidiMap<K, V>) map;\n        return tmpMap;\n    }\n    return new UnmodifiableOrderedBidiMap<K, V>(map);\n}"
            ],
            [
                "unmodifiableSortedBidiMap",
                "org.apache.commons.collections4.bidimap",
                "UnmodifiableSortedBidiMap",
                "/**\n * Factory method to create an unmodifiable map.\n * <p>\n * If the map passed in is already unmodifiable, it is returned.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the map to decorate, must not be null\n * @return an unmodifiable SortedBidiMap\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> SortedBidiMap<K, V> unmodifiableSortedBidiMap(final SortedBidiMap<K, ? extends V> map) {\n    if (map instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final SortedBidiMap<K, V> tmpMap = (SortedBidiMap<K, V>) map;\n        return tmpMap;\n    }\n    return new UnmodifiableSortedBidiMap<K, V>(map);\n}"
            ],
            [
                "emptyMultiValuedMap",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "/**\n * Returns immutable EMPTY_MULTI_VALUED_MAP with generic type safety.\n *\n * @param <K> the type of key in the map\n * @param <V> the type of value in the map\n * @return immutable and empty <code>MultiValuedMap</code>\n */\n@SuppressWarnings(\"unchecked\")\npublic static <K, V> MultiValuedMap<K, V> emptyMultiValuedMap() {\n    return EMPTY_MULTI_VALUED_MAP;\n}"
            ],
            [
                "emptyIfNull",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "// Null safe methods\n/**\n * Returns an immutable empty <code>MultiValuedMap</code> if the argument is\n * <code>null</code>, or the argument itself otherwise.\n *\n * @param <K> the type of key in the map\n * @param <V> the type of value in the map\n * @param map  the map, may be null\n * @return an empty {@link MultiValuedMap} if the argument is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <K, V> MultiValuedMap<K, V> emptyIfNull(final MultiValuedMap<K, V> map) {\n    return map == null ? EMPTY_MULTI_VALUED_MAP : map;\n}"
            ],
            [
                "isEmpty",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "/**\n * Null-safe check if the specified <code>MultiValuedMap</code> is empty.\n * <p>\n * If the provided map is null, returns true.\n *\n * @param map  the map to check, may be null\n * @return true if the map is empty or null\n */\npublic static boolean isEmpty(final MultiValuedMap<?, ?> map) {\n    return map == null || map.isEmpty();\n}"
            ],
            [
                "getCollection",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "// Null safe getters\n// -------------------------------------------------------------------------\n/**\n * Gets a Collection from <code>MultiValuedMap</code> in a null-safe manner.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the {@link MultiValuedMap} to use\n * @param key  the key to look up\n * @return the Collection in the {@link MultiValuedMap}, or null if input map is null\n */\npublic static <K, V> Collection<V> getCollection(final MultiValuedMap<K, V> map, final K key) {\n    if (map != null) {\n        return map.get(key);\n    }\n    return null;\n}"
            ],
            [
                "getValuesAsList",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "// TODO: review the getValuesAsXXX methods - depending on the actual MultiValuedMap type, changes\n// to the returned collection might update the backing map. This should be clarified and/or prevented.\n/**\n * Gets a List from <code>MultiValuedMap</code> in a null-safe manner.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the {@link MultiValuedMap} to use\n * @param key  the key to look up\n * @return the Collection in the {@link MultiValuedMap} as List, or null if input map is null\n */\npublic static <K, V> List<V> getValuesAsList(final MultiValuedMap<K, V> map, final K key) {\n    if (map != null) {\n        Collection<V> col = map.get(key);\n        if (col instanceof List) {\n            return (List<V>) col;\n        }\n        return new ArrayList<V>(col);\n    }\n    return null;\n}"
            ],
            [
                "getValuesAsSet",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "/**\n * Gets a Set from <code>MultiValuedMap</code> in a null-safe manner.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the {@link MultiValuedMap} to use\n * @param key  the key to look up\n * @return the Collection in the {@link MultiValuedMap} as Set, or null if input map is null\n */\npublic static <K, V> Set<V> getValuesAsSet(final MultiValuedMap<K, V> map, final K key) {\n    if (map != null) {\n        Collection<V> col = map.get(key);\n        if (col instanceof Set) {\n            return (Set<V>) col;\n        }\n        return new HashSet<V>(col);\n    }\n    return null;\n}"
            ],
            [
                "getValuesAsBag",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "/**\n * Gets a Bag from <code>MultiValuedMap</code> in a null-safe manner.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the {@link MultiValuedMap} to use\n * @param key  the key to look up\n * @return the Collection in the {@link MultiValuedMap} as Bag, or null if input map is null\n */\npublic static <K, V> Bag<V> getValuesAsBag(final MultiValuedMap<K, V> map, final K key) {\n    if (map != null) {\n        Collection<V> col = map.get(key);\n        if (col instanceof Bag) {\n            return (Bag<V>) col;\n        }\n        return new HashBag<V>(col);\n    }\n    return null;\n}"
            ],
            [
                "newListValuedHashMap",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "// Factory Methods\n// -----------------------------------------------------------------------\n/**\n * Creates a {@link ListValuedMap} with an {@link java.util.ArrayList ArrayList} as\n * collection class to store the values mapped to a key.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @return a new <code>ListValuedMap</code>\n */\npublic static <K, V> ListValuedMap<K, V> newListValuedHashMap() {\n    return new ArrayListValuedHashMap<K, V>();\n}"
            ],
            [
                "newSetValuedHashMap",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "/**\n * Creates a {@link SetValuedMap} with an {@link java.util.HashSet HashSet} as\n * collection class to store the values mapped to a key.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @return a new {@link SetValuedMap}\n */\npublic static <K, V> SetValuedMap<K, V> newSetValuedHashMap() {\n    return new HashSetValuedHashMap<K, V>();\n}"
            ],
            [
                "unmodifiableMultiValuedMap",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "// MultiValuedMap Decorators\n// -----------------------------------------------------------------------\n/**\n * Returns an <code>UnmodifiableMultiValuedMap</code> backed by the given\n * map.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the {@link MultiValuedMap} to decorate, must not be null\n * @return an unmodifiable {@link MultiValuedMap} backed by the provided map\n * @throws NullPointerException if map is null\n */\npublic static <K, V> MultiValuedMap<K, V> unmodifiableMultiValuedMap(final MultiValuedMap<? extends K, ? extends V> map) {\n    return UnmodifiableMultiValuedMap.<K, V>unmodifiableMultiValuedMap(map);\n}"
            ],
            [
                "transformedMultiValuedMap",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "/**\n * Returns a <code>TransformedMultiValuedMap</code> backed by the given map.\n * <p>\n * This method returns a new <code>MultiValuedMap</code> (decorating the\n * specified map) that will transform any new entries added to it. Existing\n * entries in the specified map will not be transformed. If you want that\n * behaviour, see {@link TransformedMultiValuedMap#transformedMap}.\n * <p>\n * Each object is passed through the transformers as it is added to the Map.\n * It is important not to use the original map after invoking this method,\n * as it is a back door for adding untransformed objects.\n * <p>\n * If there are any elements already in the map being decorated, they are\n * NOT transformed.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the {@link MultiValuedMap} to transform, must not be null, typically empty\n * @param keyTransformer  the transformer for the map keys, null means no transformation\n * @param valueTransformer  the transformer for the map values, null means no transformation\n * @return a transformed <code>MultiValuedMap</code> backed by the given map\n * @throws NullPointerException if map is null\n */\npublic static <K, V> MultiValuedMap<K, V> transformedMultiValuedMap(final MultiValuedMap<K, V> map, final Transformer<? super K, ? extends K> keyTransformer, final Transformer<? super V, ? extends V> valueTransformer) {\n    return TransformedMultiValuedMap.transformingMap(map, keyTransformer, valueTransformer);\n}"
            ],
            [
                "unmodifiableBoundedCollection",
                "org.apache.commons.collections4.collection",
                "UnmodifiableBoundedCollection",
                "/**\n * Factory method to create an unmodifiable bounded collection.\n *\n * @param <E> the type of the elements in the collection\n * @param coll  the <code>BoundedCollection</code> to decorate, must not be null\n * @return a new unmodifiable bounded collection\n * @throws NullPointerException if {@code coll} is {@code null}\n * @since 4.0\n */\npublic static <E> BoundedCollection<E> unmodifiableBoundedCollection(final BoundedCollection<? extends E> coll) {\n    if (coll instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final BoundedCollection<E> tmpColl = (BoundedCollection<E>) coll;\n        return tmpColl;\n    }\n    return new UnmodifiableBoundedCollection<E>(coll);\n}"
            ],
            [
                "unmodifiableBoundedCollection",
                "org.apache.commons.collections4.collection",
                "UnmodifiableBoundedCollection",
                "/**\n * Factory method to create an unmodifiable bounded collection.\n * <p>\n * This method is capable of drilling down through up to 1000 other decorators\n * to find a suitable BoundedCollection.\n *\n * @param <E> the type of the elements in the collection\n * @param coll  the <code>BoundedCollection</code> to decorate, must not be null\n * @return a new unmodifiable bounded collection\n * @throws NullPointerException if coll is null\n * @throws IllegalArgumentException if coll is not a {@code BoundedCollection}\n * @since 4.0\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> BoundedCollection<E> unmodifiableBoundedCollection(Collection<? extends E> coll) {\n    if (coll == null) {\n        throw new NullPointerException(\"Collection must not be null.\");\n    }\n    // handle decorators\n    for (int i = 0; i < 1000; i++) {\n        // counter to prevent infinite looping\n        if (coll instanceof BoundedCollection) {\n            // normal loop exit\n            break;\n        }\n        if (coll instanceof AbstractCollectionDecorator) {\n            coll = ((AbstractCollectionDecorator<E>) coll).decorated();\n        } else if (coll instanceof SynchronizedCollection) {\n            coll = ((SynchronizedCollection<E>) coll).decorated();\n        }\n    }\n    if (coll instanceof BoundedCollection == false) {\n        throw new IllegalArgumentException(\"Collection is not a bounded collection.\");\n    }\n    return new UnmodifiableBoundedCollection<E>((BoundedCollection<E>) coll);\n}"
            ],
            [
                "transformingCollection",
                "org.apache.commons.collections4.collection",
                "TransformedCollection",
                "/**\n * Factory method to create a transforming collection.\n * <p>\n * If there are any elements already in the collection being decorated, they\n * are NOT transformed.\n * Contrast this with {@link #transformedCollection(Collection, Transformer)}.\n *\n * @param <E> the type of the elements in the collection\n * @param coll  the collection to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed collection\n * @throws NullPointerException if collection or transformer is null\n * @since 4.0\n */\npublic static <E> TransformedCollection<E> transformingCollection(final Collection<E> coll, final Transformer<? super E, ? extends E> transformer) {\n    return new TransformedCollection<E>(coll, transformer);\n}"
            ],
            [
                "transformedCollection",
                "org.apache.commons.collections4.collection",
                "TransformedCollection",
                "/**\n * Factory method to create a transforming collection that will transform\n * existing contents of the specified collection.\n * <p>\n * If there are any elements already in the collection being decorated, they\n * will be transformed by this method.\n * Contrast this with {@link #transformingCollection(Collection, Transformer)}.\n *\n * @param <E> the type of the elements in the collection\n * @param collection  the collection to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed Collection\n * @throws NullPointerException if collection or transformer is null\n * @since 4.0\n */\npublic static <E> TransformedCollection<E> transformedCollection(final Collection<E> collection, final Transformer<? super E, ? extends E> transformer) {\n    final TransformedCollection<E> decorated = new TransformedCollection<E>(collection, transformer);\n    // null collection & transformer are disallowed by the constructor call above\n    if (collection.size() > 0) {\n        // collection is of type E\n        @SuppressWarnings(\"unchecked\")\n        final E[] // NOPMD - false positive for generics\n        values = (E[]) collection.toArray();\n        collection.clear();\n        for (final E value : values) {\n            decorated.decorated().add(transformer.transform(value));\n        }\n    }\n    return decorated;\n}"
            ],
            [
                "builder",
                "org.apache.commons.collections4.collection",
                "PredicatedCollection",
                "/**\n * Returns a Builder with the given predicate.\n *\n * @param <E>  the element type\n * @param predicate  the predicate to use\n * @return a new Builder for predicated collections\n * @since 4.1\n */\npublic static <E> Builder<E> builder(final Predicate<? super E> predicate) {\n    return new Builder<E>(predicate);\n}"
            ],
            [
                "notNullBuilder",
                "org.apache.commons.collections4.collection",
                "PredicatedCollection",
                "/**\n * Returns a Builder with a NotNullPredicate.\n *\n * @param <E>  the element type\n * @return a new Builder for predicated collections that ignores null values.\n * @since 4.1\n */\npublic static <E> Builder<E> notNullBuilder() {\n    return new Builder<E>(NotNullPredicate.<E>notNullPredicate());\n}"
            ],
            [
                "predicatedCollection",
                "org.apache.commons.collections4.collection",
                "PredicatedCollection",
                "/**\n * Factory method to create a predicated (validating) collection.\n * <p>\n * If there are any elements already in the collection being decorated, they\n * are validated.\n *\n * @param <T> the type of the elements in the collection\n * @param coll  the collection to decorate, must not be null\n * @param predicate  the predicate to use for validation, must not be null\n * @return a new predicated collection\n * @throws NullPointerException if collection or predicate is null\n * @throws IllegalArgumentException if the collection contains invalid elements\n * @since 4.0\n */\npublic static <T> PredicatedCollection<T> predicatedCollection(final Collection<T> coll, final Predicate<? super T> predicate) {\n    return new PredicatedCollection<T>(coll, predicate);\n}"
            ],
            [
                "uniqueIndexedCollection",
                "org.apache.commons.collections4.collection",
                "IndexedCollection",
                "/**\n * Create an {@link IndexedCollection} for a unique index.\n * <p>\n * If an element is added, which maps to an existing key, an {@link IllegalArgumentException}\n * will be thrown.\n *\n * @param <K> the index object type.\n * @param <C> the collection type.\n * @param coll the decorated {@link Collection}.\n * @param keyTransformer the {@link Transformer} for generating index keys.\n * @return the created {@link IndexedCollection}.\n */\npublic static <K, C> IndexedCollection<K, C> uniqueIndexedCollection(final Collection<C> coll, final Transformer<C, K> keyTransformer) {\n    return new IndexedCollection<K, C>(coll, keyTransformer, MultiValueMap.<K, C>multiValueMap(new HashMap<K, Collection<C>>()), true);\n}"
            ],
            [
                "nonUniqueIndexedCollection",
                "org.apache.commons.collections4.collection",
                "IndexedCollection",
                "/**\n * Create an {@link IndexedCollection} for a non-unique index.\n *\n * @param <K> the index object type.\n * @param <C> the collection type.\n * @param coll the decorated {@link Collection}.\n * @param keyTransformer the {@link Transformer} for generating index keys.\n * @return the created {@link IndexedCollection}.\n */\npublic static <K, C> IndexedCollection<K, C> nonUniqueIndexedCollection(final Collection<C> coll, final Transformer<C, K> keyTransformer) {\n    return new IndexedCollection<K, C>(coll, keyTransformer, MultiValueMap.<K, C>multiValueMap(new HashMap<K, Collection<C>>()), false);\n}"
            ],
            [
                "synchronizedCollection",
                "org.apache.commons.collections4.collection",
                "SynchronizedCollection",
                "/**\n * Factory method to create a synchronized collection.\n *\n * @param <T> the type of the elements in the collection\n * @param coll  the collection to decorate, must not be null\n * @return a new synchronized collection\n * @throws NullPointerException if collection is null\n * @since 4.0\n */\npublic static <T> SynchronizedCollection<T> synchronizedCollection(final Collection<T> coll) {\n    return new SynchronizedCollection<T>(coll);\n}"
            ],
            [
                "unmodifiableCollection",
                "org.apache.commons.collections4.collection",
                "UnmodifiableCollection",
                "/**\n * Factory method to create an unmodifiable collection.\n * <p>\n * If the collection passed in is already unmodifiable, it is returned.\n *\n * @param <T> the type of the elements in the collection\n * @param coll  the collection to decorate, must not be null\n * @return an unmodifiable collection\n * @throws NullPointerException if collection is null\n * @since 4.0\n */\npublic static <T> Collection<T> unmodifiableCollection(final Collection<? extends T> coll) {\n    if (coll instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final Collection<T> tmpColl = (Collection<T>) coll;\n        return tmpColl;\n    }\n    return new UnmodifiableCollection<T>(coll);\n}"
            ],
            [
                "exceptionFactory",
                "org.apache.commons.collections4",
                "FactoryUtils",
                "/**\n * Gets a Factory that always throws an exception.\n * This could be useful during testing as a placeholder.\n *\n * @see org.apache.commons.collections4.functors.ExceptionFactory\n *\n * @param <T> the type that the factory creates\n * @return the factory\n */\npublic static <T> Factory<T> exceptionFactory() {\n    return ExceptionFactory.<T>exceptionFactory();\n}"
            ],
            [
                "nullFactory",
                "org.apache.commons.collections4",
                "FactoryUtils",
                "/**\n * Gets a Factory that will return null each time the factory is used.\n * This could be useful during testing as a placeholder.\n *\n * @see org.apache.commons.collections4.functors.ConstantFactory\n * @param <T> the \"type\" of null object the factory should return.\n * @return the factory\n */\npublic static <T> Factory<T> nullFactory() {\n    return ConstantFactory.<T>constantFactory(null);\n}"
            ],
            [
                "constantFactory",
                "org.apache.commons.collections4",
                "FactoryUtils",
                "/**\n * Creates a Factory that will return the same object each time the factory\n * is used. No check is made that the object is immutable. In general, only\n * immutable objects should use the constant factory. Mutable objects should\n * use the prototype factory.\n *\n * @see org.apache.commons.collections4.functors.ConstantFactory\n *\n * @param <T> the type that the factory creates\n * @param constantToReturn  the constant object to return each time in the factory\n * @return the <code>constant</code> factory.\n */\npublic static <T> Factory<T> constantFactory(final T constantToReturn) {\n    return ConstantFactory.constantFactory(constantToReturn);\n}"
            ],
            [
                "prototypeFactory",
                "org.apache.commons.collections4",
                "FactoryUtils",
                "/**\n * Creates a Factory that will return a clone of the same prototype object\n * each time the factory is used. The prototype will be cloned using one of these\n * techniques (in order):\n * <ul>\n * <li>public clone method\n * <li>public copy constructor\n * <li>serialization clone\n * <ul>\n *\n * @see org.apache.commons.collections4.functors.PrototypeFactory\n *\n * @param <T> the type that the factory creates\n * @param prototype  the object to clone each time in the factory\n * @return the <code>prototype</code> factory, or a {@link ConstantFactory#NULL_INSTANCE} if\n * the {@code prototype} is {@code null}\n * @throws IllegalArgumentException if the prototype cannot be cloned\n */\npublic static <T> Factory<T> prototypeFactory(final T prototype) {\n    return PrototypeFactory.<T>prototypeFactory(prototype);\n}"
            ],
            [
                "instantiateFactory",
                "org.apache.commons.collections4",
                "FactoryUtils",
                "/**\n * Creates a Factory that can create objects of a specific type using\n * a no-args constructor.\n *\n * @see org.apache.commons.collections4.functors.InstantiateFactory\n *\n * @param <T> the type that the factory creates\n * @param classToInstantiate  the Class to instantiate each time in the factory\n * @return the <code>reflection</code> factory\n * @throws NullPointerException if the classToInstantiate is null\n */\npublic static <T> Factory<T> instantiateFactory(final Class<T> classToInstantiate) {\n    return InstantiateFactory.instantiateFactory(classToInstantiate, null, null);\n}"
            ],
            [
                "instantiateFactory",
                "org.apache.commons.collections4",
                "FactoryUtils",
                "/**\n * Creates a Factory that can create objects of a specific type using\n * the arguments specified to this method.\n *\n * @see org.apache.commons.collections4.functors.InstantiateFactory\n *\n * @param <T> the type that the factory creates\n * @param classToInstantiate  the Class to instantiate each time in the factory\n * @param paramTypes  parameter types for the constructor, can be null\n * @param args  the arguments to pass to the constructor, can be null\n * @return the <code>reflection</code> factory\n * @throws NullPointerException if the classToInstantiate is null\n * @throws IllegalArgumentException if the paramTypes and args don't match\n * @throws IllegalArgumentException if the constructor doesn't exist\n */\npublic static <T> Factory<T> instantiateFactory(final Class<T> classToInstantiate, final Class<?>[] paramTypes, final Object[] args) {\n    return InstantiateFactory.instantiateFactory(classToInstantiate, paramTypes, args);\n}"
            ],
            [
                "emptyIfNull",
                "org.apache.commons.collections4",
                "ListUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns an immutable empty list if the argument is <code>null</code>,\n * or the argument itself otherwise.\n *\n * @param <T> the element type\n * @param list the list, possibly <code>null</code>\n * @return an empty list if the argument is <code>null</code>\n */\npublic static <T> List<T> emptyIfNull(final List<T> list) {\n    return list == null ? Collections.<T>emptyList() : list;\n}"
            ],
            [
                "defaultIfNull",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns either the passed in list, or if the list is {@code null},\n * the value of {@code defaultList}.\n *\n * @param <T> the element type\n * @param list  the list, possibly {@code null}\n * @param defaultList  the returned values if list is {@code null}\n * @return an empty list if the argument is <code>null</code>\n * @since 4.0\n */\npublic static <T> List<T> defaultIfNull(final List<T> list, final List<T> defaultList) {\n    return list == null ? defaultList : list;\n}"
            ],
            [
                "intersection",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns a new list containing all elements that are contained in\n * both given lists.\n *\n * @param <E> the element type\n * @param list1  the first list\n * @param list2  the second list\n * @return  the intersection of those two lists\n * @throws NullPointerException if either list is null\n */\npublic static <E> List<E> intersection(final List<? extends E> list1, final List<? extends E> list2) {\n    final List<E> result = new ArrayList<E>();\n    List<? extends E> smaller = list1;\n    List<? extends E> larger = list2;\n    if (list1.size() > list2.size()) {\n        smaller = list2;\n        larger = list1;\n    }\n    final HashSet<E> hashSet = new HashSet<E>(smaller);\n    for (final E e : larger) {\n        if (hashSet.contains(e)) {\n            result.add(e);\n            hashSet.remove(e);\n        }\n    }\n    return result;\n}"
            ],
            [
                "subtract",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Subtracts all elements in the second list from the first list,\n * placing the results in a new list.\n * <p>\n * This differs from {@link List#removeAll(Collection)} in that\n * cardinality is respected; if <Code>list1</Code> contains two\n * occurrences of <Code>null</Code> and <Code>list2</Code> only\n * contains one occurrence, then the returned list will still contain\n * one occurrence.\n *\n * @param <E> the element type\n * @param list1  the list to subtract from\n * @param list2  the list to subtract\n * @return a new list containing the results\n * @throws NullPointerException if either list is null\n */\npublic static <E> List<E> subtract(final List<E> list1, final List<? extends E> list2) {\n    final ArrayList<E> result = new ArrayList<E>();\n    final HashBag<E> bag = new HashBag<E>(list2);\n    for (final E e : list1) {\n        if (!bag.remove(e, 1)) {\n            result.add(e);\n        }\n    }\n    return result;\n}"
            ],
            [
                "sum",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns the sum of the given lists.  This is their intersection\n * subtracted from their union.\n *\n * @param <E> the element type\n * @param list1  the first list\n * @param list2  the second list\n * @return  a new list containing the sum of those lists\n * @throws NullPointerException if either list is null\n */\npublic static <E> List<E> sum(final List<? extends E> list1, final List<? extends E> list2) {\n    return subtract(union(list1, list2), intersection(list1, list2));\n}"
            ],
            [
                "union",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns a new list containing the second list appended to the\n * first list.  The {@link List#addAll(Collection)} operation is\n * used to append the two given lists into a new list.\n *\n * @param <E> the element type\n * @param list1  the first list\n * @param list2  the second list\n * @return a new list containing the union of those lists\n * @throws NullPointerException if either list is null\n */\npublic static <E> List<E> union(final List<? extends E> list1, final List<? extends E> list2) {\n    final ArrayList<E> result = new ArrayList<E>(list1);\n    result.addAll(list2);\n    return result;\n}"
            ],
            [
                "select",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Selects all elements from input collection which match the given\n * predicate into an output list.\n * <p>\n * A <code>null</code> predicate matches no elements.\n *\n * @param <E> the element type\n * @param inputCollection  the collection to get the input from, may not be null\n * @param predicate  the predicate to use, may be null\n * @return the elements matching the predicate (new list)\n * @throws NullPointerException if the input list is null\n *\n * @since 4.0\n * @see CollectionUtils#select(Iterable, Predicate)\n */\npublic static <E> List<E> select(final Collection<? extends E> inputCollection, final Predicate<? super E> predicate) {\n    return CollectionUtils.select(inputCollection, predicate, new ArrayList<E>(inputCollection.size()));\n}"
            ],
            [
                "selectRejected",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Selects all elements from inputCollection which don't match the given\n * predicate into an output collection.\n * <p>\n * If the input predicate is <code>null</code>, the result is an empty list.\n *\n * @param <E> the element type\n * @param inputCollection the collection to get the input from, may not be null\n * @param predicate the predicate to use, may be null\n * @return the elements <b>not</b> matching the predicate (new list)\n * @throws NullPointerException if the input collection is null\n *\n * @since 4.0\n * @see CollectionUtils#selectRejected(Iterable, Predicate)\n */\npublic static <E> List<E> selectRejected(final Collection<? extends E> inputCollection, final Predicate<? super E> predicate) {\n    return CollectionUtils.selectRejected(inputCollection, predicate, new ArrayList<E>(inputCollection.size()));\n}"
            ],
            [
                "isEqualList",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Tests two lists for value-equality as per the equality contract in\n * {@link java.util.List#equals(java.lang.Object)}.\n * <p>\n * This method is useful for implementing <code>List</code> when you cannot\n * extend AbstractList. The method takes Collection instances to enable other\n * collection types to use the List implementation algorithm.\n * <p>\n * The relevant text (slightly paraphrased as this is a static method) is:\n * <blockquote>\n * Compares the two list objects for equality.  Returns\n * {@code true} if and only if both\n * lists have the same size, and all corresponding pairs of elements in\n * the two lists are <i>equal</i>.  (Two elements {@code e1} and\n * {@code e2} are <i>equal</i> if <tt>(e1==null ? e2==null :\n * e1.equals(e2))</tt>.)  In other words, two lists are defined to be\n * equal if they contain the same elements in the same order.  This\n * definition ensures that the equals method works properly across\n * different implementations of the {@code List} interface.\n * </blockquote>\n *\n * <b>Note:</b> The behaviour of this method is undefined if the lists are\n * modified during the equals comparison.\n *\n * @see java.util.List\n * @param list1  the first list, may be null\n * @param list2  the second list, may be null\n * @return whether the lists are equal by value comparison\n */\npublic static boolean isEqualList(final Collection<?> list1, final Collection<?> list2) {\n    if (list1 == list2) {\n        return true;\n    }\n    if (list1 == null || list2 == null || list1.size() != list2.size()) {\n        return false;\n    }\n    final Iterator<?> it1 = list1.iterator();\n    final Iterator<?> it2 = list2.iterator();\n    Object obj1 = null;\n    Object obj2 = null;\n    while (it1.hasNext() && it2.hasNext()) {\n        obj1 = it1.next();\n        obj2 = it2.next();\n        if (!(obj1 == null ? obj2 == null : obj1.equals(obj2))) {\n            return false;\n        }\n    }\n    return !(it1.hasNext() || it2.hasNext());\n}"
            ],
            [
                "hashCodeForList",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Generates a hash code using the algorithm specified in\n * {@link java.util.List#hashCode()}.\n * <p>\n * This method is useful for implementing <code>List</code> when you cannot\n * extend AbstractList. The method takes Collection instances to enable other\n * collection types to use the List implementation algorithm.\n *\n * @see java.util.List#hashCode()\n * @param list  the list to generate the hashCode for, may be null\n * @return the hash code\n */\npublic static int hashCodeForList(final Collection<?> list) {\n    if (list == null) {\n        return 0;\n    }\n    int hashCode = 1;\n    final Iterator<?> it = list.iterator();\n    while (it.hasNext()) {\n        final Object obj = it.next();\n        hashCode = 31 * hashCode + (obj == null ? 0 : obj.hashCode());\n    }\n    return hashCode;\n}"
            ],
            [
                "retainAll",
                "org.apache.commons.collections4",
                "ListUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns a List containing all the elements in <code>collection</code>\n * that are also in <code>retain</code>. The cardinality of an element <code>e</code>\n * in the returned list is the same as the cardinality of <code>e</code>\n * in <code>collection</code> unless <code>retain</code> does not contain <code>e</code>, in which\n * case the cardinality is zero. This method is useful if you do not wish to modify\n * the collection <code>c</code> and thus cannot call <code>collection.retainAll(retain);</code>.\n * <p>\n * This implementation iterates over <code>collection</code>, checking each element in\n * turn to see if it's contained in <code>retain</code>. If it's contained, it's added\n * to the returned list. As a consequence, it is advised to use a collection type for\n * <code>retain</code> that provides a fast (e.g. O(1)) implementation of\n * {@link Collection#contains(Object)}.\n *\n * @param <E>  the element type\n * @param collection  the collection whose contents are the target of the #retailAll operation\n * @param retain  the collection containing the elements to be retained in the returned collection\n * @return a <code>List</code> containing all the elements of <code>c</code>\n * that occur at least once in <code>retain</code>.\n * @throws NullPointerException if either parameter is null\n * @since 3.2\n */\npublic static <E> List<E> retainAll(final Collection<E> collection, final Collection<?> retain) {\n    final List<E> list = new ArrayList<E>(Math.min(collection.size(), retain.size()));\n    for (final E obj : collection) {\n        if (retain.contains(obj)) {\n            list.add(obj);\n        }\n    }\n    return list;\n}"
            ],
            [
                "removeAll",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Removes the elements in <code>remove</code> from <code>collection</code>. That is, this\n * method returns a list containing all the elements in <code>collection</code>\n * that are not in <code>remove</code>. The cardinality of an element <code>e</code>\n * in the returned collection is the same as the cardinality of <code>e</code>\n * in <code>collection</code> unless <code>remove</code> contains <code>e</code>, in which\n * case the cardinality is zero. This method is useful if you do not wish to modify\n * <code>collection</code> and thus cannot call <code>collection.removeAll(remove);</code>.\n * <p>\n * This implementation iterates over <code>collection</code>, checking each element in\n * turn to see if it's contained in <code>remove</code>. If it's not contained, it's added\n * to the returned list. As a consequence, it is advised to use a collection type for\n * <code>remove</code> that provides a fast (e.g. O(1)) implementation of\n * {@link Collection#contains(Object)}.\n *\n * @param <E>  the element type\n * @param collection  the collection from which items are removed (in the returned collection)\n * @param remove  the items to be removed from the returned <code>collection</code>\n * @return a <code>List</code> containing all the elements of <code>c</code> except\n * any elements that also occur in <code>remove</code>.\n * @throws NullPointerException if either parameter is null\n * @since 3.2\n */\npublic static <E> List<E> removeAll(final Collection<E> collection, final Collection<?> remove) {\n    final List<E> list = new ArrayList<E>();\n    for (final E obj : collection) {\n        if (!remove.contains(obj)) {\n            list.add(obj);\n        }\n    }\n    return list;\n}"
            ],
            [
                "synchronizedList",
                "org.apache.commons.collections4",
                "ListUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns a synchronized list backed by the given list.\n * <p>\n * You must manually synchronize on the returned list's iterator to\n * avoid non-deterministic behavior:\n *\n * <pre>\n * List list = ListUtils.synchronizedList(myList);\n * synchronized (list) {\n *     Iterator i = list.iterator();\n *     while (i.hasNext()) {\n *         process (i.next());\n *     }\n * }\n * </pre>\n *\n * This method is just a wrapper for {@link Collections#synchronizedList(List)}.\n *\n * @param <E> the element type\n * @param list  the list to synchronize, must not be null\n * @return a synchronized list backed by the given list\n * @throws NullPointerException if the list is null\n */\npublic static <E> List<E> synchronizedList(final List<E> list) {\n    return Collections.synchronizedList(list);\n}"
            ],
            [
                "unmodifiableList",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns an unmodifiable list backed by the given list.\n * <p>\n * This method uses the implementation in the decorators subpackage.\n *\n * @param <E>  the element type\n * @param list  the list to make unmodifiable, must not be null\n * @return an unmodifiable list backed by the given list\n * @throws NullPointerException if the list is null\n */\npublic static <E> List<E> unmodifiableList(final List<? extends E> list) {\n    return UnmodifiableList.unmodifiableList(list);\n}"
            ],
            [
                "predicatedList",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns a predicated (validating) list backed by the given list.\n * <p>\n * Only objects that pass the test in the given predicate can be added to the list.\n * Trying to add an invalid object results in an IllegalArgumentException.\n * It is important not to use the original list after invoking this method,\n * as it is a backdoor for adding invalid objects.\n *\n * @param <E> the element type\n * @param list  the list to predicate, must not be null\n * @param predicate  the predicate for the list, must not be null\n * @return a predicated list backed by the given list\n * @throws NullPointerException if the List or Predicate is null\n */\npublic static <E> List<E> predicatedList(final List<E> list, final Predicate<E> predicate) {\n    return PredicatedList.predicatedList(list, predicate);\n}"
            ],
            [
                "transformedList",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns a transformed list backed by the given list.\n * <p>\n * This method returns a new list (decorating the specified list) that\n * will transform any new entries added to it.\n * Existing entries in the specified list will not be transformed.\n * <p>\n * Each object is passed through the transformer as it is added to the\n * List. It is important not to use the original list after invoking this\n * method, as it is a backdoor for adding untransformed objects.\n * <p>\n * Existing entries in the specified list will not be transformed.\n * If you want that behaviour, see {@link TransformedList#transformedList}.\n *\n * @param <E> the element type\n * @param list  the list to predicate, must not be null\n * @param transformer  the transformer for the list, must not be null\n * @return a transformed list backed by the given list\n * @throws NullPointerException if the List or Transformer is null\n */\npublic static <E> List<E> transformedList(final List<E> list, final Transformer<? super E, ? extends E> transformer) {\n    return TransformedList.transformingList(list, transformer);\n}"
            ],
            [
                "lazyList",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns a \"lazy\" list whose elements will be created on demand.\n * <p>\n * When the index passed to the returned list's {@link List#get(int) get}\n * method is greater than the list's size, then the factory will be used\n * to create a new object and that object will be inserted at that index.\n * <p>\n * For instance:\n *\n * <pre>\n * Factory&lt;Date&gt; factory = new Factory&lt;Date&gt;() {\n *     public Date create() {\n *         return new Date();\n *     }\n * }\n * List&lt;Date&gt; lazy = ListUtils.lazyList(new ArrayList&lt;Date&gt;(), factory);\n * Date date = lazy.get(3);\n * </pre>\n *\n * After the above code is executed, <code>date</code> will refer to\n * a new <code>Date</code> instance.  Furthermore, that <code>Date</code>\n * instance is the fourth element in the list.  The first, second,\n * and third element are all set to <code>null</code>.\n *\n * @param <E> the element type\n * @param list  the list to make lazy, must not be null\n * @param factory  the factory for creating new objects, must not be null\n * @return a lazy list backed by the given list\n * @throws NullPointerException if the List or Factory is null\n */\npublic static <E> List<E> lazyList(final List<E> list, final Factory<? extends E> factory) {\n    return LazyList.lazyList(list, factory);\n}"
            ],
            [
                "fixedSizeList",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns a fixed-sized list backed by the given list.\n * Elements may not be added or removed from the returned list, but\n * existing elements can be changed (for instance, via the\n * {@link List#set(int, Object)} method).\n *\n * @param <E>  the element type\n * @param list  the list whose size to fix, must not be null\n * @return a fixed-size list backed by that list\n * @throws NullPointerException  if the List is null\n */\npublic static <E> List<E> fixedSizeList(final List<E> list) {\n    return FixedSizeList.fixedSizeList(list);\n}"
            ],
            [
                "indexOf",
                "org.apache.commons.collections4",
                "ListUtils",
                "//-----------------------------------------------------------------------\n/**\n * Finds the first index in the given List which matches the given predicate.\n * <p>\n * If the input List or predicate is null, or no element of the List\n * matches the predicate, -1 is returned.\n *\n * @param <E>  the element type\n * @param list the List to search, may be null\n * @param predicate  the predicate to use, may be null\n * @return the first index of an Object in the List which matches the predicate or -1 if none could be found\n */\npublic static <E> int indexOf(final List<E> list, final Predicate<E> predicate) {\n    if (list != null && predicate != null) {\n        for (int i = 0; i < list.size(); i++) {\n            final E item = list.get(i);\n            if (predicate.evaluate(item)) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}"
            ],
            [
                "longestCommonSubsequence",
                "org.apache.commons.collections4",
                "ListUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns the longest common subsequence (LCS) of two sequences (lists).\n *\n * @param <E>  the element type\n * @param a  the first list\n * @param b  the second list\n * @return the longest common subsequence\n * @throws NullPointerException if either list is {@code null}\n * @since 4.0\n */\npublic static <E> List<E> longestCommonSubsequence(final List<E> a, final List<E> b) {\n    return longestCommonSubsequence(a, b, DefaultEquator.defaultEquator());\n}"
            ],
            [
                "longestCommonSubsequence",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns the longest common subsequence (LCS) of two sequences (lists).\n *\n * @param <E>  the element type\n * @param a  the first list\n * @param b  the second list\n * @param equator  the equator used to test object equality\n * @return the longest common subsequence\n * @throws NullPointerException if either list or the equator is {@code null}\n * @since 4.0\n */\npublic static <E> List<E> longestCommonSubsequence(final List<E> a, final List<E> b, final Equator<? super E> equator) {\n    if (a == null || b == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (equator == null) {\n        throw new NullPointerException(\"Equator must not be null\");\n    }\n    final SequencesComparator<E> comparator = new SequencesComparator<E>(a, b, equator);\n    final EditScript<E> script = comparator.getScript();\n    final LcsVisitor<E> visitor = new LcsVisitor<E>();\n    script.visit(visitor);\n    return visitor.getSubSequence();\n}"
            ],
            [
                "longestCommonSubsequence",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns the longest common subsequence (LCS) of two {@link CharSequence} objects.\n * <p>\n * This is a convenience method for using {@link #longestCommonSubsequence(List, List)}\n * with {@link CharSequence} instances.\n *\n * @param a  the first sequence\n * @param b  the second sequence\n * @return the longest common subsequence as {@link String}\n * @throws NullPointerException if either sequence is {@code null}\n * @since 4.0\n */\npublic static String longestCommonSubsequence(final CharSequence a, final CharSequence b) {\n    if (a == null || b == null) {\n        throw new NullPointerException(\"CharSequence must not be null\");\n    }\n    final List<Character> lcs = longestCommonSubsequence(new CharSequenceAsList(a), new CharSequenceAsList(b));\n    final StringBuilder sb = new StringBuilder();\n    for (Character ch : lcs) {\n        sb.append(ch);\n    }\n    return sb.toString();\n}"
            ],
            [
                "partition",
                "org.apache.commons.collections4",
                "ListUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns consecutive {@link List#subList(int, int) sublists} of a\n * list, each of the same size (the final list may be smaller). For example,\n * partitioning a list containing {@code [a, b, c, d, e]} with a partition\n * size of 3 yields {@code [[a, b, c], [d, e]]} -- an outer list containing\n * two inner lists of three and two elements, all in the original order.\n * <p>\n * The outer list is unmodifiable, but reflects the latest state of the\n * source list. The inner lists are sublist views of the original list,\n * produced on demand using {@link List#subList(int, int)}, and are subject\n * to all the usual caveats about modification as explained in that API.\n * <p>\n * Adapted from http://code.google.com/p/guava-libraries/\n *\n * @param <T> the element type\n * @param list  the list to return consecutive sublists of\n * @param size  the desired size of each sublist (the last may be smaller)\n * @return a list of consecutive sublists\n * @throws NullPointerException if list is null\n * @throws IllegalArgumentException if size is not strictly positive\n * @since 4.0\n */\npublic static <T> List<List<T>> partition(final List<T> list, final int size) {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (size <= 0) {\n        throw new IllegalArgumentException(\"Size must be greater than 0\");\n    }\n    return new Partition<T>(list, size);\n}"
            ],
            [
                "getObject",
                "org.apache.commons.collections4",
                "MapUtils",
                "// Type safe getters\n//-------------------------------------------------------------------------\n/**\n * Gets from a Map in a null-safe manner.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map, <code>null</code> if null map input\n */\npublic static <K, V> V getObject(final Map<? super K, V> map, final K key) {\n    if (map != null) {\n        return map.get(key);\n    }\n    return null;\n}"
            ],
            [
                "getString",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a String from a Map in a null-safe manner.\n * <p>\n * The String is obtained via <code>toString</code>.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a String, <code>null</code> if null map input\n */\npublic static <K> String getString(final Map<? super K, ?> map, final K key) {\n    if (map != null) {\n        final Object answer = map.get(key);\n        if (answer != null) {\n            return answer.toString();\n        }\n    }\n    return null;\n}"
            ],
            [
                "getBoolean",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a Boolean from a Map in a null-safe manner.\n * <p>\n * If the value is a <code>Boolean</code> it is returned directly.\n * If the value is a <code>String</code> and it equals 'true' ignoring case\n * then <code>true</code> is returned, otherwise <code>false</code>.\n * If the value is a <code>Number</code> an integer zero value returns\n * <code>false</code> and non-zero returns <code>true</code>.\n * Otherwise, <code>null</code> is returned.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a Boolean, <code>null</code> if null map input\n */\npublic static <K> Boolean getBoolean(final Map<? super K, ?> map, final K key) {\n    if (map != null) {\n        final Object answer = map.get(key);\n        if (answer != null) {\n            if (answer instanceof Boolean) {\n                return (Boolean) answer;\n            }\n            if (answer instanceof String) {\n                return Boolean.valueOf((String) answer);\n            }\n            if (answer instanceof Number) {\n                final Number n = (Number) answer;\n                return n.intValue() != 0 ? Boolean.TRUE : Boolean.FALSE;\n            }\n        }\n    }\n    return null;\n}"
            ],
            [
                "getNumber",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a Number from a Map in a null-safe manner.\n * <p>\n * If the value is a <code>Number</code> it is returned directly.\n * If the value is a <code>String</code> it is converted using\n * {@link NumberFormat#parse(String)} on the system default formatter\n * returning <code>null</code> if the conversion fails.\n * Otherwise, <code>null</code> is returned.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a Number, <code>null</code> if null map input\n */\npublic static <K> Number getNumber(final Map<? super K, ?> map, final K key) {\n    if (map != null) {\n        final Object answer = map.get(key);\n        if (answer != null) {\n            if (answer instanceof Number) {\n                return (Number) answer;\n            }\n            if (answer instanceof String) {\n                try {\n                    final String text = (String) answer;\n                    return NumberFormat.getInstance().parse(text);\n                } catch (final ParseException e) {\n                    // NOPMD\n                    // failure means null is returned\n                }\n            }\n        }\n    }\n    return null;\n}"
            ],
            [
                "getByte",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a Byte from a Map in a null-safe manner.\n * <p>\n * The Byte is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a Byte, <code>null</code> if null map input\n */\npublic static <K> Byte getByte(final Map<? super K, ?> map, final K key) {\n    final Number answer = getNumber(map, key);\n    if (answer == null) {\n        return null;\n    }\n    if (answer instanceof Byte) {\n        return (Byte) answer;\n    }\n    return Byte.valueOf(answer.byteValue());\n}"
            ],
            [
                "getShort",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a Short from a Map in a null-safe manner.\n * <p>\n * The Short is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a Short, <code>null</code> if null map input\n */\npublic static <K> Short getShort(final Map<? super K, ?> map, final K key) {\n    final Number answer = getNumber(map, key);\n    if (answer == null) {\n        return null;\n    }\n    if (answer instanceof Short) {\n        return (Short) answer;\n    }\n    return Short.valueOf(answer.shortValue());\n}"
            ],
            [
                "getInteger",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a Integer from a Map in a null-safe manner.\n * <p>\n * The Integer is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a Integer, <code>null</code> if null map input\n */\npublic static <K> Integer getInteger(final Map<? super K, ?> map, final K key) {\n    final Number answer = getNumber(map, key);\n    if (answer == null) {\n        return null;\n    }\n    if (answer instanceof Integer) {\n        return (Integer) answer;\n    }\n    return Integer.valueOf(answer.intValue());\n}"
            ],
            [
                "getLong",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a Long from a Map in a null-safe manner.\n * <p>\n * The Long is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a Long, <code>null</code> if null map input\n */\npublic static <K> Long getLong(final Map<? super K, ?> map, final K key) {\n    final Number answer = getNumber(map, key);\n    if (answer == null) {\n        return null;\n    }\n    if (answer instanceof Long) {\n        return (Long) answer;\n    }\n    return Long.valueOf(answer.longValue());\n}"
            ],
            [
                "getFloat",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a Float from a Map in a null-safe manner.\n * <p>\n * The Float is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a Float, <code>null</code> if null map input\n */\npublic static <K> Float getFloat(final Map<? super K, ?> map, final K key) {\n    final Number answer = getNumber(map, key);\n    if (answer == null) {\n        return null;\n    }\n    if (answer instanceof Float) {\n        return (Float) answer;\n    }\n    return Float.valueOf(answer.floatValue());\n}"
            ],
            [
                "getDouble",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a Double from a Map in a null-safe manner.\n * <p>\n * The Double is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a Double, <code>null</code> if null map input\n */\npublic static <K> Double getDouble(final Map<? super K, ?> map, final K key) {\n    final Number answer = getNumber(map, key);\n    if (answer == null) {\n        return null;\n    }\n    if (answer instanceof Double) {\n        return (Double) answer;\n    }\n    return Double.valueOf(answer.doubleValue());\n}"
            ],
            [
                "getMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a Map from a Map in a null-safe manner.\n * <p>\n * If the value returned from the specified map is not a Map then\n * <code>null</code> is returned.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a Map, <code>null</code> if null map input\n */\npublic static <K> Map<?, ?> getMap(final Map<? super K, ?> map, final K key) {\n    if (map != null) {\n        final Object answer = map.get(key);\n        if (answer != null && answer instanceof Map) {\n            return (Map<?, ?>) answer;\n        }\n    }\n    return null;\n}"
            ],
            [
                "getObject",
                "org.apache.commons.collections4",
                "MapUtils",
                "// Type safe getters with default values\n//-------------------------------------------------------------------------\n/**\n * Looks up the given key in the given map, converting null into the\n * given default value.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null\n * @return  the value in the map, or defaultValue if the original value\n *   is null or the map is null\n */\npublic static <K, V> V getObject(final Map<K, V> map, final K key, final V defaultValue) {\n    if (map != null) {\n        final V answer = map.get(key);\n        if (answer != null) {\n            return answer;\n        }\n    }\n    return defaultValue;\n}"
            ],
            [
                "getString",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Looks up the given key in the given map, converting the result into\n * a string, using the default value if the the conversion fails.\n *\n * @param <K>  the key type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null or if the\n *   conversion fails\n * @return  the value in the map as a string, or defaultValue if the\n *   original value is null, the map is null or the string conversion fails\n */\npublic static <K> String getString(final Map<? super K, ?> map, final K key, final String defaultValue) {\n    String answer = getString(map, key);\n    if (answer == null) {\n        answer = defaultValue;\n    }\n    return answer;\n}"
            ],
            [
                "getBoolean",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Looks up the given key in the given map, converting the result into\n * a boolean, using the default value if the the conversion fails.\n *\n * @param <K>  the key type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null or if the\n *   conversion fails\n * @return  the value in the map as a boolean, or defaultValue if the\n *   original value is null, the map is null or the boolean conversion fails\n */\npublic static <K> Boolean getBoolean(final Map<? super K, ?> map, final K key, final Boolean defaultValue) {\n    Boolean answer = getBoolean(map, key);\n    if (answer == null) {\n        answer = defaultValue;\n    }\n    return answer;\n}"
            ],
            [
                "getNumber",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Looks up the given key in the given map, converting the result into\n * a number, using the default value if the the conversion fails.\n *\n * @param <K>  the key type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null or if the\n *   conversion fails\n * @return  the value in the map as a number, or defaultValue if the\n *   original value is null, the map is null or the number conversion fails\n */\npublic static <K> Number getNumber(final Map<? super K, ?> map, final K key, final Number defaultValue) {\n    Number answer = getNumber(map, key);\n    if (answer == null) {\n        answer = defaultValue;\n    }\n    return answer;\n}"
            ],
            [
                "getByte",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Looks up the given key in the given map, converting the result into\n * a byte, using the default value if the the conversion fails.\n *\n * @param <K>  the key type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null or if the\n *   conversion fails\n * @return  the value in the map as a number, or defaultValue if the\n *   original value is null, the map is null or the number conversion fails\n */\npublic static <K> Byte getByte(final Map<? super K, ?> map, final K key, final Byte defaultValue) {\n    Byte answer = getByte(map, key);\n    if (answer == null) {\n        answer = defaultValue;\n    }\n    return answer;\n}"
            ],
            [
                "getShort",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Looks up the given key in the given map, converting the result into\n * a short, using the default value if the the conversion fails.\n *\n * @param <K>  the key type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null or if the\n *   conversion fails\n * @return  the value in the map as a number, or defaultValue if the\n *   original value is null, the map is null or the number conversion fails\n */\npublic static <K> Short getShort(final Map<? super K, ?> map, final K key, final Short defaultValue) {\n    Short answer = getShort(map, key);\n    if (answer == null) {\n        answer = defaultValue;\n    }\n    return answer;\n}"
            ],
            [
                "getInteger",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Looks up the given key in the given map, converting the result into\n * an integer, using the default value if the the conversion fails.\n *\n * @param <K>  the key type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null or if the\n *   conversion fails\n * @return  the value in the map as a number, or defaultValue if the\n *   original value is null, the map is null or the number conversion fails\n */\npublic static <K> Integer getInteger(final Map<? super K, ?> map, final K key, final Integer defaultValue) {\n    Integer answer = getInteger(map, key);\n    if (answer == null) {\n        answer = defaultValue;\n    }\n    return answer;\n}"
            ],
            [
                "getLong",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Looks up the given key in the given map, converting the result into\n * a long, using the default value if the the conversion fails.\n *\n * @param <K>  the key type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null or if the\n *   conversion fails\n * @return  the value in the map as a number, or defaultValue if the\n *   original value is null, the map is null or the number conversion fails\n */\npublic static <K> Long getLong(final Map<? super K, ?> map, final K key, final Long defaultValue) {\n    Long answer = getLong(map, key);\n    if (answer == null) {\n        answer = defaultValue;\n    }\n    return answer;\n}"
            ],
            [
                "getFloat",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Looks up the given key in the given map, converting the result into\n * a float, using the default value if the the conversion fails.\n *\n * @param <K>  the key type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null or if the\n *   conversion fails\n * @return  the value in the map as a number, or defaultValue if the\n *   original value is null, the map is null or the number conversion fails\n */\npublic static <K> Float getFloat(final Map<? super K, ?> map, final K key, final Float defaultValue) {\n    Float answer = getFloat(map, key);\n    if (answer == null) {\n        answer = defaultValue;\n    }\n    return answer;\n}"
            ],
            [
                "getDouble",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Looks up the given key in the given map, converting the result into\n * a double, using the default value if the the conversion fails.\n *\n * @param <K>  the key type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null or if the\n *   conversion fails\n * @return  the value in the map as a number, or defaultValue if the\n *   original value is null, the map is null or the number conversion fails\n */\npublic static <K> Double getDouble(final Map<? super K, ?> map, final K key, final Double defaultValue) {\n    Double answer = getDouble(map, key);\n    if (answer == null) {\n        answer = defaultValue;\n    }\n    return answer;\n}"
            ],
            [
                "getMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Looks up the given key in the given map, converting the result into\n * a map, using the default value if the the conversion fails.\n *\n * @param <K>  the key type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null or if the\n *   conversion fails\n * @return  the value in the map as a number, or defaultValue if the\n *   original value is null, the map is null or the map conversion fails\n */\npublic static <K> Map<?, ?> getMap(final Map<? super K, ?> map, final K key, final Map<?, ?> defaultValue) {\n    Map<?, ?> answer = getMap(map, key);\n    if (answer == null) {\n        answer = defaultValue;\n    }\n    return answer;\n}"
            ],
            [
                "getBooleanValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "// Type safe primitive getters\n//-------------------------------------------------------------------------\n/**\n * Gets a boolean from a Map in a null-safe manner.\n * <p>\n * If the value is a <code>Boolean</code> its value is returned.\n * If the value is a <code>String</code> and it equals 'true' ignoring case\n * then <code>true</code> is returned, otherwise <code>false</code>.\n * If the value is a <code>Number</code> an integer zero value returns\n * <code>false</code> and non-zero returns <code>true</code>.\n * Otherwise, <code>false</code> is returned.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a Boolean, <code>false</code> if null map input\n */\npublic static <K> boolean getBooleanValue(final Map<? super K, ?> map, final K key) {\n    return Boolean.TRUE.equals(getBoolean(map, key));\n}"
            ],
            [
                "getByteValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a byte from a Map in a null-safe manner.\n * <p>\n * The byte is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a byte, <code>0</code> if null map input\n */\npublic static <K> byte getByteValue(final Map<? super K, ?> map, final K key) {\n    final Byte byteObject = getByte(map, key);\n    if (byteObject == null) {\n        return 0;\n    }\n    return byteObject.byteValue();\n}"
            ],
            [
                "getShortValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a short from a Map in a null-safe manner.\n * <p>\n * The short is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a short, <code>0</code> if null map input\n */\npublic static <K> short getShortValue(final Map<? super K, ?> map, final K key) {\n    final Short shortObject = getShort(map, key);\n    if (shortObject == null) {\n        return 0;\n    }\n    return shortObject.shortValue();\n}"
            ],
            [
                "getIntValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets an int from a Map in a null-safe manner.\n * <p>\n * The int is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as an int, <code>0</code> if null map input\n */\npublic static <K> int getIntValue(final Map<? super K, ?> map, final K key) {\n    final Integer integerObject = getInteger(map, key);\n    if (integerObject == null) {\n        return 0;\n    }\n    return integerObject.intValue();\n}"
            ],
            [
                "getLongValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a long from a Map in a null-safe manner.\n * <p>\n * The long is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a long, <code>0L</code> if null map input\n */\npublic static <K> long getLongValue(final Map<? super K, ?> map, final K key) {\n    final Long longObject = getLong(map, key);\n    if (longObject == null) {\n        return 0L;\n    }\n    return longObject.longValue();\n}"
            ],
            [
                "getFloatValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a float from a Map in a null-safe manner.\n * <p>\n * The float is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a float, <code>0.0F</code> if null map input\n */\npublic static <K> float getFloatValue(final Map<? super K, ?> map, final K key) {\n    final Float floatObject = getFloat(map, key);\n    if (floatObject == null) {\n        return 0f;\n    }\n    return floatObject.floatValue();\n}"
            ],
            [
                "getDoubleValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a double from a Map in a null-safe manner.\n * <p>\n * The double is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a double, <code>0.0</code> if null map input\n */\npublic static <K> double getDoubleValue(final Map<? super K, ?> map, final K key) {\n    final Double doubleObject = getDouble(map, key);\n    if (doubleObject == null) {\n        return 0d;\n    }\n    return doubleObject.doubleValue();\n}"
            ],
            [
                "getBooleanValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "// Type safe primitive getters with default values\n//-------------------------------------------------------------------------\n/**\n * Gets a boolean from a Map in a null-safe manner,\n * using the default value if the the conversion fails.\n * <p>\n * If the value is a <code>Boolean</code> its value is returned.\n * If the value is a <code>String</code> and it equals 'true' ignoring case\n * then <code>true</code> is returned, otherwise <code>false</code>.\n * If the value is a <code>Number</code> an integer zero value returns\n * <code>false</code> and non-zero returns <code>true</code>.\n * Otherwise, <code>defaultValue</code> is returned.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @param defaultValue  return if the value is null or if the conversion fails\n * @return the value in the Map as a Boolean, <code>defaultValue</code> if null map input\n */\npublic static <K> boolean getBooleanValue(final Map<? super K, ?> map, final K key, final boolean defaultValue) {\n    final Boolean booleanObject = getBoolean(map, key);\n    if (booleanObject == null) {\n        return defaultValue;\n    }\n    return booleanObject.booleanValue();\n}"
            ],
            [
                "getByteValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a byte from a Map in a null-safe manner,\n * using the default value if the the conversion fails.\n * <p>\n * The byte is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @param defaultValue  return if the value is null or if the conversion fails\n * @return the value in the Map as a byte, <code>defaultValue</code> if null map input\n */\npublic static <K> byte getByteValue(final Map<? super K, ?> map, final K key, final byte defaultValue) {\n    final Byte byteObject = getByte(map, key);\n    if (byteObject == null) {\n        return defaultValue;\n    }\n    return byteObject.byteValue();\n}"
            ],
            [
                "getShortValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a short from a Map in a null-safe manner,\n * using the default value if the the conversion fails.\n * <p>\n * The short is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @param defaultValue  return if the value is null or if the conversion fails\n * @return the value in the Map as a short, <code>defaultValue</code> if null map input\n */\npublic static <K> short getShortValue(final Map<? super K, ?> map, final K key, final short defaultValue) {\n    final Short shortObject = getShort(map, key);\n    if (shortObject == null) {\n        return defaultValue;\n    }\n    return shortObject.shortValue();\n}"
            ],
            [
                "getIntValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets an int from a Map in a null-safe manner,\n * using the default value if the the conversion fails.\n * <p>\n * The int is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @param defaultValue  return if the value is null or if the conversion fails\n * @return the value in the Map as an int, <code>defaultValue</code> if null map input\n */\npublic static <K> int getIntValue(final Map<? super K, ?> map, final K key, final int defaultValue) {\n    final Integer integerObject = getInteger(map, key);\n    if (integerObject == null) {\n        return defaultValue;\n    }\n    return integerObject.intValue();\n}"
            ],
            [
                "getLongValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a long from a Map in a null-safe manner,\n * using the default value if the the conversion fails.\n * <p>\n * The long is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @param defaultValue  return if the value is null or if the conversion fails\n * @return the value in the Map as a long, <code>defaultValue</code> if null map input\n */\npublic static <K> long getLongValue(final Map<? super K, ?> map, final K key, final long defaultValue) {\n    final Long longObject = getLong(map, key);\n    if (longObject == null) {\n        return defaultValue;\n    }\n    return longObject.longValue();\n}"
            ],
            [
                "getFloatValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a float from a Map in a null-safe manner,\n * using the default value if the the conversion fails.\n * <p>\n * The float is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @param defaultValue  return if the value is null or if the conversion fails\n * @return the value in the Map as a float, <code>defaultValue</code> if null map input\n */\npublic static <K> float getFloatValue(final Map<? super K, ?> map, final K key, final float defaultValue) {\n    final Float floatObject = getFloat(map, key);\n    if (floatObject == null) {\n        return defaultValue;\n    }\n    return floatObject.floatValue();\n}"
            ],
            [
                "getDoubleValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a double from a Map in a null-safe manner,\n * using the default value if the the conversion fails.\n * <p>\n * The double is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @param defaultValue  return if the value is null or if the conversion fails\n * @return the value in the Map as a double, <code>defaultValue</code> if null map input\n */\npublic static <K> double getDoubleValue(final Map<? super K, ?> map, final K key, final double defaultValue) {\n    final Double doubleObject = getDouble(map, key);\n    if (doubleObject == null) {\n        return defaultValue;\n    }\n    return doubleObject.doubleValue();\n}"
            ],
            [
                "toProperties",
                "org.apache.commons.collections4",
                "MapUtils",
                "// Conversion methods\n//-------------------------------------------------------------------------\n/**\n * Gets a new Properties object initialised with the values from a Map.\n * A null input will return an empty properties object.\n * <p>\n * A Properties object may only store non-null keys and values, thus if\n * the provided map contains either a key or value which is {@code null},\n * a {@link NullPointerException} will be thrown.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to convert to a Properties object\n * @return the properties object\n * @throws NullPointerException if a key or value in the provided map is {@code null}\n */\npublic static <K, V> Properties toProperties(final Map<K, V> map) {\n    final Properties answer = new Properties();\n    if (map != null) {\n        for (final Entry<K, V> entry2 : map.entrySet()) {\n            final Map.Entry<?, ?> entry = entry2;\n            final Object key = entry.getKey();\n            final Object value = entry.getValue();\n            answer.put(key, value);\n        }\n    }\n    return answer;\n}"
            ],
            [
                "toMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Creates a new HashMap using data copied from a ResourceBundle.\n *\n * @param resourceBundle  the resource bundle to convert, may not be null\n * @return the hashmap containing the data\n * @throws NullPointerException if the bundle is null\n */\npublic static Map<String, Object> toMap(final ResourceBundle resourceBundle) {\n    final Enumeration<String> enumeration = resourceBundle.getKeys();\n    final Map<String, Object> map = new HashMap<String, Object>();\n    while (enumeration.hasMoreElements()) {\n        final String key = enumeration.nextElement();\n        final Object value = resourceBundle.getObject(key);\n        map.put(key, value);\n    }\n    return map;\n}"
            ],
            [
                "invertMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "// Misc\n//-----------------------------------------------------------------------\n/**\n * Inverts the supplied map returning a new HashMap such that the keys of\n * the input are swapped with the values.\n * <p>\n * This operation assumes that the inverse mapping is well defined.\n * If the input map had multiple entries with the same value mapped to\n * different keys, the returned map will map one of those keys to the\n * value, but the exact key which will be mapped is undefined.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to invert, may not be null\n * @return a new HashMap containing the inverted data\n * @throws NullPointerException if the map is null\n */\npublic static <K, V> Map<V, K> invertMap(final Map<K, V> map) {\n    final Map<V, K> out = new HashMap<V, K>(map.size());\n    for (final Entry<K, V> entry : map.entrySet()) {\n        out.put(entry.getValue(), entry.getKey());\n    }\n    return out;\n}"
            ],
            [
                "putAll",
                "org.apache.commons.collections4",
                "MapUtils",
                "//-----------------------------------------------------------------------\n/**\n * Puts all the keys and values from the specified array into the map.\n * <p>\n * This method is an alternative to the {@link java.util.Map#putAll(java.util.Map)}\n * method and constructors. It allows you to build a map from an object array\n * of various possible styles.\n * <p>\n * If the first entry in the object array implements {@link java.util.Map.Entry}\n * or {@link KeyValue} then the key and value are added from that object.\n * If the first entry in the object array is an object array itself, then\n * it is assumed that index 0 in the sub-array is the key and index 1 is the value.\n * Otherwise, the array is treated as keys and values in alternate indices.\n * <p>\n * For example, to create a color map:\n * <pre>\n * Map colorMap = MapUtils.putAll(new HashMap(), new String[][] {\n *     {\"RED\", \"#FF0000\"},\n *     {\"GREEN\", \"#00FF00\"},\n *     {\"BLUE\", \"#0000FF\"}\n * });\n * </pre>\n * or:\n * <pre>\n * Map colorMap = MapUtils.putAll(new HashMap(), new String[] {\n *     \"RED\", \"#FF0000\",\n *     \"GREEN\", \"#00FF00\",\n *     \"BLUE\", \"#0000FF\"\n * });\n * </pre>\n * or:\n * <pre>\n * Map colorMap = MapUtils.putAll(new HashMap(), new Map.Entry[] {\n *     new DefaultMapEntry(\"RED\", \"#FF0000\"),\n *     new DefaultMapEntry(\"GREEN\", \"#00FF00\"),\n *     new DefaultMapEntry(\"BLUE\", \"#0000FF\")\n * });\n * </pre>\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to populate, must not be null\n * @param array  an array to populate from, null ignored\n * @return the input map\n * @throws NullPointerException  if map is null\n * @throws IllegalArgumentException  if sub-array or entry matching used and an entry is invalid\n * @throws ClassCastException if the array contents is mixed\n * @since 3.2\n */\n// As per Javadoc throws CCE for invalid array contents\n@SuppressWarnings(\"unchecked\")\npublic static <K, V> Map<K, V> putAll(final Map<K, V> map, final Object[] array) {\n    if (map == null) {\n        throw new NullPointerException(\"The map must not be null\");\n    }\n    if (array == null || array.length == 0) {\n        return map;\n    }\n    final Object obj = array[0];\n    if (obj instanceof Map.Entry) {\n        for (final Object element : array) {\n            // cast ok here, type is checked above\n            final Map.Entry<K, V> entry = (Map.Entry<K, V>) element;\n            map.put(entry.getKey(), entry.getValue());\n        }\n    } else if (obj instanceof KeyValue) {\n        for (final Object element : array) {\n            // cast ok here, type is checked above\n            final KeyValue<K, V> keyval = (KeyValue<K, V>) element;\n            map.put(keyval.getKey(), keyval.getValue());\n        }\n    } else if (obj instanceof Object[]) {\n        for (int i = 0; i < array.length; i++) {\n            final Object[] sub = (Object[]) array[i];\n            if (sub == null || sub.length < 2) {\n                throw new IllegalArgumentException(\"Invalid array element: \" + i);\n            }\n            // these casts can fail if array has incorrect types\n            map.put((K) sub[0], (V) sub[1]);\n        }\n    } else {\n        for (int i = 0; i < array.length - 1; ) {\n            // these casts can fail if array has incorrect types\n            map.put((K) array[i++], (V) array[i++]);\n        }\n    }\n    return map;\n}"
            ],
            [
                "emptyIfNull",
                "org.apache.commons.collections4",
                "MapUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns an immutable empty map if the argument is <code>null</code>,\n * or the argument itself otherwise.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map the map, possibly <code>null</code>\n * @return an empty map if the argument is <code>null</code>\n */\npublic static <K, V> Map<K, V> emptyIfNull(final Map<K, V> map) {\n    return map == null ? Collections.<K, V>emptyMap() : map;\n}"
            ],
            [
                "isEmpty",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Null-safe check if the specified map is empty.\n * <p>\n * Null returns true.\n *\n * @param map  the map to check, may be null\n * @return true if empty or null\n * @since 3.2\n */\npublic static boolean isEmpty(final Map<?, ?> map) {\n    return map == null || map.isEmpty();\n}"
            ],
            [
                "isNotEmpty",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Null-safe check if the specified map is not empty.\n * <p>\n * Null returns false.\n *\n * @param map  the map to check, may be null\n * @return true if non-null and non-empty\n * @since 3.2\n */\npublic static boolean isNotEmpty(final Map<?, ?> map) {\n    return !MapUtils.isEmpty(map);\n}"
            ],
            [
                "synchronizedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "// Map decorators\n//-----------------------------------------------------------------------\n/**\n * Returns a synchronized map backed by the given map.\n * <p>\n * You must manually synchronize on the returned buffer's iterator to\n * avoid non-deterministic behavior:\n *\n * <pre>\n * Map m = MapUtils.synchronizedMap(myMap);\n * Set s = m.keySet();  // outside synchronized block\n * synchronized (m) {  // synchronized on MAP!\n *     Iterator i = s.iterator();\n *     while (i.hasNext()) {\n *         process (i.next());\n *     }\n * }\n * </pre>\n *\n * This method uses the implementation in {@link java.util.Collections Collections}.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to synchronize, must not be null\n * @return a synchronized map backed by the given map\n */\npublic static <K, V> Map<K, V> synchronizedMap(final Map<K, V> map) {\n    return Collections.synchronizedMap(map);\n}"
            ],
            [
                "unmodifiableMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns an unmodifiable map backed by the given map.\n * <p>\n * This method uses the implementation in the decorators subpackage.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to make unmodifiable, must not be null\n * @return an unmodifiable map backed by the given map\n * @throws NullPointerException  if the map is null\n */\npublic static <K, V> Map<K, V> unmodifiableMap(final Map<? extends K, ? extends V> map) {\n    return UnmodifiableMap.unmodifiableMap(map);\n}"
            ],
            [
                "predicatedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a predicated (validating) map backed by the given map.\n * <p>\n * Only objects that pass the tests in the given predicates can be added to the map.\n * Trying to add an invalid object results in an IllegalArgumentException.\n * Keys must pass the key predicate, values must pass the value predicate.\n * It is important not to use the original map after invoking this method,\n * as it is a backdoor for adding invalid objects.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to predicate, must not be null\n * @param keyPred  the predicate for keys, null means no check\n * @param valuePred  the predicate for values, null means no check\n * @return a predicated map backed by the given map\n * @throws NullPointerException  if the Map is null\n */\npublic static <K, V> IterableMap<K, V> predicatedMap(final Map<K, V> map, final Predicate<? super K> keyPred, final Predicate<? super V> valuePred) {\n    return PredicatedMap.predicatedMap(map, keyPred, valuePred);\n}"
            ],
            [
                "transformedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a transformed map backed by the given map.\n * <p>\n * This method returns a new map (decorating the specified map) that\n * will transform any new entries added to it.\n * Existing entries in the specified map will not be transformed.\n * If you want that behaviour, see {@link TransformedMap#transformedMap}.\n * <p>\n * Each object is passed through the transformers as it is added to the\n * Map. It is important not to use the original map after invoking this\n * method, as it is a backdoor for adding untransformed objects.\n * <p>\n * If there are any elements already in the map being decorated, they\n * are NOT transformed.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to transform, must not be null, typically empty\n * @param keyTransformer  the transformer for the map keys, null means no transformation\n * @param valueTransformer  the transformer for the map values, null means no transformation\n * @return a transformed map backed by the given map\n * @throws NullPointerException  if the Map is null\n */\npublic static <K, V> IterableMap<K, V> transformedMap(final Map<K, V> map, final Transformer<? super K, ? extends K> keyTransformer, final Transformer<? super V, ? extends V> valueTransformer) {\n    return TransformedMap.transformingMap(map, keyTransformer, valueTransformer);\n}"
            ],
            [
                "fixedSizeMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a fixed-sized map backed by the given map.\n * Elements may not be added or removed from the returned map, but\n * existing elements can be changed (for instance, via the\n * {@link Map#put(Object,Object)} method).\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map whose size to fix, must not be null\n * @return a fixed-size map backed by that map\n * @throws NullPointerException  if the Map is null\n */\npublic static <K, V> IterableMap<K, V> fixedSizeMap(final Map<K, V> map) {\n    return FixedSizeMap.fixedSizeMap(map);\n}"
            ],
            [
                "lazyMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a \"lazy\" map whose values will be created on demand.\n * <p>\n * When the key passed to the returned map's {@link Map#get(Object)}\n * method is not present in the map, then the factory will be used\n * to create a new object and that object will become the value\n * associated with that key.\n * <p>\n * For instance:\n * <pre>\n * Factory factory = new Factory() {\n *     public Object create() {\n *         return new Date();\n *     }\n * }\n * Map lazyMap = MapUtils.lazyMap(new HashMap(), factory);\n * Object obj = lazyMap.get(\"test\");\n * </pre>\n *\n * After the above code is executed, <code>obj</code> will contain\n * a new <code>Date</code> instance.  Furthermore, that <code>Date</code>\n * instance is the value for the <code>\"test\"</code> key in the map.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to make lazy, must not be null\n * @param factory  the factory for creating new objects, must not be null\n * @return a lazy map backed by the given map\n * @throws NullPointerException  if the Map or Factory is null\n */\npublic static <K, V> IterableMap<K, V> lazyMap(final Map<K, V> map, final Factory<? extends V> factory) {\n    return LazyMap.lazyMap(map, factory);\n}"
            ],
            [
                "lazyMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a \"lazy\" map whose values will be created on demand.\n * <p>\n * When the key passed to the returned map's {@link Map#get(Object)}\n * method is not present in the map, then the factory will be used\n * to create a new object and that object will become the value\n * associated with that key. The factory is a {@link Transformer}\n * that will be passed the key which it must transform into the value.\n * <p>\n * For instance:\n * <pre>\n * Transformer factory = new Transformer() {\n *     public Object transform(Object mapKey) {\n *         return new File(mapKey);\n *     }\n * }\n * Map lazyMap = MapUtils.lazyMap(new HashMap(), factory);\n * Object obj = lazyMap.get(\"C:/dev\");\n * </pre>\n *\n * After the above code is executed, <code>obj</code> will contain\n * a new <code>File</code> instance for the C drive dev directory.\n * Furthermore, that <code>File</code> instance is the value for the\n * <code>\"C:/dev\"</code> key in the map.\n * <p>\n * If a lazy map is wrapped by a synchronized map, the result is a simple\n * synchronized cache. When an object is not is the cache, the cache itself\n * calls back to the factory Transformer to populate itself, all within the\n * same synchronized block.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to make lazy, must not be null\n * @param transformerFactory  the factory for creating new objects, must not be null\n * @return a lazy map backed by the given map\n * @throws NullPointerException  if the Map or Transformer is null\n */\npublic static <K, V> IterableMap<K, V> lazyMap(final Map<K, V> map, final Transformer<? super K, ? extends V> transformerFactory) {\n    return LazyMap.lazyMap(map, transformerFactory);\n}"
            ],
            [
                "orderedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a map that maintains the order of keys that are added\n * backed by the given map.\n * <p>\n * If a key is added twice, the order is determined by the first add.\n * The order is observed through the keySet, values and entrySet.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to order, must not be null\n * @return an ordered map backed by the given map\n * @throws NullPointerException  if the Map is null\n */\npublic static <K, V> OrderedMap<K, V> orderedMap(final Map<K, V> map) {\n    return ListOrderedMap.listOrderedMap(map);\n}"
            ],
            [
                "multiValueMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Creates a mult-value map backed by the given map which returns\n * collections of type ArrayList.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate\n * @return a multi-value map backed by the given map which returns ArrayLists of values.\n * @see MultiValueMap\n * @since 3.2\n * @deprecated since 4.1, use {@link MultiValuedMap} instead\n */\n@Deprecated\npublic static <K, V> MultiValueMap<K, V> multiValueMap(final Map<K, ? super Collection<V>> map) {\n    return MultiValueMap.<K, V>multiValueMap(map);\n}"
            ],
            [
                "multiValueMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Creates a multi-value map backed by the given map which returns\n * collections of the specified type.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param <C>  the collection class type\n * @param map  the map to decorate\n * @param collectionClass  the type of collections to return from the map\n *   (must contain public no-arg constructor and extend Collection)\n * @return a multi-value map backed by the given map which returns collections of the specified type\n * @see MultiValueMap\n * @since 3.2\n * @deprecated since 4.1, use {@link MultiValuedMap} instead\n */\n@Deprecated\npublic static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(final Map<K, C> map, final Class<C> collectionClass) {\n    return MultiValueMap.multiValueMap(map, collectionClass);\n}"
            ],
            [
                "multiValueMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Creates a multi-value map backed by the given map which returns\n * collections created by the specified collection factory.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param <C>  the collection class type\n * @param map  the map to decorate\n * @param collectionFactory  a factor which creates collection objects\n * @return a multi-value map backed by the given map which returns collections\n *   created by the specified collection factory\n * @see MultiValueMap\n * @since 3.2\n * @deprecated since 4.1, use {@link MultiValuedMap} instead\n */\n@Deprecated\npublic static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(final Map<K, C> map, final Factory<C> collectionFactory) {\n    return MultiValueMap.multiValueMap(map, collectionFactory);\n}"
            ],
            [
                "synchronizedSortedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "// SortedMap decorators\n//-----------------------------------------------------------------------\n/**\n * Returns a synchronized sorted map backed by the given sorted map.\n * <p>\n * You must manually synchronize on the returned buffer's iterator to\n * avoid non-deterministic behavior:\n *\n * <pre>\n * Map m = MapUtils.synchronizedSortedMap(myMap);\n * Set s = m.keySet();  // outside synchronized block\n * synchronized (m) {  // synchronized on MAP!\n *     Iterator i = s.iterator();\n *     while (i.hasNext()) {\n *         process (i.next());\n *     }\n * }\n * </pre>\n *\n * This method uses the implementation in {@link java.util.Collections Collections}.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to synchronize, must not be null\n * @return a synchronized map backed by the given map\n * @throws NullPointerException  if the map is null\n */\npublic static <K, V> SortedMap<K, V> synchronizedSortedMap(final SortedMap<K, V> map) {\n    return Collections.synchronizedSortedMap(map);\n}"
            ],
            [
                "unmodifiableSortedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns an unmodifiable sorted map backed by the given sorted map.\n * <p>\n * This method uses the implementation in the decorators subpackage.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the sorted map to make unmodifiable, must not be null\n * @return an unmodifiable map backed by the given map\n * @throws NullPointerException  if the map is null\n */\npublic static <K, V> SortedMap<K, V> unmodifiableSortedMap(final SortedMap<K, ? extends V> map) {\n    return UnmodifiableSortedMap.unmodifiableSortedMap(map);\n}"
            ],
            [
                "predicatedSortedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a predicated (validating) sorted map backed by the given map.\n * <p>\n * Only objects that pass the tests in the given predicates can be added to the map.\n * Trying to add an invalid object results in an IllegalArgumentException.\n * Keys must pass the key predicate, values must pass the value predicate.\n * It is important not to use the original map after invoking this method,\n * as it is a backdoor for adding invalid objects.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to predicate, must not be null\n * @param keyPred  the predicate for keys, null means no check\n * @param valuePred  the predicate for values, null means no check\n * @return a predicated map backed by the given map\n * @throws NullPointerException  if the SortedMap is null\n */\npublic static <K, V> SortedMap<K, V> predicatedSortedMap(final SortedMap<K, V> map, final Predicate<? super K> keyPred, final Predicate<? super V> valuePred) {\n    return PredicatedSortedMap.predicatedSortedMap(map, keyPred, valuePred);\n}"
            ],
            [
                "transformedSortedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a transformed sorted map backed by the given map.\n * <p>\n * This method returns a new sorted map (decorating the specified map) that\n * will transform any new entries added to it.\n * Existing entries in the specified map will not be transformed.\n * If you want that behaviour, see {@link TransformedSortedMap#transformedSortedMap}.\n * <p>\n * Each object is passed through the transformers as it is added to the\n * Map. It is important not to use the original map after invoking this\n * method, as it is a backdoor for adding untransformed objects.\n * <p>\n * If there are any elements already in the map being decorated, they\n * are NOT transformed.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to transform, must not be null, typically empty\n * @param keyTransformer  the transformer for the map keys, null means no transformation\n * @param valueTransformer  the transformer for the map values, null means no transformation\n * @return a transformed map backed by the given map\n * @throws NullPointerException  if the SortedMap is null\n */\npublic static <K, V> SortedMap<K, V> transformedSortedMap(final SortedMap<K, V> map, final Transformer<? super K, ? extends K> keyTransformer, final Transformer<? super V, ? extends V> valueTransformer) {\n    return TransformedSortedMap.transformingSortedMap(map, keyTransformer, valueTransformer);\n}"
            ],
            [
                "fixedSizeSortedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a fixed-sized sorted map backed by the given sorted map.\n * Elements may not be added or removed from the returned map, but\n * existing elements can be changed (for instance, via the\n * {@link Map#put(Object,Object)} method).\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map whose size to fix, must not be null\n * @return a fixed-size map backed by that map\n * @throws NullPointerException  if the SortedMap is null\n */\npublic static <K, V> SortedMap<K, V> fixedSizeSortedMap(final SortedMap<K, V> map) {\n    return FixedSizeSortedMap.fixedSizeSortedMap(map);\n}"
            ],
            [
                "lazySortedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a \"lazy\" sorted map whose values will be created on demand.\n * <p>\n * When the key passed to the returned map's {@link Map#get(Object)}\n * method is not present in the map, then the factory will be used\n * to create a new object and that object will become the value\n * associated with that key.\n * <p>\n * For instance:\n *\n * <pre>\n * Factory factory = new Factory() {\n *     public Object create() {\n *         return new Date();\n *     }\n * }\n * SortedMap lazy = MapUtils.lazySortedMap(new TreeMap(), factory);\n * Object obj = lazy.get(\"test\");\n * </pre>\n *\n * After the above code is executed, <code>obj</code> will contain\n * a new <code>Date</code> instance.  Furthermore, that <code>Date</code>\n * instance is the value for the <code>\"test\"</code> key.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to make lazy, must not be null\n * @param factory  the factory for creating new objects, must not be null\n * @return a lazy map backed by the given map\n * @throws NullPointerException  if the SortedMap or Factory is null\n */\npublic static <K, V> SortedMap<K, V> lazySortedMap(final SortedMap<K, V> map, final Factory<? extends V> factory) {\n    return LazySortedMap.lazySortedMap(map, factory);\n}"
            ],
            [
                "lazySortedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a \"lazy\" sorted map whose values will be created on demand.\n * <p>\n * When the key passed to the returned map's {@link Map#get(Object)}\n * method is not present in the map, then the factory will be used\n * to create a new object and that object will become the value\n * associated with that key. The factory is a {@link Transformer}\n * that will be passed the key which it must transform into the value.\n * <p>\n * For instance:\n * <pre>\n * Transformer factory = new Transformer() {\n *     public Object transform(Object mapKey) {\n *         return new File(mapKey);\n *     }\n * }\n * SortedMap lazy = MapUtils.lazySortedMap(new TreeMap(), factory);\n * Object obj = lazy.get(\"C:/dev\");\n * </pre>\n *\n * After the above code is executed, <code>obj</code> will contain\n * a new <code>File</code> instance for the C drive dev directory.\n * Furthermore, that <code>File</code> instance is the value for the\n * <code>\"C:/dev\"</code> key in the map.\n * <p>\n * If a lazy map is wrapped by a synchronized map, the result is a simple\n * synchronized cache. When an object is not is the cache, the cache itself\n * calls back to the factory Transformer to populate itself, all within the\n * same synchronized block.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to make lazy, must not be null\n * @param transformerFactory  the factory for creating new objects, must not be null\n * @return a lazy map backed by the given map\n * @throws NullPointerException  if the Map or Transformer is null\n */\npublic static <K, V> SortedMap<K, V> lazySortedMap(final SortedMap<K, V> map, final Transformer<? super K, ? extends V> transformerFactory) {\n    return LazySortedMap.lazySortedMap(map, transformerFactory);\n}"
            ],
            [
                "iterableMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Get the specified {@link Map} as an {@link IterableMap}.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map to wrap if necessary.\n * @return IterableMap<K, V>\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> IterableMap<K, V> iterableMap(final Map<K, V> map) {\n    if (map == null) {\n        throw new NullPointerException(\"Map must not be null\");\n    }\n    return map instanceof IterableMap ? (IterableMap<K, V>) map : new AbstractMapDecorator<K, V>(map) {\n    };\n}"
            ],
            [
                "iterableSortedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Get the specified {@link SortedMap} as an {@link IterableSortedMap}.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param sortedMap to wrap if necessary\n * @return {@link IterableSortedMap}<K, V>\n * @throws NullPointerException if sortedMap is null\n * @since 4.0\n */\npublic static <K, V> IterableSortedMap<K, V> iterableSortedMap(final SortedMap<K, V> sortedMap) {\n    if (sortedMap == null) {\n        throw new NullPointerException(\"Map must not be null\");\n    }\n    return sortedMap instanceof IterableSortedMap ? (IterableSortedMap<K, V>) sortedMap : new AbstractSortedMapDecorator<K, V>(sortedMap) {\n    };\n}"
            ],
            [
                "defaultEquator",
                "org.apache.commons.collections4.functors",
                "DefaultEquator",
                "/**\n * Factory returning the typed singleton instance.\n *\n * @param <T>  the object type\n * @return the singleton instance\n */\n// the static instance works for all types\n@SuppressWarnings(\"unchecked\")\npublic static <T> DefaultEquator<T> defaultEquator() {\n    return (DefaultEquator<T>) DefaultEquator.INSTANCE;\n}"
            ],
            [
                "stringValueTransformer",
                "org.apache.commons.collections4.functors",
                "StringValueTransformer",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <T>  the input type\n * @return the singleton instance\n * @since 3.1\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Transformer<T, String> stringValueTransformer() {\n    return (Transformer<T, String>) INSTANCE;\n}"
            ],
            [
                "ifTransformer",
                "org.apache.commons.collections4.functors",
                "IfTransformer",
                "/**\n * Factory method that performs validation.\n *\n * @param <I>  input type for the transformer\n * @param <O>  output type for the transformer\n * @param predicate  predicate to switch on\n * @param trueTransformer  transformer used if true\n * @param falseTransformer  transformer used if false\n * @return the <code>if</code> transformer\n * @throws NullPointerException if either argument is null\n */\npublic static <I, O> Transformer<I, O> ifTransformer(final Predicate<? super I> predicate, final Transformer<? super I, ? extends O> trueTransformer, final Transformer<? super I, ? extends O> falseTransformer) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    if (trueTransformer == null || falseTransformer == null) {\n        throw new NullPointerException(\"Transformers must not be null\");\n    }\n    return new IfTransformer<I, O>(predicate, trueTransformer, falseTransformer);\n}"
            ],
            [
                "ifTransformer",
                "org.apache.commons.collections4.functors",
                "IfTransformer",
                "/**\n * Factory method that performs validation.\n * <p>\n * This factory creates a transformer that just returns the input object when\n * the predicate is false.\n *\n * @param <T>  input and output type for the transformer\n * @param predicate  predicate to switch on\n * @param trueTransformer  transformer used if true\n * @return the <code>if</code> transformer\n * @throws NullPointerException if either argument is null\n */\npublic static <T> Transformer<T, T> ifTransformer(final Predicate<? super T> predicate, final Transformer<? super T, ? extends T> trueTransformer) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    if (trueTransformer == null) {\n        throw new NullPointerException(\"Transformer must not be null\");\n    }\n    return new IfTransformer<T, T>(predicate, trueTransformer, NOPTransformer.<T>nopTransformer());\n}"
            ],
            [
                "identityPredicate",
                "org.apache.commons.collections4.functors",
                "IdentityPredicate",
                "/**\n * Factory to create the identity predicate.\n *\n * @param <T> the type that the predicate queries\n * @param object  the object to compare to\n * @return the predicate\n */\npublic static <T> Predicate<T> identityPredicate(final T object) {\n    if (object == null) {\n        return NullPredicate.<T>nullPredicate();\n    }\n    return new IdentityPredicate<T>(object);\n}"
            ],
            [
                "exceptionClosure",
                "org.apache.commons.collections4.functors",
                "ExceptionClosure",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <E> the type that the closure acts on\n * @return the singleton instance\n * @since 3.1\n */\n// the static instance works for all types\n@SuppressWarnings(\"unchecked\")\npublic static <E> Closure<E> exceptionClosure() {\n    return (Closure<E>) INSTANCE;\n}"
            ],
            [
                "nopClosure",
                "org.apache.commons.collections4.functors",
                "NOPClosure",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <E> the type that the closure acts on\n * @return the singleton instance\n * @since 3.1\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Closure<E> nopClosure() {\n    return (Closure<E>) INSTANCE;\n}"
            ],
            [
                "closureTransformer",
                "org.apache.commons.collections4.functors",
                "ClosureTransformer",
                "/**\n * Factory method that performs validation.\n *\n * @param <T>  the type of the object to transform\n * @param closure  the closure to call, not null\n * @return the <code>closure</code> transformer\n * @throws NullPointerException if the closure is null\n */\npublic static <T> Transformer<T, T> closureTransformer(final Closure<? super T> closure) {\n    if (closure == null) {\n        throw new NullPointerException(\"Closure must not be null\");\n    }\n    return new ClosureTransformer<T>(closure);\n}"
            ],
            [
                "copy",
                "org.apache.commons.collections4.functors",
                "FunctorUtils",
                "/**\n * Clone the predicates to ensure that the internal reference can't be messed with.\n * Due to the {@link Predicate#evaluate(T)} method, Predicate<? super T> is\n * able to be coerced to Predicate<T> without casting issues.\n *\n * @param predicates  the predicates to copy\n * @return the cloned predicates\n */\n@SuppressWarnings(\"unchecked\")\nstatic <T> Predicate<T>[] copy(final Predicate<? super T>... predicates) {\n    if (predicates == null) {\n        return null;\n    }\n    return (Predicate<T>[]) predicates.clone();\n}"
            ],
            [
                "coerce",
                "org.apache.commons.collections4.functors",
                "FunctorUtils",
                "/**\n * A very simple method that coerces Predicate<? super T> to Predicate<T>.\n * Due to the {@link Predicate#evaluate(T)} method, Predicate<? super T> is\n * able to be coerced to Predicate<T> without casting issues.\n * <p>This method exists\n * simply as centralised documentation and atomic unchecked warning\n * suppression.\n *\n * @param <T> the type of object the returned predicate should \"accept\"\n * @param predicate the predicate to coerce.\n * @return the coerced predicate.\n */\n@SuppressWarnings(\"unchecked\")\nstatic <T> Predicate<T> coerce(final Predicate<? super T> predicate) {\n    return (Predicate<T>) predicate;\n}"
            ],
            [
                "validate",
                "org.apache.commons.collections4.functors",
                "FunctorUtils",
                "/**\n * Validate the predicates to ensure that all is well.\n *\n * @param predicates  the predicates to validate\n * @return predicate array\n */\nstatic <T> Predicate<? super T>[] validate(final Collection<? extends Predicate<? super T>> predicates) {\n    if (predicates == null) {\n        throw new NullPointerException(\"The predicate collection must not be null\");\n    }\n    // convert to array like this to guarantee iterator() ordering\n    // OK\n    @SuppressWarnings(\"unchecked\")\n    final Predicate<? super T>[] preds = new Predicate[predicates.size()];\n    int i = 0;\n    for (final Predicate<? super T> predicate : predicates) {\n        preds[i] = predicate;\n        if (preds[i] == null) {\n            throw new NullPointerException(\"The predicate collection must not contain a null predicate, index \" + i + \" was null\");\n        }\n        i++;\n    }\n    return preds;\n}"
            ],
            [
                "copy",
                "org.apache.commons.collections4.functors",
                "FunctorUtils",
                "/**\n * Clone the closures to ensure that the internal reference can't be messed with.\n *\n * @param closures  the closures to copy\n * @return the cloned closures\n */\n@SuppressWarnings(\"unchecked\")\nstatic <E> Closure<E>[] copy(final Closure<? super E>... closures) {\n    if (closures == null) {\n        return null;\n    }\n    return (Closure<E>[]) closures.clone();\n}"
            ],
            [
                "coerce",
                "org.apache.commons.collections4.functors",
                "FunctorUtils",
                "/**\n * A very simple method that coerces Closure<? super T> to Closure<T>.\n * <p>This method exists\n * simply as centralised documentation and atomic unchecked warning\n * suppression.\n *\n * @param <T> the type of object the returned closure should \"accept\"\n * @param closure the closure to coerce.\n * @return the coerced closure.\n */\n@SuppressWarnings(\"unchecked\")\nstatic <T> Closure<T> coerce(final Closure<? super T> closure) {\n    return (Closure<T>) closure;\n}"
            ],
            [
                "copy",
                "org.apache.commons.collections4.functors",
                "FunctorUtils",
                "/**\n * Copy method\n *\n * @param transformers  the transformers to copy\n * @return a clone of the transformers\n */\n@SuppressWarnings(\"unchecked\")\nstatic <I, O> Transformer<I, O>[] copy(final Transformer<? super I, ? extends O>... transformers) {\n    if (transformers == null) {\n        return null;\n    }\n    return (Transformer<I, O>[]) transformers.clone();\n}"
            ],
            [
                "coerce",
                "org.apache.commons.collections4.functors",
                "FunctorUtils",
                "/**\n * A very simple method that coerces Transformer<? super I, ? extends O> to Transformer<I, O>.\n * <p>This method exists\n * simply as centralised documentation and atomic unchecked warning\n * suppression.\n *\n * @param <T> the type of object the returned transformer should \"accept\"\n * @param transformer the transformer to coerce.\n * @return the coerced transformer.\n */\n@SuppressWarnings(\"unchecked\")\nstatic <I, O> Transformer<I, O> coerce(final Transformer<? super I, ? extends O> transformer) {\n    return (Transformer<I, O>) transformer;\n}"
            ],
            [
                "transformerPredicate",
                "org.apache.commons.collections4.functors",
                "TransformerPredicate",
                "/**\n * Factory to create the predicate.\n *\n * @param <T> the type that the predicate queries\n * @param transformer  the transformer to decorate\n * @return the predicate\n * @throws NullPointerException if the transformer is null\n */\npublic static <T> Predicate<T> transformerPredicate(final Transformer<? super T, Boolean> transformer) {\n    if (transformer == null) {\n        throw new NullPointerException(\"The transformer to call must not be null\");\n    }\n    return new TransformerPredicate<T>(transformer);\n}"
            ],
            [
                "nullPredicate",
                "org.apache.commons.collections4.functors",
                "NullPredicate",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <T> the type that the predicate queries\n * @return the singleton instance\n * @since 3.1\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Predicate<T> nullPredicate() {\n    return (Predicate<T>) INSTANCE;\n}"
            ],
            [
                "nullTransformer",
                "org.apache.commons.collections4.functors",
                "ConstantTransformer",
                "/**\n * Get a typed null instance.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @return Transformer<I, O> that always returns null.\n */\n// The null transformer works for all object types\n@SuppressWarnings(\"unchecked\")\npublic static <I, O> Transformer<I, O> nullTransformer() {\n    return (Transformer<I, O>) NULL_INSTANCE;\n}"
            ],
            [
                "constantTransformer",
                "org.apache.commons.collections4.functors",
                "ConstantTransformer",
                "/**\n * Transformer method that performs validation.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param constantToReturn  the constant object to return each time in the factory\n * @return the <code>constant</code> factory.\n */\npublic static <I, O> Transformer<I, O> constantTransformer(final O constantToReturn) {\n    if (constantToReturn == null) {\n        return nullTransformer();\n    }\n    return new ConstantTransformer<I, O>(constantToReturn);\n}"
            ],
            [
                "predicateTransformer",
                "org.apache.commons.collections4.functors",
                "PredicateTransformer",
                "/**\n * Factory method that performs validation.\n *\n * @param <T>  the input type\n * @param predicate  the predicate to call, not null\n * @return the <code>predicate</code> transformer\n * @throws IllegalArgumentException if the predicate is null\n */\npublic static <T> Transformer<T, Boolean> predicateTransformer(final Predicate<? super T> predicate) {\n    if (predicate == null) {\n        throw new IllegalArgumentException(\"Predicate must not be null\");\n    }\n    return new PredicateTransformer<T>(predicate);\n}"
            ],
            [
                "whileClosure",
                "org.apache.commons.collections4.functors",
                "WhileClosure",
                "/**\n * Factory method that performs validation.\n *\n * @param <E> the type that the closure acts on\n * @param predicate  the predicate used to evaluate when the loop terminates, not null\n * @param closure  the closure the execute, not null\n * @param doLoop  true to act as a do-while loop, always executing the closure once\n * @return the <code>while</code> closure\n * @throws NullPointerException if the predicate or closure is null\n */\npublic static <E> Closure<E> whileClosure(final Predicate<? super E> predicate, final Closure<? super E> closure, final boolean doLoop) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    if (closure == null) {\n        throw new NullPointerException(\"Closure must not be null\");\n    }\n    return new WhileClosure<E>(predicate, closure, doLoop);\n}"
            ],
            [
                "forClosure",
                "org.apache.commons.collections4.functors",
                "ForClosure",
                "/**\n * Factory method that performs validation.\n * <p>\n * A null closure or zero count returns the <code>NOPClosure</code>.\n * A count of one returns the specified closure.\n *\n * @param <E> the type that the closure acts on\n * @param count  the number of times to execute the closure\n * @param closure  the closure to execute, not null\n * @return the <code>for</code> closure\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Closure<E> forClosure(final int count, final Closure<? super E> closure) {\n    if (count <= 0 || closure == null) {\n        return NOPClosure.<E>nopClosure();\n    }\n    if (count == 1) {\n        return (Closure<E>) closure;\n    }\n    return new ForClosure<E>(count, closure);\n}"
            ],
            [
                "nullIsTruePredicate",
                "org.apache.commons.collections4.functors",
                "NullIsTruePredicate",
                "/**\n * Factory to create the null true predicate.\n *\n * @param <T> the type that the predicate queries\n * @param predicate  the predicate to decorate, not null\n * @return the predicate\n * @throws NullPointerException if the predicate is null\n */\npublic static <T> Predicate<T> nullIsTruePredicate(final Predicate<? super T> predicate) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    return new NullIsTruePredicate<T>(predicate);\n}"
            ],
            [
                "transformedPredicate",
                "org.apache.commons.collections4.functors",
                "TransformedPredicate",
                "/**\n * Factory to create the predicate.\n *\n * @param <T> the type that the predicate queries\n * @param transformer  the transformer to call\n * @param predicate  the predicate to call with the result of the transform\n * @return the predicate\n * @throws NullPointerException if the transformer or the predicate is null\n */\npublic static <T> Predicate<T> transformedPredicate(final Transformer<? super T, ? extends T> transformer, final Predicate<? super T> predicate) {\n    if (transformer == null) {\n        throw new NullPointerException(\"The transformer to call must not be null\");\n    }\n    if (predicate == null) {\n        throw new NullPointerException(\"The predicate to call must not be null\");\n    }\n    return new TransformedPredicate<T>(transformer, predicate);\n}"
            ],
            [
                "nonePredicate",
                "org.apache.commons.collections4.functors",
                "NonePredicate",
                "/**\n * Factory to create the predicate.\n * <p>\n * If the array is size zero, the predicate always returns true.\n *\n * @param <T> the type that the predicate queries\n * @param predicates  the predicates to check, cloned, not null\n * @return the <code>any</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n */\npublic static <T> Predicate<T> nonePredicate(final Predicate<? super T>... predicates) {\n    FunctorUtils.validate(predicates);\n    if (predicates.length == 0) {\n        return TruePredicate.<T>truePredicate();\n    }\n    return new NonePredicate<T>(FunctorUtils.copy(predicates));\n}"
            ],
            [
                "nonePredicate",
                "org.apache.commons.collections4.functors",
                "NonePredicate",
                "/**\n * Factory to create the predicate.\n * <p>\n * If the collection is size zero, the predicate always returns true.\n *\n * @param <T> the type that the predicate queries\n * @param predicates  the predicates to check, cloned, not null\n * @return the <code>one</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n */\npublic static <T> Predicate<T> nonePredicate(final Collection<? extends Predicate<? super T>> predicates) {\n    final Predicate<? super T>[] preds = FunctorUtils.validate(predicates);\n    if (preds.length == 0) {\n        return TruePredicate.<T>truePredicate();\n    }\n    return new NonePredicate<T>(preds);\n}"
            ],
            [
                "exceptionTransformer",
                "org.apache.commons.collections4.functors",
                "ExceptionTransformer",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @return the singleton instance\n * @since 3.1\n */\n// the static instance works for all types\n@SuppressWarnings(\"unchecked\")\npublic static <I, O> Transformer<I, O> exceptionTransformer() {\n    return (Transformer<I, O>) INSTANCE;\n}"
            ],
            [
                "switchTransformer",
                "org.apache.commons.collections4.functors",
                "SwitchTransformer",
                "/**\n * Factory method that performs validation and copies the parameter arrays.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param predicates  array of predicates, cloned, no nulls\n * @param transformers  matching array of transformers, cloned, no nulls\n * @param defaultTransformer  the transformer to use if no match, null means return null\n * @return the <code>chained</code> transformer\n * @throws NullPointerException if array is null\n * @throws NullPointerException if any element in the array is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <I, O> Transformer<I, O> switchTransformer(final Predicate<? super I>[] predicates, final Transformer<? super I, ? extends O>[] transformers, final Transformer<? super I, ? extends O> defaultTransformer) {\n    FunctorUtils.validate(predicates);\n    FunctorUtils.validate(transformers);\n    if (predicates.length != transformers.length) {\n        throw new IllegalArgumentException(\"The predicate and transformer arrays must be the same size\");\n    }\n    if (predicates.length == 0) {\n        return (Transformer<I, O>) (defaultTransformer == null ? ConstantTransformer.<I, O>nullTransformer() : defaultTransformer);\n    }\n    return new SwitchTransformer<I, O>(predicates, transformers, defaultTransformer);\n}"
            ],
            [
                "switchTransformer",
                "org.apache.commons.collections4.functors",
                "SwitchTransformer",
                "/**\n * Create a new Transformer that calls one of the transformers depending\n * on the predicates.\n * <p>\n * The Map consists of Predicate keys and Transformer values. A transformer\n * is called if its matching predicate returns true. Each predicate is evaluated\n * until one returns true. If no predicates evaluate to true, the default\n * transformer is called. The default transformer is set in the map with a\n * null key. The ordering is that of the iterator() method on the entryset\n * collection of the map.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param map  a map of predicates to transformers\n * @return the <code>switch</code> transformer\n * @throws NullPointerException if the map is null\n * @throws NullPointerException if any transformer in the map is null\n * @throws ClassCastException  if the map elements are of the wrong type\n */\n@SuppressWarnings(\"unchecked\")\npublic static <I, O> Transformer<I, O> switchTransformer(final Map<? extends Predicate<? super I>, ? extends Transformer<? super I, ? extends O>> map) {\n    if (map == null) {\n        throw new NullPointerException(\"The predicate and transformer map must not be null\");\n    }\n    if (map.size() == 0) {\n        return ConstantTransformer.<I, O>nullTransformer();\n    }\n    // convert to array like this to guarantee iterator() ordering\n    final Transformer<? super I, ? extends O> defaultTransformer = map.remove(null);\n    final int size = map.size();\n    if (size == 0) {\n        return (Transformer<I, O>) (defaultTransformer == null ? ConstantTransformer.<I, O>nullTransformer() : defaultTransformer);\n    }\n    final Transformer<? super I, ? extends O>[] transformers = new Transformer[size];\n    final Predicate<? super I>[] preds = new Predicate[size];\n    int i = 0;\n    for (final Map.Entry<? extends Predicate<? super I>, ? extends Transformer<? super I, ? extends O>> entry : map.entrySet()) {\n        preds[i] = entry.getKey();\n        transformers[i] = entry.getValue();\n        i++;\n    }\n    return new SwitchTransformer<I, O>(false, preds, transformers, defaultTransformer);\n}"
            ],
            [
                "transformerClosure",
                "org.apache.commons.collections4.functors",
                "TransformerClosure",
                "/**\n * Factory method that performs validation.\n * <p>\n * A null transformer will return the <code>NOPClosure</code>.\n *\n * @param <E> the type that the closure acts on\n * @param transformer  the transformer to call, null means nop\n * @return the <code>transformer</code> closure\n */\npublic static <E> Closure<E> transformerClosure(final Transformer<? super E, ?> transformer) {\n    if (transformer == null) {\n        return NOPClosure.<E>nopClosure();\n    }\n    return new TransformerClosure<E>(transformer);\n}"
            ],
            [
                "orPredicate",
                "org.apache.commons.collections4.functors",
                "OrPredicate",
                "/**\n * Factory to create the predicate.\n *\n * @param <T> the type that the predicate queries\n * @param predicate1  the first predicate to check, not null\n * @param predicate2  the second predicate to check, not null\n * @return the <code>and</code> predicate\n * @throws NullPointerException if either predicate is null\n */\npublic static <T> Predicate<T> orPredicate(final Predicate<? super T> predicate1, final Predicate<? super T> predicate2) {\n    if (predicate1 == null || predicate2 == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    return new OrPredicate<T>(predicate1, predicate2);\n}"
            ],
            [
                "nopTransformer",
                "org.apache.commons.collections4.functors",
                "NOPTransformer",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <T>  the input/output type\n * @return the singleton instance\n * @since 3.1\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Transformer<T, T> nopTransformer() {\n    return (Transformer<T, T>) INSTANCE;\n}"
            ],
            [
                "mapTransformer",
                "org.apache.commons.collections4.functors",
                "MapTransformer",
                "/**\n * Factory to create the transformer.\n * <p>\n * If the map is null, a transformer that always returns null is returned.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param map the map, not cloned\n * @return the transformer\n */\npublic static <I, O> Transformer<I, O> mapTransformer(final Map<? super I, ? extends O> map) {\n    if (map == null) {\n        return ConstantTransformer.<I, O>nullTransformer();\n    }\n    return new MapTransformer<I, O>(map);\n}"
            ],
            [
                "exceptionFactory",
                "org.apache.commons.collections4.functors",
                "ExceptionFactory",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <T>  the type the factory creates\n * @return the singleton instance\n * @since 3.1\n */\n// the static instance works for all types\n@SuppressWarnings(\"unchecked\")\npublic static <T> Factory<T> exceptionFactory() {\n    return (Factory<T>) INSTANCE;\n}"
            ],
            [
                "chainedClosure",
                "org.apache.commons.collections4.functors",
                "ChainedClosure",
                "/**\n * Factory method that performs validation and copies the parameter array.\n *\n * @param <E> the type that the closure acts on\n * @param closures  the closures to chain, copied, no nulls\n * @return the <code>chained</code> closure\n * @throws NullPointerException if the closures array is null\n * @throws NullPointerException if any closure in the array is null\n */\npublic static <E> Closure<E> chainedClosure(final Closure<? super E>... closures) {\n    FunctorUtils.validate(closures);\n    if (closures.length == 0) {\n        return NOPClosure.<E>nopClosure();\n    }\n    return new ChainedClosure<E>(closures);\n}"
            ],
            [
                "chainedClosure",
                "org.apache.commons.collections4.functors",
                "ChainedClosure",
                "/**\n * Create a new Closure that calls each closure in turn, passing the\n * result into the next closure. The ordering is that of the iterator()\n * method on the collection.\n *\n * @param <E> the type that the closure acts on\n * @param closures  a collection of closures to chain\n * @return the <code>chained</code> closure\n * @throws NullPointerException if the closures collection is null\n * @throws NullPointerException if any closure in the collection is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Closure<E> chainedClosure(final Collection<? extends Closure<? super E>> closures) {\n    if (closures == null) {\n        throw new NullPointerException(\"Closure collection must not be null\");\n    }\n    if (closures.size() == 0) {\n        return NOPClosure.<E>nopClosure();\n    }\n    // convert to array like this to guarantee iterator() ordering\n    final Closure<? super E>[] cmds = new Closure[closures.size()];\n    int i = 0;\n    for (final Closure<? super E> closure : closures) {\n        cmds[i++] = closure;\n    }\n    FunctorUtils.validate(cmds);\n    return new ChainedClosure<E>(false, cmds);\n}"
            ],
            [
                "andPredicate",
                "org.apache.commons.collections4.functors",
                "AndPredicate",
                "/**\n * Factory to create the predicate.\n *\n * @param <T> the type that the predicate queries\n * @param predicate1  the first predicate to check, not null\n * @param predicate2  the second predicate to check, not null\n * @return the <code>and</code> predicate\n * @throws NullPointerException if either predicate is null\n */\npublic static <T> Predicate<T> andPredicate(final Predicate<? super T> predicate1, final Predicate<? super T> predicate2) {\n    if (predicate1 == null || predicate2 == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    return new AndPredicate<T>(predicate1, predicate2);\n}"
            ],
            [
                "prototypeFactory",
                "org.apache.commons.collections4.functors",
                "PrototypeFactory",
                "/**\n * Factory method that performs validation.\n * <p>\n * Creates a Factory that will return a clone of the same prototype object\n * each time the factory is used. The prototype will be cloned using one of these\n * techniques (in order):\n * <ul>\n * <li>public clone method\n * <li>public copy constructor\n * <li>serialization clone\n * <ul>\n *\n * @param <T>  the type the factory creates\n * @param prototype  the object to clone each time in the factory\n * @return the <code>prototype</code> factory, or a {@link ConstantFactory#NULL_INSTANCE} if\n * the {@code prototype} is {@code null}\n * @throws IllegalArgumentException if the prototype cannot be cloned\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Factory<T> prototypeFactory(final T prototype) {\n    if (prototype == null) {\n        return ConstantFactory.<T>constantFactory(null);\n    }\n    try {\n        final Method method = prototype.getClass().getMethod(\"clone\", (Class[]) null);\n        return new PrototypeCloneFactory<T>(prototype, method);\n    } catch (final NoSuchMethodException ex) {\n        try {\n            prototype.getClass().getConstructor(new Class<?>[] { prototype.getClass() });\n            return new InstantiateFactory<T>((Class<T>) prototype.getClass(), new Class<?>[] { prototype.getClass() }, new Object[] { prototype });\n        } catch (final NoSuchMethodException ex2) {\n            if (prototype instanceof Serializable) {\n                return (Factory<T>) new PrototypeSerializationFactory<Serializable>((Serializable) prototype);\n            }\n        }\n    }\n    throw new IllegalArgumentException(\"The prototype must be cloneable via a public clone method\");\n}"
            ],
            [
                "exceptionPredicate",
                "org.apache.commons.collections4.functors",
                "ExceptionPredicate",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <T>  the object type\n * @return the singleton instance\n * @since 3.1\n */\n// the static instance works for all types\n@SuppressWarnings(\"unchecked\")\npublic static <T> Predicate<T> exceptionPredicate() {\n    return (Predicate<T>) INSTANCE;\n}"
            ],
            [
                "instanceOfPredicate",
                "org.apache.commons.collections4.functors",
                "InstanceofPredicate",
                "/**\n * Factory to create the identity predicate.\n *\n * @param type  the type to check for, may not be null\n * @return the predicate\n * @throws NullPointerException if the class is null\n */\npublic static Predicate<Object> instanceOfPredicate(final Class<?> type) {\n    if (type == null) {\n        throw new NullPointerException(\"The type to check instanceof must not be null\");\n    }\n    return new InstanceofPredicate(type);\n}"
            ],
            [
                "invokerTransformer",
                "org.apache.commons.collections4.functors",
                "InvokerTransformer",
                "/**\n * Gets an instance of this transformer calling a specific method with no arguments.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param methodName  the method name to call\n * @return an invoker transformer\n * @throws NullPointerException if methodName is null\n * @since 3.1\n */\npublic static <I, O> Transformer<I, O> invokerTransformer(final String methodName) {\n    if (methodName == null) {\n        throw new NullPointerException(\"The method to invoke must not be null\");\n    }\n    return new InvokerTransformer<I, O>(methodName);\n}"
            ],
            [
                "invokerTransformer",
                "org.apache.commons.collections4.functors",
                "InvokerTransformer",
                "/**\n * Gets an instance of this transformer calling a specific method with specific values.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param methodName  the method name to call\n * @param paramTypes  the parameter types of the method\n * @param args  the arguments to pass to the method\n * @return an invoker transformer\n * @throws NullPointerException if methodName is null\n * @throws IllegalArgumentException if paramTypes does not match args\n */\npublic static <I, O> Transformer<I, O> invokerTransformer(final String methodName, final Class<?>[] paramTypes, final Object[] args) {\n    if (methodName == null) {\n        throw new NullPointerException(\"The method to invoke must not be null\");\n    }\n    if (((paramTypes == null) && (args != null)) || ((paramTypes != null) && (args == null)) || ((paramTypes != null) && (args != null) && (paramTypes.length != args.length))) {\n        throw new IllegalArgumentException(\"The parameter types must match the arguments\");\n    }\n    if (paramTypes == null || paramTypes.length == 0) {\n        return new InvokerTransformer<I, O>(methodName);\n    }\n    return new InvokerTransformer<I, O>(methodName, paramTypes, args);\n}"
            ],
            [
                "falsePredicate",
                "org.apache.commons.collections4.functors",
                "FalsePredicate",
                "/**\n * Get a typed instance.\n *\n * @param <T> the type that the predicate queries\n * @return the singleton instance\n * @since 4.0\n */\n// the static instance works for all types\n@SuppressWarnings(\"unchecked\")\npublic static <T> Predicate<T> falsePredicate() {\n    return (Predicate<T>) INSTANCE;\n}"
            ],
            [
                "cloneTransformer",
                "org.apache.commons.collections4.functors",
                "CloneTransformer",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <T>  the type of the objects to be cloned\n * @return the singleton instance\n * @since 3.1\n */\n// the singleton instance works for all types\n@SuppressWarnings(\"unchecked\")\npublic static <T> Transformer<T, T> cloneTransformer() {\n    return INSTANCE;\n}"
            ],
            [
                "notPredicate",
                "org.apache.commons.collections4.functors",
                "NotPredicate",
                "/**\n * Factory to create the not predicate.\n *\n * @param <T> the type that the predicate queries\n * @param predicate  the predicate to decorate, not null\n * @return the predicate\n * @throws NullPointerException if the predicate is null\n */\npublic static <T> Predicate<T> notPredicate(final Predicate<? super T> predicate) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    return new NotPredicate<T>(predicate);\n}"
            ],
            [
                "constantFactory",
                "org.apache.commons.collections4.functors",
                "ConstantFactory",
                "/**\n * Factory method that performs validation.\n *\n * @param <T>  the type of the constant\n * @param constantToReturn  the constant object to return each time in the factory\n * @return the <code>constant</code> factory.\n */\n// The null factory works for all object types\n@SuppressWarnings(\"unchecked\")\npublic static <T> Factory<T> constantFactory(final T constantToReturn) {\n    if (constantToReturn == null) {\n        return (Factory<T>) NULL_INSTANCE;\n    }\n    return new ConstantFactory<T>(constantToReturn);\n}"
            ],
            [
                "chainedTransformer",
                "org.apache.commons.collections4.functors",
                "ChainedTransformer",
                "/**\n * Factory method that performs validation and copies the parameter array.\n *\n * @param <T>  the object type\n * @param transformers  the transformers to chain, copied, no nulls\n * @return the <code>chained</code> transformer\n * @throws NullPointerException if the transformers array is null\n * @throws NullPointerException if any transformer in the array is null\n */\npublic static <T> Transformer<T, T> chainedTransformer(final Transformer<? super T, ? extends T>... transformers) {\n    FunctorUtils.validate(transformers);\n    if (transformers.length == 0) {\n        return NOPTransformer.<T>nopTransformer();\n    }\n    return new ChainedTransformer<T>(transformers);\n}"
            ],
            [
                "chainedTransformer",
                "org.apache.commons.collections4.functors",
                "ChainedTransformer",
                "/**\n * Create a new Transformer that calls each transformer in turn, passing the\n * result into the next transformer. The ordering is that of the iterator()\n * method on the collection.\n *\n * @param <T>  the object type\n * @param transformers  a collection of transformers to chain\n * @return the <code>chained</code> transformer\n * @throws NullPointerException if the transformers collection is null\n * @throws NullPointerException if any transformer in the collection is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Transformer<T, T> chainedTransformer(final Collection<? extends Transformer<? super T, ? extends T>> transformers) {\n    if (transformers == null) {\n        throw new NullPointerException(\"Transformer collection must not be null\");\n    }\n    if (transformers.size() == 0) {\n        return NOPTransformer.<T>nopTransformer();\n    }\n    // convert to array like this to guarantee iterator() ordering\n    final Transformer<T, T>[] cmds = transformers.toArray(new Transformer[transformers.size()]);\n    FunctorUtils.validate(cmds);\n    return new ChainedTransformer<T>(false, cmds);\n}"
            ],
            [
                "comparatorPredicate",
                "org.apache.commons.collections4.functors",
                "ComparatorPredicate",
                "/**\n * Factory to create the comparator predicate\n *\n * @param <T> the type that the predicate queries\n * @param object  the object to compare to\n * @param comparator  the comparator to use for comparison\n * @return the predicate\n * @throws NullPointerException if comparator is null\n */\npublic static <T> Predicate<T> comparatorPredicate(final T object, final Comparator<T> comparator) {\n    return comparatorPredicate(object, comparator, Criterion.EQUAL);\n}"
            ],
            [
                "comparatorPredicate",
                "org.apache.commons.collections4.functors",
                "ComparatorPredicate",
                "/**\n * Factory to create the comparator predicate\n *\n * @param <T> the type that the predicate queries\n * @param object  the object to compare to\n * @param comparator  the comparator to use for comparison\n * @param criterion  the criterion to use to evaluate comparison\n * @return the predicate\n * @throws NullPointerException if comparator or criterion is null\n */\npublic static <T> Predicate<T> comparatorPredicate(final T object, final Comparator<T> comparator, final Criterion criterion) {\n    if (comparator == null) {\n        throw new NullPointerException(\"Comparator must not be null.\");\n    }\n    if (criterion == null) {\n        throw new NullPointerException(\"Criterion must not be null.\");\n    }\n    return new ComparatorPredicate<T>(object, comparator, criterion);\n}"
            ],
            [
                "allPredicate",
                "org.apache.commons.collections4.functors",
                "AllPredicate",
                "/**\n * Factory to create the predicate.\n * <p>\n * If the array is size zero, the predicate always returns true.\n * If the array is size one, then that predicate is returned.\n *\n * @param <T> the type that the predicate queries\n * @param predicates  the predicates to check, cloned, not null\n * @return the <code>all</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n */\npublic static <T> Predicate<T> allPredicate(final Predicate<? super T>... predicates) {\n    FunctorUtils.validate(predicates);\n    if (predicates.length == 0) {\n        return truePredicate();\n    }\n    if (predicates.length == 1) {\n        return coerce(predicates[0]);\n    }\n    return new AllPredicate<T>(FunctorUtils.copy(predicates));\n}"
            ],
            [
                "allPredicate",
                "org.apache.commons.collections4.functors",
                "AllPredicate",
                "/**\n * Factory to create the predicate.\n * <p>\n * If the collection is size zero, the predicate always returns true.\n * If the collection is size one, then that predicate is returned.\n *\n * @param <T> the type that the predicate queries\n * @param predicates  the predicates to check, cloned, not null\n * @return the <code>all</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n */\npublic static <T> Predicate<T> allPredicate(final Collection<? extends Predicate<? super T>> predicates) {\n    final Predicate<? super T>[] preds = validate(predicates);\n    if (preds.length == 0) {\n        return truePredicate();\n    }\n    if (preds.length == 1) {\n        return coerce(preds[0]);\n    }\n    return new AllPredicate<T>(preds);\n}"
            ],
            [
                "nullIsFalsePredicate",
                "org.apache.commons.collections4.functors",
                "NullIsFalsePredicate",
                "/**\n * Factory to create the null false predicate.\n *\n * @param <T> the type that the predicate queries\n * @param predicate  the predicate to decorate, not null\n * @return the predicate\n * @throws NullPointerException if the predicate is null\n */\npublic static <T> Predicate<T> nullIsFalsePredicate(final Predicate<? super T> predicate) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    return new NullIsFalsePredicate<T>(predicate);\n}"
            ],
            [
                "nullIsExceptionPredicate",
                "org.apache.commons.collections4.functors",
                "NullIsExceptionPredicate",
                "/**\n * Factory to create the null exception predicate.\n *\n * @param <T> the type that the predicate queries\n * @param predicate  the predicate to decorate, not null\n * @return the predicate\n * @throws NullPointerException if the predicate is null\n */\npublic static <T> Predicate<T> nullIsExceptionPredicate(final Predicate<? super T> predicate) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    return new NullIsExceptionPredicate<T>(predicate);\n}"
            ],
            [
                "anyPredicate",
                "org.apache.commons.collections4.functors",
                "AnyPredicate",
                "/**\n * Factory to create the predicate.\n * <p>\n * If the array is size zero, the predicate always returns false.\n * If the array is size one, then that predicate is returned.\n *\n * @param <T> the type that the predicate queries\n * @param predicates  the predicates to check, cloned, not null\n * @return the <code>any</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Predicate<T> anyPredicate(final Predicate<? super T>... predicates) {\n    FunctorUtils.validate(predicates);\n    if (predicates.length == 0) {\n        return FalsePredicate.<T>falsePredicate();\n    }\n    if (predicates.length == 1) {\n        return (Predicate<T>) predicates[0];\n    }\n    return new AnyPredicate<T>(FunctorUtils.copy(predicates));\n}"
            ],
            [
                "anyPredicate",
                "org.apache.commons.collections4.functors",
                "AnyPredicate",
                "/**\n * Factory to create the predicate.\n * <p>\n * If the collection is size zero, the predicate always returns false.\n * If the collection is size one, then that predicate is returned.\n *\n * @param <T> the type that the predicate queries\n * @param predicates  the predicates to check, cloned, not null\n * @return the <code>all</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Predicate<T> anyPredicate(final Collection<? extends Predicate<? super T>> predicates) {\n    final Predicate<? super T>[] preds = FunctorUtils.validate(predicates);\n    if (preds.length == 0) {\n        return FalsePredicate.<T>falsePredicate();\n    }\n    if (preds.length == 1) {\n        return (Predicate<T>) preds[0];\n    }\n    return new AnyPredicate<T>(preds);\n}"
            ],
            [
                "truePredicate",
                "org.apache.commons.collections4.functors",
                "TruePredicate",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <T> the type that the predicate queries\n * @return the singleton instance\n * @since 3.1\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Predicate<T> truePredicate() {\n    return (Predicate<T>) INSTANCE;\n}"
            ],
            [
                "factoryTransformer",
                "org.apache.commons.collections4.functors",
                "FactoryTransformer",
                "/**\n * Factory method that performs validation.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param factory  the factory to call, not null\n * @return the <code>factory</code> transformer\n * @throws NullPointerException if the factory is null\n */\npublic static <I, O> Transformer<I, O> factoryTransformer(final Factory<? extends O> factory) {\n    if (factory == null) {\n        throw new NullPointerException(\"Factory must not be null\");\n    }\n    return new FactoryTransformer<I, O>(factory);\n}"
            ],
            [
                "notNullPredicate",
                "org.apache.commons.collections4.functors",
                "NotNullPredicate",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <T> the type that the predicate queries\n * @return the singleton instance\n * @since 3.1\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Predicate<T> notNullPredicate() {\n    return (Predicate<T>) INSTANCE;\n}"
            ],
            [
                "switchClosure",
                "org.apache.commons.collections4.functors",
                "SwitchClosure",
                "/**\n * Factory method that performs validation and copies the parameter arrays.\n *\n * @param <E> the type that the closure acts on\n * @param predicates  array of predicates, cloned, no nulls\n * @param closures  matching array of closures, cloned, no nulls\n * @param defaultClosure  the closure to use if no match, null means nop\n * @return the <code>chained</code> closure\n * @throws NullPointerException if array is null\n * @throws NullPointerException if any element in the array is null\n * @throws IllegalArgumentException if the array lengths of predicates and closures do not match\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Closure<E> switchClosure(final Predicate<? super E>[] predicates, final Closure<? super E>[] closures, final Closure<? super E> defaultClosure) {\n    FunctorUtils.validate(predicates);\n    FunctorUtils.validate(closures);\n    if (predicates.length != closures.length) {\n        throw new IllegalArgumentException(\"The predicate and closure arrays must be the same size\");\n    }\n    if (predicates.length == 0) {\n        return (Closure<E>) (defaultClosure == null ? NOPClosure.<E>nopClosure() : defaultClosure);\n    }\n    return new SwitchClosure<E>(predicates, closures, defaultClosure);\n}"
            ],
            [
                "switchClosure",
                "org.apache.commons.collections4.functors",
                "SwitchClosure",
                "/**\n * Create a new Closure that calls one of the closures depending\n * on the predicates.\n * <p>\n * The Map consists of Predicate keys and Closure values. A closure\n * is called if its matching predicate returns true. Each predicate is evaluated\n * until one returns true. If no predicates evaluate to true, the default\n * closure is called. The default closure is set in the map with a\n * null key. The ordering is that of the iterator() method on the entryset\n * collection of the map.\n *\n * @param <E> the type that the closure acts on\n * @param predicatesAndClosures  a map of predicates to closures\n * @return the <code>switch</code> closure\n * @throws NullPointerException if the map is null\n * @throws NullPointerException if any closure in the map is null\n * @throws ClassCastException  if the map elements are of the wrong type\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Closure<E> switchClosure(final Map<Predicate<E>, Closure<E>> predicatesAndClosures) {\n    if (predicatesAndClosures == null) {\n        throw new NullPointerException(\"The predicate and closure map must not be null\");\n    }\n    // convert to array like this to guarantee iterator() ordering\n    final Closure<? super E> defaultClosure = predicatesAndClosures.remove(null);\n    final int size = predicatesAndClosures.size();\n    if (size == 0) {\n        return (Closure<E>) (defaultClosure == null ? NOPClosure.<E>nopClosure() : defaultClosure);\n    }\n    final Closure<E>[] closures = new Closure[size];\n    final Predicate<E>[] preds = new Predicate[size];\n    int i = 0;\n    for (final Map.Entry<Predicate<E>, Closure<E>> entry : predicatesAndClosures.entrySet()) {\n        preds[i] = entry.getKey();\n        closures[i] = entry.getValue();\n        i++;\n    }\n    return new SwitchClosure<E>(false, preds, closures, defaultClosure);\n}"
            ],
            [
                "uniquePredicate",
                "org.apache.commons.collections4.functors",
                "UniquePredicate",
                "/**\n * Factory to create the predicate.\n *\n * @param <T> the type that the predicate queries\n * @return the predicate\n * @throws IllegalArgumentException if the predicate is null\n */\npublic static <T> Predicate<T> uniquePredicate() {\n    return new UniquePredicate<T>();\n}"
            ],
            [
                "instantiateTransformer",
                "org.apache.commons.collections4.functors",
                "InstantiateTransformer",
                "/**\n * Get a typed no-arg instance.\n *\n * @param <T>  the type of the objects to be created\n * @return Transformer<Class<? extends T>, T>\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Transformer<Class<? extends T>, T> instantiateTransformer() {\n    return NO_ARG_INSTANCE;\n}"
            ],
            [
                "instantiateTransformer",
                "org.apache.commons.collections4.functors",
                "InstantiateTransformer",
                "/**\n * Transformer method that performs validation.\n *\n * @param <T>  the type of the objects to be created\n * @param paramTypes  the constructor parameter types\n * @param args  the constructor arguments\n * @return an instantiate transformer\n * @throws IllegalArgumentException if paramTypes does not match args\n */\npublic static <T> Transformer<Class<? extends T>, T> instantiateTransformer(final Class<?>[] paramTypes, final Object[] args) {\n    if (((paramTypes == null) && (args != null)) || ((paramTypes != null) && (args == null)) || ((paramTypes != null) && (args != null) && (paramTypes.length != args.length))) {\n        throw new IllegalArgumentException(\"Parameter types must match the arguments\");\n    }\n    if (paramTypes == null || paramTypes.length == 0) {\n        return new InstantiateTransformer<T>();\n    }\n    return new InstantiateTransformer<T>(paramTypes, args);\n}"
            ],
            [
                "onePredicate",
                "org.apache.commons.collections4.functors",
                "OnePredicate",
                "/**\n * Factory to create the predicate.\n * <p>\n * If the array is size zero, the predicate always returns false.\n * If the array is size one, then that predicate is returned.\n *\n * @param <T> the type that the predicate queries\n * @param predicates  the predicates to check, cloned, not null\n * @return the <code>any</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Predicate<T> onePredicate(final Predicate<? super T>... predicates) {\n    FunctorUtils.validate(predicates);\n    if (predicates.length == 0) {\n        return FalsePredicate.<T>falsePredicate();\n    }\n    if (predicates.length == 1) {\n        return (Predicate<T>) predicates[0];\n    }\n    return new OnePredicate<T>(FunctorUtils.copy(predicates));\n}"
            ],
            [
                "onePredicate",
                "org.apache.commons.collections4.functors",
                "OnePredicate",
                "/**\n * Factory to create the predicate.\n *\n * @param <T> the type that the predicate queries\n * @param predicates  the predicates to check, cloned, not null\n * @return the <code>one</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n */\npublic static <T> Predicate<T> onePredicate(final Collection<? extends Predicate<? super T>> predicates) {\n    final Predicate<? super T>[] preds = FunctorUtils.validate(predicates);\n    return new OnePredicate<T>(preds);\n}"
            ],
            [
                "equalPredicate",
                "org.apache.commons.collections4.functors",
                "EqualPredicate",
                "/**\n * Factory to create the predicate.\n *\n * @param <T> the type that the predicate queries\n * @param object  the object to compare to\n * @return the predicate\n */\npublic static <T> Predicate<T> equalPredicate(final T object) {\n    if (object == null) {\n        return NullPredicate.nullPredicate();\n    }\n    return new EqualPredicate<T>(object);\n}"
            ],
            [
                "equalPredicate",
                "org.apache.commons.collections4.functors",
                "EqualPredicate",
                "/**\n * Factory to create the identity predicate.\n *\n * @param <T> the type that the predicate queries\n * @param object  the object to compare to\n * @param equator  the equator to use for comparison\n * @return the predicate\n * @since 4.0\n */\npublic static <T> Predicate<T> equalPredicate(final T object, final Equator<T> equator) {\n    if (object == null) {\n        return NullPredicate.nullPredicate();\n    }\n    return new EqualPredicate<T>(object, equator);\n}"
            ],
            [
                "instantiateFactory",
                "org.apache.commons.collections4.functors",
                "InstantiateFactory",
                "/**\n * Factory method that performs validation.\n *\n * @param <T>  the type the factory creates\n * @param classToInstantiate  the class to instantiate, not null\n * @param paramTypes  the constructor parameter types, cloned\n * @param args  the constructor arguments, cloned\n * @return a new instantiate factory\n * @throws NullPointerException if classToInstantiate is null\n * @throws IllegalArgumentException if paramTypes does not match args\n */\npublic static <T> Factory<T> instantiateFactory(final Class<T> classToInstantiate, final Class<?>[] paramTypes, final Object[] args) {\n    if (classToInstantiate == null) {\n        throw new NullPointerException(\"Class to instantiate must not be null\");\n    }\n    if (paramTypes == null && args != null || paramTypes != null && args == null || paramTypes != null && args != null && paramTypes.length != args.length) {\n        throw new IllegalArgumentException(\"Parameter types must match the arguments\");\n    }\n    if (paramTypes == null || paramTypes.length == 0) {\n        return new InstantiateFactory<T>(classToInstantiate);\n    }\n    return new InstantiateFactory<T>(classToInstantiate, paramTypes, args);\n}"
            ],
            [
                "ifClosure",
                "org.apache.commons.collections4.functors",
                "IfClosure",
                "/**\n * Factory method that performs validation.\n * <p>\n * This factory creates a closure that performs no action when\n * the predicate is false.\n *\n * @param <E> the type that the closure acts on\n * @param predicate  predicate to switch on\n * @param trueClosure  closure used if true\n * @return the <code>if</code> closure\n * @throws NullPointerException if either argument is null\n * @since 3.2\n */\npublic static <E> Closure<E> ifClosure(final Predicate<? super E> predicate, final Closure<? super E> trueClosure) {\n    return IfClosure.<E>ifClosure(predicate, trueClosure, NOPClosure.<E>nopClosure());\n}"
            ],
            [
                "ifClosure",
                "org.apache.commons.collections4.functors",
                "IfClosure",
                "/**\n * Factory method that performs validation.\n *\n * @param <E> the type that the closure acts on\n * @param predicate  predicate to switch on\n * @param trueClosure  closure used if true\n * @param falseClosure  closure used if false\n * @return the <code>if</code> closure\n * @throws NullPointerException if any argument is null\n */\npublic static <E> Closure<E> ifClosure(final Predicate<? super E> predicate, final Closure<? super E> trueClosure, final Closure<? super E> falseClosure) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    if (trueClosure == null || falseClosure == null) {\n        throw new NullPointerException(\"Closures must not be null\");\n    }\n    return new IfClosure<E>(predicate, trueClosure, falseClosure);\n}"
            ],
            [
                "getTrueFirstComparator",
                "org.apache.commons.collections4.comparators",
                "BooleanComparator",
                "//-----------------------------------------------------------------------\n/**\n * Returns a BooleanComparator instance that sorts\n * <code>true</code> values before <code>false</code> values.\n * <p />\n * Clients are encouraged to use the value returned from\n * this method instead of constructing a new instance\n * to reduce allocation and garbage collection overhead when\n * multiple BooleanComparators may be used in the same\n * virtual machine.\n *\n * @return the true first singleton BooleanComparator\n */\npublic static BooleanComparator getTrueFirstComparator() {\n    return TRUE_FIRST;\n}"
            ],
            [
                "getFalseFirstComparator",
                "org.apache.commons.collections4.comparators",
                "BooleanComparator",
                "/**\n * Returns a BooleanComparator instance that sorts\n * <code>false</code> values before <code>true</code> values.\n * <p />\n * Clients are encouraged to use the value returned from\n * this method instead of constructing a new instance\n * to reduce allocation and garbage collection overhead when\n * multiple BooleanComparators may be used in the same\n * virtual machine.\n *\n * @return the false first singleton BooleanComparator\n */\npublic static BooleanComparator getFalseFirstComparator() {\n    return FALSE_FIRST;\n}"
            ],
            [
                "booleanComparator",
                "org.apache.commons.collections4.comparators",
                "BooleanComparator",
                "/**\n * Returns a BooleanComparator instance that sorts\n * <code><i>trueFirst</i></code> values before\n * <code>&#x21;<i>trueFirst</i></code> values.\n * <p />\n * Clients are encouraged to use the value returned from\n * this method instead of constructing a new instance\n * to reduce allocation and garbage collection overhead when\n * multiple BooleanComparators may be used in the same\n * virtual machine.\n *\n * @param trueFirst when <code>true</code>, sort\n * <code>true</code> <code>Boolean</code>s before <code>false</code>\n * @return a singleton BooleanComparator instance\n * @since 4.0\n */\npublic static BooleanComparator booleanComparator(final boolean trueFirst) {\n    return trueFirst ? TRUE_FIRST : FALSE_FIRST;\n}"
            ],
            [
                "comparableComparator",
                "org.apache.commons.collections4.comparators",
                "ComparableComparator",
                "//-----------------------------------------------------------------------\n/**\n * Gets the singleton instance of a ComparableComparator.\n * <p>\n * Developers are encouraged to use the comparator returned from this method\n * instead of constructing a new instance to reduce allocation and GC overhead\n * when multiple comparable comparators may be used in the same VM.\n *\n * @param <E>  the element type\n * @return the singleton ComparableComparator\n * @since 4.0\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E extends Comparable<? super E>> ComparableComparator<E> comparableComparator() {\n    return INSTANCE;\n}"
            ],
            [
                "emptyCollection",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns the immutable EMPTY_COLLECTION with generic type safety.\n *\n * @see #EMPTY_COLLECTION\n * @since 4.0\n * @param <T> the element type\n * @return immutable empty collection\n */\n// OK, empty collection is compatible with any type\n@SuppressWarnings(\"unchecked\")\npublic static <T> Collection<T> emptyCollection() {\n    return EMPTY_COLLECTION;\n}"
            ],
            [
                "emptyIfNull",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns an immutable empty collection if the argument is <code>null</code>,\n * or the argument itself otherwise.\n *\n * @param <T> the element type\n * @param collection the collection, possibly <code>null</code>\n * @return an empty collection if the argument is <code>null</code>\n */\n// OK, empty collection is compatible with any type\n@SuppressWarnings(\"unchecked\")\npublic static <T> Collection<T> emptyIfNull(final Collection<T> collection) {\n    return collection == null ? EMPTY_COLLECTION : collection;\n}"
            ],
            [
                "union",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns a {@link Collection} containing the union of the given\n * {@link Iterable}s.\n * <p>\n * The cardinality of each element in the returned {@link Collection} will\n * be equal to the maximum of the cardinality of that element in the two\n * given {@link Iterable}s.\n *\n * @param a the first collection, must not be null\n * @param b the second collection, must not be null\n * @param <O> the generic type that is able to represent the types contained\n *        in both input collections.\n * @return the union of the two collections\n * @see Collection#addAll\n */\npublic static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}"
            ],
            [
                "intersection",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns a {@link Collection} containing the intersection of the given\n * {@link Iterable}s.\n * <p>\n * The cardinality of each element in the returned {@link Collection} will\n * be equal to the minimum of the cardinality of that element in the two\n * given {@link Iterable}s.\n *\n * @param a the first collection, must not be null\n * @param b the second collection, must not be null\n * @param <O> the generic type that is able to represent the types contained\n *        in both input collections.\n * @return the intersection of the two collections\n * @see Collection#retainAll\n * @see #containsAny\n */\npublic static <O> Collection<O> intersection(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.min(obj));\n    }\n    return helper.list();\n}"
            ],
            [
                "disjunction",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns a {@link Collection} containing the exclusive disjunction\n * (symmetric difference) of the given {@link Iterable}s.\n * <p>\n * The cardinality of each element <i>e</i> in the returned\n * {@link Collection} will be equal to\n * <tt>max(cardinality(<i>e</i>,<i>a</i>),cardinality(<i>e</i>,<i>b</i>)) - min(cardinality(<i>e</i>,<i>a</i>),\n * cardinality(<i>e</i>,<i>b</i>))</tt>.\n * <p>\n * This is equivalent to\n * {@code {@link #subtract subtract}({@link #union union(a,b)},{@link #intersection intersection(a,b)})}\n * or\n * {@code {@link #union union}({@link #subtract subtract(a,b)},{@link #subtract subtract(b,a)})}.\n *\n * @param a the first collection, must not be null\n * @param b the second collection, must not be null\n * @param <O> the generic type that is able to represent the types contained\n *        in both input collections.\n * @return the symmetric difference of the two collections\n */\npublic static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}"
            ],
            [
                "subtract",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns a new {@link Collection} containing {@code <i>a</i> - <i>b</i>}.\n * The cardinality of each element <i>e</i> in the returned {@link Collection}\n * will be the cardinality of <i>e</i> in <i>a</i> minus the cardinality\n * of <i>e</i> in <i>b</i>, or zero, whichever is greater.\n *\n * @param a  the collection to subtract from, must not be null\n * @param b  the collection to subtract, must not be null\n * @param <O> the generic type that is able to represent the types contained\n *        in both input collections.\n * @return a new collection with the results\n * @see Collection#removeAll\n */\npublic static <O> Collection<O> subtract(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n    final Predicate<O> p = TruePredicate.truePredicate();\n    return subtract(a, b, p);\n}"
            ],
            [
                "subtract",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns a new {@link Collection} containing <i>a</i> minus a subset of\n * <i>b</i>.  Only the elements of <i>b</i> that satisfy the predicate\n * condition, <i>p</i> are subtracted from <i>a</i>.\n *\n * <p>The cardinality of each element <i>e</i> in the returned {@link Collection}\n * that satisfies the predicate condition will be the cardinality of <i>e</i> in <i>a</i>\n * minus the cardinality of <i>e</i> in <i>b</i>, or zero, whichever is greater.</p>\n * <p>The cardinality of each element <i>e</i> in the returned {@link Collection} that does <b>not</b>\n * satisfy the predicate condition will be equal to the cardinality of <i>e</i> in <i>a</i>.</p>\n *\n * @param a  the collection to subtract from, must not be null\n * @param b  the collection to subtract, must not be null\n * @param p  the condition used to determine which elements of <i>b</i> are\n *        subtracted.\n * @param <O> the generic type that is able to represent the types contained\n *        in both input collections.\n * @return a new collection with the results\n * @since 4.0\n * @see Collection#removeAll\n */\npublic static <O> Collection<O> subtract(final Iterable<? extends O> a, final Iterable<? extends O> b, final Predicate<O> p) {\n    final ArrayList<O> list = new ArrayList<O>();\n    final HashBag<O> bag = new HashBag<O>();\n    for (final O element : b) {\n        if (p.evaluate(element)) {\n            bag.add(element);\n        }\n    }\n    for (final O element : a) {\n        if (!bag.remove(element, 1)) {\n            list.add(element);\n        }\n    }\n    return list;\n}"
            ],
            [
                "containsAll",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns <code>true</code> iff all elements of {@code coll2} are also contained\n * in {@code coll1}. The cardinality of values in {@code coll2} is not taken into account,\n * which is the same behavior as {@link Collection#containsAll(Collection)}.\n * <p>\n * In other words, this method returns <code>true</code> iff the\n * {@link #intersection} of <i>coll1</i> and <i>coll2</i> has the same cardinality as\n * the set of unique values from {@code coll2}. In case {@code coll2} is empty, {@code true}\n * will be returned.\n * <p>\n * This method is intended as a replacement for {@link Collection#containsAll(Collection)}\n * with a guaranteed runtime complexity of {@code O(n + m)}. Depending on the type of\n * {@link Collection} provided, this method will be much faster than calling\n * {@link Collection#containsAll(Collection)} instead, though this will come at the\n * cost of an additional space complexity O(n).\n *\n * @param coll1  the first collection, must not be null\n * @param coll2  the second collection, must not be null\n * @return <code>true</code> iff the intersection of the collections has the same cardinality\n *   as the set of unique elements from the second collection\n * @since 4.0\n */\npublic static boolean containsAll(final Collection<?> coll1, final Collection<?> coll2) {\n    if (coll2.isEmpty()) {\n        return true;\n    } else {\n        final Iterator<?> it = coll1.iterator();\n        final Set<Object> elementsAlreadySeen = new HashSet<Object>();\n        for (final Object nextElement : coll2) {\n            if (elementsAlreadySeen.contains(nextElement)) {\n                continue;\n            }\n            boolean foundCurrentElement = false;\n            while (it.hasNext()) {\n                final Object p = it.next();\n                elementsAlreadySeen.add(p);\n                if (nextElement == null ? p == null : nextElement.equals(p)) {\n                    foundCurrentElement = true;\n                    break;\n                }\n            }\n            if (foundCurrentElement) {\n                continue;\n            } else {\n                return false;\n            }\n        }\n        return true;\n    }\n}"
            ],
            [
                "containsAny",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns <code>true</code> iff at least one element is in both collections.\n * <p>\n * In other words, this method returns <code>true</code> iff the\n * {@link #intersection} of <i>coll1</i> and <i>coll2</i> is not empty.\n *\n * @param coll1  the first collection, must not be null\n * @param coll2  the second collection, must not be null\n * @return <code>true</code> iff the intersection of the collections is non-empty\n * @since 2.1\n * @see #intersection\n */\npublic static boolean containsAny(final Collection<?> coll1, final Collection<?> coll2) {\n    if (coll1.size() < coll2.size()) {\n        for (final Object aColl1 : coll1) {\n            if (coll2.contains(aColl1)) {\n                return true;\n            }\n        }\n    } else {\n        for (final Object aColl2 : coll2) {\n            if (coll1.contains(aColl2)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}"
            ],
            [
                "getCardinalityMap",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns a {@link Map} mapping each unique element in the given\n * {@link Collection} to an {@link Integer} representing the number\n * of occurrences of that element in the {@link Collection}.\n * <p>\n * Only those elements present in the collection will appear as\n * keys in the map.\n *\n * @param <O>  the type of object in the returned {@link Map}. This is a super type of <I>.\n * @param coll  the collection to get the cardinality map for, must not be null\n * @return the populated cardinality map\n */\npublic static <O> Map<O, Integer> getCardinalityMap(final Iterable<? extends O> coll) {\n    final Map<O, Integer> count = new HashMap<O, Integer>();\n    for (final O obj : coll) {\n        final Integer c = count.get(obj);\n        if (c == null) {\n            count.put(obj, Integer.valueOf(1));\n        } else {\n            count.put(obj, Integer.valueOf(c.intValue() + 1));\n        }\n    }\n    return count;\n}"
            ],
            [
                "isSubCollection",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns {@code true} iff <i>a</i> is a sub-collection of <i>b</i>,\n * that is, iff the cardinality of <i>e</i> in <i>a</i> is less than or\n * equal to the cardinality of <i>e</i> in <i>b</i>, for each element <i>e</i>\n * in <i>a</i>.\n *\n * @param a the first (sub?) collection, must not be null\n * @param b the second (super?) collection, must not be null\n * @return <code>true</code> iff <i>a</i> is a sub-collection of <i>b</i>\n * @see #isProperSubCollection\n * @see Collection#containsAll\n */\npublic static boolean isSubCollection(final Collection<?> a, final Collection<?> b) {\n    final CardinalityHelper<Object> helper = new CardinalityHelper<Object>(a, b);\n    for (final Object obj : a) {\n        if (helper.freqA(obj) > helper.freqB(obj)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isProperSubCollection",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns {@code true} iff <i>a</i> is a <i>proper</i> sub-collection of <i>b</i>,\n * that is, iff the cardinality of <i>e</i> in <i>a</i> is less\n * than or equal to the cardinality of <i>e</i> in <i>b</i>,\n * for each element <i>e</i> in <i>a</i>, and there is at least one\n * element <i>f</i> such that the cardinality of <i>f</i> in <i>b</i>\n * is strictly greater than the cardinality of <i>f</i> in <i>a</i>.\n * <p>\n * The implementation assumes\n * <ul>\n *    <li><code>a.size()</code> and <code>b.size()</code> represent the\n *    total cardinality of <i>a</i> and <i>b</i>, resp. </li>\n *    <li><code>a.size() < Integer.MAXVALUE</code></li>\n * </ul>\n *\n * @param a  the first (sub?) collection, must not be null\n * @param b  the second (super?) collection, must not be null\n * @return <code>true</code> iff <i>a</i> is a <i>proper</i> sub-collection of <i>b</i>\n * @see #isSubCollection\n * @see Collection#containsAll\n */\npublic static boolean isProperSubCollection(final Collection<?> a, final Collection<?> b) {\n    return a.size() < b.size() && CollectionUtils.isSubCollection(a, b);\n}"
            ],
            [
                "isEqualCollection",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns {@code true} iff the given {@link Collection}s contain\n * exactly the same elements with exactly the same cardinalities.\n * <p>\n * That is, iff the cardinality of <i>e</i> in <i>a</i> is\n * equal to the cardinality of <i>e</i> in <i>b</i>,\n * for each element <i>e</i> in <i>a</i> or <i>b</i>.\n *\n * @param a  the first collection, must not be null\n * @param b  the second collection, must not be null\n * @return <code>true</code> iff the collections contain the same elements with the same cardinalities.\n */\npublic static boolean isEqualCollection(final Collection<?> a, final Collection<?> b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n    final CardinalityHelper<Object> helper = new CardinalityHelper<Object>(a, b);\n    if (helper.cardinalityA.size() != helper.cardinalityB.size()) {\n        return false;\n    }\n    for (final Object obj : helper.cardinalityA.keySet()) {\n        if (helper.freqA(obj) != helper.freqB(obj)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isEqualCollection",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns {@code true} iff the given {@link Collection}s contain\n * exactly the same elements with exactly the same cardinalities.\n * <p>\n * That is, iff the cardinality of <i>e</i> in <i>a</i> is\n * equal to the cardinality of <i>e</i> in <i>b</i>,\n * for each element <i>e</i> in <i>a</i> or <i>b</i>.\n * <p>\n * <b>Note:</b> from version 4.1 onwards this method requires the input\n * collections and equator to be of compatible type (using bounded wildcards).\n * Providing incompatible arguments (e.g. by casting to their rawtypes)\n * will result in a {@code ClassCastException} thrown at runtime.\n *\n * @param <E>  the element type\n * @param a  the first collection, must not be null\n * @param b  the second collection, must not be null\n * @param equator  the Equator used for testing equality\n * @return <code>true</code> iff the collections contain the same elements with the same cardinalities.\n * @throws NullPointerException if the equator is null\n * @since 4.0\n */\npublic static <E> boolean isEqualCollection(final Collection<? extends E> a, final Collection<? extends E> b, final Equator<? super E> equator) {\n    if (equator == null) {\n        throw new NullPointerException(\"Equator must not be null.\");\n    }\n    if (a.size() != b.size()) {\n        return false;\n    }\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    final Transformer<E, ?> transformer = new Transformer() {\n\n        public EquatorWrapper<?> transform(final Object input) {\n            return new EquatorWrapper(equator, input);\n        }\n    };\n    return isEqualCollection(collect(a, transformer), collect(b, transformer));\n}"
            ],
            [
                "cardinality",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns the number of occurrences of <i>obj</i> in <i>coll</i>.\n *\n * @param obj the object to find the cardinality of\n * @param coll the {@link Iterable} to search\n * @param <O> the type of object that the {@link Iterable} may contain.\n * @return the the number of occurrences of obj in coll\n * @throws NullPointerException if coll is null\n * @deprecated since 4.1, use {@link IterableUtils#frequency(Iterable, Object)} instead.\n *   Be aware that the order of parameters has changed.\n */\n@Deprecated\npublic static <O> int cardinality(final O obj, final Iterable<? super O> coll) {\n    if (coll == null) {\n        throw new NullPointerException(\"coll must not be null.\");\n    }\n    return IterableUtils.frequency(coll, obj);\n}"
            ],
            [
                "find",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Finds the first element in the given collection which matches the given predicate.\n * <p>\n * If the input collection or predicate is null, or no element of the collection\n * matches the predicate, null is returned.\n *\n * @param <T>  the type of object the {@link Iterable} contains\n * @param collection  the collection to search, may be null\n * @param predicate  the predicate to use, may be null\n * @return the first element of the collection which matches the predicate or null if none could be found\n * @deprecated since 4.1, use {@link IterableUtils#find(Iterable, Predicate)} instead\n */\n@Deprecated\npublic static <T> T find(final Iterable<T> collection, final Predicate<? super T> predicate) {\n    return predicate != null ? IterableUtils.find(collection, predicate) : null;\n}"
            ],
            [
                "forAllDo",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Executes the given closure on each element in the collection.\n * <p>\n * If the input collection or closure is null, there is no change made.\n *\n * @param <T>  the type of object the {@link Iterable} contains\n * @param <C>  the closure type\n * @param collection  the collection to get the input from, may be null\n * @param closure  the closure to perform, may be null\n * @return closure\n * @deprecated since 4.1, use {@link IterableUtils#forEach(Iterable, Closure)} instead\n */\n@Deprecated\npublic static <T, C extends Closure<? super T>> C forAllDo(final Iterable<T> collection, final C closure) {\n    if (closure != null) {\n        IterableUtils.forEach(collection, closure);\n    }\n    return closure;\n}"
            ],
            [
                "forAllDo",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Executes the given closure on each element in the collection.\n * <p>\n * If the input collection or closure is null, there is no change made.\n *\n * @param <T>  the type of object the {@link Iterator} contains\n * @param <C>  the closure type\n * @param iterator  the iterator to get the input from, may be null\n * @param closure  the closure to perform, may be null\n * @return closure\n * @since 4.0\n * @deprecated since 4.1, use {@link IteratorUtils#forEach(Iterator, Closure)} instead\n */\n@Deprecated\npublic static <T, C extends Closure<? super T>> C forAllDo(final Iterator<T> iterator, final C closure) {\n    if (closure != null) {\n        IteratorUtils.forEach(iterator, closure);\n    }\n    return closure;\n}"
            ],
            [
                "forAllButLastDo",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Executes the given closure on each but the last element in the collection.\n * <p>\n * If the input collection or closure is null, there is no change made.\n *\n * @param <T>  the type of object the {@link Iterable} contains\n * @param <C>  the closure type\n * @param collection  the collection to get the input from, may be null\n * @param closure  the closure to perform, may be null\n * @return the last element in the collection, or null if either collection or closure is null\n * @since 4.0\n * @deprecated since 4.1, use {@link IterableUtils#forEachButLast(Iterable, Closure)} instead\n */\n@Deprecated\npublic static <T, C extends Closure<? super T>> T forAllButLastDo(final Iterable<T> collection, final C closure) {\n    return closure != null ? IterableUtils.forEachButLast(collection, closure) : null;\n}"
            ],
            [
                "forAllButLastDo",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Executes the given closure on each but the last element in the collection.\n * <p>\n * If the input collection or closure is null, there is no change made.\n *\n * @param <T>  the type of object the {@link Collection} contains\n * @param <C>  the closure type\n * @param iterator  the iterator to get the input from, may be null\n * @param closure  the closure to perform, may be null\n * @return the last element in the collection, or null if either iterator or closure is null\n * @since 4.0\n * @deprecated since 4.1, use {@link IteratorUtils#forEachButLast(Iterator, Closure)} instead\n */\n@Deprecated\npublic static <T, C extends Closure<? super T>> T forAllButLastDo(final Iterator<T> iterator, final C closure) {\n    return closure != null ? IteratorUtils.forEachButLast(iterator, closure) : null;\n}"
            ],
            [
                "filter",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Filter the collection by applying a Predicate to each element. If the\n * predicate returns false, remove the element.\n * <p>\n * If the input collection or predicate is null, there is no change made.\n *\n * @param <T>  the type of object the {@link Iterable} contains\n * @param collection  the collection to get the input from, may be null\n * @param predicate  the predicate to use as a filter, may be null\n * @return true if the collection is modified by this call, false otherwise.\n */\npublic static <T> boolean filter(final Iterable<T> collection, final Predicate<? super T> predicate) {\n    boolean result = false;\n    if (collection != null && predicate != null) {\n        for (final Iterator<T> it = collection.iterator(); it.hasNext(); ) {\n            if (!predicate.evaluate(it.next())) {\n                it.remove();\n                result = true;\n            }\n        }\n    }\n    return result;\n}"
            ],
            [
                "filterInverse",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Filter the collection by applying a Predicate to each element. If the\n * predicate returns true, remove the element.\n * <p>\n * This is equivalent to <pre>filter(collection, PredicateUtils.notPredicate(predicate))</pre>\n * if predicate is != null.\n * <p>\n * If the input collection or predicate is null, there is no change made.\n *\n * @param <T>  the type of object the {@link Iterable} contains\n * @param collection  the collection to get the input from, may be null\n * @param predicate  the predicate to use as a filter, may be null\n * @return true if the collection is modified by this call, false otherwise.\n */\npublic static <T> boolean filterInverse(final Iterable<T> collection, final Predicate<? super T> predicate) {\n    return filter(collection, predicate == null ? null : PredicateUtils.notPredicate(predicate));\n}"
            ],
            [
                "countMatches",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Counts the number of elements in the input collection that match the\n * predicate.\n * <p>\n * A <code>null</code> collection or predicate matches no elements.\n *\n * @param <C>  the type of object the {@link Iterable} contains\n * @param input  the {@link Iterable} to get the input from, may be null\n * @param predicate  the predicate to use, may be null\n * @return the number of matches for the predicate in the collection\n * @deprecated since 4.1, use {@link IterableUtils#countMatches(Iterable, Predicate)} instead\n */\n@Deprecated\npublic static <C> int countMatches(final Iterable<C> input, final Predicate<? super C> predicate) {\n    return predicate == null ? 0 : (int) IterableUtils.countMatches(input, predicate);\n}"
            ],
            [
                "exists",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Answers true if a predicate is true for at least one element of a\n * collection.\n * <p>\n * A <code>null</code> collection or predicate returns false.\n *\n * @param <C>  the type of object the {@link Iterable} contains\n * @param input  the {@link Iterable} to get the input from, may be null\n * @param predicate  the predicate to use, may be null\n * @return true if at least one element of the collection matches the predicate\n * @deprecated since 4.1, use {@link IterableUtils#matchesAny(Iterable, Predicate)} instead\n */\n@Deprecated\npublic static <C> boolean exists(final Iterable<C> input, final Predicate<? super C> predicate) {\n    return predicate == null ? false : IterableUtils.matchesAny(input, predicate);\n}"
            ],
            [
                "matchesAll",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Answers true if a predicate is true for every element of a\n * collection.\n * <p>\n * A <code>null</code> predicate returns false.<br/>\n * A <code>null</code> or empty collection returns true.\n *\n * @param <C>  the type of object the {@link Iterable} contains\n * @param input  the {@link Iterable} to get the input from, may be null\n * @param predicate  the predicate to use, may be null\n * @return true if every element of the collection matches the predicate or if the\n * collection is empty, false otherwise\n * @since 4.0\n * @deprecated since 4.1, use {@link IterableUtils#matchesAll(Iterable, Predicate)} instead\n */\n@Deprecated\npublic static <C> boolean matchesAll(final Iterable<C> input, final Predicate<? super C> predicate) {\n    return predicate == null ? false : IterableUtils.matchesAll(input, predicate);\n}"
            ],
            [
                "select",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Selects all elements from input collection which match the given\n * predicate into an output collection.\n * <p>\n * A <code>null</code> predicate matches no elements.\n *\n * @param <O>  the type of object the {@link Iterable} contains\n * @param inputCollection  the collection to get the input from, may not be null\n * @param predicate  the predicate to use, may be null\n * @return the elements matching the predicate (new list)\n * @throws NullPointerException if the input collection is null\n */\npublic static <O> Collection<O> select(final Iterable<? extends O> inputCollection, final Predicate<? super O> predicate) {\n    final Collection<O> answer = inputCollection instanceof Collection<?> ? new ArrayList<O>(((Collection<?>) inputCollection).size()) : new ArrayList<O>();\n    return select(inputCollection, predicate, answer);\n}"
            ],
            [
                "select",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Selects all elements from input collection which match the given\n * predicate and adds them to outputCollection.\n * <p>\n * If the input collection or predicate is null, there is no change to the\n * output collection.\n *\n * @param <O>  the type of object the {@link Iterable} contains\n * @param <R>  the type of the output {@link Collection}\n * @param inputCollection  the collection to get the input from, may be null\n * @param predicate  the predicate to use, may be null\n * @param outputCollection  the collection to output into, may not be null if the inputCollection\n *   and predicate or not null\n * @return the outputCollection\n */\npublic static <O, R extends Collection<? super O>> R select(final Iterable<? extends O> inputCollection, final Predicate<? super O> predicate, final R outputCollection) {\n    if (inputCollection != null && predicate != null) {\n        for (final O item : inputCollection) {\n            if (predicate.evaluate(item)) {\n                outputCollection.add(item);\n            }\n        }\n    }\n    return outputCollection;\n}"
            ],
            [
                "select",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Selects all elements from inputCollection into an output and rejected collection,\n * based on the evaluation of the given predicate.\n * <p>\n * Elements matching the predicate are added to the <code>outputCollection</code>,\n * all other elements are added to the <code>rejectedCollection</code>.\n * <p>\n * If the input predicate is <code>null</code>, no elements are added to\n * <code>outputCollection</code> or <code>rejectedCollection</code>.\n * <p>\n * Note: calling the method is equivalent to the following code snippet:\n * <pre>\n *   select(inputCollection, predicate, outputCollection);\n *   selectRejected(inputCollection, predicate, rejectedCollection);\n * </pre>\n *\n * @param <O>  the type of object the {@link Iterable} contains\n * @param <R>  the type of the output {@link Collection}\n * @param inputCollection  the collection to get the input from, may be null\n * @param predicate  the predicate to use, may be null\n * @param outputCollection  the collection to output selected elements into, may not be null if the\n *   inputCollection and predicate are not null\n * @param rejectedCollection  the collection to output rejected elements into, may not be null if the\n *   inputCollection or predicate are not null\n * @return the outputCollection\n * @since 4.1\n */\npublic static <O, R extends Collection<? super O>> R select(final Iterable<? extends O> inputCollection, final Predicate<? super O> predicate, R outputCollection, R rejectedCollection) {\n    if (inputCollection != null && predicate != null) {\n        for (final O element : inputCollection) {\n            if (predicate.evaluate(element)) {\n                outputCollection.add(element);\n            } else {\n                rejectedCollection.add(element);\n            }\n        }\n    }\n    return outputCollection;\n}"
            ],
            [
                "selectRejected",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Selects all elements from inputCollection which don't match the given\n * predicate into an output collection.\n * <p>\n * If the input predicate is <code>null</code>, the result is an empty\n * list.\n *\n * @param <O>  the type of object the {@link Iterable} contains\n * @param inputCollection  the collection to get the input from, may not be null\n * @param predicate  the predicate to use, may be null\n * @return the elements <b>not</b> matching the predicate (new list)\n * @throws NullPointerException if the input collection is null\n */\npublic static <O> Collection<O> selectRejected(final Iterable<? extends O> inputCollection, final Predicate<? super O> predicate) {\n    final Collection<O> answer = inputCollection instanceof Collection<?> ? new ArrayList<O>(((Collection<?>) inputCollection).size()) : new ArrayList<O>();\n    return selectRejected(inputCollection, predicate, answer);\n}"
            ],
            [
                "selectRejected",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Selects all elements from inputCollection which don't match the given\n * predicate and adds them to outputCollection.\n * <p>\n * If the input predicate is <code>null</code>, no elements are added to\n * <code>outputCollection</code>.\n *\n * @param <O>  the type of object the {@link Iterable} contains\n * @param <R>  the type of the output {@link Collection}\n * @param inputCollection  the collection to get the input from, may be null\n * @param predicate  the predicate to use, may be null\n * @param outputCollection  the collection to output into, may not be null if the inputCollection\n *   and predicate or not null\n * @return outputCollection\n */\npublic static <O, R extends Collection<? super O>> R selectRejected(final Iterable<? extends O> inputCollection, final Predicate<? super O> predicate, final R outputCollection) {\n    if (inputCollection != null && predicate != null) {\n        for (final O item : inputCollection) {\n            if (!predicate.evaluate(item)) {\n                outputCollection.add(item);\n            }\n        }\n    }\n    return outputCollection;\n}"
            ],
            [
                "collect",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns a new Collection containing all elements of the input collection\n * transformed by the given transformer.\n * <p>\n * If the input collection or transformer is null, the result is an empty list.\n *\n * @param <I>  the type of object in the input collection\n * @param <O>  the type of object in the output collection\n * @param inputCollection  the collection to get the input from, may not be null\n * @param transformer  the transformer to use, may be null\n * @return the transformed result (new list)\n * @throws NullPointerException if the input collection is null\n */\npublic static <I, O> Collection<O> collect(final Iterable<I> inputCollection, final Transformer<? super I, ? extends O> transformer) {\n    final Collection<O> answer = inputCollection instanceof Collection<?> ? new ArrayList<O>(((Collection<?>) inputCollection).size()) : new ArrayList<O>();\n    return collect(inputCollection, transformer, answer);\n}"
            ],
            [
                "collect",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Transforms all elements from the input iterator with the given transformer\n * and adds them to the output collection.\n * <p>\n * If the input iterator or transformer is null, the result is an empty list.\n *\n * @param <I>  the type of object in the input collection\n * @param <O>  the type of object in the output collection\n * @param inputIterator  the iterator to get the input from, may be null\n * @param transformer  the transformer to use, may be null\n * @return the transformed result (new list)\n */\npublic static <I, O> Collection<O> collect(final Iterator<I> inputIterator, final Transformer<? super I, ? extends O> transformer) {\n    return collect(inputIterator, transformer, new ArrayList<O>());\n}"
            ],
            [
                "collect",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Transforms all elements from input collection with the given transformer\n * and adds them to the output collection.\n * <p>\n * If the input collection or transformer is null, there is no change to the\n * output collection.\n *\n * @param <I>  the type of object in the input collection\n * @param <O>  the type of object in the output collection\n * @param <R>  the type of the output collection\n * @param inputCollection  the collection to get the input from, may be null\n * @param transformer  the transformer to use, may be null\n * @param outputCollection  the collection to output into, may not be null if inputCollection\n *   and transformer are not null\n * @return the output collection with the transformed input added\n * @throws NullPointerException if the outputCollection is null and both, inputCollection and\n *   transformer are not null\n */\npublic static <I, O, R extends Collection<? super O>> R collect(final Iterable<? extends I> inputCollection, final Transformer<? super I, ? extends O> transformer, final R outputCollection) {\n    if (inputCollection != null) {\n        return collect(inputCollection.iterator(), transformer, outputCollection);\n    }\n    return outputCollection;\n}"
            ],
            [
                "collect",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Transforms all elements from the input iterator with the given transformer\n * and adds them to the output collection.\n * <p>\n * If the input iterator or transformer is null, there is no change to the\n * output collection.\n *\n * @param <I>  the type of object in the input collection\n * @param <O>  the type of object in the output collection\n * @param <R>  the type of the output collection\n * @param inputIterator  the iterator to get the input from, may be null\n * @param transformer  the transformer to use, may be null\n * @param outputCollection  the collection to output into, may not be null if inputIterator\n *   and transformer are not null\n * @return the outputCollection with the transformed input added\n * @throws NullPointerException if the output collection is null and both, inputIterator and\n *   transformer are not null\n */\npublic static <I, O, R extends Collection<? super O>> R collect(final Iterator<? extends I> inputIterator, final Transformer<? super I, ? extends O> transformer, final R outputCollection) {\n    if (inputIterator != null && transformer != null) {\n        while (inputIterator.hasNext()) {\n            final I item = inputIterator.next();\n            final O value = transformer.transform(item);\n            outputCollection.add(value);\n        }\n    }\n    return outputCollection;\n}"
            ],
            [
                "addIgnoreNull",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "//-----------------------------------------------------------------------\n/**\n * Adds an element to the collection unless the element is null.\n *\n * @param <T>  the type of object the {@link Collection} contains\n * @param collection  the collection to add to, must not be null\n * @param object  the object to add, if null it will not be added\n * @return true if the collection changed\n * @throws NullPointerException if the collection is null\n * @since 3.2\n */\npublic static <T> boolean addIgnoreNull(final Collection<T> collection, final T object) {\n    if (collection == null) {\n        throw new NullPointerException(\"The collection must not be null\");\n    }\n    return object != null && collection.add(object);\n}"
            ],
            [
                "addAll",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Adds all elements in the {@link Iterable} to the given collection. If the\n * {@link Iterable} is a {@link Collection} then it is cast and will be\n * added using {@link Collection#addAll(Collection)} instead of iterating.\n *\n * @param <C>  the type of object the {@link Collection} contains\n * @param collection  the collection to add to, must not be null\n * @param iterable  the iterable of elements to add, must not be null\n * @return a boolean indicating whether the collection has changed or not.\n * @throws NullPointerException if the collection or iterator is null\n */\npublic static <C> boolean addAll(final Collection<C> collection, final Iterable<? extends C> iterable) {\n    if (iterable instanceof Collection<?>) {\n        return collection.addAll((Collection<? extends C>) iterable);\n    }\n    return addAll(collection, iterable.iterator());\n}"
            ],
            [
                "addAll",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Adds all elements in the iteration to the given collection.\n *\n * @param <C>  the type of object the {@link Collection} contains\n * @param collection  the collection to add to, must not be null\n * @param iterator  the iterator of elements to add, must not be null\n * @return a boolean indicating whether the collection has changed or not.\n * @throws NullPointerException if the collection or iterator is null\n */\npublic static <C> boolean addAll(final Collection<C> collection, final Iterator<? extends C> iterator) {\n    boolean changed = false;\n    while (iterator.hasNext()) {\n        changed |= collection.add(iterator.next());\n    }\n    return changed;\n}"
            ],
            [
                "addAll",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Adds all elements in the enumeration to the given collection.\n *\n * @param <C>  the type of object the {@link Collection} contains\n * @param collection  the collection to add to, must not be null\n * @param enumeration  the enumeration of elements to add, must not be null\n * @return {@code true} if the collections was changed, {@code false} otherwise\n * @throws NullPointerException if the collection or enumeration is null\n */\npublic static <C> boolean addAll(final Collection<C> collection, final Enumeration<? extends C> enumeration) {\n    boolean changed = false;\n    while (enumeration.hasMoreElements()) {\n        changed |= collection.add(enumeration.nextElement());\n    }\n    return changed;\n}"
            ],
            [
                "addAll",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Adds all elements in the array to the given collection.\n *\n * @param <C>  the type of object the {@link Collection} contains\n * @param collection  the collection to add to, must not be null\n * @param elements  the array of elements to add, must not be null\n * @return {@code true} if the collection was changed, {@code false} otherwise\n * @throws NullPointerException if the collection or array is null\n */\npublic static <C> boolean addAll(final Collection<C> collection, final C[] elements) {\n    boolean changed = false;\n    for (final C element : elements) {\n        changed |= collection.add(element);\n    }\n    return changed;\n}"
            ],
            [
                "get",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns the <code>index</code>-th value in {@link Iterator}, throwing\n * <code>IndexOutOfBoundsException</code> if there is no such element.\n * <p>\n * The Iterator is advanced to <code>index</code> (or to the end, if\n * <code>index</code> exceeds the number of entries) as a side effect of this method.\n *\n * @param iterator  the iterator to get a value from\n * @param index  the index to get\n * @param <T> the type of object in the {@link Iterator}\n * @return the object at the specified index\n * @throws IndexOutOfBoundsException if the index is invalid\n * @throws IllegalArgumentException if the object type is invalid\n * @deprecated since 4.1, use {@code IteratorUtils.get(Iterator, int)} instead\n */\n@Deprecated\npublic static <T> T get(final Iterator<T> iterator, final int index) {\n    return IteratorUtils.get(iterator, index);\n}"
            ],
            [
                "get",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns the <code>index</code>-th value in the <code>iterable</code>'s {@link Iterator}, throwing\n * <code>IndexOutOfBoundsException</code> if there is no such element.\n * <p>\n * If the {@link Iterable} is a {@link List}, then it will use {@link List#get(int)}.\n *\n * @param iterable  the {@link Iterable} to get a value from\n * @param index  the index to get\n * @param <T> the type of object in the {@link Iterable}.\n * @return the object at the specified index\n * @throws IndexOutOfBoundsException if the index is invalid\n * @deprecated since 4.1, use {@code IterableUtils.get(Iterable, int)} instead\n */\n@Deprecated\npublic static <T> T get(final Iterable<T> iterable, final int index) {\n    return IterableUtils.get(iterable, index);\n}"
            ],
            [
                "get",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns the <code>index</code>-th value in <code>object</code>, throwing\n * <code>IndexOutOfBoundsException</code> if there is no such element or\n * <code>IllegalArgumentException</code> if <code>object</code> is not an\n * instance of one of the supported types.\n * <p>\n * The supported types, and associated semantics are:\n * <ul>\n * <li> Map -- the value returned is the <code>Map.Entry</code> in position\n *      <code>index</code> in the map's <code>entrySet</code> iterator,\n *      if there is such an entry.</li>\n * <li> List -- this method is equivalent to the list's get method.</li>\n * <li> Array -- the <code>index</code>-th array entry is returned,\n *      if there is such an entry; otherwise an <code>IndexOutOfBoundsException</code>\n *      is thrown.</li>\n * <li> Collection -- the value returned is the <code>index</code>-th object\n *      returned by the collection's default iterator, if there is such an element.</li>\n * <li> Iterator or Enumeration -- the value returned is the\n *      <code>index</code>-th object in the Iterator/Enumeration, if there\n *      is such an element.  The Iterator/Enumeration is advanced to\n *      <code>index</code> (or to the end, if <code>index</code> exceeds the\n *      number of entries) as a side effect of this method.</li>\n * </ul>\n *\n * @param object  the object to get a value from\n * @param index  the index to get\n * @return the object at the specified index\n * @throws IndexOutOfBoundsException if the index is invalid\n * @throws IllegalArgumentException if the object type is invalid\n */\npublic static Object get(final Object object, final int index) {\n    int i = index;\n    if (i < 0) {\n        throw new IndexOutOfBoundsException(\"Index cannot be negative: \" + i);\n    }\n    if (object instanceof Map<?, ?>) {\n        final Map<?, ?> map = (Map<?, ?>) object;\n        final Iterator<?> iterator = map.entrySet().iterator();\n        return IteratorUtils.get(iterator, i);\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object)[i];\n    } else if (object instanceof Iterator<?>) {\n        final Iterator<?> it = (Iterator<?>) object;\n        return IteratorUtils.get(it, i);\n    } else if (object instanceof Iterable<?>) {\n        final Iterable<?> iterable = (Iterable<?>) object;\n        return IterableUtils.get(iterable, i);\n    } else if (object instanceof Collection<?>) {\n        final Iterator<?> iterator = ((Collection<?>) object).iterator();\n        return IteratorUtils.get(iterator, i);\n    } else if (object instanceof Enumeration<?>) {\n        final Enumeration<?> it = (Enumeration<?>) object;\n        return EnumerationUtils.get(it, i);\n    } else if (object == null) {\n        throw new IllegalArgumentException(\"Unsupported object type: null\");\n    } else {\n        try {\n            return Array.get(object, i);\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}"
            ],
            [
                "get",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns the <code>index</code>-th <code>Map.Entry</code> in the <code>map</code>'s <code>entrySet</code>,\n * throwing <code>IndexOutOfBoundsException</code> if there is no such element.\n *\n * @param <K>  the key type in the {@link Map}\n * @param <V>  the key type in the {@link Map}\n * @param map  the object to get a value from\n * @param index  the index to get\n * @return the object at the specified index\n * @throws IndexOutOfBoundsException if the index is invalid\n */\npublic static <K, V> Map.Entry<K, V> get(final Map<K, V> map, final int index) {\n    checkIndexBounds(index);\n    return get(map.entrySet(), index);\n}"
            ],
            [
                "size",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Gets the size of the collection/iterator specified.\n * <p>\n * This method can handles objects as follows\n * <ul>\n * <li>Collection - the collection size\n * <li>Map - the map size\n * <li>Array - the array size\n * <li>Iterator - the number of elements remaining in the iterator\n * <li>Enumeration - the number of elements remaining in the enumeration\n * </ul>\n *\n * @param object  the object to get the size of, may be null\n * @return the size of the specified collection or 0 if the object was null\n * @throws IllegalArgumentException thrown if object is not recognised\n * @since 3.1\n */\npublic static int size(final Object object) {\n    if (object == null) {\n        return 0;\n    }\n    int total = 0;\n    if (object instanceof Map<?, ?>) {\n        total = ((Map<?, ?>) object).size();\n    } else if (object instanceof Collection<?>) {\n        total = ((Collection<?>) object).size();\n    } else if (object instanceof Iterable<?>) {\n        total = IterableUtils.size((Iterable<?>) object);\n    } else if (object instanceof Object[]) {\n        total = ((Object[]) object).length;\n    } else if (object instanceof Iterator<?>) {\n        total = IteratorUtils.size((Iterator<?>) object);\n    } else if (object instanceof Enumeration<?>) {\n        final Enumeration<?> it = (Enumeration<?>) object;\n        while (it.hasMoreElements()) {\n            total++;\n            it.nextElement();\n        }\n    } else {\n        try {\n            total = Array.getLength(object);\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n    return total;\n}"
            ],
            [
                "sizeIsEmpty",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Checks if the specified collection/array/iterator is empty.\n * <p>\n * This method can handles objects as follows\n * <ul>\n * <li>Collection - via collection isEmpty\n * <li>Map - via map isEmpty\n * <li>Array - using array size\n * <li>Iterator - via hasNext\n * <li>Enumeration - via hasMoreElements\n * </ul>\n * <p>\n * Note: This method is named to avoid clashing with\n * {@link #isEmpty(Collection)}.\n *\n * @param object  the object to get the size of, may be null\n * @return true if empty or null\n * @throws IllegalArgumentException thrown if object is not recognised\n * @since 3.2\n */\npublic static boolean sizeIsEmpty(final Object object) {\n    if (object == null) {\n        return true;\n    } else if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Iterable<?>) {\n        return IterableUtils.isEmpty((Iterable<?>) object);\n    } else if (object instanceof Map<?, ?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return ((Iterator<?>) object).hasNext() == false;\n    } else if (object instanceof Enumeration<?>) {\n        return ((Enumeration<?>) object).hasMoreElements() == false;\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}"
            ],
            [
                "isEmpty",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "//-----------------------------------------------------------------------\n/**\n * Null-safe check if the specified collection is empty.\n * <p>\n * Null returns true.\n *\n * @param coll  the collection to check, may be null\n * @return true if empty or null\n * @since 3.2\n */\npublic static boolean isEmpty(final Collection<?> coll) {\n    return coll == null || coll.isEmpty();\n}"
            ],
            [
                "isNotEmpty",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Null-safe check if the specified collection is not empty.\n * <p>\n * Null returns false.\n *\n * @param coll  the collection to check, may be null\n * @return true if non-null and non-empty\n * @since 3.2\n */\npublic static boolean isNotEmpty(final Collection<?> coll) {\n    return !isEmpty(coll);\n}"
            ],
            [
                "isFull",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns true if no more elements can be added to the Collection.\n * <p>\n * This method uses the {@link BoundedCollection} interface to determine the\n * full status. If the collection does not implement this interface then\n * false is returned.\n * <p>\n * The collection does not have to implement this interface directly.\n * If the collection has been decorated using the decorators subpackage\n * then these will be removed to access the BoundedCollection.\n *\n * @param coll  the collection to check\n * @return true if the BoundedCollection is full\n * @throws NullPointerException if the collection is null\n */\npublic static boolean isFull(final Collection<? extends Object> coll) {\n    if (coll == null) {\n        throw new NullPointerException(\"The collection must not be null\");\n    }\n    if (coll instanceof BoundedCollection) {\n        return ((BoundedCollection<?>) coll).isFull();\n    }\n    try {\n        final BoundedCollection<?> bcoll = UnmodifiableBoundedCollection.unmodifiableBoundedCollection(coll);\n        return bcoll.isFull();\n    } catch (final IllegalArgumentException ex) {\n        return false;\n    }\n}"
            ],
            [
                "maxSize",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Get the maximum number of elements that the Collection can contain.\n * <p>\n * This method uses the {@link BoundedCollection} interface to determine the\n * maximum size. If the collection does not implement this interface then\n * -1 is returned.\n * <p>\n * The collection does not have to implement this interface directly.\n * If the collection has been decorated using the decorators subpackage\n * then these will be removed to access the BoundedCollection.\n *\n * @param coll  the collection to check\n * @return the maximum size of the BoundedCollection, -1 if no maximum size\n * @throws NullPointerException if the collection is null\n */\npublic static int maxSize(final Collection<? extends Object> coll) {\n    if (coll == null) {\n        throw new NullPointerException(\"The collection must not be null\");\n    }\n    if (coll instanceof BoundedCollection) {\n        return ((BoundedCollection<?>) coll).maxSize();\n    }\n    try {\n        final BoundedCollection<?> bcoll = UnmodifiableBoundedCollection.unmodifiableBoundedCollection(coll);\n        return bcoll.maxSize();\n    } catch (final IllegalArgumentException ex) {\n        return -1;\n    }\n}"
            ],
            [
                "collate",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "//-----------------------------------------------------------------------\n/**\n * Merges two sorted Collections, a and b, into a single, sorted List\n * such that the natural ordering of the elements is retained.\n * <p>\n * Uses the standard O(n) merge algorithm for combining two sorted lists.\n *\n * @param <O>  the element type\n * @param a  the first collection, must not be null\n * @param b  the second collection, must not be null\n * @return a new sorted List, containing the elements of Collection a and b\n * @throws NullPointerException if either collection is null\n * @since 4.0\n */\npublic static <O extends Comparable<? super O>> List<O> collate(Iterable<? extends O> a, Iterable<? extends O> b) {\n    return collate(a, b, ComparatorUtils.<O>naturalComparator(), true);\n}"
            ],
            [
                "collate",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Merges two sorted Collections, a and b, into a single, sorted List\n * such that the natural ordering of the elements is retained.\n * <p>\n * Uses the standard O(n) merge algorithm for combining two sorted lists.\n *\n * @param <O>  the element type\n * @param a  the first collection, must not be null\n * @param b  the second collection, must not be null\n * @param includeDuplicates  if {@code true} duplicate elements will be retained, otherwise\n *   they will be removed in the output collection\n * @return a new sorted List, containing the elements of Collection a and b\n * @throws NullPointerException if either collection is null\n * @since 4.0\n */\npublic static <O extends Comparable<? super O>> List<O> collate(final Iterable<? extends O> a, final Iterable<? extends O> b, final boolean includeDuplicates) {\n    return collate(a, b, ComparatorUtils.<O>naturalComparator(), includeDuplicates);\n}"
            ],
            [
                "collate",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Merges two sorted Collections, a and b, into a single, sorted List\n * such that the ordering of the elements according to Comparator c is retained.\n * <p>\n * Uses the standard O(n) merge algorithm for combining two sorted lists.\n *\n * @param <O>  the element type\n * @param a  the first collection, must not be null\n * @param b  the second collection, must not be null\n * @param c  the comparator to use for the merge.\n * @return a new sorted List, containing the elements of Collection a and b\n * @throws NullPointerException if either collection or the comparator is null\n * @since 4.0\n */\npublic static <O> List<O> collate(final Iterable<? extends O> a, final Iterable<? extends O> b, final Comparator<? super O> c) {\n    return collate(a, b, c, true);\n}"
            ],
            [
                "collate",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Merges two sorted Collections, a and b, into a single, sorted List\n * such that the ordering of the elements according to Comparator c is retained.\n * <p>\n * Uses the standard O(n) merge algorithm for combining two sorted lists.\n *\n * @param <O>  the element type\n * @param a  the first collection, must not be null\n * @param b  the second collection, must not be null\n * @param c  the comparator to use for the merge.\n * @param includeDuplicates  if {@code true} duplicate elements will be retained, otherwise\n *   they will be removed in the output collection\n * @return a new sorted List, containing the elements of Collection a and b\n * @throws NullPointerException if either collection or the comparator is null\n * @since 4.0\n */\npublic static <O> List<O> collate(final Iterable<? extends O> a, final Iterable<? extends O> b, final Comparator<? super O> c, final boolean includeDuplicates) {\n    if (a == null || b == null) {\n        throw new NullPointerException(\"The collections must not be null\");\n    }\n    if (c == null) {\n        throw new NullPointerException(\"The comparator must not be null\");\n    }\n    // if both Iterables are a Collection, we can estimate the size\n    final int totalSize = a instanceof Collection<?> && b instanceof Collection<?> ? Math.max(1, ((Collection<?>) a).size() + ((Collection<?>) b).size()) : 10;\n    final Iterator<O> iterator = new CollatingIterator<O>(c, a.iterator(), b.iterator());\n    if (includeDuplicates) {\n        return IteratorUtils.toList(iterator, totalSize);\n    } else {\n        final ArrayList<O> mergedList = new ArrayList<O>(totalSize);\n        O lastItem = null;\n        while (iterator.hasNext()) {\n            final O item = iterator.next();\n            if (lastItem == null || !lastItem.equals(item)) {\n                mergedList.add(item);\n            }\n            lastItem = item;\n        }\n        mergedList.trimToSize();\n        return mergedList;\n    }\n}"
            ],
            [
                "permutations",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns a {@link Collection} of all the permutations of the input collection.\n * <p>\n * NOTE: the number of permutations of a given collection is equal to n!, where\n * n is the size of the collection. Thus, the resulting collection will become\n * <b>very</b> large for collections &gt; 10 (e.g. 10! = 3628800, 15! = 1307674368000).\n * <p>\n * For larger collections it is advised to use a {@link PermutationIterator} to\n * iterate over all permutations.\n *\n * @see PermutationIterator\n *\n * @param <E>  the element type\n * @param collection  the collection to create permutations for, may not be null\n * @return an unordered collection of all permutations of the input collection\n * @throws NullPointerException if collection is null\n * @since 4.0\n */\npublic static <E> Collection<List<E>> permutations(final Collection<E> collection) {\n    final PermutationIterator<E> it = new PermutationIterator<E>(collection);\n    final Collection<List<E>> result = new LinkedList<List<E>>();\n    while (it.hasNext()) {\n        result.add(it.next());\n    }\n    return result;\n}"
            ],
            [
                "retainAll",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns a collection containing all the elements in <code>collection</code>\n * that are also in <code>retain</code>. The cardinality of an element <code>e</code>\n * in the returned collection is the same as the cardinality of <code>e</code>\n * in <code>collection</code> unless <code>retain</code> does not contain <code>e</code>, in which\n * case the cardinality is zero. This method is useful if you do not wish to modify\n * the collection <code>c</code> and thus cannot call <code>c.retainAll(retain);</code>.\n * <p>\n * This implementation iterates over <code>collection</code>, checking each element in\n * turn to see if it's contained in <code>retain</code>. If it's contained, it's added\n * to the returned list. As a consequence, it is advised to use a collection type for\n * <code>retain</code> that provides a fast (e.g. O(1)) implementation of\n * {@link Collection#contains(Object)}.\n *\n * @param <C>  the type of object the {@link Collection} contains\n * @param collection  the collection whose contents are the target of the #retailAll operation\n * @param retain  the collection containing the elements to be retained in the returned collection\n * @return a <code>Collection</code> containing all the elements of <code>collection</code>\n * that occur at least once in <code>retain</code>.\n * @throws NullPointerException if either parameter is null\n * @since 3.2\n */\npublic static <C> Collection<C> retainAll(final Collection<C> collection, final Collection<?> retain) {\n    return ListUtils.retainAll(collection, retain);\n}"
            ],
            [
                "retainAll",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns a collection containing all the elements in\n * <code>collection</code> that are also in <code>retain</code>. The\n * cardinality of an element <code>e</code> in the returned collection is\n * the same as the cardinality of <code>e</code> in <code>collection</code>\n * unless <code>retain</code> does not contain <code>e</code>, in which case\n * the cardinality is zero. This method is useful if you do not wish to\n * modify the collection <code>c</code> and thus cannot call\n * <code>c.retainAll(retain);</code>.\n * <p>\n * Moreover this method uses an {@link Equator} instead of\n * {@link Object#equals(Object)} to determine the equality of the elements\n * in <code>collection</code> and <code>retain</code>. Hence this method is\n * useful in cases where the equals behavior of an object needs to be\n * modified without changing the object itself.\n *\n * @param <E> the type of object the {@link Collection} contains\n * @param collection the collection whose contents are the target of the {@code retainAll} operation\n * @param retain the collection containing the elements to be retained in the returned collection\n * @param equator the Equator used for testing equality\n * @return a <code>Collection</code> containing all the elements of <code>collection</code>\n * that occur at least once in <code>retain</code> according to the <code>equator</code>\n * @throws NullPointerException if any of the parameters is null\n * @since 4.1\n */\npublic static <E> Collection<E> retainAll(final Iterable<E> collection, final Iterable<? extends E> retain, final Equator<? super E> equator) {\n    final Transformer<E, EquatorWrapper<E>> transformer = new Transformer<E, EquatorWrapper<E>>() {\n\n        public EquatorWrapper<E> transform(E input) {\n            return new EquatorWrapper<E>(equator, input);\n        }\n    };\n    final Set<EquatorWrapper<E>> retainSet = collect(retain, transformer, new HashSet<EquatorWrapper<E>>());\n    final List<E> list = new ArrayList<E>();\n    for (final E element : collection) {\n        if (retainSet.contains(new EquatorWrapper<E>(equator, element))) {\n            list.add(element);\n        }\n    }\n    return list;\n}"
            ],
            [
                "removeAll",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Removes the elements in <code>remove</code> from <code>collection</code>. That is, this\n * method returns a collection containing all the elements in <code>c</code>\n * that are not in <code>remove</code>. The cardinality of an element <code>e</code>\n * in the returned collection is the same as the cardinality of <code>e</code>\n * in <code>collection</code> unless <code>remove</code> contains <code>e</code>, in which\n * case the cardinality is zero. This method is useful if you do not wish to modify\n * the collection <code>c</code> and thus cannot call <code>collection.removeAll(remove);</code>.\n * <p>\n * This implementation iterates over <code>collection</code>, checking each element in\n * turn to see if it's contained in <code>remove</code>. If it's not contained, it's added\n * to the returned list. As a consequence, it is advised to use a collection type for\n * <code>remove</code> that provides a fast (e.g. O(1)) implementation of\n * {@link Collection#contains(Object)}.\n *\n * @param <E>  the type of object the {@link Collection} contains\n * @param collection  the collection from which items are removed (in the returned collection)\n * @param remove  the items to be removed from the returned <code>collection</code>\n * @return a <code>Collection</code> containing all the elements of <code>collection</code> except\n * any elements that also occur in <code>remove</code>.\n * @throws NullPointerException if either parameter is null\n * @since 4.0 (method existed in 3.2 but was completely broken)\n */\npublic static <E> Collection<E> removeAll(final Collection<E> collection, final Collection<?> remove) {\n    return ListUtils.removeAll(collection, remove);\n}"
            ],
            [
                "removeAll",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Removes all elements in <code>remove</code> from <code>collection</code>.\n * That is, this method returns a collection containing all the elements in\n * <code>collection</code> that are not in <code>remove</code>. The\n * cardinality of an element <code>e</code> in the returned collection is\n * the same as the cardinality of <code>e</code> in <code>collection</code>\n * unless <code>remove</code> contains <code>e</code>, in which case the\n * cardinality is zero. This method is useful if you do not wish to modify\n * the collection <code>c</code> and thus cannot call\n * <code>collection.removeAll(remove)</code>.\n * <p>\n * Moreover this method uses an {@link Equator} instead of\n * {@link Object#equals(Object)} to determine the equality of the elements\n * in <code>collection</code> and <code>remove</code>. Hence this method is\n * useful in cases where the equals behavior of an object needs to be\n * modified without changing the object itself.\n *\n * @param <E> the type of object the {@link Collection} contains\n * @param collection the collection from which items are removed (in the returned collection)\n * @param remove the items to be removed from the returned collection\n * @param equator the Equator used for testing equality\n * @return a <code>Collection</code> containing all the elements of <code>collection</code>\n * except any element that if equal according to the <code>equator</code>\n * @throws NullPointerException if any of the parameters is null\n * @since 4.1\n */\npublic static <E> Collection<E> removeAll(final Iterable<E> collection, final Iterable<? extends E> remove, final Equator<? super E> equator) {\n    final Transformer<E, EquatorWrapper<E>> transformer = new Transformer<E, EquatorWrapper<E>>() {\n\n        public EquatorWrapper<E> transform(E input) {\n            return new EquatorWrapper<E>(equator, input);\n        }\n    };\n    final Set<EquatorWrapper<E>> removeSet = collect(remove, transformer, new HashSet<EquatorWrapper<E>>());\n    final List<E> list = new ArrayList<E>();\n    for (final E element : collection) {\n        if (!removeSet.contains(new EquatorWrapper<E>(equator, element))) {\n            list.add(element);\n        }\n    }\n    return list;\n}"
            ],
            [
                "synchronizedCollection",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns a synchronized collection backed by the given collection.\n * <p>\n * You must manually synchronize on the returned buffer's iterator to\n * avoid non-deterministic behavior:\n *\n * <pre>\n * Collection c = CollectionUtils.synchronizedCollection(myCollection);\n * synchronized (c) {\n *     Iterator i = c.iterator();\n *     while (i.hasNext()) {\n *         process (i.next());\n *     }\n * }\n * </pre>\n *\n * This method uses the implementation in the decorators subpackage.\n *\n * @param <C>  the type of object the {@link Collection} contains\n * @param collection  the collection to synchronize, must not be null\n * @return a synchronized collection backed by the given collection\n * @throws NullPointerException if the collection is null\n * @deprecated since 4.1, use {@link java.util.Collections#synchronizedCollection(Collection)} instead\n */\n@Deprecated\npublic static <C> Collection<C> synchronizedCollection(final Collection<C> collection) {\n    return SynchronizedCollection.synchronizedCollection(collection);\n}"
            ],
            [
                "unmodifiableCollection",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns an unmodifiable collection backed by the given collection.\n * <p>\n * This method uses the implementation in the decorators subpackage.\n *\n * @param <C>  the type of object the {@link Collection} contains\n * @param collection  the collection to make unmodifiable, must not be null\n * @return an unmodifiable collection backed by the given collection\n * @throws NullPointerException if the collection is null\n * @deprecated since 4.1, use {@link java.util.Collections#unmodifiableCollection(Collection)} instead\n */\n@Deprecated\npublic static <C> Collection<C> unmodifiableCollection(final Collection<? extends C> collection) {\n    return UnmodifiableCollection.unmodifiableCollection(collection);\n}"
            ],
            [
                "predicatedCollection",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns a predicated (validating) collection backed by the given collection.\n * <p>\n * Only objects that pass the test in the given predicate can be added to the collection.\n * Trying to add an invalid object results in an IllegalArgumentException.\n * It is important not to use the original collection after invoking this method,\n * as it is a backdoor for adding invalid objects.\n *\n * @param <C> the type of objects in the Collection.\n * @param collection  the collection to predicate, must not be null\n * @param predicate  the predicate for the collection, must not be null\n * @return a predicated collection backed by the given collection\n * @throws NullPointerException if the Collection is null\n */\npublic static <C> Collection<C> predicatedCollection(final Collection<C> collection, final Predicate<? super C> predicate) {\n    return PredicatedCollection.predicatedCollection(collection, predicate);\n}"
            ],
            [
                "transformingCollection",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns a transformed bag backed by the given collection.\n * <p>\n * Each object is passed through the transformer as it is added to the\n * Collection. It is important not to use the original collection after invoking this\n * method, as it is a backdoor for adding untransformed objects.\n * <p>\n * Existing entries in the specified collection will not be transformed.\n * If you want that behaviour, see {@link TransformedCollection#transformedCollection}.\n *\n * @param <E> the type of object the {@link Collection} contains\n * @param collection  the collection to predicate, must not be null\n * @param transformer  the transformer for the collection, must not be null\n * @return a transformed collection backed by the given collection\n * @throws NullPointerException if the Collection or Transformer is null\n */\npublic static <E> Collection<E> transformingCollection(final Collection<E> collection, final Transformer<? super E, ? extends E> transformer) {\n    return TransformedCollection.transformingCollection(collection, transformer);\n}"
            ],
            [
                "extractSingleton",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Extract the lone element of the specified Collection.\n * @param <E> collection type\n * @param collection to read\n * @return sole member of collection\n * @throws NullPointerException if collection is null\n * @throws IllegalArgumentException if collection is empty or contains more than one element\n * @since 4.0\n */\npublic static <E> E extractSingleton(final Collection<E> collection) {\n    if (collection == null) {\n        throw new NullPointerException(\"Collection must not be null.\");\n    }\n    if (collection.size() != 1) {\n        throw new IllegalArgumentException(\"Can extract singleton only when collection size == 1\");\n    }\n    return collection.iterator().next();\n}"
            ],
            [
                "transformingMap",
                "org.apache.commons.collections4.splitmap",
                "TransformedSplitMap",
                "/**\n * Factory method to create a transforming map.\n * <p>\n * If there are any elements already in the map being decorated, they are\n * NOT transformed.\n *\n * @param <J>  the input key type\n * @param <K>  the output key type\n * @param <U>  the input value type\n * @param <V>  the output value type\n * @param map the map to decorate, must not be null\n * @param keyTransformer the transformer to use for key conversion, must not be null\n * @param valueTransformer the transformer to use for value conversion, must not be null\n * @return a new transformed map\n * @throws NullPointerException if map or either of the transformers is null\n */\npublic static <J, K, U, V> TransformedSplitMap<J, K, U, V> transformingMap(final Map<K, V> map, final Transformer<? super J, ? extends K> keyTransformer, final Transformer<? super U, ? extends V> valueTransformer) {\n    return new TransformedSplitMap<J, K, U, V>(map, keyTransformer, valueTransformer);\n}"
            ],
            [
                "emptyIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Empty\n// ----------------------------------------------------------------------\n/**\n * Gets an empty iterable.\n * <p>\n * This iterable does not contain any elements.\n *\n * @param <E> the element type\n * @return an empty iterable\n */\n// OK, empty collection is compatible with any type\n@SuppressWarnings(\"unchecked\")\npublic static <E> Iterable<E> emptyIterable() {\n    return EMPTY_ITERABLE;\n}"
            ],
            [
                "chainedIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Chained\n// ----------------------------------------------------------------------\n/**\n * Combines two iterables into a single iterable.\n * <p>\n * The returned iterable has an iterator that traverses the elements in {@code a},\n * followed by the elements in {@code b}. The source iterators are not polled until\n * necessary.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the corresponding\n * input iterator supports it.\n *\n * @param <E> the element type\n * @param a  the first iterable, may not be null\n * @param b  the second iterable, may not be null\n * @return a new iterable, combining the provided iterables\n * @throws NullPointerException if either a or b is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Iterable<E> chainedIterable(final Iterable<? extends E> a, final Iterable<? extends E> b) {\n    return chainedIterable(new Iterable[] { a, b });\n}"
            ],
            [
                "chainedIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Combines three iterables into a single iterable.\n * <p>\n * The returned iterable has an iterator that traverses the elements in {@code a},\n * followed by the elements in {@code b} and {@code c}. The source iterators are\n * not polled until necessary.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the corresponding\n * input iterator supports it.\n *\n * @param <E> the element type\n * @param a  the first iterable, may not be null\n * @param b  the second iterable, may not be null\n * @param c  the third iterable, may not be null\n * @return a new iterable, combining the provided iterables\n * @throws NullPointerException if either of the provided iterables is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Iterable<E> chainedIterable(final Iterable<? extends E> a, final Iterable<? extends E> b, final Iterable<? extends E> c) {\n    return chainedIterable(new Iterable[] { a, b, c });\n}"
            ],
            [
                "chainedIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Combines four iterables into a single iterable.\n * <p>\n * The returned iterable has an iterator that traverses the elements in {@code a},\n * followed by the elements in {@code b}, {@code c} and {@code d}. The source\n * iterators are not polled until necessary.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the corresponding\n * input iterator supports it.\n *\n * @param <E> the element type\n * @param a  the first iterable, may not be null\n * @param b  the second iterable, may not be null\n * @param c  the third iterable, may not be null\n * @param d  the fourth iterable, may not be null\n * @return a new iterable, combining the provided iterables\n * @throws NullPointerException if either of the provided iterables is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Iterable<E> chainedIterable(final Iterable<? extends E> a, final Iterable<? extends E> b, final Iterable<? extends E> c, final Iterable<? extends E> d) {\n    return chainedIterable(new Iterable[] { a, b, c, d });\n}"
            ],
            [
                "chainedIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Combines the provided iterables into a single iterable.\n * <p>\n * The returned iterable has an iterator that traverses the elements in the order\n * of the arguments, i.e. iterables[0], iterables[1], .... The source iterators\n * are not polled until necessary.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the corresponding\n * input iterator supports it.\n *\n * @param <E> the element type\n * @param iterables  the iterables to combine, may not be null\n * @return a new iterable, combining the provided iterables\n * @throws NullPointerException if either of the provided iterables is null\n */\npublic static <E> Iterable<E> chainedIterable(final Iterable<? extends E>... iterables) {\n    checkNotNull(iterables);\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            return new LazyIteratorChain<E>() {\n\n                @Override\n                protected Iterator<? extends E> nextIterator(int count) {\n                    if (count > iterables.length) {\n                        return null;\n                    } else {\n                        return iterables[count - 1].iterator();\n                    }\n                }\n            };\n        }\n    };\n}"
            ],
            [
                "collatedIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Collated\n// ----------------------------------------------------------------------\n/**\n * Combines the two provided iterables into an ordered iterable using\n * natural ordering.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the\n * corresponding input iterator supports it.\n *\n * @param <E> the element type\n * @param a  the first iterable, may not be null\n * @param b  the second iterable, may not be null\n * @return a filtered view on the specified iterable\n * @throws NullPointerException if either of the provided iterables is null\n */\npublic static <E> Iterable<E> collatedIterable(final Iterable<? extends E> a, final Iterable<? extends E> b) {\n    checkNotNull(a, b);\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            return IteratorUtils.collatedIterator(null, a.iterator(), b.iterator());\n        }\n    };\n}"
            ],
            [
                "collatedIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Combines the two provided iterables into an ordered iterable using the\n * provided comparator. If the comparator is null, natural ordering will be\n * used.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the\n * corresponding input iterator supports it.\n *\n * @param <E> the element type\n * @param comparator  the comparator defining an ordering over the elements,\n *   may be null, in which case natural ordering will be used\n * @param a  the first iterable, may not be null\n * @param b  the second iterable, may not be null\n * @return a filtered view on the specified iterable\n * @throws NullPointerException if either of the provided iterables is null\n */\npublic static <E> Iterable<E> collatedIterable(final Comparator<? super E> comparator, final Iterable<? extends E> a, final Iterable<? extends E> b) {\n    checkNotNull(a, b);\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            return IteratorUtils.collatedIterator(comparator, a.iterator(), b.iterator());\n        }\n    };\n}"
            ],
            [
                "filteredIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Filtered\n// ----------------------------------------------------------------------\n/**\n * Returns a view of the given iterable that only contains elements matching\n * the provided predicate.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the\n * corresponding input iterator supports it.\n *\n * @param <E> the element type\n * @param iterable  the iterable to filter, may not be null\n * @param predicate  the predicate used to filter elements, may not be null\n * @return a filtered view on the specified iterable\n * @throws NullPointerException if either iterable or predicate is null\n */\npublic static <E> Iterable<E> filteredIterable(final Iterable<E> iterable, final Predicate<? super E> predicate) {\n    checkNotNull(iterable);\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null.\");\n    }\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            return IteratorUtils.filteredIterator(emptyIteratorIfNull(iterable), predicate);\n        }\n    };\n}"
            ],
            [
                "boundedIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Bounded\n// ----------------------------------------------------------------------\n/**\n * Returns a view of the given iterable that contains at most the given number\n * of elements.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the corresponding\n * input iterator supports it.\n *\n * @param <E> the element type\n * @param iterable  the iterable to limit, may not be null\n * @param maxSize  the maximum number of elements, must not be negative\n * @return a bounded view on the specified iterable\n * @throws IllegalArgumentException if maxSize is negative\n * @throws NullPointerException if iterable is null\n */\npublic static <E> Iterable<E> boundedIterable(final Iterable<E> iterable, final long maxSize) {\n    checkNotNull(iterable);\n    if (maxSize < 0) {\n        throw new IllegalArgumentException(\"MaxSize parameter must not be negative.\");\n    }\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            return IteratorUtils.boundedIterator(iterable.iterator(), maxSize);\n        }\n    };\n}"
            ],
            [
                "loopingIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Looping\n// ----------------------------------------------------------------------\n/**\n * Returns a view of the given iterable which will cycle infinitely over\n * its elements.\n * <p>\n * The returned iterable's iterator supports {@code remove()} if\n * {@code iterable.iterator()} does. After {@code remove()} is called, subsequent\n * cycles omit the removed element, which is no longer in {@code iterable}. The\n * iterator's {@code hasNext()} method returns {@code true} until {@code iterable}\n * is empty.\n *\n * @param <E> the element type\n * @param iterable  the iterable to loop, may not be null\n * @return a view of the iterable, providing an infinite loop over its elements\n * @throws NullPointerException if iterable is null\n */\npublic static <E> Iterable<E> loopingIterable(final Iterable<E> iterable) {\n    checkNotNull(iterable);\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            return new LazyIteratorChain<E>() {\n\n                @Override\n                protected Iterator<? extends E> nextIterator(int count) {\n                    if (IterableUtils.isEmpty(iterable)) {\n                        return null;\n                    } else {\n                        return iterable.iterator();\n                    }\n                }\n            };\n        }\n    };\n}"
            ],
            [
                "reversedIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Reversed\n// ----------------------------------------------------------------------\n/**\n * Returns a reversed view of the given iterable.\n * <p>\n * In case the provided iterable is a {@link List} instance, a\n * {@link ReverseListIterator} will be used to reverse the traversal\n * order, otherwise an intermediate {@link List} needs to be created.\n * <p>\n * The returned iterable's iterator supports {@code remove()} if the\n * provided iterable is a {@link List} instance.\n *\n * @param <E> the element type\n * @param iterable  the iterable to use, may not be null\n * @return a reversed view of the specified iterable\n * @throws NullPointerException if iterable is null\n * @see ReverseListIterator\n */\npublic static <E> Iterable<E> reversedIterable(final Iterable<E> iterable) {\n    checkNotNull(iterable);\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            final List<E> list = (iterable instanceof List<?>) ? (List<E>) iterable : IteratorUtils.toList(iterable.iterator());\n            return new ReverseListIterator<E>(list);\n        }\n    };\n}"
            ],
            [
                "skippingIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Skipping\n// ----------------------------------------------------------------------\n/**\n * Returns a view of the given iterable that skips the first N elements.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the corresponding\n * input iterator supports it.\n *\n * @param <E> the element type\n * @param iterable  the iterable to use, may not be null\n * @param elementsToSkip  the number of elements to skip from the start, must not be negative\n * @return a view of the specified iterable, skipping the first N elements\n * @throws IllegalArgumentException if elementsToSkip is negative\n * @throws NullPointerException if iterable is null\n */\npublic static <E> Iterable<E> skippingIterable(final Iterable<E> iterable, final long elementsToSkip) {\n    checkNotNull(iterable);\n    if (elementsToSkip < 0) {\n        throw new IllegalArgumentException(\"ElementsToSkip parameter must not be negative.\");\n    }\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            return IteratorUtils.skippingIterator(iterable.iterator(), elementsToSkip);\n        }\n    };\n}"
            ],
            [
                "transformedIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Transformed\n// ----------------------------------------------------------------------\n/**\n * Returns a transformed view of the given iterable where all of its elements\n * have been transformed by the provided transformer.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the corresponding\n * input iterator supports it.\n *\n * @param <I>  the input element type\n * @param <O>  the output element type\n * @param iterable  the iterable to transform, may not be null\n * @param transformer  the transformer, must not be null\n * @return a transformed view of the specified iterable\n * @throws NullPointerException if either iterable or transformer is null\n */\npublic static <I, O> Iterable<O> transformedIterable(final Iterable<I> iterable, final Transformer<? super I, ? extends O> transformer) {\n    checkNotNull(iterable);\n    if (transformer == null) {\n        throw new NullPointerException(\"Transformer must not be null.\");\n    }\n    return new FluentIterable<O>() {\n\n        @Override\n        public Iterator<O> iterator() {\n            return IteratorUtils.transformedIterator(iterable.iterator(), transformer);\n        }\n    };\n}"
            ],
            [
                "uniqueIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Unique\n// ----------------------------------------------------------------------\n/**\n * Returns a unique view of the given iterable.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the\n * corresponding input iterator supports it. Calling {@code remove()}\n * will only remove a single element from the underlying iterator.\n *\n * @param <E> the element type\n * @param iterable  the iterable to use, may not be null\n * @return a unique view of the specified iterable\n * @throws NullPointerException if iterable is null\n */\npublic static <E> Iterable<E> uniqueIterable(final Iterable<E> iterable) {\n    checkNotNull(iterable);\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            return new UniqueFilterIterator<E>(iterable.iterator());\n        }\n    };\n}"
            ],
            [
                "unmodifiableIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Unmodifiable\n// ----------------------------------------------------------------------\n/**\n * Returns an unmodifiable view of the given iterable.\n * <p>\n * The returned iterable's iterator does not support {@code remove()}.\n *\n * @param <E> the element type\n * @param iterable  the iterable to use, may not be null\n * @return an unmodifiable view of the specified iterable\n * @throws NullPointerException if iterable is null\n */\npublic static <E> Iterable<E> unmodifiableIterable(final Iterable<E> iterable) {\n    checkNotNull(iterable);\n    if (iterable instanceof UnmodifiableIterable<?>) {\n        return iterable;\n    }\n    return new UnmodifiableIterable<E>(iterable);\n}"
            ],
            [
                "zippingIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Zipping\n// ----------------------------------------------------------------------\n/**\n * Interleaves two iterables into a single iterable.\n * <p>\n * The returned iterable has an iterator that traverses the elements in {@code a}\n * and {@code b} in alternating order. The source iterators are not polled until\n * necessary.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the corresponding\n * input iterator supports it.\n *\n * @param <E> the element type\n * @param a  the first iterable, may not be null\n * @param b  the second iterable, may not be null\n * @return a new iterable, interleaving the provided iterables\n * @throws NullPointerException if either a or b is null\n */\npublic static <E> Iterable<E> zippingIterable(final Iterable<? extends E> a, final Iterable<? extends E> b) {\n    checkNotNull(a);\n    checkNotNull(b);\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            return IteratorUtils.zippingIterator(a.iterator(), b.iterator());\n        }\n    };\n}"
            ],
            [
                "zippingIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Interleaves two iterables into a single iterable.\n * <p>\n * The returned iterable has an iterator that traverses the elements in {@code a}\n * and {@code b} in alternating order. The source iterators are not polled until\n * necessary.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the corresponding\n * input iterator supports it.\n *\n * @param <E> the element type\n * @param first  the first iterable, may not be null\n * @param others  the array of iterables to interleave, may not be null\n * @return a new iterable, interleaving the provided iterables\n * @throws NullPointerException if either of the provided iterables is null\n */\npublic static <E> Iterable<E> zippingIterable(final Iterable<? extends E> first, final Iterable<? extends E>... others) {\n    checkNotNull(first);\n    checkNotNull(others);\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            // safe\n            @SuppressWarnings(\"unchecked\")\n            Iterator<? extends E>[] iterators = new Iterator[others.length + 1];\n            iterators[0] = first.iterator();\n            for (int i = 0; i < others.length; i++) {\n                iterators[i + 1] = others[i].iterator();\n            }\n            return IteratorUtils.zippingIterator(iterators);\n        }\n    };\n}"
            ],
            [
                "emptyIfNull",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Utility methods\n// ----------------------------------------------------------------------\n/**\n * Returns an immutable empty iterable if the argument is null,\n * or the argument itself otherwise.\n *\n * @param <E> the element type\n * @param iterable  the iterable, may be null\n * @return an empty iterable if the argument is null\n */\npublic static <E> Iterable<E> emptyIfNull(final Iterable<E> iterable) {\n    return iterable == null ? IterableUtils.<E>emptyIterable() : iterable;\n}"
            ],
            [
                "forEachButLast",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Executes the given closure on each but the last element in the iterable.\n * <p>\n * If the input iterable is null no change is made.\n *\n * @param <E> the type of object the {@link Iterable} contains\n * @param iterable  the iterable to get the input from, may be null\n * @param closure  the closure to perform, may not be null\n * @return the last element in the iterable, or null if iterable is null or empty\n */\npublic static <E> E forEachButLast(final Iterable<E> iterable, final Closure<? super E> closure) {\n    return IteratorUtils.forEachButLast(emptyIteratorIfNull(iterable), closure);\n}"
            ],
            [
                "find",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Finds the first element in the given iterable which matches the given predicate.\n * <p>\n * A <code>null</code> or empty iterator returns null.\n *\n * @param <E> the element type\n * @param iterable  the iterable to search, may be null\n * @param predicate  the predicate to use, may not be null\n * @return the first element of the iterable which matches the predicate or null if none could be found\n * @throws NullPointerException if predicate is null\n */\npublic static <E> E find(final Iterable<E> iterable, final Predicate<? super E> predicate) {\n    return IteratorUtils.find(emptyIteratorIfNull(iterable), predicate);\n}"
            ],
            [
                "indexOf",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Returns the index of the first element in the specified iterable that\n * matches the given predicate.\n * <p>\n * A <code>null</code> or empty iterable returns -1.\n *\n * @param <E> the element type\n * @param iterable  the iterable to search, may be null\n * @param predicate  the predicate to use, may not be null\n * @return the index of the first element which matches the predicate or -1 if none matches\n * @throws NullPointerException if predicate is null\n */\npublic static <E> int indexOf(final Iterable<E> iterable, final Predicate<? super E> predicate) {\n    return IteratorUtils.indexOf(emptyIteratorIfNull(iterable), predicate);\n}"
            ],
            [
                "matchesAll",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Answers true if a predicate is true for every element of an iterable.\n * <p>\n * A <code>null</code> or empty iterable returns true.\n *\n * @param <E> the type of object the {@link Iterable} contains\n * @param iterable  the {@link Iterable} to use, may be null\n * @param predicate  the predicate to use, may not be null\n * @return true if every element of the collection matches the predicate or if the\n *   collection is empty, false otherwise\n * @throws NullPointerException if predicate is null\n */\npublic static <E> boolean matchesAll(final Iterable<E> iterable, final Predicate<? super E> predicate) {\n    return IteratorUtils.matchesAll(emptyIteratorIfNull(iterable), predicate);\n}"
            ],
            [
                "matchesAny",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Answers true if a predicate is true for any element of the iterable.\n * <p>\n * A <code>null</code> or empty iterable returns false.\n *\n * @param <E> the type of object the {@link Iterable} contains\n * @param iterable  the {@link Iterable} to use, may be null\n * @param predicate  the predicate to use, may not be null\n * @return true if any element of the collection matches the predicate, false otherwise\n * @throws NullPointerException if predicate is null\n */\npublic static <E> boolean matchesAny(final Iterable<E> iterable, final Predicate<? super E> predicate) {\n    return IteratorUtils.matchesAny(emptyIteratorIfNull(iterable), predicate);\n}"
            ],
            [
                "countMatches",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Counts the number of elements in the input iterable that match the predicate.\n * <p>\n * A <code>null</code> iterable matches no elements.\n *\n * @param <E> the type of object the {@link Iterable} contains\n * @param input  the {@link Iterable} to get the input from, may be null\n * @param predicate  the predicate to use, may not be null\n * @return the number of matches for the predicate in the collection\n * @throws NullPointerException if predicate is null\n */\npublic static <E> long countMatches(final Iterable<E> input, final Predicate<? super E> predicate) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null.\");\n    }\n    return size(filteredIterable(emptyIfNull(input), predicate));\n}"
            ],
            [
                "isEmpty",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Answers true if the provided iterable is empty.\n * <p>\n * A <code>null</code> iterable returns true.\n *\n * @param iterable  the {@link Iterable to use}, may be null\n * @return true if the iterable is null or empty, false otherwise\n */\npublic static boolean isEmpty(final Iterable<?> iterable) {\n    if (iterable instanceof Collection<?>) {\n        return ((Collection<?>) iterable).isEmpty();\n    } else {\n        return IteratorUtils.isEmpty(emptyIteratorIfNull(iterable));\n    }\n}"
            ],
            [
                "contains",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Checks if the object is contained in the given iterable.\n * <p>\n * A <code>null</code> or empty iterable returns false.\n *\n * @param <E> the type of object the {@link Iterable} contains\n * @param iterable  the iterable to check, may be null\n * @param object  the object to check\n * @return true if the object is contained in the iterable, false otherwise\n */\npublic static <E> boolean contains(final Iterable<E> iterable, final Object object) {\n    if (iterable instanceof Collection<?>) {\n        return ((Collection<E>) iterable).contains(object);\n    } else {\n        return IteratorUtils.contains(emptyIteratorIfNull(iterable), object);\n    }\n}"
            ],
            [
                "contains",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Checks if the object is contained in the given iterable. Object equality\n * is tested with an {@code equator} unlike {@link #contains(Iterable, Object)}\n * which uses {@link Object#equals(Object)}.\n * <p>\n * A <code>null</code> or empty iterable returns false.\n * A <code>null</code> object will not be passed to the equator, instead a\n * {@link org.apache.commons.collections4.functors.NullPredicate NullPredicate}\n * will be used.\n *\n * @param <E> the type of object the {@link Iterable} contains\n * @param iterable  the iterable to check, may be null\n * @param object  the object to check\n * @param equator  the equator to use to check, may not be null\n * @return true if the object is contained in the iterable, false otherwise\n * @throws NullPointerException if equator is null\n */\npublic static <E> boolean contains(final Iterable<? extends E> iterable, final E object, final Equator<? super E> equator) {\n    if (equator == null) {\n        throw new NullPointerException(\"Equator must not be null.\");\n    }\n    return matchesAny(iterable, EqualPredicate.equalPredicate(object, equator));\n}"
            ],
            [
                "frequency",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Returns the number of occurrences of the provided object in the iterable.\n *\n * @param <E> the element type that the {@link Iterable} may contain\n * @param <T> the element type of the object to find\n * @param iterable  the {@link Iterable} to search\n * @param obj  the object to find the cardinality of\n * @return the the number of occurrences of obj in iterable\n */\npublic static <E, T extends E> int frequency(final Iterable<E> iterable, final T obj) {\n    if (iterable instanceof Set<?>) {\n        return ((Set<E>) iterable).contains(obj) ? 1 : 0;\n    }\n    if (iterable instanceof Bag<?>) {\n        return ((Bag<E>) iterable).getCount(obj);\n    }\n    return size(filteredIterable(emptyIfNull(iterable), EqualPredicate.<E>equalPredicate(obj)));\n}"
            ],
            [
                "get",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Returns the <code>index</code>-th value in the <code>iterable</code>'s {@link Iterator}, throwing\n * <code>IndexOutOfBoundsException</code> if there is no such element.\n * <p>\n * If the {@link Iterable} is a {@link List}, then it will use {@link List#get(int)}.\n *\n * @param <T> the type of object in the {@link Iterable}.\n * @param iterable  the {@link Iterable} to get a value from, may be null\n * @param index  the index to get\n * @return the object at the specified index\n * @throws IndexOutOfBoundsException if the index is invalid\n */\npublic static <T> T get(final Iterable<T> iterable, final int index) {\n    CollectionUtils.checkIndexBounds(index);\n    if (iterable instanceof List<?>) {\n        return ((List<T>) iterable).get(index);\n    }\n    return IteratorUtils.get(emptyIteratorIfNull(iterable), index);\n}"
            ],
            [
                "size",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Returns the number of elements contained in the given iterator.\n * <p>\n * A <code>null</code> or empty iterator returns {@code 0}.\n *\n * @param iterable  the iterable to check, may be null\n * @return the number of elements contained in the iterable\n */\npublic static int size(final Iterable<?> iterable) {\n    if (iterable instanceof Collection<?>) {\n        return ((Collection<?>) iterable).size();\n    } else {\n        return IteratorUtils.size(emptyIteratorIfNull(iterable));\n    }\n}"
            ],
            [
                "partition",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Partitions all elements from iterable into separate output collections,\n * based on the evaluation of the given predicate.\n * <p>\n * For each predicate, the result will contain a list holding all elements of the\n * input iterable matching the predicate. The last list will hold all elements\n * which didn't match any predicate:\n * <pre>\n *  [C1, R] = partition(I, P1) with\n *  I = input\n *  P1 = first predicate\n *  C1 = collection of elements matching P1\n *  R = collection of elements rejected by all predicates\n * </pre>\n * <p>\n * If the input iterable is <code>null</code>, the same is returned as for an\n * empty iterable.\n * <p>\n * Example: for an input list [1, 2, 3, 4, 5] calling partition with a predicate [x &lt; 3]\n * will result in the following output: [[1, 2], [3, 4, 5]].\n *\n * @param <O>  the type of object the {@link Iterable} contains\n * @param iterable  the iterable to partition, may be null\n * @param predicate  the predicate to use, may not be null\n * @return a list containing the output collections\n * @throws NullPointerException if predicate is null\n */\npublic static <O> List<List<O>> partition(final Iterable<? extends O> iterable, final Predicate<? super O> predicate) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null.\");\n    }\n    // safe\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    final Factory<List<O>> factory = FactoryUtils.instantiateFactory((Class) ArrayList.class);\n    // safe\n    @SuppressWarnings(\"unchecked\")\n    final Predicate<? super O>[] predicates = new Predicate[] { predicate };\n    return partition(iterable, factory, predicates);\n}"
            ],
            [
                "partition",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Partitions all elements from iterable into separate output collections,\n * based on the evaluation of the given predicates.\n * <p>\n * For each predicate, the result will contain a list holding all elements of the\n * input iterable matching the predicate. The last list will hold all elements\n * which didn't match any predicate:\n * <pre>\n *  [C1, C2, R] = partition(I, P1, P2) with\n *  I = input\n *  P1 = first predicate\n *  P2 = second predicate\n *  C1 = collection of elements matching P1\n *  C2 = collection of elements matching P2\n *  R = collection of elements rejected by all predicates\n * </pre>\n * <p>\n * <b>Note</b>: elements are only added to the output collection of the first matching\n * predicate, determined by the order of arguments.\n * <p>\n * If the input iterable is <code>null</code>, the same is returned as for an\n * empty iterable.\n * <p>\n * Example: for an input list [1, 2, 3, 4, 5] calling partition with predicates [x &lt; 3]\n * and [x &lt; 5] will result in the following output: [[1, 2], [3, 4], [5]].\n *\n * @param <O>  the type of object the {@link Iterable} contains\n * @param iterable  the collection to get the input from, may be null\n * @param predicates  the predicates to use, may not be null\n * @return a list containing the output collections\n * @throws NullPointerException if any predicate is null\n */\npublic static <O> List<List<O>> partition(final Iterable<? extends O> iterable, final Predicate<? super O>... predicates) {\n    // safe\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    final Factory<List<O>> factory = FactoryUtils.instantiateFactory((Class) ArrayList.class);\n    return partition(iterable, factory, predicates);\n}"
            ],
            [
                "partition",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Partitions all elements from iterable into separate output collections,\n * based on the evaluation of the given predicates.\n * <p>\n * For each predicate, the returned list will contain a collection holding\n * all elements of the input iterable matching the predicate. The last collection\n * contained in the list will hold all elements which didn't match any predicate:\n * <pre>\n *  [C1, C2, R] = partition(I, P1, P2) with\n *  I = input\n *  P1 = first predicate\n *  P2 = second predicate\n *  C1 = collection of elements matching P1\n *  C2 = collection of elements matching P2\n *  R = collection of elements rejected by all predicates\n * </pre>\n * <p>\n * <b>Note</b>: elements are only added to the output collection of the first matching\n * predicate, determined by the order of arguments.\n * <p>\n * If the input iterable is <code>null</code>, the same is returned as for an\n * empty iterable.\n * If no predicates have been provided, all elements of the input collection\n * will be added to the rejected collection.\n * <p>\n * Example: for an input list [1, 2, 3, 4, 5] calling partition with predicates [x &lt; 3]\n * and [x &lt; 5] will result in the following output: [[1, 2], [3, 4], [5]].\n *\n * @param <O>  the type of object the {@link Iterable} contains\n * @param <R>  the type of the output {@link Collection}\n * @param iterable  the collection to get the input from, may be null\n * @param partitionFactory  the factory used to create the output collections\n * @param predicates  the predicates to use, may not be null\n * @return a list containing the output collections\n * @throws NullPointerException if any predicate is null\n */\npublic static <O, R extends Collection<O>> List<R> partition(final Iterable<? extends O> iterable, final Factory<R> partitionFactory, final Predicate<? super O>... predicates) {\n    if (iterable == null) {\n        final Iterable<O> empty = emptyIterable();\n        return partition(empty, partitionFactory, predicates);\n    }\n    if (predicates == null) {\n        throw new NullPointerException(\"Predicates must not be null.\");\n    }\n    for (Predicate<?> p : predicates) {\n        if (p == null) {\n            throw new NullPointerException(\"Predicate must not be null.\");\n        }\n    }\n    if (predicates.length < 1) {\n        // return the entire input collection as a single partition\n        final R singlePartition = partitionFactory.create();\n        CollectionUtils.addAll(singlePartition, iterable);\n        return Collections.singletonList(singlePartition);\n    }\n    // create the empty partitions\n    final int numberOfPredicates = predicates.length;\n    final int numberOfPartitions = numberOfPredicates + 1;\n    final List<R> partitions = new ArrayList<R>(numberOfPartitions);\n    for (int i = 0; i < numberOfPartitions; ++i) {\n        partitions.add(partitionFactory.create());\n    }\n    // for each element in inputCollection:\n    // find the first predicate that evaluates to true.\n    // if there is a predicate, add the element to the corresponding partition.\n    // if there is no predicate, add it to the last, catch-all partition.\n    for (final O element : iterable) {\n        boolean elementAssigned = false;\n        for (int i = 0; i < numberOfPredicates; ++i) {\n            if (predicates[i].evaluate(element)) {\n                partitions.get(i).add(element);\n                elementAssigned = true;\n                break;\n            }\n        }\n        if (!elementAssigned) {\n            // no predicates evaluated to true\n            // add element to last partition\n            partitions.get(numberOfPredicates).add(element);\n        }\n    }\n    return partitions;\n}"
            ],
            [
                "toList",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Gets a new list with the contents of the provided iterable.\n *\n * @param <E> the element type\n * @param iterable  the iterable to use, may be null\n * @return a list of the iterator contents\n */\npublic static <E> List<E> toList(final Iterable<E> iterable) {\n    return IteratorUtils.toList(emptyIteratorIfNull(iterable));\n}"
            ],
            [
                "toString",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Returns a string representation of the elements of the specified iterable.\n * <p>\n * The string representation consists of a list of the iterable's elements,\n * enclosed in square brackets ({@code \"[]\"}). Adjacent elements are separated\n * by the characters {@code \", \"} (a comma followed by a space). Elements are\n * converted to strings as by {@code String.valueOf(Object)}.\n *\n * @param <E> the element type\n * @param iterable  the iterable to convert to a string, may be null\n * @return a string representation of {@code iterable}\n */\npublic static <E> String toString(final Iterable<E> iterable) {\n    return IteratorUtils.toString(emptyIteratorIfNull(iterable));\n}"
            ],
            [
                "toString",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Returns a string representation of the elements of the specified iterable.\n * <p>\n * The string representation consists of a list of the iterable's elements,\n * enclosed in square brackets ({@code \"[]\"}). Adjacent elements are separated\n * by the characters {@code \", \"} (a comma followed by a space). Elements are\n * converted to strings as by using the provided {@code transformer}.\n *\n * @param <E> the element type\n * @param iterable  the iterable to convert to a string, may be null\n * @param transformer  the transformer used to get a string representation of an element\n * @return a string representation of {@code iterable}\n * @throws NullPointerException if {@code transformer} is null\n */\npublic static <E> String toString(final Iterable<E> iterable, final Transformer<? super E, String> transformer) {\n    if (transformer == null) {\n        throw new NullPointerException(\"Transformer must not be null.\");\n    }\n    return IteratorUtils.toString(emptyIteratorIfNull(iterable), transformer);\n}"
            ],
            [
                "toString",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Returns a string representation of the elements of the specified iterable.\n * <p>\n * The string representation consists of a list of the iterable's elements,\n * enclosed by the provided {@code prefix} and {@code suffix}. Adjacent elements\n * are separated by the provided {@code delimiter}. Elements are converted to\n * strings as by using the provided {@code transformer}.\n *\n * @param <E> the element type\n * @param iterable  the iterable to convert to a string, may be null\n * @param transformer  the transformer used to get a string representation of an element\n * @param delimiter  the string to delimit elements\n * @param prefix  the prefix, prepended to the string representation\n * @param suffix  the suffix, appended to the string representation\n * @return a string representation of {@code iterable}\n * @throws NullPointerException if either transformer, delimiter, prefix or suffix is null\n */\npublic static <E> String toString(final Iterable<E> iterable, final Transformer<? super E, String> transformer, final String delimiter, final String prefix, final String suffix) {\n    return IteratorUtils.toString(emptyIteratorIfNull(iterable), transformer, delimiter, prefix, suffix);\n}"
            ],
            [
                "unmodifiableTrie",
                "org.apache.commons.collections4",
                "TrieUtils",
                "/**\n * Returns an unmodifiable instance of a {@link Trie}\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param trie  the trie to make unmodifiable, must not be null\n * @return an unmodifiable trie backed by the given trie\n * @throws NullPointerException if trie is null\n *\n * @see java.util.Collections#unmodifiableMap(java.util.Map)\n */\npublic static <K, V> Trie<K, V> unmodifiableTrie(final Trie<K, ? extends V> trie) {\n    return UnmodifiableTrie.unmodifiableTrie(trie);\n}"
            ],
            [
                "exceptionClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Gets a Closure that always throws an exception.\n * This could be useful during testing as a placeholder.\n *\n * @see org.apache.commons.collections4.functors.ExceptionClosure\n *\n * @param <E>  the type that the closure acts on\n * @return the closure\n */\npublic static <E> Closure<E> exceptionClosure() {\n    return ExceptionClosure.<E>exceptionClosure();\n}"
            ],
            [
                "nopClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Gets a Closure that will do nothing.\n * This could be useful during testing as a placeholder.\n *\n * @see org.apache.commons.collections4.functors.NOPClosure\n *\n * @param <E>  the type that the closure acts on\n * @return the closure\n */\npublic static <E> Closure<E> nopClosure() {\n    return NOPClosure.<E>nopClosure();\n}"
            ],
            [
                "asClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Creates a Closure that calls a Transformer each time it is called.\n * The transformer will be called using the closure's input object.\n * The transformer's result will be ignored.\n *\n * @see org.apache.commons.collections4.functors.TransformerClosure\n *\n * @param <E>  the type that the closure acts on\n * @param transformer  the transformer to run each time in the closure, null means nop\n * @return the closure\n */\npublic static <E> Closure<E> asClosure(final Transformer<? super E, ?> transformer) {\n    return TransformerClosure.transformerClosure(transformer);\n}"
            ],
            [
                "forClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Creates a Closure that will call the closure <code>count</code> times.\n * <p>\n * A null closure or zero count returns the <code>NOPClosure</code>.\n *\n * @see org.apache.commons.collections4.functors.ForClosure\n *\n * @param <E>  the type that the closure acts on\n * @param count  the number of times to loop\n * @param closure  the closure to call repeatedly\n * @return the <code>for</code> closure\n */\npublic static <E> Closure<E> forClosure(final int count, final Closure<? super E> closure) {\n    return ForClosure.forClosure(count, closure);\n}"
            ],
            [
                "whileClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Creates a Closure that will call the closure repeatedly until the\n * predicate returns false.\n *\n * @see org.apache.commons.collections4.functors.WhileClosure\n *\n * @param <E>  the type that the closure acts on\n * @param predicate  the predicate to use as an end of loop test, not null\n * @param closure  the closure to call repeatedly, not null\n * @return the <code>while</code> closure\n * @throws NullPointerException if either argument is null\n */\npublic static <E> Closure<E> whileClosure(final Predicate<? super E> predicate, final Closure<? super E> closure) {\n    return WhileClosure.<E>whileClosure(predicate, closure, false);\n}"
            ],
            [
                "doWhileClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Creates a Closure that will call the closure once and then repeatedly\n * until the predicate returns false.\n *\n * @see org.apache.commons.collections4.functors.WhileClosure\n *\n * @param <E>  the type that the closure acts on\n * @param closure  the closure to call repeatedly, not null\n * @param predicate  the predicate to use as an end of loop test, not null\n * @return the <code>do-while</code> closure\n * @throws NullPointerException if either argument is null\n */\npublic static <E> Closure<E> doWhileClosure(final Closure<? super E> closure, final Predicate<? super E> predicate) {\n    return WhileClosure.<E>whileClosure(predicate, closure, true);\n}"
            ],
            [
                "invokerClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Creates a Closure that will invoke a specific method on the closure's\n * input object by reflection.\n *\n * @see org.apache.commons.collections4.functors.InvokerTransformer\n * @see org.apache.commons.collections4.functors.TransformerClosure\n *\n * @param <E>  the type that the closure acts on\n * @param methodName  the name of the method\n * @return the <code>invoker</code> closure\n * @throws NullPointerException if the method name is null\n */\npublic static <E> Closure<E> invokerClosure(final String methodName) {\n    // reuse transformer as it has caching - this is lazy really, should have inner class here\n    return asClosure(InvokerTransformer.<E, Object>invokerTransformer(methodName));\n}"
            ],
            [
                "invokerClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Creates a Closure that will invoke a specific method on the closure's\n * input object by reflection.\n *\n * @see org.apache.commons.collections4.functors.InvokerTransformer\n * @see org.apache.commons.collections4.functors.TransformerClosure\n *\n * @param <E>  the type that the closure acts on\n * @param methodName  the name of the method\n * @param paramTypes  the parameter types\n * @param args  the arguments\n * @return the <code>invoker</code> closure\n * @throws NullPointerException if the method name is null\n * @throws IllegalArgumentException if the paramTypes and args don't match\n */\npublic static <E> Closure<E> invokerClosure(final String methodName, final Class<?>[] paramTypes, final Object[] args) {\n    // reuse transformer as it has caching - this is lazy really, should have inner class here\n    return asClosure(InvokerTransformer.<E, Object>invokerTransformer(methodName, paramTypes, args));\n}"
            ],
            [
                "chainedClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Create a new Closure that calls each closure in turn, passing the\n * result into the next closure.\n *\n * @see org.apache.commons.collections4.functors.ChainedClosure\n *\n * @param <E>  the type that the closure acts on\n * @param closures  an array of closures to chain\n * @return the <code>chained</code> closure\n * @throws NullPointerException if the closures array is null\n * @throws NullPointerException if any closure in the array is null\n */\npublic static <E> Closure<E> chainedClosure(final Closure<? super E>... closures) {\n    return ChainedClosure.chainedClosure(closures);\n}"
            ],
            [
                "chainedClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Create a new Closure that calls each closure in turn, passing the\n * result into the next closure. The ordering is that of the iterator()\n * method on the collection.\n *\n * @see org.apache.commons.collections4.functors.ChainedClosure\n *\n * @param <E>  the type that the closure acts on\n * @param closures  a collection of closures to chain\n * @return the <code>chained</code> closure\n * @throws NullPointerException if the closures collection is null\n * @throws NullPointerException if any closure in the collection is null\n * @throws IllegalArgumentException if the closures collection is empty\n */\npublic static <E> Closure<E> chainedClosure(final Collection<? extends Closure<? super E>> closures) {\n    return ChainedClosure.chainedClosure(closures);\n}"
            ],
            [
                "ifClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Create a new Closure that calls another closure based on the\n * result of the specified predicate.\n *\n * @see org.apache.commons.collections4.functors.IfClosure\n *\n * @param <E>  the type that the closure acts on\n * @param predicate  the validating predicate\n * @param trueClosure  the closure called if the predicate is true\n * @return the <code>if</code> closure\n * @throws NullPointerException if the predicate or closure is null\n * @since 3.2\n */\npublic static <E> Closure<E> ifClosure(final Predicate<? super E> predicate, final Closure<? super E> trueClosure) {\n    return IfClosure.<E>ifClosure(predicate, trueClosure);\n}"
            ],
            [
                "ifClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Create a new Closure that calls one of two closures depending\n * on the specified predicate.\n *\n * @see org.apache.commons.collections4.functors.IfClosure\n *\n * @param <E>  the type that the closure acts on\n * @param predicate  the predicate to switch on\n * @param trueClosure  the closure called if the predicate is true\n * @param falseClosure  the closure called if the predicate is false\n * @return the <code>switch</code> closure\n * @throws NullPointerException if the predicate or either closure is null\n */\npublic static <E> Closure<E> ifClosure(final Predicate<? super E> predicate, final Closure<? super E> trueClosure, final Closure<? super E> falseClosure) {\n    return IfClosure.<E>ifClosure(predicate, trueClosure, falseClosure);\n}"
            ],
            [
                "switchClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Create a new Closure that calls one of the closures depending\n * on the predicates.\n * <p>\n * The closure at array location 0 is called if the predicate at array\n * location 0 returned true. Each predicate is evaluated\n * until one returns true.\n *\n * @see org.apache.commons.collections4.functors.SwitchClosure\n *\n * @param <E>  the type that the closure acts on\n * @param predicates  an array of predicates to check, not null\n * @param closures  an array of closures to call, not null\n * @return the <code>switch</code> closure\n * @throws NullPointerException if the either array is null\n * @throws NullPointerException if any element in the arrays is null\n * @throws IllegalArgumentException if the arrays have different sizes\n */\npublic static <E> Closure<E> switchClosure(final Predicate<? super E>[] predicates, final Closure<? super E>[] closures) {\n    return SwitchClosure.<E>switchClosure(predicates, closures, null);\n}"
            ],
            [
                "switchClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Create a new Closure that calls one of the closures depending\n * on the predicates.\n * <p>\n * The closure at array location 0 is called if the predicate at array\n * location 0 returned true. Each predicate is evaluated\n * until one returns true. If no predicates evaluate to true, the default\n * closure is called.\n *\n * @see org.apache.commons.collections4.functors.SwitchClosure\n *\n * @param <E>  the type that the closure acts on\n * @param predicates  an array of predicates to check, not null\n * @param closures  an array of closures to call, not null\n * @param defaultClosure  the default to call if no predicate matches\n * @return the <code>switch</code> closure\n * @throws NullPointerException if the either array is null\n * @throws NullPointerException if any element in the arrays is null\n * @throws IllegalArgumentException if the arrays are different sizes\n */\npublic static <E> Closure<E> switchClosure(final Predicate<? super E>[] predicates, final Closure<? super E>[] closures, final Closure<? super E> defaultClosure) {\n    return SwitchClosure.<E>switchClosure(predicates, closures, defaultClosure);\n}"
            ],
            [
                "switchClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Create a new Closure that calls one of the closures depending\n * on the predicates.\n * <p>\n * The Map consists of Predicate keys and Closure values. A closure\n * is called if its matching predicate returns true. Each predicate is evaluated\n * until one returns true. If no predicates evaluate to true, the default\n * closure is called. The default closure is set in the map with a\n * null key. The ordering is that of the iterator() method on the entryset\n * collection of the map.\n *\n * @see org.apache.commons.collections4.functors.SwitchClosure\n *\n * @param <E>  the type that the closure acts on\n * @param predicatesAndClosures  a map of predicates to closures\n * @return the <code>switch</code> closure\n * @throws NullPointerException if the map is null\n * @throws NullPointerException if any closure in the map is null\n * @throws IllegalArgumentException if the map is empty\n * @throws ClassCastException  if the map elements are of the wrong type\n */\npublic static <E> Closure<E> switchClosure(final Map<Predicate<E>, Closure<E>> predicatesAndClosures) {\n    return SwitchClosure.switchClosure(predicatesAndClosures);\n}"
            ],
            [
                "switchMapClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Create a new Closure that uses the input object as a key to find the\n * closure to call.\n * <p>\n * The Map consists of object keys and Closure values. A closure\n * is called if the input object equals the key. If there is no match, the\n * default closure is called. The default closure is set in the map\n * using a null key.\n *\n * @see org.apache.commons.collections4.functors.SwitchClosure\n *\n * @param <E>  the type that the closure acts on\n * @param objectsAndClosures  a map of objects to closures\n * @return the closure\n * @throws NullPointerException if the map is null\n * @throws NullPointerException if any closure in the map is null\n * @throws IllegalArgumentException if the map is empty\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Closure<E> switchMapClosure(final Map<? extends E, Closure<E>> objectsAndClosures) {\n    if (objectsAndClosures == null) {\n        throw new NullPointerException(\"The object and closure map must not be null\");\n    }\n    final Closure<? super E> def = objectsAndClosures.remove(null);\n    final int size = objectsAndClosures.size();\n    final Closure<? super E>[] trs = new Closure[size];\n    final Predicate<E>[] preds = new Predicate[size];\n    int i = 0;\n    for (final Map.Entry<? extends E, Closure<E>> entry : objectsAndClosures.entrySet()) {\n        preds[i] = EqualPredicate.<E>equalPredicate(entry.getKey());\n        trs[i] = entry.getValue();\n        i++;\n    }\n    return ClosureUtils.<E>switchClosure(preds, trs, def);\n}"
            ],
            [
                "unmodifiableTrie",
                "org.apache.commons.collections4.trie",
                "UnmodifiableTrie",
                "/**\n * Factory method to create a unmodifiable trie.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param trie  the trie to decorate, must not be null\n * @return a new unmodifiable trie\n * @throws NullPointerException if trie is null\n */\npublic static <K, V> Trie<K, V> unmodifiableTrie(final Trie<K, ? extends V> trie) {\n    if (trie instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final Trie<K, V> tmpTrie = (Trie<K, V>) trie;\n        return tmpTrie;\n    }\n    return new UnmodifiableTrie<K, V>(trie);\n}"
            ],
            [
                "isOutOfBoundsIndex",
                "org.apache.commons.collections4.trie",
                "KeyAnalyzer",
                "/**\n * Returns true if bitIndex is a {@link KeyAnalyzer#OUT_OF_BOUNDS_BIT_KEY}.\n */\nstatic boolean isOutOfBoundsIndex(final int bitIndex) {\n    return bitIndex == OUT_OF_BOUNDS_BIT_KEY;\n}"
            ],
            [
                "isEqualBitKey",
                "org.apache.commons.collections4.trie",
                "KeyAnalyzer",
                "/**\n * Returns true if bitIndex is a {@link KeyAnalyzer#EQUAL_BIT_KEY}.\n */\nstatic boolean isEqualBitKey(final int bitIndex) {\n    return bitIndex == EQUAL_BIT_KEY;\n}"
            ],
            [
                "isNullBitKey",
                "org.apache.commons.collections4.trie",
                "KeyAnalyzer",
                "/**\n * Returns true if bitIndex is a {@link KeyAnalyzer#NULL_BIT_KEY}.\n */\nstatic boolean isNullBitKey(final int bitIndex) {\n    return bitIndex == NULL_BIT_KEY;\n}"
            ],
            [
                "isValidBitIndex",
                "org.apache.commons.collections4.trie",
                "KeyAnalyzer",
                "/**\n * Returns true if the given bitIndex is valid.\n * Indices are considered valid if they're between 0 and {@link Integer#MAX_VALUE}\n */\nstatic boolean isValidBitIndex(final int bitIndex) {\n    return bitIndex >= 0;\n}"
            ],
            [
                "isValidUplink",
                "org.apache.commons.collections4.trie",
                "AbstractPatriciaTrie",
                "/**\n * Returns true if 'next' is a valid uplink coming from 'from'.\n */\nstatic boolean isValidUplink(final TrieEntry<?, ?> next, final TrieEntry<?, ?> from) {\n    return next != null && next.bitIndex <= from.bitIndex && !next.isEmpty();\n}"
            ],
            [
                "compare",
                "org.apache.commons.collections4.trie",
                "AbstractBitwiseTrie",
                "/**\n * Returns true if both values are either null or equal.\n */\nstatic boolean compare(final Object a, final Object b) {\n    return a == null ? b == null : a.equals(b);\n}"
            ],
            [
                "transformingSortedMap",
                "org.apache.commons.collections4.map",
                "TransformedSortedMap",
                "/**\n * Factory method to create a transforming sorted map.\n * <p>\n * If there are any elements already in the map being decorated, they are NOT transformed.\n * Contrast this with {@link #transformedSortedMap(SortedMap, Transformer, Transformer)}.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param keyTransformer  the predicate to validate the keys, null means no transformation\n * @param valueTransformer  the predicate to validate to values, null means no transformation\n * @return a new transformed sorted map\n * @throws NullPointerException if the map is null\n * @since 4.0\n */\npublic static <K, V> TransformedSortedMap<K, V> transformingSortedMap(final SortedMap<K, V> map, final Transformer<? super K, ? extends K> keyTransformer, final Transformer<? super V, ? extends V> valueTransformer) {\n    return new TransformedSortedMap<K, V>(map, keyTransformer, valueTransformer);\n}"
            ],
            [
                "transformedSortedMap",
                "org.apache.commons.collections4.map",
                "TransformedSortedMap",
                "/**\n * Factory method to create a transforming sorted map that will transform\n * existing contents of the specified map.\n * <p>\n * If there are any elements already in the map being decorated, they\n * will be transformed by this method.\n * Contrast this with {@link #transformingSortedMap(SortedMap, Transformer, Transformer)}.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param keyTransformer  the transformer to use for key conversion, null means no transformation\n * @param valueTransformer  the transformer to use for value conversion, null means no transformation\n * @return a new transformed sorted map\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> TransformedSortedMap<K, V> transformedSortedMap(final SortedMap<K, V> map, final Transformer<? super K, ? extends K> keyTransformer, final Transformer<? super V, ? extends V> valueTransformer) {\n    final TransformedSortedMap<K, V> decorated = new TransformedSortedMap<K, V>(map, keyTransformer, valueTransformer);\n    if (map.size() > 0) {\n        final Map<K, V> transformed = decorated.transformMap(map);\n        decorated.clear();\n        // avoids double transformation\n        decorated.decorated().putAll(transformed);\n    }\n    return decorated;\n}"
            ],
            [
                "predicatedMap",
                "org.apache.commons.collections4.map",
                "PredicatedMap",
                "/**\n * Factory method to create a predicated (validating) map.\n * <p>\n * If there are any elements already in the list being decorated, they\n * are validated.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param keyPredicate  the predicate to validate the keys, null means no check\n * @param valuePredicate  the predicate to validate to values, null means no check\n * @return a new predicated map\n * @throws NullPointerException if the map is null\n * @since 4.0\n */\npublic static <K, V> PredicatedMap<K, V> predicatedMap(final Map<K, V> map, final Predicate<? super K> keyPredicate, final Predicate<? super V> valuePredicate) {\n    return new PredicatedMap<K, V>(map, keyPredicate, valuePredicate);\n}"
            ],
            [
                "fixedSizeSortedMap",
                "org.apache.commons.collections4.map",
                "FixedSizeSortedMap",
                "/**\n * Factory method to create a fixed size sorted map.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @return a new fixed size sorted map\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> FixedSizeSortedMap<K, V> fixedSizeSortedMap(final SortedMap<K, V> map) {\n    return new FixedSizeSortedMap<K, V>(map);\n}"
            ],
            [
                "unmodifiableSortedMap",
                "org.apache.commons.collections4.map",
                "UnmodifiableSortedMap",
                "/**\n * Factory method to create an unmodifiable sorted map.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @return a new unmodifiable sorted map\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> SortedMap<K, V> unmodifiableSortedMap(final SortedMap<K, ? extends V> map) {\n    if (map instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final SortedMap<K, V> tmpMap = (SortedMap<K, V>) map;\n        return tmpMap;\n    }\n    return new UnmodifiableSortedMap<K, V>(map);\n}"
            ],
            [
                "predicatedSortedMap",
                "org.apache.commons.collections4.map",
                "PredicatedSortedMap",
                "/**\n * Factory method to create a predicated (validating) sorted map.\n * <p>\n * If there are any elements already in the list being decorated, they\n * are validated.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param keyPredicate  the predicate to validate the keys, null means no check\n * @param valuePredicate  the predicate to validate to values, null means no check\n * @return a new predicated sorted map\n * @throws NullPointerException if the map is null\n * @since 4.0\n */\npublic static <K, V> PredicatedSortedMap<K, V> predicatedSortedMap(final SortedMap<K, V> map, final Predicate<? super K> keyPredicate, final Predicate<? super V> valuePredicate) {\n    return new PredicatedSortedMap<K, V>(map, keyPredicate, valuePredicate);\n}"
            ],
            [
                "defaultedMap",
                "org.apache.commons.collections4.map",
                "DefaultedMap",
                "//-----------------------------------------------------------------------\n/**\n * Factory method to create a defaulting map.\n * <p>\n * The value specified is returned when a missing key is found.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param defaultValue  the default value to return when the key is not found\n * @return a new defaulting map\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> DefaultedMap<K, V> defaultedMap(final Map<K, V> map, final V defaultValue) {\n    return new DefaultedMap<K, V>(map, ConstantTransformer.constantTransformer(defaultValue));\n}"
            ],
            [
                "defaultedMap",
                "org.apache.commons.collections4.map",
                "DefaultedMap",
                "/**\n * Factory method to create a defaulting map.\n * <p>\n * The factory specified is called when a missing key is found.\n * The result will be returned as the result of the map get(key) method.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param factory  the factory to use to create entries, must not be null\n * @return a new defaulting map\n * @throws NullPointerException if map or factory is null\n * @since 4.0\n */\npublic static <K, V> DefaultedMap<K, V> defaultedMap(final Map<K, V> map, final Factory<? extends V> factory) {\n    if (factory == null) {\n        throw new IllegalArgumentException(\"Factory must not be null\");\n    }\n    return new DefaultedMap<K, V>(map, FactoryTransformer.factoryTransformer(factory));\n}"
            ],
            [
                "defaultedMap",
                "org.apache.commons.collections4.map",
                "DefaultedMap",
                "/**\n * Factory method to create a defaulting map.\n * <p>\n * The transformer specified is called when a missing key is found.\n * The key is passed to the transformer as the input, and the result\n * will be returned as the result of the map get(key) method.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param transformer  the transformer to use as a factory to create entries, must not be null\n * @return a new defaulting map\n * @throws NullPointerException if map or factory is null\n * @since 4.0\n */\npublic static <K, V> Map<K, V> defaultedMap(final Map<K, V> map, final Transformer<? super K, ? extends V> transformer) {\n    if (transformer == null) {\n        throw new IllegalArgumentException(\"Transformer must not be null\");\n    }\n    return new DefaultedMap<K, V>(map, transformer);\n}"
            ],
            [
                "fixedSizeMap",
                "org.apache.commons.collections4.map",
                "FixedSizeMap",
                "/**\n * Factory method to create a fixed size map.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @return a new fixed size map\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> FixedSizeMap<K, V> fixedSizeMap(final Map<K, V> map) {\n    return new FixedSizeMap<K, V>(map);\n}"
            ],
            [
                "lazySortedMap",
                "org.apache.commons.collections4.map",
                "LazySortedMap",
                "/**\n * Factory method to create a lazily instantiated sorted map.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param factory  the factory to use, must not be null\n * @return a new lazy sorted map\n * @throws NullPointerException if map or factory is null\n * @since 4.0\n */\npublic static <K, V> LazySortedMap<K, V> lazySortedMap(final SortedMap<K, V> map, final Factory<? extends V> factory) {\n    return new LazySortedMap<K, V>(map, factory);\n}"
            ],
            [
                "lazySortedMap",
                "org.apache.commons.collections4.map",
                "LazySortedMap",
                "/**\n * Factory method to create a lazily instantiated sorted map.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param factory  the factory to use, must not be null\n * @return a new lazy sorted map\n * @throws NullPointerException if map or factory is null\n * @since 4.0\n */\npublic static <K, V> LazySortedMap<K, V> lazySortedMap(final SortedMap<K, V> map, final Transformer<? super K, ? extends V> factory) {\n    return new LazySortedMap<K, V>(map, factory);\n}"
            ],
            [
                "unmodifiableOrderedMap",
                "org.apache.commons.collections4.map",
                "UnmodifiableOrderedMap",
                "/**\n * Factory method to create an unmodifiable sorted map.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @return a new ordered map\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> OrderedMap<K, V> unmodifiableOrderedMap(final OrderedMap<? extends K, ? extends V> map) {\n    if (map instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final OrderedMap<K, V> tmpMap = (OrderedMap<K, V>) map;\n        return tmpMap;\n    }\n    return new UnmodifiableOrderedMap<K, V>(map);\n}"
            ],
            [
                "unmodifiableMap",
                "org.apache.commons.collections4.map",
                "UnmodifiableMap",
                "/**\n * Factory method to create an unmodifiable map.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @return a new unmodifiable map\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> Map<K, V> unmodifiableMap(final Map<? extends K, ? extends V> map) {\n    if (map instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final Map<K, V> tmpMap = (Map<K, V>) map;\n        return tmpMap;\n    }\n    return new UnmodifiableMap<K, V>(map);\n}"
            ],
            [
                "listOrderedMap",
                "org.apache.commons.collections4.map",
                "ListOrderedMap",
                "/**\n * Factory method to create an ordered map.\n * <p>\n * An <code>ArrayList</code> is used to retain order.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @return a new list ordered map\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> ListOrderedMap<K, V> listOrderedMap(final Map<K, V> map) {\n    return new ListOrderedMap<K, V>(map);\n}"
            ],
            [
                "unmodifiableEntrySet",
                "org.apache.commons.collections4.map",
                "UnmodifiableEntrySet",
                "/**\n * Factory method to create an unmodifiable set of Map Entry objects.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param set  the set to decorate, must not be null\n * @return a new unmodifiable entry set\n * @throws NullPointerException if set is null\n * @since 4.0\n */\npublic static <K, V> Set<Map.Entry<K, V>> unmodifiableEntrySet(final Set<Map.Entry<K, V>> set) {\n    if (set instanceof Unmodifiable) {\n        return set;\n    }\n    return new UnmodifiableEntrySet<K, V>(set);\n}"
            ],
            [
                "resolve",
                "org.apache.commons.collections4.map",
                "AbstractReferenceMap",
                "/**\n * Resolve enum from int.\n * @param value  the int value\n * @return ReferenceType\n * @throws IllegalArgumentException if the specified value is invalid.\n */\npublic static ReferenceStrength resolve(final int value) {\n    switch(value) {\n        case 0:\n            return HARD;\n        case 1:\n            return SOFT;\n        case 2:\n            return WEAK;\n        default:\n            throw new IllegalArgumentException();\n    }\n}"
            ],
            [
                "resolve",
                "org.apache.commons.collections4.map",
                "ReferenceStrength",
                "/**\n * Resolve enum from int.\n * @param value  the int value\n * @return ReferenceType\n * @throws IllegalArgumentException if the specified value is invalid.\n */\npublic static ReferenceStrength resolve(final int value) {\n    switch(value) {\n        case 0:\n            return HARD;\n        case 1:\n            return SOFT;\n        case 2:\n            return WEAK;\n        default:\n            throw new IllegalArgumentException();\n    }\n}"
            ],
            [
                "multiKeyMap",
                "org.apache.commons.collections4.map",
                "MultiKeyMap",
                "//-----------------------------------------------------------------------\n/**\n * Decorates the specified map to add the MultiKeyMap API and fast query.\n * The map must not be null and must be empty.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, not null\n * @return a new multi key map\n * @throws NullPointerException if map is null\n * @throws IllegalArgumentException if the map is not empty\n * @since 4.0\n */\npublic static <K, V> MultiKeyMap<K, V> multiKeyMap(final AbstractHashedMap<MultiKey<? extends K>, V> map) {\n    if (map == null) {\n        throw new NullPointerException(\"Map must not be null\");\n    }\n    if (map.size() > 0) {\n        throw new IllegalArgumentException(\"Map must be empty\");\n    }\n    return new MultiKeyMap<K, V>(map);\n}"
            ],
            [
                "lazyMap",
                "org.apache.commons.collections4.map",
                "LazyMap",
                "/**\n * Factory method to create a lazily instantiated map.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param factory  the factory to use, must not be null\n * @return a new lazy map\n * @throws NullPointerException if map or factory is null\n * @since 4.0\n */\npublic static <K, V> LazyMap<K, V> lazyMap(final Map<K, V> map, final Factory<? extends V> factory) {\n    return new LazyMap<K, V>(map, factory);\n}"
            ],
            [
                "lazyMap",
                "org.apache.commons.collections4.map",
                "LazyMap",
                "/**\n * Factory method to create a lazily instantiated map.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param factory  the factory to use, must not be null\n * @return a new lazy map\n * @throws NullPointerException if map or factory is null\n * @since 4.0\n */\npublic static <V, K> LazyMap<K, V> lazyMap(final Map<K, V> map, final Transformer<? super K, ? extends V> factory) {\n    return new LazyMap<K, V>(map, factory);\n}"
            ],
            [
                "multiValueMap",
                "org.apache.commons.collections4.map",
                "MultiValueMap",
                "/**\n * Creates a map which wraps the given map and\n * maps keys to ArrayLists.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to wrap\n * @return a new multi-value map\n * @since 4.0\n */\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\npublic static <K, V> MultiValueMap<K, V> multiValueMap(final Map<K, ? super Collection<V>> map) {\n    return MultiValueMap.<K, V, ArrayList>multiValueMap((Map<K, ? super Collection>) map, ArrayList.class);\n}"
            ],
            [
                "multiValueMap",
                "org.apache.commons.collections4.map",
                "MultiValueMap",
                "/**\n * Creates a map which decorates the given <code>map</code> and\n * maps keys to collections of type <code>collectionClass</code>.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param <C>  the collection class type\n * @param map  the map to wrap\n * @param collectionClass  the type of the collection class\n * @return a new multi-value map\n * @since 4.0\n */\npublic static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(final Map<K, ? super C> map, final Class<C> collectionClass) {\n    return new MultiValueMap<K, V>(map, new ReflectionFactory<C>(collectionClass));\n}"
            ],
            [
                "multiValueMap",
                "org.apache.commons.collections4.map",
                "MultiValueMap",
                "/**\n * Creates a map which decorates the given <code>map</code> and\n * creates the value collections using the supplied <code>collectionFactory</code>.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param <C>  the collection class type\n * @param map  the map to decorate\n * @param collectionFactory  the collection factory (must return a Collection object).\n * @return a new multi-value map\n * @since 4.0\n */\npublic static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(final Map<K, ? super C> map, final Factory<C> collectionFactory) {\n    return new MultiValueMap<K, V>(map, collectionFactory);\n}"
            ],
            [
                "transformingMap",
                "org.apache.commons.collections4.map",
                "TransformedMap",
                "/**\n * Factory method to create a transforming map.\n * <p>\n * If there are any elements already in the map being decorated, they\n * are NOT transformed.\n * Contrast this with {@link #transformedMap(Map, Transformer, Transformer)}.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param keyTransformer  the transformer to use for key conversion, null means no transformation\n * @param valueTransformer  the transformer to use for value conversion, null means no transformation\n * @return a new transformed map\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> TransformedMap<K, V> transformingMap(final Map<K, V> map, final Transformer<? super K, ? extends K> keyTransformer, final Transformer<? super V, ? extends V> valueTransformer) {\n    return new TransformedMap<K, V>(map, keyTransformer, valueTransformer);\n}"
            ],
            [
                "transformedMap",
                "org.apache.commons.collections4.map",
                "TransformedMap",
                "/**\n * Factory method to create a transforming map that will transform\n * existing contents of the specified map.\n * <p>\n * If there are any elements already in the map being decorated, they\n * will be transformed by this method.\n * Contrast this with {@link #transformingMap(Map, Transformer, Transformer)}.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param keyTransformer  the transformer to use for key conversion, null means no transformation\n * @param valueTransformer  the transformer to use for value conversion, null means no transformation\n * @return a new transformed map\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> TransformedMap<K, V> transformedMap(final Map<K, V> map, final Transformer<? super K, ? extends K> keyTransformer, final Transformer<? super V, ? extends V> valueTransformer) {\n    final TransformedMap<K, V> decorated = new TransformedMap<K, V>(map, keyTransformer, valueTransformer);\n    if (map.size() > 0) {\n        final Map<K, V> transformed = decorated.transformMap(map);\n        decorated.clear();\n        // avoids double transformation\n        decorated.decorated().putAll(transformed);\n    }\n    return decorated;\n}"
            ],
            [
                "synchronizedMultiSet",
                "org.apache.commons.collections4",
                "MultiSetUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns a synchronized (thread-safe) multiset backed by the given multiset.\n * In order to guarantee serial access, it is critical that all access to the\n * backing multiset is accomplished through the returned multiset.\n * <p>\n * It is imperative that the user manually synchronize on the returned multiset\n * when iterating over it:\n *\n * <pre>\n * MultiSet multiset = MultiSetUtils.synchronizedMultiSet(new HashMultiSet());\n * ...\n * synchronized(multiset) {\n *     Iterator i = multiset.iterator(); // Must be in synchronized block\n *     while (i.hasNext())\n *         foo(i.next());\n *     }\n * }\n * </pre>\n *\n * Failure to follow this advice may result in non-deterministic behavior.\n *\n * @param <E> the element type\n * @param multiset the multiset to synchronize, must not be null\n * @return a synchronized multiset backed by that multiset\n * @throws NullPointerException if the MultiSet is null\n */\npublic static <E> MultiSet<E> synchronizedMultiSet(final MultiSet<E> multiset) {\n    return SynchronizedMultiSet.synchronizedMultiSet(multiset);\n}"
            ],
            [
                "unmodifiableMultiSet",
                "org.apache.commons.collections4",
                "MultiSetUtils",
                "/**\n * Returns an unmodifiable view of the given multiset. Any modification attempts\n * to the returned multiset will raise an {@link UnsupportedOperationException}.\n *\n * @param <E> the element type\n * @param multiset the multiset whose unmodifiable view is to be returned, must not be null\n * @return an unmodifiable view of that multiset\n * @throws NullPointerException if the MultiSet is null\n */\npublic static <E> MultiSet<E> unmodifiableMultiSet(final MultiSet<? extends E> multiset) {\n    return UnmodifiableMultiSet.unmodifiableMultiSet(multiset);\n}"
            ],
            [
                "predicatedMultiSet",
                "org.apache.commons.collections4",
                "MultiSetUtils",
                "/**\n * Returns a predicated (validating) multiset backed by the given multiset.\n * <p>\n * Only objects that pass the test in the given predicate can be added to\n * the multiset. Trying to add an invalid object results in an\n * IllegalArgumentException. It is important not to use the original multiset\n * after invoking this method, as it is a backdoor for adding invalid\n * objects.\n *\n * @param <E> the element type\n * @param multiset the multiset to predicate, must not be null\n * @param predicate the predicate for the multiset, must not be null\n * @return a predicated multiset backed by the given multiset\n * @throws NullPointerException if the MultiSet or Predicate is null\n */\npublic static <E> MultiSet<E> predicatedMultiSet(final MultiSet<E> multiset, final Predicate<? super E> predicate) {\n    return PredicatedMultiSet.predicatedMultiSet(multiset, predicate);\n}"
            ],
            [
                "emptyMultiSet",
                "org.apache.commons.collections4",
                "MultiSetUtils",
                "/**\n * Get an empty <code>MultiSet</code>.\n *\n * @param <E> the element type\n * @return an empty MultiSet\n */\n// OK, empty multiset is compatible with any type\n@SuppressWarnings(\"unchecked\")\npublic static <E> MultiSet<E> emptyMultiSet() {\n    return EMPTY_MULTISET;\n}"
            ],
            [
                "unmodifiableMultiValuedMap",
                "org.apache.commons.collections4.multimap",
                "UnmodifiableMultiValuedMap",
                "/**\n * Factory method to create an unmodifiable MultiValuedMap.\n * <p>\n * If the map passed in is already unmodifiable, it is returned.\n *\n * @param <K> the type of key elements\n * @param <V> the type of value elements\n * @param map  the map to decorate, may not be null\n * @return an unmodifiable MultiValuedMap\n * @throws NullPointerException if map is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <K, V> UnmodifiableMultiValuedMap<K, V> unmodifiableMultiValuedMap(MultiValuedMap<? extends K, ? extends V> map) {\n    if (map instanceof Unmodifiable) {\n        return (UnmodifiableMultiValuedMap<K, V>) map;\n    }\n    return new UnmodifiableMultiValuedMap<K, V>(map);\n}"
            ],
            [
                "transformingMap",
                "org.apache.commons.collections4.multimap",
                "TransformedMultiValuedMap",
                "/**\n * Factory method to create a transforming MultiValuedMap.\n * <p>\n * If there are any elements already in the map being decorated, they are\n * NOT transformed. Contrast this with\n * {@link #transformedMap(MultiValuedMap, Transformer, Transformer)}.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the MultiValuedMap to decorate, may not be null\n * @param keyTransformer  the transformer to use for key conversion, null means no conversion\n * @param valueTransformer  the transformer to use for value conversion, null means no conversion\n * @return a new transformed MultiValuedMap\n * @throws NullPointerException if map is null\n */\npublic static <K, V> TransformedMultiValuedMap<K, V> transformingMap(final MultiValuedMap<K, V> map, final Transformer<? super K, ? extends K> keyTransformer, final Transformer<? super V, ? extends V> valueTransformer) {\n    return new TransformedMultiValuedMap<K, V>(map, keyTransformer, valueTransformer);\n}"
            ],
            [
                "transformedMap",
                "org.apache.commons.collections4.multimap",
                "TransformedMultiValuedMap",
                "/**\n * Factory method to create a transforming MultiValuedMap that will\n * transform existing contents of the specified map.\n * <p>\n * If there are any elements already in the map being decorated, they will\n * be transformed by this method. Contrast this with\n * {@link #transformingMap(MultiValuedMap, Transformer, Transformer)}.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the MultiValuedMap to decorate, may not be null\n * @param keyTransformer  the transformer to use for key conversion, null means no conversion\n * @param valueTransformer  the transformer to use for value conversion, null means no conversion\n * @return a new transformed MultiValuedMap\n * @throws NullPointerException if map is null\n */\npublic static <K, V> TransformedMultiValuedMap<K, V> transformedMap(final MultiValuedMap<K, V> map, final Transformer<? super K, ? extends K> keyTransformer, final Transformer<? super V, ? extends V> valueTransformer) {\n    final TransformedMultiValuedMap<K, V> decorated = new TransformedMultiValuedMap<K, V>(map, keyTransformer, valueTransformer);\n    if (!map.isEmpty()) {\n        final MultiValuedMap<K, V> mapCopy = new ArrayListValuedHashMap<K, V>(map);\n        decorated.clear();\n        decorated.putAll(mapCopy);\n    }\n    return decorated;\n}"
            ],
            [
                "lazyList",
                "org.apache.commons.collections4.list",
                "LazyList",
                "/**\n * Factory method to create a lazily instantiating list.\n *\n * @param <E> the type of the elements in the list\n * @param list  the list to decorate, must not be null\n * @param factory  the factory to use for creation, must not be null\n * @return a new lazy list\n * @throws NullPointerException if list or factory is null\n * @since 4.0\n */\npublic static <E> LazyList<E> lazyList(final List<E> list, final Factory<? extends E> factory) {\n    return new LazyList<E>(list, factory);\n}"
            ],
            [
                "setUniqueList",
                "org.apache.commons.collections4.list",
                "SetUniqueList",
                "/**\n * Factory method to create a SetList using the supplied list to retain order.\n * <p>\n * If the list contains duplicates, these are removed (first indexed one\n * kept). A <code>HashSet</code> is used for the set behaviour.\n *\n * @param <E>  the element type\n * @param list  the list to decorate, must not be null\n * @return a new {@link SetUniqueList}\n * @throws NullPointerException if list is null\n * @since 4.0\n */\npublic static <E> SetUniqueList<E> setUniqueList(final List<E> list) {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) {\n        return new SetUniqueList<E>(list, new HashSet<E>());\n    }\n    final List<E> temp = new ArrayList<E>(list);\n    list.clear();\n    final SetUniqueList<E> sl = new SetUniqueList<E>(list, new HashSet<E>());\n    sl.addAll(temp);\n    return sl;\n}"
            ],
            [
                "unmodifiableList",
                "org.apache.commons.collections4.list",
                "UnmodifiableList",
                "/**\n * Factory method to create an unmodifiable list.\n *\n * @param <E> the type of the elements in the list\n * @param list  the list to decorate, must not be null\n * @return a new unmodifiable list\n * @throws NullPointerException if list is null\n * @since 4.0\n */\npublic static <E> List<E> unmodifiableList(final List<? extends E> list) {\n    if (list instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final List<E> tmpList = (List<E>) list;\n        return tmpList;\n    }\n    return new UnmodifiableList<E>(list);\n}"
            ],
            [
                "fixedSizeList",
                "org.apache.commons.collections4.list",
                "FixedSizeList",
                "/**\n * Factory method to create a fixed size list.\n *\n * @param <E> the type of the elements in the list\n * @param list  the list to decorate, must not be null\n * @return a new fixed size list\n * @throws NullPointerException if list is null\n * @since 4.0\n */\npublic static <E> FixedSizeList<E> fixedSizeList(final List<E> list) {\n    return new FixedSizeList<E>(list);\n}"
            ],
            [
                "transformingList",
                "org.apache.commons.collections4.list",
                "TransformedList",
                "/**\n * Factory method to create a transforming list.\n * <p>\n * If there are any elements already in the list being decorated, they\n * are NOT transformed.\n * Contrast this with {@link #transformedList(List, Transformer)}.\n *\n * @param <E> the type of the elements in the list\n * @param list  the list to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed list\n * @throws NullPointerException if list or transformer is null\n * @since 4.0\n */\npublic static <E> TransformedList<E> transformingList(final List<E> list, final Transformer<? super E, ? extends E> transformer) {\n    return new TransformedList<E>(list, transformer);\n}"
            ],
            [
                "transformedList",
                "org.apache.commons.collections4.list",
                "TransformedList",
                "/**\n * Factory method to create a transforming list that will transform\n * existing contents of the specified list.\n * <p>\n * If there are any elements already in the list being decorated, they\n * will be transformed by this method.\n * Contrast this with {@link #transformingList(List, Transformer)}.\n *\n * @param <E> the type of the elements in the list\n * @param list  the list to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed List\n * @throws NullPointerException if list or transformer is null\n * @since 4.0\n */\npublic static <E> TransformedList<E> transformedList(final List<E> list, final Transformer<? super E, ? extends E> transformer) {\n    final TransformedList<E> decorated = new TransformedList<E>(list, transformer);\n    if (list.size() > 0) {\n        // list is of type E\n        @SuppressWarnings(\"unchecked\")\n        final E[] // NOPMD - false positive for generics\n        values = (E[]) list.toArray();\n        list.clear();\n        for (final E value : values) {\n            decorated.decorated().add(transformer.transform(value));\n        }\n    }\n    return decorated;\n}"
            ],
            [
                "growthList",
                "org.apache.commons.collections4.list",
                "GrowthList",
                "/**\n * Factory method to create a growth list.\n *\n * @param <E> the type of the elements in the list\n * @param list  the list to decorate, must not be null\n * @return a new growth list\n * @throws NullPointerException if list is null\n * @since 4.0\n */\npublic static <E> GrowthList<E> growthList(final List<E> list) {\n    return new GrowthList<E>(list);\n}"
            ],
            [
                "predicatedList",
                "org.apache.commons.collections4.list",
                "PredicatedList",
                "/**\n * Factory method to create a predicated (validating) list.\n * <p>\n * If there are any elements already in the list being decorated, they\n * are validated.\n *\n * @param <T> the type of the elements in the list\n * @param list  the list to decorate, must not be null\n * @param predicate  the predicate to use for validation, must not be null\n * @return a new predicated list\n * @throws NullPointerException if list or predicate is null\n * @throws IllegalArgumentException if the list contains invalid elements\n * @since 4.0\n */\npublic static <T> PredicatedList<T> predicatedList(final List<T> list, final Predicate<? super T> predicate) {\n    return new PredicatedList<T>(list, predicate);\n}"
            ],
            [
                "transformingQueue",
                "org.apache.commons.collections4.queue",
                "TransformedQueue",
                "/**\n * Factory method to create a transforming queue.\n * <p>\n * If there are any elements already in the queue being decorated, they\n * are NOT transformed.\n * Contrast this with {@link #transformedQueue(Queue, Transformer)}.\n *\n * @param <E> the type of the elements in the queue\n * @param queue  the queue to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed Queue\n * @throws NullPointerException if queue or transformer is null\n */\npublic static <E> TransformedQueue<E> transformingQueue(final Queue<E> queue, final Transformer<? super E, ? extends E> transformer) {\n    return new TransformedQueue<E>(queue, transformer);\n}"
            ],
            [
                "transformedQueue",
                "org.apache.commons.collections4.queue",
                "TransformedQueue",
                "/**\n * Factory method to create a transforming queue that will transform\n * existing contents of the specified queue.\n * <p>\n * If there are any elements already in the queue being decorated, they\n * will be transformed by this method.\n * Contrast this with {@link #transformingQueue(Queue, Transformer)}.\n *\n * @param <E> the type of the elements in the queue\n * @param queue  the queue to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed Queue\n * @throws NullPointerException if queue or transformer is null\n * @since 4.0\n */\npublic static <E> TransformedQueue<E> transformedQueue(final Queue<E> queue, final Transformer<? super E, ? extends E> transformer) {\n    // throws IAE if queue or transformer is null\n    final TransformedQueue<E> decorated = new TransformedQueue<E>(queue, transformer);\n    if (queue.size() > 0) {\n        // queue is type <E>\n        @SuppressWarnings(\"unchecked\")\n        final E[] // NOPMD - false positive for generics\n        values = (E[]) queue.toArray();\n        queue.clear();\n        for (final E value : values) {\n            decorated.decorated().add(transformer.transform(value));\n        }\n    }\n    return decorated;\n}"
            ],
            [
                "unmodifiableQueue",
                "org.apache.commons.collections4.queue",
                "UnmodifiableQueue",
                "/**\n * Factory method to create an unmodifiable queue.\n * <p>\n * If the queue passed in is already unmodifiable, it is returned.\n *\n * @param <E> the type of the elements in the queue\n * @param queue  the queue to decorate, must not be null\n * @return an unmodifiable Queue\n * @throws NullPointerException if queue is null\n */\npublic static <E> Queue<E> unmodifiableQueue(final Queue<? extends E> queue) {\n    if (queue instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final Queue<E> tmpQueue = (Queue<E>) queue;\n        return tmpQueue;\n    }\n    return new UnmodifiableQueue<E>(queue);\n}"
            ],
            [
                "predicatedQueue",
                "org.apache.commons.collections4.queue",
                "PredicatedQueue",
                "/**\n * Factory method to create a predicated (validating) queue.\n * <p>\n * If there are any elements already in the queue being decorated, they\n * are validated.\n *\n * @param <E> the type of the elements in the queue\n * @param Queue  the queue to decorate, must not be null\n * @param predicate  the predicate to use for validation, must not be null\n * @return a new predicated queue\n * @throws NullPointerException if queue or predicate is null\n * @throws IllegalArgumentException if the queue contains invalid elements\n */\npublic static <E> PredicatedQueue<E> predicatedQueue(final Queue<E> Queue, final Predicate<? super E> predicate) {\n    return new PredicatedQueue<E>(Queue, predicate);\n}"
            ],
            [
                "empty",
                "org.apache.commons.collections4",
                "FluentIterable",
                "// Static factory methods\n// ----------------------------------------------------------------------\n/**\n * Creates a new empty FluentIterable.\n *\n * @param <T>  the element type\n * @return a new empty FluentIterable\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> FluentIterable<T> empty() {\n    return IterableUtils.EMPTY_ITERABLE;\n}"
            ],
            [
                "of",
                "org.apache.commons.collections4",
                "FluentIterable",
                "/**\n * Creates a new FluentIterable of the single provided element.\n * <p>\n * The returned iterable's iterator does not support {@code remove()}.\n *\n * @param <T>  the element type\n * @param singleton  the singleton element\n * @return a new FluentIterable containing the singleton\n */\npublic static <T> FluentIterable<T> of(final T singleton) {\n    return of(IteratorUtils.asIterable(new SingletonIterator<T>(singleton, false)));\n}"
            ],
            [
                "of",
                "org.apache.commons.collections4",
                "FluentIterable",
                "/**\n * Creates a new FluentIterable from the provided elements.\n * <p>\n * The returned iterable's iterator does not support {@code remove()}.\n *\n * @param <T>  the element type\n * @param elements  the elements to be contained in the FluentIterable\n * @return a new FluentIterable containing the provided elements\n */\npublic static <T> FluentIterable<T> of(final T... elements) {\n    return of(Arrays.asList(elements));\n}"
            ],
            [
                "of",
                "org.apache.commons.collections4",
                "FluentIterable",
                "/**\n * Construct a new FluentIterable from the provided iterable. If the\n * iterable is already an instance of FluentIterable, the instance\n * will be returned instead.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the\n * corresponding input iterator supports it.\n *\n * @param <T>  the element type\n * @param iterable  the iterable to wrap into a FluentIterable, may not be null\n * @return a new FluentIterable wrapping the provided iterable\n * @throws NullPointerException if iterable is null\n */\npublic static <T> FluentIterable<T> of(final Iterable<T> iterable) {\n    IterableUtils.checkNotNull(iterable);\n    if (iterable instanceof FluentIterable<?>) {\n        return (FluentIterable<T>) iterable;\n    } else {\n        return new FluentIterable<T>(iterable);\n    }\n}"
            ],
            [
                "exceptionTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Gets a transformer that always throws an exception.\n * This could be useful during testing as a placeholder.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @return the transformer\n * @see ExceptionTransformer\n */\npublic static <I, O> Transformer<I, O> exceptionTransformer() {\n    return ExceptionTransformer.exceptionTransformer();\n}"
            ],
            [
                "nullTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Gets a transformer that always returns null.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @return the transformer\n * @see ConstantTransformer\n */\npublic static <I, O> Transformer<I, O> nullTransformer() {\n    return ConstantTransformer.nullTransformer();\n}"
            ],
            [
                "nopTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Gets a transformer that returns the input object.\n * The input object should be immutable to maintain the\n * contract of Transformer (although this is not checked).\n *\n * @param <T>  the input/output type\n * @return the transformer\n * @see NOPTransformer\n */\npublic static <T> Transformer<T, T> nopTransformer() {\n    return NOPTransformer.nopTransformer();\n}"
            ],
            [
                "cloneTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Gets a transformer that returns a clone of the input object.\n * The input object will be cloned using one of these techniques (in order):\n * <ul>\n * <li>public clone method\n * <li>public copy constructor\n * <li>serialization clone\n * <ul>\n *\n * @param <T>  the input/output type\n * @return the transformer\n * @see CloneTransformer\n */\npublic static <T> Transformer<T, T> cloneTransformer() {\n    return CloneTransformer.cloneTransformer();\n}"
            ],
            [
                "constantTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Creates a Transformer that will return the same object each time the\n * transformer is used.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param constantToReturn  the constant object to return each time in the transformer\n * @return the transformer.\n * @see ConstantTransformer\n */\npublic static <I, O> Transformer<I, O> constantTransformer(final O constantToReturn) {\n    return ConstantTransformer.constantTransformer(constantToReturn);\n}"
            ],
            [
                "asTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Creates a Transformer that calls a Closure each time the transformer is used.\n * The transformer returns the input object.\n *\n * @param <T>  the input/output type\n * @param closure  the closure to run each time in the transformer, not null\n * @return the transformer\n * @throws NullPointerException if the closure is null\n * @see ClosureTransformer\n */\npublic static <T> Transformer<T, T> asTransformer(final Closure<? super T> closure) {\n    return ClosureTransformer.closureTransformer(closure);\n}"
            ],
            [
                "asTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Creates a Transformer that calls a Predicate each time the transformer is used.\n * The transformer will return either Boolean.TRUE or Boolean.FALSE.\n *\n * @param <T>  the input type\n * @param predicate  the predicate to run each time in the transformer, not null\n * @return the transformer\n * @throws NullPointerException if the predicate is null\n * @see PredicateTransformer\n */\npublic static <T> Transformer<T, Boolean> asTransformer(final Predicate<? super T> predicate) {\n    return PredicateTransformer.predicateTransformer(predicate);\n}"
            ],
            [
                "asTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Creates a Transformer that calls a Factory each time the transformer is used.\n * The transformer will return the value returned by the factory.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param factory  the factory to run each time in the transformer, not null\n * @return the transformer\n * @throws NullPointerException if the factory is null\n * @see FactoryTransformer\n */\npublic static <I, O> Transformer<I, O> asTransformer(final Factory<? extends O> factory) {\n    return FactoryTransformer.factoryTransformer(factory);\n}"
            ],
            [
                "chainedTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Create a new Transformer that calls each transformer in turn, passing the\n * result into the next transformer.\n *\n * @param <T>  the input/output type\n * @param transformers  an array of transformers to chain\n * @return the transformer\n * @throws NullPointerException if the transformers array or any of the transformers is null\n * @see ChainedTransformer\n */\npublic static <T> Transformer<T, T> chainedTransformer(final Transformer<? super T, ? extends T>... transformers) {\n    return ChainedTransformer.chainedTransformer(transformers);\n}"
            ],
            [
                "chainedTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Create a new Transformer that calls each transformer in turn, passing the\n * result into the next transformer. The ordering is that of the iterator()\n * method on the collection.\n *\n * @param <T>  the input/output type\n * @param transformers  a collection of transformers to chain\n * @return the transformer\n * @throws NullPointerException if the transformers collection or any of the transformers is null\n * @see ChainedTransformer\n */\npublic static <T> Transformer<T, T> chainedTransformer(final Collection<? extends Transformer<? super T, ? extends T>> transformers) {\n    return ChainedTransformer.chainedTransformer(transformers);\n}"
            ],
            [
                "ifTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Create a new Transformer that calls the transformer if the predicate is true,\n * otherwise the input object is returned unchanged.\n *\n * @param <T>  the input / output type\n * @param predicate  the predicate to switch on\n * @param trueTransformer  the transformer called if the predicate is true\n * @return the transformer\n * @throws NullPointerException if either the predicate or transformer is null\n * @see IfTransformer\n * @since 4.1\n */\npublic static <T> Transformer<T, T> ifTransformer(final Predicate<? super T> predicate, final Transformer<? super T, ? extends T> trueTransformer) {\n    return IfTransformer.ifTransformer(predicate, trueTransformer);\n}"
            ],
            [
                "ifTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Create a new Transformer that calls one of two transformers depending\n * on the specified predicate.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param predicate  the predicate to switch on\n * @param trueTransformer  the transformer called if the predicate is true\n * @param falseTransformer  the transformer called if the predicate is false\n * @return the transformer\n * @throws NullPointerException if either the predicate or transformer is null\n * @see IfTransformer\n * @since 4.1\n */\npublic static <I, O> Transformer<I, O> ifTransformer(final Predicate<? super I> predicate, final Transformer<? super I, ? extends O> trueTransformer, final Transformer<? super I, ? extends O> falseTransformer) {\n    return IfTransformer.ifTransformer(predicate, trueTransformer, falseTransformer);\n}"
            ],
            [
                "switchTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Create a new Transformer that calls one of two transformers depending\n * on the specified predicate.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param predicate  the predicate to switch on\n * @param trueTransformer  the transformer called if the predicate is true\n * @param falseTransformer  the transformer called if the predicate is false\n * @return the transformer\n * @throws NullPointerException if either the predicate or transformer is null\n * @see SwitchTransformer\n * @deprecated as of 4.1, use {@link #ifTransformer(Predicate, Transformer, Transformer))\n */\n@SuppressWarnings(\"unchecked\")\n@Deprecated\npublic static <I, O> Transformer<I, O> switchTransformer(final Predicate<? super I> predicate, final Transformer<? super I, ? extends O> trueTransformer, final Transformer<? super I, ? extends O> falseTransformer) {\n    return SwitchTransformer.switchTransformer(new Predicate[] { predicate }, new Transformer[] { trueTransformer }, falseTransformer);\n}"
            ],
            [
                "switchTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Create a new Transformer that calls one of the transformers depending\n * on the predicates. The transformer at array location 0 is called if the\n * predicate at array location 0 returned true. Each predicate is evaluated\n * until one returns true. If no predicates evaluate to true, null is returned.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param predicates  an array of predicates to check\n * @param transformers  an array of transformers to call\n * @return the transformer\n * @throws NullPointerException if the either array is null\n * @throws NullPointerException if any element in the arrays is null\n * @throws IllegalArgumentException if the arrays have different sizes\n * @see SwitchTransformer\n */\npublic static <I, O> Transformer<I, O> switchTransformer(final Predicate<? super I>[] predicates, final Transformer<? super I, ? extends O>[] transformers) {\n    return SwitchTransformer.switchTransformer(predicates, transformers, null);\n}"
            ],
            [
                "switchTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Create a new Transformer that calls one of the transformers depending\n * on the predicates. The transformer at array location 0 is called if the\n * predicate at array location 0 returned true. Each predicate is evaluated\n * until one returns true. If no predicates evaluate to true, the default\n * transformer is called. If the default transformer is null, null is returned.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param predicates  an array of predicates to check\n * @param transformers  an array of transformers to call\n * @param defaultTransformer  the default to call if no predicate matches, null means return null\n * @return the transformer\n * @throws NullPointerException if the either array is null\n * @throws NullPointerException if any element in the arrays is null\n * @throws IllegalArgumentException if the arrays have different sizes\n * @see SwitchTransformer\n */\npublic static <I, O> Transformer<I, O> switchTransformer(final Predicate<? super I>[] predicates, final Transformer<? super I, ? extends O>[] transformers, final Transformer<? super I, ? extends O> defaultTransformer) {\n    return SwitchTransformer.switchTransformer(predicates, transformers, defaultTransformer);\n}"
            ],
            [
                "switchTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Create a new Transformer that calls one of the transformers depending\n * on the predicates.\n * <p>\n * The Map consists of Predicate keys and Transformer values. A transformer\n * is called if its matching predicate returns true. Each predicate is evaluated\n * until one returns true. If no predicates evaluate to true, the default\n * transformer is called. The default transformer is set in the map with a\n * null key. If no default transformer is set, null will be returned in a default\n * case. The ordering is that of the iterator() method on the entryset collection\n * of the map.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param predicatesAndTransformers  a map of predicates to transformers\n * @return the transformer\n * @throws NullPointerException if the map is null\n * @throws NullPointerException if any transformer in the map is null\n * @throws ClassCastException  if the map elements are of the wrong type\n * @see SwitchTransformer\n */\npublic static <I, O> Transformer<I, O> switchTransformer(final Map<Predicate<I>, Transformer<I, O>> predicatesAndTransformers) {\n    return SwitchTransformer.switchTransformer(predicatesAndTransformers);\n}"
            ],
            [
                "switchMapTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Create a new Transformer that uses the input object as a key to find the\n * transformer to call.\n * <p>\n * The Map consists of object keys and Transformer values. A transformer\n * is called if the input object equals the key. If there is no match, the\n * default transformer is called. The default transformer is set in the map\n * using a null key. If no default is set, null will be returned in a default case.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param objectsAndTransformers  a map of objects to transformers\n * @return the transformer\n * @throws NullPointerException if the map is null\n * @throws NullPointerException if any transformer in the map is null\n * @see SwitchTransformer\n */\n@SuppressWarnings(\"unchecked\")\npublic static <I, O> Transformer<I, O> switchMapTransformer(final Map<I, Transformer<I, O>> objectsAndTransformers) {\n    if (objectsAndTransformers == null) {\n        throw new NullPointerException(\"The object and transformer map must not be null\");\n    }\n    final Transformer<? super I, ? extends O> def = objectsAndTransformers.remove(null);\n    final int size = objectsAndTransformers.size();\n    final Transformer<? super I, ? extends O>[] trs = new Transformer[size];\n    final Predicate<I>[] preds = new Predicate[size];\n    int i = 0;\n    for (final Map.Entry<I, Transformer<I, O>> entry : objectsAndTransformers.entrySet()) {\n        preds[i] = EqualPredicate.<I>equalPredicate(entry.getKey());\n        trs[i++] = entry.getValue();\n    }\n    return TransformerUtils.switchTransformer(preds, trs, def);\n}"
            ],
            [
                "instantiateTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Gets a Transformer that expects an input Class object that it will instantiate.\n *\n * @param <T>  the output type\n * @return the transformer\n * @see InstantiateTransformer\n */\npublic static <T> Transformer<Class<? extends T>, T> instantiateTransformer() {\n    return InstantiateTransformer.instantiateTransformer();\n}"
            ],
            [
                "instantiateTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Creates a Transformer that expects an input Class object that it will\n * instantiate. The constructor used is determined by the arguments specified\n * to this method.\n *\n * @param <T>  the output type\n * @param paramTypes  parameter types for the constructor, can be null\n * @param args  the arguments to pass to the constructor, can be null\n * @return the transformer\n * @throws IllegalArgumentException if the paramTypes and args don't match\n * @see InstantiateTransformer\n */\npublic static <T> Transformer<Class<? extends T>, T> instantiateTransformer(final Class<?>[] paramTypes, final Object[] args) {\n    return InstantiateTransformer.instantiateTransformer(paramTypes, args);\n}"
            ],
            [
                "mapTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Creates a Transformer that uses the passed in Map to transform the input\n * object (as a simple lookup).\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param map  the map to use to transform the objects\n * @return the transformer, or {@link ConstantTransformer#nullTransformer()} if the\n *   {@code map} is {@code null}\n * @see MapTransformer\n */\npublic static <I, O> Transformer<I, O> mapTransformer(final Map<? super I, ? extends O> map) {\n    return MapTransformer.mapTransformer(map);\n}"
            ],
            [
                "invokerTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Gets a Transformer that invokes a method on the input object.\n * The method must have no parameters. If the input object is null,\n * null is returned.\n * <p>\n * For example, <code>TransformerUtils.invokerTransformer(\"getName\");</code>\n * will call the <code>getName/code> method on the input object to\n * determine the transformer result.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param methodName  the method name to call on the input object, may not be null\n * @return the transformer\n * @throws NullPointerException if the methodName is null.\n * @see InvokerTransformer\n */\npublic static <I, O> Transformer<I, O> invokerTransformer(final String methodName) {\n    return InvokerTransformer.invokerTransformer(methodName, null, null);\n}"
            ],
            [
                "invokerTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Gets a Transformer that invokes a method on the input object.\n * The method parameters are specified. If the input object is {@code null},\n * {@code null} is returned.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param methodName  the name of the method\n * @param paramTypes  the parameter types\n * @param args  the arguments\n * @return the transformer\n * @throws NullPointerException if the method name is null\n * @throws IllegalArgumentException if the paramTypes and args don't match\n * @see InvokerTransformer\n */\npublic static <I, O> Transformer<I, O> invokerTransformer(final String methodName, final Class<?>[] paramTypes, final Object[] args) {\n    return InvokerTransformer.invokerTransformer(methodName, paramTypes, args);\n}"
            ],
            [
                "stringValueTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Gets a transformer that returns a <code>java.lang.String</code>\n * representation of the input object. This is achieved via the\n * <code>toString</code> method, <code>null</code> returns 'null'.\n *\n * @param <T>  the input type\n * @return the transformer\n * @see StringValueTransformer\n */\npublic static <T> Transformer<T, String> stringValueTransformer() {\n    return StringValueTransformer.stringValueTransformer();\n}"
            ],
            [
                "exceptionPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "// Simple predicates\n//-----------------------------------------------------------------------------\n/**\n * Gets a Predicate that always throws an exception.\n * This could be useful during testing as a placeholder.\n *\n * @param <T>  the type that the predicate queries\n * @return the predicate\n * @see ExceptionPredicate\n */\npublic static <T> Predicate<T> exceptionPredicate() {\n    return ExceptionPredicate.exceptionPredicate();\n}"
            ],
            [
                "truePredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Gets a Predicate that always returns true.\n *\n * @param <T>  the type that the predicate queries\n * @return the predicate\n * @see TruePredicate\n */\npublic static <T> Predicate<T> truePredicate() {\n    return TruePredicate.truePredicate();\n}"
            ],
            [
                "falsePredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Gets a Predicate that always returns false.\n *\n * @param <T>  the type that the predicate queries\n * @return the predicate\n * @see FalsePredicate\n */\npublic static <T> Predicate<T> falsePredicate() {\n    return FalsePredicate.falsePredicate();\n}"
            ],
            [
                "nullPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Gets a Predicate that checks if the input object passed in is null.\n *\n * @param <T>  the type that the predicate queries\n * @return the predicate\n * @see NullPredicate\n */\npublic static <T> Predicate<T> nullPredicate() {\n    return NullPredicate.nullPredicate();\n}"
            ],
            [
                "notNullPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Gets a Predicate that checks if the input object passed in is not null.\n *\n * @param <T>  the type that the predicate queries\n * @return the predicate\n * @see NotNullPredicate\n */\npublic static <T> Predicate<T> notNullPredicate() {\n    return NotNullPredicate.notNullPredicate();\n}"
            ],
            [
                "equalPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Creates a Predicate that checks if the input object is equal to the\n * specified object using equals().\n *\n * @param <T>  the type that the predicate queries\n * @param value  the value to compare against\n * @return the predicate\n * @see EqualPredicate\n */\npublic static <T> Predicate<T> equalPredicate(final T value) {\n    return EqualPredicate.equalPredicate(value);\n}"
            ],
            [
                "identityPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Creates a Predicate that checks if the input object is equal to the\n * specified object by identity.\n *\n * @param <T>  the type that the predicate queries\n * @param value  the value to compare against\n * @return the predicate\n * @see IdentityPredicate\n */\npublic static <T> Predicate<T> identityPredicate(final T value) {\n    return IdentityPredicate.identityPredicate(value);\n}"
            ],
            [
                "instanceofPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Creates a Predicate that checks if the object passed in is of\n * a particular type, using instanceof. A <code>null</code> input\n * object will return <code>false</code>.\n *\n * @param type  the type to check for, may not be null\n * @return the predicate\n * @throws NullPointerException if the class is null\n * @see InstanceofPredicate\n */\npublic static Predicate<Object> instanceofPredicate(final Class<?> type) {\n    return InstanceofPredicate.instanceOfPredicate(type);\n}"
            ],
            [
                "uniquePredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Creates a Predicate that returns true the first time an object is\n * encountered, and false if the same object is received\n * again. The comparison is by equals(). A <code>null</code> input object\n * is accepted and will return true the first time, and false subsequently\n * as well.\n *\n * @param <T>  the type that the predicate queries\n * @return the predicate\n * @see UniquePredicate\n */\npublic static <T> Predicate<T> uniquePredicate() {\n    // must return new instance each time\n    return UniquePredicate.uniquePredicate();\n}"
            ],
            [
                "invokerPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Creates a Predicate that invokes a method on the input object.\n * The method must return either a boolean or a non-null Boolean,\n * and have no parameters. If the input object is null, a\n * PredicateException is thrown.\n * <p>\n * For example, <code>PredicateUtils.invokerPredicate(\"isEmpty\");</code>\n * will call the <code>isEmpty</code> method on the input object to\n * determine the predicate result.\n *\n * @param <T>  the type that the predicate queries\n * @param methodName  the method name to call on the input object, may not be null\n * @return the predicate\n * @throws NullPointerException if the methodName is null.\n * @see InvokerTransformer\n * @see TransformerPredicate\n */\npublic static <T> Predicate<T> invokerPredicate(final String methodName) {\n    // reuse transformer as it has caching - this is lazy really, should have inner class here\n    return asPredicate(InvokerTransformer.<Object, Boolean>invokerTransformer(methodName));\n}"
            ],
            [
                "invokerPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Creates a Predicate that invokes a method on the input object.\n * The method must return either a boolean or a non-null Boolean,\n * and have no parameters. If the input object is null, a\n * PredicateException is thrown.\n * <p>\n * For example, <code>PredicateUtils.invokerPredicate(\"isEmpty\");</code>\n * will call the <code>isEmpty</code> method on the input object to\n * determine the predicate result.\n *\n * @param <T>  the type that the predicate queries\n * @param methodName  the method name to call on the input object, may not be null\n * @param paramTypes  the parameter types\n * @param args  the arguments\n * @return the predicate\n * @throws NullPointerException if the method name is null\n * @throws IllegalArgumentException if the paramTypes and args don't match\n * @see InvokerTransformer\n * @see TransformerPredicate\n */\npublic static <T> Predicate<T> invokerPredicate(final String methodName, final Class<?>[] paramTypes, final Object[] args) {\n    // reuse transformer as it has caching - this is lazy really, should have inner class here\n    return asPredicate(InvokerTransformer.<Object, Boolean>invokerTransformer(methodName, paramTypes, args));\n}"
            ],
            [
                "andPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "// Boolean combinations\n//-----------------------------------------------------------------------------\n/**\n * Create a new Predicate that returns true only if both of the specified\n * predicates are true.\n *\n * @param <T>  the type that the predicate queries\n * @param predicate1  the first predicate, may not be null\n * @param predicate2  the second predicate, may not be null\n * @return the <code>and</code> predicate\n * @throws NullPointerException if either predicate is null\n * @see AndPredicate\n */\npublic static <T> Predicate<T> andPredicate(final Predicate<? super T> predicate1, final Predicate<? super T> predicate2) {\n    return AndPredicate.andPredicate(predicate1, predicate2);\n}"
            ],
            [
                "allPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true only if all of the specified\n * predicates are true.\n * If the array of predicates is empty, then this predicate returns true.\n *\n * @param <T>  the type that the predicate queries\n * @param predicates  an array of predicates to check, may not be null\n * @return the <code>all</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n * @see AllPredicate\n */\npublic static <T> Predicate<T> allPredicate(final Predicate<? super T>... predicates) {\n    return AllPredicate.allPredicate(predicates);\n}"
            ],
            [
                "allPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true only if all of the specified\n * predicates are true. The predicates are checked in iterator order.\n * If the collection of predicates is empty, then this predicate returns true.\n *\n * @param <T>  the type that the predicate queries\n * @param predicates  a collection of predicates to check, may not be null\n * @return the <code>all</code> predicate\n * @throws NullPointerException if the predicates collection is null\n * @throws NullPointerException if any predicate in the collection is null\n * @see AllPredicate\n */\npublic static <T> Predicate<T> allPredicate(final Collection<? extends Predicate<? super T>> predicates) {\n    return AllPredicate.allPredicate(predicates);\n}"
            ],
            [
                "orPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true if either of the specified\n * predicates are true.\n *\n * @param <T>  the type that the predicate queries\n * @param predicate1  the first predicate, may not be null\n * @param predicate2  the second predicate, may not be null\n * @return the <code>or</code> predicate\n * @throws NullPointerException if either predicate is null\n * @see OrPredicate\n */\npublic static <T> Predicate<T> orPredicate(final Predicate<? super T> predicate1, final Predicate<? super T> predicate2) {\n    return OrPredicate.orPredicate(predicate1, predicate2);\n}"
            ],
            [
                "anyPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true if any of the specified\n * predicates are true.\n * If the array of predicates is empty, then this predicate returns false.\n *\n * @param <T>  the type that the predicate queries\n * @param predicates  an array of predicates to check, may not be null\n * @return the <code>any</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n * @see AnyPredicate\n */\npublic static <T> Predicate<T> anyPredicate(final Predicate<? super T>... predicates) {\n    return AnyPredicate.anyPredicate(predicates);\n}"
            ],
            [
                "anyPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true if any of the specified\n * predicates are true. The predicates are checked in iterator order.\n * If the collection of predicates is empty, then this predicate returns false.\n *\n * @param <T>  the type that the predicate queries\n * @param predicates  a collection of predicates to check, may not be null\n * @return the <code>any</code> predicate\n * @throws NullPointerException if the predicates collection is null\n * @throws NullPointerException if any predicate in the collection is null\n * @see AnyPredicate\n */\npublic static <T> Predicate<T> anyPredicate(final Collection<? extends Predicate<? super T>> predicates) {\n    return AnyPredicate.anyPredicate(predicates);\n}"
            ],
            [
                "eitherPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true if one, but not both, of the\n * specified predicates are true. XOR\n *\n * @param <T>  the type that the predicate queries\n * @param predicate1  the first predicate, may not be null\n * @param predicate2  the second predicate, may not be null\n * @return the <code>either</code> predicate\n * @throws NullPointerException if either predicate is null\n * @see OnePredicate\n */\npublic static <T> Predicate<T> eitherPredicate(final Predicate<? super T> predicate1, final Predicate<? super T> predicate2) {\n    @SuppressWarnings(\"unchecked\")\n    final Predicate<T> onePredicate = PredicateUtils.onePredicate(predicate1, predicate2);\n    return onePredicate;\n}"
            ],
            [
                "onePredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true if only one of the specified\n * predicates are true.\n * If the array of predicates is empty, then this predicate returns false.\n *\n * @param <T>  the type that the predicate queries\n * @param predicates  an array of predicates to check, may not be null\n * @return the <code>one</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n * @see OnePredicate\n */\npublic static <T> Predicate<T> onePredicate(final Predicate<? super T>... predicates) {\n    return OnePredicate.onePredicate(predicates);\n}"
            ],
            [
                "onePredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true if only one of the specified\n * predicates are true. The predicates are checked in iterator order.\n * If the collection of predicates is empty, then this predicate returns false.\n *\n * @param <T>  the type that the predicate queries\n * @param predicates  a collection of predicates to check, may not be null\n * @return the <code>one</code> predicate\n * @throws NullPointerException if the predicates collection is null\n * @throws NullPointerException if any predicate in the collection is null\n * @see OnePredicate\n */\npublic static <T> Predicate<T> onePredicate(final Collection<? extends Predicate<? super T>> predicates) {\n    return OnePredicate.onePredicate(predicates);\n}"
            ],
            [
                "neitherPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true if neither of the specified\n * predicates are true.\n *\n * @param <T>  the type that the predicate queries\n * @param predicate1  the first predicate, may not be null\n * @param predicate2  the second predicate, may not be null\n * @return the <code>neither</code> predicate\n * @throws NullPointerException if either predicate is null\n * @see NonePredicate\n */\npublic static <T> Predicate<T> neitherPredicate(final Predicate<? super T> predicate1, final Predicate<? super T> predicate2) {\n    @SuppressWarnings(\"unchecked\")\n    final Predicate<T> nonePredicate = PredicateUtils.nonePredicate(predicate1, predicate2);\n    return nonePredicate;\n}"
            ],
            [
                "nonePredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true if none of the specified\n * predicates are true.\n * If the array of predicates is empty, then this predicate returns true.\n *\n * @param <T>  the type that the predicate queries\n * @param predicates  an array of predicates to check, may not be null\n * @return the <code>none</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n * @see NonePredicate\n */\npublic static <T> Predicate<T> nonePredicate(final Predicate<? super T>... predicates) {\n    return NonePredicate.nonePredicate(predicates);\n}"
            ],
            [
                "nonePredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true if none of the specified\n * predicates are true. The predicates are checked in iterator order.\n * If the collection of predicates is empty, then this predicate returns true.\n *\n * @param <T>  the type that the predicate queries\n * @param predicates  a collection of predicates to check, may not be null\n * @return the <code>none</code> predicate\n * @throws NullPointerException if the predicates collection is null\n * @throws NullPointerException if any predicate in the collection is null\n * @see NonePredicate\n */\npublic static <T> Predicate<T> nonePredicate(final Collection<? extends Predicate<? super T>> predicates) {\n    return NonePredicate.nonePredicate(predicates);\n}"
            ],
            [
                "notPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true if the specified predicate\n * returns false and vice versa.\n *\n * @param <T>  the type that the predicate queries\n * @param predicate  the predicate to not\n * @return the <code>not</code> predicate\n * @throws NullPointerException if the predicate is null\n * @see NotPredicate\n */\npublic static <T> Predicate<T> notPredicate(final Predicate<? super T> predicate) {\n    return NotPredicate.notPredicate(predicate);\n}"
            ],
            [
                "asPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "// Adaptors\n//-----------------------------------------------------------------------------\n/**\n * Create a new Predicate that wraps a Transformer. The Transformer must\n * return either Boolean.TRUE or Boolean.FALSE otherwise a PredicateException\n * will be thrown.\n *\n * @param <T>  the type that the predicate queries\n * @param transformer  the transformer to wrap, may not be null\n * @return the transformer wrapping predicate\n * @throws NullPointerException if the transformer is null\n * @see TransformerPredicate\n */\npublic static <T> Predicate<T> asPredicate(final Transformer<? super T, Boolean> transformer) {\n    return TransformerPredicate.transformerPredicate(transformer);\n}"
            ],
            [
                "nullIsExceptionPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "// Null handlers\n//-----------------------------------------------------------------------------\n/**\n * Gets a Predicate that throws an exception if the input object is null,\n * otherwise it calls the specified Predicate. This allows null handling\n * behaviour to be added to Predicates that don't support nulls.\n *\n * @param <T>  the type that the predicate queries\n * @param predicate  the predicate to wrap, may not be null\n * @return the predicate\n * @throws NullPointerException if the predicate is null.\n * @see NullIsExceptionPredicate\n */\npublic static <T> Predicate<T> nullIsExceptionPredicate(final Predicate<? super T> predicate) {\n    return NullIsExceptionPredicate.nullIsExceptionPredicate(predicate);\n}"
            ],
            [
                "nullIsFalsePredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Gets a Predicate that returns false if the input object is null, otherwise\n * it calls the specified Predicate. This allows null handling behaviour to\n * be added to Predicates that don't support nulls.\n *\n * @param <T>  the type that the predicate queries\n * @param predicate  the predicate to wrap, may not be null\n * @return the predicate\n * @throws NullPointerException if the predicate is null.\n * @see NullIsFalsePredicate\n */\npublic static <T> Predicate<T> nullIsFalsePredicate(final Predicate<? super T> predicate) {\n    return NullIsFalsePredicate.nullIsFalsePredicate(predicate);\n}"
            ],
            [
                "nullIsTruePredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Gets a Predicate that returns true if the input object is null, otherwise\n * it calls the specified Predicate. This allows null handling behaviour to\n * be added to Predicates that don't support nulls.\n *\n * @param <T>  the type that the predicate queries\n * @param predicate  the predicate to wrap, may not be null\n * @return the predicate\n * @throws NullPointerException if the predicate is null.\n * @see NullIsTruePredicate\n */\npublic static <T> Predicate<T> nullIsTruePredicate(final Predicate<? super T> predicate) {\n    return NullIsTruePredicate.nullIsTruePredicate(predicate);\n}"
            ],
            [
                "transformedPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "// Transformed\n//-----------------------------------------------------------------------\n/**\n * Creates a predicate that transforms the input object before passing it\n * to the predicate.\n *\n * @param <T>  the type that the predicate queries\n * @param transformer  the transformer to call first\n * @param predicate  the predicate to call with the result of the transform\n * @return the predicate\n * @throws NullPointerException if the transformer or the predicate is null\n * @see TransformedPredicate\n * @since 3.1\n */\npublic static <T> Predicate<T> transformedPredicate(final Transformer<? super T, ? extends T> transformer, final Predicate<? super T> predicate) {\n    return TransformedPredicate.transformedPredicate(transformer, predicate);\n}"
            ],
            [
                "emptySet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Get a typed empty unmodifiable Set.\n * @param <E> the element type\n * @return an empty Set\n */\npublic static <E> Set<E> emptySet() {\n    return Collections.<E>emptySet();\n}"
            ],
            [
                "emptySortedSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Get a typed empty unmodifiable sorted set.\n * @param <E> the element type\n * @return an empty sorted Set\n */\n// empty set is OK for any type\n@SuppressWarnings(\"unchecked\")\npublic static <E> SortedSet<E> emptySortedSet() {\n    return EMPTY_SORTED_SET;\n}"
            ],
            [
                "emptyIfNull",
                "org.apache.commons.collections4",
                "SetUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns an immutable empty set if the argument is <code>null</code>,\n * or the argument itself otherwise.\n *\n * @param <T> the element type\n * @param set the set, possibly <code>null</code>\n * @return an empty set if the argument is <code>null</code>\n */\npublic static <T> Set<T> emptyIfNull(final Set<T> set) {\n    return set == null ? Collections.<T>emptySet() : set;\n}"
            ],
            [
                "isEqualSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Tests two sets for equality as per the <code>equals()</code> contract\n * in {@link java.util.Set#equals(java.lang.Object)}.\n * <p>\n * This method is useful for implementing <code>Set</code> when you cannot\n * extend AbstractSet. The method takes Collection instances to enable other\n * collection types to use the Set implementation algorithm.\n * <p>\n * The relevant text (slightly paraphrased as this is a static method) is:\n * <blockquote>\n * <p>Two sets are considered equal if they have\n * the same size, and every member of the first set is contained in\n * the second. This ensures that the {@code equals} method works\n * properly across different implementations of the {@code Set}\n * interface.</p>\n *\n * <p>\n * This implementation first checks if the two sets are the same object:\n * if so it returns {@code true}.  Then, it checks if the two sets are\n * identical in size; if not, it returns false. If so, it returns\n * {@code a.containsAll((Collection) b)}.</p>\n * </blockquote>\n *\n * @see java.util.Set\n * @param set1  the first set, may be null\n * @param set2  the second set, may be null\n * @return whether the sets are equal by value comparison\n */\npublic static boolean isEqualSet(final Collection<?> set1, final Collection<?> set2) {\n    if (set1 == set2) {\n        return true;\n    }\n    if (set1 == null || set2 == null || set1.size() != set2.size()) {\n        return false;\n    }\n    return set1.containsAll(set2);\n}"
            ],
            [
                "hashCodeForSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Generates a hash code using the algorithm specified in\n * {@link java.util.Set#hashCode()}.\n * <p>\n * This method is useful for implementing <code>Set</code> when you cannot\n * extend AbstractSet. The method takes Collection instances to enable other\n * collection types to use the Set implementation algorithm.\n *\n * @param <T> the element type\n * @see java.util.Set#hashCode()\n * @param set  the set to calculate the hash code for, may be null\n * @return the hash code\n */\npublic static <T> int hashCodeForSet(final Collection<T> set) {\n    if (set == null) {\n        return 0;\n    }\n    int hashCode = 0;\n    for (final T obj : set) {\n        if (obj != null) {\n            hashCode += obj.hashCode();\n        }\n    }\n    return hashCode;\n}"
            ],
            [
                "newIdentityHashSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a new hash set that matches elements based on <code>==</code> not\n * <code>equals()</code>.\n * <p>\n * <strong>This set will violate the detail of various Set contracts.</note>\n * As a general rule, don't compare this set to other sets. In particular, you can't\n * use decorators like {@link ListOrderedSet} on it, which silently assume that these\n * contracts are fulfilled.</strong>\n * <p>\n * <strong>Note that the returned set is not synchronized and is not thread-safe.</strong>\n * If you wish to use this set from multiple threads concurrently, you must use\n * appropriate synchronization. The simplest approach is to wrap this map\n * using {@link java.util.Collections#synchronizedSet(Set)}. This class may throw\n * exceptions when accessed by concurrent threads without synchronization.\n *\n * @param <E>  the element type\n * @return a new identity hash set\n * @since 4.1\n */\npublic static <E> Set<E> newIdentityHashSet() {\n    return Collections.newSetFromMap(new IdentityHashMap<E, Boolean>());\n}"
            ],
            [
                "synchronizedSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "// Set\n//-----------------------------------------------------------------------\n/**\n * Returns a synchronized set backed by the given set.\n * <p>\n * You must manually synchronize on the returned set's iterator to\n * avoid non-deterministic behavior:\n *\n * <pre>\n * Set s = SetUtils.synchronizedSet(mySet);\n * synchronized (s) {\n *     Iterator i = s.iterator();\n *     while (i.hasNext()) {\n *         process (i.next());\n *     }\n * }\n * </pre>\n *\n * This method is just a wrapper for {@link Collections#synchronizedSet(Set)}.\n *\n * @param <E> the element type\n * @param set  the set to synchronize, must not be null\n * @return a synchronized set backed by the given set\n * @throws NullPointerException if the set is null\n */\npublic static <E> Set<E> synchronizedSet(final Set<E> set) {\n    return Collections.synchronizedSet(set);\n}"
            ],
            [
                "unmodifiableSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns an unmodifiable set backed by the given set.\n * <p>\n * This method uses the implementation in the decorators subpackage.\n *\n * @param <E> the element type\n * @param set  the set to make unmodifiable, must not be null\n * @return an unmodifiable set backed by the given set\n * @throws NullPointerException if the set is null\n */\npublic static <E> Set<E> unmodifiableSet(final Set<? extends E> set) {\n    return UnmodifiableSet.unmodifiableSet(set);\n}"
            ],
            [
                "predicatedSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a predicated (validating) set backed by the given set.\n * <p>\n * Only objects that pass the test in the given predicate can be added to the set.\n * Trying to add an invalid object results in an IllegalArgumentException.\n * It is important not to use the original set after invoking this method,\n * as it is a backdoor for adding invalid objects.\n *\n * @param <E> the element type\n * @param set  the set to predicate, must not be null\n * @param predicate  the predicate for the set, must not be null\n * @return a predicated set backed by the given set\n * @throws NullPointerException if the set or predicate is null\n */\npublic static <E> Set<E> predicatedSet(final Set<E> set, final Predicate<? super E> predicate) {\n    return PredicatedSet.predicatedSet(set, predicate);\n}"
            ],
            [
                "transformedSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a transformed set backed by the given set.\n * <p>\n * Each object is passed through the transformer as it is added to the\n * Set. It is important not to use the original set after invoking this\n * method, as it is a backdoor for adding untransformed objects.\n * <p>\n * Existing entries in the specified set will not be transformed.\n * If you want that behaviour, see {@link TransformedSet#transformedSet}.\n *\n * @param <E> the element type\n * @param set  the set to transform, must not be null\n * @param transformer  the transformer for the set, must not be null\n * @return a transformed set backed by the given set\n * @throws NullPointerException if the set or transformer is null\n */\npublic static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer) {\n    return TransformedSet.transformingSet(set, transformer);\n}"
            ],
            [
                "orderedSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a set that maintains the order of elements that are added\n * backed by the given set.\n * <p>\n * If an element is added twice, the order is determined by the first add.\n * The order is observed through the iterator or toArray.\n *\n * @param <E> the element type\n * @param set  the set to order, must not be null\n * @return an ordered set backed by the given set\n * @throws NullPointerException if the set is null\n */\npublic static <E> Set<E> orderedSet(final Set<E> set) {\n    return ListOrderedSet.listOrderedSet(set);\n}"
            ],
            [
                "synchronizedSortedSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "// SortedSet\n//-----------------------------------------------------------------------\n/**\n * Returns a synchronized sorted set backed by the given sorted set.\n * <p>\n * You must manually synchronize on the returned set's iterator to\n * avoid non-deterministic behavior:\n *\n * <pre>\n * Set s = SetUtils.synchronizedSortedSet(mySet);\n * synchronized (s) {\n *     Iterator i = s.iterator();\n *     while (i.hasNext()) {\n *         process (i.next());\n *     }\n * }\n * </pre>\n *\n * This method is just a wrapper for {@link Collections#synchronizedSortedSet(SortedSet)}.\n *\n * @param <E> the element type\n * @param set  the sorted set to synchronize, must not be null\n * @return a synchronized set backed by the given set\n * @throws NullPointerException if the set is null\n */\npublic static <E> SortedSet<E> synchronizedSortedSet(final SortedSet<E> set) {\n    return Collections.synchronizedSortedSet(set);\n}"
            ],
            [
                "unmodifiableSortedSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns an unmodifiable sorted set backed by the given sorted set.\n * <p>\n * This method uses the implementation in the decorators subpackage.\n *\n * @param <E> the element type\n * @param set  the sorted set to make unmodifiable, must not be null\n * @return an unmodifiable set backed by the given set\n * @throws NullPointerException if the set is null\n */\npublic static <E> SortedSet<E> unmodifiableSortedSet(final SortedSet<E> set) {\n    return UnmodifiableSortedSet.unmodifiableSortedSet(set);\n}"
            ],
            [
                "predicatedSortedSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a predicated (validating) sorted set backed by the given sorted set.\n * <p>\n * Only objects that pass the test in the given predicate can be added to the set.\n * Trying to add an invalid object results in an IllegalArgumentException.\n * It is important not to use the original set after invoking this method,\n * as it is a backdoor for adding invalid objects.\n *\n * @param <E> the element type\n * @param set  the sorted set to predicate, must not be null\n * @param predicate  the predicate for the sorted set, must not be null\n * @return a predicated sorted set backed by the given sorted set\n * @throws NullPointerException if the set or predicate is null\n */\npublic static <E> SortedSet<E> predicatedSortedSet(final SortedSet<E> set, final Predicate<? super E> predicate) {\n    return PredicatedSortedSet.predicatedSortedSet(set, predicate);\n}"
            ],
            [
                "transformedSortedSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a transformed sorted set backed by the given set.\n * <p>\n * Each object is passed through the transformer as it is added to the\n * Set. It is important not to use the original set after invoking this\n * method, as it is a backdoor for adding untransformed objects.\n * <p>\n * Existing entries in the specified set will not be transformed.\n * If you want that behaviour, see {@link TransformedSortedSet#transformedSortedSet}.\n *\n * @param <E> the element type\n * @param set  the set to transform, must not be null\n * @param transformer  the transformer for the set, must not be null\n * @return a transformed set backed by the given set\n * @throws NullPointerException if the set or transformer is null\n */\npublic static <E> SortedSet<E> transformedSortedSet(final SortedSet<E> set, final Transformer<? super E, ? extends E> transformer) {\n    return TransformedSortedSet.transformingSortedSet(set, transformer);\n}"
            ],
            [
                "unmodifiableNavigableSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "// NavigableSet\n//-----------------------------------------------------------------------\n/**\n * Returns an unmodifiable navigable set backed by the given navigable set.\n * <p>\n * This method uses the implementation in the decorators subpackage.\n *\n * @param <E> the element type\n * @param set  the navigable set to make unmodifiable, must not be null\n * @return an unmodifiable set backed by the given set\n * @throws NullPointerException if the set is null\n * @since 4.1\n */\npublic static <E> SortedSet<E> unmodifiableNavigableSet(final NavigableSet<E> set) {\n    return UnmodifiableNavigableSet.unmodifiableNavigableSet(set);\n}"
            ],
            [
                "predicatedNavigableSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a predicated (validating) navigable set backed by the given navigable set.\n * <p>\n * Only objects that pass the test in the given predicate can be added to the set.\n * Trying to add an invalid object results in an IllegalArgumentException.\n * It is important not to use the original set after invoking this method,\n * as it is a backdoor for adding invalid objects.\n *\n * @param <E> the element type\n * @param set  the navigable set to predicate, must not be null\n * @param predicate  the predicate for the navigable set, must not be null\n * @return a predicated navigable set backed by the given navigable set\n * @throws NullPointerException if the set or predicate is null\n * @since 4.1\n */\npublic static <E> SortedSet<E> predicatedNavigableSet(final NavigableSet<E> set, final Predicate<? super E> predicate) {\n    return PredicatedNavigableSet.predicatedNavigableSet(set, predicate);\n}"
            ],
            [
                "transformedNavigableSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a transformed navigable set backed by the given navigable set.\n * <p>\n * Each object is passed through the transformer as it is added to the\n * Set. It is important not to use the original set after invoking this\n * method, as it is a backdoor for adding untransformed objects.\n * <p>\n * Existing entries in the specified set will not be transformed.\n * If you want that behaviour, see {@link TransformedNavigableSet#transformedNavigableSet}.\n *\n * @param <E> the element type\n * @param set  the navigable set to transform, must not be null\n * @param transformer  the transformer for the set, must not be null\n * @return a transformed set backed by the given set\n * @throws NullPointerException if the set or transformer is null\n * @since 4.1\n */\npublic static <E> SortedSet<E> transformedNavigableSet(final NavigableSet<E> set, final Transformer<? super E, ? extends E> transformer) {\n    return TransformedNavigableSet.transformingNavigableSet(set, transformer);\n}"
            ],
            [
                "union",
                "org.apache.commons.collections4",
                "SetUtils",
                "// Set operations\n//-----------------------------------------------------------------------\n/**\n * Returns a unmodifiable <b>view</b> of the union of the given {@link Set}s.\n * <p>\n * The returned view contains all elements of {@code a} and {@code b}.\n *\n * @param <E> the generic type that is able to represent the types contained\n *   in both input sets.\n * @param a  the first set, must not be null\n * @param b  the second set, must not be null\n * @return a view of the union of the two set\n * @throws NullPointerException if either input set is null\n * @since 4.1\n */\npublic static <E> SetView<E> union(final Set<? extends E> a, final Set<? extends E> b) {\n    if (a == null || b == null) {\n        throw new NullPointerException(\"Sets must not be null.\");\n    }\n    final SetView<E> bMinusA = difference(b, a);\n    return new SetView<E>() {\n\n        @Override\n        public boolean contains(Object o) {\n            return a.contains(o) || b.contains(o);\n        }\n\n        @Override\n        public Iterator<E> createIterator() {\n            return IteratorUtils.chainedIterator(a.iterator(), bMinusA.iterator());\n        }\n\n        @Override\n        public boolean isEmpty() {\n            return a.isEmpty() && b.isEmpty();\n        }\n\n        @Override\n        public int size() {\n            return a.size() + bMinusA.size();\n        }\n    };\n}"
            ],
            [
                "difference",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a unmodifiable <b>view</b> containing the difference of the given\n * {@link Set}s, denoted by {@code a \\ b} (or {@code a - b}).\n * <p>\n * The returned view contains all elements of {@code a} that are not a member\n * of {@code b}.\n *\n * @param <E> the generic type that is able to represent the types contained\n *   in both input sets.\n * @param a  the set to subtract from, must not be null\n * @param b  the set to subtract, must not be null\n * @return a view of the relative complement of  of the two sets\n * @since 4.1\n */\npublic static <E> SetView<E> difference(final Set<? extends E> a, final Set<? extends E> b) {\n    if (a == null || b == null) {\n        throw new NullPointerException(\"Sets must not be null.\");\n    }\n    final Predicate<E> notContainedInB = new Predicate<E>() {\n\n        @Override\n        public boolean evaluate(E object) {\n            return !b.contains(object);\n        }\n    };\n    return new SetView<E>() {\n\n        @Override\n        public boolean contains(Object o) {\n            return a.contains(o) && !b.contains(o);\n        }\n\n        @Override\n        public Iterator<E> createIterator() {\n            return IteratorUtils.filteredIterator(a.iterator(), notContainedInB);\n        }\n    };\n}"
            ],
            [
                "intersection",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a unmodifiable <b>view</b> of the intersection of the given {@link Set}s.\n * <p>\n * The returned view contains all elements that are members of both input sets\n * ({@code a} and {@code b}).\n *\n * @param <E> the generic type that is able to represent the types contained\n *   in both input sets.\n * @param a  the first set, must not be null\n * @param b  the second set, must not be null\n * @return a view of the intersection of the two sets\n * @since 4.1\n */\npublic static <E> SetView<E> intersection(final Set<? extends E> a, final Set<? extends E> b) {\n    if (a == null || b == null) {\n        throw new NullPointerException(\"Sets must not be null.\");\n    }\n    final Predicate<E> containedInB = new Predicate<E>() {\n\n        @Override\n        public boolean evaluate(E object) {\n            return b.contains(object);\n        }\n    };\n    return new SetView<E>() {\n\n        @Override\n        public boolean contains(Object o) {\n            return a.contains(o) && b.contains(o);\n        }\n\n        @Override\n        public Iterator<E> createIterator() {\n            return IteratorUtils.filteredIterator(a.iterator(), containedInB);\n        }\n    };\n}"
            ],
            [
                "disjunction",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a unmodifiable <b>view</b> of the symmetric difference of the given\n * {@link Set}s.\n * <p>\n * The returned view contains all elements of {@code a} and {@code b} that are\n * not a member of the other set.\n * <p>\n * This is equivalent to {@code union(difference(a, b), difference(b, a))}.\n *\n * @param <E> the generic type that is able to represent the types contained\n *   in both input sets.\n * @param a  the first set, must not be null\n * @param b  the second set, must not be null\n * @return a view of the symmetric difference of the two sets\n * @since 4.1\n */\npublic static <E> SetView<E> disjunction(final Set<? extends E> a, final Set<? extends E> b) {\n    if (a == null || b == null) {\n        throw new NullPointerException(\"Sets must not be null.\");\n    }\n    final SetView<E> aMinusB = difference(a, b);\n    final SetView<E> bMinusA = difference(b, a);\n    return new SetView<E>() {\n\n        @Override\n        public boolean contains(Object o) {\n            return a.contains(o) ^ b.contains(o);\n        }\n\n        @Override\n        public Iterator<E> createIterator() {\n            return IteratorUtils.chainedIterator(aMinusB.iterator(), bMinusA.iterator());\n        }\n\n        @Override\n        public boolean isEmpty() {\n            return aMinusB.isEmpty() && bMinusA.isEmpty();\n        }\n\n        @Override\n        public int size() {\n            return aMinusB.size() + bMinusA.size();\n        }\n    };\n}"
            ],
            [
                "transformingSet",
                "org.apache.commons.collections4.set",
                "TransformedSet",
                "/**\n * Factory method to create a transforming set.\n * <p>\n * If there are any elements already in the set being decorated, they\n * are NOT transformed.\n * Contrast this with {@link #transformedSet(Set, Transformer)}.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed set\n * @throws NullPointerException if set or transformer is null\n * @since 4.0\n */\npublic static <E> TransformedSet<E> transformingSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer) {\n    return new TransformedSet<E>(set, transformer);\n}"
            ],
            [
                "transformedSet",
                "org.apache.commons.collections4.set",
                "TransformedSet",
                "/**\n * Factory method to create a transforming set that will transform\n * existing contents of the specified set.\n * <p>\n * If there are any elements already in the set being decorated, they\n * will be transformed by this method.\n * Contrast this with {@link #transformingSet(Set, Transformer)}.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed set\n * @throws NullPointerException if set or transformer is null\n * @since 4.0\n */\npublic static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer) {\n    final TransformedSet<E> decorated = new TransformedSet<E>(set, transformer);\n    if (set.size() > 0) {\n        // set is type E\n        @SuppressWarnings(\"unchecked\")\n        final E[] // NOPMD - false positive for generics\n        values = (E[]) set.toArray();\n        set.clear();\n        for (final E value : values) {\n            decorated.decorated().add(transformer.transform(value));\n        }\n    }\n    return decorated;\n}"
            ],
            [
                "transformingNavigableSet",
                "org.apache.commons.collections4.set",
                "TransformedNavigableSet",
                "/**\n * Factory method to create a transforming navigable set.\n * <p>\n * If there are any elements already in the set being decorated, they\n * are NOT transformed.\n * Contrast this with {@link #transformedNavigableSet(NavigableSet, Transformer)}.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed {@link NavigableSet}\n * @throws NullPointerException if set or transformer is null\n */\npublic static <E> TransformedNavigableSet<E> transformingNavigableSet(final NavigableSet<E> set, final Transformer<? super E, ? extends E> transformer) {\n    return new TransformedNavigableSet<E>(set, transformer);\n}"
            ],
            [
                "transformedNavigableSet",
                "org.apache.commons.collections4.set",
                "TransformedNavigableSet",
                "/**\n * Factory method to create a transforming navigable set that will transform\n * existing contents of the specified navigable set.\n * <p>\n * If there are any elements already in the set being decorated, they\n * will be transformed by this method.\n * Contrast this with {@link #transformingNavigableSet(NavigableSet, Transformer)}.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed {@link NavigableSet}\n * @throws NullPointerException if set or transformer is null\n */\npublic static <E> TransformedNavigableSet<E> transformedNavigableSet(final NavigableSet<E> set, final Transformer<? super E, ? extends E> transformer) {\n    final TransformedNavigableSet<E> decorated = new TransformedNavigableSet<E>(set, transformer);\n    if (set.size() > 0) {\n        // set is type E\n        @SuppressWarnings(\"unchecked\")\n        final E[] // NOPMD - false positive for generics\n        values = (E[]) set.toArray();\n        set.clear();\n        for (final E value : values) {\n            decorated.decorated().add(transformer.transform(value));\n        }\n    }\n    return decorated;\n}"
            ],
            [
                "predicatedNavigableSet",
                "org.apache.commons.collections4.set",
                "PredicatedNavigableSet",
                "/**\n * Factory method to create a predicated (validating) navigable set.\n * <p>\n * If there are any elements already in the set being decorated, they\n * are validated.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @param predicate  the predicate to use for validation, must not be null\n * @return a new predicated navigable set.\n * @throws NullPointerException if set or predicate is null\n * @throws IllegalArgumentException if the set contains invalid elements\n * @since 4.0\n */\npublic static <E> PredicatedNavigableSet<E> predicatedNavigableSet(final NavigableSet<E> set, final Predicate<? super E> predicate) {\n    return new PredicatedNavigableSet<E>(set, predicate);\n}"
            ],
            [
                "listOrderedSet",
                "org.apache.commons.collections4.set",
                "ListOrderedSet",
                "/**\n * Factory method to create an ordered set specifying the list and set to use.\n * <p>\n * The list and set must both be empty.\n *\n * @param <E> the element type\n * @param set the set to decorate, must be empty and not null\n * @param list the list to decorate, must be empty and not null\n * @return a new ordered set\n * @throws NullPointerException if set or list is null\n * @throws IllegalArgumentException if either the set or list is not empty\n * @since 4.0\n */\npublic static <E> ListOrderedSet<E> listOrderedSet(final Set<E> set, final List<E> list) {\n    if (set == null) {\n        throw new NullPointerException(\"Set must not be null\");\n    }\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (set.size() > 0 || list.size() > 0) {\n        throw new IllegalArgumentException(\"Set and List must be empty\");\n    }\n    return new ListOrderedSet<E>(set, list);\n}"
            ],
            [
                "listOrderedSet",
                "org.apache.commons.collections4.set",
                "ListOrderedSet",
                "/**\n * Factory method to create an ordered set.\n * <p>\n * An <code>ArrayList</code> is used to retain order.\n *\n * @param <E> the element type\n * @param set the set to decorate, must not be null\n * @return a new ordered set\n * @throws NullPointerException if set is null\n * @since 4.0\n */\npublic static <E> ListOrderedSet<E> listOrderedSet(final Set<E> set) {\n    return new ListOrderedSet<E>(set);\n}"
            ],
            [
                "listOrderedSet",
                "org.apache.commons.collections4.set",
                "ListOrderedSet",
                "/**\n * Factory method to create an ordered set using the supplied list to retain order.\n * <p>\n * A <code>HashSet</code> is used for the set behaviour.\n * <p>\n * NOTE: If the list contains duplicates, the duplicates are removed,\n * altering the specified list.\n *\n * @param <E> the element type\n * @param list the list to decorate, must not be null\n * @return a new ordered set\n * @throws NullPointerException if list is null\n * @since 4.0\n */\npublic static <E> ListOrderedSet<E> listOrderedSet(final List<E> list) {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n    return new ListOrderedSet<E>(set, list);\n}"
            ],
            [
                "unmodifiableSet",
                "org.apache.commons.collections4.set",
                "UnmodifiableSet",
                "/**\n * Factory method to create an unmodifiable set.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @return a new unmodifiable set\n * @throws NullPointerException if set is null\n * @since 4.0\n */\npublic static <E> Set<E> unmodifiableSet(final Set<? extends E> set) {\n    if (set instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final Set<E> tmpSet = (Set<E>) set;\n        return tmpSet;\n    }\n    return new UnmodifiableSet<E>(set);\n}"
            ],
            [
                "mapBackedSet",
                "org.apache.commons.collections4.set",
                "MapBackedSet",
                "/**\n * Factory method to create a set from a map.\n *\n * @param <E> the element type\n * @param <V> the dummy value type in the map\n * @param map  the map to decorate, must not be null\n * @return a new map backed set\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <E, V> MapBackedSet<E, V> mapBackedSet(final Map<E, ? super V> map) {\n    return mapBackedSet(map, null);\n}"
            ],
            [
                "mapBackedSet",
                "org.apache.commons.collections4.set",
                "MapBackedSet",
                "/**\n * Factory method to create a set from a map.\n *\n * @param <E> the element type\n * @param <V> the dummy value type in the map\n * @param map  the map to decorate, must not be null\n * @param dummyValue  the dummy value to use\n * @return a new map backed set\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <E, V> MapBackedSet<E, V> mapBackedSet(final Map<E, ? super V> map, final V dummyValue) {\n    return new MapBackedSet<E, V>(map, dummyValue);\n}"
            ],
            [
                "unmodifiableSortedSet",
                "org.apache.commons.collections4.set",
                "UnmodifiableSortedSet",
                "/**\n * Factory method to create an unmodifiable set.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @return a new unmodifiable {@link SortedSet}\n * @throws NullPointerException if set is null\n * @since 4.0\n */\npublic static <E> SortedSet<E> unmodifiableSortedSet(final SortedSet<E> set) {\n    if (set instanceof Unmodifiable) {\n        return set;\n    }\n    return new UnmodifiableSortedSet<E>(set);\n}"
            ],
            [
                "predicatedSortedSet",
                "org.apache.commons.collections4.set",
                "PredicatedSortedSet",
                "/**\n * Factory method to create a predicated (validating) sorted set.\n * <p>\n * If there are any elements already in the set being decorated, they\n * are validated.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @param predicate  the predicate to use for validation, must not be null\n * @return a new predicated sorted set.\n * @throws NullPointerException if set or predicate is null\n * @throws IllegalArgumentException if the set contains invalid elements\n * @since 4.0\n */\npublic static <E> PredicatedSortedSet<E> predicatedSortedSet(final SortedSet<E> set, final Predicate<? super E> predicate) {\n    return new PredicatedSortedSet<E>(set, predicate);\n}"
            ],
            [
                "predicatedSet",
                "org.apache.commons.collections4.set",
                "PredicatedSet",
                "/**\n * Factory method to create a predicated (validating) set.\n * <p>\n * If there are any elements already in the set being decorated, they\n * are validated.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @param predicate  the predicate to use for validation, must not be null\n * @return a decorated set\n * @throws NullPointerException if set or predicate is null\n * @throws IllegalArgumentException if the set contains invalid elements\n * @since 4.0\n */\npublic static <E> PredicatedSet<E> predicatedSet(final Set<E> set, final Predicate<? super E> predicate) {\n    return new PredicatedSet<E>(set, predicate);\n}"
            ],
            [
                "unmodifiableNavigableSet",
                "org.apache.commons.collections4.set",
                "UnmodifiableNavigableSet",
                "/**\n * Factory method to create an unmodifiable set.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @return a new unmodifiable {@link NavigableSet}\n * @throws NullPointerException if set is null\n */\npublic static <E> NavigableSet<E> unmodifiableNavigableSet(final NavigableSet<E> set) {\n    if (set instanceof Unmodifiable) {\n        return set;\n    }\n    return new UnmodifiableNavigableSet<E>(set);\n}"
            ],
            [
                "transformingSortedSet",
                "org.apache.commons.collections4.set",
                "TransformedSortedSet",
                "/**\n * Factory method to create a transforming sorted set.\n * <p>\n * If there are any elements already in the set being decorated, they\n * are NOT transformed.\n * Contrast this with {@link #transformedSortedSet(SortedSet, Transformer)}.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed {@link SortedSet}\n * @throws NullPointerException if set or transformer is null\n * @since 4.0\n */\npublic static <E> TransformedSortedSet<E> transformingSortedSet(final SortedSet<E> set, final Transformer<? super E, ? extends E> transformer) {\n    return new TransformedSortedSet<E>(set, transformer);\n}"
            ],
            [
                "transformedSortedSet",
                "org.apache.commons.collections4.set",
                "TransformedSortedSet",
                "/**\n * Factory method to create a transforming sorted set that will transform\n * existing contents of the specified sorted set.\n * <p>\n * If there are any elements already in the set being decorated, they\n * will be transformed by this method.\n * Contrast this with {@link #transformingSortedSet(SortedSet, Transformer)}.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed {@link SortedSet}\n * @throws NullPointerException if set or transformer is null\n * @since 4.0\n */\npublic static <E> TransformedSortedSet<E> transformedSortedSet(final SortedSet<E> set, final Transformer<? super E, ? extends E> transformer) {\n    final TransformedSortedSet<E> decorated = new TransformedSortedSet<E>(set, transformer);\n    if (set.size() > 0) {\n        // set is type E\n        @SuppressWarnings(\"unchecked\")\n        final E[] // NOPMD - false positive for generics\n        values = (E[]) set.toArray();\n        set.clear();\n        for (final E value : values) {\n            decorated.decorated().add(transformer.transform(value));\n        }\n    }\n    return decorated;\n}"
            ],
            [
                "get",
                "org.apache.commons.collections4",
                "EnumerationUtils",
                "/**\n * Returns the <code>index</code>-th value in the {@link Enumeration}, throwing\n * <code>IndexOutOfBoundsException</code> if there is no such element.\n * <p>\n * The Enumeration is advanced to <code>index</code> (or to the end, if\n * <code>index</code> exceeds the number of entries) as a side effect of this method.\n *\n * @param e  the enumeration to get a value from\n * @param index  the index to get\n * @param <T> the type of object in the {@link Enumeration}\n * @return the object at the specified index\n * @throws IndexOutOfBoundsException if the index is invalid\n * @throws IllegalArgumentException if the object type is invalid\n * @since 4.1\n */\npublic static <T> T get(final Enumeration<T> e, final int index) {\n    int i = index;\n    CollectionUtils.checkIndexBounds(i);\n    while (e.hasMoreElements()) {\n        i--;\n        if (i == -1) {\n            return e.nextElement();\n        } else {\n            e.nextElement();\n        }\n    }\n    throw new IndexOutOfBoundsException(\"Entry does not exist: \" + i);\n}"
            ],
            [
                "toList",
                "org.apache.commons.collections4",
                "EnumerationUtils",
                "/**\n * Creates a list based on an enumeration.\n *\n * <p>As the enumeration is traversed, an ArrayList of its values is\n * created. The new list is returned.</p>\n *\n * @param <E> the element type\n * @param enumeration  the enumeration to traverse, which should not be <code>null</code>.\n * @return a list containing all elements of the given enumeration\n * @throws NullPointerException if the enumeration parameter is <code>null</code>.\n */\npublic static <E> List<E> toList(final Enumeration<? extends E> enumeration) {\n    return IteratorUtils.toList(new EnumerationIterator<E>(enumeration));\n}"
            ],
            [
                "toList",
                "org.apache.commons.collections4",
                "EnumerationUtils",
                "/**\n * Override toList(Enumeration) for StringTokenizer as it implements Enumeration&lt;Object&gt;\n * for the sake of backward compatibility.\n *\n * @param stringTokenizer  the tokenizer to convert to a {@link List}&lt;{@link String}&gt;\n * @return a list containing all tokens of the given StringTokenizer\n */\npublic static List<String> toList(final StringTokenizer stringTokenizer) {\n    final List<String> result = new ArrayList<String>(stringTokenizer.countTokens());\n    while (stringTokenizer.hasMoreTokens()) {\n        result.add(stringTokenizer.nextToken());\n    }\n    return result;\n}"
            ],
            [
                "unmodifiableQueue",
                "org.apache.commons.collections4",
                "QueueUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns an unmodifiable queue backed by the given queue.\n *\n * @param <E> the type of the elements in the queue\n * @param queue  the queue to make unmodifiable, must not be null\n * @return an unmodifiable queue backed by that queue\n * @throws NullPointerException if the queue is null\n */\npublic static <E> Queue<E> unmodifiableQueue(final Queue<? extends E> queue) {\n    return UnmodifiableQueue.unmodifiableQueue(queue);\n}"
            ],
            [
                "predicatedQueue",
                "org.apache.commons.collections4",
                "QueueUtils",
                "/**\n * Returns a predicated (validating) queue backed by the given queue.\n * <p>\n * Only objects that pass the test in the given predicate can be added to the queue.\n * Trying to add an invalid object results in an IllegalArgumentException.\n * It is important not to use the original queue after invoking this method,\n * as it is a backdoor for adding invalid objects.\n *\n * @param <E> the type of the elements in the queue\n * @param queue  the queue to predicate, must not be null\n * @param predicate  the predicate used to evaluate new elements, must not be null\n * @return a predicated queue\n * @throws NullPointerException if the queue or predicate is null\n */\npublic static <E> Queue<E> predicatedQueue(final Queue<E> queue, final Predicate<? super E> predicate) {\n    return PredicatedQueue.predicatedQueue(queue, predicate);\n}"
            ],
            [
                "transformingQueue",
                "org.apache.commons.collections4",
                "QueueUtils",
                "/**\n * Returns a transformed queue backed by the given queue.\n * <p>\n * Each object is passed through the transformer as it is added to the\n * Queue. It is important not to use the original queue after invoking this\n * method, as it is a backdoor for adding untransformed objects.\n * <p>\n * Existing entries in the specified queue will not be transformed.\n * If you want that behaviour, see {@link TransformedQueue#transformedQueue}.\n *\n * @param <E> the type of the elements in the queue\n * @param queue  the queue to predicate, must not be null\n * @param transformer  the transformer for the queue, must not be null\n * @return a transformed queue backed by the given queue\n * @throws NullPointerException if the queue or transformer is null\n */\npublic static <E> Queue<E> transformingQueue(final Queue<E> queue, final Transformer<? super E, ? extends E> transformer) {\n    return TransformedQueue.transformingQueue(queue, transformer);\n}"
            ],
            [
                "emptyQueue",
                "org.apache.commons.collections4",
                "QueueUtils",
                "/**\n * Get an empty <code>Queue</code>.\n *\n * @param <E> the type of the elements in the queue\n * @return an empty {@link Queue}\n */\n// OK, empty queue is compatible with any type\n@SuppressWarnings(\"unchecked\")\npublic static <E> Queue<E> emptyQueue() {\n    return (Queue<E>) EMPTY_QUEUE;\n}"
            ],
            [
                "synchronizedBag",
                "org.apache.commons.collections4.bag",
                "SynchronizedBag",
                "/**\n * Factory method to create a synchronized bag.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @return a new synchronized Bag\n * @throws NullPointerException if bag is null\n * @since 4.0\n */\npublic static <E> SynchronizedBag<E> synchronizedBag(final Bag<E> bag) {\n    return new SynchronizedBag<E>(bag);\n}"
            ],
            [
                "collectionBag",
                "org.apache.commons.collections4.bag",
                "CollectionBag",
                "/**\n * Factory method to create a bag that complies to the Collection contract.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @return a Bag that complies to the Collection contract\n * @throws NullPointerException if bag is null\n */\npublic static <E> Bag<E> collectionBag(final Bag<E> bag) {\n    return new CollectionBag<E>(bag);\n}"
            ],
            [
                "unmodifiableBag",
                "org.apache.commons.collections4.bag",
                "UnmodifiableBag",
                "/**\n * Factory method to create an unmodifiable bag.\n * <p>\n * If the bag passed in is already unmodifiable, it is returned.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @return an unmodifiable Bag\n * @throws NullPointerException if bag is null\n * @since 4.0\n */\npublic static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n    if (bag instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final Bag<E> tmpBag = (Bag<E>) bag;\n        return tmpBag;\n    }\n    return new UnmodifiableBag<E>(bag);\n}"
            ],
            [
                "predicatedSortedBag",
                "org.apache.commons.collections4.bag",
                "PredicatedSortedBag",
                "/**\n * Factory method to create a predicated (validating) bag.\n * <p>\n * If there are any elements already in the bag being decorated, they\n * are validated.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @param predicate  the predicate to use for validation, must not be null\n * @return a new predicated SortedBag\n * @throws NullPointerException if bag or predicate is null\n * @throws IllegalArgumentException if the bag contains invalid elements\n * @since 4.0\n */\npublic static <E> PredicatedSortedBag<E> predicatedSortedBag(final SortedBag<E> bag, final Predicate<? super E> predicate) {\n    return new PredicatedSortedBag<E>(bag, predicate);\n}"
            ],
            [
                "unmodifiableSortedBag",
                "org.apache.commons.collections4.bag",
                "UnmodifiableSortedBag",
                "/**\n * Factory method to create an unmodifiable bag.\n * <p>\n * If the bag passed in is already unmodifiable, it is returned.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @return an unmodifiable SortedBag\n * @throws NullPointerException if bag is null\n * @since 4.0\n */\npublic static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n    if (bag instanceof Unmodifiable) {\n        return bag;\n    }\n    return new UnmodifiableSortedBag<E>(bag);\n}"
            ],
            [
                "transformingSortedBag",
                "org.apache.commons.collections4.bag",
                "TransformedSortedBag",
                "/**\n * Factory method to create a transforming sorted bag.\n * <p>\n * If there are any elements already in the bag being decorated, they\n * are NOT transformed. Contrast this with {@link #transformedSortedBag(SortedBag, Transformer)}.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed SortedBag\n * @throws NullPointerException if bag or transformer is null\n * @since 4.0\n */\npublic static <E> TransformedSortedBag<E> transformingSortedBag(final SortedBag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n    return new TransformedSortedBag<E>(bag, transformer);\n}"
            ],
            [
                "transformedSortedBag",
                "org.apache.commons.collections4.bag",
                "TransformedSortedBag",
                "/**\n * Factory method to create a transforming sorted bag that will transform\n * existing contents of the specified sorted bag.\n * <p>\n * If there are any elements already in the bag being decorated, they\n * will be transformed by this method.\n * Contrast this with {@link #transformingSortedBag(SortedBag, Transformer)}.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed SortedBag\n * @throws NullPointerException if bag or transformer is null\n * @since 4.0\n */\npublic static <E> TransformedSortedBag<E> transformedSortedBag(final SortedBag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n    final TransformedSortedBag<E> decorated = new TransformedSortedBag<E>(bag, transformer);\n    if (bag.size() > 0) {\n        // bag is type E\n        @SuppressWarnings(\"unchecked\")\n        final E[] // NOPMD - false positive for generics\n        values = (E[]) bag.toArray();\n        bag.clear();\n        for (final E value : values) {\n            decorated.decorated().add(transformer.transform(value));\n        }\n    }\n    return decorated;\n}"
            ],
            [
                "predicatedBag",
                "org.apache.commons.collections4.bag",
                "PredicatedBag",
                "/**\n * Factory method to create a predicated (validating) bag.\n * <p>\n * If there are any elements already in the bag being decorated, they\n * are validated.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @param predicate  the predicate to use for validation, must not be null\n * @return a new predicated Bag\n * @throws NullPointerException if bag or predicate is null\n * @throws IllegalArgumentException if the bag contains invalid elements\n * @since 4.0\n */\npublic static <E> PredicatedBag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n    return new PredicatedBag<E>(bag, predicate);\n}"
            ],
            [
                "synchronizedSortedBag",
                "org.apache.commons.collections4.bag",
                "SynchronizedSortedBag",
                "/**\n * Factory method to create a synchronized sorted bag.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @return a new synchronized SortedBag\n * @throws NullPointerException if bag is null\n * @since 4.0\n */\npublic static <E> SynchronizedSortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n    return new SynchronizedSortedBag<E>(bag);\n}"
            ],
            [
                "collectionSortedBag",
                "org.apache.commons.collections4.bag",
                "CollectionSortedBag",
                "/**\n * Factory method to create a sorted bag that complies to the Collection contract.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the sorted bag to decorate, must not be null\n * @return a SortedBag that complies to the Collection contract\n * @throws NullPointerException if bag is null\n */\npublic static <E> SortedBag<E> collectionSortedBag(final SortedBag<E> bag) {\n    return new CollectionSortedBag<E>(bag);\n}"
            ],
            [
                "transformingBag",
                "org.apache.commons.collections4.bag",
                "TransformedBag",
                "/**\n * Factory method to create a transforming bag.\n * <p>\n * If there are any elements already in the bag being decorated, they\n * are NOT transformed. Contrast this with {@link #transformedBag(Bag, Transformer)}.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed Bag\n * @throws NullPointerException if bag or transformer is null\n * @since 4.0\n */\npublic static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n    return new TransformedBag<E>(bag, transformer);\n}"
            ],
            [
                "transformedBag",
                "org.apache.commons.collections4.bag",
                "TransformedBag",
                "/**\n * Factory method to create a transforming bag that will transform\n * existing contents of the specified bag.\n * <p>\n * If there are any elements already in the bag being decorated, they\n * will be transformed by this method.\n * Contrast this with {@link #transformingBag(Bag, Transformer)}.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed Bag\n * @throws NullPointerException if bag or transformer is null\n * @since 4.0\n */\npublic static <E> Bag<E> transformedBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n    final TransformedBag<E> decorated = new TransformedBag<E>(bag, transformer);\n    if (bag.size() > 0) {\n        // Bag is of type E\n        @SuppressWarnings(\"unchecked\")\n        final E[] // NOPMD - false positive for generics\n        values = (E[]) bag.toArray();\n        bag.clear();\n        for (final E value : values) {\n            decorated.decorated().add(transformer.transform(value));\n        }\n    }\n    return decorated;\n}"
            ],
            [
                "predicatedMultiSet",
                "org.apache.commons.collections4.multiset",
                "PredicatedMultiSet",
                "/**\n * Factory method to create a predicated (validating) multiset.\n * <p>\n * If there are any elements already in the multiset being decorated, they\n * are validated.\n *\n * @param <E> the type of the elements in the multiset\n * @param multiset  the multiset to decorate, must not be null\n * @param predicate  the predicate to use for validation, must not be null\n * @return a new predicated MultiSet\n * @throws NullPointerException if multiset or predicate is null\n * @throws IllegalArgumentException if the multiset contains invalid elements\n */\npublic static <E> PredicatedMultiSet<E> predicatedMultiSet(final MultiSet<E> multiset, final Predicate<? super E> predicate) {\n    return new PredicatedMultiSet<E>(multiset, predicate);\n}"
            ],
            [
                "unmodifiableMultiSet",
                "org.apache.commons.collections4.multiset",
                "UnmodifiableMultiSet",
                "/**\n * Factory method to create an unmodifiable multiset.\n * <p>\n * If the multiset passed in is already unmodifiable, it is returned.\n *\n * @param <E>  the type of the elements in the multiset\n * @param multiset  the multiset to decorate, may not be null\n * @return an unmodifiable MultiSet\n * @throws NullPointerException if multiset is null\n */\npublic static <E> MultiSet<E> unmodifiableMultiSet(final MultiSet<? extends E> multiset) {\n    if (multiset instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final MultiSet<E> tmpMultiSet = (MultiSet<E>) multiset;\n        return tmpMultiSet;\n    }\n    return new UnmodifiableMultiSet<E>(multiset);\n}"
            ],
            [
                "synchronizedMultiSet",
                "org.apache.commons.collections4.multiset",
                "SynchronizedMultiSet",
                "/**\n * Factory method to create a synchronized multiset.\n *\n * @param <E> the type of the elements in the multiset\n * @param multiset  the multiset to decorate, must not be null\n * @return a new synchronized MultiSet\n * @throws NullPointerException if multiset is null\n */\npublic static <E> SynchronizedMultiSet<E> synchronizedMultiSet(final MultiSet<E> multiset) {\n    return new SynchronizedMultiSet<E>(multiset);\n}"
            ],
            [
                "synchronizedBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns a synchronized (thread-safe) bag backed by the given bag. In\n * order to guarantee serial access, it is critical that all access to the\n * backing bag is accomplished through the returned bag.\n * <p>\n * It is imperative that the user manually synchronize on the returned bag\n * when iterating over it:\n *\n * <pre>\n * Bag bag = BagUtils.synchronizedBag(new HashBag());\n * ...\n * synchronized(bag) {\n *     Iterator i = bag.iterator(); // Must be in synchronized block\n *     while (i.hasNext())\n *         foo(i.next());\n *     }\n * }\n * </pre>\n *\n * Failure to follow this advice may result in non-deterministic behavior.\n *\n * @param <E> the element type\n * @param bag the bag to synchronize, must not be null\n * @return a synchronized bag backed by that bag\n * @throws NullPointerException if the Bag is null\n */\npublic static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n    return SynchronizedBag.synchronizedBag(bag);\n}"
            ],
            [
                "unmodifiableBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * Returns an unmodifiable view of the given bag. Any modification attempts\n * to the returned bag will raise an {@link UnsupportedOperationException}.\n *\n * @param <E> the element type\n * @param bag the bag whose unmodifiable view is to be returned, must not be null\n * @return an unmodifiable view of that bag\n * @throws NullPointerException if the Bag is null\n */\npublic static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n    return UnmodifiableBag.unmodifiableBag(bag);\n}"
            ],
            [
                "predicatedBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * Returns a predicated (validating) bag backed by the given bag.\n * <p>\n * Only objects that pass the test in the given predicate can be added to\n * the bag. Trying to add an invalid object results in an\n * IllegalArgumentException. It is important not to use the original bag\n * after invoking this method, as it is a backdoor for adding invalid\n * objects.\n *\n * @param <E> the element type\n * @param bag the bag to predicate, must not be null\n * @param predicate the predicate for the bag, must not be null\n * @return a predicated bag backed by the given bag\n * @throws NullPointerException if the Bag or Predicate is null\n */\npublic static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n    return PredicatedBag.predicatedBag(bag, predicate);\n}"
            ],
            [
                "transformingBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * Returns a transformed bag backed by the given bag.\n * <p>\n * Each object is passed through the transformer as it is added to the Bag.\n * It is important not to use the original bag after invoking this method,\n * as it is a backdoor for adding untransformed objects.\n * <p>\n * Existing entries in the specified bag will not be transformed.\n * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n *\n * @param <E> the element type\n * @param bag the bag to predicate, must not be null\n * @param transformer the transformer for the bag, must not be null\n * @return a transformed bag backed by the given bag\n * @throws NullPointerException if the Bag or Transformer is null\n */\npublic static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n    return TransformedBag.transformingBag(bag, transformer);\n}"
            ],
            [
                "collectionBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * Returns a bag that complies to the Collection contract, backed by the given bag.\n *\n * @param <E> the element type\n * @param bag the bag to decorate, must not be null\n * @return a Bag that complies to the Collection contract\n * @throws NullPointerException if bag is null\n * @since 4.0\n */\npublic static <E> Bag<E> collectionBag(final Bag<E> bag) {\n    return CollectionBag.collectionBag(bag);\n}"
            ],
            [
                "synchronizedSortedBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns a synchronized (thread-safe) sorted bag backed by the given\n * sorted bag. In order to guarantee serial access, it is critical that all\n * access to the backing bag is accomplished through the returned bag.\n * <p>\n * It is imperative that the user manually synchronize on the returned bag\n * when iterating over it:\n *\n * <pre>\n * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n * ...\n * synchronized(bag) {\n *     Iterator i = bag.iterator(); // Must be in synchronized block\n *     while (i.hasNext())\n *         foo(i.next());\n *     }\n * }\n * </pre>\n *\n * Failure to follow this advice may result in non-deterministic behavior.\n *\n * @param <E> the element type\n * @param bag the bag to synchronize, must not be null\n * @return a synchronized bag backed by that bag\n * @throws NullPointerException if the SortedBag is null\n */\npublic static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n    return SynchronizedSortedBag.synchronizedSortedBag(bag);\n}"
            ],
            [
                "unmodifiableSortedBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * Returns an unmodifiable view of the given sorted bag. Any modification\n * attempts to the returned bag will raise an\n * {@link UnsupportedOperationException}.\n *\n * @param <E> the element type\n * @param bag the bag whose unmodifiable view is to be returned, must not be null\n * @return an unmodifiable view of that bag\n * @throws NullPointerException if the SortedBag is null\n */\npublic static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n    return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n}"
            ],
            [
                "predicatedSortedBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * Returns a predicated (validating) sorted bag backed by the given sorted\n * bag.\n * <p>\n * Only objects that pass the test in the given predicate can be added to\n * the bag. Trying to add an invalid object results in an\n * IllegalArgumentException. It is important not to use the original bag\n * after invoking this method, as it is a backdoor for adding invalid\n * objects.\n *\n * @param <E> the element type\n * @param bag the sorted bag to predicate, must not be null\n * @param predicate the predicate for the bag, must not be null\n * @return a predicated bag backed by the given bag\n * @throws NullPointerException if the SortedBag or Predicate is null\n */\npublic static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag, final Predicate<? super E> predicate) {\n    return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n}"
            ],
            [
                "transformingSortedBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * Returns a transformed sorted bag backed by the given bag.\n * <p>\n * Each object is passed through the transformer as it is added to the Bag.\n * It is important not to use the original bag after invoking this method,\n * as it is a backdoor for adding untransformed objects.\n * <p>\n * Existing entries in the specified bag will not be transformed.\n * If you want that behaviour, see\n * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n *\n * @param <E> the element type\n * @param bag the bag to predicate, must not be null\n * @param transformer the transformer for the bag, must not be null\n * @return a transformed bag backed by the given bag\n * @throws NullPointerException if the Bag or Transformer is null\n */\npublic static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n    return TransformedSortedBag.transformingSortedBag(bag, transformer);\n}"
            ],
            [
                "emptyBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * Get an empty <code>Bag</code>.\n *\n * @param <E> the element type\n * @return an empty Bag\n */\n// OK, empty bag is compatible with any type\n@SuppressWarnings(\"unchecked\")\npublic static <E> Bag<E> emptyBag() {\n    return (Bag<E>) EMPTY_BAG;\n}"
            ],
            [
                "emptySortedBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * Get an empty <code>SortedBag</code>.\n *\n * @param <E> the element type\n * @return an empty sorted Bag\n */\n// OK, empty bag is compatible with any type\n@SuppressWarnings(\"unchecked\")\npublic static <E> SortedBag<E> emptySortedBag() {\n    return (SortedBag<E>) EMPTY_SORTED_BAG;\n}"
            ],
            [
                "resettableEmptyListIterator",
                "org.apache.commons.collections4.iterators",
                "EmptyListIterator",
                "/**\n * Get a typed instance of the iterator.\n * @param <E> the element type\n * @return {@link ResettableListIterator}<E>\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> ResettableListIterator<E> resettableEmptyListIterator() {\n    return (ResettableListIterator<E>) RESETTABLE_INSTANCE;\n}"
            ],
            [
                "emptyListIterator",
                "org.apache.commons.collections4.iterators",
                "EmptyListIterator",
                "/**\n * Get a typed instance of the iterator.\n * @param <E> the element type\n * @return {@link ListIterator}<E>\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> ListIterator<E> emptyListIterator() {\n    return (ListIterator<E>) INSTANCE;\n}"
            ],
            [
                "unmodifiableOrderedMapIterator",
                "org.apache.commons.collections4.iterators",
                "UnmodifiableOrderedMapIterator",
                "//-----------------------------------------------------------------------\n/**\n * Decorates the specified iterator such that it cannot be modified.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param iterator  the iterator to decorate\n * @return a new unmodifiable ordered map iterator\n * @throws NullPointerException if the iterator is null\n */\npublic static <K, V> OrderedMapIterator<K, V> unmodifiableOrderedMapIterator(final OrderedMapIterator<K, ? extends V> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"OrderedMapIterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final OrderedMapIterator<K, V> tmpIterator = (OrderedMapIterator<K, V>) iterator;\n        return tmpIterator;\n    }\n    return new UnmodifiableOrderedMapIterator<K, V>(iterator);\n}"
            ],
            [
                "unmodifiableIterator",
                "org.apache.commons.collections4.iterators",
                "UnmodifiableIterator",
                "//-----------------------------------------------------------------------\n/**\n * Decorates the specified iterator such that it cannot be modified.\n * <p>\n * If the iterator is already unmodifiable it is returned directly.\n *\n * @param <E>  the element type\n * @param iterator  the iterator to decorate\n * @return a new unmodifiable iterator\n * @throws NullPointerException if the iterator is null\n */\npublic static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final Iterator<E> tmpIterator = (Iterator<E>) iterator;\n        return tmpIterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}"
            ],
            [
                "peekingIterator",
                "org.apache.commons.collections4.iterators",
                "PeekingIterator",
                "//-----------------------------------------------------------------------\n/**\n * Decorates the specified iterator to support one-element lookahead.\n * <p>\n * If the iterator is already a {@link PeekingIterator} it is returned directly.\n *\n * @param <E>  the element type\n * @param iterator  the iterator to decorate\n * @return a new peeking iterator\n * @throws NullPointerException if the iterator is null\n */\npublic static <E> PeekingIterator<E> peekingIterator(final Iterator<? extends E> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof PeekingIterator<?>) {\n        // safe cast\n        @SuppressWarnings(\"unchecked\")\n        final PeekingIterator<E> it = (PeekingIterator<E>) iterator;\n        return it;\n    }\n    return new PeekingIterator<E>(iterator);\n}"
            ],
            [
                "emptyMapIterator",
                "org.apache.commons.collections4.iterators",
                "EmptyMapIterator",
                "/**\n * Get a typed instance of the iterator.\n * @param <K> the key type\n * @param <V> the value type\n * @return {@link MapIterator}<K, V>\n */\n@SuppressWarnings(\"unchecked\")\npublic static <K, V> MapIterator<K, V> emptyMapIterator() {\n    return (MapIterator<K, V>) INSTANCE;\n}"
            ],
            [
                "emptyOrderedIterator",
                "org.apache.commons.collections4.iterators",
                "EmptyOrderedIterator",
                "/**\n * Typed instance of the iterator.\n * @param <E> the element type\n * @return OrderedIterator<E>\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> OrderedIterator<E> emptyOrderedIterator() {\n    return (OrderedIterator<E>) INSTANCE;\n}"
            ],
            [
                "umodifiableListIterator",
                "org.apache.commons.collections4.iterators",
                "UnmodifiableListIterator",
                "//-----------------------------------------------------------------------\n/**\n * Decorates the specified iterator such that it cannot be modified.\n *\n * @param <E>  the element type\n * @param iterator  the iterator to decorate\n * @return a new unmodifiable list iterator\n * @throws NullPointerException if the iterator is null\n */\npublic static <E> ListIterator<E> umodifiableListIterator(final ListIterator<? extends E> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"ListIterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final ListIterator<E> tmpIterator = (ListIterator<E>) iterator;\n        return tmpIterator;\n    }\n    return new UnmodifiableListIterator<E>(iterator);\n}"
            ],
            [
                "emptyOrderedMapIterator",
                "org.apache.commons.collections4.iterators",
                "EmptyOrderedMapIterator",
                "/**\n * Get a typed instance of the iterator.\n * @param <K> the key type\n * @param <V> the value type\n * @return {@link OrderedMapIterator}<K, V>\n */\n@SuppressWarnings(\"unchecked\")\npublic static <K, V> OrderedMapIterator<K, V> emptyOrderedMapIterator() {\n    return (OrderedMapIterator<K, V>) INSTANCE;\n}"
            ],
            [
                "unmodifiableMapIterator",
                "org.apache.commons.collections4.iterators",
                "UnmodifiableMapIterator",
                "//-----------------------------------------------------------------------\n/**\n * Decorates the specified iterator such that it cannot be modified.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param iterator  the iterator to decorate\n * @return a new unmodifiable map iterator\n * @throws NullPointerException if the iterator is null\n */\npublic static <K, V> MapIterator<K, V> unmodifiableMapIterator(final MapIterator<? extends K, ? extends V> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"MapIterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final MapIterator<K, V> tmpIterator = (MapIterator<K, V>) iterator;\n        return tmpIterator;\n    }\n    return new UnmodifiableMapIterator<K, V>(iterator);\n}"
            ],
            [
                "resettableEmptyIterator",
                "org.apache.commons.collections4.iterators",
                "EmptyIterator",
                "/**\n * Get a typed resettable empty iterator instance.\n * @param <E> the element type\n * @return ResettableIterator<E>\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> ResettableIterator<E> resettableEmptyIterator() {\n    return (ResettableIterator<E>) RESETTABLE_INSTANCE;\n}"
            ],
            [
                "emptyIterator",
                "org.apache.commons.collections4.iterators",
                "EmptyIterator",
                "/**\n * Get a typed empty iterator instance.\n * @param <E> the element type\n * @return Iterator<E>\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Iterator<E> emptyIterator() {\n    return (Iterator<E>) INSTANCE;\n}"
            ],
            [
                "pushbackIterator",
                "org.apache.commons.collections4.iterators",
                "PushbackIterator",
                "//-----------------------------------------------------------------------\n/**\n * Decorates the specified iterator to support one-element lookahead.\n * <p>\n * If the iterator is already a {@link PushbackIterator} it is returned directly.\n *\n * @param <E>  the element type\n * @param iterator  the iterator to decorate\n * @return a new peeking iterator\n * @throws NullPointerException if the iterator is null\n */\npublic static <E> PushbackIterator<E> pushbackIterator(final Iterator<? extends E> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof PushbackIterator<?>) {\n        // safe cast\n        @SuppressWarnings(\"unchecked\")\n        final PushbackIterator<E> it = (PushbackIterator<E>) iterator;\n        return it;\n    }\n    return new PushbackIterator<E>(iterator);\n}"
            ],
            [
                "readableMap",
                "org.apache.commons.collections4",
                "SplitMapUtils",
                "//-----------------------------------------------------------------------\n/**\n * Get the specified {@link Get} as an instance of {@link IterableMap}.\n * If <code>get</code> implements {@link IterableMap} directly, no conversion will take place.\n * If <code>get</code> implements {@link Map} but not {@link IterableMap} it will be decorated.\n * Otherwise an {@link Unmodifiable} {@link IterableMap} will be returned.\n * @param <K> the key type\n * @param <V> the value type\n * @param get to wrap, must not be null\n * @return {@link IterableMap}\n * @throws NullPointerException if the argument is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <K, V> IterableMap<K, V> readableMap(final Get<K, V> get) {\n    if (get == null) {\n        throw new NullPointerException(\"Get must not be null\");\n    }\n    if (get instanceof Map) {\n        return get instanceof IterableMap ? ((IterableMap<K, V>) get) : MapUtils.iterableMap((Map<K, V>) get);\n    }\n    return new WrappedGet<K, V>(get);\n}"
            ],
            [
                "writableMap",
                "org.apache.commons.collections4",
                "SplitMapUtils",
                "/**\n * Get the specified {@link Put} as an instanceof {@link Map}.\n * If <code>put</code> implements {@link Map} directly, no conversion will take place.\n * Otherwise a <em>write-only</em> {@link Map} will be returned.  On such a {@link Map}\n * it is recommended that the result of #put(K, V) be discarded as it likely will not\n * match <code>V</code> at runtime.\n *\n * @param <K> the key type\n * @param <V> the element type\n * @param put to wrap, must not be null\n * @return {@link Map}\n * @throws NullPointerException if the argument is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <K, V> Map<K, V> writableMap(final Put<K, V> put) {\n    if (put == null) {\n        throw new NullPointerException(\"Put must not be null\");\n    }\n    if (put instanceof Map) {\n        return (Map<K, V>) put;\n    }\n    return new WrappedPut<K, V>(put);\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "EMPTY_ITERATOR",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// validation is done in this class in certain cases because the\n// public classes allow invalid states\n/**\n * An iterator over no elements.\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final ResettableIterator EMPTY_ITERATOR = EmptyIterator.RESETTABLE_INSTANCE;"
            ],
            [
                "EMPTY_LIST_ITERATOR",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * A list iterator over no elements.\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final ResettableListIterator EMPTY_LIST_ITERATOR = EmptyListIterator.RESETTABLE_INSTANCE;"
            ],
            [
                "EMPTY_ORDERED_ITERATOR",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * An ordered iterator over no elements.\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final OrderedIterator EMPTY_ORDERED_ITERATOR = EmptyOrderedIterator.INSTANCE;"
            ],
            [
                "EMPTY_MAP_ITERATOR",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * A map iterator over no elements.\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final MapIterator EMPTY_MAP_ITERATOR = EmptyMapIterator.INSTANCE;"
            ],
            [
                "EMPTY_ORDERED_MAP_ITERATOR",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * An ordered map iterator over no elements.\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final OrderedMapIterator EMPTY_ORDERED_MAP_ITERATOR = EmptyOrderedMapIterator.INSTANCE;"
            ],
            [
                "NATURAL_COMPARATOR",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Comparator for natural sort order.\n *\n * @see ComparableComparator#comparableComparator()\n */\n// explicit type needed for Java 1.5 compilation\n@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\npublic static final Comparator NATURAL_COMPARATOR = ComparableComparator.<Comparable>comparableComparator();"
            ],
            [
                "EMPTY_MULTI_VALUED_MAP",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "/**\n * An empty {@link UnmodifiableMultiValuedMap}.\n */\n@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\npublic static final MultiValuedMap EMPTY_MULTI_VALUED_MAP = UnmodifiableMultiValuedMap.unmodifiableMultiValuedMap(new ArrayListValuedHashMap(0, 0));"
            ],
            [
                "EMPTY_SORTED_MAP",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * An empty unmodifiable sorted map.\n * This is not provided in the JDK.\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final SortedMap EMPTY_SORTED_MAP = UnmodifiableSortedMap.unmodifiableSortedMap(new TreeMap<Object, Object>());"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "DefaultEquator",
                "/**\n * Static instance\n */\n// the static instance works for all types\n@SuppressWarnings(\"rawtypes\")\npublic static final DefaultEquator INSTANCE = new DefaultEquator<Object>();"
            ],
            [
                "HASHCODE_NULL",
                "org.apache.commons.collections4.functors",
                "DefaultEquator",
                "/**\n * Hashcode used for <code>null</code> objects.\n */\npublic static final int HASHCODE_NULL = -1;"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "ExceptionClosure",
                "/**\n * Singleton predicate instance\n */\n// the static instance works for all types\n@SuppressWarnings(\"rawtypes\")\npublic static final Closure INSTANCE = new ExceptionClosure<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "NOPClosure",
                "/**\n * Singleton predicate instance\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final Closure INSTANCE = new NOPClosure<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "NullPredicate",
                "/**\n * Singleton predicate instance\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final Predicate INSTANCE = new NullPredicate<Object>();"
            ],
            [
                "NULL_INSTANCE",
                "org.apache.commons.collections4.functors",
                "ConstantTransformer",
                "/**\n * Returns null each time\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final Transformer NULL_INSTANCE = new ConstantTransformer<Object, Object>(null);"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "ExceptionTransformer",
                "/**\n * Singleton predicate instance\n */\n// the static instance works for all types\n@SuppressWarnings(\"rawtypes\")\npublic static final Transformer INSTANCE = new ExceptionTransformer<Object, Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "NOPTransformer",
                "/**\n * Singleton predicate instance\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final Transformer INSTANCE = new NOPTransformer<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "ExceptionFactory",
                "/**\n * Singleton predicate instance\n */\n// the static instance works for all types\n@SuppressWarnings(\"rawtypes\")\npublic static final Factory INSTANCE = new ExceptionFactory<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "ExceptionPredicate",
                "/**\n * Singleton predicate instance\n */\n// the static instance works for all types\n@SuppressWarnings(\"rawtypes\")\npublic static final Predicate INSTANCE = new ExceptionPredicate<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "FalsePredicate",
                "/**\n * Singleton predicate instance\n */\n// the static instance works for all types\n@SuppressWarnings(\"rawtypes\")\npublic static final Predicate INSTANCE = new FalsePredicate<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "CloneTransformer",
                "/**\n * Singleton predicate instance\n */\n// the singleton instance works for all types\n@SuppressWarnings(\"rawtypes\")\npublic static final Transformer INSTANCE = new CloneTransformer<Object>();"
            ],
            [
                "NULL_INSTANCE",
                "org.apache.commons.collections4.functors",
                "ConstantFactory",
                "/**\n * Returns null each time\n */\n// The null factory works for all object types\n@SuppressWarnings(\"rawtypes\")\npublic static final Factory NULL_INSTANCE = new ConstantFactory<Object>(null);"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "TruePredicate",
                "/**\n * Singleton predicate instance\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final Predicate INSTANCE = new TruePredicate<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "NotNullPredicate",
                "/**\n * Singleton predicate instance\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final Predicate INSTANCE = new NotNullPredicate<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.comparators",
                "ComparableComparator",
                "/**\n * The singleton instance.\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final ComparableComparator INSTANCE = new ComparableComparator();"
            ],
            [
                "EMPTY_COLLECTION",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * An empty unmodifiable collection.\n * The JDK provides empty Set and List implementations which could be used for\n * this purpose. However they could be cast to Set or List which might be\n * undesirable. This implementation only implements Collection.\n */\n// we deliberately use the raw type here\n@SuppressWarnings(\"rawtypes\")\npublic static final Collection EMPTY_COLLECTION = UnmodifiableCollection.unmodifiableCollection(new ArrayList<Object>());"
            ],
            [
                "EMPTY_ITERABLE",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * An empty iterable.\n */\n@SuppressWarnings(\"rawtypes\")\nstatic final FluentIterable EMPTY_ITERABLE = new FluentIterable<Object>() {\n\n    @Override\n    public Iterator<Object> iterator() {\n        return IteratorUtils.emptyIterator();\n    }\n};"
            ],
            [
                "NULL_BIT_KEY",
                "org.apache.commons.collections4.trie",
                "KeyAnalyzer",
                "/**\n * Returned by {@link #bitIndex(Object, int, int, Object, int, int)}\n * if key's bits are all 0.\n */\npublic static final int NULL_BIT_KEY = -1;"
            ],
            [
                "EQUAL_BIT_KEY",
                "org.apache.commons.collections4.trie",
                "KeyAnalyzer",
                "/**\n * Returned by {@link #bitIndex(Object, int, int, Object, int, int)} if key and found key are equal.\n * This is a very very specific case and shouldn't happen on a regular basis.\n */\npublic static final int EQUAL_BIT_KEY = -2;"
            ],
            [
                "OUT_OF_BOUNDS_BIT_KEY",
                "org.apache.commons.collections4.trie",
                "KeyAnalyzer",
                "public static final int OUT_OF_BOUNDS_BIT_KEY = -3;"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.trie.analyzer",
                "StringKeyAnalyzer",
                "/**\n * A singleton instance of {@link StringKeyAnalyzer}.\n */\npublic static final StringKeyAnalyzer INSTANCE = new StringKeyAnalyzer();"
            ],
            [
                "LENGTH",
                "org.apache.commons.collections4.trie.analyzer",
                "StringKeyAnalyzer",
                "/**\n * The number of bits per {@link Character}.\n */\npublic static final int LENGTH = Character.SIZE;"
            ],
            [
                "NO_NEXT_ENTRY",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "protected static final String NO_NEXT_ENTRY = \"No next() entry in the iteration\";"
            ],
            [
                "NO_PREVIOUS_ENTRY",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "protected static final String NO_PREVIOUS_ENTRY = \"No previous() entry in the iteration\";"
            ],
            [
                "REMOVE_INVALID",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "protected static final String REMOVE_INVALID = \"remove() can only be called once after next()\";"
            ],
            [
                "GETKEY_INVALID",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "protected static final String GETKEY_INVALID = \"getKey() can only be called after next() and before remove()\";"
            ],
            [
                "GETVALUE_INVALID",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "protected static final String GETVALUE_INVALID = \"getValue() can only be called after next() and before remove()\";"
            ],
            [
                "SETVALUE_INVALID",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "protected static final String SETVALUE_INVALID = \"setValue() can only be called after next() and before remove()\";"
            ],
            [
                "DEFAULT_CAPACITY",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "/**\n * The default capacity to use\n */\nprotected static final int DEFAULT_CAPACITY = 16;"
            ],
            [
                "DEFAULT_THRESHOLD",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "/**\n * The default threshold to use\n */\nprotected static final int DEFAULT_THRESHOLD = 12;"
            ],
            [
                "DEFAULT_LOAD_FACTOR",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "/**\n * The default load factor to use\n */\nprotected static final float DEFAULT_LOAD_FACTOR = 0.75f;"
            ],
            [
                "MAXIMUM_CAPACITY",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "/**\n * The maximum capacity allowed\n */\nprotected static final int MAXIMUM_CAPACITY = 1 << 30;"
            ],
            [
                "NULL",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "/**\n * An object for masking null\n */\nprotected static final Object NULL = new Object();"
            ],
            [
                "DEFAULT_MAX_SIZE",
                "org.apache.commons.collections4.map",
                "LRUMap",
                "/**\n * Default maximum size\n */\nprotected static final int DEFAULT_MAX_SIZE = 100;"
            ],
            [
                "EMPTY_MULTISET",
                "org.apache.commons.collections4",
                "MultiSetUtils",
                "/**\n * An empty unmodifiable multiset.\n */\n// OK, empty multiset is compatible with any type\n@SuppressWarnings(\"rawtypes\")\npublic static final MultiSet EMPTY_MULTISET = UnmodifiableMultiSet.unmodifiableMultiSet(new HashMultiSet<Object>());"
            ],
            [
                "EMPTY_SORTED_SET",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * An empty unmodifiable sorted set.\n * This is not provided in the JDK.\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final SortedSet EMPTY_SORTED_SET = UnmodifiableSortedSet.unmodifiableSortedSet(new TreeSet<Object>());"
            ],
            [
                "EMPTY_QUEUE",
                "org.apache.commons.collections4",
                "QueueUtils",
                "/**\n * An empty unmodifiable queue.\n */\n// OK, empty queue is compatible with any type\n@SuppressWarnings(\"rawtypes\")\npublic static final Queue EMPTY_QUEUE = UnmodifiableQueue.unmodifiableQueue(new LinkedList<Object>());"
            ],
            [
                "EMPTY_BAG",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * An empty unmodifiable bag.\n */\n// OK, empty bag is compatible with any type\n@SuppressWarnings(\"rawtypes\")\npublic static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());"
            ],
            [
                "EMPTY_SORTED_BAG",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * An empty unmodifiable sorted bag.\n */\n// OK, empty bag is compatible with any type\n@SuppressWarnings(\"rawtypes\")\npublic static final Bag EMPTY_SORTED_BAG = UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());"
            ],
            [
                "RESETTABLE_INSTANCE",
                "org.apache.commons.collections4.iterators",
                "EmptyListIterator",
                "/**\n * Singleton instance of the iterator.\n * @since 3.1\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final ResettableListIterator RESETTABLE_INSTANCE = new EmptyListIterator<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.iterators",
                "EmptyListIterator",
                "/**\n * Singleton instance of the iterator.\n * @since 2.1.1 and 3.1\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final ListIterator INSTANCE = RESETTABLE_INSTANCE;"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.iterators",
                "EmptyMapIterator",
                "/**\n * Singleton instance of the iterator.\n * @since 3.1\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final MapIterator INSTANCE = new EmptyMapIterator<Object, Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.iterators",
                "EmptyOrderedIterator",
                "/**\n * Singleton instance of the iterator.\n * @since 3.1\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final OrderedIterator INSTANCE = new EmptyOrderedIterator<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.iterators",
                "EmptyOrderedMapIterator",
                "/**\n * Singleton instance of the iterator.\n * @since 3.1\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final OrderedMapIterator INSTANCE = new EmptyOrderedMapIterator<Object, Object>();"
            ],
            [
                "RESETTABLE_INSTANCE",
                "org.apache.commons.collections4.iterators",
                "EmptyIterator",
                "/**\n * Singleton instance of the iterator.\n * @since 3.1\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final ResettableIterator RESETTABLE_INSTANCE = new EmptyIterator<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.iterators",
                "EmptyIterator",
                "/**\n * Singleton instance of the iterator.\n * @since 2.1.1 and 3.1\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final Iterator INSTANCE = RESETTABLE_INSTANCE;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [
            [
                "coll",
                "java.util.Collection",
                "Collection<C>"
            ],
            [
                "keyTransformer",
                "org.apache.commons.collections4.Transformer",
                "Transformer<C, K>"
            ],
            [
                "map",
                "org.apache.commons.collections4.MultiMap",
                "MultiMap<K, C>"
            ],
            [
                "uniqueIndex",
                "",
                "boolean"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "values",
                "org.apache.commons.collections4.collection",
                "IndexedCollection",
                "/**\n * Get all elements associated with the given key.\n *\n * @param key  key to look up\n * @return a collection of elements found, or null if {@code contains(key) == false}\n */\n// index is a MultiMap which returns a Collection\n@SuppressWarnings(\"unchecked\")\npublic Collection<C> values(final K key) {\n    return (Collection<C>) index.get(key);\n}"
            ],
            [
                "toArray",
                "org.apache.commons.collections4.collection",
                "AbstractCollectionDecorator",
                "public <T> T[] toArray(T[] arg0)"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "retainAll",
                "java.util",
                "Collection",
                "public abstract boolean retainAll(Collection<? extends Object> arg0)"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "decorated",
                "org.apache.commons.collections4.collection",
                "AbstractCollectionDecorator",
                "protected Collection<E> decorated()"
            ],
            [
                "parallelStream",
                "java.util",
                "Collection",
                "public default Stream<E> parallelStream()"
            ],
            [
                "removeAll",
                "java.util",
                "Collection",
                "public abstract boolean removeAll(Collection<? extends Object> arg0)"
            ],
            [
                "retainAll",
                "org.apache.commons.collections4.collection",
                "IndexedCollection",
                "@Override\npublic boolean retainAll(final Collection<?> coll) {\n    final boolean changed = super.retainAll(coll);\n    if (changed) {\n        reindex();\n    }\n    return changed;\n}"
            ],
            [
                "stream",
                "java.util",
                "Collection",
                "public default Stream<E> stream()"
            ],
            [
                "containsAll",
                "org.apache.commons.collections4.collection",
                "IndexedCollection",
                "/**\n * {@inheritDoc}\n * <p>\n * Note: uses the index for fast lookup\n */\n@Override\npublic boolean containsAll(final Collection<?> coll) {\n    for (final Object o : coll) {\n        if (!contains(o)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "toArray",
                "org.apache.commons.collections4.collection",
                "AbstractCollectionDecorator",
                "public Object[] toArray()"
            ],
            [
                "toString",
                "org.apache.commons.collections4.collection",
                "AbstractCollectionDecorator",
                "public String toString()"
            ],
            [
                "iterator",
                "org.apache.commons.collections4.collection",
                "AbstractCollectionDecorator",
                "public Iterator<E> iterator()"
            ],
            [
                "removeAll",
                "org.apache.commons.collections4.collection",
                "IndexedCollection",
                "@Override\npublic boolean removeAll(final Collection<?> coll) {\n    boolean changed = false;\n    for (final Object o : coll) {\n        changed |= remove(o);\n    }\n    return changed;\n}"
            ],
            [
                "toArray",
                "java.util",
                "Collection",
                "public default <T> T[] toArray(IntFunction<T[]> arg0)"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "addAll",
                "org.apache.commons.collections4.collection",
                "IndexedCollection",
                "@Override\npublic boolean addAll(final Collection<? extends C> coll) {\n    boolean changed = false;\n    for (final C c : coll) {\n        changed |= add(c);\n    }\n    return changed;\n}"
            ],
            [
                "size",
                "org.apache.commons.collections4.collection",
                "AbstractCollectionDecorator",
                "public int size()"
            ],
            [
                "spliterator",
                "java.lang",
                "Iterable",
                "public default Spliterator<T> spliterator()"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "containsAll",
                "java.util",
                "Collection",
                "public abstract boolean containsAll(Collection<? extends Object> arg0)"
            ],
            [
                "remove",
                "org.apache.commons.collections4.collection",
                "IndexedCollection",
                "@SuppressWarnings(\"unchecked\")\n@Override\npublic boolean remove(final Object object) {\n    final boolean removed = super.remove(object);\n    if (removed) {\n        removeFromIndex((C) object);\n    }\n    return removed;\n}"
            ],
            [
                "iterator",
                "java.lang",
                "Iterable",
                "public abstract Iterator<T> iterator()"
            ],
            [
                "get",
                "org.apache.commons.collections4.collection",
                "IndexedCollection",
                "/**\n * Get the element associated with the given key.\n * <p>\n * In case of a non-unique index, this method will return the first\n * value associated with the given key. To retrieve all elements associated\n * with a key, use {@link #values(Object)}.\n *\n * @param key  key to look up\n * @return element found\n * @see #values(Object)\n */\npublic C get(final K key) {\n    // index is a MultiMap which returns a Collection\n    @SuppressWarnings(\"unchecked\")\n    final Collection<C> coll = (Collection<C>) index.get(key);\n    return coll == null ? null : coll.iterator().next();\n}"
            ],
            [
                "add",
                "org.apache.commons.collections4.collection",
                "IndexedCollection",
                "/**\n * {@inheritDoc}\n *\n * @throws IllegalArgumentException if the object maps to an existing key and the index\n *   enforces a uniqueness constraint\n */\n@Override\npublic boolean add(final C object) {\n    final boolean added = super.add(object);\n    if (added) {\n        addToIndex(object);\n    }\n    return added;\n}"
            ],
            [
                "contains",
                "org.apache.commons.collections4.collection",
                "IndexedCollection",
                "/**\n * {@inheritDoc}\n * <p>\n * Note: uses the index for fast lookup\n */\n@SuppressWarnings(\"unchecked\")\n@Override\npublic boolean contains(final Object object) {\n    return index.containsKey(keyTransformer.transform((C) object));\n}"
            ],
            [
                "isEmpty",
                "org.apache.commons.collections4.collection",
                "AbstractCollectionDecorator",
                "public boolean isEmpty()"
            ],
            [
                "spliterator",
                "java.util",
                "Collection",
                "public default Spliterator<E> spliterator()"
            ],
            [
                "removeIf",
                "org.apache.commons.collections4.collection",
                "AbstractCollectionDecorator",
                "public boolean removeIf(Predicate<? super E> arg0)"
            ],
            [
                "add",
                "java.util",
                "Collection",
                "public abstract boolean add(E arg0)"
            ],
            [
                "removeIf",
                "java.util",
                "Collection",
                "public default boolean removeIf(Predicate<? super E> arg0)"
            ],
            [
                "contains",
                "java.util",
                "Collection",
                "public abstract boolean contains(Object arg0)"
            ],
            [
                "isEmpty",
                "java.util",
                "Collection",
                "public abstract boolean isEmpty()"
            ],
            [
                "toArray",
                "java.util",
                "Collection",
                "public abstract Object[] toArray()"
            ],
            [
                "addAll",
                "java.util",
                "Collection",
                "public abstract boolean addAll(Collection<? extends E> arg0)"
            ],
            [
                "remove",
                "java.util",
                "Collection",
                "public abstract boolean remove(Object arg0)"
            ],
            [
                "equals",
                "java.util",
                "Collection",
                "public abstract boolean equals(Object arg0)"
            ],
            [
                "size",
                "java.util",
                "Collection",
                "public abstract int size()"
            ],
            [
                "hashCode",
                "java.util",
                "Collection",
                "public abstract int hashCode()"
            ],
            [
                "toArray",
                "java.util",
                "Collection",
                "public abstract <T> T[] toArray(T[] arg0)"
            ],
            [
                "iterator",
                "java.util",
                "Collection",
                "public abstract Iterator<E> iterator()"
            ],
            [
                "transform",
                "org.apache.commons.collections4",
                "Transformer",
                "public abstract O transform(I arg0)"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "get",
                "org.apache.commons.collections4",
                "MultiMap",
                "public abstract Object get(Object arg0)"
            ],
            [
                "removeMapping",
                "org.apache.commons.collections4",
                "MultiMap",
                "public abstract boolean removeMapping(K arg0, V arg1)"
            ],
            [
                "size",
                "org.apache.commons.collections4",
                "MultiMap",
                "public abstract int size()"
            ],
            [
                "remove",
                "org.apache.commons.collections4",
                "MultiMap",
                "public abstract Object remove(Object arg0)"
            ],
            [
                "put",
                "org.apache.commons.collections4",
                "MultiMap",
                "public abstract Object put(K arg0, Object arg1)"
            ],
            [
                "containsValue",
                "org.apache.commons.collections4",
                "MultiMap",
                "public abstract boolean containsValue(Object arg0)"
            ],
            [
                "values",
                "org.apache.commons.collections4",
                "MultiMap",
                "public abstract Collection<Object> values()"
            ],
            [
                "replace",
                "java.util",
                "Map",
                "public default boolean replace(K arg0, V arg1, V arg2)"
            ],
            [
                "replace",
                "java.util",
                "Map",
                "public default V replace(K arg0, V arg1)"
            ],
            [
                "getOrDefault",
                "java.util",
                "Map",
                "public default V getOrDefault(Object arg0, V arg1)"
            ],
            [
                "equals",
                "java.util",
                "Map",
                "public abstract boolean equals(Object arg0)"
            ],
            [
                "remove",
                "java.util",
                "Map",
                "public default boolean remove(Object arg0, Object arg1)"
            ],
            [
                "size",
                "java.util",
                "Map",
                "public abstract int size()"
            ],
            [
                "values",
                "java.util",
                "Map",
                "public abstract Collection<V> values()"
            ],
            [
                "entrySet",
                "java.util",
                "Map",
                "public abstract Set<Map.Entry<K, V>> entrySet()"
            ],
            [
                "putIfAbsent",
                "java.util",
                "Map",
                "public default V putIfAbsent(K arg0, V arg1)"
            ],
            [
                "computeIfPresent",
                "java.util",
                "Map",
                "public default V computeIfPresent(K arg0, BiFunction<? super K, ? super V, ? extends V> arg1)"
            ],
            [
                "isEmpty",
                "java.util",
                "Map",
                "public abstract boolean isEmpty()"
            ],
            [
                "computeIfAbsent",
                "java.util",
                "Map",
                "public default V computeIfAbsent(K arg0, Function<? super K, ? extends V> arg1)"
            ],
            [
                "merge",
                "java.util",
                "Map",
                "public default V merge(K arg0, V arg1, BiFunction<? super V, ? super V, ? extends V> arg2)"
            ],
            [
                "get",
                "java.util",
                "Map",
                "public abstract V get(Object arg0)"
            ],
            [
                "containsKey",
                "java.util",
                "Map",
                "public abstract boolean containsKey(Object arg0)"
            ],
            [
                "keySet",
                "java.util",
                "Map",
                "public abstract Set<K> keySet()"
            ],
            [
                "containsValue",
                "java.util",
                "Map",
                "public abstract boolean containsValue(Object arg0)"
            ],
            [
                "remove",
                "java.util",
                "Map",
                "public abstract V remove(Object arg0)"
            ],
            [
                "hashCode",
                "java.util",
                "Map",
                "public abstract int hashCode()"
            ],
            [
                "compute",
                "java.util",
                "Map",
                "public default V compute(K arg0, BiFunction<? super K, ? super V, ? extends V> arg1)"
            ],
            [
                "put",
                "java.util",
                "Map",
                "public abstract V put(K arg0, V arg1)"
            ],
            [
                "put",
                "org.apache.commons.collections4",
                "Put",
                "public abstract Object put(K arg0, V arg1)"
            ],
            [
                "mapIterator",
                "org.apache.commons.collections4",
                "IterableGet",
                "public abstract MapIterator<K, V> mapIterator()"
            ],
            [
                "entrySet",
                "org.apache.commons.collections4",
                "Get",
                "public abstract Set<Map.Entry<K, V>> entrySet()"
            ],
            [
                "size",
                "org.apache.commons.collections4",
                "Get",
                "public abstract int size()"
            ],
            [
                "get",
                "org.apache.commons.collections4",
                "Get",
                "public abstract V get(Object arg0)"
            ],
            [
                "remove",
                "org.apache.commons.collections4",
                "Get",
                "public abstract V remove(Object arg0)"
            ],
            [
                "keySet",
                "org.apache.commons.collections4",
                "Get",
                "public abstract Set<K> keySet()"
            ],
            [
                "isEmpty",
                "org.apache.commons.collections4",
                "Get",
                "public abstract boolean isEmpty()"
            ],
            [
                "values",
                "org.apache.commons.collections4",
                "Get",
                "public abstract Collection<V> values()"
            ],
            [
                "containsKey",
                "org.apache.commons.collections4",
                "Get",
                "public abstract boolean containsKey(Object arg0)"
            ],
            [
                "containsValue",
                "org.apache.commons.collections4",
                "Get",
                "public abstract boolean containsValue(Object arg0)"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 6369,
        "oracle": "coll == null;",
        "oracleType": "EXCEPT_POST",
        "projectName": "commons-collections4-4.1",
        "packageName": "org.apache.commons.collections4.collection",
        "className": "UnmodifiableCollection",
        "javadocTag": "@throws NullPointerException if collection is null",
        "methodJavadoc": "    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param coll  the collection to decorate, must not be null\n     * @throws NullPointerException if collection is null\n     */",
        "methodSourceCode": "private UnmodifiableCollection(final Collection<? extends E> coll){\n    super((Collection<E>) coll);\n}",
        "classJavadoc": "/**\n * Decorates another {@link Collection} to ensure it can't be altered.\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n * <p>\n * Attempts to modify it will result in an UnsupportedOperationException.\n *\n * @param <E> the type of the elements in the collection\n * @since 3.0\n * @version $Id: UnmodifiableCollection.java 1686855 2015-06-22 13:00:27Z tn $\n */",
        "classSourceCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4.collection;\n\nimport java.util.Collection;\nimport java.util.Iterator;\n\nimport org.apache.commons.collections4.Unmodifiable;\nimport org.apache.commons.collections4.iterators.UnmodifiableIterator;\n\n/**\n * Decorates another {@link Collection} to ensure it can't be altered.\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n * <p>\n * Attempts to modify it will result in an UnsupportedOperationException.\n *\n * @param <E> the type of the elements in the collection\n * @since 3.0\n * @version $Id: UnmodifiableCollection.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic final class UnmodifiableCollection<E>\n        extends AbstractCollectionDecorator<E>\n        implements Unmodifiable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = -239892006883819945L;\n\n    /**\n     * Factory method to create an unmodifiable collection.\n     * <p>\n     * If the collection passed in is already unmodifiable, it is returned.\n     *\n     * @param <T> the type of the elements in the collection\n     * @param coll  the collection to decorate, must not be null\n     * @return an unmodifiable collection\n     * @throws NullPointerException if collection is null\n     * @since 4.0\n     */\n    public static <T> Collection<T> unmodifiableCollection(final Collection<? extends T> coll) {\n        if (coll instanceof Unmodifiable) {\n            @SuppressWarnings(\"unchecked\") // safe to upcast\n            final Collection<T> tmpColl = (Collection<T>) coll;\n            return tmpColl;\n        }\n        return new UnmodifiableCollection<T>(coll);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param coll  the collection to decorate, must not be null\n     * @throws NullPointerException if collection is null\n     */\n    @SuppressWarnings(\"unchecked\") // safe to upcast\n    private UnmodifiableCollection(final Collection<? extends E> coll) {\n        super((Collection<E>) coll);\n    }\n\n    //-----------------------------------------------------------------------\n    @Override\n    public Iterator<E> iterator() {\n        return UnmodifiableIterator.unmodifiableIterator(decorated().iterator());\n    }\n\n    @Override\n    public boolean add(final E object) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean addAll(final Collection<? extends E> coll) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public void clear() {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean remove(final Object object) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean removeAll(final Collection<?> coll) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean retainAll(final Collection<?> coll) {\n        throw new UnsupportedOperationException();\n    }\n\n}\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "BidiMap",
                "org.apache.commons.collections4"
            ],
            [
                "Equator",
                "org.apache.commons.collections4"
            ],
            [
                "MultiSet",
                "org.apache.commons.collections4"
            ],
            [
                "IteratorUtils",
                "org.apache.commons.collections4"
            ],
            [
                "ComparatorUtils",
                "org.apache.commons.collections4"
            ],
            [
                "FunctorException",
                "org.apache.commons.collections4"
            ],
            [
                "AbstractDualBidiMap",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "UnmodifiableBidiMap",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "AbstractOrderedBidiMapDecorator",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "UnmodifiableOrderedBidiMap",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "AbstractBidiMapDecorator",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "DualLinkedHashBidiMap",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "UnmodifiableSortedBidiMap",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "AbstractSortedBidiMapDecorator",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "DualHashBidiMap",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "DualTreeBidiMap",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "TreeBidiMap",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "MultiMapUtils",
                "org.apache.commons.collections4"
            ],
            [
                "BoundedCollection",
                "org.apache.commons.collections4"
            ],
            [
                "UnmodifiableBoundedCollection",
                "org.apache.commons.collections4.collection"
            ],
            [
                "CompositeCollection",
                "org.apache.commons.collections4.collection"
            ],
            [
                "TransformedCollection",
                "org.apache.commons.collections4.collection"
            ],
            [
                "PredicatedCollection",
                "org.apache.commons.collections4.collection"
            ],
            [
                "IndexedCollection",
                "org.apache.commons.collections4.collection"
            ],
            [
                "SynchronizedCollection",
                "org.apache.commons.collections4.collection"
            ],
            [
                "UnmodifiableCollection",
                "org.apache.commons.collections4.collection"
            ],
            [
                "AbstractCollectionDecorator",
                "org.apache.commons.collections4.collection"
            ],
            [
                "OrderedBidiMap",
                "org.apache.commons.collections4"
            ],
            [
                "FactoryUtils",
                "org.apache.commons.collections4"
            ],
            [
                "IterableGet",
                "org.apache.commons.collections4"
            ],
            [
                "ListUtils",
                "org.apache.commons.collections4"
            ],
            [
                "Closure",
                "org.apache.commons.collections4"
            ],
            [
                "IterableSortedMap",
                "org.apache.commons.collections4"
            ],
            [
                "MapUtils",
                "org.apache.commons.collections4"
            ],
            [
                "Transformer",
                "org.apache.commons.collections4"
            ],
            [
                "DefaultEquator",
                "org.apache.commons.collections4.functors"
            ],
            [
                "StringValueTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "PredicateDecorator",
                "org.apache.commons.collections4.functors"
            ],
            [
                "IfTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "IdentityPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ExceptionClosure",
                "org.apache.commons.collections4.functors"
            ],
            [
                "NOPClosure",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ClosureTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "FunctorUtils",
                "org.apache.commons.collections4.functors"
            ],
            [
                "TransformerPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "NullPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ConstantTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "PredicateTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "WhileClosure",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ForClosure",
                "org.apache.commons.collections4.functors"
            ],
            [
                "NullIsTruePredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "TransformedPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "NonePredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ExceptionTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "SwitchTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "TransformerClosure",
                "org.apache.commons.collections4.functors"
            ],
            [
                "OrPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "NOPTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "MapTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ExceptionFactory",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ChainedClosure",
                "org.apache.commons.collections4.functors"
            ],
            [
                "AndPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "PrototypeFactory",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ExceptionPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "AbstractQuantifierPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "InstanceofPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "InvokerTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "FalsePredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "CloneTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "NotPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ConstantFactory",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ChainedTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ComparatorPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "CatchAndRethrowClosure",
                "org.apache.commons.collections4.functors"
            ],
            [
                "AllPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "NullIsFalsePredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "NullIsExceptionPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "AnyPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "TruePredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "FactoryTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "NotNullPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "SwitchClosure",
                "org.apache.commons.collections4.functors"
            ],
            [
                "UniquePredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "InstantiateTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "OnePredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "EqualPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "InstantiateFactory",
                "org.apache.commons.collections4.functors"
            ],
            [
                "IfClosure",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ResettableListIterator",
                "org.apache.commons.collections4"
            ],
            [
                "OrderedIterator",
                "org.apache.commons.collections4"
            ],
            [
                "ComparatorChain",
                "org.apache.commons.collections4.comparators"
            ],
            [
                "BooleanComparator",
                "org.apache.commons.collections4.comparators"
            ],
            [
                "ReverseComparator",
                "org.apache.commons.collections4.comparators"
            ],
            [
                "ComparableComparator",
                "org.apache.commons.collections4.comparators"
            ],
            [
                "TransformingComparator",
                "org.apache.commons.collections4.comparators"
            ],
            [
                "FixedOrderComparator",
                "org.apache.commons.collections4.comparators"
            ],
            [
                "NullComparator",
                "org.apache.commons.collections4.comparators"
            ],
            [
                "CollectionUtils",
                "org.apache.commons.collections4"
            ],
            [
                "ListValuedMap",
                "org.apache.commons.collections4"
            ],
            [
                "AbstractIterableGetMapDecorator",
                "org.apache.commons.collections4.splitmap"
            ],
            [
                "TransformedSplitMap",
                "org.apache.commons.collections4.splitmap"
            ],
            [
                "Factory",
                "org.apache.commons.collections4"
            ],
            [
                "IterableUtils",
                "org.apache.commons.collections4"
            ],
            [
                "Bag",
                "org.apache.commons.collections4"
            ],
            [
                "Predicate",
                "org.apache.commons.collections4"
            ],
            [
                "SortedBag",
                "org.apache.commons.collections4"
            ],
            [
                "TrieUtils",
                "org.apache.commons.collections4"
            ],
            [
                "ClosureUtils",
                "org.apache.commons.collections4"
            ],
            [
                "PatriciaTrie",
                "org.apache.commons.collections4.trie"
            ],
            [
                "UnmodifiableTrie",
                "org.apache.commons.collections4.trie"
            ],
            [
                "KeyAnalyzer",
                "org.apache.commons.collections4.trie"
            ],
            [
                "AbstractPatriciaTrie",
                "org.apache.commons.collections4.trie"
            ],
            [
                "AbstractBitwiseTrie",
                "org.apache.commons.collections4.trie"
            ],
            [
                "StringKeyAnalyzer",
                "org.apache.commons.collections4.trie.analyzer"
            ],
            [
                "TransformedSortedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "AbstractLinkedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "Flat3Map",
                "org.apache.commons.collections4.map"
            ],
            [
                "PredicatedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "FixedSizeSortedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "UnmodifiableSortedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "PredicatedSortedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "DefaultedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "ReferenceIdentityMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "AbstractSortedMapDecorator",
                "org.apache.commons.collections4.map"
            ],
            [
                "AbstractInputCheckedMapDecorator",
                "org.apache.commons.collections4.map"
            ],
            [
                "FixedSizeMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "LazySortedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "UnmodifiableOrderedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "CaseInsensitiveMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "AbstractHashedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "AbstractOrderedMapDecorator",
                "org.apache.commons.collections4.map"
            ],
            [
                "UnmodifiableMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "EntrySetToMapIteratorAdapter",
                "org.apache.commons.collections4.map"
            ],
            [
                "AbstractIterableMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "ListOrderedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "LinkedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "SingletonMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "UnmodifiableEntrySet",
                "org.apache.commons.collections4.map"
            ],
            [
                "StaticBucketMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "AbstractMapDecorator",
                "org.apache.commons.collections4.map"
            ],
            [
                "AbstractReferenceMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "MultiKeyMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "HashedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "LazyMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "PassiveExpiringMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "MultiValueMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "LRUMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "ReferenceMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "TransformedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "CompositeMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "UnmodifiableMapEntry",
                "org.apache.commons.collections4.keyvalue"
            ],
            [
                "MultiKey",
                "org.apache.commons.collections4.keyvalue"
            ],
            [
                "DefaultMapEntry",
                "org.apache.commons.collections4.keyvalue"
            ],
            [
                "DefaultKeyValue",
                "org.apache.commons.collections4.keyvalue"
            ],
            [
                "AbstractMapEntryDecorator",
                "org.apache.commons.collections4.keyvalue"
            ],
            [
                "AbstractKeyValue",
                "org.apache.commons.collections4.keyvalue"
            ],
            [
                "TiedMapEntry",
                "org.apache.commons.collections4.keyvalue"
            ],
            [
                "AbstractMapEntry",
                "org.apache.commons.collections4.keyvalue"
            ],
            [
                "MultiSetUtils",
                "org.apache.commons.collections4"
            ],
            [
                "MapIterator",
                "org.apache.commons.collections4"
            ],
            [
                "AbstractMultiValuedMap",
                "org.apache.commons.collections4.multimap"
            ],
            [
                "UnmodifiableMultiValuedMap",
                "org.apache.commons.collections4.multimap"
            ],
            [
                "HashSetValuedHashMap",
                "org.apache.commons.collections4.multimap"
            ],
            [
                "TransformedMultiValuedMap",
                "org.apache.commons.collections4.multimap"
            ],
            [
                "AbstractSetValuedMap",
                "org.apache.commons.collections4.multimap"
            ],
            [
                "AbstractListValuedMap",
                "org.apache.commons.collections4.multimap"
            ],
            [
                "ArrayListValuedHashMap",
                "org.apache.commons.collections4.multimap"
            ],
            [
                "AbstractMultiValuedMapDecorator",
                "org.apache.commons.collections4.multimap"
            ],
            [
                "LazyList",
                "org.apache.commons.collections4.list"
            ],
            [
                "AbstractSerializableListDecorator",
                "org.apache.commons.collections4.list"
            ],
            [
                "TreeList",
                "org.apache.commons.collections4.list"
            ],
            [
                "SetUniqueList",
                "org.apache.commons.collections4.list"
            ],
            [
                "AbstractListDecorator",
                "org.apache.commons.collections4.list"
            ],
            [
                "NodeCachingLinkedList",
                "org.apache.commons.collections4.list"
            ],
            [
                "UnmodifiableList",
                "org.apache.commons.collections4.list"
            ],
            [
                "FixedSizeList",
                "org.apache.commons.collections4.list"
            ],
            [
                "TransformedList",
                "org.apache.commons.collections4.list"
            ],
            [
                "GrowthList",
                "org.apache.commons.collections4.list"
            ],
            [
                "AbstractLinkedList",
                "org.apache.commons.collections4.list"
            ],
            [
                "CursorableLinkedList",
                "org.apache.commons.collections4.list"
            ],
            [
                "PredicatedList",
                "org.apache.commons.collections4.list"
            ],
            [
                "OrderedMap",
                "org.apache.commons.collections4"
            ],
            [
                "AbstractQueueDecorator",
                "org.apache.commons.collections4.queue"
            ],
            [
                "TransformedQueue",
                "org.apache.commons.collections4.queue"
            ],
            [
                "UnmodifiableQueue",
                "org.apache.commons.collections4.queue"
            ],
            [
                "CircularFifoQueue",
                "org.apache.commons.collections4.queue"
            ],
            [
                "PredicatedQueue",
                "org.apache.commons.collections4.queue"
            ],
            [
                "FluentIterable",
                "org.apache.commons.collections4"
            ],
            [
                "TransformerUtils",
                "org.apache.commons.collections4"
            ],
            [
                "PredicateUtils",
                "org.apache.commons.collections4"
            ],
            [
                "ResettableIterator",
                "org.apache.commons.collections4"
            ],
            [
                "MultiValuedMap",
                "org.apache.commons.collections4"
            ],
            [
                "SetUtils",
                "org.apache.commons.collections4"
            ],
            [
                "SortedBidiMap",
                "org.apache.commons.collections4"
            ],
            [
                "ArrayStack",
                "org.apache.commons.collections4"
            ],
            [
                "Put",
                "org.apache.commons.collections4"
            ],
            [
                "OrderedMapIterator",
                "org.apache.commons.collections4"
            ],
            [
                "TransformedSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "CompositeSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "TransformedNavigableSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "PredicatedNavigableSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "AbstractSetDecorator",
                "org.apache.commons.collections4.set"
            ],
            [
                "ListOrderedSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "UnmodifiableSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "AbstractSerializableSetDecorator",
                "org.apache.commons.collections4.set"
            ],
            [
                "MapBackedSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "UnmodifiableSortedSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "PredicatedSortedSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "AbstractSortedSetDecorator",
                "org.apache.commons.collections4.set"
            ],
            [
                "PredicatedSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "AbstractNavigableSetDecorator",
                "org.apache.commons.collections4.set"
            ],
            [
                "UnmodifiableNavigableSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "TransformedSortedSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "IterableMap",
                "org.apache.commons.collections4"
            ],
            [
                "EnumerationUtils",
                "org.apache.commons.collections4"
            ],
            [
                "DeleteCommand",
                "org.apache.commons.collections4.sequence"
            ],
            [
                "ReplacementsHandler",
                "org.apache.commons.collections4.sequence"
            ],
            [
                "InsertCommand",
                "org.apache.commons.collections4.sequence"
            ],
            [
                "SequencesComparator",
                "org.apache.commons.collections4.sequence"
            ],
            [
                "ReplacementsFinder",
                "org.apache.commons.collections4.sequence"
            ],
            [
                "KeepCommand",
                "org.apache.commons.collections4.sequence"
            ],
            [
                "EditCommand",
                "org.apache.commons.collections4.sequence"
            ],
            [
                "CommandVisitor",
                "org.apache.commons.collections4.sequence"
            ],
            [
                "EditScript",
                "org.apache.commons.collections4.sequence"
            ],
            [
                "QueueUtils",
                "org.apache.commons.collections4"
            ],
            [
                "SetValuedMap",
                "org.apache.commons.collections4"
            ],
            [
                "SynchronizedBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "AbstractMapBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "CollectionBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "UnmodifiableBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "PredicatedSortedBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "UnmodifiableSortedBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "HashBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "AbstractBagDecorator",
                "org.apache.commons.collections4.bag"
            ],
            [
                "TransformedSortedBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "TreeBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "PredicatedBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "SynchronizedSortedBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "CollectionSortedBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "TransformedBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "AbstractSortedBagDecorator",
                "org.apache.commons.collections4.bag"
            ],
            [
                "HashMultiSet",
                "org.apache.commons.collections4.multiset"
            ],
            [
                "AbstractMultiSet",
                "org.apache.commons.collections4.multiset"
            ],
            [
                "PredicatedMultiSet",
                "org.apache.commons.collections4.multiset"
            ],
            [
                "AbstractMultiSetDecorator",
                "org.apache.commons.collections4.multiset"
            ],
            [
                "AbstractMapMultiSet",
                "org.apache.commons.collections4.multiset"
            ],
            [
                "UnmodifiableMultiSet",
                "org.apache.commons.collections4.multiset"
            ],
            [
                "SynchronizedMultiSet",
                "org.apache.commons.collections4.multiset"
            ],
            [
                "BagUtils",
                "org.apache.commons.collections4"
            ],
            [
                "Unmodifiable",
                "org.apache.commons.collections4"
            ],
            [
                "Get",
                "org.apache.commons.collections4"
            ],
            [
                "Trie",
                "org.apache.commons.collections4"
            ],
            [
                "MultiMap",
                "org.apache.commons.collections4"
            ],
            [
                "KeyValue",
                "org.apache.commons.collections4"
            ],
            [
                "IteratorChain",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "EmptyListIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "UnmodifiableOrderedMapIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "AbstractListIteratorDecorator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "ZippingIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "UnmodifiableIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "CollatingIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "UniqueFilterIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "ReverseListIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "BoundedIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "AbstractIteratorDecorator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "TransformIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "AbstractEmptyIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "NodeListIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "ArrayListIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "LazyIteratorChain",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "LoopingListIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "PeekingIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "ObjectGraphIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "ArrayIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "PermutationIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "SingletonListIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "EmptyMapIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "ObjectArrayIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "EnumerationIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "IteratorIterable",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "AbstractEmptyMapIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "LoopingIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "IteratorEnumeration",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "SingletonIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "ListIteratorWrapper",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "SkippingIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "EmptyOrderedIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "AbstractMapIteratorDecorator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "ObjectArrayListIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "UnmodifiableListIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "EmptyOrderedMapIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "UnmodifiableMapIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "EmptyIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "EntrySetMapIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "PushbackIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "FilterIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "AbstractUntypedIteratorDecorator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "AbstractOrderedMapIteratorDecorator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "FilterListIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "SplitMapUtils",
                "org.apache.commons.collections4"
            ],
            [
                "BoundedMap",
                "org.apache.commons.collections4"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "emptyIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Empty\n//-----------------------------------------------------------------------\n/**\n * Gets an empty iterator.\n * <p>\n * This iterator is a valid iterator object that will iterate over nothing.\n *\n * @param <E> the element type\n * @return an iterator over nothing\n */\npublic static <E> ResettableIterator<E> emptyIterator() {\n    return EmptyIterator.<E>resettableEmptyIterator();\n}"
            ],
            [
                "emptyListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an empty list iterator.\n * <p>\n * This iterator is a valid list iterator object that will iterate\n * over nothing.\n *\n * @param <E> the element type\n * @return a list iterator over nothing\n */\npublic static <E> ResettableListIterator<E> emptyListIterator() {\n    return EmptyListIterator.<E>resettableEmptyListIterator();\n}"
            ],
            [
                "emptyOrderedIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an empty ordered iterator.\n * <p>\n * This iterator is a valid iterator object that will iterate\n * over nothing.\n *\n * @param <E> the element type\n * @return an ordered iterator over nothing\n */\npublic static <E> OrderedIterator<E> emptyOrderedIterator() {\n    return EmptyOrderedIterator.<E>emptyOrderedIterator();\n}"
            ],
            [
                "emptyMapIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an empty map iterator.\n * <p>\n * This iterator is a valid map iterator object that will iterate\n * over nothing.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @return a map iterator over nothing\n */\npublic static <K, V> MapIterator<K, V> emptyMapIterator() {\n    return EmptyMapIterator.<K, V>emptyMapIterator();\n}"
            ],
            [
                "emptyOrderedMapIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an empty ordered map iterator.\n * <p>\n * This iterator is a valid map iterator object that will iterate\n * over nothing.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @return a map iterator over nothing\n */\npublic static <K, V> OrderedMapIterator<K, V> emptyOrderedMapIterator() {\n    return EmptyOrderedMapIterator.<K, V>emptyOrderedMapIterator();\n}"
            ],
            [
                "singletonIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Singleton\n//-----------------------------------------------------------------------\n/**\n * Gets a singleton iterator.\n * <p>\n * This iterator is a valid iterator object that will iterate over\n * the specified object.\n *\n * @param <E> the element type\n * @param object  the single object over which to iterate\n * @return a singleton iterator over the object\n */\npublic static <E> ResettableIterator<E> singletonIterator(final E object) {\n    return new SingletonIterator<E>(object);\n}"
            ],
            [
                "singletonListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a singleton list iterator.\n * <p>\n * This iterator is a valid list iterator object that will iterate over\n * the specified object.\n *\n * @param <E> the element type\n * @param object  the single object over which to iterate\n * @return a singleton list iterator over the object\n */\npublic static <E> ListIterator<E> singletonListIterator(final E object) {\n    return new SingletonListIterator<E>(object);\n}"
            ],
            [
                "arrayIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Arrays\n//-----------------------------------------------------------------------\n/**\n * Gets an iterator over an object array.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @return an iterator over the array\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableIterator<E> arrayIterator(final E... array) {\n    return new ObjectArrayIterator<E>(array);\n}"
            ],
            [
                "arrayIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator over an object or primitive array.\n * <p>\n * This method will handle primitive arrays as well as object arrays.\n * The primitives will be wrapped in the appropriate wrapper class.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @return an iterator over the array\n * @throws IllegalArgumentException if the array is not an array\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableIterator<E> arrayIterator(final Object array) {\n    return new ArrayIterator<E>(array);\n}"
            ],
            [
                "arrayIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator over the end part of an object array.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @param start  the index to start iterating at\n * @return an iterator over part of the array\n * @throws IndexOutOfBoundsException if start is less than zero or greater\n *   than the length of the array\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableIterator<E> arrayIterator(final E[] array, final int start) {\n    return new ObjectArrayIterator<E>(array, start);\n}"
            ],
            [
                "arrayIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator over the end part of an object or primitive array.\n * <p>\n * This method will handle primitive arrays as well as object arrays.\n * The primitives will be wrapped in the appropriate wrapper class.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @param start  the index to start iterating at\n * @return an iterator over part of the array\n * @throws IllegalArgumentException if the array is not an array\n * @throws IndexOutOfBoundsException if start is less than zero or greater\n *   than the length of the array\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableIterator<E> arrayIterator(final Object array, final int start) {\n    return new ArrayIterator<E>(array, start);\n}"
            ],
            [
                "arrayIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator over part of an object array.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @param start  the index to start iterating at\n * @param end  the index to finish iterating at\n * @return an iterator over part of the array\n * @throws IndexOutOfBoundsException if array bounds are invalid\n * @throws IllegalArgumentException if end is before start\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableIterator<E> arrayIterator(final E[] array, final int start, final int end) {\n    return new ObjectArrayIterator<E>(array, start, end);\n}"
            ],
            [
                "arrayIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator over part of an object or primitive array.\n * <p>\n * This method will handle primitive arrays as well as object arrays.\n * The primitives will be wrapped in the appropriate wrapper class.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @param start  the index to start iterating at\n * @param end  the index to finish iterating at\n * @return an iterator over part of the array\n * @throws IllegalArgumentException if the array is not an array or end is before start\n * @throws IndexOutOfBoundsException if array bounds are invalid\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableIterator<E> arrayIterator(final Object array, final int start, final int end) {\n    return new ArrayIterator<E>(array, start, end);\n}"
            ],
            [
                "arrayListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "//-----------------------------------------------------------------------\n/**\n * Gets a list iterator over an object array.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @return a list iterator over the array\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableListIterator<E> arrayListIterator(final E... array) {\n    return new ObjectArrayListIterator<E>(array);\n}"
            ],
            [
                "arrayListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a list iterator over an object or primitive array.\n * <p>\n * This method will handle primitive arrays as well as object arrays.\n * The primitives will be wrapped in the appropriate wrapper class.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @return a list iterator over the array\n * @throws IllegalArgumentException if the array is not an array\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableListIterator<E> arrayListIterator(final Object array) {\n    return new ArrayListIterator<E>(array);\n}"
            ],
            [
                "arrayListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a list iterator over the end part of an object array.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @param start  the index to start iterating at\n * @return a list iterator over part of the array\n * @throws IndexOutOfBoundsException if start is less than zero\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableListIterator<E> arrayListIterator(final E[] array, final int start) {\n    return new ObjectArrayListIterator<E>(array, start);\n}"
            ],
            [
                "arrayListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a list iterator over the end part of an object or primitive array.\n * <p>\n * This method will handle primitive arrays as well as object arrays.\n * The primitives will be wrapped in the appropriate wrapper class.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @param start  the index to start iterating at\n * @return a list iterator over part of the array\n * @throws IllegalArgumentException if the array is not an array\n * @throws IndexOutOfBoundsException if start is less than zero\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableListIterator<E> arrayListIterator(final Object array, final int start) {\n    return new ArrayListIterator<E>(array, start);\n}"
            ],
            [
                "arrayListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a list iterator over part of an object array.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @param start  the index to start iterating at\n * @param end  the index to finish iterating at\n * @return a list iterator over part of the array\n * @throws IndexOutOfBoundsException if array bounds are invalid\n * @throws IllegalArgumentException if end is before start\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableListIterator<E> arrayListIterator(final E[] array, final int start, final int end) {\n    return new ObjectArrayListIterator<E>(array, start, end);\n}"
            ],
            [
                "arrayListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a list iterator over part of an object or primitive array.\n * <p>\n * This method will handle primitive arrays as well as object arrays.\n * The primitives will be wrapped in the appropriate wrapper class.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @param start  the index to start iterating at\n * @param end  the index to finish iterating at\n * @return a list iterator over part of the array\n * @throws IllegalArgumentException if the array is not an array or end is before start\n * @throws IndexOutOfBoundsException if array bounds are invalid\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableListIterator<E> arrayListIterator(final Object array, final int start, final int end) {\n    return new ArrayListIterator<E>(array, start, end);\n}"
            ],
            [
                "boundedIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Bounded\n//-----------------------------------------------------------------------\n/**\n * Decorates the specified iterator to return at most the given number\n * of elements.\n *\n * @param <E> the element type\n * @param iterator  the iterator to decorate\n * @param max  the maximum number of elements returned by this iterator\n * @return a new bounded iterator\n * @throws NullPointerException if the iterator is null\n * @throws IllegalArgumentException if max is negative\n * @since 4.1\n */\npublic static <E> BoundedIterator<E> boundedIterator(final Iterator<? extends E> iterator, long max) {\n    return boundedIterator(iterator, 0, max);\n}"
            ],
            [
                "boundedIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Decorates the specified iterator to return at most the given number\n * of elements, skipping all elements until the iterator reaches the\n * position at {@code offset}.\n * <p>\n * The iterator is immediately advanced until it reaches the position at\n * {@code offset}, incurring O(n) time.\n *\n * @param <E> the element type\n * @param iterator  the iterator to decorate\n * @param offset  the index of the first element of the decorated iterator to return\n * @param max  the maximum number of elements returned by this iterator\n * @return a new bounded iterator\n * @throws NullPointerException if the iterator is null\n * @throws IllegalArgumentException if either offset or max is negative\n * @since 4.1\n */\npublic static <E> BoundedIterator<E> boundedIterator(final Iterator<? extends E> iterator, long offset, long max) {\n    return new BoundedIterator<E>(iterator, offset, max);\n}"
            ],
            [
                "unmodifiableIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Unmodifiable\n//-----------------------------------------------------------------------\n/**\n * Gets an immutable version of an {@link Iterator}. The returned object\n * will always throw an {@link UnsupportedOperationException} for\n * the {@link Iterator#remove} method.\n *\n * @param <E> the element type\n * @param iterator  the iterator to make immutable\n * @return an immutable version of the iterator\n */\npublic static <E> Iterator<E> unmodifiableIterator(final Iterator<E> iterator) {\n    return UnmodifiableIterator.unmodifiableIterator(iterator);\n}"
            ],
            [
                "unmodifiableListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an immutable version of a {@link ListIterator}. The returned object\n * will always throw an {@link UnsupportedOperationException} for\n * the {@link Iterator#remove}, {@link ListIterator#add} and\n * {@link ListIterator#set} methods.\n *\n * @param <E> the element type\n * @param listIterator  the iterator to make immutable\n * @return an immutable version of the iterator\n */\npublic static <E> ListIterator<E> unmodifiableListIterator(final ListIterator<E> listIterator) {\n    return UnmodifiableListIterator.umodifiableListIterator(listIterator);\n}"
            ],
            [
                "unmodifiableMapIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an immutable version of a {@link MapIterator}. The returned object\n * will always throw an {@link UnsupportedOperationException} for\n * the {@link Iterator#remove}, {@link MapIterator#setValue(Object)} methods.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param mapIterator  the iterator to make immutable\n * @return an immutable version of the iterator\n */\npublic static <K, V> MapIterator<K, V> unmodifiableMapIterator(final MapIterator<K, V> mapIterator) {\n    return UnmodifiableMapIterator.unmodifiableMapIterator(mapIterator);\n}"
            ],
            [
                "chainedIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Chained\n//-----------------------------------------------------------------------\n/**\n * Gets an iterator that iterates through two {@link Iterator}s\n * one after another.\n *\n * @param <E> the element type\n * @param iterator1  the first iterator to use, not null\n * @param iterator2  the second iterator to use, not null\n * @return a combination iterator over the iterators\n * @throws NullPointerException if either iterator is null\n */\npublic static <E> Iterator<E> chainedIterator(final Iterator<? extends E> iterator1, final Iterator<? extends E> iterator2) {\n    // keep a version with two iterators to avoid the following warning in client code (Java 5 & 6)\n    // \"A generic array of E is created for a varargs parameter\"\n    return new IteratorChain<E>(iterator1, iterator2);\n}"
            ],
            [
                "chainedIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator that iterates through an array of {@link Iterator}s\n * one after another.\n *\n * @param <E> the element type\n * @param iterators  the iterators to use, not null or empty or contain nulls\n * @return a combination iterator over the iterators\n * @throws NullPointerException if iterators array is null or contains a null\n */\npublic static <E> Iterator<E> chainedIterator(final Iterator<? extends E>... iterators) {\n    return new IteratorChain<E>(iterators);\n}"
            ],
            [
                "chainedIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator that iterates through a collections of {@link Iterator}s\n * one after another.\n *\n * @param <E> the element type\n * @param iterators  the iterators to use, not null or empty or contain nulls\n * @return a combination iterator over the iterators\n * @throws NullPointerException if iterators collection is null or contains a null\n * @throws ClassCastException if the iterators collection contains the wrong object type\n */\npublic static <E> Iterator<E> chainedIterator(final Collection<Iterator<? extends E>> iterators) {\n    return new IteratorChain<E>(iterators);\n}"
            ],
            [
                "collatedIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Collated\n//-----------------------------------------------------------------------\n/**\n * Gets an iterator that provides an ordered iteration over the elements\n * contained in a collection of ordered {@link Iterator}s.\n * <p>\n * Given two ordered {@link Iterator}s <code>A</code> and <code>B</code>,\n * the {@link Iterator#next()} method will return the lesser of\n * <code>A.next()</code> and <code>B.next()</code>.\n * <p>\n * The comparator is optional. If null is specified then natural order is used.\n *\n * @param <E> the element type\n * @param comparator  the comparator to use, may be null for natural order\n * @param iterator1  the first iterators to use, not null\n * @param iterator2  the first iterators to use, not null\n * @return a combination iterator over the iterators\n * @throws NullPointerException if either iterator is null\n */\npublic static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator, final Iterator<? extends E> iterator1, final Iterator<? extends E> iterator2) {\n    @SuppressWarnings(\"unchecked\")\n    final Comparator<E> comp = comparator == null ? ComparatorUtils.NATURAL_COMPARATOR : (Comparator<E>) comparator;\n    return new CollatingIterator<E>(comp, iterator1, iterator2);\n}"
            ],
            [
                "collatedIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator that provides an ordered iteration over the elements\n * contained in an array of {@link Iterator}s.\n * <p>\n * Given two ordered {@link Iterator}s <code>A</code> and <code>B</code>,\n * the {@link Iterator#next()} method will return the lesser of\n * <code>A.next()</code> and <code>B.next()</code> and so on.\n * <p>\n * The comparator is optional. If null is specified then natural order is used.\n *\n * @param <E> the element type\n * @param comparator  the comparator to use, may be null for natural order\n * @param iterators  the iterators to use, not null or empty or contain nulls\n * @return a combination iterator over the iterators\n * @throws NullPointerException if iterators array is null or contains a null value\n */\npublic static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator, final Iterator<? extends E>... iterators) {\n    @SuppressWarnings(\"unchecked\")\n    final Comparator<E> comp = comparator == null ? ComparatorUtils.NATURAL_COMPARATOR : (Comparator<E>) comparator;\n    return new CollatingIterator<E>(comp, iterators);\n}"
            ],
            [
                "collatedIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator that provides an ordered iteration over the elements\n * contained in a collection of {@link Iterator}s.\n * <p>\n * Given two ordered {@link Iterator}s <code>A</code> and <code>B</code>,\n * the {@link Iterator#next()} method will return the lesser of\n * <code>A.next()</code> and <code>B.next()</code> and so on.\n * <p>\n * The comparator is optional. If null is specified then natural order is used.\n *\n * @param <E> the element type\n * @param comparator  the comparator to use, may be null for natural order\n * @param iterators  the iterators to use, not null or empty or contain nulls\n * @return a combination iterator over the iterators\n * @throws NullPointerException if iterators collection is null or contains a null\n * @throws ClassCastException if the iterators collection contains the wrong object type\n */\npublic static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator, final Collection<Iterator<? extends E>> iterators) {\n    @SuppressWarnings(\"unchecked\")\n    final Comparator<E> comp = comparator == null ? ComparatorUtils.NATURAL_COMPARATOR : (Comparator<E>) comparator;\n    return new CollatingIterator<E>(comp, iterators);\n}"
            ],
            [
                "objectGraphIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Object Graph\n//-----------------------------------------------------------------------\n/**\n * Gets an iterator that operates over an object graph.\n * <p>\n * This iterator can extract multiple objects from a complex tree-like object graph.\n * The iteration starts from a single root object.\n * It uses a <code>Transformer</code> to extract the iterators and elements.\n * Its main benefit is that no intermediate <code>List</code> is created.\n * <p>\n * For example, consider an object graph:\n * <pre>\n *                 |- Branch -- Leaf\n *                 |         \\- Leaf\n *         |- Tree |         /- Leaf\n *         |       |- Branch -- Leaf\n *  Forest |                 \\- Leaf\n *         |       |- Branch -- Leaf\n *         |       |         \\- Leaf\n *         |- Tree |         /- Leaf\n *                 |- Branch -- Leaf\n *                 |- Branch -- Leaf</pre>\n * The following <code>Transformer</code>, used in this class, will extract all\n * the Leaf objects without creating a combined intermediate list:\n * <pre>\n * public Object transform(Object input) {\n *   if (input instanceof Forest) {\n *     return ((Forest) input).treeIterator();\n *   }\n *   if (input instanceof Tree) {\n *     return ((Tree) input).branchIterator();\n *   }\n *   if (input instanceof Branch) {\n *     return ((Branch) input).leafIterator();\n *   }\n *   if (input instanceof Leaf) {\n *     return input;\n *   }\n *   throw new ClassCastException();\n * }</pre>\n * <p>\n * Internally, iteration starts from the root object. When next is called,\n * the transformer is called to examine the object. The transformer will return\n * either an iterator or an object. If the object is an Iterator, the next element\n * from that iterator is obtained and the process repeats. If the element is an object\n * it is returned.\n * <p>\n * Under many circumstances, linking Iterators together in this manner is\n * more efficient (and convenient) than using nested for loops to extract a list.\n *\n * @param <E> the element type\n * @param root  the root object to start iterating from, null results in an empty iterator\n * @param transformer  the transformer to use, see above, null uses no effect transformer\n * @return a new object graph iterator\n * @since 3.1\n */\npublic static <E> Iterator<E> objectGraphIterator(final E root, final Transformer<? super E, ? extends E> transformer) {\n    return new ObjectGraphIterator<E>(root, transformer);\n}"
            ],
            [
                "transformedIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Transformed\n//-----------------------------------------------------------------------\n/**\n * Gets an iterator that transforms the elements of another iterator.\n * <p>\n * The transformation occurs during the next() method and the underlying\n * iterator is unaffected by the transformation.\n *\n * @param <I> the input type\n * @param <O> the output type\n * @param iterator  the iterator to use, not null\n * @param transform  the transform to use, not null\n * @return a new transforming iterator\n * @throws NullPointerException if either parameter is null\n */\npublic static <I, O> Iterator<O> transformedIterator(final Iterator<? extends I> iterator, final Transformer<? super I, ? extends O> transform) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (transform == null) {\n        throw new NullPointerException(\"Transformer must not be null\");\n    }\n    return new TransformIterator<I, O>(iterator, transform);\n}"
            ],
            [
                "filteredIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Filtered\n//-----------------------------------------------------------------------\n/**\n * Gets an iterator that filters another iterator.\n * <p>\n * The returned iterator will only return objects that match the specified\n * filtering predicate.\n *\n * @param <E> the element type\n * @param iterator  the iterator to use, not null\n * @param predicate  the predicate to use as a filter, not null\n * @return a new filtered iterator\n * @throws NullPointerException if either parameter is null\n */\npublic static <E> Iterator<E> filteredIterator(final Iterator<? extends E> iterator, final Predicate<? super E> predicate) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    return new FilterIterator<E>(iterator, predicate);\n}"
            ],
            [
                "filteredListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a list iterator that filters another list iterator.\n * <p>\n * The returned iterator will only return objects that match the specified\n * filtering predicate.\n *\n * @param <E> the element type\n * @param listIterator  the list iterator to use, not null\n * @param predicate  the predicate to use as a filter, not null\n * @return a new filtered iterator\n * @throws NullPointerException if either parameter is null\n */\npublic static <E> ListIterator<E> filteredListIterator(final ListIterator<? extends E> listIterator, final Predicate<? super E> predicate) {\n    if (listIterator == null) {\n        throw new NullPointerException(\"ListIterator must not be null\");\n    }\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    return new FilterListIterator<E>(listIterator, predicate);\n}"
            ],
            [
                "loopingIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Looping\n//-----------------------------------------------------------------------\n/**\n * Gets an iterator that loops continuously over the supplied collection.\n * <p>\n * The iterator will only stop looping if the remove method is called\n * enough times to empty the collection, or if the collection is empty\n * to start with.\n *\n * @param <E> the element type\n * @param coll  the collection to iterate over, not null\n * @return a new looping iterator\n * @throws NullPointerException if the collection is null\n */\npublic static <E> ResettableIterator<E> loopingIterator(final Collection<? extends E> coll) {\n    if (coll == null) {\n        throw new NullPointerException(\"Collection must not be null\");\n    }\n    return new LoopingIterator<E>(coll);\n}"
            ],
            [
                "loopingListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator that loops continuously over the supplied list.\n * <p>\n * The iterator will only stop looping if the remove method is called\n * enough times to empty the list, or if the list is empty to start with.\n *\n * @param <E> the element type\n * @param list  the list to iterate over, not null\n * @return a new looping iterator\n * @throws NullPointerException if the list is null\n * @since 3.2\n */\npublic static <E> ResettableListIterator<E> loopingListIterator(final List<E> list) {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    return new LoopingListIterator<E>(list);\n}"
            ],
            [
                "nodeListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// org.w3c.dom.NodeList iterators\n//-----------------------------------------------------------------------\n/**\n * Gets an {@link Iterator} that wraps the specified {@link NodeList}.\n * The returned {@link Iterator} can be used for a single iteration.\n *\n * @param nodeList  the node list to use, may not be null\n * @return a new, single use {@link Iterator}\n * @throws NullPointerException if nodeList is null\n * @since 4.0\n */\npublic static NodeListIterator nodeListIterator(final NodeList nodeList) {\n    if (nodeList == null) {\n        throw new NullPointerException(\"NodeList must not be null\");\n    }\n    return new NodeListIterator(nodeList);\n}"
            ],
            [
                "nodeListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an {@link Iterator} that wraps the specified node's childNodes.\n * The returned {@link Iterator} can be used for a single iteration.\n * <p>\n * Convenience method, allows easy iteration over NodeLists:\n * <pre>\n *   Iterator&lt;Node&gt; iterator = IteratorUtils.nodeListIterator(node);\n *   for(Node childNode : IteratorUtils.asIterable(iterator)) {\n *     ...\n *   }\n * </pre>\n *\n * @param node  the node to use, may not be null\n * @return a new, single use {@link Iterator}\n * @throws NullPointerException if node is null\n * @since 4.0\n */\npublic static NodeListIterator nodeListIterator(final Node node) {\n    if (node == null) {\n        throw new NullPointerException(\"Node must not be null\");\n    }\n    return new NodeListIterator(node);\n}"
            ],
            [
                "peekingIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Peeking\n//-----------------------------------------------------------------------\n/**\n * Gets an iterator that supports one-element lookahead.\n *\n * @param <E> the element type\n * @param iterator  the iterator to decorate, not null\n * @return a peeking iterator\n * @throws NullPointerException if the iterator is null\n * @since 4.0\n */\npublic static <E> Iterator<E> peekingIterator(final Iterator<? extends E> iterator) {\n    return PeekingIterator.peekingIterator(iterator);\n}"
            ],
            [
                "pushbackIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Pushback\n//-----------------------------------------------------------------------\n/**\n * Gets an iterator that supports pushback of elements.\n *\n * @param <E> the element type\n * @param iterator  the iterator to decorate, not null\n * @return a pushback iterator\n * @throws NullPointerException if the iterator is null\n * @since 4.0\n */\npublic static <E> Iterator<E> pushbackIterator(final Iterator<? extends E> iterator) {\n    return PushbackIterator.pushbackIterator(iterator);\n}"
            ],
            [
                "skippingIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Skipping\n//-----------------------------------------------------------------------\n/**\n * Decorates the specified iterator to skip the first N elements.\n *\n * @param <E> the element type\n * @param iterator  the iterator to decorate\n * @param offset  the first number of elements to skip\n * @return a new skipping iterator\n * @throws NullPointerException if the iterator is null\n * @throws IllegalArgumentException if offset is negative\n * @since 4.1\n */\npublic static <E> SkippingIterator<E> skippingIterator(final Iterator<E> iterator, long offset) {\n    return new SkippingIterator<E>(iterator, offset);\n}"
            ],
            [
                "zippingIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Zipping\n//-----------------------------------------------------------------------\n/**\n * Returns an iterator that interleaves elements from the decorated iterators.\n *\n * @param <E> the element type\n * @param a  the first iterator to interleave\n * @param b  the second iterator to interleave\n * @return an iterator, interleaving the decorated iterators\n * @throws NullPointerException if any iterator is null\n * @since 4.1\n */\npublic static <E> ZippingIterator<E> zippingIterator(final Iterator<? extends E> a, final Iterator<? extends E> b) {\n    return new ZippingIterator<E>(a, b);\n}"
            ],
            [
                "zippingIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Returns an iterator that interleaves elements from the decorated iterators.\n *\n * @param <E> the element type\n * @param a  the first iterator to interleave\n * @param b  the second iterator to interleave\n * @param c  the third iterator to interleave\n * @return an iterator, interleaving the decorated iterators\n * @throws NullPointerException if any iterator is null\n * @since 4.1\n */\npublic static <E> ZippingIterator<E> zippingIterator(final Iterator<? extends E> a, final Iterator<? extends E> b, final Iterator<? extends E> c) {\n    return new ZippingIterator<E>(a, b, c);\n}"
            ],
            [
                "zippingIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Returns an iterator that interleaves elements from the decorated iterators.\n *\n * @param <E> the element type\n * @param iterators  the array of iterators to interleave\n * @return an iterator, interleaving the decorated iterators\n * @throws NullPointerException if any iterator is null\n * @since 4.1\n */\npublic static <E> ZippingIterator<E> zippingIterator(final Iterator<? extends E>... iterators) {\n    return new ZippingIterator<E>(iterators);\n}"
            ],
            [
                "asIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Views\n//-----------------------------------------------------------------------\n/**\n * Gets an iterator that provides an iterator view of the given enumeration.\n *\n * @param <E> the element type\n * @param enumeration  the enumeration to use, may not be null\n * @return a new iterator\n * @throws NullPointerException if enumeration is null\n */\npublic static <E> Iterator<E> asIterator(final Enumeration<? extends E> enumeration) {\n    if (enumeration == null) {\n        throw new NullPointerException(\"Enumeration must not be null\");\n    }\n    return new EnumerationIterator<E>(enumeration);\n}"
            ],
            [
                "asIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator that provides an iterator view of the given enumeration\n * that will remove elements from the specified collection.\n *\n * @param <E> the element type\n * @param enumeration  the enumeration to use, may not be null\n * @param removeCollection  the collection to remove elements from, may not be null\n * @return a new iterator\n * @throws NullPointerException if enumeration or removeCollection is null\n */\npublic static <E> Iterator<E> asIterator(final Enumeration<? extends E> enumeration, final Collection<? super E> removeCollection) {\n    if (enumeration == null) {\n        throw new NullPointerException(\"Enumeration must not be null\");\n    }\n    if (removeCollection == null) {\n        throw new NullPointerException(\"Collection must not be null\");\n    }\n    return new EnumerationIterator<E>(enumeration, removeCollection);\n}"
            ],
            [
                "asEnumeration",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an enumeration that wraps an iterator.\n *\n * @param <E> the element type\n * @param iterator  the iterator to use, may not be null\n * @return a new enumeration\n * @throws NullPointerException if iterator is null\n */\npublic static <E> Enumeration<E> asEnumeration(final Iterator<? extends E> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorEnumeration<E>(iterator);\n}"
            ],
            [
                "asIterable",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an {@link Iterable} that wraps an iterator.  The returned {@link Iterable} can be\n * used for a single iteration.\n *\n * @param <E> the element type\n * @param iterator  the iterator to use, may not be null\n * @return a new, single use {@link Iterable}\n * @throws NullPointerException if iterator is null\n */\npublic static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}"
            ],
            [
                "asMultipleUseIterable",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterable that wraps an iterator.  The returned iterable can be\n * used for multiple iterations.\n *\n * @param <E> the element type\n * @param iterator  the iterator to use, may not be null\n * @return a new, multiple use iterable\n * @throws NullPointerException if iterator is null\n */\npublic static <E> Iterable<E> asMultipleUseIterable(final Iterator<? extends E> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, true);\n}"
            ],
            [
                "toListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a list iterator based on a simple iterator.\n * <p>\n * As the wrapped Iterator is traversed, a LinkedList of its values is\n * cached, permitting all required operations of ListIterator.\n *\n * @param <E> the element type\n * @param iterator  the iterator to use, may not be null\n * @return a new iterator\n * @throws NullPointerException if iterator parameter is null\n */\npublic static <E> ListIterator<E> toListIterator(final Iterator<? extends E> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new ListIteratorWrapper<E>(iterator);\n}"
            ],
            [
                "toArray",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an array based on an iterator.\n * <p>\n * As the wrapped Iterator is traversed, an ArrayList of its values is\n * created. At the end, this is converted to an array.\n *\n * @param iterator  the iterator to use, not null\n * @return an array of the iterator contents\n * @throws NullPointerException if iterator parameter is null\n */\npublic static Object[] toArray(final Iterator<?> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    final List<?> list = toList(iterator, 100);\n    return list.toArray();\n}"
            ],
            [
                "toArray",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an array based on an iterator.\n * <p>\n * As the wrapped Iterator is traversed, an ArrayList of its values is\n * created. At the end, this is converted to an array.\n *\n * @param <E> the element type\n * @param iterator  the iterator to use, not null\n * @param arrayClass  the class of array to create\n * @return an array of the iterator contents\n * @throws NullPointerException if iterator parameter or arrayClass is null\n * @throws ArrayStoreException if the arrayClass is invalid\n */\npublic static <E> E[] toArray(final Iterator<? extends E> iterator, final Class<E> arrayClass) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (arrayClass == null) {\n        throw new NullPointerException(\"Array class must not be null\");\n    }\n    final List<E> list = toList(iterator, 100);\n    @SuppressWarnings(\"unchecked\")\n    final E[] array = (E[]) Array.newInstance(arrayClass, list.size());\n    return list.toArray(array);\n}"
            ],
            [
                "toList",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a list based on an iterator.\n * <p>\n * As the wrapped Iterator is traversed, an ArrayList of its values is\n * created. At the end, the list is returned.\n *\n * @param <E> the element type\n * @param iterator  the iterator to use, not null\n * @return a list of the iterator contents\n * @throws NullPointerException if iterator parameter is null\n */\npublic static <E> List<E> toList(final Iterator<? extends E> iterator) {\n    return toList(iterator, 10);\n}"
            ],
            [
                "toList",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a list based on an iterator.\n * <p>\n * As the wrapped Iterator is traversed, an ArrayList of its values is\n * created. At the end, the list is returned.\n *\n * @param <E> the element type\n * @param iterator  the iterator to use, not null\n * @param estimatedSize  the initial size of the ArrayList\n * @return a list of the iterator contents\n * @throws NullPointerException if iterator parameter is null\n * @throws IllegalArgumentException if the size is less than 1\n */\npublic static <E> List<E> toList(final Iterator<? extends E> iterator, final int estimatedSize) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (estimatedSize < 1) {\n        throw new IllegalArgumentException(\"Estimated size must be greater than 0\");\n    }\n    final List<E> list = new ArrayList<E>(estimatedSize);\n    while (iterator.hasNext()) {\n        list.add(iterator.next());\n    }\n    return list;\n}"
            ],
            [
                "getIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a suitable Iterator for the given object.\n * <p>\n * This method can handle objects as follows\n * <ul>\n * <li>null - empty iterator\n * <li>Iterator - returned directly\n * <li>Enumeration - wrapped\n * <li>Collection - iterator from collection returned\n * <li>Map - values iterator returned\n * <li>Dictionary - values (elements) enumeration returned as iterator\n * <li>array - iterator over array returned\n * <li>object with iterator() public method accessed by reflection\n * <li>object - singleton iterator\n * <li>NodeList - iterator over the list\n * <li>Node - iterator over the child nodes\n * </ul>\n *\n * @param obj  the object to convert to an iterator\n * @return a suitable iterator, never null\n */\npublic static Iterator<?> getIterator(final Object obj) {\n    if (obj == null) {\n        return emptyIterator();\n    }\n    if (obj instanceof Iterator) {\n        return (Iterator<?>) obj;\n    }\n    if (obj instanceof Iterable) {\n        return ((Iterable<?>) obj).iterator();\n    }\n    if (obj instanceof Object[]) {\n        return new ObjectArrayIterator<Object>((Object[]) obj);\n    }\n    if (obj instanceof Enumeration) {\n        return new EnumerationIterator<Object>((Enumeration<?>) obj);\n    }\n    if (obj instanceof Map) {\n        return ((Map<?, ?>) obj).values().iterator();\n    }\n    if (obj instanceof NodeList) {\n        return new NodeListIterator((NodeList) obj);\n    }\n    if (obj instanceof Node) {\n        return new NodeListIterator((Node) obj);\n    }\n    if (obj instanceof Dictionary) {\n        return new EnumerationIterator<Object>(((Dictionary<?, ?>) obj).elements());\n    } else if (obj.getClass().isArray()) {\n        return new ArrayIterator<Object>(obj);\n    }\n    try {\n        final Method method = obj.getClass().getMethod(\"iterator\", (Class[]) null);\n        if (Iterator.class.isAssignableFrom(method.getReturnType())) {\n            final Iterator<?> it = (Iterator<?>) method.invoke(obj, (Object[]) null);\n            if (it != null) {\n                return it;\n            }\n        }\n    } catch (final RuntimeException e) {\n        // NOPMD\n        // ignore\n    } catch (final NoSuchMethodException e) {\n        // NOPMD\n        // ignore\n    } catch (final IllegalAccessException e) {\n        // NOPMD\n        // ignore\n    } catch (final InvocationTargetException e) {\n        // NOPMD\n        // ignore\n    }\n    return singletonIterator(obj);\n}"
            ],
            [
                "forEachButLast",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Executes the given closure on each but the last element in the iterator.\n * <p>\n * If the input iterator is null no change is made.\n *\n * @param <E> the type of object the {@link Iterator} contains\n * @param iterator  the iterator to get the input from, may be null\n * @param closure  the closure to perform, may not be null\n * @return the last element in the iterator, or null if iterator is null or empty\n * @throws NullPointerException if closure is null\n * @since 4.1\n */\npublic static <E> E forEachButLast(final Iterator<E> iterator, final Closure<? super E> closure) {\n    if (closure == null) {\n        throw new NullPointerException(\"Closure must not be null.\");\n    }\n    if (iterator != null) {\n        while (iterator.hasNext()) {\n            final E element = iterator.next();\n            if (iterator.hasNext()) {\n                closure.execute(element);\n            } else {\n                return element;\n            }\n        }\n    }\n    return null;\n}"
            ],
            [
                "find",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Finds the first element in the given iterator which matches the given predicate.\n * <p>\n * A <code>null</code> or empty iterator returns null.\n *\n * @param <E> the element type\n * @param iterator  the iterator to search, may be null\n * @param predicate  the predicate to use, may not be null\n * @return the first element of the iterator which matches the predicate or null if none could be found\n * @throws NullPointerException if predicate is null\n * @since 4.1\n */\npublic static <E> E find(final Iterator<E> iterator, final Predicate<? super E> predicate) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    if (iterator != null) {\n        while (iterator.hasNext()) {\n            final E element = iterator.next();\n            if (predicate.evaluate(element)) {\n                return element;\n            }\n        }\n    }\n    return null;\n}"
            ],
            [
                "indexOf",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Returns the index of the first element in the specified iterator that\n * matches the given predicate.\n * <p>\n * A <code>null</code> or empty iterator returns -1.\n *\n * @param <E> the element type\n * @param iterator  the iterator to search, may be null\n * @param predicate  the predicate to use, may not be null\n * @return the index of the first element which matches the predicate or -1 if none matches\n * @throws NullPointerException if predicate is null\n * @since 4.1\n */\npublic static <E> int indexOf(final Iterator<E> iterator, final Predicate<? super E> predicate) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    if (iterator != null) {\n        for (int index = 0; iterator.hasNext(); index++) {\n            final E element = iterator.next();\n            if (predicate.evaluate(element)) {\n                return index;\n            }\n        }\n    }\n    return -1;\n}"
            ],
            [
                "matchesAny",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Answers true if a predicate is true for any element of the iterator.\n * <p>\n * A <code>null</code> or empty iterator returns false.\n *\n * @param <E> the type of object the {@link Iterator} contains\n * @param iterator  the {@link Iterator} to use, may be null\n * @param predicate  the predicate to use, may not be null\n * @return true if any element of the collection matches the predicate, false otherwise\n * @throws NullPointerException if predicate is null\n * @since 4.1\n */\npublic static <E> boolean matchesAny(final Iterator<E> iterator, final Predicate<? super E> predicate) {\n    return indexOf(iterator, predicate) != -1;\n}"
            ],
            [
                "matchesAll",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Answers true if a predicate is true for every element of an iterator.\n * <p>\n * A <code>null</code> or empty iterator returns true.\n *\n * @param <E> the type of object the {@link Iterator} contains\n * @param iterator  the {@link Iterator} to use, may be null\n * @param predicate  the predicate to use, may not be null\n * @return true if every element of the collection matches the predicate or if the\n *   collection is empty, false otherwise\n * @throws NullPointerException if predicate is null\n * @since 4.1\n */\npublic static <E> boolean matchesAll(final Iterator<E> iterator, final Predicate<? super E> predicate) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    if (iterator != null) {\n        while (iterator.hasNext()) {\n            final E element = iterator.next();\n            if (!predicate.evaluate(element)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
            ],
            [
                "isEmpty",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Checks if the given iterator is empty.\n * <p>\n * A <code>null</code> or empty iterator returns true.\n *\n * @param iterator  the {@link Iterator} to use, may be null\n * @return true if the iterator is exhausted or null, false otherwise\n * @since 4.1\n */\npublic static boolean isEmpty(final Iterator<?> iterator) {\n    return iterator == null || !iterator.hasNext();\n}"
            ],
            [
                "contains",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Checks if the object is contained in the given iterator.\n * <p>\n * A <code>null</code> or empty iterator returns false.\n *\n * @param <E> the type of object the {@link Iterator} contains\n * @param iterator  the iterator to check, may be null\n * @param object  the object to check\n * @return true if the object is contained in the iterator, false otherwise\n * @since 4.1\n */\npublic static <E> boolean contains(final Iterator<E> iterator, final Object object) {\n    return matchesAny(iterator, EqualPredicate.equalPredicate(object));\n}"
            ],
            [
                "get",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Returns the <code>index</code>-th value in {@link Iterator}, throwing\n * <code>IndexOutOfBoundsException</code> if there is no such element.\n * <p>\n * The Iterator is advanced to <code>index</code> (or to the end, if\n * <code>index</code> exceeds the number of entries) as a side effect of this method.\n *\n * @param <E> the type of object in the {@link Iterator}\n * @param iterator  the iterator to get a value from\n * @param index  the index to get\n * @return the object at the specified index\n * @throws IndexOutOfBoundsException if the index is invalid\n * @since 4.1\n */\npublic static <E> E get(final Iterator<E> iterator, final int index) {\n    int i = index;\n    CollectionUtils.checkIndexBounds(i);\n    while (iterator.hasNext()) {\n        i--;\n        if (i == -1) {\n            return iterator.next();\n        }\n        iterator.next();\n    }\n    throw new IndexOutOfBoundsException(\"Entry does not exist: \" + i);\n}"
            ],
            [
                "size",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Returns the number of elements contained in the given iterator.\n * <p>\n * A <code>null</code> or empty iterator returns {@code 0}.\n *\n * @param iterator  the iterator to check, may be null\n * @return the number of elements contained in the iterator\n * @since 4.1\n */\npublic static int size(final Iterator<?> iterator) {\n    int size = 0;\n    if (iterator != null) {\n        while (iterator.hasNext()) {\n            iterator.next();\n            size++;\n        }\n    }\n    return size;\n}"
            ],
            [
                "toString",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Returns a string representation of the elements of the specified iterator.\n * <p>\n * The string representation consists of a list of the iterator's elements,\n * enclosed in square brackets ({@code \"[]\"}). Adjacent elements are separated\n * by the characters {@code \", \"} (a comma followed by a space). Elements are\n * converted to strings as by {@code String.valueOf(Object)}.\n *\n * @param <E> the element type\n * @param iterator  the iterator to convert to a string, may be null\n * @return a string representation of {@code iterator}\n * @since 4.1\n */\npublic static <E> String toString(final Iterator<E> iterator) {\n    return toString(iterator, TransformerUtils.stringValueTransformer(), DEFAULT_TOSTRING_DELIMITER, DEFAULT_TOSTRING_PREFIX, DEFAULT_TOSTRING_SUFFIX);\n}"
            ],
            [
                "toString",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Returns a string representation of the elements of the specified iterator.\n * <p>\n * The string representation consists of a list of the iterable's elements,\n * enclosed in square brackets ({@code \"[]\"}). Adjacent elements are separated\n * by the characters {@code \", \"} (a comma followed by a space). Elements are\n * converted to strings as by using the provided {@code transformer}.\n *\n * @param <E> the element type\n * @param iterator  the iterator to convert to a string, may be null\n * @param transformer  the transformer used to get a string representation of an element\n * @return a string representation of {@code iterator}\n * @throws NullPointerException if {@code transformer} is null\n * @since 4.1\n */\npublic static <E> String toString(final Iterator<E> iterator, final Transformer<? super E, String> transformer) {\n    return toString(iterator, transformer, DEFAULT_TOSTRING_DELIMITER, DEFAULT_TOSTRING_PREFIX, DEFAULT_TOSTRING_SUFFIX);\n}"
            ],
            [
                "toString",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Returns a string representation of the elements of the specified iterator.\n * <p>\n * The string representation consists of a list of the iterator's elements,\n * enclosed by the provided {@code prefix} and {@code suffix}. Adjacent elements\n * are separated by the provided {@code delimiter}. Elements are converted to\n * strings as by using the provided {@code transformer}.\n *\n * @param <E> the element type\n * @param iterator  the iterator to convert to a string, may be null\n * @param transformer  the transformer used to get a string representation of an element\n * @param delimiter  the string to delimit elements\n * @param prefix  the prefix, prepended to the string representation\n * @param suffix  the suffix, appended to the string representation\n * @return a string representation of {@code iterator}\n * @throws NullPointerException if either transformer, delimiter, prefix or suffix is null\n * @since 4.1\n */\npublic static <E> String toString(final Iterator<E> iterator, final Transformer<? super E, String> transformer, final String delimiter, final String prefix, final String suffix) {\n    if (transformer == null) {\n        throw new NullPointerException(\"transformer may not be null\");\n    }\n    if (delimiter == null) {\n        throw new NullPointerException(\"delimiter may not be null\");\n    }\n    if (prefix == null) {\n        throw new NullPointerException(\"prefix may not be null\");\n    }\n    if (suffix == null) {\n        throw new NullPointerException(\"suffix may not be null\");\n    }\n    final StringBuilder stringBuilder = new StringBuilder(prefix);\n    if (iterator != null) {\n        while (iterator.hasNext()) {\n            final E element = iterator.next();\n            stringBuilder.append(transformer.transform(element));\n            stringBuilder.append(delimiter);\n        }\n        if (stringBuilder.length() > prefix.length()) {\n            stringBuilder.setLength(stringBuilder.length() - delimiter.length());\n        }\n    }\n    stringBuilder.append(suffix);\n    return stringBuilder.toString();\n}"
            ],
            [
                "naturalComparator",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Gets a comparator that uses the natural order of the objects.\n *\n * @param <E>  the object type to compare\n * @return  a comparator which uses natural order\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E extends Comparable<? super E>> Comparator<E> naturalComparator() {\n    return NATURAL_COMPARATOR;\n}"
            ],
            [
                "chainedComparator",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Gets a comparator that compares using an array of {@link Comparator}s, applied\n * in sequence until one returns not equal or the array is exhausted.\n *\n * @param <E>  the object type to compare\n * @param comparators  the comparators to use, not null or empty or containing nulls\n * @return a {@link ComparatorChain} formed from the input comparators\n * @throws NullPointerException if comparators array is null or contains a null\n * @see ComparatorChain\n */\npublic static <E> Comparator<E> chainedComparator(final Comparator<E>... comparators) {\n    final ComparatorChain<E> chain = new ComparatorChain<E>();\n    for (final Comparator<E> comparator : comparators) {\n        if (comparator == null) {\n            throw new NullPointerException(\"Comparator cannot be null\");\n        }\n        chain.addComparator(comparator);\n    }\n    return chain;\n}"
            ],
            [
                "chainedComparator",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Gets a comparator that compares using a collection of {@link Comparator}s,\n * applied in (default iterator) sequence until one returns not equal or the\n * collection is exhausted.\n *\n * @param <E>  the object type to compare\n * @param comparators  the comparators to use, not null or empty or containing nulls\n * @return a {@link ComparatorChain} formed from the input comparators\n * @throws NullPointerException if comparators collection is null or contains a null\n * @throws ClassCastException if the comparators collection contains the wrong object type\n * @see ComparatorChain\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Comparator<E> chainedComparator(final Collection<Comparator<E>> comparators) {\n    return chainedComparator((Comparator<E>[]) comparators.toArray(new Comparator[comparators.size()]));\n}"
            ],
            [
                "reversedComparator",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Gets a comparator that reverses the order of the given comparator.\n *\n * @param <E>  the object type to compare\n * @param comparator  the comparator to reverse\n * @return  a comparator that reverses the order of the input comparator\n * @see ReverseComparator\n */\npublic static <E> Comparator<E> reversedComparator(final Comparator<E> comparator) {\n    return new ReverseComparator<E>(comparator);\n}"
            ],
            [
                "booleanComparator",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Gets a Comparator that can sort Boolean objects.\n * <p>\n * The parameter specifies whether true or false is sorted first.\n * <p>\n * The comparator throws NullPointerException if a null value is compared.\n *\n * @param trueFirst  when <code>true</code>, sort\n *        <code>true</code> {@link Boolean}s before\n *        <code>false</code> {@link Boolean}s.\n * @return  a comparator that sorts booleans\n */\npublic static Comparator<Boolean> booleanComparator(final boolean trueFirst) {\n    return BooleanComparator.booleanComparator(trueFirst);\n}"
            ],
            [
                "nullLowComparator",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Gets a Comparator that controls the comparison of <code>null</code> values.\n * <p>\n * The returned comparator will consider a null value to be less than\n * any nonnull value, and equal to any other null value.  Two nonnull\n * values will be evaluated with the given comparator.\n *\n * @param <E>  the object type to compare\n * @param comparator the comparator that wants to allow nulls\n * @return  a version of that comparator that allows nulls\n * @see NullComparator\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Comparator<E> nullLowComparator(Comparator<E> comparator) {\n    if (comparator == null) {\n        comparator = NATURAL_COMPARATOR;\n    }\n    return new NullComparator<E>(comparator, false);\n}"
            ],
            [
                "nullHighComparator",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Gets a Comparator that controls the comparison of <code>null</code> values.\n * <p>\n * The returned comparator will consider a null value to be greater than\n * any nonnull value, and equal to any other null value.  Two nonnull\n * values will be evaluated with the given comparator.\n *\n * @param <E>  the object type to compare\n * @param comparator the comparator that wants to allow nulls\n * @return  a version of that comparator that allows nulls\n * @see NullComparator\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Comparator<E> nullHighComparator(Comparator<E> comparator) {\n    if (comparator == null) {\n        comparator = NATURAL_COMPARATOR;\n    }\n    return new NullComparator<E>(comparator, true);\n}"
            ],
            [
                "transformedComparator",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Gets a Comparator that passes transformed objects to the given comparator.\n * <p>\n * Objects passed to the returned comparator will first be transformed\n * by the given transformer before they are compared by the given\n * comparator.\n *\n * @param <I>  the input object type of the transformed comparator\n * @param <O>  the object type of the decorated comparator\n * @param comparator  the sort order to use\n * @param transformer  the transformer to use\n * @return  a comparator that transforms its input objects before comparing them\n * @see  TransformingComparator\n */\n@SuppressWarnings(\"unchecked\")\npublic static <I, O> Comparator<I> transformedComparator(Comparator<O> comparator, final Transformer<? super I, ? extends O> transformer) {\n    if (comparator == null) {\n        comparator = NATURAL_COMPARATOR;\n    }\n    return new TransformingComparator<I, O>(transformer, comparator);\n}"
            ],
            [
                "min",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Returns the smaller of the given objects according to the given\n * comparator, returning the second object if the comparator\n * returns equal.\n *\n * @param <E>  the object type to compare\n * @param o1  the first object to compare\n * @param o2  the second object to compare\n * @param comparator  the sort order to use\n * @return  the smaller of the two objects\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> E min(final E o1, final E o2, Comparator<E> comparator) {\n    if (comparator == null) {\n        comparator = NATURAL_COMPARATOR;\n    }\n    final int c = comparator.compare(o1, o2);\n    return c < 0 ? o1 : o2;\n}"
            ],
            [
                "max",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Returns the larger of the given objects according to the given\n * comparator, returning the second object if the comparator\n * returns equal.\n *\n * @param <E>  the object type to compare\n * @param o1  the first object to compare\n * @param o2  the second object to compare\n * @param comparator  the sort order to use\n * @return  the larger of the two objects\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> E max(final E o1, final E o2, Comparator<E> comparator) {\n    if (comparator == null) {\n        comparator = NATURAL_COMPARATOR;\n    }\n    final int c = comparator.compare(o1, o2);\n    return c > 0 ? o1 : o2;\n}"
            ],
            [
                "unmodifiableBidiMap",
                "org.apache.commons.collections4.bidimap",
                "UnmodifiableBidiMap",
                "/**\n * Factory method to create an unmodifiable map.\n * <p>\n * If the map passed in is already unmodifiable, it is returned.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the map to decorate, must not be null\n * @return an unmodifiable BidiMap\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> BidiMap<K, V> unmodifiableBidiMap(final BidiMap<? extends K, ? extends V> map) {\n    if (map instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final BidiMap<K, V> tmpMap = (BidiMap<K, V>) map;\n        return tmpMap;\n    }\n    return new UnmodifiableBidiMap<K, V>(map);\n}"
            ],
            [
                "unmodifiableOrderedBidiMap",
                "org.apache.commons.collections4.bidimap",
                "UnmodifiableOrderedBidiMap",
                "/**\n * Factory method to create an unmodifiable map.\n * <p>\n * If the map passed in is already unmodifiable, it is returned.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the map to decorate, must not be null\n * @return an unmodifiable OrderedBidiMap\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> OrderedBidiMap<K, V> unmodifiableOrderedBidiMap(final OrderedBidiMap<? extends K, ? extends V> map) {\n    if (map instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final OrderedBidiMap<K, V> tmpMap = (OrderedBidiMap<K, V>) map;\n        return tmpMap;\n    }\n    return new UnmodifiableOrderedBidiMap<K, V>(map);\n}"
            ],
            [
                "unmodifiableSortedBidiMap",
                "org.apache.commons.collections4.bidimap",
                "UnmodifiableSortedBidiMap",
                "/**\n * Factory method to create an unmodifiable map.\n * <p>\n * If the map passed in is already unmodifiable, it is returned.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the map to decorate, must not be null\n * @return an unmodifiable SortedBidiMap\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> SortedBidiMap<K, V> unmodifiableSortedBidiMap(final SortedBidiMap<K, ? extends V> map) {\n    if (map instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final SortedBidiMap<K, V> tmpMap = (SortedBidiMap<K, V>) map;\n        return tmpMap;\n    }\n    return new UnmodifiableSortedBidiMap<K, V>(map);\n}"
            ],
            [
                "emptyMultiValuedMap",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "/**\n * Returns immutable EMPTY_MULTI_VALUED_MAP with generic type safety.\n *\n * @param <K> the type of key in the map\n * @param <V> the type of value in the map\n * @return immutable and empty <code>MultiValuedMap</code>\n */\n@SuppressWarnings(\"unchecked\")\npublic static <K, V> MultiValuedMap<K, V> emptyMultiValuedMap() {\n    return EMPTY_MULTI_VALUED_MAP;\n}"
            ],
            [
                "emptyIfNull",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "// Null safe methods\n/**\n * Returns an immutable empty <code>MultiValuedMap</code> if the argument is\n * <code>null</code>, or the argument itself otherwise.\n *\n * @param <K> the type of key in the map\n * @param <V> the type of value in the map\n * @param map  the map, may be null\n * @return an empty {@link MultiValuedMap} if the argument is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <K, V> MultiValuedMap<K, V> emptyIfNull(final MultiValuedMap<K, V> map) {\n    return map == null ? EMPTY_MULTI_VALUED_MAP : map;\n}"
            ],
            [
                "isEmpty",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "/**\n * Null-safe check if the specified <code>MultiValuedMap</code> is empty.\n * <p>\n * If the provided map is null, returns true.\n *\n * @param map  the map to check, may be null\n * @return true if the map is empty or null\n */\npublic static boolean isEmpty(final MultiValuedMap<?, ?> map) {\n    return map == null || map.isEmpty();\n}"
            ],
            [
                "getCollection",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "// Null safe getters\n// -------------------------------------------------------------------------\n/**\n * Gets a Collection from <code>MultiValuedMap</code> in a null-safe manner.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the {@link MultiValuedMap} to use\n * @param key  the key to look up\n * @return the Collection in the {@link MultiValuedMap}, or null if input map is null\n */\npublic static <K, V> Collection<V> getCollection(final MultiValuedMap<K, V> map, final K key) {\n    if (map != null) {\n        return map.get(key);\n    }\n    return null;\n}"
            ],
            [
                "getValuesAsList",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "// TODO: review the getValuesAsXXX methods - depending on the actual MultiValuedMap type, changes\n// to the returned collection might update the backing map. This should be clarified and/or prevented.\n/**\n * Gets a List from <code>MultiValuedMap</code> in a null-safe manner.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the {@link MultiValuedMap} to use\n * @param key  the key to look up\n * @return the Collection in the {@link MultiValuedMap} as List, or null if input map is null\n */\npublic static <K, V> List<V> getValuesAsList(final MultiValuedMap<K, V> map, final K key) {\n    if (map != null) {\n        Collection<V> col = map.get(key);\n        if (col instanceof List) {\n            return (List<V>) col;\n        }\n        return new ArrayList<V>(col);\n    }\n    return null;\n}"
            ],
            [
                "getValuesAsSet",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "/**\n * Gets a Set from <code>MultiValuedMap</code> in a null-safe manner.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the {@link MultiValuedMap} to use\n * @param key  the key to look up\n * @return the Collection in the {@link MultiValuedMap} as Set, or null if input map is null\n */\npublic static <K, V> Set<V> getValuesAsSet(final MultiValuedMap<K, V> map, final K key) {\n    if (map != null) {\n        Collection<V> col = map.get(key);\n        if (col instanceof Set) {\n            return (Set<V>) col;\n        }\n        return new HashSet<V>(col);\n    }\n    return null;\n}"
            ],
            [
                "getValuesAsBag",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "/**\n * Gets a Bag from <code>MultiValuedMap</code> in a null-safe manner.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the {@link MultiValuedMap} to use\n * @param key  the key to look up\n * @return the Collection in the {@link MultiValuedMap} as Bag, or null if input map is null\n */\npublic static <K, V> Bag<V> getValuesAsBag(final MultiValuedMap<K, V> map, final K key) {\n    if (map != null) {\n        Collection<V> col = map.get(key);\n        if (col instanceof Bag) {\n            return (Bag<V>) col;\n        }\n        return new HashBag<V>(col);\n    }\n    return null;\n}"
            ],
            [
                "newListValuedHashMap",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "// Factory Methods\n// -----------------------------------------------------------------------\n/**\n * Creates a {@link ListValuedMap} with an {@link java.util.ArrayList ArrayList} as\n * collection class to store the values mapped to a key.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @return a new <code>ListValuedMap</code>\n */\npublic static <K, V> ListValuedMap<K, V> newListValuedHashMap() {\n    return new ArrayListValuedHashMap<K, V>();\n}"
            ],
            [
                "newSetValuedHashMap",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "/**\n * Creates a {@link SetValuedMap} with an {@link java.util.HashSet HashSet} as\n * collection class to store the values mapped to a key.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @return a new {@link SetValuedMap}\n */\npublic static <K, V> SetValuedMap<K, V> newSetValuedHashMap() {\n    return new HashSetValuedHashMap<K, V>();\n}"
            ],
            [
                "unmodifiableMultiValuedMap",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "// MultiValuedMap Decorators\n// -----------------------------------------------------------------------\n/**\n * Returns an <code>UnmodifiableMultiValuedMap</code> backed by the given\n * map.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the {@link MultiValuedMap} to decorate, must not be null\n * @return an unmodifiable {@link MultiValuedMap} backed by the provided map\n * @throws NullPointerException if map is null\n */\npublic static <K, V> MultiValuedMap<K, V> unmodifiableMultiValuedMap(final MultiValuedMap<? extends K, ? extends V> map) {\n    return UnmodifiableMultiValuedMap.<K, V>unmodifiableMultiValuedMap(map);\n}"
            ],
            [
                "transformedMultiValuedMap",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "/**\n * Returns a <code>TransformedMultiValuedMap</code> backed by the given map.\n * <p>\n * This method returns a new <code>MultiValuedMap</code> (decorating the\n * specified map) that will transform any new entries added to it. Existing\n * entries in the specified map will not be transformed. If you want that\n * behaviour, see {@link TransformedMultiValuedMap#transformedMap}.\n * <p>\n * Each object is passed through the transformers as it is added to the Map.\n * It is important not to use the original map after invoking this method,\n * as it is a back door for adding untransformed objects.\n * <p>\n * If there are any elements already in the map being decorated, they are\n * NOT transformed.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the {@link MultiValuedMap} to transform, must not be null, typically empty\n * @param keyTransformer  the transformer for the map keys, null means no transformation\n * @param valueTransformer  the transformer for the map values, null means no transformation\n * @return a transformed <code>MultiValuedMap</code> backed by the given map\n * @throws NullPointerException if map is null\n */\npublic static <K, V> MultiValuedMap<K, V> transformedMultiValuedMap(final MultiValuedMap<K, V> map, final Transformer<? super K, ? extends K> keyTransformer, final Transformer<? super V, ? extends V> valueTransformer) {\n    return TransformedMultiValuedMap.transformingMap(map, keyTransformer, valueTransformer);\n}"
            ],
            [
                "unmodifiableBoundedCollection",
                "org.apache.commons.collections4.collection",
                "UnmodifiableBoundedCollection",
                "/**\n * Factory method to create an unmodifiable bounded collection.\n *\n * @param <E> the type of the elements in the collection\n * @param coll  the <code>BoundedCollection</code> to decorate, must not be null\n * @return a new unmodifiable bounded collection\n * @throws NullPointerException if {@code coll} is {@code null}\n * @since 4.0\n */\npublic static <E> BoundedCollection<E> unmodifiableBoundedCollection(final BoundedCollection<? extends E> coll) {\n    if (coll instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final BoundedCollection<E> tmpColl = (BoundedCollection<E>) coll;\n        return tmpColl;\n    }\n    return new UnmodifiableBoundedCollection<E>(coll);\n}"
            ],
            [
                "unmodifiableBoundedCollection",
                "org.apache.commons.collections4.collection",
                "UnmodifiableBoundedCollection",
                "/**\n * Factory method to create an unmodifiable bounded collection.\n * <p>\n * This method is capable of drilling down through up to 1000 other decorators\n * to find a suitable BoundedCollection.\n *\n * @param <E> the type of the elements in the collection\n * @param coll  the <code>BoundedCollection</code> to decorate, must not be null\n * @return a new unmodifiable bounded collection\n * @throws NullPointerException if coll is null\n * @throws IllegalArgumentException if coll is not a {@code BoundedCollection}\n * @since 4.0\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> BoundedCollection<E> unmodifiableBoundedCollection(Collection<? extends E> coll) {\n    if (coll == null) {\n        throw new NullPointerException(\"Collection must not be null.\");\n    }\n    // handle decorators\n    for (int i = 0; i < 1000; i++) {\n        // counter to prevent infinite looping\n        if (coll instanceof BoundedCollection) {\n            // normal loop exit\n            break;\n        }\n        if (coll instanceof AbstractCollectionDecorator) {\n            coll = ((AbstractCollectionDecorator<E>) coll).decorated();\n        } else if (coll instanceof SynchronizedCollection) {\n            coll = ((SynchronizedCollection<E>) coll).decorated();\n        }\n    }\n    if (coll instanceof BoundedCollection == false) {\n        throw new IllegalArgumentException(\"Collection is not a bounded collection.\");\n    }\n    return new UnmodifiableBoundedCollection<E>((BoundedCollection<E>) coll);\n}"
            ],
            [
                "transformingCollection",
                "org.apache.commons.collections4.collection",
                "TransformedCollection",
                "/**\n * Factory method to create a transforming collection.\n * <p>\n * If there are any elements already in the collection being decorated, they\n * are NOT transformed.\n * Contrast this with {@link #transformedCollection(Collection, Transformer)}.\n *\n * @param <E> the type of the elements in the collection\n * @param coll  the collection to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed collection\n * @throws NullPointerException if collection or transformer is null\n * @since 4.0\n */\npublic static <E> TransformedCollection<E> transformingCollection(final Collection<E> coll, final Transformer<? super E, ? extends E> transformer) {\n    return new TransformedCollection<E>(coll, transformer);\n}"
            ],
            [
                "transformedCollection",
                "org.apache.commons.collections4.collection",
                "TransformedCollection",
                "/**\n * Factory method to create a transforming collection that will transform\n * existing contents of the specified collection.\n * <p>\n * If there are any elements already in the collection being decorated, they\n * will be transformed by this method.\n * Contrast this with {@link #transformingCollection(Collection, Transformer)}.\n *\n * @param <E> the type of the elements in the collection\n * @param collection  the collection to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed Collection\n * @throws NullPointerException if collection or transformer is null\n * @since 4.0\n */\npublic static <E> TransformedCollection<E> transformedCollection(final Collection<E> collection, final Transformer<? super E, ? extends E> transformer) {\n    final TransformedCollection<E> decorated = new TransformedCollection<E>(collection, transformer);\n    // null collection & transformer are disallowed by the constructor call above\n    if (collection.size() > 0) {\n        // collection is of type E\n        @SuppressWarnings(\"unchecked\")\n        final E[] // NOPMD - false positive for generics\n        values = (E[]) collection.toArray();\n        collection.clear();\n        for (final E value : values) {\n            decorated.decorated().add(transformer.transform(value));\n        }\n    }\n    return decorated;\n}"
            ],
            [
                "builder",
                "org.apache.commons.collections4.collection",
                "PredicatedCollection",
                "/**\n * Returns a Builder with the given predicate.\n *\n * @param <E>  the element type\n * @param predicate  the predicate to use\n * @return a new Builder for predicated collections\n * @since 4.1\n */\npublic static <E> Builder<E> builder(final Predicate<? super E> predicate) {\n    return new Builder<E>(predicate);\n}"
            ],
            [
                "notNullBuilder",
                "org.apache.commons.collections4.collection",
                "PredicatedCollection",
                "/**\n * Returns a Builder with a NotNullPredicate.\n *\n * @param <E>  the element type\n * @return a new Builder for predicated collections that ignores null values.\n * @since 4.1\n */\npublic static <E> Builder<E> notNullBuilder() {\n    return new Builder<E>(NotNullPredicate.<E>notNullPredicate());\n}"
            ],
            [
                "predicatedCollection",
                "org.apache.commons.collections4.collection",
                "PredicatedCollection",
                "/**\n * Factory method to create a predicated (validating) collection.\n * <p>\n * If there are any elements already in the collection being decorated, they\n * are validated.\n *\n * @param <T> the type of the elements in the collection\n * @param coll  the collection to decorate, must not be null\n * @param predicate  the predicate to use for validation, must not be null\n * @return a new predicated collection\n * @throws NullPointerException if collection or predicate is null\n * @throws IllegalArgumentException if the collection contains invalid elements\n * @since 4.0\n */\npublic static <T> PredicatedCollection<T> predicatedCollection(final Collection<T> coll, final Predicate<? super T> predicate) {\n    return new PredicatedCollection<T>(coll, predicate);\n}"
            ],
            [
                "uniqueIndexedCollection",
                "org.apache.commons.collections4.collection",
                "IndexedCollection",
                "/**\n * Create an {@link IndexedCollection} for a unique index.\n * <p>\n * If an element is added, which maps to an existing key, an {@link IllegalArgumentException}\n * will be thrown.\n *\n * @param <K> the index object type.\n * @param <C> the collection type.\n * @param coll the decorated {@link Collection}.\n * @param keyTransformer the {@link Transformer} for generating index keys.\n * @return the created {@link IndexedCollection}.\n */\npublic static <K, C> IndexedCollection<K, C> uniqueIndexedCollection(final Collection<C> coll, final Transformer<C, K> keyTransformer) {\n    return new IndexedCollection<K, C>(coll, keyTransformer, MultiValueMap.<K, C>multiValueMap(new HashMap<K, Collection<C>>()), true);\n}"
            ],
            [
                "nonUniqueIndexedCollection",
                "org.apache.commons.collections4.collection",
                "IndexedCollection",
                "/**\n * Create an {@link IndexedCollection} for a non-unique index.\n *\n * @param <K> the index object type.\n * @param <C> the collection type.\n * @param coll the decorated {@link Collection}.\n * @param keyTransformer the {@link Transformer} for generating index keys.\n * @return the created {@link IndexedCollection}.\n */\npublic static <K, C> IndexedCollection<K, C> nonUniqueIndexedCollection(final Collection<C> coll, final Transformer<C, K> keyTransformer) {\n    return new IndexedCollection<K, C>(coll, keyTransformer, MultiValueMap.<K, C>multiValueMap(new HashMap<K, Collection<C>>()), false);\n}"
            ],
            [
                "synchronizedCollection",
                "org.apache.commons.collections4.collection",
                "SynchronizedCollection",
                "/**\n * Factory method to create a synchronized collection.\n *\n * @param <T> the type of the elements in the collection\n * @param coll  the collection to decorate, must not be null\n * @return a new synchronized collection\n * @throws NullPointerException if collection is null\n * @since 4.0\n */\npublic static <T> SynchronizedCollection<T> synchronizedCollection(final Collection<T> coll) {\n    return new SynchronizedCollection<T>(coll);\n}"
            ],
            [
                "unmodifiableCollection",
                "org.apache.commons.collections4.collection",
                "UnmodifiableCollection",
                "/**\n * Factory method to create an unmodifiable collection.\n * <p>\n * If the collection passed in is already unmodifiable, it is returned.\n *\n * @param <T> the type of the elements in the collection\n * @param coll  the collection to decorate, must not be null\n * @return an unmodifiable collection\n * @throws NullPointerException if collection is null\n * @since 4.0\n */\npublic static <T> Collection<T> unmodifiableCollection(final Collection<? extends T> coll) {\n    if (coll instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final Collection<T> tmpColl = (Collection<T>) coll;\n        return tmpColl;\n    }\n    return new UnmodifiableCollection<T>(coll);\n}"
            ],
            [
                "exceptionFactory",
                "org.apache.commons.collections4",
                "FactoryUtils",
                "/**\n * Gets a Factory that always throws an exception.\n * This could be useful during testing as a placeholder.\n *\n * @see org.apache.commons.collections4.functors.ExceptionFactory\n *\n * @param <T> the type that the factory creates\n * @return the factory\n */\npublic static <T> Factory<T> exceptionFactory() {\n    return ExceptionFactory.<T>exceptionFactory();\n}"
            ],
            [
                "nullFactory",
                "org.apache.commons.collections4",
                "FactoryUtils",
                "/**\n * Gets a Factory that will return null each time the factory is used.\n * This could be useful during testing as a placeholder.\n *\n * @see org.apache.commons.collections4.functors.ConstantFactory\n * @param <T> the \"type\" of null object the factory should return.\n * @return the factory\n */\npublic static <T> Factory<T> nullFactory() {\n    return ConstantFactory.<T>constantFactory(null);\n}"
            ],
            [
                "constantFactory",
                "org.apache.commons.collections4",
                "FactoryUtils",
                "/**\n * Creates a Factory that will return the same object each time the factory\n * is used. No check is made that the object is immutable. In general, only\n * immutable objects should use the constant factory. Mutable objects should\n * use the prototype factory.\n *\n * @see org.apache.commons.collections4.functors.ConstantFactory\n *\n * @param <T> the type that the factory creates\n * @param constantToReturn  the constant object to return each time in the factory\n * @return the <code>constant</code> factory.\n */\npublic static <T> Factory<T> constantFactory(final T constantToReturn) {\n    return ConstantFactory.constantFactory(constantToReturn);\n}"
            ],
            [
                "prototypeFactory",
                "org.apache.commons.collections4",
                "FactoryUtils",
                "/**\n * Creates a Factory that will return a clone of the same prototype object\n * each time the factory is used. The prototype will be cloned using one of these\n * techniques (in order):\n * <ul>\n * <li>public clone method\n * <li>public copy constructor\n * <li>serialization clone\n * <ul>\n *\n * @see org.apache.commons.collections4.functors.PrototypeFactory\n *\n * @param <T> the type that the factory creates\n * @param prototype  the object to clone each time in the factory\n * @return the <code>prototype</code> factory, or a {@link ConstantFactory#NULL_INSTANCE} if\n * the {@code prototype} is {@code null}\n * @throws IllegalArgumentException if the prototype cannot be cloned\n */\npublic static <T> Factory<T> prototypeFactory(final T prototype) {\n    return PrototypeFactory.<T>prototypeFactory(prototype);\n}"
            ],
            [
                "instantiateFactory",
                "org.apache.commons.collections4",
                "FactoryUtils",
                "/**\n * Creates a Factory that can create objects of a specific type using\n * a no-args constructor.\n *\n * @see org.apache.commons.collections4.functors.InstantiateFactory\n *\n * @param <T> the type that the factory creates\n * @param classToInstantiate  the Class to instantiate each time in the factory\n * @return the <code>reflection</code> factory\n * @throws NullPointerException if the classToInstantiate is null\n */\npublic static <T> Factory<T> instantiateFactory(final Class<T> classToInstantiate) {\n    return InstantiateFactory.instantiateFactory(classToInstantiate, null, null);\n}"
            ],
            [
                "instantiateFactory",
                "org.apache.commons.collections4",
                "FactoryUtils",
                "/**\n * Creates a Factory that can create objects of a specific type using\n * the arguments specified to this method.\n *\n * @see org.apache.commons.collections4.functors.InstantiateFactory\n *\n * @param <T> the type that the factory creates\n * @param classToInstantiate  the Class to instantiate each time in the factory\n * @param paramTypes  parameter types for the constructor, can be null\n * @param args  the arguments to pass to the constructor, can be null\n * @return the <code>reflection</code> factory\n * @throws NullPointerException if the classToInstantiate is null\n * @throws IllegalArgumentException if the paramTypes and args don't match\n * @throws IllegalArgumentException if the constructor doesn't exist\n */\npublic static <T> Factory<T> instantiateFactory(final Class<T> classToInstantiate, final Class<?>[] paramTypes, final Object[] args) {\n    return InstantiateFactory.instantiateFactory(classToInstantiate, paramTypes, args);\n}"
            ],
            [
                "emptyIfNull",
                "org.apache.commons.collections4",
                "ListUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns an immutable empty list if the argument is <code>null</code>,\n * or the argument itself otherwise.\n *\n * @param <T> the element type\n * @param list the list, possibly <code>null</code>\n * @return an empty list if the argument is <code>null</code>\n */\npublic static <T> List<T> emptyIfNull(final List<T> list) {\n    return list == null ? Collections.<T>emptyList() : list;\n}"
            ],
            [
                "defaultIfNull",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns either the passed in list, or if the list is {@code null},\n * the value of {@code defaultList}.\n *\n * @param <T> the element type\n * @param list  the list, possibly {@code null}\n * @param defaultList  the returned values if list is {@code null}\n * @return an empty list if the argument is <code>null</code>\n * @since 4.0\n */\npublic static <T> List<T> defaultIfNull(final List<T> list, final List<T> defaultList) {\n    return list == null ? defaultList : list;\n}"
            ],
            [
                "intersection",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns a new list containing all elements that are contained in\n * both given lists.\n *\n * @param <E> the element type\n * @param list1  the first list\n * @param list2  the second list\n * @return  the intersection of those two lists\n * @throws NullPointerException if either list is null\n */\npublic static <E> List<E> intersection(final List<? extends E> list1, final List<? extends E> list2) {\n    final List<E> result = new ArrayList<E>();\n    List<? extends E> smaller = list1;\n    List<? extends E> larger = list2;\n    if (list1.size() > list2.size()) {\n        smaller = list2;\n        larger = list1;\n    }\n    final HashSet<E> hashSet = new HashSet<E>(smaller);\n    for (final E e : larger) {\n        if (hashSet.contains(e)) {\n            result.add(e);\n            hashSet.remove(e);\n        }\n    }\n    return result;\n}"
            ],
            [
                "subtract",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Subtracts all elements in the second list from the first list,\n * placing the results in a new list.\n * <p>\n * This differs from {@link List#removeAll(Collection)} in that\n * cardinality is respected; if <Code>list1</Code> contains two\n * occurrences of <Code>null</Code> and <Code>list2</Code> only\n * contains one occurrence, then the returned list will still contain\n * one occurrence.\n *\n * @param <E> the element type\n * @param list1  the list to subtract from\n * @param list2  the list to subtract\n * @return a new list containing the results\n * @throws NullPointerException if either list is null\n */\npublic static <E> List<E> subtract(final List<E> list1, final List<? extends E> list2) {\n    final ArrayList<E> result = new ArrayList<E>();\n    final HashBag<E> bag = new HashBag<E>(list2);\n    for (final E e : list1) {\n        if (!bag.remove(e, 1)) {\n            result.add(e);\n        }\n    }\n    return result;\n}"
            ],
            [
                "sum",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns the sum of the given lists.  This is their intersection\n * subtracted from their union.\n *\n * @param <E> the element type\n * @param list1  the first list\n * @param list2  the second list\n * @return  a new list containing the sum of those lists\n * @throws NullPointerException if either list is null\n */\npublic static <E> List<E> sum(final List<? extends E> list1, final List<? extends E> list2) {\n    return subtract(union(list1, list2), intersection(list1, list2));\n}"
            ],
            [
                "union",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns a new list containing the second list appended to the\n * first list.  The {@link List#addAll(Collection)} operation is\n * used to append the two given lists into a new list.\n *\n * @param <E> the element type\n * @param list1  the first list\n * @param list2  the second list\n * @return a new list containing the union of those lists\n * @throws NullPointerException if either list is null\n */\npublic static <E> List<E> union(final List<? extends E> list1, final List<? extends E> list2) {\n    final ArrayList<E> result = new ArrayList<E>(list1);\n    result.addAll(list2);\n    return result;\n}"
            ],
            [
                "select",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Selects all elements from input collection which match the given\n * predicate into an output list.\n * <p>\n * A <code>null</code> predicate matches no elements.\n *\n * @param <E> the element type\n * @param inputCollection  the collection to get the input from, may not be null\n * @param predicate  the predicate to use, may be null\n * @return the elements matching the predicate (new list)\n * @throws NullPointerException if the input list is null\n *\n * @since 4.0\n * @see CollectionUtils#select(Iterable, Predicate)\n */\npublic static <E> List<E> select(final Collection<? extends E> inputCollection, final Predicate<? super E> predicate) {\n    return CollectionUtils.select(inputCollection, predicate, new ArrayList<E>(inputCollection.size()));\n}"
            ],
            [
                "selectRejected",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Selects all elements from inputCollection which don't match the given\n * predicate into an output collection.\n * <p>\n * If the input predicate is <code>null</code>, the result is an empty list.\n *\n * @param <E> the element type\n * @param inputCollection the collection to get the input from, may not be null\n * @param predicate the predicate to use, may be null\n * @return the elements <b>not</b> matching the predicate (new list)\n * @throws NullPointerException if the input collection is null\n *\n * @since 4.0\n * @see CollectionUtils#selectRejected(Iterable, Predicate)\n */\npublic static <E> List<E> selectRejected(final Collection<? extends E> inputCollection, final Predicate<? super E> predicate) {\n    return CollectionUtils.selectRejected(inputCollection, predicate, new ArrayList<E>(inputCollection.size()));\n}"
            ],
            [
                "isEqualList",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Tests two lists for value-equality as per the equality contract in\n * {@link java.util.List#equals(java.lang.Object)}.\n * <p>\n * This method is useful for implementing <code>List</code> when you cannot\n * extend AbstractList. The method takes Collection instances to enable other\n * collection types to use the List implementation algorithm.\n * <p>\n * The relevant text (slightly paraphrased as this is a static method) is:\n * <blockquote>\n * Compares the two list objects for equality.  Returns\n * {@code true} if and only if both\n * lists have the same size, and all corresponding pairs of elements in\n * the two lists are <i>equal</i>.  (Two elements {@code e1} and\n * {@code e2} are <i>equal</i> if <tt>(e1==null ? e2==null :\n * e1.equals(e2))</tt>.)  In other words, two lists are defined to be\n * equal if they contain the same elements in the same order.  This\n * definition ensures that the equals method works properly across\n * different implementations of the {@code List} interface.\n * </blockquote>\n *\n * <b>Note:</b> The behaviour of this method is undefined if the lists are\n * modified during the equals comparison.\n *\n * @see java.util.List\n * @param list1  the first list, may be null\n * @param list2  the second list, may be null\n * @return whether the lists are equal by value comparison\n */\npublic static boolean isEqualList(final Collection<?> list1, final Collection<?> list2) {\n    if (list1 == list2) {\n        return true;\n    }\n    if (list1 == null || list2 == null || list1.size() != list2.size()) {\n        return false;\n    }\n    final Iterator<?> it1 = list1.iterator();\n    final Iterator<?> it2 = list2.iterator();\n    Object obj1 = null;\n    Object obj2 = null;\n    while (it1.hasNext() && it2.hasNext()) {\n        obj1 = it1.next();\n        obj2 = it2.next();\n        if (!(obj1 == null ? obj2 == null : obj1.equals(obj2))) {\n            return false;\n        }\n    }\n    return !(it1.hasNext() || it2.hasNext());\n}"
            ],
            [
                "hashCodeForList",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Generates a hash code using the algorithm specified in\n * {@link java.util.List#hashCode()}.\n * <p>\n * This method is useful for implementing <code>List</code> when you cannot\n * extend AbstractList. The method takes Collection instances to enable other\n * collection types to use the List implementation algorithm.\n *\n * @see java.util.List#hashCode()\n * @param list  the list to generate the hashCode for, may be null\n * @return the hash code\n */\npublic static int hashCodeForList(final Collection<?> list) {\n    if (list == null) {\n        return 0;\n    }\n    int hashCode = 1;\n    final Iterator<?> it = list.iterator();\n    while (it.hasNext()) {\n        final Object obj = it.next();\n        hashCode = 31 * hashCode + (obj == null ? 0 : obj.hashCode());\n    }\n    return hashCode;\n}"
            ],
            [
                "retainAll",
                "org.apache.commons.collections4",
                "ListUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns a List containing all the elements in <code>collection</code>\n * that are also in <code>retain</code>. The cardinality of an element <code>e</code>\n * in the returned list is the same as the cardinality of <code>e</code>\n * in <code>collection</code> unless <code>retain</code> does not contain <code>e</code>, in which\n * case the cardinality is zero. This method is useful if you do not wish to modify\n * the collection <code>c</code> and thus cannot call <code>collection.retainAll(retain);</code>.\n * <p>\n * This implementation iterates over <code>collection</code>, checking each element in\n * turn to see if it's contained in <code>retain</code>. If it's contained, it's added\n * to the returned list. As a consequence, it is advised to use a collection type for\n * <code>retain</code> that provides a fast (e.g. O(1)) implementation of\n * {@link Collection#contains(Object)}.\n *\n * @param <E>  the element type\n * @param collection  the collection whose contents are the target of the #retailAll operation\n * @param retain  the collection containing the elements to be retained in the returned collection\n * @return a <code>List</code> containing all the elements of <code>c</code>\n * that occur at least once in <code>retain</code>.\n * @throws NullPointerException if either parameter is null\n * @since 3.2\n */\npublic static <E> List<E> retainAll(final Collection<E> collection, final Collection<?> retain) {\n    final List<E> list = new ArrayList<E>(Math.min(collection.size(), retain.size()));\n    for (final E obj : collection) {\n        if (retain.contains(obj)) {\n            list.add(obj);\n        }\n    }\n    return list;\n}"
            ],
            [
                "removeAll",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Removes the elements in <code>remove</code> from <code>collection</code>. That is, this\n * method returns a list containing all the elements in <code>collection</code>\n * that are not in <code>remove</code>. The cardinality of an element <code>e</code>\n * in the returned collection is the same as the cardinality of <code>e</code>\n * in <code>collection</code> unless <code>remove</code> contains <code>e</code>, in which\n * case the cardinality is zero. This method is useful if you do not wish to modify\n * <code>collection</code> and thus cannot call <code>collection.removeAll(remove);</code>.\n * <p>\n * This implementation iterates over <code>collection</code>, checking each element in\n * turn to see if it's contained in <code>remove</code>. If it's not contained, it's added\n * to the returned list. As a consequence, it is advised to use a collection type for\n * <code>remove</code> that provides a fast (e.g. O(1)) implementation of\n * {@link Collection#contains(Object)}.\n *\n * @param <E>  the element type\n * @param collection  the collection from which items are removed (in the returned collection)\n * @param remove  the items to be removed from the returned <code>collection</code>\n * @return a <code>List</code> containing all the elements of <code>c</code> except\n * any elements that also occur in <code>remove</code>.\n * @throws NullPointerException if either parameter is null\n * @since 3.2\n */\npublic static <E> List<E> removeAll(final Collection<E> collection, final Collection<?> remove) {\n    final List<E> list = new ArrayList<E>();\n    for (final E obj : collection) {\n        if (!remove.contains(obj)) {\n            list.add(obj);\n        }\n    }\n    return list;\n}"
            ],
            [
                "synchronizedList",
                "org.apache.commons.collections4",
                "ListUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns a synchronized list backed by the given list.\n * <p>\n * You must manually synchronize on the returned list's iterator to\n * avoid non-deterministic behavior:\n *\n * <pre>\n * List list = ListUtils.synchronizedList(myList);\n * synchronized (list) {\n *     Iterator i = list.iterator();\n *     while (i.hasNext()) {\n *         process (i.next());\n *     }\n * }\n * </pre>\n *\n * This method is just a wrapper for {@link Collections#synchronizedList(List)}.\n *\n * @param <E> the element type\n * @param list  the list to synchronize, must not be null\n * @return a synchronized list backed by the given list\n * @throws NullPointerException if the list is null\n */\npublic static <E> List<E> synchronizedList(final List<E> list) {\n    return Collections.synchronizedList(list);\n}"
            ],
            [
                "unmodifiableList",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns an unmodifiable list backed by the given list.\n * <p>\n * This method uses the implementation in the decorators subpackage.\n *\n * @param <E>  the element type\n * @param list  the list to make unmodifiable, must not be null\n * @return an unmodifiable list backed by the given list\n * @throws NullPointerException if the list is null\n */\npublic static <E> List<E> unmodifiableList(final List<? extends E> list) {\n    return UnmodifiableList.unmodifiableList(list);\n}"
            ],
            [
                "predicatedList",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns a predicated (validating) list backed by the given list.\n * <p>\n * Only objects that pass the test in the given predicate can be added to the list.\n * Trying to add an invalid object results in an IllegalArgumentException.\n * It is important not to use the original list after invoking this method,\n * as it is a backdoor for adding invalid objects.\n *\n * @param <E> the element type\n * @param list  the list to predicate, must not be null\n * @param predicate  the predicate for the list, must not be null\n * @return a predicated list backed by the given list\n * @throws NullPointerException if the List or Predicate is null\n */\npublic static <E> List<E> predicatedList(final List<E> list, final Predicate<E> predicate) {\n    return PredicatedList.predicatedList(list, predicate);\n}"
            ],
            [
                "transformedList",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns a transformed list backed by the given list.\n * <p>\n * This method returns a new list (decorating the specified list) that\n * will transform any new entries added to it.\n * Existing entries in the specified list will not be transformed.\n * <p>\n * Each object is passed through the transformer as it is added to the\n * List. It is important not to use the original list after invoking this\n * method, as it is a backdoor for adding untransformed objects.\n * <p>\n * Existing entries in the specified list will not be transformed.\n * If you want that behaviour, see {@link TransformedList#transformedList}.\n *\n * @param <E> the element type\n * @param list  the list to predicate, must not be null\n * @param transformer  the transformer for the list, must not be null\n * @return a transformed list backed by the given list\n * @throws NullPointerException if the List or Transformer is null\n */\npublic static <E> List<E> transformedList(final List<E> list, final Transformer<? super E, ? extends E> transformer) {\n    return TransformedList.transformingList(list, transformer);\n}"
            ],
            [
                "lazyList",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns a \"lazy\" list whose elements will be created on demand.\n * <p>\n * When the index passed to the returned list's {@link List#get(int) get}\n * method is greater than the list's size, then the factory will be used\n * to create a new object and that object will be inserted at that index.\n * <p>\n * For instance:\n *\n * <pre>\n * Factory&lt;Date&gt; factory = new Factory&lt;Date&gt;() {\n *     public Date create() {\n *         return new Date();\n *     }\n * }\n * List&lt;Date&gt; lazy = ListUtils.lazyList(new ArrayList&lt;Date&gt;(), factory);\n * Date date = lazy.get(3);\n * </pre>\n *\n * After the above code is executed, <code>date</code> will refer to\n * a new <code>Date</code> instance.  Furthermore, that <code>Date</code>\n * instance is the fourth element in the list.  The first, second,\n * and third element are all set to <code>null</code>.\n *\n * @param <E> the element type\n * @param list  the list to make lazy, must not be null\n * @param factory  the factory for creating new objects, must not be null\n * @return a lazy list backed by the given list\n * @throws NullPointerException if the List or Factory is null\n */\npublic static <E> List<E> lazyList(final List<E> list, final Factory<? extends E> factory) {\n    return LazyList.lazyList(list, factory);\n}"
            ],
            [
                "fixedSizeList",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns a fixed-sized list backed by the given list.\n * Elements may not be added or removed from the returned list, but\n * existing elements can be changed (for instance, via the\n * {@link List#set(int, Object)} method).\n *\n * @param <E>  the element type\n * @param list  the list whose size to fix, must not be null\n * @return a fixed-size list backed by that list\n * @throws NullPointerException  if the List is null\n */\npublic static <E> List<E> fixedSizeList(final List<E> list) {\n    return FixedSizeList.fixedSizeList(list);\n}"
            ],
            [
                "indexOf",
                "org.apache.commons.collections4",
                "ListUtils",
                "//-----------------------------------------------------------------------\n/**\n * Finds the first index in the given List which matches the given predicate.\n * <p>\n * If the input List or predicate is null, or no element of the List\n * matches the predicate, -1 is returned.\n *\n * @param <E>  the element type\n * @param list the List to search, may be null\n * @param predicate  the predicate to use, may be null\n * @return the first index of an Object in the List which matches the predicate or -1 if none could be found\n */\npublic static <E> int indexOf(final List<E> list, final Predicate<E> predicate) {\n    if (list != null && predicate != null) {\n        for (int i = 0; i < list.size(); i++) {\n            final E item = list.get(i);\n            if (predicate.evaluate(item)) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}"
            ],
            [
                "longestCommonSubsequence",
                "org.apache.commons.collections4",
                "ListUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns the longest common subsequence (LCS) of two sequences (lists).\n *\n * @param <E>  the element type\n * @param a  the first list\n * @param b  the second list\n * @return the longest common subsequence\n * @throws NullPointerException if either list is {@code null}\n * @since 4.0\n */\npublic static <E> List<E> longestCommonSubsequence(final List<E> a, final List<E> b) {\n    return longestCommonSubsequence(a, b, DefaultEquator.defaultEquator());\n}"
            ],
            [
                "longestCommonSubsequence",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns the longest common subsequence (LCS) of two sequences (lists).\n *\n * @param <E>  the element type\n * @param a  the first list\n * @param b  the second list\n * @param equator  the equator used to test object equality\n * @return the longest common subsequence\n * @throws NullPointerException if either list or the equator is {@code null}\n * @since 4.0\n */\npublic static <E> List<E> longestCommonSubsequence(final List<E> a, final List<E> b, final Equator<? super E> equator) {\n    if (a == null || b == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (equator == null) {\n        throw new NullPointerException(\"Equator must not be null\");\n    }\n    final SequencesComparator<E> comparator = new SequencesComparator<E>(a, b, equator);\n    final EditScript<E> script = comparator.getScript();\n    final LcsVisitor<E> visitor = new LcsVisitor<E>();\n    script.visit(visitor);\n    return visitor.getSubSequence();\n}"
            ],
            [
                "longestCommonSubsequence",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns the longest common subsequence (LCS) of two {@link CharSequence} objects.\n * <p>\n * This is a convenience method for using {@link #longestCommonSubsequence(List, List)}\n * with {@link CharSequence} instances.\n *\n * @param a  the first sequence\n * @param b  the second sequence\n * @return the longest common subsequence as {@link String}\n * @throws NullPointerException if either sequence is {@code null}\n * @since 4.0\n */\npublic static String longestCommonSubsequence(final CharSequence a, final CharSequence b) {\n    if (a == null || b == null) {\n        throw new NullPointerException(\"CharSequence must not be null\");\n    }\n    final List<Character> lcs = longestCommonSubsequence(new CharSequenceAsList(a), new CharSequenceAsList(b));\n    final StringBuilder sb = new StringBuilder();\n    for (Character ch : lcs) {\n        sb.append(ch);\n    }\n    return sb.toString();\n}"
            ],
            [
                "partition",
                "org.apache.commons.collections4",
                "ListUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns consecutive {@link List#subList(int, int) sublists} of a\n * list, each of the same size (the final list may be smaller). For example,\n * partitioning a list containing {@code [a, b, c, d, e]} with a partition\n * size of 3 yields {@code [[a, b, c], [d, e]]} -- an outer list containing\n * two inner lists of three and two elements, all in the original order.\n * <p>\n * The outer list is unmodifiable, but reflects the latest state of the\n * source list. The inner lists are sublist views of the original list,\n * produced on demand using {@link List#subList(int, int)}, and are subject\n * to all the usual caveats about modification as explained in that API.\n * <p>\n * Adapted from http://code.google.com/p/guava-libraries/\n *\n * @param <T> the element type\n * @param list  the list to return consecutive sublists of\n * @param size  the desired size of each sublist (the last may be smaller)\n * @return a list of consecutive sublists\n * @throws NullPointerException if list is null\n * @throws IllegalArgumentException if size is not strictly positive\n * @since 4.0\n */\npublic static <T> List<List<T>> partition(final List<T> list, final int size) {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (size <= 0) {\n        throw new IllegalArgumentException(\"Size must be greater than 0\");\n    }\n    return new Partition<T>(list, size);\n}"
            ],
            [
                "getObject",
                "org.apache.commons.collections4",
                "MapUtils",
                "// Type safe getters\n//-------------------------------------------------------------------------\n/**\n * Gets from a Map in a null-safe manner.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map, <code>null</code> if null map input\n */\npublic static <K, V> V getObject(final Map<? super K, V> map, final K key) {\n    if (map != null) {\n        return map.get(key);\n    }\n    return null;\n}"
            ],
            [
                "getString",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a String from a Map in a null-safe manner.\n * <p>\n * The String is obtained via <code>toString</code>.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a String, <code>null</code> if null map input\n */\npublic static <K> String getString(final Map<? super K, ?> map, final K key) {\n    if (map != null) {\n        final Object answer = map.get(key);\n        if (answer != null) {\n            return answer.toString();\n        }\n    }\n    return null;\n}"
            ],
            [
                "getBoolean",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a Boolean from a Map in a null-safe manner.\n * <p>\n * If the value is a <code>Boolean</code> it is returned directly.\n * If the value is a <code>String</code> and it equals 'true' ignoring case\n * then <code>true</code> is returned, otherwise <code>false</code>.\n * If the value is a <code>Number</code> an integer zero value returns\n * <code>false</code> and non-zero returns <code>true</code>.\n * Otherwise, <code>null</code> is returned.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a Boolean, <code>null</code> if null map input\n */\npublic static <K> Boolean getBoolean(final Map<? super K, ?> map, final K key) {\n    if (map != null) {\n        final Object answer = map.get(key);\n        if (answer != null) {\n            if (answer instanceof Boolean) {\n                return (Boolean) answer;\n            }\n            if (answer instanceof String) {\n                return Boolean.valueOf((String) answer);\n            }\n            if (answer instanceof Number) {\n                final Number n = (Number) answer;\n                return n.intValue() != 0 ? Boolean.TRUE : Boolean.FALSE;\n            }\n        }\n    }\n    return null;\n}"
            ],
            [
                "getNumber",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a Number from a Map in a null-safe manner.\n * <p>\n * If the value is a <code>Number</code> it is returned directly.\n * If the value is a <code>String</code> it is converted using\n * {@link NumberFormat#parse(String)} on the system default formatter\n * returning <code>null</code> if the conversion fails.\n * Otherwise, <code>null</code> is returned.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a Number, <code>null</code> if null map input\n */\npublic static <K> Number getNumber(final Map<? super K, ?> map, final K key) {\n    if (map != null) {\n        final Object answer = map.get(key);\n        if (answer != null) {\n            if (answer instanceof Number) {\n                return (Number) answer;\n            }\n            if (answer instanceof String) {\n                try {\n                    final String text = (String) answer;\n                    return NumberFormat.getInstance().parse(text);\n                } catch (final ParseException e) {\n                    // NOPMD\n                    // failure means null is returned\n                }\n            }\n        }\n    }\n    return null;\n}"
            ],
            [
                "getByte",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a Byte from a Map in a null-safe manner.\n * <p>\n * The Byte is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a Byte, <code>null</code> if null map input\n */\npublic static <K> Byte getByte(final Map<? super K, ?> map, final K key) {\n    final Number answer = getNumber(map, key);\n    if (answer == null) {\n        return null;\n    }\n    if (answer instanceof Byte) {\n        return (Byte) answer;\n    }\n    return Byte.valueOf(answer.byteValue());\n}"
            ],
            [
                "getShort",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a Short from a Map in a null-safe manner.\n * <p>\n * The Short is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a Short, <code>null</code> if null map input\n */\npublic static <K> Short getShort(final Map<? super K, ?> map, final K key) {\n    final Number answer = getNumber(map, key);\n    if (answer == null) {\n        return null;\n    }\n    if (answer instanceof Short) {\n        return (Short) answer;\n    }\n    return Short.valueOf(answer.shortValue());\n}"
            ],
            [
                "getInteger",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a Integer from a Map in a null-safe manner.\n * <p>\n * The Integer is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a Integer, <code>null</code> if null map input\n */\npublic static <K> Integer getInteger(final Map<? super K, ?> map, final K key) {\n    final Number answer = getNumber(map, key);\n    if (answer == null) {\n        return null;\n    }\n    if (answer instanceof Integer) {\n        return (Integer) answer;\n    }\n    return Integer.valueOf(answer.intValue());\n}"
            ],
            [
                "getLong",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a Long from a Map in a null-safe manner.\n * <p>\n * The Long is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a Long, <code>null</code> if null map input\n */\npublic static <K> Long getLong(final Map<? super K, ?> map, final K key) {\n    final Number answer = getNumber(map, key);\n    if (answer == null) {\n        return null;\n    }\n    if (answer instanceof Long) {\n        return (Long) answer;\n    }\n    return Long.valueOf(answer.longValue());\n}"
            ],
            [
                "getFloat",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a Float from a Map in a null-safe manner.\n * <p>\n * The Float is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a Float, <code>null</code> if null map input\n */\npublic static <K> Float getFloat(final Map<? super K, ?> map, final K key) {\n    final Number answer = getNumber(map, key);\n    if (answer == null) {\n        return null;\n    }\n    if (answer instanceof Float) {\n        return (Float) answer;\n    }\n    return Float.valueOf(answer.floatValue());\n}"
            ],
            [
                "getDouble",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a Double from a Map in a null-safe manner.\n * <p>\n * The Double is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a Double, <code>null</code> if null map input\n */\npublic static <K> Double getDouble(final Map<? super K, ?> map, final K key) {\n    final Number answer = getNumber(map, key);\n    if (answer == null) {\n        return null;\n    }\n    if (answer instanceof Double) {\n        return (Double) answer;\n    }\n    return Double.valueOf(answer.doubleValue());\n}"
            ],
            [
                "getMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a Map from a Map in a null-safe manner.\n * <p>\n * If the value returned from the specified map is not a Map then\n * <code>null</code> is returned.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a Map, <code>null</code> if null map input\n */\npublic static <K> Map<?, ?> getMap(final Map<? super K, ?> map, final K key) {\n    if (map != null) {\n        final Object answer = map.get(key);\n        if (answer != null && answer instanceof Map) {\n            return (Map<?, ?>) answer;\n        }\n    }\n    return null;\n}"
            ],
            [
                "getObject",
                "org.apache.commons.collections4",
                "MapUtils",
                "// Type safe getters with default values\n//-------------------------------------------------------------------------\n/**\n * Looks up the given key in the given map, converting null into the\n * given default value.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null\n * @return  the value in the map, or defaultValue if the original value\n *   is null or the map is null\n */\npublic static <K, V> V getObject(final Map<K, V> map, final K key, final V defaultValue) {\n    if (map != null) {\n        final V answer = map.get(key);\n        if (answer != null) {\n            return answer;\n        }\n    }\n    return defaultValue;\n}"
            ],
            [
                "getString",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Looks up the given key in the given map, converting the result into\n * a string, using the default value if the the conversion fails.\n *\n * @param <K>  the key type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null or if the\n *   conversion fails\n * @return  the value in the map as a string, or defaultValue if the\n *   original value is null, the map is null or the string conversion fails\n */\npublic static <K> String getString(final Map<? super K, ?> map, final K key, final String defaultValue) {\n    String answer = getString(map, key);\n    if (answer == null) {\n        answer = defaultValue;\n    }\n    return answer;\n}"
            ],
            [
                "getBoolean",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Looks up the given key in the given map, converting the result into\n * a boolean, using the default value if the the conversion fails.\n *\n * @param <K>  the key type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null or if the\n *   conversion fails\n * @return  the value in the map as a boolean, or defaultValue if the\n *   original value is null, the map is null or the boolean conversion fails\n */\npublic static <K> Boolean getBoolean(final Map<? super K, ?> map, final K key, final Boolean defaultValue) {\n    Boolean answer = getBoolean(map, key);\n    if (answer == null) {\n        answer = defaultValue;\n    }\n    return answer;\n}"
            ],
            [
                "getNumber",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Looks up the given key in the given map, converting the result into\n * a number, using the default value if the the conversion fails.\n *\n * @param <K>  the key type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null or if the\n *   conversion fails\n * @return  the value in the map as a number, or defaultValue if the\n *   original value is null, the map is null or the number conversion fails\n */\npublic static <K> Number getNumber(final Map<? super K, ?> map, final K key, final Number defaultValue) {\n    Number answer = getNumber(map, key);\n    if (answer == null) {\n        answer = defaultValue;\n    }\n    return answer;\n}"
            ],
            [
                "getByte",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Looks up the given key in the given map, converting the result into\n * a byte, using the default value if the the conversion fails.\n *\n * @param <K>  the key type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null or if the\n *   conversion fails\n * @return  the value in the map as a number, or defaultValue if the\n *   original value is null, the map is null or the number conversion fails\n */\npublic static <K> Byte getByte(final Map<? super K, ?> map, final K key, final Byte defaultValue) {\n    Byte answer = getByte(map, key);\n    if (answer == null) {\n        answer = defaultValue;\n    }\n    return answer;\n}"
            ],
            [
                "getShort",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Looks up the given key in the given map, converting the result into\n * a short, using the default value if the the conversion fails.\n *\n * @param <K>  the key type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null or if the\n *   conversion fails\n * @return  the value in the map as a number, or defaultValue if the\n *   original value is null, the map is null or the number conversion fails\n */\npublic static <K> Short getShort(final Map<? super K, ?> map, final K key, final Short defaultValue) {\n    Short answer = getShort(map, key);\n    if (answer == null) {\n        answer = defaultValue;\n    }\n    return answer;\n}"
            ],
            [
                "getInteger",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Looks up the given key in the given map, converting the result into\n * an integer, using the default value if the the conversion fails.\n *\n * @param <K>  the key type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null or if the\n *   conversion fails\n * @return  the value in the map as a number, or defaultValue if the\n *   original value is null, the map is null or the number conversion fails\n */\npublic static <K> Integer getInteger(final Map<? super K, ?> map, final K key, final Integer defaultValue) {\n    Integer answer = getInteger(map, key);\n    if (answer == null) {\n        answer = defaultValue;\n    }\n    return answer;\n}"
            ],
            [
                "getLong",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Looks up the given key in the given map, converting the result into\n * a long, using the default value if the the conversion fails.\n *\n * @param <K>  the key type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null or if the\n *   conversion fails\n * @return  the value in the map as a number, or defaultValue if the\n *   original value is null, the map is null or the number conversion fails\n */\npublic static <K> Long getLong(final Map<? super K, ?> map, final K key, final Long defaultValue) {\n    Long answer = getLong(map, key);\n    if (answer == null) {\n        answer = defaultValue;\n    }\n    return answer;\n}"
            ],
            [
                "getFloat",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Looks up the given key in the given map, converting the result into\n * a float, using the default value if the the conversion fails.\n *\n * @param <K>  the key type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null or if the\n *   conversion fails\n * @return  the value in the map as a number, or defaultValue if the\n *   original value is null, the map is null or the number conversion fails\n */\npublic static <K> Float getFloat(final Map<? super K, ?> map, final K key, final Float defaultValue) {\n    Float answer = getFloat(map, key);\n    if (answer == null) {\n        answer = defaultValue;\n    }\n    return answer;\n}"
            ],
            [
                "getDouble",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Looks up the given key in the given map, converting the result into\n * a double, using the default value if the the conversion fails.\n *\n * @param <K>  the key type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null or if the\n *   conversion fails\n * @return  the value in the map as a number, or defaultValue if the\n *   original value is null, the map is null or the number conversion fails\n */\npublic static <K> Double getDouble(final Map<? super K, ?> map, final K key, final Double defaultValue) {\n    Double answer = getDouble(map, key);\n    if (answer == null) {\n        answer = defaultValue;\n    }\n    return answer;\n}"
            ],
            [
                "getMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Looks up the given key in the given map, converting the result into\n * a map, using the default value if the the conversion fails.\n *\n * @param <K>  the key type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null or if the\n *   conversion fails\n * @return  the value in the map as a number, or defaultValue if the\n *   original value is null, the map is null or the map conversion fails\n */\npublic static <K> Map<?, ?> getMap(final Map<? super K, ?> map, final K key, final Map<?, ?> defaultValue) {\n    Map<?, ?> answer = getMap(map, key);\n    if (answer == null) {\n        answer = defaultValue;\n    }\n    return answer;\n}"
            ],
            [
                "getBooleanValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "// Type safe primitive getters\n//-------------------------------------------------------------------------\n/**\n * Gets a boolean from a Map in a null-safe manner.\n * <p>\n * If the value is a <code>Boolean</code> its value is returned.\n * If the value is a <code>String</code> and it equals 'true' ignoring case\n * then <code>true</code> is returned, otherwise <code>false</code>.\n * If the value is a <code>Number</code> an integer zero value returns\n * <code>false</code> and non-zero returns <code>true</code>.\n * Otherwise, <code>false</code> is returned.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a Boolean, <code>false</code> if null map input\n */\npublic static <K> boolean getBooleanValue(final Map<? super K, ?> map, final K key) {\n    return Boolean.TRUE.equals(getBoolean(map, key));\n}"
            ],
            [
                "getByteValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a byte from a Map in a null-safe manner.\n * <p>\n * The byte is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a byte, <code>0</code> if null map input\n */\npublic static <K> byte getByteValue(final Map<? super K, ?> map, final K key) {\n    final Byte byteObject = getByte(map, key);\n    if (byteObject == null) {\n        return 0;\n    }\n    return byteObject.byteValue();\n}"
            ],
            [
                "getShortValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a short from a Map in a null-safe manner.\n * <p>\n * The short is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a short, <code>0</code> if null map input\n */\npublic static <K> short getShortValue(final Map<? super K, ?> map, final K key) {\n    final Short shortObject = getShort(map, key);\n    if (shortObject == null) {\n        return 0;\n    }\n    return shortObject.shortValue();\n}"
            ],
            [
                "getIntValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets an int from a Map in a null-safe manner.\n * <p>\n * The int is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as an int, <code>0</code> if null map input\n */\npublic static <K> int getIntValue(final Map<? super K, ?> map, final K key) {\n    final Integer integerObject = getInteger(map, key);\n    if (integerObject == null) {\n        return 0;\n    }\n    return integerObject.intValue();\n}"
            ],
            [
                "getLongValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a long from a Map in a null-safe manner.\n * <p>\n * The long is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a long, <code>0L</code> if null map input\n */\npublic static <K> long getLongValue(final Map<? super K, ?> map, final K key) {\n    final Long longObject = getLong(map, key);\n    if (longObject == null) {\n        return 0L;\n    }\n    return longObject.longValue();\n}"
            ],
            [
                "getFloatValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a float from a Map in a null-safe manner.\n * <p>\n * The float is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a float, <code>0.0F</code> if null map input\n */\npublic static <K> float getFloatValue(final Map<? super K, ?> map, final K key) {\n    final Float floatObject = getFloat(map, key);\n    if (floatObject == null) {\n        return 0f;\n    }\n    return floatObject.floatValue();\n}"
            ],
            [
                "getDoubleValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a double from a Map in a null-safe manner.\n * <p>\n * The double is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a double, <code>0.0</code> if null map input\n */\npublic static <K> double getDoubleValue(final Map<? super K, ?> map, final K key) {\n    final Double doubleObject = getDouble(map, key);\n    if (doubleObject == null) {\n        return 0d;\n    }\n    return doubleObject.doubleValue();\n}"
            ],
            [
                "getBooleanValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "// Type safe primitive getters with default values\n//-------------------------------------------------------------------------\n/**\n * Gets a boolean from a Map in a null-safe manner,\n * using the default value if the the conversion fails.\n * <p>\n * If the value is a <code>Boolean</code> its value is returned.\n * If the value is a <code>String</code> and it equals 'true' ignoring case\n * then <code>true</code> is returned, otherwise <code>false</code>.\n * If the value is a <code>Number</code> an integer zero value returns\n * <code>false</code> and non-zero returns <code>true</code>.\n * Otherwise, <code>defaultValue</code> is returned.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @param defaultValue  return if the value is null or if the conversion fails\n * @return the value in the Map as a Boolean, <code>defaultValue</code> if null map input\n */\npublic static <K> boolean getBooleanValue(final Map<? super K, ?> map, final K key, final boolean defaultValue) {\n    final Boolean booleanObject = getBoolean(map, key);\n    if (booleanObject == null) {\n        return defaultValue;\n    }\n    return booleanObject.booleanValue();\n}"
            ],
            [
                "getByteValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a byte from a Map in a null-safe manner,\n * using the default value if the the conversion fails.\n * <p>\n * The byte is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @param defaultValue  return if the value is null or if the conversion fails\n * @return the value in the Map as a byte, <code>defaultValue</code> if null map input\n */\npublic static <K> byte getByteValue(final Map<? super K, ?> map, final K key, final byte defaultValue) {\n    final Byte byteObject = getByte(map, key);\n    if (byteObject == null) {\n        return defaultValue;\n    }\n    return byteObject.byteValue();\n}"
            ],
            [
                "getShortValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a short from a Map in a null-safe manner,\n * using the default value if the the conversion fails.\n * <p>\n * The short is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @param defaultValue  return if the value is null or if the conversion fails\n * @return the value in the Map as a short, <code>defaultValue</code> if null map input\n */\npublic static <K> short getShortValue(final Map<? super K, ?> map, final K key, final short defaultValue) {\n    final Short shortObject = getShort(map, key);\n    if (shortObject == null) {\n        return defaultValue;\n    }\n    return shortObject.shortValue();\n}"
            ],
            [
                "getIntValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets an int from a Map in a null-safe manner,\n * using the default value if the the conversion fails.\n * <p>\n * The int is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @param defaultValue  return if the value is null or if the conversion fails\n * @return the value in the Map as an int, <code>defaultValue</code> if null map input\n */\npublic static <K> int getIntValue(final Map<? super K, ?> map, final K key, final int defaultValue) {\n    final Integer integerObject = getInteger(map, key);\n    if (integerObject == null) {\n        return defaultValue;\n    }\n    return integerObject.intValue();\n}"
            ],
            [
                "getLongValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a long from a Map in a null-safe manner,\n * using the default value if the the conversion fails.\n * <p>\n * The long is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @param defaultValue  return if the value is null or if the conversion fails\n * @return the value in the Map as a long, <code>defaultValue</code> if null map input\n */\npublic static <K> long getLongValue(final Map<? super K, ?> map, final K key, final long defaultValue) {\n    final Long longObject = getLong(map, key);\n    if (longObject == null) {\n        return defaultValue;\n    }\n    return longObject.longValue();\n}"
            ],
            [
                "getFloatValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a float from a Map in a null-safe manner,\n * using the default value if the the conversion fails.\n * <p>\n * The float is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @param defaultValue  return if the value is null or if the conversion fails\n * @return the value in the Map as a float, <code>defaultValue</code> if null map input\n */\npublic static <K> float getFloatValue(final Map<? super K, ?> map, final K key, final float defaultValue) {\n    final Float floatObject = getFloat(map, key);\n    if (floatObject == null) {\n        return defaultValue;\n    }\n    return floatObject.floatValue();\n}"
            ],
            [
                "getDoubleValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a double from a Map in a null-safe manner,\n * using the default value if the the conversion fails.\n * <p>\n * The double is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @param defaultValue  return if the value is null or if the conversion fails\n * @return the value in the Map as a double, <code>defaultValue</code> if null map input\n */\npublic static <K> double getDoubleValue(final Map<? super K, ?> map, final K key, final double defaultValue) {\n    final Double doubleObject = getDouble(map, key);\n    if (doubleObject == null) {\n        return defaultValue;\n    }\n    return doubleObject.doubleValue();\n}"
            ],
            [
                "toProperties",
                "org.apache.commons.collections4",
                "MapUtils",
                "// Conversion methods\n//-------------------------------------------------------------------------\n/**\n * Gets a new Properties object initialised with the values from a Map.\n * A null input will return an empty properties object.\n * <p>\n * A Properties object may only store non-null keys and values, thus if\n * the provided map contains either a key or value which is {@code null},\n * a {@link NullPointerException} will be thrown.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to convert to a Properties object\n * @return the properties object\n * @throws NullPointerException if a key or value in the provided map is {@code null}\n */\npublic static <K, V> Properties toProperties(final Map<K, V> map) {\n    final Properties answer = new Properties();\n    if (map != null) {\n        for (final Entry<K, V> entry2 : map.entrySet()) {\n            final Map.Entry<?, ?> entry = entry2;\n            final Object key = entry.getKey();\n            final Object value = entry.getValue();\n            answer.put(key, value);\n        }\n    }\n    return answer;\n}"
            ],
            [
                "toMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Creates a new HashMap using data copied from a ResourceBundle.\n *\n * @param resourceBundle  the resource bundle to convert, may not be null\n * @return the hashmap containing the data\n * @throws NullPointerException if the bundle is null\n */\npublic static Map<String, Object> toMap(final ResourceBundle resourceBundle) {\n    final Enumeration<String> enumeration = resourceBundle.getKeys();\n    final Map<String, Object> map = new HashMap<String, Object>();\n    while (enumeration.hasMoreElements()) {\n        final String key = enumeration.nextElement();\n        final Object value = resourceBundle.getObject(key);\n        map.put(key, value);\n    }\n    return map;\n}"
            ],
            [
                "invertMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "// Misc\n//-----------------------------------------------------------------------\n/**\n * Inverts the supplied map returning a new HashMap such that the keys of\n * the input are swapped with the values.\n * <p>\n * This operation assumes that the inverse mapping is well defined.\n * If the input map had multiple entries with the same value mapped to\n * different keys, the returned map will map one of those keys to the\n * value, but the exact key which will be mapped is undefined.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to invert, may not be null\n * @return a new HashMap containing the inverted data\n * @throws NullPointerException if the map is null\n */\npublic static <K, V> Map<V, K> invertMap(final Map<K, V> map) {\n    final Map<V, K> out = new HashMap<V, K>(map.size());\n    for (final Entry<K, V> entry : map.entrySet()) {\n        out.put(entry.getValue(), entry.getKey());\n    }\n    return out;\n}"
            ],
            [
                "putAll",
                "org.apache.commons.collections4",
                "MapUtils",
                "//-----------------------------------------------------------------------\n/**\n * Puts all the keys and values from the specified array into the map.\n * <p>\n * This method is an alternative to the {@link java.util.Map#putAll(java.util.Map)}\n * method and constructors. It allows you to build a map from an object array\n * of various possible styles.\n * <p>\n * If the first entry in the object array implements {@link java.util.Map.Entry}\n * or {@link KeyValue} then the key and value are added from that object.\n * If the first entry in the object array is an object array itself, then\n * it is assumed that index 0 in the sub-array is the key and index 1 is the value.\n * Otherwise, the array is treated as keys and values in alternate indices.\n * <p>\n * For example, to create a color map:\n * <pre>\n * Map colorMap = MapUtils.putAll(new HashMap(), new String[][] {\n *     {\"RED\", \"#FF0000\"},\n *     {\"GREEN\", \"#00FF00\"},\n *     {\"BLUE\", \"#0000FF\"}\n * });\n * </pre>\n * or:\n * <pre>\n * Map colorMap = MapUtils.putAll(new HashMap(), new String[] {\n *     \"RED\", \"#FF0000\",\n *     \"GREEN\", \"#00FF00\",\n *     \"BLUE\", \"#0000FF\"\n * });\n * </pre>\n * or:\n * <pre>\n * Map colorMap = MapUtils.putAll(new HashMap(), new Map.Entry[] {\n *     new DefaultMapEntry(\"RED\", \"#FF0000\"),\n *     new DefaultMapEntry(\"GREEN\", \"#00FF00\"),\n *     new DefaultMapEntry(\"BLUE\", \"#0000FF\")\n * });\n * </pre>\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to populate, must not be null\n * @param array  an array to populate from, null ignored\n * @return the input map\n * @throws NullPointerException  if map is null\n * @throws IllegalArgumentException  if sub-array or entry matching used and an entry is invalid\n * @throws ClassCastException if the array contents is mixed\n * @since 3.2\n */\n// As per Javadoc throws CCE for invalid array contents\n@SuppressWarnings(\"unchecked\")\npublic static <K, V> Map<K, V> putAll(final Map<K, V> map, final Object[] array) {\n    if (map == null) {\n        throw new NullPointerException(\"The map must not be null\");\n    }\n    if (array == null || array.length == 0) {\n        return map;\n    }\n    final Object obj = array[0];\n    if (obj instanceof Map.Entry) {\n        for (final Object element : array) {\n            // cast ok here, type is checked above\n            final Map.Entry<K, V> entry = (Map.Entry<K, V>) element;\n            map.put(entry.getKey(), entry.getValue());\n        }\n    } else if (obj instanceof KeyValue) {\n        for (final Object element : array) {\n            // cast ok here, type is checked above\n            final KeyValue<K, V> keyval = (KeyValue<K, V>) element;\n            map.put(keyval.getKey(), keyval.getValue());\n        }\n    } else if (obj instanceof Object[]) {\n        for (int i = 0; i < array.length; i++) {\n            final Object[] sub = (Object[]) array[i];\n            if (sub == null || sub.length < 2) {\n                throw new IllegalArgumentException(\"Invalid array element: \" + i);\n            }\n            // these casts can fail if array has incorrect types\n            map.put((K) sub[0], (V) sub[1]);\n        }\n    } else {\n        for (int i = 0; i < array.length - 1; ) {\n            // these casts can fail if array has incorrect types\n            map.put((K) array[i++], (V) array[i++]);\n        }\n    }\n    return map;\n}"
            ],
            [
                "emptyIfNull",
                "org.apache.commons.collections4",
                "MapUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns an immutable empty map if the argument is <code>null</code>,\n * or the argument itself otherwise.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map the map, possibly <code>null</code>\n * @return an empty map if the argument is <code>null</code>\n */\npublic static <K, V> Map<K, V> emptyIfNull(final Map<K, V> map) {\n    return map == null ? Collections.<K, V>emptyMap() : map;\n}"
            ],
            [
                "isEmpty",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Null-safe check if the specified map is empty.\n * <p>\n * Null returns true.\n *\n * @param map  the map to check, may be null\n * @return true if empty or null\n * @since 3.2\n */\npublic static boolean isEmpty(final Map<?, ?> map) {\n    return map == null || map.isEmpty();\n}"
            ],
            [
                "isNotEmpty",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Null-safe check if the specified map is not empty.\n * <p>\n * Null returns false.\n *\n * @param map  the map to check, may be null\n * @return true if non-null and non-empty\n * @since 3.2\n */\npublic static boolean isNotEmpty(final Map<?, ?> map) {\n    return !MapUtils.isEmpty(map);\n}"
            ],
            [
                "synchronizedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "// Map decorators\n//-----------------------------------------------------------------------\n/**\n * Returns a synchronized map backed by the given map.\n * <p>\n * You must manually synchronize on the returned buffer's iterator to\n * avoid non-deterministic behavior:\n *\n * <pre>\n * Map m = MapUtils.synchronizedMap(myMap);\n * Set s = m.keySet();  // outside synchronized block\n * synchronized (m) {  // synchronized on MAP!\n *     Iterator i = s.iterator();\n *     while (i.hasNext()) {\n *         process (i.next());\n *     }\n * }\n * </pre>\n *\n * This method uses the implementation in {@link java.util.Collections Collections}.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to synchronize, must not be null\n * @return a synchronized map backed by the given map\n */\npublic static <K, V> Map<K, V> synchronizedMap(final Map<K, V> map) {\n    return Collections.synchronizedMap(map);\n}"
            ],
            [
                "unmodifiableMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns an unmodifiable map backed by the given map.\n * <p>\n * This method uses the implementation in the decorators subpackage.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to make unmodifiable, must not be null\n * @return an unmodifiable map backed by the given map\n * @throws NullPointerException  if the map is null\n */\npublic static <K, V> Map<K, V> unmodifiableMap(final Map<? extends K, ? extends V> map) {\n    return UnmodifiableMap.unmodifiableMap(map);\n}"
            ],
            [
                "predicatedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a predicated (validating) map backed by the given map.\n * <p>\n * Only objects that pass the tests in the given predicates can be added to the map.\n * Trying to add an invalid object results in an IllegalArgumentException.\n * Keys must pass the key predicate, values must pass the value predicate.\n * It is important not to use the original map after invoking this method,\n * as it is a backdoor for adding invalid objects.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to predicate, must not be null\n * @param keyPred  the predicate for keys, null means no check\n * @param valuePred  the predicate for values, null means no check\n * @return a predicated map backed by the given map\n * @throws NullPointerException  if the Map is null\n */\npublic static <K, V> IterableMap<K, V> predicatedMap(final Map<K, V> map, final Predicate<? super K> keyPred, final Predicate<? super V> valuePred) {\n    return PredicatedMap.predicatedMap(map, keyPred, valuePred);\n}"
            ],
            [
                "transformedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a transformed map backed by the given map.\n * <p>\n * This method returns a new map (decorating the specified map) that\n * will transform any new entries added to it.\n * Existing entries in the specified map will not be transformed.\n * If you want that behaviour, see {@link TransformedMap#transformedMap}.\n * <p>\n * Each object is passed through the transformers as it is added to the\n * Map. It is important not to use the original map after invoking this\n * method, as it is a backdoor for adding untransformed objects.\n * <p>\n * If there are any elements already in the map being decorated, they\n * are NOT transformed.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to transform, must not be null, typically empty\n * @param keyTransformer  the transformer for the map keys, null means no transformation\n * @param valueTransformer  the transformer for the map values, null means no transformation\n * @return a transformed map backed by the given map\n * @throws NullPointerException  if the Map is null\n */\npublic static <K, V> IterableMap<K, V> transformedMap(final Map<K, V> map, final Transformer<? super K, ? extends K> keyTransformer, final Transformer<? super V, ? extends V> valueTransformer) {\n    return TransformedMap.transformingMap(map, keyTransformer, valueTransformer);\n}"
            ],
            [
                "fixedSizeMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a fixed-sized map backed by the given map.\n * Elements may not be added or removed from the returned map, but\n * existing elements can be changed (for instance, via the\n * {@link Map#put(Object,Object)} method).\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map whose size to fix, must not be null\n * @return a fixed-size map backed by that map\n * @throws NullPointerException  if the Map is null\n */\npublic static <K, V> IterableMap<K, V> fixedSizeMap(final Map<K, V> map) {\n    return FixedSizeMap.fixedSizeMap(map);\n}"
            ],
            [
                "lazyMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a \"lazy\" map whose values will be created on demand.\n * <p>\n * When the key passed to the returned map's {@link Map#get(Object)}\n * method is not present in the map, then the factory will be used\n * to create a new object and that object will become the value\n * associated with that key.\n * <p>\n * For instance:\n * <pre>\n * Factory factory = new Factory() {\n *     public Object create() {\n *         return new Date();\n *     }\n * }\n * Map lazyMap = MapUtils.lazyMap(new HashMap(), factory);\n * Object obj = lazyMap.get(\"test\");\n * </pre>\n *\n * After the above code is executed, <code>obj</code> will contain\n * a new <code>Date</code> instance.  Furthermore, that <code>Date</code>\n * instance is the value for the <code>\"test\"</code> key in the map.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to make lazy, must not be null\n * @param factory  the factory for creating new objects, must not be null\n * @return a lazy map backed by the given map\n * @throws NullPointerException  if the Map or Factory is null\n */\npublic static <K, V> IterableMap<K, V> lazyMap(final Map<K, V> map, final Factory<? extends V> factory) {\n    return LazyMap.lazyMap(map, factory);\n}"
            ],
            [
                "lazyMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a \"lazy\" map whose values will be created on demand.\n * <p>\n * When the key passed to the returned map's {@link Map#get(Object)}\n * method is not present in the map, then the factory will be used\n * to create a new object and that object will become the value\n * associated with that key. The factory is a {@link Transformer}\n * that will be passed the key which it must transform into the value.\n * <p>\n * For instance:\n * <pre>\n * Transformer factory = new Transformer() {\n *     public Object transform(Object mapKey) {\n *         return new File(mapKey);\n *     }\n * }\n * Map lazyMap = MapUtils.lazyMap(new HashMap(), factory);\n * Object obj = lazyMap.get(\"C:/dev\");\n * </pre>\n *\n * After the above code is executed, <code>obj</code> will contain\n * a new <code>File</code> instance for the C drive dev directory.\n * Furthermore, that <code>File</code> instance is the value for the\n * <code>\"C:/dev\"</code> key in the map.\n * <p>\n * If a lazy map is wrapped by a synchronized map, the result is a simple\n * synchronized cache. When an object is not is the cache, the cache itself\n * calls back to the factory Transformer to populate itself, all within the\n * same synchronized block.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to make lazy, must not be null\n * @param transformerFactory  the factory for creating new objects, must not be null\n * @return a lazy map backed by the given map\n * @throws NullPointerException  if the Map or Transformer is null\n */\npublic static <K, V> IterableMap<K, V> lazyMap(final Map<K, V> map, final Transformer<? super K, ? extends V> transformerFactory) {\n    return LazyMap.lazyMap(map, transformerFactory);\n}"
            ],
            [
                "orderedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a map that maintains the order of keys that are added\n * backed by the given map.\n * <p>\n * If a key is added twice, the order is determined by the first add.\n * The order is observed through the keySet, values and entrySet.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to order, must not be null\n * @return an ordered map backed by the given map\n * @throws NullPointerException  if the Map is null\n */\npublic static <K, V> OrderedMap<K, V> orderedMap(final Map<K, V> map) {\n    return ListOrderedMap.listOrderedMap(map);\n}"
            ],
            [
                "multiValueMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Creates a mult-value map backed by the given map which returns\n * collections of type ArrayList.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate\n * @return a multi-value map backed by the given map which returns ArrayLists of values.\n * @see MultiValueMap\n * @since 3.2\n * @deprecated since 4.1, use {@link MultiValuedMap} instead\n */\n@Deprecated\npublic static <K, V> MultiValueMap<K, V> multiValueMap(final Map<K, ? super Collection<V>> map) {\n    return MultiValueMap.<K, V>multiValueMap(map);\n}"
            ],
            [
                "multiValueMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Creates a multi-value map backed by the given map which returns\n * collections of the specified type.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param <C>  the collection class type\n * @param map  the map to decorate\n * @param collectionClass  the type of collections to return from the map\n *   (must contain public no-arg constructor and extend Collection)\n * @return a multi-value map backed by the given map which returns collections of the specified type\n * @see MultiValueMap\n * @since 3.2\n * @deprecated since 4.1, use {@link MultiValuedMap} instead\n */\n@Deprecated\npublic static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(final Map<K, C> map, final Class<C> collectionClass) {\n    return MultiValueMap.multiValueMap(map, collectionClass);\n}"
            ],
            [
                "multiValueMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Creates a multi-value map backed by the given map which returns\n * collections created by the specified collection factory.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param <C>  the collection class type\n * @param map  the map to decorate\n * @param collectionFactory  a factor which creates collection objects\n * @return a multi-value map backed by the given map which returns collections\n *   created by the specified collection factory\n * @see MultiValueMap\n * @since 3.2\n * @deprecated since 4.1, use {@link MultiValuedMap} instead\n */\n@Deprecated\npublic static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(final Map<K, C> map, final Factory<C> collectionFactory) {\n    return MultiValueMap.multiValueMap(map, collectionFactory);\n}"
            ],
            [
                "synchronizedSortedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "// SortedMap decorators\n//-----------------------------------------------------------------------\n/**\n * Returns a synchronized sorted map backed by the given sorted map.\n * <p>\n * You must manually synchronize on the returned buffer's iterator to\n * avoid non-deterministic behavior:\n *\n * <pre>\n * Map m = MapUtils.synchronizedSortedMap(myMap);\n * Set s = m.keySet();  // outside synchronized block\n * synchronized (m) {  // synchronized on MAP!\n *     Iterator i = s.iterator();\n *     while (i.hasNext()) {\n *         process (i.next());\n *     }\n * }\n * </pre>\n *\n * This method uses the implementation in {@link java.util.Collections Collections}.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to synchronize, must not be null\n * @return a synchronized map backed by the given map\n * @throws NullPointerException  if the map is null\n */\npublic static <K, V> SortedMap<K, V> synchronizedSortedMap(final SortedMap<K, V> map) {\n    return Collections.synchronizedSortedMap(map);\n}"
            ],
            [
                "unmodifiableSortedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns an unmodifiable sorted map backed by the given sorted map.\n * <p>\n * This method uses the implementation in the decorators subpackage.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the sorted map to make unmodifiable, must not be null\n * @return an unmodifiable map backed by the given map\n * @throws NullPointerException  if the map is null\n */\npublic static <K, V> SortedMap<K, V> unmodifiableSortedMap(final SortedMap<K, ? extends V> map) {\n    return UnmodifiableSortedMap.unmodifiableSortedMap(map);\n}"
            ],
            [
                "predicatedSortedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a predicated (validating) sorted map backed by the given map.\n * <p>\n * Only objects that pass the tests in the given predicates can be added to the map.\n * Trying to add an invalid object results in an IllegalArgumentException.\n * Keys must pass the key predicate, values must pass the value predicate.\n * It is important not to use the original map after invoking this method,\n * as it is a backdoor for adding invalid objects.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to predicate, must not be null\n * @param keyPred  the predicate for keys, null means no check\n * @param valuePred  the predicate for values, null means no check\n * @return a predicated map backed by the given map\n * @throws NullPointerException  if the SortedMap is null\n */\npublic static <K, V> SortedMap<K, V> predicatedSortedMap(final SortedMap<K, V> map, final Predicate<? super K> keyPred, final Predicate<? super V> valuePred) {\n    return PredicatedSortedMap.predicatedSortedMap(map, keyPred, valuePred);\n}"
            ],
            [
                "transformedSortedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a transformed sorted map backed by the given map.\n * <p>\n * This method returns a new sorted map (decorating the specified map) that\n * will transform any new entries added to it.\n * Existing entries in the specified map will not be transformed.\n * If you want that behaviour, see {@link TransformedSortedMap#transformedSortedMap}.\n * <p>\n * Each object is passed through the transformers as it is added to the\n * Map. It is important not to use the original map after invoking this\n * method, as it is a backdoor for adding untransformed objects.\n * <p>\n * If there are any elements already in the map being decorated, they\n * are NOT transformed.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to transform, must not be null, typically empty\n * @param keyTransformer  the transformer for the map keys, null means no transformation\n * @param valueTransformer  the transformer for the map values, null means no transformation\n * @return a transformed map backed by the given map\n * @throws NullPointerException  if the SortedMap is null\n */\npublic static <K, V> SortedMap<K, V> transformedSortedMap(final SortedMap<K, V> map, final Transformer<? super K, ? extends K> keyTransformer, final Transformer<? super V, ? extends V> valueTransformer) {\n    return TransformedSortedMap.transformingSortedMap(map, keyTransformer, valueTransformer);\n}"
            ],
            [
                "fixedSizeSortedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a fixed-sized sorted map backed by the given sorted map.\n * Elements may not be added or removed from the returned map, but\n * existing elements can be changed (for instance, via the\n * {@link Map#put(Object,Object)} method).\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map whose size to fix, must not be null\n * @return a fixed-size map backed by that map\n * @throws NullPointerException  if the SortedMap is null\n */\npublic static <K, V> SortedMap<K, V> fixedSizeSortedMap(final SortedMap<K, V> map) {\n    return FixedSizeSortedMap.fixedSizeSortedMap(map);\n}"
            ],
            [
                "lazySortedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a \"lazy\" sorted map whose values will be created on demand.\n * <p>\n * When the key passed to the returned map's {@link Map#get(Object)}\n * method is not present in the map, then the factory will be used\n * to create a new object and that object will become the value\n * associated with that key.\n * <p>\n * For instance:\n *\n * <pre>\n * Factory factory = new Factory() {\n *     public Object create() {\n *         return new Date();\n *     }\n * }\n * SortedMap lazy = MapUtils.lazySortedMap(new TreeMap(), factory);\n * Object obj = lazy.get(\"test\");\n * </pre>\n *\n * After the above code is executed, <code>obj</code> will contain\n * a new <code>Date</code> instance.  Furthermore, that <code>Date</code>\n * instance is the value for the <code>\"test\"</code> key.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to make lazy, must not be null\n * @param factory  the factory for creating new objects, must not be null\n * @return a lazy map backed by the given map\n * @throws NullPointerException  if the SortedMap or Factory is null\n */\npublic static <K, V> SortedMap<K, V> lazySortedMap(final SortedMap<K, V> map, final Factory<? extends V> factory) {\n    return LazySortedMap.lazySortedMap(map, factory);\n}"
            ],
            [
                "lazySortedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a \"lazy\" sorted map whose values will be created on demand.\n * <p>\n * When the key passed to the returned map's {@link Map#get(Object)}\n * method is not present in the map, then the factory will be used\n * to create a new object and that object will become the value\n * associated with that key. The factory is a {@link Transformer}\n * that will be passed the key which it must transform into the value.\n * <p>\n * For instance:\n * <pre>\n * Transformer factory = new Transformer() {\n *     public Object transform(Object mapKey) {\n *         return new File(mapKey);\n *     }\n * }\n * SortedMap lazy = MapUtils.lazySortedMap(new TreeMap(), factory);\n * Object obj = lazy.get(\"C:/dev\");\n * </pre>\n *\n * After the above code is executed, <code>obj</code> will contain\n * a new <code>File</code> instance for the C drive dev directory.\n * Furthermore, that <code>File</code> instance is the value for the\n * <code>\"C:/dev\"</code> key in the map.\n * <p>\n * If a lazy map is wrapped by a synchronized map, the result is a simple\n * synchronized cache. When an object is not is the cache, the cache itself\n * calls back to the factory Transformer to populate itself, all within the\n * same synchronized block.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to make lazy, must not be null\n * @param transformerFactory  the factory for creating new objects, must not be null\n * @return a lazy map backed by the given map\n * @throws NullPointerException  if the Map or Transformer is null\n */\npublic static <K, V> SortedMap<K, V> lazySortedMap(final SortedMap<K, V> map, final Transformer<? super K, ? extends V> transformerFactory) {\n    return LazySortedMap.lazySortedMap(map, transformerFactory);\n}"
            ],
            [
                "iterableMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Get the specified {@link Map} as an {@link IterableMap}.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map to wrap if necessary.\n * @return IterableMap<K, V>\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> IterableMap<K, V> iterableMap(final Map<K, V> map) {\n    if (map == null) {\n        throw new NullPointerException(\"Map must not be null\");\n    }\n    return map instanceof IterableMap ? (IterableMap<K, V>) map : new AbstractMapDecorator<K, V>(map) {\n    };\n}"
            ],
            [
                "iterableSortedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Get the specified {@link SortedMap} as an {@link IterableSortedMap}.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param sortedMap to wrap if necessary\n * @return {@link IterableSortedMap}<K, V>\n * @throws NullPointerException if sortedMap is null\n * @since 4.0\n */\npublic static <K, V> IterableSortedMap<K, V> iterableSortedMap(final SortedMap<K, V> sortedMap) {\n    if (sortedMap == null) {\n        throw new NullPointerException(\"Map must not be null\");\n    }\n    return sortedMap instanceof IterableSortedMap ? (IterableSortedMap<K, V>) sortedMap : new AbstractSortedMapDecorator<K, V>(sortedMap) {\n    };\n}"
            ],
            [
                "defaultEquator",
                "org.apache.commons.collections4.functors",
                "DefaultEquator",
                "/**\n * Factory returning the typed singleton instance.\n *\n * @param <T>  the object type\n * @return the singleton instance\n */\n// the static instance works for all types\n@SuppressWarnings(\"unchecked\")\npublic static <T> DefaultEquator<T> defaultEquator() {\n    return (DefaultEquator<T>) DefaultEquator.INSTANCE;\n}"
            ],
            [
                "stringValueTransformer",
                "org.apache.commons.collections4.functors",
                "StringValueTransformer",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <T>  the input type\n * @return the singleton instance\n * @since 3.1\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Transformer<T, String> stringValueTransformer() {\n    return (Transformer<T, String>) INSTANCE;\n}"
            ],
            [
                "ifTransformer",
                "org.apache.commons.collections4.functors",
                "IfTransformer",
                "/**\n * Factory method that performs validation.\n *\n * @param <I>  input type for the transformer\n * @param <O>  output type for the transformer\n * @param predicate  predicate to switch on\n * @param trueTransformer  transformer used if true\n * @param falseTransformer  transformer used if false\n * @return the <code>if</code> transformer\n * @throws NullPointerException if either argument is null\n */\npublic static <I, O> Transformer<I, O> ifTransformer(final Predicate<? super I> predicate, final Transformer<? super I, ? extends O> trueTransformer, final Transformer<? super I, ? extends O> falseTransformer) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    if (trueTransformer == null || falseTransformer == null) {\n        throw new NullPointerException(\"Transformers must not be null\");\n    }\n    return new IfTransformer<I, O>(predicate, trueTransformer, falseTransformer);\n}"
            ],
            [
                "ifTransformer",
                "org.apache.commons.collections4.functors",
                "IfTransformer",
                "/**\n * Factory method that performs validation.\n * <p>\n * This factory creates a transformer that just returns the input object when\n * the predicate is false.\n *\n * @param <T>  input and output type for the transformer\n * @param predicate  predicate to switch on\n * @param trueTransformer  transformer used if true\n * @return the <code>if</code> transformer\n * @throws NullPointerException if either argument is null\n */\npublic static <T> Transformer<T, T> ifTransformer(final Predicate<? super T> predicate, final Transformer<? super T, ? extends T> trueTransformer) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    if (trueTransformer == null) {\n        throw new NullPointerException(\"Transformer must not be null\");\n    }\n    return new IfTransformer<T, T>(predicate, trueTransformer, NOPTransformer.<T>nopTransformer());\n}"
            ],
            [
                "identityPredicate",
                "org.apache.commons.collections4.functors",
                "IdentityPredicate",
                "/**\n * Factory to create the identity predicate.\n *\n * @param <T> the type that the predicate queries\n * @param object  the object to compare to\n * @return the predicate\n */\npublic static <T> Predicate<T> identityPredicate(final T object) {\n    if (object == null) {\n        return NullPredicate.<T>nullPredicate();\n    }\n    return new IdentityPredicate<T>(object);\n}"
            ],
            [
                "exceptionClosure",
                "org.apache.commons.collections4.functors",
                "ExceptionClosure",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <E> the type that the closure acts on\n * @return the singleton instance\n * @since 3.1\n */\n// the static instance works for all types\n@SuppressWarnings(\"unchecked\")\npublic static <E> Closure<E> exceptionClosure() {\n    return (Closure<E>) INSTANCE;\n}"
            ],
            [
                "nopClosure",
                "org.apache.commons.collections4.functors",
                "NOPClosure",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <E> the type that the closure acts on\n * @return the singleton instance\n * @since 3.1\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Closure<E> nopClosure() {\n    return (Closure<E>) INSTANCE;\n}"
            ],
            [
                "closureTransformer",
                "org.apache.commons.collections4.functors",
                "ClosureTransformer",
                "/**\n * Factory method that performs validation.\n *\n * @param <T>  the type of the object to transform\n * @param closure  the closure to call, not null\n * @return the <code>closure</code> transformer\n * @throws NullPointerException if the closure is null\n */\npublic static <T> Transformer<T, T> closureTransformer(final Closure<? super T> closure) {\n    if (closure == null) {\n        throw new NullPointerException(\"Closure must not be null\");\n    }\n    return new ClosureTransformer<T>(closure);\n}"
            ],
            [
                "copy",
                "org.apache.commons.collections4.functors",
                "FunctorUtils",
                "/**\n * Clone the predicates to ensure that the internal reference can't be messed with.\n * Due to the {@link Predicate#evaluate(T)} method, Predicate<? super T> is\n * able to be coerced to Predicate<T> without casting issues.\n *\n * @param predicates  the predicates to copy\n * @return the cloned predicates\n */\n@SuppressWarnings(\"unchecked\")\nstatic <T> Predicate<T>[] copy(final Predicate<? super T>... predicates) {\n    if (predicates == null) {\n        return null;\n    }\n    return (Predicate<T>[]) predicates.clone();\n}"
            ],
            [
                "coerce",
                "org.apache.commons.collections4.functors",
                "FunctorUtils",
                "/**\n * A very simple method that coerces Predicate<? super T> to Predicate<T>.\n * Due to the {@link Predicate#evaluate(T)} method, Predicate<? super T> is\n * able to be coerced to Predicate<T> without casting issues.\n * <p>This method exists\n * simply as centralised documentation and atomic unchecked warning\n * suppression.\n *\n * @param <T> the type of object the returned predicate should \"accept\"\n * @param predicate the predicate to coerce.\n * @return the coerced predicate.\n */\n@SuppressWarnings(\"unchecked\")\nstatic <T> Predicate<T> coerce(final Predicate<? super T> predicate) {\n    return (Predicate<T>) predicate;\n}"
            ],
            [
                "validate",
                "org.apache.commons.collections4.functors",
                "FunctorUtils",
                "/**\n * Validate the predicates to ensure that all is well.\n *\n * @param predicates  the predicates to validate\n * @return predicate array\n */\nstatic <T> Predicate<? super T>[] validate(final Collection<? extends Predicate<? super T>> predicates) {\n    if (predicates == null) {\n        throw new NullPointerException(\"The predicate collection must not be null\");\n    }\n    // convert to array like this to guarantee iterator() ordering\n    // OK\n    @SuppressWarnings(\"unchecked\")\n    final Predicate<? super T>[] preds = new Predicate[predicates.size()];\n    int i = 0;\n    for (final Predicate<? super T> predicate : predicates) {\n        preds[i] = predicate;\n        if (preds[i] == null) {\n            throw new NullPointerException(\"The predicate collection must not contain a null predicate, index \" + i + \" was null\");\n        }\n        i++;\n    }\n    return preds;\n}"
            ],
            [
                "copy",
                "org.apache.commons.collections4.functors",
                "FunctorUtils",
                "/**\n * Clone the closures to ensure that the internal reference can't be messed with.\n *\n * @param closures  the closures to copy\n * @return the cloned closures\n */\n@SuppressWarnings(\"unchecked\")\nstatic <E> Closure<E>[] copy(final Closure<? super E>... closures) {\n    if (closures == null) {\n        return null;\n    }\n    return (Closure<E>[]) closures.clone();\n}"
            ],
            [
                "coerce",
                "org.apache.commons.collections4.functors",
                "FunctorUtils",
                "/**\n * A very simple method that coerces Closure<? super T> to Closure<T>.\n * <p>This method exists\n * simply as centralised documentation and atomic unchecked warning\n * suppression.\n *\n * @param <T> the type of object the returned closure should \"accept\"\n * @param closure the closure to coerce.\n * @return the coerced closure.\n */\n@SuppressWarnings(\"unchecked\")\nstatic <T> Closure<T> coerce(final Closure<? super T> closure) {\n    return (Closure<T>) closure;\n}"
            ],
            [
                "copy",
                "org.apache.commons.collections4.functors",
                "FunctorUtils",
                "/**\n * Copy method\n *\n * @param transformers  the transformers to copy\n * @return a clone of the transformers\n */\n@SuppressWarnings(\"unchecked\")\nstatic <I, O> Transformer<I, O>[] copy(final Transformer<? super I, ? extends O>... transformers) {\n    if (transformers == null) {\n        return null;\n    }\n    return (Transformer<I, O>[]) transformers.clone();\n}"
            ],
            [
                "coerce",
                "org.apache.commons.collections4.functors",
                "FunctorUtils",
                "/**\n * A very simple method that coerces Transformer<? super I, ? extends O> to Transformer<I, O>.\n * <p>This method exists\n * simply as centralised documentation and atomic unchecked warning\n * suppression.\n *\n * @param <T> the type of object the returned transformer should \"accept\"\n * @param transformer the transformer to coerce.\n * @return the coerced transformer.\n */\n@SuppressWarnings(\"unchecked\")\nstatic <I, O> Transformer<I, O> coerce(final Transformer<? super I, ? extends O> transformer) {\n    return (Transformer<I, O>) transformer;\n}"
            ],
            [
                "transformerPredicate",
                "org.apache.commons.collections4.functors",
                "TransformerPredicate",
                "/**\n * Factory to create the predicate.\n *\n * @param <T> the type that the predicate queries\n * @param transformer  the transformer to decorate\n * @return the predicate\n * @throws NullPointerException if the transformer is null\n */\npublic static <T> Predicate<T> transformerPredicate(final Transformer<? super T, Boolean> transformer) {\n    if (transformer == null) {\n        throw new NullPointerException(\"The transformer to call must not be null\");\n    }\n    return new TransformerPredicate<T>(transformer);\n}"
            ],
            [
                "nullPredicate",
                "org.apache.commons.collections4.functors",
                "NullPredicate",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <T> the type that the predicate queries\n * @return the singleton instance\n * @since 3.1\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Predicate<T> nullPredicate() {\n    return (Predicate<T>) INSTANCE;\n}"
            ],
            [
                "nullTransformer",
                "org.apache.commons.collections4.functors",
                "ConstantTransformer",
                "/**\n * Get a typed null instance.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @return Transformer<I, O> that always returns null.\n */\n// The null transformer works for all object types\n@SuppressWarnings(\"unchecked\")\npublic static <I, O> Transformer<I, O> nullTransformer() {\n    return (Transformer<I, O>) NULL_INSTANCE;\n}"
            ],
            [
                "constantTransformer",
                "org.apache.commons.collections4.functors",
                "ConstantTransformer",
                "/**\n * Transformer method that performs validation.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param constantToReturn  the constant object to return each time in the factory\n * @return the <code>constant</code> factory.\n */\npublic static <I, O> Transformer<I, O> constantTransformer(final O constantToReturn) {\n    if (constantToReturn == null) {\n        return nullTransformer();\n    }\n    return new ConstantTransformer<I, O>(constantToReturn);\n}"
            ],
            [
                "predicateTransformer",
                "org.apache.commons.collections4.functors",
                "PredicateTransformer",
                "/**\n * Factory method that performs validation.\n *\n * @param <T>  the input type\n * @param predicate  the predicate to call, not null\n * @return the <code>predicate</code> transformer\n * @throws IllegalArgumentException if the predicate is null\n */\npublic static <T> Transformer<T, Boolean> predicateTransformer(final Predicate<? super T> predicate) {\n    if (predicate == null) {\n        throw new IllegalArgumentException(\"Predicate must not be null\");\n    }\n    return new PredicateTransformer<T>(predicate);\n}"
            ],
            [
                "whileClosure",
                "org.apache.commons.collections4.functors",
                "WhileClosure",
                "/**\n * Factory method that performs validation.\n *\n * @param <E> the type that the closure acts on\n * @param predicate  the predicate used to evaluate when the loop terminates, not null\n * @param closure  the closure the execute, not null\n * @param doLoop  true to act as a do-while loop, always executing the closure once\n * @return the <code>while</code> closure\n * @throws NullPointerException if the predicate or closure is null\n */\npublic static <E> Closure<E> whileClosure(final Predicate<? super E> predicate, final Closure<? super E> closure, final boolean doLoop) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    if (closure == null) {\n        throw new NullPointerException(\"Closure must not be null\");\n    }\n    return new WhileClosure<E>(predicate, closure, doLoop);\n}"
            ],
            [
                "forClosure",
                "org.apache.commons.collections4.functors",
                "ForClosure",
                "/**\n * Factory method that performs validation.\n * <p>\n * A null closure or zero count returns the <code>NOPClosure</code>.\n * A count of one returns the specified closure.\n *\n * @param <E> the type that the closure acts on\n * @param count  the number of times to execute the closure\n * @param closure  the closure to execute, not null\n * @return the <code>for</code> closure\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Closure<E> forClosure(final int count, final Closure<? super E> closure) {\n    if (count <= 0 || closure == null) {\n        return NOPClosure.<E>nopClosure();\n    }\n    if (count == 1) {\n        return (Closure<E>) closure;\n    }\n    return new ForClosure<E>(count, closure);\n}"
            ],
            [
                "nullIsTruePredicate",
                "org.apache.commons.collections4.functors",
                "NullIsTruePredicate",
                "/**\n * Factory to create the null true predicate.\n *\n * @param <T> the type that the predicate queries\n * @param predicate  the predicate to decorate, not null\n * @return the predicate\n * @throws NullPointerException if the predicate is null\n */\npublic static <T> Predicate<T> nullIsTruePredicate(final Predicate<? super T> predicate) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    return new NullIsTruePredicate<T>(predicate);\n}"
            ],
            [
                "transformedPredicate",
                "org.apache.commons.collections4.functors",
                "TransformedPredicate",
                "/**\n * Factory to create the predicate.\n *\n * @param <T> the type that the predicate queries\n * @param transformer  the transformer to call\n * @param predicate  the predicate to call with the result of the transform\n * @return the predicate\n * @throws NullPointerException if the transformer or the predicate is null\n */\npublic static <T> Predicate<T> transformedPredicate(final Transformer<? super T, ? extends T> transformer, final Predicate<? super T> predicate) {\n    if (transformer == null) {\n        throw new NullPointerException(\"The transformer to call must not be null\");\n    }\n    if (predicate == null) {\n        throw new NullPointerException(\"The predicate to call must not be null\");\n    }\n    return new TransformedPredicate<T>(transformer, predicate);\n}"
            ],
            [
                "nonePredicate",
                "org.apache.commons.collections4.functors",
                "NonePredicate",
                "/**\n * Factory to create the predicate.\n * <p>\n * If the array is size zero, the predicate always returns true.\n *\n * @param <T> the type that the predicate queries\n * @param predicates  the predicates to check, cloned, not null\n * @return the <code>any</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n */\npublic static <T> Predicate<T> nonePredicate(final Predicate<? super T>... predicates) {\n    FunctorUtils.validate(predicates);\n    if (predicates.length == 0) {\n        return TruePredicate.<T>truePredicate();\n    }\n    return new NonePredicate<T>(FunctorUtils.copy(predicates));\n}"
            ],
            [
                "nonePredicate",
                "org.apache.commons.collections4.functors",
                "NonePredicate",
                "/**\n * Factory to create the predicate.\n * <p>\n * If the collection is size zero, the predicate always returns true.\n *\n * @param <T> the type that the predicate queries\n * @param predicates  the predicates to check, cloned, not null\n * @return the <code>one</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n */\npublic static <T> Predicate<T> nonePredicate(final Collection<? extends Predicate<? super T>> predicates) {\n    final Predicate<? super T>[] preds = FunctorUtils.validate(predicates);\n    if (preds.length == 0) {\n        return TruePredicate.<T>truePredicate();\n    }\n    return new NonePredicate<T>(preds);\n}"
            ],
            [
                "exceptionTransformer",
                "org.apache.commons.collections4.functors",
                "ExceptionTransformer",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @return the singleton instance\n * @since 3.1\n */\n// the static instance works for all types\n@SuppressWarnings(\"unchecked\")\npublic static <I, O> Transformer<I, O> exceptionTransformer() {\n    return (Transformer<I, O>) INSTANCE;\n}"
            ],
            [
                "switchTransformer",
                "org.apache.commons.collections4.functors",
                "SwitchTransformer",
                "/**\n * Factory method that performs validation and copies the parameter arrays.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param predicates  array of predicates, cloned, no nulls\n * @param transformers  matching array of transformers, cloned, no nulls\n * @param defaultTransformer  the transformer to use if no match, null means return null\n * @return the <code>chained</code> transformer\n * @throws NullPointerException if array is null\n * @throws NullPointerException if any element in the array is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <I, O> Transformer<I, O> switchTransformer(final Predicate<? super I>[] predicates, final Transformer<? super I, ? extends O>[] transformers, final Transformer<? super I, ? extends O> defaultTransformer) {\n    FunctorUtils.validate(predicates);\n    FunctorUtils.validate(transformers);\n    if (predicates.length != transformers.length) {\n        throw new IllegalArgumentException(\"The predicate and transformer arrays must be the same size\");\n    }\n    if (predicates.length == 0) {\n        return (Transformer<I, O>) (defaultTransformer == null ? ConstantTransformer.<I, O>nullTransformer() : defaultTransformer);\n    }\n    return new SwitchTransformer<I, O>(predicates, transformers, defaultTransformer);\n}"
            ],
            [
                "switchTransformer",
                "org.apache.commons.collections4.functors",
                "SwitchTransformer",
                "/**\n * Create a new Transformer that calls one of the transformers depending\n * on the predicates.\n * <p>\n * The Map consists of Predicate keys and Transformer values. A transformer\n * is called if its matching predicate returns true. Each predicate is evaluated\n * until one returns true. If no predicates evaluate to true, the default\n * transformer is called. The default transformer is set in the map with a\n * null key. The ordering is that of the iterator() method on the entryset\n * collection of the map.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param map  a map of predicates to transformers\n * @return the <code>switch</code> transformer\n * @throws NullPointerException if the map is null\n * @throws NullPointerException if any transformer in the map is null\n * @throws ClassCastException  if the map elements are of the wrong type\n */\n@SuppressWarnings(\"unchecked\")\npublic static <I, O> Transformer<I, O> switchTransformer(final Map<? extends Predicate<? super I>, ? extends Transformer<? super I, ? extends O>> map) {\n    if (map == null) {\n        throw new NullPointerException(\"The predicate and transformer map must not be null\");\n    }\n    if (map.size() == 0) {\n        return ConstantTransformer.<I, O>nullTransformer();\n    }\n    // convert to array like this to guarantee iterator() ordering\n    final Transformer<? super I, ? extends O> defaultTransformer = map.remove(null);\n    final int size = map.size();\n    if (size == 0) {\n        return (Transformer<I, O>) (defaultTransformer == null ? ConstantTransformer.<I, O>nullTransformer() : defaultTransformer);\n    }\n    final Transformer<? super I, ? extends O>[] transformers = new Transformer[size];\n    final Predicate<? super I>[] preds = new Predicate[size];\n    int i = 0;\n    for (final Map.Entry<? extends Predicate<? super I>, ? extends Transformer<? super I, ? extends O>> entry : map.entrySet()) {\n        preds[i] = entry.getKey();\n        transformers[i] = entry.getValue();\n        i++;\n    }\n    return new SwitchTransformer<I, O>(false, preds, transformers, defaultTransformer);\n}"
            ],
            [
                "transformerClosure",
                "org.apache.commons.collections4.functors",
                "TransformerClosure",
                "/**\n * Factory method that performs validation.\n * <p>\n * A null transformer will return the <code>NOPClosure</code>.\n *\n * @param <E> the type that the closure acts on\n * @param transformer  the transformer to call, null means nop\n * @return the <code>transformer</code> closure\n */\npublic static <E> Closure<E> transformerClosure(final Transformer<? super E, ?> transformer) {\n    if (transformer == null) {\n        return NOPClosure.<E>nopClosure();\n    }\n    return new TransformerClosure<E>(transformer);\n}"
            ],
            [
                "orPredicate",
                "org.apache.commons.collections4.functors",
                "OrPredicate",
                "/**\n * Factory to create the predicate.\n *\n * @param <T> the type that the predicate queries\n * @param predicate1  the first predicate to check, not null\n * @param predicate2  the second predicate to check, not null\n * @return the <code>and</code> predicate\n * @throws NullPointerException if either predicate is null\n */\npublic static <T> Predicate<T> orPredicate(final Predicate<? super T> predicate1, final Predicate<? super T> predicate2) {\n    if (predicate1 == null || predicate2 == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    return new OrPredicate<T>(predicate1, predicate2);\n}"
            ],
            [
                "nopTransformer",
                "org.apache.commons.collections4.functors",
                "NOPTransformer",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <T>  the input/output type\n * @return the singleton instance\n * @since 3.1\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Transformer<T, T> nopTransformer() {\n    return (Transformer<T, T>) INSTANCE;\n}"
            ],
            [
                "mapTransformer",
                "org.apache.commons.collections4.functors",
                "MapTransformer",
                "/**\n * Factory to create the transformer.\n * <p>\n * If the map is null, a transformer that always returns null is returned.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param map the map, not cloned\n * @return the transformer\n */\npublic static <I, O> Transformer<I, O> mapTransformer(final Map<? super I, ? extends O> map) {\n    if (map == null) {\n        return ConstantTransformer.<I, O>nullTransformer();\n    }\n    return new MapTransformer<I, O>(map);\n}"
            ],
            [
                "exceptionFactory",
                "org.apache.commons.collections4.functors",
                "ExceptionFactory",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <T>  the type the factory creates\n * @return the singleton instance\n * @since 3.1\n */\n// the static instance works for all types\n@SuppressWarnings(\"unchecked\")\npublic static <T> Factory<T> exceptionFactory() {\n    return (Factory<T>) INSTANCE;\n}"
            ],
            [
                "chainedClosure",
                "org.apache.commons.collections4.functors",
                "ChainedClosure",
                "/**\n * Factory method that performs validation and copies the parameter array.\n *\n * @param <E> the type that the closure acts on\n * @param closures  the closures to chain, copied, no nulls\n * @return the <code>chained</code> closure\n * @throws NullPointerException if the closures array is null\n * @throws NullPointerException if any closure in the array is null\n */\npublic static <E> Closure<E> chainedClosure(final Closure<? super E>... closures) {\n    FunctorUtils.validate(closures);\n    if (closures.length == 0) {\n        return NOPClosure.<E>nopClosure();\n    }\n    return new ChainedClosure<E>(closures);\n}"
            ],
            [
                "chainedClosure",
                "org.apache.commons.collections4.functors",
                "ChainedClosure",
                "/**\n * Create a new Closure that calls each closure in turn, passing the\n * result into the next closure. The ordering is that of the iterator()\n * method on the collection.\n *\n * @param <E> the type that the closure acts on\n * @param closures  a collection of closures to chain\n * @return the <code>chained</code> closure\n * @throws NullPointerException if the closures collection is null\n * @throws NullPointerException if any closure in the collection is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Closure<E> chainedClosure(final Collection<? extends Closure<? super E>> closures) {\n    if (closures == null) {\n        throw new NullPointerException(\"Closure collection must not be null\");\n    }\n    if (closures.size() == 0) {\n        return NOPClosure.<E>nopClosure();\n    }\n    // convert to array like this to guarantee iterator() ordering\n    final Closure<? super E>[] cmds = new Closure[closures.size()];\n    int i = 0;\n    for (final Closure<? super E> closure : closures) {\n        cmds[i++] = closure;\n    }\n    FunctorUtils.validate(cmds);\n    return new ChainedClosure<E>(false, cmds);\n}"
            ],
            [
                "andPredicate",
                "org.apache.commons.collections4.functors",
                "AndPredicate",
                "/**\n * Factory to create the predicate.\n *\n * @param <T> the type that the predicate queries\n * @param predicate1  the first predicate to check, not null\n * @param predicate2  the second predicate to check, not null\n * @return the <code>and</code> predicate\n * @throws NullPointerException if either predicate is null\n */\npublic static <T> Predicate<T> andPredicate(final Predicate<? super T> predicate1, final Predicate<? super T> predicate2) {\n    if (predicate1 == null || predicate2 == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    return new AndPredicate<T>(predicate1, predicate2);\n}"
            ],
            [
                "prototypeFactory",
                "org.apache.commons.collections4.functors",
                "PrototypeFactory",
                "/**\n * Factory method that performs validation.\n * <p>\n * Creates a Factory that will return a clone of the same prototype object\n * each time the factory is used. The prototype will be cloned using one of these\n * techniques (in order):\n * <ul>\n * <li>public clone method\n * <li>public copy constructor\n * <li>serialization clone\n * <ul>\n *\n * @param <T>  the type the factory creates\n * @param prototype  the object to clone each time in the factory\n * @return the <code>prototype</code> factory, or a {@link ConstantFactory#NULL_INSTANCE} if\n * the {@code prototype} is {@code null}\n * @throws IllegalArgumentException if the prototype cannot be cloned\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Factory<T> prototypeFactory(final T prototype) {\n    if (prototype == null) {\n        return ConstantFactory.<T>constantFactory(null);\n    }\n    try {\n        final Method method = prototype.getClass().getMethod(\"clone\", (Class[]) null);\n        return new PrototypeCloneFactory<T>(prototype, method);\n    } catch (final NoSuchMethodException ex) {\n        try {\n            prototype.getClass().getConstructor(new Class<?>[] { prototype.getClass() });\n            return new InstantiateFactory<T>((Class<T>) prototype.getClass(), new Class<?>[] { prototype.getClass() }, new Object[] { prototype });\n        } catch (final NoSuchMethodException ex2) {\n            if (prototype instanceof Serializable) {\n                return (Factory<T>) new PrototypeSerializationFactory<Serializable>((Serializable) prototype);\n            }\n        }\n    }\n    throw new IllegalArgumentException(\"The prototype must be cloneable via a public clone method\");\n}"
            ],
            [
                "exceptionPredicate",
                "org.apache.commons.collections4.functors",
                "ExceptionPredicate",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <T>  the object type\n * @return the singleton instance\n * @since 3.1\n */\n// the static instance works for all types\n@SuppressWarnings(\"unchecked\")\npublic static <T> Predicate<T> exceptionPredicate() {\n    return (Predicate<T>) INSTANCE;\n}"
            ],
            [
                "instanceOfPredicate",
                "org.apache.commons.collections4.functors",
                "InstanceofPredicate",
                "/**\n * Factory to create the identity predicate.\n *\n * @param type  the type to check for, may not be null\n * @return the predicate\n * @throws NullPointerException if the class is null\n */\npublic static Predicate<Object> instanceOfPredicate(final Class<?> type) {\n    if (type == null) {\n        throw new NullPointerException(\"The type to check instanceof must not be null\");\n    }\n    return new InstanceofPredicate(type);\n}"
            ],
            [
                "invokerTransformer",
                "org.apache.commons.collections4.functors",
                "InvokerTransformer",
                "/**\n * Gets an instance of this transformer calling a specific method with no arguments.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param methodName  the method name to call\n * @return an invoker transformer\n * @throws NullPointerException if methodName is null\n * @since 3.1\n */\npublic static <I, O> Transformer<I, O> invokerTransformer(final String methodName) {\n    if (methodName == null) {\n        throw new NullPointerException(\"The method to invoke must not be null\");\n    }\n    return new InvokerTransformer<I, O>(methodName);\n}"
            ],
            [
                "invokerTransformer",
                "org.apache.commons.collections4.functors",
                "InvokerTransformer",
                "/**\n * Gets an instance of this transformer calling a specific method with specific values.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param methodName  the method name to call\n * @param paramTypes  the parameter types of the method\n * @param args  the arguments to pass to the method\n * @return an invoker transformer\n * @throws NullPointerException if methodName is null\n * @throws IllegalArgumentException if paramTypes does not match args\n */\npublic static <I, O> Transformer<I, O> invokerTransformer(final String methodName, final Class<?>[] paramTypes, final Object[] args) {\n    if (methodName == null) {\n        throw new NullPointerException(\"The method to invoke must not be null\");\n    }\n    if (((paramTypes == null) && (args != null)) || ((paramTypes != null) && (args == null)) || ((paramTypes != null) && (args != null) && (paramTypes.length != args.length))) {\n        throw new IllegalArgumentException(\"The parameter types must match the arguments\");\n    }\n    if (paramTypes == null || paramTypes.length == 0) {\n        return new InvokerTransformer<I, O>(methodName);\n    }\n    return new InvokerTransformer<I, O>(methodName, paramTypes, args);\n}"
            ],
            [
                "falsePredicate",
                "org.apache.commons.collections4.functors",
                "FalsePredicate",
                "/**\n * Get a typed instance.\n *\n * @param <T> the type that the predicate queries\n * @return the singleton instance\n * @since 4.0\n */\n// the static instance works for all types\n@SuppressWarnings(\"unchecked\")\npublic static <T> Predicate<T> falsePredicate() {\n    return (Predicate<T>) INSTANCE;\n}"
            ],
            [
                "cloneTransformer",
                "org.apache.commons.collections4.functors",
                "CloneTransformer",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <T>  the type of the objects to be cloned\n * @return the singleton instance\n * @since 3.1\n */\n// the singleton instance works for all types\n@SuppressWarnings(\"unchecked\")\npublic static <T> Transformer<T, T> cloneTransformer() {\n    return INSTANCE;\n}"
            ],
            [
                "notPredicate",
                "org.apache.commons.collections4.functors",
                "NotPredicate",
                "/**\n * Factory to create the not predicate.\n *\n * @param <T> the type that the predicate queries\n * @param predicate  the predicate to decorate, not null\n * @return the predicate\n * @throws NullPointerException if the predicate is null\n */\npublic static <T> Predicate<T> notPredicate(final Predicate<? super T> predicate) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    return new NotPredicate<T>(predicate);\n}"
            ],
            [
                "constantFactory",
                "org.apache.commons.collections4.functors",
                "ConstantFactory",
                "/**\n * Factory method that performs validation.\n *\n * @param <T>  the type of the constant\n * @param constantToReturn  the constant object to return each time in the factory\n * @return the <code>constant</code> factory.\n */\n// The null factory works for all object types\n@SuppressWarnings(\"unchecked\")\npublic static <T> Factory<T> constantFactory(final T constantToReturn) {\n    if (constantToReturn == null) {\n        return (Factory<T>) NULL_INSTANCE;\n    }\n    return new ConstantFactory<T>(constantToReturn);\n}"
            ],
            [
                "chainedTransformer",
                "org.apache.commons.collections4.functors",
                "ChainedTransformer",
                "/**\n * Factory method that performs validation and copies the parameter array.\n *\n * @param <T>  the object type\n * @param transformers  the transformers to chain, copied, no nulls\n * @return the <code>chained</code> transformer\n * @throws NullPointerException if the transformers array is null\n * @throws NullPointerException if any transformer in the array is null\n */\npublic static <T> Transformer<T, T> chainedTransformer(final Transformer<? super T, ? extends T>... transformers) {\n    FunctorUtils.validate(transformers);\n    if (transformers.length == 0) {\n        return NOPTransformer.<T>nopTransformer();\n    }\n    return new ChainedTransformer<T>(transformers);\n}"
            ],
            [
                "chainedTransformer",
                "org.apache.commons.collections4.functors",
                "ChainedTransformer",
                "/**\n * Create a new Transformer that calls each transformer in turn, passing the\n * result into the next transformer. The ordering is that of the iterator()\n * method on the collection.\n *\n * @param <T>  the object type\n * @param transformers  a collection of transformers to chain\n * @return the <code>chained</code> transformer\n * @throws NullPointerException if the transformers collection is null\n * @throws NullPointerException if any transformer in the collection is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Transformer<T, T> chainedTransformer(final Collection<? extends Transformer<? super T, ? extends T>> transformers) {\n    if (transformers == null) {\n        throw new NullPointerException(\"Transformer collection must not be null\");\n    }\n    if (transformers.size() == 0) {\n        return NOPTransformer.<T>nopTransformer();\n    }\n    // convert to array like this to guarantee iterator() ordering\n    final Transformer<T, T>[] cmds = transformers.toArray(new Transformer[transformers.size()]);\n    FunctorUtils.validate(cmds);\n    return new ChainedTransformer<T>(false, cmds);\n}"
            ],
            [
                "comparatorPredicate",
                "org.apache.commons.collections4.functors",
                "ComparatorPredicate",
                "/**\n * Factory to create the comparator predicate\n *\n * @param <T> the type that the predicate queries\n * @param object  the object to compare to\n * @param comparator  the comparator to use for comparison\n * @return the predicate\n * @throws NullPointerException if comparator is null\n */\npublic static <T> Predicate<T> comparatorPredicate(final T object, final Comparator<T> comparator) {\n    return comparatorPredicate(object, comparator, Criterion.EQUAL);\n}"
            ],
            [
                "comparatorPredicate",
                "org.apache.commons.collections4.functors",
                "ComparatorPredicate",
                "/**\n * Factory to create the comparator predicate\n *\n * @param <T> the type that the predicate queries\n * @param object  the object to compare to\n * @param comparator  the comparator to use for comparison\n * @param criterion  the criterion to use to evaluate comparison\n * @return the predicate\n * @throws NullPointerException if comparator or criterion is null\n */\npublic static <T> Predicate<T> comparatorPredicate(final T object, final Comparator<T> comparator, final Criterion criterion) {\n    if (comparator == null) {\n        throw new NullPointerException(\"Comparator must not be null.\");\n    }\n    if (criterion == null) {\n        throw new NullPointerException(\"Criterion must not be null.\");\n    }\n    return new ComparatorPredicate<T>(object, comparator, criterion);\n}"
            ],
            [
                "allPredicate",
                "org.apache.commons.collections4.functors",
                "AllPredicate",
                "/**\n * Factory to create the predicate.\n * <p>\n * If the array is size zero, the predicate always returns true.\n * If the array is size one, then that predicate is returned.\n *\n * @param <T> the type that the predicate queries\n * @param predicates  the predicates to check, cloned, not null\n * @return the <code>all</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n */\npublic static <T> Predicate<T> allPredicate(final Predicate<? super T>... predicates) {\n    FunctorUtils.validate(predicates);\n    if (predicates.length == 0) {\n        return truePredicate();\n    }\n    if (predicates.length == 1) {\n        return coerce(predicates[0]);\n    }\n    return new AllPredicate<T>(FunctorUtils.copy(predicates));\n}"
            ],
            [
                "allPredicate",
                "org.apache.commons.collections4.functors",
                "AllPredicate",
                "/**\n * Factory to create the predicate.\n * <p>\n * If the collection is size zero, the predicate always returns true.\n * If the collection is size one, then that predicate is returned.\n *\n * @param <T> the type that the predicate queries\n * @param predicates  the predicates to check, cloned, not null\n * @return the <code>all</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n */\npublic static <T> Predicate<T> allPredicate(final Collection<? extends Predicate<? super T>> predicates) {\n    final Predicate<? super T>[] preds = validate(predicates);\n    if (preds.length == 0) {\n        return truePredicate();\n    }\n    if (preds.length == 1) {\n        return coerce(preds[0]);\n    }\n    return new AllPredicate<T>(preds);\n}"
            ],
            [
                "nullIsFalsePredicate",
                "org.apache.commons.collections4.functors",
                "NullIsFalsePredicate",
                "/**\n * Factory to create the null false predicate.\n *\n * @param <T> the type that the predicate queries\n * @param predicate  the predicate to decorate, not null\n * @return the predicate\n * @throws NullPointerException if the predicate is null\n */\npublic static <T> Predicate<T> nullIsFalsePredicate(final Predicate<? super T> predicate) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    return new NullIsFalsePredicate<T>(predicate);\n}"
            ],
            [
                "nullIsExceptionPredicate",
                "org.apache.commons.collections4.functors",
                "NullIsExceptionPredicate",
                "/**\n * Factory to create the null exception predicate.\n *\n * @param <T> the type that the predicate queries\n * @param predicate  the predicate to decorate, not null\n * @return the predicate\n * @throws NullPointerException if the predicate is null\n */\npublic static <T> Predicate<T> nullIsExceptionPredicate(final Predicate<? super T> predicate) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    return new NullIsExceptionPredicate<T>(predicate);\n}"
            ],
            [
                "anyPredicate",
                "org.apache.commons.collections4.functors",
                "AnyPredicate",
                "/**\n * Factory to create the predicate.\n * <p>\n * If the array is size zero, the predicate always returns false.\n * If the array is size one, then that predicate is returned.\n *\n * @param <T> the type that the predicate queries\n * @param predicates  the predicates to check, cloned, not null\n * @return the <code>any</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Predicate<T> anyPredicate(final Predicate<? super T>... predicates) {\n    FunctorUtils.validate(predicates);\n    if (predicates.length == 0) {\n        return FalsePredicate.<T>falsePredicate();\n    }\n    if (predicates.length == 1) {\n        return (Predicate<T>) predicates[0];\n    }\n    return new AnyPredicate<T>(FunctorUtils.copy(predicates));\n}"
            ],
            [
                "anyPredicate",
                "org.apache.commons.collections4.functors",
                "AnyPredicate",
                "/**\n * Factory to create the predicate.\n * <p>\n * If the collection is size zero, the predicate always returns false.\n * If the collection is size one, then that predicate is returned.\n *\n * @param <T> the type that the predicate queries\n * @param predicates  the predicates to check, cloned, not null\n * @return the <code>all</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Predicate<T> anyPredicate(final Collection<? extends Predicate<? super T>> predicates) {\n    final Predicate<? super T>[] preds = FunctorUtils.validate(predicates);\n    if (preds.length == 0) {\n        return FalsePredicate.<T>falsePredicate();\n    }\n    if (preds.length == 1) {\n        return (Predicate<T>) preds[0];\n    }\n    return new AnyPredicate<T>(preds);\n}"
            ],
            [
                "truePredicate",
                "org.apache.commons.collections4.functors",
                "TruePredicate",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <T> the type that the predicate queries\n * @return the singleton instance\n * @since 3.1\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Predicate<T> truePredicate() {\n    return (Predicate<T>) INSTANCE;\n}"
            ],
            [
                "factoryTransformer",
                "org.apache.commons.collections4.functors",
                "FactoryTransformer",
                "/**\n * Factory method that performs validation.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param factory  the factory to call, not null\n * @return the <code>factory</code> transformer\n * @throws NullPointerException if the factory is null\n */\npublic static <I, O> Transformer<I, O> factoryTransformer(final Factory<? extends O> factory) {\n    if (factory == null) {\n        throw new NullPointerException(\"Factory must not be null\");\n    }\n    return new FactoryTransformer<I, O>(factory);\n}"
            ],
            [
                "notNullPredicate",
                "org.apache.commons.collections4.functors",
                "NotNullPredicate",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <T> the type that the predicate queries\n * @return the singleton instance\n * @since 3.1\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Predicate<T> notNullPredicate() {\n    return (Predicate<T>) INSTANCE;\n}"
            ],
            [
                "switchClosure",
                "org.apache.commons.collections4.functors",
                "SwitchClosure",
                "/**\n * Factory method that performs validation and copies the parameter arrays.\n *\n * @param <E> the type that the closure acts on\n * @param predicates  array of predicates, cloned, no nulls\n * @param closures  matching array of closures, cloned, no nulls\n * @param defaultClosure  the closure to use if no match, null means nop\n * @return the <code>chained</code> closure\n * @throws NullPointerException if array is null\n * @throws NullPointerException if any element in the array is null\n * @throws IllegalArgumentException if the array lengths of predicates and closures do not match\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Closure<E> switchClosure(final Predicate<? super E>[] predicates, final Closure<? super E>[] closures, final Closure<? super E> defaultClosure) {\n    FunctorUtils.validate(predicates);\n    FunctorUtils.validate(closures);\n    if (predicates.length != closures.length) {\n        throw new IllegalArgumentException(\"The predicate and closure arrays must be the same size\");\n    }\n    if (predicates.length == 0) {\n        return (Closure<E>) (defaultClosure == null ? NOPClosure.<E>nopClosure() : defaultClosure);\n    }\n    return new SwitchClosure<E>(predicates, closures, defaultClosure);\n}"
            ],
            [
                "switchClosure",
                "org.apache.commons.collections4.functors",
                "SwitchClosure",
                "/**\n * Create a new Closure that calls one of the closures depending\n * on the predicates.\n * <p>\n * The Map consists of Predicate keys and Closure values. A closure\n * is called if its matching predicate returns true. Each predicate is evaluated\n * until one returns true. If no predicates evaluate to true, the default\n * closure is called. The default closure is set in the map with a\n * null key. The ordering is that of the iterator() method on the entryset\n * collection of the map.\n *\n * @param <E> the type that the closure acts on\n * @param predicatesAndClosures  a map of predicates to closures\n * @return the <code>switch</code> closure\n * @throws NullPointerException if the map is null\n * @throws NullPointerException if any closure in the map is null\n * @throws ClassCastException  if the map elements are of the wrong type\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Closure<E> switchClosure(final Map<Predicate<E>, Closure<E>> predicatesAndClosures) {\n    if (predicatesAndClosures == null) {\n        throw new NullPointerException(\"The predicate and closure map must not be null\");\n    }\n    // convert to array like this to guarantee iterator() ordering\n    final Closure<? super E> defaultClosure = predicatesAndClosures.remove(null);\n    final int size = predicatesAndClosures.size();\n    if (size == 0) {\n        return (Closure<E>) (defaultClosure == null ? NOPClosure.<E>nopClosure() : defaultClosure);\n    }\n    final Closure<E>[] closures = new Closure[size];\n    final Predicate<E>[] preds = new Predicate[size];\n    int i = 0;\n    for (final Map.Entry<Predicate<E>, Closure<E>> entry : predicatesAndClosures.entrySet()) {\n        preds[i] = entry.getKey();\n        closures[i] = entry.getValue();\n        i++;\n    }\n    return new SwitchClosure<E>(false, preds, closures, defaultClosure);\n}"
            ],
            [
                "uniquePredicate",
                "org.apache.commons.collections4.functors",
                "UniquePredicate",
                "/**\n * Factory to create the predicate.\n *\n * @param <T> the type that the predicate queries\n * @return the predicate\n * @throws IllegalArgumentException if the predicate is null\n */\npublic static <T> Predicate<T> uniquePredicate() {\n    return new UniquePredicate<T>();\n}"
            ],
            [
                "instantiateTransformer",
                "org.apache.commons.collections4.functors",
                "InstantiateTransformer",
                "/**\n * Get a typed no-arg instance.\n *\n * @param <T>  the type of the objects to be created\n * @return Transformer<Class<? extends T>, T>\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Transformer<Class<? extends T>, T> instantiateTransformer() {\n    return NO_ARG_INSTANCE;\n}"
            ],
            [
                "instantiateTransformer",
                "org.apache.commons.collections4.functors",
                "InstantiateTransformer",
                "/**\n * Transformer method that performs validation.\n *\n * @param <T>  the type of the objects to be created\n * @param paramTypes  the constructor parameter types\n * @param args  the constructor arguments\n * @return an instantiate transformer\n * @throws IllegalArgumentException if paramTypes does not match args\n */\npublic static <T> Transformer<Class<? extends T>, T> instantiateTransformer(final Class<?>[] paramTypes, final Object[] args) {\n    if (((paramTypes == null) && (args != null)) || ((paramTypes != null) && (args == null)) || ((paramTypes != null) && (args != null) && (paramTypes.length != args.length))) {\n        throw new IllegalArgumentException(\"Parameter types must match the arguments\");\n    }\n    if (paramTypes == null || paramTypes.length == 0) {\n        return new InstantiateTransformer<T>();\n    }\n    return new InstantiateTransformer<T>(paramTypes, args);\n}"
            ],
            [
                "onePredicate",
                "org.apache.commons.collections4.functors",
                "OnePredicate",
                "/**\n * Factory to create the predicate.\n * <p>\n * If the array is size zero, the predicate always returns false.\n * If the array is size one, then that predicate is returned.\n *\n * @param <T> the type that the predicate queries\n * @param predicates  the predicates to check, cloned, not null\n * @return the <code>any</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Predicate<T> onePredicate(final Predicate<? super T>... predicates) {\n    FunctorUtils.validate(predicates);\n    if (predicates.length == 0) {\n        return FalsePredicate.<T>falsePredicate();\n    }\n    if (predicates.length == 1) {\n        return (Predicate<T>) predicates[0];\n    }\n    return new OnePredicate<T>(FunctorUtils.copy(predicates));\n}"
            ],
            [
                "onePredicate",
                "org.apache.commons.collections4.functors",
                "OnePredicate",
                "/**\n * Factory to create the predicate.\n *\n * @param <T> the type that the predicate queries\n * @param predicates  the predicates to check, cloned, not null\n * @return the <code>one</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n */\npublic static <T> Predicate<T> onePredicate(final Collection<? extends Predicate<? super T>> predicates) {\n    final Predicate<? super T>[] preds = FunctorUtils.validate(predicates);\n    return new OnePredicate<T>(preds);\n}"
            ],
            [
                "equalPredicate",
                "org.apache.commons.collections4.functors",
                "EqualPredicate",
                "/**\n * Factory to create the predicate.\n *\n * @param <T> the type that the predicate queries\n * @param object  the object to compare to\n * @return the predicate\n */\npublic static <T> Predicate<T> equalPredicate(final T object) {\n    if (object == null) {\n        return NullPredicate.nullPredicate();\n    }\n    return new EqualPredicate<T>(object);\n}"
            ],
            [
                "equalPredicate",
                "org.apache.commons.collections4.functors",
                "EqualPredicate",
                "/**\n * Factory to create the identity predicate.\n *\n * @param <T> the type that the predicate queries\n * @param object  the object to compare to\n * @param equator  the equator to use for comparison\n * @return the predicate\n * @since 4.0\n */\npublic static <T> Predicate<T> equalPredicate(final T object, final Equator<T> equator) {\n    if (object == null) {\n        return NullPredicate.nullPredicate();\n    }\n    return new EqualPredicate<T>(object, equator);\n}"
            ],
            [
                "instantiateFactory",
                "org.apache.commons.collections4.functors",
                "InstantiateFactory",
                "/**\n * Factory method that performs validation.\n *\n * @param <T>  the type the factory creates\n * @param classToInstantiate  the class to instantiate, not null\n * @param paramTypes  the constructor parameter types, cloned\n * @param args  the constructor arguments, cloned\n * @return a new instantiate factory\n * @throws NullPointerException if classToInstantiate is null\n * @throws IllegalArgumentException if paramTypes does not match args\n */\npublic static <T> Factory<T> instantiateFactory(final Class<T> classToInstantiate, final Class<?>[] paramTypes, final Object[] args) {\n    if (classToInstantiate == null) {\n        throw new NullPointerException(\"Class to instantiate must not be null\");\n    }\n    if (paramTypes == null && args != null || paramTypes != null && args == null || paramTypes != null && args != null && paramTypes.length != args.length) {\n        throw new IllegalArgumentException(\"Parameter types must match the arguments\");\n    }\n    if (paramTypes == null || paramTypes.length == 0) {\n        return new InstantiateFactory<T>(classToInstantiate);\n    }\n    return new InstantiateFactory<T>(classToInstantiate, paramTypes, args);\n}"
            ],
            [
                "ifClosure",
                "org.apache.commons.collections4.functors",
                "IfClosure",
                "/**\n * Factory method that performs validation.\n * <p>\n * This factory creates a closure that performs no action when\n * the predicate is false.\n *\n * @param <E> the type that the closure acts on\n * @param predicate  predicate to switch on\n * @param trueClosure  closure used if true\n * @return the <code>if</code> closure\n * @throws NullPointerException if either argument is null\n * @since 3.2\n */\npublic static <E> Closure<E> ifClosure(final Predicate<? super E> predicate, final Closure<? super E> trueClosure) {\n    return IfClosure.<E>ifClosure(predicate, trueClosure, NOPClosure.<E>nopClosure());\n}"
            ],
            [
                "ifClosure",
                "org.apache.commons.collections4.functors",
                "IfClosure",
                "/**\n * Factory method that performs validation.\n *\n * @param <E> the type that the closure acts on\n * @param predicate  predicate to switch on\n * @param trueClosure  closure used if true\n * @param falseClosure  closure used if false\n * @return the <code>if</code> closure\n * @throws NullPointerException if any argument is null\n */\npublic static <E> Closure<E> ifClosure(final Predicate<? super E> predicate, final Closure<? super E> trueClosure, final Closure<? super E> falseClosure) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    if (trueClosure == null || falseClosure == null) {\n        throw new NullPointerException(\"Closures must not be null\");\n    }\n    return new IfClosure<E>(predicate, trueClosure, falseClosure);\n}"
            ],
            [
                "getTrueFirstComparator",
                "org.apache.commons.collections4.comparators",
                "BooleanComparator",
                "//-----------------------------------------------------------------------\n/**\n * Returns a BooleanComparator instance that sorts\n * <code>true</code> values before <code>false</code> values.\n * <p />\n * Clients are encouraged to use the value returned from\n * this method instead of constructing a new instance\n * to reduce allocation and garbage collection overhead when\n * multiple BooleanComparators may be used in the same\n * virtual machine.\n *\n * @return the true first singleton BooleanComparator\n */\npublic static BooleanComparator getTrueFirstComparator() {\n    return TRUE_FIRST;\n}"
            ],
            [
                "getFalseFirstComparator",
                "org.apache.commons.collections4.comparators",
                "BooleanComparator",
                "/**\n * Returns a BooleanComparator instance that sorts\n * <code>false</code> values before <code>true</code> values.\n * <p />\n * Clients are encouraged to use the value returned from\n * this method instead of constructing a new instance\n * to reduce allocation and garbage collection overhead when\n * multiple BooleanComparators may be used in the same\n * virtual machine.\n *\n * @return the false first singleton BooleanComparator\n */\npublic static BooleanComparator getFalseFirstComparator() {\n    return FALSE_FIRST;\n}"
            ],
            [
                "booleanComparator",
                "org.apache.commons.collections4.comparators",
                "BooleanComparator",
                "/**\n * Returns a BooleanComparator instance that sorts\n * <code><i>trueFirst</i></code> values before\n * <code>&#x21;<i>trueFirst</i></code> values.\n * <p />\n * Clients are encouraged to use the value returned from\n * this method instead of constructing a new instance\n * to reduce allocation and garbage collection overhead when\n * multiple BooleanComparators may be used in the same\n * virtual machine.\n *\n * @param trueFirst when <code>true</code>, sort\n * <code>true</code> <code>Boolean</code>s before <code>false</code>\n * @return a singleton BooleanComparator instance\n * @since 4.0\n */\npublic static BooleanComparator booleanComparator(final boolean trueFirst) {\n    return trueFirst ? TRUE_FIRST : FALSE_FIRST;\n}"
            ],
            [
                "comparableComparator",
                "org.apache.commons.collections4.comparators",
                "ComparableComparator",
                "//-----------------------------------------------------------------------\n/**\n * Gets the singleton instance of a ComparableComparator.\n * <p>\n * Developers are encouraged to use the comparator returned from this method\n * instead of constructing a new instance to reduce allocation and GC overhead\n * when multiple comparable comparators may be used in the same VM.\n *\n * @param <E>  the element type\n * @return the singleton ComparableComparator\n * @since 4.0\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E extends Comparable<? super E>> ComparableComparator<E> comparableComparator() {\n    return INSTANCE;\n}"
            ],
            [
                "emptyCollection",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns the immutable EMPTY_COLLECTION with generic type safety.\n *\n * @see #EMPTY_COLLECTION\n * @since 4.0\n * @param <T> the element type\n * @return immutable empty collection\n */\n// OK, empty collection is compatible with any type\n@SuppressWarnings(\"unchecked\")\npublic static <T> Collection<T> emptyCollection() {\n    return EMPTY_COLLECTION;\n}"
            ],
            [
                "emptyIfNull",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns an immutable empty collection if the argument is <code>null</code>,\n * or the argument itself otherwise.\n *\n * @param <T> the element type\n * @param collection the collection, possibly <code>null</code>\n * @return an empty collection if the argument is <code>null</code>\n */\n// OK, empty collection is compatible with any type\n@SuppressWarnings(\"unchecked\")\npublic static <T> Collection<T> emptyIfNull(final Collection<T> collection) {\n    return collection == null ? EMPTY_COLLECTION : collection;\n}"
            ],
            [
                "union",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns a {@link Collection} containing the union of the given\n * {@link Iterable}s.\n * <p>\n * The cardinality of each element in the returned {@link Collection} will\n * be equal to the maximum of the cardinality of that element in the two\n * given {@link Iterable}s.\n *\n * @param a the first collection, must not be null\n * @param b the second collection, must not be null\n * @param <O> the generic type that is able to represent the types contained\n *        in both input collections.\n * @return the union of the two collections\n * @see Collection#addAll\n */\npublic static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}"
            ],
            [
                "intersection",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns a {@link Collection} containing the intersection of the given\n * {@link Iterable}s.\n * <p>\n * The cardinality of each element in the returned {@link Collection} will\n * be equal to the minimum of the cardinality of that element in the two\n * given {@link Iterable}s.\n *\n * @param a the first collection, must not be null\n * @param b the second collection, must not be null\n * @param <O> the generic type that is able to represent the types contained\n *        in both input collections.\n * @return the intersection of the two collections\n * @see Collection#retainAll\n * @see #containsAny\n */\npublic static <O> Collection<O> intersection(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.min(obj));\n    }\n    return helper.list();\n}"
            ],
            [
                "disjunction",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns a {@link Collection} containing the exclusive disjunction\n * (symmetric difference) of the given {@link Iterable}s.\n * <p>\n * The cardinality of each element <i>e</i> in the returned\n * {@link Collection} will be equal to\n * <tt>max(cardinality(<i>e</i>,<i>a</i>),cardinality(<i>e</i>,<i>b</i>)) - min(cardinality(<i>e</i>,<i>a</i>),\n * cardinality(<i>e</i>,<i>b</i>))</tt>.\n * <p>\n * This is equivalent to\n * {@code {@link #subtract subtract}({@link #union union(a,b)},{@link #intersection intersection(a,b)})}\n * or\n * {@code {@link #union union}({@link #subtract subtract(a,b)},{@link #subtract subtract(b,a)})}.\n *\n * @param a the first collection, must not be null\n * @param b the second collection, must not be null\n * @param <O> the generic type that is able to represent the types contained\n *        in both input collections.\n * @return the symmetric difference of the two collections\n */\npublic static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}"
            ],
            [
                "subtract",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns a new {@link Collection} containing {@code <i>a</i> - <i>b</i>}.\n * The cardinality of each element <i>e</i> in the returned {@link Collection}\n * will be the cardinality of <i>e</i> in <i>a</i> minus the cardinality\n * of <i>e</i> in <i>b</i>, or zero, whichever is greater.\n *\n * @param a  the collection to subtract from, must not be null\n * @param b  the collection to subtract, must not be null\n * @param <O> the generic type that is able to represent the types contained\n *        in both input collections.\n * @return a new collection with the results\n * @see Collection#removeAll\n */\npublic static <O> Collection<O> subtract(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n    final Predicate<O> p = TruePredicate.truePredicate();\n    return subtract(a, b, p);\n}"
            ],
            [
                "subtract",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns a new {@link Collection} containing <i>a</i> minus a subset of\n * <i>b</i>.  Only the elements of <i>b</i> that satisfy the predicate\n * condition, <i>p</i> are subtracted from <i>a</i>.\n *\n * <p>The cardinality of each element <i>e</i> in the returned {@link Collection}\n * that satisfies the predicate condition will be the cardinality of <i>e</i> in <i>a</i>\n * minus the cardinality of <i>e</i> in <i>b</i>, or zero, whichever is greater.</p>\n * <p>The cardinality of each element <i>e</i> in the returned {@link Collection} that does <b>not</b>\n * satisfy the predicate condition will be equal to the cardinality of <i>e</i> in <i>a</i>.</p>\n *\n * @param a  the collection to subtract from, must not be null\n * @param b  the collection to subtract, must not be null\n * @param p  the condition used to determine which elements of <i>b</i> are\n *        subtracted.\n * @param <O> the generic type that is able to represent the types contained\n *        in both input collections.\n * @return a new collection with the results\n * @since 4.0\n * @see Collection#removeAll\n */\npublic static <O> Collection<O> subtract(final Iterable<? extends O> a, final Iterable<? extends O> b, final Predicate<O> p) {\n    final ArrayList<O> list = new ArrayList<O>();\n    final HashBag<O> bag = new HashBag<O>();\n    for (final O element : b) {\n        if (p.evaluate(element)) {\n            bag.add(element);\n        }\n    }\n    for (final O element : a) {\n        if (!bag.remove(element, 1)) {\n            list.add(element);\n        }\n    }\n    return list;\n}"
            ],
            [
                "containsAll",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns <code>true</code> iff all elements of {@code coll2} are also contained\n * in {@code coll1}. The cardinality of values in {@code coll2} is not taken into account,\n * which is the same behavior as {@link Collection#containsAll(Collection)}.\n * <p>\n * In other words, this method returns <code>true</code> iff the\n * {@link #intersection} of <i>coll1</i> and <i>coll2</i> has the same cardinality as\n * the set of unique values from {@code coll2}. In case {@code coll2} is empty, {@code true}\n * will be returned.\n * <p>\n * This method is intended as a replacement for {@link Collection#containsAll(Collection)}\n * with a guaranteed runtime complexity of {@code O(n + m)}. Depending on the type of\n * {@link Collection} provided, this method will be much faster than calling\n * {@link Collection#containsAll(Collection)} instead, though this will come at the\n * cost of an additional space complexity O(n).\n *\n * @param coll1  the first collection, must not be null\n * @param coll2  the second collection, must not be null\n * @return <code>true</code> iff the intersection of the collections has the same cardinality\n *   as the set of unique elements from the second collection\n * @since 4.0\n */\npublic static boolean containsAll(final Collection<?> coll1, final Collection<?> coll2) {\n    if (coll2.isEmpty()) {\n        return true;\n    } else {\n        final Iterator<?> it = coll1.iterator();\n        final Set<Object> elementsAlreadySeen = new HashSet<Object>();\n        for (final Object nextElement : coll2) {\n            if (elementsAlreadySeen.contains(nextElement)) {\n                continue;\n            }\n            boolean foundCurrentElement = false;\n            while (it.hasNext()) {\n                final Object p = it.next();\n                elementsAlreadySeen.add(p);\n                if (nextElement == null ? p == null : nextElement.equals(p)) {\n                    foundCurrentElement = true;\n                    break;\n                }\n            }\n            if (foundCurrentElement) {\n                continue;\n            } else {\n                return false;\n            }\n        }\n        return true;\n    }\n}"
            ],
            [
                "containsAny",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns <code>true</code> iff at least one element is in both collections.\n * <p>\n * In other words, this method returns <code>true</code> iff the\n * {@link #intersection} of <i>coll1</i> and <i>coll2</i> is not empty.\n *\n * @param coll1  the first collection, must not be null\n * @param coll2  the second collection, must not be null\n * @return <code>true</code> iff the intersection of the collections is non-empty\n * @since 2.1\n * @see #intersection\n */\npublic static boolean containsAny(final Collection<?> coll1, final Collection<?> coll2) {\n    if (coll1.size() < coll2.size()) {\n        for (final Object aColl1 : coll1) {\n            if (coll2.contains(aColl1)) {\n                return true;\n            }\n        }\n    } else {\n        for (final Object aColl2 : coll2) {\n            if (coll1.contains(aColl2)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}"
            ],
            [
                "getCardinalityMap",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns a {@link Map} mapping each unique element in the given\n * {@link Collection} to an {@link Integer} representing the number\n * of occurrences of that element in the {@link Collection}.\n * <p>\n * Only those elements present in the collection will appear as\n * keys in the map.\n *\n * @param <O>  the type of object in the returned {@link Map}. This is a super type of <I>.\n * @param coll  the collection to get the cardinality map for, must not be null\n * @return the populated cardinality map\n */\npublic static <O> Map<O, Integer> getCardinalityMap(final Iterable<? extends O> coll) {\n    final Map<O, Integer> count = new HashMap<O, Integer>();\n    for (final O obj : coll) {\n        final Integer c = count.get(obj);\n        if (c == null) {\n            count.put(obj, Integer.valueOf(1));\n        } else {\n            count.put(obj, Integer.valueOf(c.intValue() + 1));\n        }\n    }\n    return count;\n}"
            ],
            [
                "isSubCollection",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns {@code true} iff <i>a</i> is a sub-collection of <i>b</i>,\n * that is, iff the cardinality of <i>e</i> in <i>a</i> is less than or\n * equal to the cardinality of <i>e</i> in <i>b</i>, for each element <i>e</i>\n * in <i>a</i>.\n *\n * @param a the first (sub?) collection, must not be null\n * @param b the second (super?) collection, must not be null\n * @return <code>true</code> iff <i>a</i> is a sub-collection of <i>b</i>\n * @see #isProperSubCollection\n * @see Collection#containsAll\n */\npublic static boolean isSubCollection(final Collection<?> a, final Collection<?> b) {\n    final CardinalityHelper<Object> helper = new CardinalityHelper<Object>(a, b);\n    for (final Object obj : a) {\n        if (helper.freqA(obj) > helper.freqB(obj)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isProperSubCollection",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns {@code true} iff <i>a</i> is a <i>proper</i> sub-collection of <i>b</i>,\n * that is, iff the cardinality of <i>e</i> in <i>a</i> is less\n * than or equal to the cardinality of <i>e</i> in <i>b</i>,\n * for each element <i>e</i> in <i>a</i>, and there is at least one\n * element <i>f</i> such that the cardinality of <i>f</i> in <i>b</i>\n * is strictly greater than the cardinality of <i>f</i> in <i>a</i>.\n * <p>\n * The implementation assumes\n * <ul>\n *    <li><code>a.size()</code> and <code>b.size()</code> represent the\n *    total cardinality of <i>a</i> and <i>b</i>, resp. </li>\n *    <li><code>a.size() < Integer.MAXVALUE</code></li>\n * </ul>\n *\n * @param a  the first (sub?) collection, must not be null\n * @param b  the second (super?) collection, must not be null\n * @return <code>true</code> iff <i>a</i> is a <i>proper</i> sub-collection of <i>b</i>\n * @see #isSubCollection\n * @see Collection#containsAll\n */\npublic static boolean isProperSubCollection(final Collection<?> a, final Collection<?> b) {\n    return a.size() < b.size() && CollectionUtils.isSubCollection(a, b);\n}"
            ],
            [
                "isEqualCollection",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns {@code true} iff the given {@link Collection}s contain\n * exactly the same elements with exactly the same cardinalities.\n * <p>\n * That is, iff the cardinality of <i>e</i> in <i>a</i> is\n * equal to the cardinality of <i>e</i> in <i>b</i>,\n * for each element <i>e</i> in <i>a</i> or <i>b</i>.\n *\n * @param a  the first collection, must not be null\n * @param b  the second collection, must not be null\n * @return <code>true</code> iff the collections contain the same elements with the same cardinalities.\n */\npublic static boolean isEqualCollection(final Collection<?> a, final Collection<?> b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n    final CardinalityHelper<Object> helper = new CardinalityHelper<Object>(a, b);\n    if (helper.cardinalityA.size() != helper.cardinalityB.size()) {\n        return false;\n    }\n    for (final Object obj : helper.cardinalityA.keySet()) {\n        if (helper.freqA(obj) != helper.freqB(obj)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isEqualCollection",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns {@code true} iff the given {@link Collection}s contain\n * exactly the same elements with exactly the same cardinalities.\n * <p>\n * That is, iff the cardinality of <i>e</i> in <i>a</i> is\n * equal to the cardinality of <i>e</i> in <i>b</i>,\n * for each element <i>e</i> in <i>a</i> or <i>b</i>.\n * <p>\n * <b>Note:</b> from version 4.1 onwards this method requires the input\n * collections and equator to be of compatible type (using bounded wildcards).\n * Providing incompatible arguments (e.g. by casting to their rawtypes)\n * will result in a {@code ClassCastException} thrown at runtime.\n *\n * @param <E>  the element type\n * @param a  the first collection, must not be null\n * @param b  the second collection, must not be null\n * @param equator  the Equator used for testing equality\n * @return <code>true</code> iff the collections contain the same elements with the same cardinalities.\n * @throws NullPointerException if the equator is null\n * @since 4.0\n */\npublic static <E> boolean isEqualCollection(final Collection<? extends E> a, final Collection<? extends E> b, final Equator<? super E> equator) {\n    if (equator == null) {\n        throw new NullPointerException(\"Equator must not be null.\");\n    }\n    if (a.size() != b.size()) {\n        return false;\n    }\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    final Transformer<E, ?> transformer = new Transformer() {\n\n        public EquatorWrapper<?> transform(final Object input) {\n            return new EquatorWrapper(equator, input);\n        }\n    };\n    return isEqualCollection(collect(a, transformer), collect(b, transformer));\n}"
            ],
            [
                "cardinality",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns the number of occurrences of <i>obj</i> in <i>coll</i>.\n *\n * @param obj the object to find the cardinality of\n * @param coll the {@link Iterable} to search\n * @param <O> the type of object that the {@link Iterable} may contain.\n * @return the the number of occurrences of obj in coll\n * @throws NullPointerException if coll is null\n * @deprecated since 4.1, use {@link IterableUtils#frequency(Iterable, Object)} instead.\n *   Be aware that the order of parameters has changed.\n */\n@Deprecated\npublic static <O> int cardinality(final O obj, final Iterable<? super O> coll) {\n    if (coll == null) {\n        throw new NullPointerException(\"coll must not be null.\");\n    }\n    return IterableUtils.frequency(coll, obj);\n}"
            ],
            [
                "find",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Finds the first element in the given collection which matches the given predicate.\n * <p>\n * If the input collection or predicate is null, or no element of the collection\n * matches the predicate, null is returned.\n *\n * @param <T>  the type of object the {@link Iterable} contains\n * @param collection  the collection to search, may be null\n * @param predicate  the predicate to use, may be null\n * @return the first element of the collection which matches the predicate or null if none could be found\n * @deprecated since 4.1, use {@link IterableUtils#find(Iterable, Predicate)} instead\n */\n@Deprecated\npublic static <T> T find(final Iterable<T> collection, final Predicate<? super T> predicate) {\n    return predicate != null ? IterableUtils.find(collection, predicate) : null;\n}"
            ],
            [
                "forAllDo",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Executes the given closure on each element in the collection.\n * <p>\n * If the input collection or closure is null, there is no change made.\n *\n * @param <T>  the type of object the {@link Iterable} contains\n * @param <C>  the closure type\n * @param collection  the collection to get the input from, may be null\n * @param closure  the closure to perform, may be null\n * @return closure\n * @deprecated since 4.1, use {@link IterableUtils#forEach(Iterable, Closure)} instead\n */\n@Deprecated\npublic static <T, C extends Closure<? super T>> C forAllDo(final Iterable<T> collection, final C closure) {\n    if (closure != null) {\n        IterableUtils.forEach(collection, closure);\n    }\n    return closure;\n}"
            ],
            [
                "forAllDo",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Executes the given closure on each element in the collection.\n * <p>\n * If the input collection or closure is null, there is no change made.\n *\n * @param <T>  the type of object the {@link Iterator} contains\n * @param <C>  the closure type\n * @param iterator  the iterator to get the input from, may be null\n * @param closure  the closure to perform, may be null\n * @return closure\n * @since 4.0\n * @deprecated since 4.1, use {@link IteratorUtils#forEach(Iterator, Closure)} instead\n */\n@Deprecated\npublic static <T, C extends Closure<? super T>> C forAllDo(final Iterator<T> iterator, final C closure) {\n    if (closure != null) {\n        IteratorUtils.forEach(iterator, closure);\n    }\n    return closure;\n}"
            ],
            [
                "forAllButLastDo",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Executes the given closure on each but the last element in the collection.\n * <p>\n * If the input collection or closure is null, there is no change made.\n *\n * @param <T>  the type of object the {@link Iterable} contains\n * @param <C>  the closure type\n * @param collection  the collection to get the input from, may be null\n * @param closure  the closure to perform, may be null\n * @return the last element in the collection, or null if either collection or closure is null\n * @since 4.0\n * @deprecated since 4.1, use {@link IterableUtils#forEachButLast(Iterable, Closure)} instead\n */\n@Deprecated\npublic static <T, C extends Closure<? super T>> T forAllButLastDo(final Iterable<T> collection, final C closure) {\n    return closure != null ? IterableUtils.forEachButLast(collection, closure) : null;\n}"
            ],
            [
                "forAllButLastDo",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Executes the given closure on each but the last element in the collection.\n * <p>\n * If the input collection or closure is null, there is no change made.\n *\n * @param <T>  the type of object the {@link Collection} contains\n * @param <C>  the closure type\n * @param iterator  the iterator to get the input from, may be null\n * @param closure  the closure to perform, may be null\n * @return the last element in the collection, or null if either iterator or closure is null\n * @since 4.0\n * @deprecated since 4.1, use {@link IteratorUtils#forEachButLast(Iterator, Closure)} instead\n */\n@Deprecated\npublic static <T, C extends Closure<? super T>> T forAllButLastDo(final Iterator<T> iterator, final C closure) {\n    return closure != null ? IteratorUtils.forEachButLast(iterator, closure) : null;\n}"
            ],
            [
                "filter",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Filter the collection by applying a Predicate to each element. If the\n * predicate returns false, remove the element.\n * <p>\n * If the input collection or predicate is null, there is no change made.\n *\n * @param <T>  the type of object the {@link Iterable} contains\n * @param collection  the collection to get the input from, may be null\n * @param predicate  the predicate to use as a filter, may be null\n * @return true if the collection is modified by this call, false otherwise.\n */\npublic static <T> boolean filter(final Iterable<T> collection, final Predicate<? super T> predicate) {\n    boolean result = false;\n    if (collection != null && predicate != null) {\n        for (final Iterator<T> it = collection.iterator(); it.hasNext(); ) {\n            if (!predicate.evaluate(it.next())) {\n                it.remove();\n                result = true;\n            }\n        }\n    }\n    return result;\n}"
            ],
            [
                "filterInverse",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Filter the collection by applying a Predicate to each element. If the\n * predicate returns true, remove the element.\n * <p>\n * This is equivalent to <pre>filter(collection, PredicateUtils.notPredicate(predicate))</pre>\n * if predicate is != null.\n * <p>\n * If the input collection or predicate is null, there is no change made.\n *\n * @param <T>  the type of object the {@link Iterable} contains\n * @param collection  the collection to get the input from, may be null\n * @param predicate  the predicate to use as a filter, may be null\n * @return true if the collection is modified by this call, false otherwise.\n */\npublic static <T> boolean filterInverse(final Iterable<T> collection, final Predicate<? super T> predicate) {\n    return filter(collection, predicate == null ? null : PredicateUtils.notPredicate(predicate));\n}"
            ],
            [
                "countMatches",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Counts the number of elements in the input collection that match the\n * predicate.\n * <p>\n * A <code>null</code> collection or predicate matches no elements.\n *\n * @param <C>  the type of object the {@link Iterable} contains\n * @param input  the {@link Iterable} to get the input from, may be null\n * @param predicate  the predicate to use, may be null\n * @return the number of matches for the predicate in the collection\n * @deprecated since 4.1, use {@link IterableUtils#countMatches(Iterable, Predicate)} instead\n */\n@Deprecated\npublic static <C> int countMatches(final Iterable<C> input, final Predicate<? super C> predicate) {\n    return predicate == null ? 0 : (int) IterableUtils.countMatches(input, predicate);\n}"
            ],
            [
                "exists",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Answers true if a predicate is true for at least one element of a\n * collection.\n * <p>\n * A <code>null</code> collection or predicate returns false.\n *\n * @param <C>  the type of object the {@link Iterable} contains\n * @param input  the {@link Iterable} to get the input from, may be null\n * @param predicate  the predicate to use, may be null\n * @return true if at least one element of the collection matches the predicate\n * @deprecated since 4.1, use {@link IterableUtils#matchesAny(Iterable, Predicate)} instead\n */\n@Deprecated\npublic static <C> boolean exists(final Iterable<C> input, final Predicate<? super C> predicate) {\n    return predicate == null ? false : IterableUtils.matchesAny(input, predicate);\n}"
            ],
            [
                "matchesAll",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Answers true if a predicate is true for every element of a\n * collection.\n * <p>\n * A <code>null</code> predicate returns false.<br/>\n * A <code>null</code> or empty collection returns true.\n *\n * @param <C>  the type of object the {@link Iterable} contains\n * @param input  the {@link Iterable} to get the input from, may be null\n * @param predicate  the predicate to use, may be null\n * @return true if every element of the collection matches the predicate or if the\n * collection is empty, false otherwise\n * @since 4.0\n * @deprecated since 4.1, use {@link IterableUtils#matchesAll(Iterable, Predicate)} instead\n */\n@Deprecated\npublic static <C> boolean matchesAll(final Iterable<C> input, final Predicate<? super C> predicate) {\n    return predicate == null ? false : IterableUtils.matchesAll(input, predicate);\n}"
            ],
            [
                "select",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Selects all elements from input collection which match the given\n * predicate into an output collection.\n * <p>\n * A <code>null</code> predicate matches no elements.\n *\n * @param <O>  the type of object the {@link Iterable} contains\n * @param inputCollection  the collection to get the input from, may not be null\n * @param predicate  the predicate to use, may be null\n * @return the elements matching the predicate (new list)\n * @throws NullPointerException if the input collection is null\n */\npublic static <O> Collection<O> select(final Iterable<? extends O> inputCollection, final Predicate<? super O> predicate) {\n    final Collection<O> answer = inputCollection instanceof Collection<?> ? new ArrayList<O>(((Collection<?>) inputCollection).size()) : new ArrayList<O>();\n    return select(inputCollection, predicate, answer);\n}"
            ],
            [
                "select",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Selects all elements from input collection which match the given\n * predicate and adds them to outputCollection.\n * <p>\n * If the input collection or predicate is null, there is no change to the\n * output collection.\n *\n * @param <O>  the type of object the {@link Iterable} contains\n * @param <R>  the type of the output {@link Collection}\n * @param inputCollection  the collection to get the input from, may be null\n * @param predicate  the predicate to use, may be null\n * @param outputCollection  the collection to output into, may not be null if the inputCollection\n *   and predicate or not null\n * @return the outputCollection\n */\npublic static <O, R extends Collection<? super O>> R select(final Iterable<? extends O> inputCollection, final Predicate<? super O> predicate, final R outputCollection) {\n    if (inputCollection != null && predicate != null) {\n        for (final O item : inputCollection) {\n            if (predicate.evaluate(item)) {\n                outputCollection.add(item);\n            }\n        }\n    }\n    return outputCollection;\n}"
            ],
            [
                "select",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Selects all elements from inputCollection into an output and rejected collection,\n * based on the evaluation of the given predicate.\n * <p>\n * Elements matching the predicate are added to the <code>outputCollection</code>,\n * all other elements are added to the <code>rejectedCollection</code>.\n * <p>\n * If the input predicate is <code>null</code>, no elements are added to\n * <code>outputCollection</code> or <code>rejectedCollection</code>.\n * <p>\n * Note: calling the method is equivalent to the following code snippet:\n * <pre>\n *   select(inputCollection, predicate, outputCollection);\n *   selectRejected(inputCollection, predicate, rejectedCollection);\n * </pre>\n *\n * @param <O>  the type of object the {@link Iterable} contains\n * @param <R>  the type of the output {@link Collection}\n * @param inputCollection  the collection to get the input from, may be null\n * @param predicate  the predicate to use, may be null\n * @param outputCollection  the collection to output selected elements into, may not be null if the\n *   inputCollection and predicate are not null\n * @param rejectedCollection  the collection to output rejected elements into, may not be null if the\n *   inputCollection or predicate are not null\n * @return the outputCollection\n * @since 4.1\n */\npublic static <O, R extends Collection<? super O>> R select(final Iterable<? extends O> inputCollection, final Predicate<? super O> predicate, R outputCollection, R rejectedCollection) {\n    if (inputCollection != null && predicate != null) {\n        for (final O element : inputCollection) {\n            if (predicate.evaluate(element)) {\n                outputCollection.add(element);\n            } else {\n                rejectedCollection.add(element);\n            }\n        }\n    }\n    return outputCollection;\n}"
            ],
            [
                "selectRejected",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Selects all elements from inputCollection which don't match the given\n * predicate into an output collection.\n * <p>\n * If the input predicate is <code>null</code>, the result is an empty\n * list.\n *\n * @param <O>  the type of object the {@link Iterable} contains\n * @param inputCollection  the collection to get the input from, may not be null\n * @param predicate  the predicate to use, may be null\n * @return the elements <b>not</b> matching the predicate (new list)\n * @throws NullPointerException if the input collection is null\n */\npublic static <O> Collection<O> selectRejected(final Iterable<? extends O> inputCollection, final Predicate<? super O> predicate) {\n    final Collection<O> answer = inputCollection instanceof Collection<?> ? new ArrayList<O>(((Collection<?>) inputCollection).size()) : new ArrayList<O>();\n    return selectRejected(inputCollection, predicate, answer);\n}"
            ],
            [
                "selectRejected",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Selects all elements from inputCollection which don't match the given\n * predicate and adds them to outputCollection.\n * <p>\n * If the input predicate is <code>null</code>, no elements are added to\n * <code>outputCollection</code>.\n *\n * @param <O>  the type of object the {@link Iterable} contains\n * @param <R>  the type of the output {@link Collection}\n * @param inputCollection  the collection to get the input from, may be null\n * @param predicate  the predicate to use, may be null\n * @param outputCollection  the collection to output into, may not be null if the inputCollection\n *   and predicate or not null\n * @return outputCollection\n */\npublic static <O, R extends Collection<? super O>> R selectRejected(final Iterable<? extends O> inputCollection, final Predicate<? super O> predicate, final R outputCollection) {\n    if (inputCollection != null && predicate != null) {\n        for (final O item : inputCollection) {\n            if (!predicate.evaluate(item)) {\n                outputCollection.add(item);\n            }\n        }\n    }\n    return outputCollection;\n}"
            ],
            [
                "collect",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns a new Collection containing all elements of the input collection\n * transformed by the given transformer.\n * <p>\n * If the input collection or transformer is null, the result is an empty list.\n *\n * @param <I>  the type of object in the input collection\n * @param <O>  the type of object in the output collection\n * @param inputCollection  the collection to get the input from, may not be null\n * @param transformer  the transformer to use, may be null\n * @return the transformed result (new list)\n * @throws NullPointerException if the input collection is null\n */\npublic static <I, O> Collection<O> collect(final Iterable<I> inputCollection, final Transformer<? super I, ? extends O> transformer) {\n    final Collection<O> answer = inputCollection instanceof Collection<?> ? new ArrayList<O>(((Collection<?>) inputCollection).size()) : new ArrayList<O>();\n    return collect(inputCollection, transformer, answer);\n}"
            ],
            [
                "collect",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Transforms all elements from the input iterator with the given transformer\n * and adds them to the output collection.\n * <p>\n * If the input iterator or transformer is null, the result is an empty list.\n *\n * @param <I>  the type of object in the input collection\n * @param <O>  the type of object in the output collection\n * @param inputIterator  the iterator to get the input from, may be null\n * @param transformer  the transformer to use, may be null\n * @return the transformed result (new list)\n */\npublic static <I, O> Collection<O> collect(final Iterator<I> inputIterator, final Transformer<? super I, ? extends O> transformer) {\n    return collect(inputIterator, transformer, new ArrayList<O>());\n}"
            ],
            [
                "collect",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Transforms all elements from input collection with the given transformer\n * and adds them to the output collection.\n * <p>\n * If the input collection or transformer is null, there is no change to the\n * output collection.\n *\n * @param <I>  the type of object in the input collection\n * @param <O>  the type of object in the output collection\n * @param <R>  the type of the output collection\n * @param inputCollection  the collection to get the input from, may be null\n * @param transformer  the transformer to use, may be null\n * @param outputCollection  the collection to output into, may not be null if inputCollection\n *   and transformer are not null\n * @return the output collection with the transformed input added\n * @throws NullPointerException if the outputCollection is null and both, inputCollection and\n *   transformer are not null\n */\npublic static <I, O, R extends Collection<? super O>> R collect(final Iterable<? extends I> inputCollection, final Transformer<? super I, ? extends O> transformer, final R outputCollection) {\n    if (inputCollection != null) {\n        return collect(inputCollection.iterator(), transformer, outputCollection);\n    }\n    return outputCollection;\n}"
            ],
            [
                "collect",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Transforms all elements from the input iterator with the given transformer\n * and adds them to the output collection.\n * <p>\n * If the input iterator or transformer is null, there is no change to the\n * output collection.\n *\n * @param <I>  the type of object in the input collection\n * @param <O>  the type of object in the output collection\n * @param <R>  the type of the output collection\n * @param inputIterator  the iterator to get the input from, may be null\n * @param transformer  the transformer to use, may be null\n * @param outputCollection  the collection to output into, may not be null if inputIterator\n *   and transformer are not null\n * @return the outputCollection with the transformed input added\n * @throws NullPointerException if the output collection is null and both, inputIterator and\n *   transformer are not null\n */\npublic static <I, O, R extends Collection<? super O>> R collect(final Iterator<? extends I> inputIterator, final Transformer<? super I, ? extends O> transformer, final R outputCollection) {\n    if (inputIterator != null && transformer != null) {\n        while (inputIterator.hasNext()) {\n            final I item = inputIterator.next();\n            final O value = transformer.transform(item);\n            outputCollection.add(value);\n        }\n    }\n    return outputCollection;\n}"
            ],
            [
                "addIgnoreNull",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "//-----------------------------------------------------------------------\n/**\n * Adds an element to the collection unless the element is null.\n *\n * @param <T>  the type of object the {@link Collection} contains\n * @param collection  the collection to add to, must not be null\n * @param object  the object to add, if null it will not be added\n * @return true if the collection changed\n * @throws NullPointerException if the collection is null\n * @since 3.2\n */\npublic static <T> boolean addIgnoreNull(final Collection<T> collection, final T object) {\n    if (collection == null) {\n        throw new NullPointerException(\"The collection must not be null\");\n    }\n    return object != null && collection.add(object);\n}"
            ],
            [
                "addAll",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Adds all elements in the {@link Iterable} to the given collection. If the\n * {@link Iterable} is a {@link Collection} then it is cast and will be\n * added using {@link Collection#addAll(Collection)} instead of iterating.\n *\n * @param <C>  the type of object the {@link Collection} contains\n * @param collection  the collection to add to, must not be null\n * @param iterable  the iterable of elements to add, must not be null\n * @return a boolean indicating whether the collection has changed or not.\n * @throws NullPointerException if the collection or iterator is null\n */\npublic static <C> boolean addAll(final Collection<C> collection, final Iterable<? extends C> iterable) {\n    if (iterable instanceof Collection<?>) {\n        return collection.addAll((Collection<? extends C>) iterable);\n    }\n    return addAll(collection, iterable.iterator());\n}"
            ],
            [
                "addAll",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Adds all elements in the iteration to the given collection.\n *\n * @param <C>  the type of object the {@link Collection} contains\n * @param collection  the collection to add to, must not be null\n * @param iterator  the iterator of elements to add, must not be null\n * @return a boolean indicating whether the collection has changed or not.\n * @throws NullPointerException if the collection or iterator is null\n */\npublic static <C> boolean addAll(final Collection<C> collection, final Iterator<? extends C> iterator) {\n    boolean changed = false;\n    while (iterator.hasNext()) {\n        changed |= collection.add(iterator.next());\n    }\n    return changed;\n}"
            ],
            [
                "addAll",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Adds all elements in the enumeration to the given collection.\n *\n * @param <C>  the type of object the {@link Collection} contains\n * @param collection  the collection to add to, must not be null\n * @param enumeration  the enumeration of elements to add, must not be null\n * @return {@code true} if the collections was changed, {@code false} otherwise\n * @throws NullPointerException if the collection or enumeration is null\n */\npublic static <C> boolean addAll(final Collection<C> collection, final Enumeration<? extends C> enumeration) {\n    boolean changed = false;\n    while (enumeration.hasMoreElements()) {\n        changed |= collection.add(enumeration.nextElement());\n    }\n    return changed;\n}"
            ],
            [
                "addAll",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Adds all elements in the array to the given collection.\n *\n * @param <C>  the type of object the {@link Collection} contains\n * @param collection  the collection to add to, must not be null\n * @param elements  the array of elements to add, must not be null\n * @return {@code true} if the collection was changed, {@code false} otherwise\n * @throws NullPointerException if the collection or array is null\n */\npublic static <C> boolean addAll(final Collection<C> collection, final C[] elements) {\n    boolean changed = false;\n    for (final C element : elements) {\n        changed |= collection.add(element);\n    }\n    return changed;\n}"
            ],
            [
                "get",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns the <code>index</code>-th value in {@link Iterator}, throwing\n * <code>IndexOutOfBoundsException</code> if there is no such element.\n * <p>\n * The Iterator is advanced to <code>index</code> (or to the end, if\n * <code>index</code> exceeds the number of entries) as a side effect of this method.\n *\n * @param iterator  the iterator to get a value from\n * @param index  the index to get\n * @param <T> the type of object in the {@link Iterator}\n * @return the object at the specified index\n * @throws IndexOutOfBoundsException if the index is invalid\n * @throws IllegalArgumentException if the object type is invalid\n * @deprecated since 4.1, use {@code IteratorUtils.get(Iterator, int)} instead\n */\n@Deprecated\npublic static <T> T get(final Iterator<T> iterator, final int index) {\n    return IteratorUtils.get(iterator, index);\n}"
            ],
            [
                "get",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns the <code>index</code>-th value in the <code>iterable</code>'s {@link Iterator}, throwing\n * <code>IndexOutOfBoundsException</code> if there is no such element.\n * <p>\n * If the {@link Iterable} is a {@link List}, then it will use {@link List#get(int)}.\n *\n * @param iterable  the {@link Iterable} to get a value from\n * @param index  the index to get\n * @param <T> the type of object in the {@link Iterable}.\n * @return the object at the specified index\n * @throws IndexOutOfBoundsException if the index is invalid\n * @deprecated since 4.1, use {@code IterableUtils.get(Iterable, int)} instead\n */\n@Deprecated\npublic static <T> T get(final Iterable<T> iterable, final int index) {\n    return IterableUtils.get(iterable, index);\n}"
            ],
            [
                "get",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns the <code>index</code>-th value in <code>object</code>, throwing\n * <code>IndexOutOfBoundsException</code> if there is no such element or\n * <code>IllegalArgumentException</code> if <code>object</code> is not an\n * instance of one of the supported types.\n * <p>\n * The supported types, and associated semantics are:\n * <ul>\n * <li> Map -- the value returned is the <code>Map.Entry</code> in position\n *      <code>index</code> in the map's <code>entrySet</code> iterator,\n *      if there is such an entry.</li>\n * <li> List -- this method is equivalent to the list's get method.</li>\n * <li> Array -- the <code>index</code>-th array entry is returned,\n *      if there is such an entry; otherwise an <code>IndexOutOfBoundsException</code>\n *      is thrown.</li>\n * <li> Collection -- the value returned is the <code>index</code>-th object\n *      returned by the collection's default iterator, if there is such an element.</li>\n * <li> Iterator or Enumeration -- the value returned is the\n *      <code>index</code>-th object in the Iterator/Enumeration, if there\n *      is such an element.  The Iterator/Enumeration is advanced to\n *      <code>index</code> (or to the end, if <code>index</code> exceeds the\n *      number of entries) as a side effect of this method.</li>\n * </ul>\n *\n * @param object  the object to get a value from\n * @param index  the index to get\n * @return the object at the specified index\n * @throws IndexOutOfBoundsException if the index is invalid\n * @throws IllegalArgumentException if the object type is invalid\n */\npublic static Object get(final Object object, final int index) {\n    int i = index;\n    if (i < 0) {\n        throw new IndexOutOfBoundsException(\"Index cannot be negative: \" + i);\n    }\n    if (object instanceof Map<?, ?>) {\n        final Map<?, ?> map = (Map<?, ?>) object;\n        final Iterator<?> iterator = map.entrySet().iterator();\n        return IteratorUtils.get(iterator, i);\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object)[i];\n    } else if (object instanceof Iterator<?>) {\n        final Iterator<?> it = (Iterator<?>) object;\n        return IteratorUtils.get(it, i);\n    } else if (object instanceof Iterable<?>) {\n        final Iterable<?> iterable = (Iterable<?>) object;\n        return IterableUtils.get(iterable, i);\n    } else if (object instanceof Collection<?>) {\n        final Iterator<?> iterator = ((Collection<?>) object).iterator();\n        return IteratorUtils.get(iterator, i);\n    } else if (object instanceof Enumeration<?>) {\n        final Enumeration<?> it = (Enumeration<?>) object;\n        return EnumerationUtils.get(it, i);\n    } else if (object == null) {\n        throw new IllegalArgumentException(\"Unsupported object type: null\");\n    } else {\n        try {\n            return Array.get(object, i);\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}"
            ],
            [
                "get",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns the <code>index</code>-th <code>Map.Entry</code> in the <code>map</code>'s <code>entrySet</code>,\n * throwing <code>IndexOutOfBoundsException</code> if there is no such element.\n *\n * @param <K>  the key type in the {@link Map}\n * @param <V>  the key type in the {@link Map}\n * @param map  the object to get a value from\n * @param index  the index to get\n * @return the object at the specified index\n * @throws IndexOutOfBoundsException if the index is invalid\n */\npublic static <K, V> Map.Entry<K, V> get(final Map<K, V> map, final int index) {\n    checkIndexBounds(index);\n    return get(map.entrySet(), index);\n}"
            ],
            [
                "size",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Gets the size of the collection/iterator specified.\n * <p>\n * This method can handles objects as follows\n * <ul>\n * <li>Collection - the collection size\n * <li>Map - the map size\n * <li>Array - the array size\n * <li>Iterator - the number of elements remaining in the iterator\n * <li>Enumeration - the number of elements remaining in the enumeration\n * </ul>\n *\n * @param object  the object to get the size of, may be null\n * @return the size of the specified collection or 0 if the object was null\n * @throws IllegalArgumentException thrown if object is not recognised\n * @since 3.1\n */\npublic static int size(final Object object) {\n    if (object == null) {\n        return 0;\n    }\n    int total = 0;\n    if (object instanceof Map<?, ?>) {\n        total = ((Map<?, ?>) object).size();\n    } else if (object instanceof Collection<?>) {\n        total = ((Collection<?>) object).size();\n    } else if (object instanceof Iterable<?>) {\n        total = IterableUtils.size((Iterable<?>) object);\n    } else if (object instanceof Object[]) {\n        total = ((Object[]) object).length;\n    } else if (object instanceof Iterator<?>) {\n        total = IteratorUtils.size((Iterator<?>) object);\n    } else if (object instanceof Enumeration<?>) {\n        final Enumeration<?> it = (Enumeration<?>) object;\n        while (it.hasMoreElements()) {\n            total++;\n            it.nextElement();\n        }\n    } else {\n        try {\n            total = Array.getLength(object);\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n    return total;\n}"
            ],
            [
                "sizeIsEmpty",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Checks if the specified collection/array/iterator is empty.\n * <p>\n * This method can handles objects as follows\n * <ul>\n * <li>Collection - via collection isEmpty\n * <li>Map - via map isEmpty\n * <li>Array - using array size\n * <li>Iterator - via hasNext\n * <li>Enumeration - via hasMoreElements\n * </ul>\n * <p>\n * Note: This method is named to avoid clashing with\n * {@link #isEmpty(Collection)}.\n *\n * @param object  the object to get the size of, may be null\n * @return true if empty or null\n * @throws IllegalArgumentException thrown if object is not recognised\n * @since 3.2\n */\npublic static boolean sizeIsEmpty(final Object object) {\n    if (object == null) {\n        return true;\n    } else if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Iterable<?>) {\n        return IterableUtils.isEmpty((Iterable<?>) object);\n    } else if (object instanceof Map<?, ?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return ((Iterator<?>) object).hasNext() == false;\n    } else if (object instanceof Enumeration<?>) {\n        return ((Enumeration<?>) object).hasMoreElements() == false;\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}"
            ],
            [
                "isEmpty",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "//-----------------------------------------------------------------------\n/**\n * Null-safe check if the specified collection is empty.\n * <p>\n * Null returns true.\n *\n * @param coll  the collection to check, may be null\n * @return true if empty or null\n * @since 3.2\n */\npublic static boolean isEmpty(final Collection<?> coll) {\n    return coll == null || coll.isEmpty();\n}"
            ],
            [
                "isNotEmpty",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Null-safe check if the specified collection is not empty.\n * <p>\n * Null returns false.\n *\n * @param coll  the collection to check, may be null\n * @return true if non-null and non-empty\n * @since 3.2\n */\npublic static boolean isNotEmpty(final Collection<?> coll) {\n    return !isEmpty(coll);\n}"
            ],
            [
                "isFull",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns true if no more elements can be added to the Collection.\n * <p>\n * This method uses the {@link BoundedCollection} interface to determine the\n * full status. If the collection does not implement this interface then\n * false is returned.\n * <p>\n * The collection does not have to implement this interface directly.\n * If the collection has been decorated using the decorators subpackage\n * then these will be removed to access the BoundedCollection.\n *\n * @param coll  the collection to check\n * @return true if the BoundedCollection is full\n * @throws NullPointerException if the collection is null\n */\npublic static boolean isFull(final Collection<? extends Object> coll) {\n    if (coll == null) {\n        throw new NullPointerException(\"The collection must not be null\");\n    }\n    if (coll instanceof BoundedCollection) {\n        return ((BoundedCollection<?>) coll).isFull();\n    }\n    try {\n        final BoundedCollection<?> bcoll = UnmodifiableBoundedCollection.unmodifiableBoundedCollection(coll);\n        return bcoll.isFull();\n    } catch (final IllegalArgumentException ex) {\n        return false;\n    }\n}"
            ],
            [
                "maxSize",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Get the maximum number of elements that the Collection can contain.\n * <p>\n * This method uses the {@link BoundedCollection} interface to determine the\n * maximum size. If the collection does not implement this interface then\n * -1 is returned.\n * <p>\n * The collection does not have to implement this interface directly.\n * If the collection has been decorated using the decorators subpackage\n * then these will be removed to access the BoundedCollection.\n *\n * @param coll  the collection to check\n * @return the maximum size of the BoundedCollection, -1 if no maximum size\n * @throws NullPointerException if the collection is null\n */\npublic static int maxSize(final Collection<? extends Object> coll) {\n    if (coll == null) {\n        throw new NullPointerException(\"The collection must not be null\");\n    }\n    if (coll instanceof BoundedCollection) {\n        return ((BoundedCollection<?>) coll).maxSize();\n    }\n    try {\n        final BoundedCollection<?> bcoll = UnmodifiableBoundedCollection.unmodifiableBoundedCollection(coll);\n        return bcoll.maxSize();\n    } catch (final IllegalArgumentException ex) {\n        return -1;\n    }\n}"
            ],
            [
                "collate",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "//-----------------------------------------------------------------------\n/**\n * Merges two sorted Collections, a and b, into a single, sorted List\n * such that the natural ordering of the elements is retained.\n * <p>\n * Uses the standard O(n) merge algorithm for combining two sorted lists.\n *\n * @param <O>  the element type\n * @param a  the first collection, must not be null\n * @param b  the second collection, must not be null\n * @return a new sorted List, containing the elements of Collection a and b\n * @throws NullPointerException if either collection is null\n * @since 4.0\n */\npublic static <O extends Comparable<? super O>> List<O> collate(Iterable<? extends O> a, Iterable<? extends O> b) {\n    return collate(a, b, ComparatorUtils.<O>naturalComparator(), true);\n}"
            ],
            [
                "collate",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Merges two sorted Collections, a and b, into a single, sorted List\n * such that the natural ordering of the elements is retained.\n * <p>\n * Uses the standard O(n) merge algorithm for combining two sorted lists.\n *\n * @param <O>  the element type\n * @param a  the first collection, must not be null\n * @param b  the second collection, must not be null\n * @param includeDuplicates  if {@code true} duplicate elements will be retained, otherwise\n *   they will be removed in the output collection\n * @return a new sorted List, containing the elements of Collection a and b\n * @throws NullPointerException if either collection is null\n * @since 4.0\n */\npublic static <O extends Comparable<? super O>> List<O> collate(final Iterable<? extends O> a, final Iterable<? extends O> b, final boolean includeDuplicates) {\n    return collate(a, b, ComparatorUtils.<O>naturalComparator(), includeDuplicates);\n}"
            ],
            [
                "collate",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Merges two sorted Collections, a and b, into a single, sorted List\n * such that the ordering of the elements according to Comparator c is retained.\n * <p>\n * Uses the standard O(n) merge algorithm for combining two sorted lists.\n *\n * @param <O>  the element type\n * @param a  the first collection, must not be null\n * @param b  the second collection, must not be null\n * @param c  the comparator to use for the merge.\n * @return a new sorted List, containing the elements of Collection a and b\n * @throws NullPointerException if either collection or the comparator is null\n * @since 4.0\n */\npublic static <O> List<O> collate(final Iterable<? extends O> a, final Iterable<? extends O> b, final Comparator<? super O> c) {\n    return collate(a, b, c, true);\n}"
            ],
            [
                "collate",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Merges two sorted Collections, a and b, into a single, sorted List\n * such that the ordering of the elements according to Comparator c is retained.\n * <p>\n * Uses the standard O(n) merge algorithm for combining two sorted lists.\n *\n * @param <O>  the element type\n * @param a  the first collection, must not be null\n * @param b  the second collection, must not be null\n * @param c  the comparator to use for the merge.\n * @param includeDuplicates  if {@code true} duplicate elements will be retained, otherwise\n *   they will be removed in the output collection\n * @return a new sorted List, containing the elements of Collection a and b\n * @throws NullPointerException if either collection or the comparator is null\n * @since 4.0\n */\npublic static <O> List<O> collate(final Iterable<? extends O> a, final Iterable<? extends O> b, final Comparator<? super O> c, final boolean includeDuplicates) {\n    if (a == null || b == null) {\n        throw new NullPointerException(\"The collections must not be null\");\n    }\n    if (c == null) {\n        throw new NullPointerException(\"The comparator must not be null\");\n    }\n    // if both Iterables are a Collection, we can estimate the size\n    final int totalSize = a instanceof Collection<?> && b instanceof Collection<?> ? Math.max(1, ((Collection<?>) a).size() + ((Collection<?>) b).size()) : 10;\n    final Iterator<O> iterator = new CollatingIterator<O>(c, a.iterator(), b.iterator());\n    if (includeDuplicates) {\n        return IteratorUtils.toList(iterator, totalSize);\n    } else {\n        final ArrayList<O> mergedList = new ArrayList<O>(totalSize);\n        O lastItem = null;\n        while (iterator.hasNext()) {\n            final O item = iterator.next();\n            if (lastItem == null || !lastItem.equals(item)) {\n                mergedList.add(item);\n            }\n            lastItem = item;\n        }\n        mergedList.trimToSize();\n        return mergedList;\n    }\n}"
            ],
            [
                "permutations",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns a {@link Collection} of all the permutations of the input collection.\n * <p>\n * NOTE: the number of permutations of a given collection is equal to n!, where\n * n is the size of the collection. Thus, the resulting collection will become\n * <b>very</b> large for collections &gt; 10 (e.g. 10! = 3628800, 15! = 1307674368000).\n * <p>\n * For larger collections it is advised to use a {@link PermutationIterator} to\n * iterate over all permutations.\n *\n * @see PermutationIterator\n *\n * @param <E>  the element type\n * @param collection  the collection to create permutations for, may not be null\n * @return an unordered collection of all permutations of the input collection\n * @throws NullPointerException if collection is null\n * @since 4.0\n */\npublic static <E> Collection<List<E>> permutations(final Collection<E> collection) {\n    final PermutationIterator<E> it = new PermutationIterator<E>(collection);\n    final Collection<List<E>> result = new LinkedList<List<E>>();\n    while (it.hasNext()) {\n        result.add(it.next());\n    }\n    return result;\n}"
            ],
            [
                "retainAll",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns a collection containing all the elements in <code>collection</code>\n * that are also in <code>retain</code>. The cardinality of an element <code>e</code>\n * in the returned collection is the same as the cardinality of <code>e</code>\n * in <code>collection</code> unless <code>retain</code> does not contain <code>e</code>, in which\n * case the cardinality is zero. This method is useful if you do not wish to modify\n * the collection <code>c</code> and thus cannot call <code>c.retainAll(retain);</code>.\n * <p>\n * This implementation iterates over <code>collection</code>, checking each element in\n * turn to see if it's contained in <code>retain</code>. If it's contained, it's added\n * to the returned list. As a consequence, it is advised to use a collection type for\n * <code>retain</code> that provides a fast (e.g. O(1)) implementation of\n * {@link Collection#contains(Object)}.\n *\n * @param <C>  the type of object the {@link Collection} contains\n * @param collection  the collection whose contents are the target of the #retailAll operation\n * @param retain  the collection containing the elements to be retained in the returned collection\n * @return a <code>Collection</code> containing all the elements of <code>collection</code>\n * that occur at least once in <code>retain</code>.\n * @throws NullPointerException if either parameter is null\n * @since 3.2\n */\npublic static <C> Collection<C> retainAll(final Collection<C> collection, final Collection<?> retain) {\n    return ListUtils.retainAll(collection, retain);\n}"
            ],
            [
                "retainAll",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns a collection containing all the elements in\n * <code>collection</code> that are also in <code>retain</code>. The\n * cardinality of an element <code>e</code> in the returned collection is\n * the same as the cardinality of <code>e</code> in <code>collection</code>\n * unless <code>retain</code> does not contain <code>e</code>, in which case\n * the cardinality is zero. This method is useful if you do not wish to\n * modify the collection <code>c</code> and thus cannot call\n * <code>c.retainAll(retain);</code>.\n * <p>\n * Moreover this method uses an {@link Equator} instead of\n * {@link Object#equals(Object)} to determine the equality of the elements\n * in <code>collection</code> and <code>retain</code>. Hence this method is\n * useful in cases where the equals behavior of an object needs to be\n * modified without changing the object itself.\n *\n * @param <E> the type of object the {@link Collection} contains\n * @param collection the collection whose contents are the target of the {@code retainAll} operation\n * @param retain the collection containing the elements to be retained in the returned collection\n * @param equator the Equator used for testing equality\n * @return a <code>Collection</code> containing all the elements of <code>collection</code>\n * that occur at least once in <code>retain</code> according to the <code>equator</code>\n * @throws NullPointerException if any of the parameters is null\n * @since 4.1\n */\npublic static <E> Collection<E> retainAll(final Iterable<E> collection, final Iterable<? extends E> retain, final Equator<? super E> equator) {\n    final Transformer<E, EquatorWrapper<E>> transformer = new Transformer<E, EquatorWrapper<E>>() {\n\n        public EquatorWrapper<E> transform(E input) {\n            return new EquatorWrapper<E>(equator, input);\n        }\n    };\n    final Set<EquatorWrapper<E>> retainSet = collect(retain, transformer, new HashSet<EquatorWrapper<E>>());\n    final List<E> list = new ArrayList<E>();\n    for (final E element : collection) {\n        if (retainSet.contains(new EquatorWrapper<E>(equator, element))) {\n            list.add(element);\n        }\n    }\n    return list;\n}"
            ],
            [
                "removeAll",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Removes the elements in <code>remove</code> from <code>collection</code>. That is, this\n * method returns a collection containing all the elements in <code>c</code>\n * that are not in <code>remove</code>. The cardinality of an element <code>e</code>\n * in the returned collection is the same as the cardinality of <code>e</code>\n * in <code>collection</code> unless <code>remove</code> contains <code>e</code>, in which\n * case the cardinality is zero. This method is useful if you do not wish to modify\n * the collection <code>c</code> and thus cannot call <code>collection.removeAll(remove);</code>.\n * <p>\n * This implementation iterates over <code>collection</code>, checking each element in\n * turn to see if it's contained in <code>remove</code>. If it's not contained, it's added\n * to the returned list. As a consequence, it is advised to use a collection type for\n * <code>remove</code> that provides a fast (e.g. O(1)) implementation of\n * {@link Collection#contains(Object)}.\n *\n * @param <E>  the type of object the {@link Collection} contains\n * @param collection  the collection from which items are removed (in the returned collection)\n * @param remove  the items to be removed from the returned <code>collection</code>\n * @return a <code>Collection</code> containing all the elements of <code>collection</code> except\n * any elements that also occur in <code>remove</code>.\n * @throws NullPointerException if either parameter is null\n * @since 4.0 (method existed in 3.2 but was completely broken)\n */\npublic static <E> Collection<E> removeAll(final Collection<E> collection, final Collection<?> remove) {\n    return ListUtils.removeAll(collection, remove);\n}"
            ],
            [
                "removeAll",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Removes all elements in <code>remove</code> from <code>collection</code>.\n * That is, this method returns a collection containing all the elements in\n * <code>collection</code> that are not in <code>remove</code>. The\n * cardinality of an element <code>e</code> in the returned collection is\n * the same as the cardinality of <code>e</code> in <code>collection</code>\n * unless <code>remove</code> contains <code>e</code>, in which case the\n * cardinality is zero. This method is useful if you do not wish to modify\n * the collection <code>c</code> and thus cannot call\n * <code>collection.removeAll(remove)</code>.\n * <p>\n * Moreover this method uses an {@link Equator} instead of\n * {@link Object#equals(Object)} to determine the equality of the elements\n * in <code>collection</code> and <code>remove</code>. Hence this method is\n * useful in cases where the equals behavior of an object needs to be\n * modified without changing the object itself.\n *\n * @param <E> the type of object the {@link Collection} contains\n * @param collection the collection from which items are removed (in the returned collection)\n * @param remove the items to be removed from the returned collection\n * @param equator the Equator used for testing equality\n * @return a <code>Collection</code> containing all the elements of <code>collection</code>\n * except any element that if equal according to the <code>equator</code>\n * @throws NullPointerException if any of the parameters is null\n * @since 4.1\n */\npublic static <E> Collection<E> removeAll(final Iterable<E> collection, final Iterable<? extends E> remove, final Equator<? super E> equator) {\n    final Transformer<E, EquatorWrapper<E>> transformer = new Transformer<E, EquatorWrapper<E>>() {\n\n        public EquatorWrapper<E> transform(E input) {\n            return new EquatorWrapper<E>(equator, input);\n        }\n    };\n    final Set<EquatorWrapper<E>> removeSet = collect(remove, transformer, new HashSet<EquatorWrapper<E>>());\n    final List<E> list = new ArrayList<E>();\n    for (final E element : collection) {\n        if (!removeSet.contains(new EquatorWrapper<E>(equator, element))) {\n            list.add(element);\n        }\n    }\n    return list;\n}"
            ],
            [
                "synchronizedCollection",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns a synchronized collection backed by the given collection.\n * <p>\n * You must manually synchronize on the returned buffer's iterator to\n * avoid non-deterministic behavior:\n *\n * <pre>\n * Collection c = CollectionUtils.synchronizedCollection(myCollection);\n * synchronized (c) {\n *     Iterator i = c.iterator();\n *     while (i.hasNext()) {\n *         process (i.next());\n *     }\n * }\n * </pre>\n *\n * This method uses the implementation in the decorators subpackage.\n *\n * @param <C>  the type of object the {@link Collection} contains\n * @param collection  the collection to synchronize, must not be null\n * @return a synchronized collection backed by the given collection\n * @throws NullPointerException if the collection is null\n * @deprecated since 4.1, use {@link java.util.Collections#synchronizedCollection(Collection)} instead\n */\n@Deprecated\npublic static <C> Collection<C> synchronizedCollection(final Collection<C> collection) {\n    return SynchronizedCollection.synchronizedCollection(collection);\n}"
            ],
            [
                "unmodifiableCollection",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns an unmodifiable collection backed by the given collection.\n * <p>\n * This method uses the implementation in the decorators subpackage.\n *\n * @param <C>  the type of object the {@link Collection} contains\n * @param collection  the collection to make unmodifiable, must not be null\n * @return an unmodifiable collection backed by the given collection\n * @throws NullPointerException if the collection is null\n * @deprecated since 4.1, use {@link java.util.Collections#unmodifiableCollection(Collection)} instead\n */\n@Deprecated\npublic static <C> Collection<C> unmodifiableCollection(final Collection<? extends C> collection) {\n    return UnmodifiableCollection.unmodifiableCollection(collection);\n}"
            ],
            [
                "predicatedCollection",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns a predicated (validating) collection backed by the given collection.\n * <p>\n * Only objects that pass the test in the given predicate can be added to the collection.\n * Trying to add an invalid object results in an IllegalArgumentException.\n * It is important not to use the original collection after invoking this method,\n * as it is a backdoor for adding invalid objects.\n *\n * @param <C> the type of objects in the Collection.\n * @param collection  the collection to predicate, must not be null\n * @param predicate  the predicate for the collection, must not be null\n * @return a predicated collection backed by the given collection\n * @throws NullPointerException if the Collection is null\n */\npublic static <C> Collection<C> predicatedCollection(final Collection<C> collection, final Predicate<? super C> predicate) {\n    return PredicatedCollection.predicatedCollection(collection, predicate);\n}"
            ],
            [
                "transformingCollection",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns a transformed bag backed by the given collection.\n * <p>\n * Each object is passed through the transformer as it is added to the\n * Collection. It is important not to use the original collection after invoking this\n * method, as it is a backdoor for adding untransformed objects.\n * <p>\n * Existing entries in the specified collection will not be transformed.\n * If you want that behaviour, see {@link TransformedCollection#transformedCollection}.\n *\n * @param <E> the type of object the {@link Collection} contains\n * @param collection  the collection to predicate, must not be null\n * @param transformer  the transformer for the collection, must not be null\n * @return a transformed collection backed by the given collection\n * @throws NullPointerException if the Collection or Transformer is null\n */\npublic static <E> Collection<E> transformingCollection(final Collection<E> collection, final Transformer<? super E, ? extends E> transformer) {\n    return TransformedCollection.transformingCollection(collection, transformer);\n}"
            ],
            [
                "extractSingleton",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Extract the lone element of the specified Collection.\n * @param <E> collection type\n * @param collection to read\n * @return sole member of collection\n * @throws NullPointerException if collection is null\n * @throws IllegalArgumentException if collection is empty or contains more than one element\n * @since 4.0\n */\npublic static <E> E extractSingleton(final Collection<E> collection) {\n    if (collection == null) {\n        throw new NullPointerException(\"Collection must not be null.\");\n    }\n    if (collection.size() != 1) {\n        throw new IllegalArgumentException(\"Can extract singleton only when collection size == 1\");\n    }\n    return collection.iterator().next();\n}"
            ],
            [
                "transformingMap",
                "org.apache.commons.collections4.splitmap",
                "TransformedSplitMap",
                "/**\n * Factory method to create a transforming map.\n * <p>\n * If there are any elements already in the map being decorated, they are\n * NOT transformed.\n *\n * @param <J>  the input key type\n * @param <K>  the output key type\n * @param <U>  the input value type\n * @param <V>  the output value type\n * @param map the map to decorate, must not be null\n * @param keyTransformer the transformer to use for key conversion, must not be null\n * @param valueTransformer the transformer to use for value conversion, must not be null\n * @return a new transformed map\n * @throws NullPointerException if map or either of the transformers is null\n */\npublic static <J, K, U, V> TransformedSplitMap<J, K, U, V> transformingMap(final Map<K, V> map, final Transformer<? super J, ? extends K> keyTransformer, final Transformer<? super U, ? extends V> valueTransformer) {\n    return new TransformedSplitMap<J, K, U, V>(map, keyTransformer, valueTransformer);\n}"
            ],
            [
                "emptyIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Empty\n// ----------------------------------------------------------------------\n/**\n * Gets an empty iterable.\n * <p>\n * This iterable does not contain any elements.\n *\n * @param <E> the element type\n * @return an empty iterable\n */\n// OK, empty collection is compatible with any type\n@SuppressWarnings(\"unchecked\")\npublic static <E> Iterable<E> emptyIterable() {\n    return EMPTY_ITERABLE;\n}"
            ],
            [
                "chainedIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Chained\n// ----------------------------------------------------------------------\n/**\n * Combines two iterables into a single iterable.\n * <p>\n * The returned iterable has an iterator that traverses the elements in {@code a},\n * followed by the elements in {@code b}. The source iterators are not polled until\n * necessary.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the corresponding\n * input iterator supports it.\n *\n * @param <E> the element type\n * @param a  the first iterable, may not be null\n * @param b  the second iterable, may not be null\n * @return a new iterable, combining the provided iterables\n * @throws NullPointerException if either a or b is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Iterable<E> chainedIterable(final Iterable<? extends E> a, final Iterable<? extends E> b) {\n    return chainedIterable(new Iterable[] { a, b });\n}"
            ],
            [
                "chainedIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Combines three iterables into a single iterable.\n * <p>\n * The returned iterable has an iterator that traverses the elements in {@code a},\n * followed by the elements in {@code b} and {@code c}. The source iterators are\n * not polled until necessary.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the corresponding\n * input iterator supports it.\n *\n * @param <E> the element type\n * @param a  the first iterable, may not be null\n * @param b  the second iterable, may not be null\n * @param c  the third iterable, may not be null\n * @return a new iterable, combining the provided iterables\n * @throws NullPointerException if either of the provided iterables is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Iterable<E> chainedIterable(final Iterable<? extends E> a, final Iterable<? extends E> b, final Iterable<? extends E> c) {\n    return chainedIterable(new Iterable[] { a, b, c });\n}"
            ],
            [
                "chainedIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Combines four iterables into a single iterable.\n * <p>\n * The returned iterable has an iterator that traverses the elements in {@code a},\n * followed by the elements in {@code b}, {@code c} and {@code d}. The source\n * iterators are not polled until necessary.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the corresponding\n * input iterator supports it.\n *\n * @param <E> the element type\n * @param a  the first iterable, may not be null\n * @param b  the second iterable, may not be null\n * @param c  the third iterable, may not be null\n * @param d  the fourth iterable, may not be null\n * @return a new iterable, combining the provided iterables\n * @throws NullPointerException if either of the provided iterables is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Iterable<E> chainedIterable(final Iterable<? extends E> a, final Iterable<? extends E> b, final Iterable<? extends E> c, final Iterable<? extends E> d) {\n    return chainedIterable(new Iterable[] { a, b, c, d });\n}"
            ],
            [
                "chainedIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Combines the provided iterables into a single iterable.\n * <p>\n * The returned iterable has an iterator that traverses the elements in the order\n * of the arguments, i.e. iterables[0], iterables[1], .... The source iterators\n * are not polled until necessary.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the corresponding\n * input iterator supports it.\n *\n * @param <E> the element type\n * @param iterables  the iterables to combine, may not be null\n * @return a new iterable, combining the provided iterables\n * @throws NullPointerException if either of the provided iterables is null\n */\npublic static <E> Iterable<E> chainedIterable(final Iterable<? extends E>... iterables) {\n    checkNotNull(iterables);\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            return new LazyIteratorChain<E>() {\n\n                @Override\n                protected Iterator<? extends E> nextIterator(int count) {\n                    if (count > iterables.length) {\n                        return null;\n                    } else {\n                        return iterables[count - 1].iterator();\n                    }\n                }\n            };\n        }\n    };\n}"
            ],
            [
                "collatedIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Collated\n// ----------------------------------------------------------------------\n/**\n * Combines the two provided iterables into an ordered iterable using\n * natural ordering.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the\n * corresponding input iterator supports it.\n *\n * @param <E> the element type\n * @param a  the first iterable, may not be null\n * @param b  the second iterable, may not be null\n * @return a filtered view on the specified iterable\n * @throws NullPointerException if either of the provided iterables is null\n */\npublic static <E> Iterable<E> collatedIterable(final Iterable<? extends E> a, final Iterable<? extends E> b) {\n    checkNotNull(a, b);\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            return IteratorUtils.collatedIterator(null, a.iterator(), b.iterator());\n        }\n    };\n}"
            ],
            [
                "collatedIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Combines the two provided iterables into an ordered iterable using the\n * provided comparator. If the comparator is null, natural ordering will be\n * used.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the\n * corresponding input iterator supports it.\n *\n * @param <E> the element type\n * @param comparator  the comparator defining an ordering over the elements,\n *   may be null, in which case natural ordering will be used\n * @param a  the first iterable, may not be null\n * @param b  the second iterable, may not be null\n * @return a filtered view on the specified iterable\n * @throws NullPointerException if either of the provided iterables is null\n */\npublic static <E> Iterable<E> collatedIterable(final Comparator<? super E> comparator, final Iterable<? extends E> a, final Iterable<? extends E> b) {\n    checkNotNull(a, b);\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            return IteratorUtils.collatedIterator(comparator, a.iterator(), b.iterator());\n        }\n    };\n}"
            ],
            [
                "filteredIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Filtered\n// ----------------------------------------------------------------------\n/**\n * Returns a view of the given iterable that only contains elements matching\n * the provided predicate.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the\n * corresponding input iterator supports it.\n *\n * @param <E> the element type\n * @param iterable  the iterable to filter, may not be null\n * @param predicate  the predicate used to filter elements, may not be null\n * @return a filtered view on the specified iterable\n * @throws NullPointerException if either iterable or predicate is null\n */\npublic static <E> Iterable<E> filteredIterable(final Iterable<E> iterable, final Predicate<? super E> predicate) {\n    checkNotNull(iterable);\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null.\");\n    }\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            return IteratorUtils.filteredIterator(emptyIteratorIfNull(iterable), predicate);\n        }\n    };\n}"
            ],
            [
                "boundedIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Bounded\n// ----------------------------------------------------------------------\n/**\n * Returns a view of the given iterable that contains at most the given number\n * of elements.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the corresponding\n * input iterator supports it.\n *\n * @param <E> the element type\n * @param iterable  the iterable to limit, may not be null\n * @param maxSize  the maximum number of elements, must not be negative\n * @return a bounded view on the specified iterable\n * @throws IllegalArgumentException if maxSize is negative\n * @throws NullPointerException if iterable is null\n */\npublic static <E> Iterable<E> boundedIterable(final Iterable<E> iterable, final long maxSize) {\n    checkNotNull(iterable);\n    if (maxSize < 0) {\n        throw new IllegalArgumentException(\"MaxSize parameter must not be negative.\");\n    }\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            return IteratorUtils.boundedIterator(iterable.iterator(), maxSize);\n        }\n    };\n}"
            ],
            [
                "loopingIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Looping\n// ----------------------------------------------------------------------\n/**\n * Returns a view of the given iterable which will cycle infinitely over\n * its elements.\n * <p>\n * The returned iterable's iterator supports {@code remove()} if\n * {@code iterable.iterator()} does. After {@code remove()} is called, subsequent\n * cycles omit the removed element, which is no longer in {@code iterable}. The\n * iterator's {@code hasNext()} method returns {@code true} until {@code iterable}\n * is empty.\n *\n * @param <E> the element type\n * @param iterable  the iterable to loop, may not be null\n * @return a view of the iterable, providing an infinite loop over its elements\n * @throws NullPointerException if iterable is null\n */\npublic static <E> Iterable<E> loopingIterable(final Iterable<E> iterable) {\n    checkNotNull(iterable);\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            return new LazyIteratorChain<E>() {\n\n                @Override\n                protected Iterator<? extends E> nextIterator(int count) {\n                    if (IterableUtils.isEmpty(iterable)) {\n                        return null;\n                    } else {\n                        return iterable.iterator();\n                    }\n                }\n            };\n        }\n    };\n}"
            ],
            [
                "reversedIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Reversed\n// ----------------------------------------------------------------------\n/**\n * Returns a reversed view of the given iterable.\n * <p>\n * In case the provided iterable is a {@link List} instance, a\n * {@link ReverseListIterator} will be used to reverse the traversal\n * order, otherwise an intermediate {@link List} needs to be created.\n * <p>\n * The returned iterable's iterator supports {@code remove()} if the\n * provided iterable is a {@link List} instance.\n *\n * @param <E> the element type\n * @param iterable  the iterable to use, may not be null\n * @return a reversed view of the specified iterable\n * @throws NullPointerException if iterable is null\n * @see ReverseListIterator\n */\npublic static <E> Iterable<E> reversedIterable(final Iterable<E> iterable) {\n    checkNotNull(iterable);\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            final List<E> list = (iterable instanceof List<?>) ? (List<E>) iterable : IteratorUtils.toList(iterable.iterator());\n            return new ReverseListIterator<E>(list);\n        }\n    };\n}"
            ],
            [
                "skippingIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Skipping\n// ----------------------------------------------------------------------\n/**\n * Returns a view of the given iterable that skips the first N elements.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the corresponding\n * input iterator supports it.\n *\n * @param <E> the element type\n * @param iterable  the iterable to use, may not be null\n * @param elementsToSkip  the number of elements to skip from the start, must not be negative\n * @return a view of the specified iterable, skipping the first N elements\n * @throws IllegalArgumentException if elementsToSkip is negative\n * @throws NullPointerException if iterable is null\n */\npublic static <E> Iterable<E> skippingIterable(final Iterable<E> iterable, final long elementsToSkip) {\n    checkNotNull(iterable);\n    if (elementsToSkip < 0) {\n        throw new IllegalArgumentException(\"ElementsToSkip parameter must not be negative.\");\n    }\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            return IteratorUtils.skippingIterator(iterable.iterator(), elementsToSkip);\n        }\n    };\n}"
            ],
            [
                "transformedIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Transformed\n// ----------------------------------------------------------------------\n/**\n * Returns a transformed view of the given iterable where all of its elements\n * have been transformed by the provided transformer.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the corresponding\n * input iterator supports it.\n *\n * @param <I>  the input element type\n * @param <O>  the output element type\n * @param iterable  the iterable to transform, may not be null\n * @param transformer  the transformer, must not be null\n * @return a transformed view of the specified iterable\n * @throws NullPointerException if either iterable or transformer is null\n */\npublic static <I, O> Iterable<O> transformedIterable(final Iterable<I> iterable, final Transformer<? super I, ? extends O> transformer) {\n    checkNotNull(iterable);\n    if (transformer == null) {\n        throw new NullPointerException(\"Transformer must not be null.\");\n    }\n    return new FluentIterable<O>() {\n\n        @Override\n        public Iterator<O> iterator() {\n            return IteratorUtils.transformedIterator(iterable.iterator(), transformer);\n        }\n    };\n}"
            ],
            [
                "uniqueIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Unique\n// ----------------------------------------------------------------------\n/**\n * Returns a unique view of the given iterable.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the\n * corresponding input iterator supports it. Calling {@code remove()}\n * will only remove a single element from the underlying iterator.\n *\n * @param <E> the element type\n * @param iterable  the iterable to use, may not be null\n * @return a unique view of the specified iterable\n * @throws NullPointerException if iterable is null\n */\npublic static <E> Iterable<E> uniqueIterable(final Iterable<E> iterable) {\n    checkNotNull(iterable);\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            return new UniqueFilterIterator<E>(iterable.iterator());\n        }\n    };\n}"
            ],
            [
                "unmodifiableIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Unmodifiable\n// ----------------------------------------------------------------------\n/**\n * Returns an unmodifiable view of the given iterable.\n * <p>\n * The returned iterable's iterator does not support {@code remove()}.\n *\n * @param <E> the element type\n * @param iterable  the iterable to use, may not be null\n * @return an unmodifiable view of the specified iterable\n * @throws NullPointerException if iterable is null\n */\npublic static <E> Iterable<E> unmodifiableIterable(final Iterable<E> iterable) {\n    checkNotNull(iterable);\n    if (iterable instanceof UnmodifiableIterable<?>) {\n        return iterable;\n    }\n    return new UnmodifiableIterable<E>(iterable);\n}"
            ],
            [
                "zippingIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Zipping\n// ----------------------------------------------------------------------\n/**\n * Interleaves two iterables into a single iterable.\n * <p>\n * The returned iterable has an iterator that traverses the elements in {@code a}\n * and {@code b} in alternating order. The source iterators are not polled until\n * necessary.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the corresponding\n * input iterator supports it.\n *\n * @param <E> the element type\n * @param a  the first iterable, may not be null\n * @param b  the second iterable, may not be null\n * @return a new iterable, interleaving the provided iterables\n * @throws NullPointerException if either a or b is null\n */\npublic static <E> Iterable<E> zippingIterable(final Iterable<? extends E> a, final Iterable<? extends E> b) {\n    checkNotNull(a);\n    checkNotNull(b);\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            return IteratorUtils.zippingIterator(a.iterator(), b.iterator());\n        }\n    };\n}"
            ],
            [
                "zippingIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Interleaves two iterables into a single iterable.\n * <p>\n * The returned iterable has an iterator that traverses the elements in {@code a}\n * and {@code b} in alternating order. The source iterators are not polled until\n * necessary.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the corresponding\n * input iterator supports it.\n *\n * @param <E> the element type\n * @param first  the first iterable, may not be null\n * @param others  the array of iterables to interleave, may not be null\n * @return a new iterable, interleaving the provided iterables\n * @throws NullPointerException if either of the provided iterables is null\n */\npublic static <E> Iterable<E> zippingIterable(final Iterable<? extends E> first, final Iterable<? extends E>... others) {\n    checkNotNull(first);\n    checkNotNull(others);\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            // safe\n            @SuppressWarnings(\"unchecked\")\n            Iterator<? extends E>[] iterators = new Iterator[others.length + 1];\n            iterators[0] = first.iterator();\n            for (int i = 0; i < others.length; i++) {\n                iterators[i + 1] = others[i].iterator();\n            }\n            return IteratorUtils.zippingIterator(iterators);\n        }\n    };\n}"
            ],
            [
                "emptyIfNull",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Utility methods\n// ----------------------------------------------------------------------\n/**\n * Returns an immutable empty iterable if the argument is null,\n * or the argument itself otherwise.\n *\n * @param <E> the element type\n * @param iterable  the iterable, may be null\n * @return an empty iterable if the argument is null\n */\npublic static <E> Iterable<E> emptyIfNull(final Iterable<E> iterable) {\n    return iterable == null ? IterableUtils.<E>emptyIterable() : iterable;\n}"
            ],
            [
                "forEachButLast",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Executes the given closure on each but the last element in the iterable.\n * <p>\n * If the input iterable is null no change is made.\n *\n * @param <E> the type of object the {@link Iterable} contains\n * @param iterable  the iterable to get the input from, may be null\n * @param closure  the closure to perform, may not be null\n * @return the last element in the iterable, or null if iterable is null or empty\n */\npublic static <E> E forEachButLast(final Iterable<E> iterable, final Closure<? super E> closure) {\n    return IteratorUtils.forEachButLast(emptyIteratorIfNull(iterable), closure);\n}"
            ],
            [
                "find",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Finds the first element in the given iterable which matches the given predicate.\n * <p>\n * A <code>null</code> or empty iterator returns null.\n *\n * @param <E> the element type\n * @param iterable  the iterable to search, may be null\n * @param predicate  the predicate to use, may not be null\n * @return the first element of the iterable which matches the predicate or null if none could be found\n * @throws NullPointerException if predicate is null\n */\npublic static <E> E find(final Iterable<E> iterable, final Predicate<? super E> predicate) {\n    return IteratorUtils.find(emptyIteratorIfNull(iterable), predicate);\n}"
            ],
            [
                "indexOf",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Returns the index of the first element in the specified iterable that\n * matches the given predicate.\n * <p>\n * A <code>null</code> or empty iterable returns -1.\n *\n * @param <E> the element type\n * @param iterable  the iterable to search, may be null\n * @param predicate  the predicate to use, may not be null\n * @return the index of the first element which matches the predicate or -1 if none matches\n * @throws NullPointerException if predicate is null\n */\npublic static <E> int indexOf(final Iterable<E> iterable, final Predicate<? super E> predicate) {\n    return IteratorUtils.indexOf(emptyIteratorIfNull(iterable), predicate);\n}"
            ],
            [
                "matchesAll",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Answers true if a predicate is true for every element of an iterable.\n * <p>\n * A <code>null</code> or empty iterable returns true.\n *\n * @param <E> the type of object the {@link Iterable} contains\n * @param iterable  the {@link Iterable} to use, may be null\n * @param predicate  the predicate to use, may not be null\n * @return true if every element of the collection matches the predicate or if the\n *   collection is empty, false otherwise\n * @throws NullPointerException if predicate is null\n */\npublic static <E> boolean matchesAll(final Iterable<E> iterable, final Predicate<? super E> predicate) {\n    return IteratorUtils.matchesAll(emptyIteratorIfNull(iterable), predicate);\n}"
            ],
            [
                "matchesAny",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Answers true if a predicate is true for any element of the iterable.\n * <p>\n * A <code>null</code> or empty iterable returns false.\n *\n * @param <E> the type of object the {@link Iterable} contains\n * @param iterable  the {@link Iterable} to use, may be null\n * @param predicate  the predicate to use, may not be null\n * @return true if any element of the collection matches the predicate, false otherwise\n * @throws NullPointerException if predicate is null\n */\npublic static <E> boolean matchesAny(final Iterable<E> iterable, final Predicate<? super E> predicate) {\n    return IteratorUtils.matchesAny(emptyIteratorIfNull(iterable), predicate);\n}"
            ],
            [
                "countMatches",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Counts the number of elements in the input iterable that match the predicate.\n * <p>\n * A <code>null</code> iterable matches no elements.\n *\n * @param <E> the type of object the {@link Iterable} contains\n * @param input  the {@link Iterable} to get the input from, may be null\n * @param predicate  the predicate to use, may not be null\n * @return the number of matches for the predicate in the collection\n * @throws NullPointerException if predicate is null\n */\npublic static <E> long countMatches(final Iterable<E> input, final Predicate<? super E> predicate) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null.\");\n    }\n    return size(filteredIterable(emptyIfNull(input), predicate));\n}"
            ],
            [
                "isEmpty",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Answers true if the provided iterable is empty.\n * <p>\n * A <code>null</code> iterable returns true.\n *\n * @param iterable  the {@link Iterable to use}, may be null\n * @return true if the iterable is null or empty, false otherwise\n */\npublic static boolean isEmpty(final Iterable<?> iterable) {\n    if (iterable instanceof Collection<?>) {\n        return ((Collection<?>) iterable).isEmpty();\n    } else {\n        return IteratorUtils.isEmpty(emptyIteratorIfNull(iterable));\n    }\n}"
            ],
            [
                "contains",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Checks if the object is contained in the given iterable.\n * <p>\n * A <code>null</code> or empty iterable returns false.\n *\n * @param <E> the type of object the {@link Iterable} contains\n * @param iterable  the iterable to check, may be null\n * @param object  the object to check\n * @return true if the object is contained in the iterable, false otherwise\n */\npublic static <E> boolean contains(final Iterable<E> iterable, final Object object) {\n    if (iterable instanceof Collection<?>) {\n        return ((Collection<E>) iterable).contains(object);\n    } else {\n        return IteratorUtils.contains(emptyIteratorIfNull(iterable), object);\n    }\n}"
            ],
            [
                "contains",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Checks if the object is contained in the given iterable. Object equality\n * is tested with an {@code equator} unlike {@link #contains(Iterable, Object)}\n * which uses {@link Object#equals(Object)}.\n * <p>\n * A <code>null</code> or empty iterable returns false.\n * A <code>null</code> object will not be passed to the equator, instead a\n * {@link org.apache.commons.collections4.functors.NullPredicate NullPredicate}\n * will be used.\n *\n * @param <E> the type of object the {@link Iterable} contains\n * @param iterable  the iterable to check, may be null\n * @param object  the object to check\n * @param equator  the equator to use to check, may not be null\n * @return true if the object is contained in the iterable, false otherwise\n * @throws NullPointerException if equator is null\n */\npublic static <E> boolean contains(final Iterable<? extends E> iterable, final E object, final Equator<? super E> equator) {\n    if (equator == null) {\n        throw new NullPointerException(\"Equator must not be null.\");\n    }\n    return matchesAny(iterable, EqualPredicate.equalPredicate(object, equator));\n}"
            ],
            [
                "frequency",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Returns the number of occurrences of the provided object in the iterable.\n *\n * @param <E> the element type that the {@link Iterable} may contain\n * @param <T> the element type of the object to find\n * @param iterable  the {@link Iterable} to search\n * @param obj  the object to find the cardinality of\n * @return the the number of occurrences of obj in iterable\n */\npublic static <E, T extends E> int frequency(final Iterable<E> iterable, final T obj) {\n    if (iterable instanceof Set<?>) {\n        return ((Set<E>) iterable).contains(obj) ? 1 : 0;\n    }\n    if (iterable instanceof Bag<?>) {\n        return ((Bag<E>) iterable).getCount(obj);\n    }\n    return size(filteredIterable(emptyIfNull(iterable), EqualPredicate.<E>equalPredicate(obj)));\n}"
            ],
            [
                "get",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Returns the <code>index</code>-th value in the <code>iterable</code>'s {@link Iterator}, throwing\n * <code>IndexOutOfBoundsException</code> if there is no such element.\n * <p>\n * If the {@link Iterable} is a {@link List}, then it will use {@link List#get(int)}.\n *\n * @param <T> the type of object in the {@link Iterable}.\n * @param iterable  the {@link Iterable} to get a value from, may be null\n * @param index  the index to get\n * @return the object at the specified index\n * @throws IndexOutOfBoundsException if the index is invalid\n */\npublic static <T> T get(final Iterable<T> iterable, final int index) {\n    CollectionUtils.checkIndexBounds(index);\n    if (iterable instanceof List<?>) {\n        return ((List<T>) iterable).get(index);\n    }\n    return IteratorUtils.get(emptyIteratorIfNull(iterable), index);\n}"
            ],
            [
                "size",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Returns the number of elements contained in the given iterator.\n * <p>\n * A <code>null</code> or empty iterator returns {@code 0}.\n *\n * @param iterable  the iterable to check, may be null\n * @return the number of elements contained in the iterable\n */\npublic static int size(final Iterable<?> iterable) {\n    if (iterable instanceof Collection<?>) {\n        return ((Collection<?>) iterable).size();\n    } else {\n        return IteratorUtils.size(emptyIteratorIfNull(iterable));\n    }\n}"
            ],
            [
                "partition",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Partitions all elements from iterable into separate output collections,\n * based on the evaluation of the given predicate.\n * <p>\n * For each predicate, the result will contain a list holding all elements of the\n * input iterable matching the predicate. The last list will hold all elements\n * which didn't match any predicate:\n * <pre>\n *  [C1, R] = partition(I, P1) with\n *  I = input\n *  P1 = first predicate\n *  C1 = collection of elements matching P1\n *  R = collection of elements rejected by all predicates\n * </pre>\n * <p>\n * If the input iterable is <code>null</code>, the same is returned as for an\n * empty iterable.\n * <p>\n * Example: for an input list [1, 2, 3, 4, 5] calling partition with a predicate [x &lt; 3]\n * will result in the following output: [[1, 2], [3, 4, 5]].\n *\n * @param <O>  the type of object the {@link Iterable} contains\n * @param iterable  the iterable to partition, may be null\n * @param predicate  the predicate to use, may not be null\n * @return a list containing the output collections\n * @throws NullPointerException if predicate is null\n */\npublic static <O> List<List<O>> partition(final Iterable<? extends O> iterable, final Predicate<? super O> predicate) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null.\");\n    }\n    // safe\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    final Factory<List<O>> factory = FactoryUtils.instantiateFactory((Class) ArrayList.class);\n    // safe\n    @SuppressWarnings(\"unchecked\")\n    final Predicate<? super O>[] predicates = new Predicate[] { predicate };\n    return partition(iterable, factory, predicates);\n}"
            ],
            [
                "partition",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Partitions all elements from iterable into separate output collections,\n * based on the evaluation of the given predicates.\n * <p>\n * For each predicate, the result will contain a list holding all elements of the\n * input iterable matching the predicate. The last list will hold all elements\n * which didn't match any predicate:\n * <pre>\n *  [C1, C2, R] = partition(I, P1, P2) with\n *  I = input\n *  P1 = first predicate\n *  P2 = second predicate\n *  C1 = collection of elements matching P1\n *  C2 = collection of elements matching P2\n *  R = collection of elements rejected by all predicates\n * </pre>\n * <p>\n * <b>Note</b>: elements are only added to the output collection of the first matching\n * predicate, determined by the order of arguments.\n * <p>\n * If the input iterable is <code>null</code>, the same is returned as for an\n * empty iterable.\n * <p>\n * Example: for an input list [1, 2, 3, 4, 5] calling partition with predicates [x &lt; 3]\n * and [x &lt; 5] will result in the following output: [[1, 2], [3, 4], [5]].\n *\n * @param <O>  the type of object the {@link Iterable} contains\n * @param iterable  the collection to get the input from, may be null\n * @param predicates  the predicates to use, may not be null\n * @return a list containing the output collections\n * @throws NullPointerException if any predicate is null\n */\npublic static <O> List<List<O>> partition(final Iterable<? extends O> iterable, final Predicate<? super O>... predicates) {\n    // safe\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    final Factory<List<O>> factory = FactoryUtils.instantiateFactory((Class) ArrayList.class);\n    return partition(iterable, factory, predicates);\n}"
            ],
            [
                "partition",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Partitions all elements from iterable into separate output collections,\n * based on the evaluation of the given predicates.\n * <p>\n * For each predicate, the returned list will contain a collection holding\n * all elements of the input iterable matching the predicate. The last collection\n * contained in the list will hold all elements which didn't match any predicate:\n * <pre>\n *  [C1, C2, R] = partition(I, P1, P2) with\n *  I = input\n *  P1 = first predicate\n *  P2 = second predicate\n *  C1 = collection of elements matching P1\n *  C2 = collection of elements matching P2\n *  R = collection of elements rejected by all predicates\n * </pre>\n * <p>\n * <b>Note</b>: elements are only added to the output collection of the first matching\n * predicate, determined by the order of arguments.\n * <p>\n * If the input iterable is <code>null</code>, the same is returned as for an\n * empty iterable.\n * If no predicates have been provided, all elements of the input collection\n * will be added to the rejected collection.\n * <p>\n * Example: for an input list [1, 2, 3, 4, 5] calling partition with predicates [x &lt; 3]\n * and [x &lt; 5] will result in the following output: [[1, 2], [3, 4], [5]].\n *\n * @param <O>  the type of object the {@link Iterable} contains\n * @param <R>  the type of the output {@link Collection}\n * @param iterable  the collection to get the input from, may be null\n * @param partitionFactory  the factory used to create the output collections\n * @param predicates  the predicates to use, may not be null\n * @return a list containing the output collections\n * @throws NullPointerException if any predicate is null\n */\npublic static <O, R extends Collection<O>> List<R> partition(final Iterable<? extends O> iterable, final Factory<R> partitionFactory, final Predicate<? super O>... predicates) {\n    if (iterable == null) {\n        final Iterable<O> empty = emptyIterable();\n        return partition(empty, partitionFactory, predicates);\n    }\n    if (predicates == null) {\n        throw new NullPointerException(\"Predicates must not be null.\");\n    }\n    for (Predicate<?> p : predicates) {\n        if (p == null) {\n            throw new NullPointerException(\"Predicate must not be null.\");\n        }\n    }\n    if (predicates.length < 1) {\n        // return the entire input collection as a single partition\n        final R singlePartition = partitionFactory.create();\n        CollectionUtils.addAll(singlePartition, iterable);\n        return Collections.singletonList(singlePartition);\n    }\n    // create the empty partitions\n    final int numberOfPredicates = predicates.length;\n    final int numberOfPartitions = numberOfPredicates + 1;\n    final List<R> partitions = new ArrayList<R>(numberOfPartitions);\n    for (int i = 0; i < numberOfPartitions; ++i) {\n        partitions.add(partitionFactory.create());\n    }\n    // for each element in inputCollection:\n    // find the first predicate that evaluates to true.\n    // if there is a predicate, add the element to the corresponding partition.\n    // if there is no predicate, add it to the last, catch-all partition.\n    for (final O element : iterable) {\n        boolean elementAssigned = false;\n        for (int i = 0; i < numberOfPredicates; ++i) {\n            if (predicates[i].evaluate(element)) {\n                partitions.get(i).add(element);\n                elementAssigned = true;\n                break;\n            }\n        }\n        if (!elementAssigned) {\n            // no predicates evaluated to true\n            // add element to last partition\n            partitions.get(numberOfPredicates).add(element);\n        }\n    }\n    return partitions;\n}"
            ],
            [
                "toList",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Gets a new list with the contents of the provided iterable.\n *\n * @param <E> the element type\n * @param iterable  the iterable to use, may be null\n * @return a list of the iterator contents\n */\npublic static <E> List<E> toList(final Iterable<E> iterable) {\n    return IteratorUtils.toList(emptyIteratorIfNull(iterable));\n}"
            ],
            [
                "toString",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Returns a string representation of the elements of the specified iterable.\n * <p>\n * The string representation consists of a list of the iterable's elements,\n * enclosed in square brackets ({@code \"[]\"}). Adjacent elements are separated\n * by the characters {@code \", \"} (a comma followed by a space). Elements are\n * converted to strings as by {@code String.valueOf(Object)}.\n *\n * @param <E> the element type\n * @param iterable  the iterable to convert to a string, may be null\n * @return a string representation of {@code iterable}\n */\npublic static <E> String toString(final Iterable<E> iterable) {\n    return IteratorUtils.toString(emptyIteratorIfNull(iterable));\n}"
            ],
            [
                "toString",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Returns a string representation of the elements of the specified iterable.\n * <p>\n * The string representation consists of a list of the iterable's elements,\n * enclosed in square brackets ({@code \"[]\"}). Adjacent elements are separated\n * by the characters {@code \", \"} (a comma followed by a space). Elements are\n * converted to strings as by using the provided {@code transformer}.\n *\n * @param <E> the element type\n * @param iterable  the iterable to convert to a string, may be null\n * @param transformer  the transformer used to get a string representation of an element\n * @return a string representation of {@code iterable}\n * @throws NullPointerException if {@code transformer} is null\n */\npublic static <E> String toString(final Iterable<E> iterable, final Transformer<? super E, String> transformer) {\n    if (transformer == null) {\n        throw new NullPointerException(\"Transformer must not be null.\");\n    }\n    return IteratorUtils.toString(emptyIteratorIfNull(iterable), transformer);\n}"
            ],
            [
                "toString",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Returns a string representation of the elements of the specified iterable.\n * <p>\n * The string representation consists of a list of the iterable's elements,\n * enclosed by the provided {@code prefix} and {@code suffix}. Adjacent elements\n * are separated by the provided {@code delimiter}. Elements are converted to\n * strings as by using the provided {@code transformer}.\n *\n * @param <E> the element type\n * @param iterable  the iterable to convert to a string, may be null\n * @param transformer  the transformer used to get a string representation of an element\n * @param delimiter  the string to delimit elements\n * @param prefix  the prefix, prepended to the string representation\n * @param suffix  the suffix, appended to the string representation\n * @return a string representation of {@code iterable}\n * @throws NullPointerException if either transformer, delimiter, prefix or suffix is null\n */\npublic static <E> String toString(final Iterable<E> iterable, final Transformer<? super E, String> transformer, final String delimiter, final String prefix, final String suffix) {\n    return IteratorUtils.toString(emptyIteratorIfNull(iterable), transformer, delimiter, prefix, suffix);\n}"
            ],
            [
                "unmodifiableTrie",
                "org.apache.commons.collections4",
                "TrieUtils",
                "/**\n * Returns an unmodifiable instance of a {@link Trie}\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param trie  the trie to make unmodifiable, must not be null\n * @return an unmodifiable trie backed by the given trie\n * @throws NullPointerException if trie is null\n *\n * @see java.util.Collections#unmodifiableMap(java.util.Map)\n */\npublic static <K, V> Trie<K, V> unmodifiableTrie(final Trie<K, ? extends V> trie) {\n    return UnmodifiableTrie.unmodifiableTrie(trie);\n}"
            ],
            [
                "exceptionClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Gets a Closure that always throws an exception.\n * This could be useful during testing as a placeholder.\n *\n * @see org.apache.commons.collections4.functors.ExceptionClosure\n *\n * @param <E>  the type that the closure acts on\n * @return the closure\n */\npublic static <E> Closure<E> exceptionClosure() {\n    return ExceptionClosure.<E>exceptionClosure();\n}"
            ],
            [
                "nopClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Gets a Closure that will do nothing.\n * This could be useful during testing as a placeholder.\n *\n * @see org.apache.commons.collections4.functors.NOPClosure\n *\n * @param <E>  the type that the closure acts on\n * @return the closure\n */\npublic static <E> Closure<E> nopClosure() {\n    return NOPClosure.<E>nopClosure();\n}"
            ],
            [
                "asClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Creates a Closure that calls a Transformer each time it is called.\n * The transformer will be called using the closure's input object.\n * The transformer's result will be ignored.\n *\n * @see org.apache.commons.collections4.functors.TransformerClosure\n *\n * @param <E>  the type that the closure acts on\n * @param transformer  the transformer to run each time in the closure, null means nop\n * @return the closure\n */\npublic static <E> Closure<E> asClosure(final Transformer<? super E, ?> transformer) {\n    return TransformerClosure.transformerClosure(transformer);\n}"
            ],
            [
                "forClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Creates a Closure that will call the closure <code>count</code> times.\n * <p>\n * A null closure or zero count returns the <code>NOPClosure</code>.\n *\n * @see org.apache.commons.collections4.functors.ForClosure\n *\n * @param <E>  the type that the closure acts on\n * @param count  the number of times to loop\n * @param closure  the closure to call repeatedly\n * @return the <code>for</code> closure\n */\npublic static <E> Closure<E> forClosure(final int count, final Closure<? super E> closure) {\n    return ForClosure.forClosure(count, closure);\n}"
            ],
            [
                "whileClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Creates a Closure that will call the closure repeatedly until the\n * predicate returns false.\n *\n * @see org.apache.commons.collections4.functors.WhileClosure\n *\n * @param <E>  the type that the closure acts on\n * @param predicate  the predicate to use as an end of loop test, not null\n * @param closure  the closure to call repeatedly, not null\n * @return the <code>while</code> closure\n * @throws NullPointerException if either argument is null\n */\npublic static <E> Closure<E> whileClosure(final Predicate<? super E> predicate, final Closure<? super E> closure) {\n    return WhileClosure.<E>whileClosure(predicate, closure, false);\n}"
            ],
            [
                "doWhileClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Creates a Closure that will call the closure once and then repeatedly\n * until the predicate returns false.\n *\n * @see org.apache.commons.collections4.functors.WhileClosure\n *\n * @param <E>  the type that the closure acts on\n * @param closure  the closure to call repeatedly, not null\n * @param predicate  the predicate to use as an end of loop test, not null\n * @return the <code>do-while</code> closure\n * @throws NullPointerException if either argument is null\n */\npublic static <E> Closure<E> doWhileClosure(final Closure<? super E> closure, final Predicate<? super E> predicate) {\n    return WhileClosure.<E>whileClosure(predicate, closure, true);\n}"
            ],
            [
                "invokerClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Creates a Closure that will invoke a specific method on the closure's\n * input object by reflection.\n *\n * @see org.apache.commons.collections4.functors.InvokerTransformer\n * @see org.apache.commons.collections4.functors.TransformerClosure\n *\n * @param <E>  the type that the closure acts on\n * @param methodName  the name of the method\n * @return the <code>invoker</code> closure\n * @throws NullPointerException if the method name is null\n */\npublic static <E> Closure<E> invokerClosure(final String methodName) {\n    // reuse transformer as it has caching - this is lazy really, should have inner class here\n    return asClosure(InvokerTransformer.<E, Object>invokerTransformer(methodName));\n}"
            ],
            [
                "invokerClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Creates a Closure that will invoke a specific method on the closure's\n * input object by reflection.\n *\n * @see org.apache.commons.collections4.functors.InvokerTransformer\n * @see org.apache.commons.collections4.functors.TransformerClosure\n *\n * @param <E>  the type that the closure acts on\n * @param methodName  the name of the method\n * @param paramTypes  the parameter types\n * @param args  the arguments\n * @return the <code>invoker</code> closure\n * @throws NullPointerException if the method name is null\n * @throws IllegalArgumentException if the paramTypes and args don't match\n */\npublic static <E> Closure<E> invokerClosure(final String methodName, final Class<?>[] paramTypes, final Object[] args) {\n    // reuse transformer as it has caching - this is lazy really, should have inner class here\n    return asClosure(InvokerTransformer.<E, Object>invokerTransformer(methodName, paramTypes, args));\n}"
            ],
            [
                "chainedClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Create a new Closure that calls each closure in turn, passing the\n * result into the next closure.\n *\n * @see org.apache.commons.collections4.functors.ChainedClosure\n *\n * @param <E>  the type that the closure acts on\n * @param closures  an array of closures to chain\n * @return the <code>chained</code> closure\n * @throws NullPointerException if the closures array is null\n * @throws NullPointerException if any closure in the array is null\n */\npublic static <E> Closure<E> chainedClosure(final Closure<? super E>... closures) {\n    return ChainedClosure.chainedClosure(closures);\n}"
            ],
            [
                "chainedClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Create a new Closure that calls each closure in turn, passing the\n * result into the next closure. The ordering is that of the iterator()\n * method on the collection.\n *\n * @see org.apache.commons.collections4.functors.ChainedClosure\n *\n * @param <E>  the type that the closure acts on\n * @param closures  a collection of closures to chain\n * @return the <code>chained</code> closure\n * @throws NullPointerException if the closures collection is null\n * @throws NullPointerException if any closure in the collection is null\n * @throws IllegalArgumentException if the closures collection is empty\n */\npublic static <E> Closure<E> chainedClosure(final Collection<? extends Closure<? super E>> closures) {\n    return ChainedClosure.chainedClosure(closures);\n}"
            ],
            [
                "ifClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Create a new Closure that calls another closure based on the\n * result of the specified predicate.\n *\n * @see org.apache.commons.collections4.functors.IfClosure\n *\n * @param <E>  the type that the closure acts on\n * @param predicate  the validating predicate\n * @param trueClosure  the closure called if the predicate is true\n * @return the <code>if</code> closure\n * @throws NullPointerException if the predicate or closure is null\n * @since 3.2\n */\npublic static <E> Closure<E> ifClosure(final Predicate<? super E> predicate, final Closure<? super E> trueClosure) {\n    return IfClosure.<E>ifClosure(predicate, trueClosure);\n}"
            ],
            [
                "ifClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Create a new Closure that calls one of two closures depending\n * on the specified predicate.\n *\n * @see org.apache.commons.collections4.functors.IfClosure\n *\n * @param <E>  the type that the closure acts on\n * @param predicate  the predicate to switch on\n * @param trueClosure  the closure called if the predicate is true\n * @param falseClosure  the closure called if the predicate is false\n * @return the <code>switch</code> closure\n * @throws NullPointerException if the predicate or either closure is null\n */\npublic static <E> Closure<E> ifClosure(final Predicate<? super E> predicate, final Closure<? super E> trueClosure, final Closure<? super E> falseClosure) {\n    return IfClosure.<E>ifClosure(predicate, trueClosure, falseClosure);\n}"
            ],
            [
                "switchClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Create a new Closure that calls one of the closures depending\n * on the predicates.\n * <p>\n * The closure at array location 0 is called if the predicate at array\n * location 0 returned true. Each predicate is evaluated\n * until one returns true.\n *\n * @see org.apache.commons.collections4.functors.SwitchClosure\n *\n * @param <E>  the type that the closure acts on\n * @param predicates  an array of predicates to check, not null\n * @param closures  an array of closures to call, not null\n * @return the <code>switch</code> closure\n * @throws NullPointerException if the either array is null\n * @throws NullPointerException if any element in the arrays is null\n * @throws IllegalArgumentException if the arrays have different sizes\n */\npublic static <E> Closure<E> switchClosure(final Predicate<? super E>[] predicates, final Closure<? super E>[] closures) {\n    return SwitchClosure.<E>switchClosure(predicates, closures, null);\n}"
            ],
            [
                "switchClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Create a new Closure that calls one of the closures depending\n * on the predicates.\n * <p>\n * The closure at array location 0 is called if the predicate at array\n * location 0 returned true. Each predicate is evaluated\n * until one returns true. If no predicates evaluate to true, the default\n * closure is called.\n *\n * @see org.apache.commons.collections4.functors.SwitchClosure\n *\n * @param <E>  the type that the closure acts on\n * @param predicates  an array of predicates to check, not null\n * @param closures  an array of closures to call, not null\n * @param defaultClosure  the default to call if no predicate matches\n * @return the <code>switch</code> closure\n * @throws NullPointerException if the either array is null\n * @throws NullPointerException if any element in the arrays is null\n * @throws IllegalArgumentException if the arrays are different sizes\n */\npublic static <E> Closure<E> switchClosure(final Predicate<? super E>[] predicates, final Closure<? super E>[] closures, final Closure<? super E> defaultClosure) {\n    return SwitchClosure.<E>switchClosure(predicates, closures, defaultClosure);\n}"
            ],
            [
                "switchClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Create a new Closure that calls one of the closures depending\n * on the predicates.\n * <p>\n * The Map consists of Predicate keys and Closure values. A closure\n * is called if its matching predicate returns true. Each predicate is evaluated\n * until one returns true. If no predicates evaluate to true, the default\n * closure is called. The default closure is set in the map with a\n * null key. The ordering is that of the iterator() method on the entryset\n * collection of the map.\n *\n * @see org.apache.commons.collections4.functors.SwitchClosure\n *\n * @param <E>  the type that the closure acts on\n * @param predicatesAndClosures  a map of predicates to closures\n * @return the <code>switch</code> closure\n * @throws NullPointerException if the map is null\n * @throws NullPointerException if any closure in the map is null\n * @throws IllegalArgumentException if the map is empty\n * @throws ClassCastException  if the map elements are of the wrong type\n */\npublic static <E> Closure<E> switchClosure(final Map<Predicate<E>, Closure<E>> predicatesAndClosures) {\n    return SwitchClosure.switchClosure(predicatesAndClosures);\n}"
            ],
            [
                "switchMapClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Create a new Closure that uses the input object as a key to find the\n * closure to call.\n * <p>\n * The Map consists of object keys and Closure values. A closure\n * is called if the input object equals the key. If there is no match, the\n * default closure is called. The default closure is set in the map\n * using a null key.\n *\n * @see org.apache.commons.collections4.functors.SwitchClosure\n *\n * @param <E>  the type that the closure acts on\n * @param objectsAndClosures  a map of objects to closures\n * @return the closure\n * @throws NullPointerException if the map is null\n * @throws NullPointerException if any closure in the map is null\n * @throws IllegalArgumentException if the map is empty\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Closure<E> switchMapClosure(final Map<? extends E, Closure<E>> objectsAndClosures) {\n    if (objectsAndClosures == null) {\n        throw new NullPointerException(\"The object and closure map must not be null\");\n    }\n    final Closure<? super E> def = objectsAndClosures.remove(null);\n    final int size = objectsAndClosures.size();\n    final Closure<? super E>[] trs = new Closure[size];\n    final Predicate<E>[] preds = new Predicate[size];\n    int i = 0;\n    for (final Map.Entry<? extends E, Closure<E>> entry : objectsAndClosures.entrySet()) {\n        preds[i] = EqualPredicate.<E>equalPredicate(entry.getKey());\n        trs[i] = entry.getValue();\n        i++;\n    }\n    return ClosureUtils.<E>switchClosure(preds, trs, def);\n}"
            ],
            [
                "unmodifiableTrie",
                "org.apache.commons.collections4.trie",
                "UnmodifiableTrie",
                "/**\n * Factory method to create a unmodifiable trie.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param trie  the trie to decorate, must not be null\n * @return a new unmodifiable trie\n * @throws NullPointerException if trie is null\n */\npublic static <K, V> Trie<K, V> unmodifiableTrie(final Trie<K, ? extends V> trie) {\n    if (trie instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final Trie<K, V> tmpTrie = (Trie<K, V>) trie;\n        return tmpTrie;\n    }\n    return new UnmodifiableTrie<K, V>(trie);\n}"
            ],
            [
                "isOutOfBoundsIndex",
                "org.apache.commons.collections4.trie",
                "KeyAnalyzer",
                "/**\n * Returns true if bitIndex is a {@link KeyAnalyzer#OUT_OF_BOUNDS_BIT_KEY}.\n */\nstatic boolean isOutOfBoundsIndex(final int bitIndex) {\n    return bitIndex == OUT_OF_BOUNDS_BIT_KEY;\n}"
            ],
            [
                "isEqualBitKey",
                "org.apache.commons.collections4.trie",
                "KeyAnalyzer",
                "/**\n * Returns true if bitIndex is a {@link KeyAnalyzer#EQUAL_BIT_KEY}.\n */\nstatic boolean isEqualBitKey(final int bitIndex) {\n    return bitIndex == EQUAL_BIT_KEY;\n}"
            ],
            [
                "isNullBitKey",
                "org.apache.commons.collections4.trie",
                "KeyAnalyzer",
                "/**\n * Returns true if bitIndex is a {@link KeyAnalyzer#NULL_BIT_KEY}.\n */\nstatic boolean isNullBitKey(final int bitIndex) {\n    return bitIndex == NULL_BIT_KEY;\n}"
            ],
            [
                "isValidBitIndex",
                "org.apache.commons.collections4.trie",
                "KeyAnalyzer",
                "/**\n * Returns true if the given bitIndex is valid.\n * Indices are considered valid if they're between 0 and {@link Integer#MAX_VALUE}\n */\nstatic boolean isValidBitIndex(final int bitIndex) {\n    return bitIndex >= 0;\n}"
            ],
            [
                "isValidUplink",
                "org.apache.commons.collections4.trie",
                "AbstractPatriciaTrie",
                "/**\n * Returns true if 'next' is a valid uplink coming from 'from'.\n */\nstatic boolean isValidUplink(final TrieEntry<?, ?> next, final TrieEntry<?, ?> from) {\n    return next != null && next.bitIndex <= from.bitIndex && !next.isEmpty();\n}"
            ],
            [
                "compare",
                "org.apache.commons.collections4.trie",
                "AbstractBitwiseTrie",
                "/**\n * Returns true if both values are either null or equal.\n */\nstatic boolean compare(final Object a, final Object b) {\n    return a == null ? b == null : a.equals(b);\n}"
            ],
            [
                "transformingSortedMap",
                "org.apache.commons.collections4.map",
                "TransformedSortedMap",
                "/**\n * Factory method to create a transforming sorted map.\n * <p>\n * If there are any elements already in the map being decorated, they are NOT transformed.\n * Contrast this with {@link #transformedSortedMap(SortedMap, Transformer, Transformer)}.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param keyTransformer  the predicate to validate the keys, null means no transformation\n * @param valueTransformer  the predicate to validate to values, null means no transformation\n * @return a new transformed sorted map\n * @throws NullPointerException if the map is null\n * @since 4.0\n */\npublic static <K, V> TransformedSortedMap<K, V> transformingSortedMap(final SortedMap<K, V> map, final Transformer<? super K, ? extends K> keyTransformer, final Transformer<? super V, ? extends V> valueTransformer) {\n    return new TransformedSortedMap<K, V>(map, keyTransformer, valueTransformer);\n}"
            ],
            [
                "transformedSortedMap",
                "org.apache.commons.collections4.map",
                "TransformedSortedMap",
                "/**\n * Factory method to create a transforming sorted map that will transform\n * existing contents of the specified map.\n * <p>\n * If there are any elements already in the map being decorated, they\n * will be transformed by this method.\n * Contrast this with {@link #transformingSortedMap(SortedMap, Transformer, Transformer)}.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param keyTransformer  the transformer to use for key conversion, null means no transformation\n * @param valueTransformer  the transformer to use for value conversion, null means no transformation\n * @return a new transformed sorted map\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> TransformedSortedMap<K, V> transformedSortedMap(final SortedMap<K, V> map, final Transformer<? super K, ? extends K> keyTransformer, final Transformer<? super V, ? extends V> valueTransformer) {\n    final TransformedSortedMap<K, V> decorated = new TransformedSortedMap<K, V>(map, keyTransformer, valueTransformer);\n    if (map.size() > 0) {\n        final Map<K, V> transformed = decorated.transformMap(map);\n        decorated.clear();\n        // avoids double transformation\n        decorated.decorated().putAll(transformed);\n    }\n    return decorated;\n}"
            ],
            [
                "predicatedMap",
                "org.apache.commons.collections4.map",
                "PredicatedMap",
                "/**\n * Factory method to create a predicated (validating) map.\n * <p>\n * If there are any elements already in the list being decorated, they\n * are validated.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param keyPredicate  the predicate to validate the keys, null means no check\n * @param valuePredicate  the predicate to validate to values, null means no check\n * @return a new predicated map\n * @throws NullPointerException if the map is null\n * @since 4.0\n */\npublic static <K, V> PredicatedMap<K, V> predicatedMap(final Map<K, V> map, final Predicate<? super K> keyPredicate, final Predicate<? super V> valuePredicate) {\n    return new PredicatedMap<K, V>(map, keyPredicate, valuePredicate);\n}"
            ],
            [
                "fixedSizeSortedMap",
                "org.apache.commons.collections4.map",
                "FixedSizeSortedMap",
                "/**\n * Factory method to create a fixed size sorted map.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @return a new fixed size sorted map\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> FixedSizeSortedMap<K, V> fixedSizeSortedMap(final SortedMap<K, V> map) {\n    return new FixedSizeSortedMap<K, V>(map);\n}"
            ],
            [
                "unmodifiableSortedMap",
                "org.apache.commons.collections4.map",
                "UnmodifiableSortedMap",
                "/**\n * Factory method to create an unmodifiable sorted map.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @return a new unmodifiable sorted map\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> SortedMap<K, V> unmodifiableSortedMap(final SortedMap<K, ? extends V> map) {\n    if (map instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final SortedMap<K, V> tmpMap = (SortedMap<K, V>) map;\n        return tmpMap;\n    }\n    return new UnmodifiableSortedMap<K, V>(map);\n}"
            ],
            [
                "predicatedSortedMap",
                "org.apache.commons.collections4.map",
                "PredicatedSortedMap",
                "/**\n * Factory method to create a predicated (validating) sorted map.\n * <p>\n * If there are any elements already in the list being decorated, they\n * are validated.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param keyPredicate  the predicate to validate the keys, null means no check\n * @param valuePredicate  the predicate to validate to values, null means no check\n * @return a new predicated sorted map\n * @throws NullPointerException if the map is null\n * @since 4.0\n */\npublic static <K, V> PredicatedSortedMap<K, V> predicatedSortedMap(final SortedMap<K, V> map, final Predicate<? super K> keyPredicate, final Predicate<? super V> valuePredicate) {\n    return new PredicatedSortedMap<K, V>(map, keyPredicate, valuePredicate);\n}"
            ],
            [
                "defaultedMap",
                "org.apache.commons.collections4.map",
                "DefaultedMap",
                "//-----------------------------------------------------------------------\n/**\n * Factory method to create a defaulting map.\n * <p>\n * The value specified is returned when a missing key is found.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param defaultValue  the default value to return when the key is not found\n * @return a new defaulting map\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> DefaultedMap<K, V> defaultedMap(final Map<K, V> map, final V defaultValue) {\n    return new DefaultedMap<K, V>(map, ConstantTransformer.constantTransformer(defaultValue));\n}"
            ],
            [
                "defaultedMap",
                "org.apache.commons.collections4.map",
                "DefaultedMap",
                "/**\n * Factory method to create a defaulting map.\n * <p>\n * The factory specified is called when a missing key is found.\n * The result will be returned as the result of the map get(key) method.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param factory  the factory to use to create entries, must not be null\n * @return a new defaulting map\n * @throws NullPointerException if map or factory is null\n * @since 4.0\n */\npublic static <K, V> DefaultedMap<K, V> defaultedMap(final Map<K, V> map, final Factory<? extends V> factory) {\n    if (factory == null) {\n        throw new IllegalArgumentException(\"Factory must not be null\");\n    }\n    return new DefaultedMap<K, V>(map, FactoryTransformer.factoryTransformer(factory));\n}"
            ],
            [
                "defaultedMap",
                "org.apache.commons.collections4.map",
                "DefaultedMap",
                "/**\n * Factory method to create a defaulting map.\n * <p>\n * The transformer specified is called when a missing key is found.\n * The key is passed to the transformer as the input, and the result\n * will be returned as the result of the map get(key) method.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param transformer  the transformer to use as a factory to create entries, must not be null\n * @return a new defaulting map\n * @throws NullPointerException if map or factory is null\n * @since 4.0\n */\npublic static <K, V> Map<K, V> defaultedMap(final Map<K, V> map, final Transformer<? super K, ? extends V> transformer) {\n    if (transformer == null) {\n        throw new IllegalArgumentException(\"Transformer must not be null\");\n    }\n    return new DefaultedMap<K, V>(map, transformer);\n}"
            ],
            [
                "fixedSizeMap",
                "org.apache.commons.collections4.map",
                "FixedSizeMap",
                "/**\n * Factory method to create a fixed size map.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @return a new fixed size map\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> FixedSizeMap<K, V> fixedSizeMap(final Map<K, V> map) {\n    return new FixedSizeMap<K, V>(map);\n}"
            ],
            [
                "lazySortedMap",
                "org.apache.commons.collections4.map",
                "LazySortedMap",
                "/**\n * Factory method to create a lazily instantiated sorted map.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param factory  the factory to use, must not be null\n * @return a new lazy sorted map\n * @throws NullPointerException if map or factory is null\n * @since 4.0\n */\npublic static <K, V> LazySortedMap<K, V> lazySortedMap(final SortedMap<K, V> map, final Factory<? extends V> factory) {\n    return new LazySortedMap<K, V>(map, factory);\n}"
            ],
            [
                "lazySortedMap",
                "org.apache.commons.collections4.map",
                "LazySortedMap",
                "/**\n * Factory method to create a lazily instantiated sorted map.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param factory  the factory to use, must not be null\n * @return a new lazy sorted map\n * @throws NullPointerException if map or factory is null\n * @since 4.0\n */\npublic static <K, V> LazySortedMap<K, V> lazySortedMap(final SortedMap<K, V> map, final Transformer<? super K, ? extends V> factory) {\n    return new LazySortedMap<K, V>(map, factory);\n}"
            ],
            [
                "unmodifiableOrderedMap",
                "org.apache.commons.collections4.map",
                "UnmodifiableOrderedMap",
                "/**\n * Factory method to create an unmodifiable sorted map.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @return a new ordered map\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> OrderedMap<K, V> unmodifiableOrderedMap(final OrderedMap<? extends K, ? extends V> map) {\n    if (map instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final OrderedMap<K, V> tmpMap = (OrderedMap<K, V>) map;\n        return tmpMap;\n    }\n    return new UnmodifiableOrderedMap<K, V>(map);\n}"
            ],
            [
                "unmodifiableMap",
                "org.apache.commons.collections4.map",
                "UnmodifiableMap",
                "/**\n * Factory method to create an unmodifiable map.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @return a new unmodifiable map\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> Map<K, V> unmodifiableMap(final Map<? extends K, ? extends V> map) {\n    if (map instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final Map<K, V> tmpMap = (Map<K, V>) map;\n        return tmpMap;\n    }\n    return new UnmodifiableMap<K, V>(map);\n}"
            ],
            [
                "listOrderedMap",
                "org.apache.commons.collections4.map",
                "ListOrderedMap",
                "/**\n * Factory method to create an ordered map.\n * <p>\n * An <code>ArrayList</code> is used to retain order.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @return a new list ordered map\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> ListOrderedMap<K, V> listOrderedMap(final Map<K, V> map) {\n    return new ListOrderedMap<K, V>(map);\n}"
            ],
            [
                "unmodifiableEntrySet",
                "org.apache.commons.collections4.map",
                "UnmodifiableEntrySet",
                "/**\n * Factory method to create an unmodifiable set of Map Entry objects.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param set  the set to decorate, must not be null\n * @return a new unmodifiable entry set\n * @throws NullPointerException if set is null\n * @since 4.0\n */\npublic static <K, V> Set<Map.Entry<K, V>> unmodifiableEntrySet(final Set<Map.Entry<K, V>> set) {\n    if (set instanceof Unmodifiable) {\n        return set;\n    }\n    return new UnmodifiableEntrySet<K, V>(set);\n}"
            ],
            [
                "resolve",
                "org.apache.commons.collections4.map",
                "AbstractReferenceMap",
                "/**\n * Resolve enum from int.\n * @param value  the int value\n * @return ReferenceType\n * @throws IllegalArgumentException if the specified value is invalid.\n */\npublic static ReferenceStrength resolve(final int value) {\n    switch(value) {\n        case 0:\n            return HARD;\n        case 1:\n            return SOFT;\n        case 2:\n            return WEAK;\n        default:\n            throw new IllegalArgumentException();\n    }\n}"
            ],
            [
                "resolve",
                "org.apache.commons.collections4.map",
                "ReferenceStrength",
                "/**\n * Resolve enum from int.\n * @param value  the int value\n * @return ReferenceType\n * @throws IllegalArgumentException if the specified value is invalid.\n */\npublic static ReferenceStrength resolve(final int value) {\n    switch(value) {\n        case 0:\n            return HARD;\n        case 1:\n            return SOFT;\n        case 2:\n            return WEAK;\n        default:\n            throw new IllegalArgumentException();\n    }\n}"
            ],
            [
                "multiKeyMap",
                "org.apache.commons.collections4.map",
                "MultiKeyMap",
                "//-----------------------------------------------------------------------\n/**\n * Decorates the specified map to add the MultiKeyMap API and fast query.\n * The map must not be null and must be empty.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, not null\n * @return a new multi key map\n * @throws NullPointerException if map is null\n * @throws IllegalArgumentException if the map is not empty\n * @since 4.0\n */\npublic static <K, V> MultiKeyMap<K, V> multiKeyMap(final AbstractHashedMap<MultiKey<? extends K>, V> map) {\n    if (map == null) {\n        throw new NullPointerException(\"Map must not be null\");\n    }\n    if (map.size() > 0) {\n        throw new IllegalArgumentException(\"Map must be empty\");\n    }\n    return new MultiKeyMap<K, V>(map);\n}"
            ],
            [
                "lazyMap",
                "org.apache.commons.collections4.map",
                "LazyMap",
                "/**\n * Factory method to create a lazily instantiated map.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param factory  the factory to use, must not be null\n * @return a new lazy map\n * @throws NullPointerException if map or factory is null\n * @since 4.0\n */\npublic static <K, V> LazyMap<K, V> lazyMap(final Map<K, V> map, final Factory<? extends V> factory) {\n    return new LazyMap<K, V>(map, factory);\n}"
            ],
            [
                "lazyMap",
                "org.apache.commons.collections4.map",
                "LazyMap",
                "/**\n * Factory method to create a lazily instantiated map.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param factory  the factory to use, must not be null\n * @return a new lazy map\n * @throws NullPointerException if map or factory is null\n * @since 4.0\n */\npublic static <V, K> LazyMap<K, V> lazyMap(final Map<K, V> map, final Transformer<? super K, ? extends V> factory) {\n    return new LazyMap<K, V>(map, factory);\n}"
            ],
            [
                "multiValueMap",
                "org.apache.commons.collections4.map",
                "MultiValueMap",
                "/**\n * Creates a map which wraps the given map and\n * maps keys to ArrayLists.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to wrap\n * @return a new multi-value map\n * @since 4.0\n */\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\npublic static <K, V> MultiValueMap<K, V> multiValueMap(final Map<K, ? super Collection<V>> map) {\n    return MultiValueMap.<K, V, ArrayList>multiValueMap((Map<K, ? super Collection>) map, ArrayList.class);\n}"
            ],
            [
                "multiValueMap",
                "org.apache.commons.collections4.map",
                "MultiValueMap",
                "/**\n * Creates a map which decorates the given <code>map</code> and\n * maps keys to collections of type <code>collectionClass</code>.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param <C>  the collection class type\n * @param map  the map to wrap\n * @param collectionClass  the type of the collection class\n * @return a new multi-value map\n * @since 4.0\n */\npublic static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(final Map<K, ? super C> map, final Class<C> collectionClass) {\n    return new MultiValueMap<K, V>(map, new ReflectionFactory<C>(collectionClass));\n}"
            ],
            [
                "multiValueMap",
                "org.apache.commons.collections4.map",
                "MultiValueMap",
                "/**\n * Creates a map which decorates the given <code>map</code> and\n * creates the value collections using the supplied <code>collectionFactory</code>.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param <C>  the collection class type\n * @param map  the map to decorate\n * @param collectionFactory  the collection factory (must return a Collection object).\n * @return a new multi-value map\n * @since 4.0\n */\npublic static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(final Map<K, ? super C> map, final Factory<C> collectionFactory) {\n    return new MultiValueMap<K, V>(map, collectionFactory);\n}"
            ],
            [
                "transformingMap",
                "org.apache.commons.collections4.map",
                "TransformedMap",
                "/**\n * Factory method to create a transforming map.\n * <p>\n * If there are any elements already in the map being decorated, they\n * are NOT transformed.\n * Contrast this with {@link #transformedMap(Map, Transformer, Transformer)}.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param keyTransformer  the transformer to use for key conversion, null means no transformation\n * @param valueTransformer  the transformer to use for value conversion, null means no transformation\n * @return a new transformed map\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> TransformedMap<K, V> transformingMap(final Map<K, V> map, final Transformer<? super K, ? extends K> keyTransformer, final Transformer<? super V, ? extends V> valueTransformer) {\n    return new TransformedMap<K, V>(map, keyTransformer, valueTransformer);\n}"
            ],
            [
                "transformedMap",
                "org.apache.commons.collections4.map",
                "TransformedMap",
                "/**\n * Factory method to create a transforming map that will transform\n * existing contents of the specified map.\n * <p>\n * If there are any elements already in the map being decorated, they\n * will be transformed by this method.\n * Contrast this with {@link #transformingMap(Map, Transformer, Transformer)}.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param keyTransformer  the transformer to use for key conversion, null means no transformation\n * @param valueTransformer  the transformer to use for value conversion, null means no transformation\n * @return a new transformed map\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> TransformedMap<K, V> transformedMap(final Map<K, V> map, final Transformer<? super K, ? extends K> keyTransformer, final Transformer<? super V, ? extends V> valueTransformer) {\n    final TransformedMap<K, V> decorated = new TransformedMap<K, V>(map, keyTransformer, valueTransformer);\n    if (map.size() > 0) {\n        final Map<K, V> transformed = decorated.transformMap(map);\n        decorated.clear();\n        // avoids double transformation\n        decorated.decorated().putAll(transformed);\n    }\n    return decorated;\n}"
            ],
            [
                "synchronizedMultiSet",
                "org.apache.commons.collections4",
                "MultiSetUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns a synchronized (thread-safe) multiset backed by the given multiset.\n * In order to guarantee serial access, it is critical that all access to the\n * backing multiset is accomplished through the returned multiset.\n * <p>\n * It is imperative that the user manually synchronize on the returned multiset\n * when iterating over it:\n *\n * <pre>\n * MultiSet multiset = MultiSetUtils.synchronizedMultiSet(new HashMultiSet());\n * ...\n * synchronized(multiset) {\n *     Iterator i = multiset.iterator(); // Must be in synchronized block\n *     while (i.hasNext())\n *         foo(i.next());\n *     }\n * }\n * </pre>\n *\n * Failure to follow this advice may result in non-deterministic behavior.\n *\n * @param <E> the element type\n * @param multiset the multiset to synchronize, must not be null\n * @return a synchronized multiset backed by that multiset\n * @throws NullPointerException if the MultiSet is null\n */\npublic static <E> MultiSet<E> synchronizedMultiSet(final MultiSet<E> multiset) {\n    return SynchronizedMultiSet.synchronizedMultiSet(multiset);\n}"
            ],
            [
                "unmodifiableMultiSet",
                "org.apache.commons.collections4",
                "MultiSetUtils",
                "/**\n * Returns an unmodifiable view of the given multiset. Any modification attempts\n * to the returned multiset will raise an {@link UnsupportedOperationException}.\n *\n * @param <E> the element type\n * @param multiset the multiset whose unmodifiable view is to be returned, must not be null\n * @return an unmodifiable view of that multiset\n * @throws NullPointerException if the MultiSet is null\n */\npublic static <E> MultiSet<E> unmodifiableMultiSet(final MultiSet<? extends E> multiset) {\n    return UnmodifiableMultiSet.unmodifiableMultiSet(multiset);\n}"
            ],
            [
                "predicatedMultiSet",
                "org.apache.commons.collections4",
                "MultiSetUtils",
                "/**\n * Returns a predicated (validating) multiset backed by the given multiset.\n * <p>\n * Only objects that pass the test in the given predicate can be added to\n * the multiset. Trying to add an invalid object results in an\n * IllegalArgumentException. It is important not to use the original multiset\n * after invoking this method, as it is a backdoor for adding invalid\n * objects.\n *\n * @param <E> the element type\n * @param multiset the multiset to predicate, must not be null\n * @param predicate the predicate for the multiset, must not be null\n * @return a predicated multiset backed by the given multiset\n * @throws NullPointerException if the MultiSet or Predicate is null\n */\npublic static <E> MultiSet<E> predicatedMultiSet(final MultiSet<E> multiset, final Predicate<? super E> predicate) {\n    return PredicatedMultiSet.predicatedMultiSet(multiset, predicate);\n}"
            ],
            [
                "emptyMultiSet",
                "org.apache.commons.collections4",
                "MultiSetUtils",
                "/**\n * Get an empty <code>MultiSet</code>.\n *\n * @param <E> the element type\n * @return an empty MultiSet\n */\n// OK, empty multiset is compatible with any type\n@SuppressWarnings(\"unchecked\")\npublic static <E> MultiSet<E> emptyMultiSet() {\n    return EMPTY_MULTISET;\n}"
            ],
            [
                "unmodifiableMultiValuedMap",
                "org.apache.commons.collections4.multimap",
                "UnmodifiableMultiValuedMap",
                "/**\n * Factory method to create an unmodifiable MultiValuedMap.\n * <p>\n * If the map passed in is already unmodifiable, it is returned.\n *\n * @param <K> the type of key elements\n * @param <V> the type of value elements\n * @param map  the map to decorate, may not be null\n * @return an unmodifiable MultiValuedMap\n * @throws NullPointerException if map is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <K, V> UnmodifiableMultiValuedMap<K, V> unmodifiableMultiValuedMap(MultiValuedMap<? extends K, ? extends V> map) {\n    if (map instanceof Unmodifiable) {\n        return (UnmodifiableMultiValuedMap<K, V>) map;\n    }\n    return new UnmodifiableMultiValuedMap<K, V>(map);\n}"
            ],
            [
                "transformingMap",
                "org.apache.commons.collections4.multimap",
                "TransformedMultiValuedMap",
                "/**\n * Factory method to create a transforming MultiValuedMap.\n * <p>\n * If there are any elements already in the map being decorated, they are\n * NOT transformed. Contrast this with\n * {@link #transformedMap(MultiValuedMap, Transformer, Transformer)}.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the MultiValuedMap to decorate, may not be null\n * @param keyTransformer  the transformer to use for key conversion, null means no conversion\n * @param valueTransformer  the transformer to use for value conversion, null means no conversion\n * @return a new transformed MultiValuedMap\n * @throws NullPointerException if map is null\n */\npublic static <K, V> TransformedMultiValuedMap<K, V> transformingMap(final MultiValuedMap<K, V> map, final Transformer<? super K, ? extends K> keyTransformer, final Transformer<? super V, ? extends V> valueTransformer) {\n    return new TransformedMultiValuedMap<K, V>(map, keyTransformer, valueTransformer);\n}"
            ],
            [
                "transformedMap",
                "org.apache.commons.collections4.multimap",
                "TransformedMultiValuedMap",
                "/**\n * Factory method to create a transforming MultiValuedMap that will\n * transform existing contents of the specified map.\n * <p>\n * If there are any elements already in the map being decorated, they will\n * be transformed by this method. Contrast this with\n * {@link #transformingMap(MultiValuedMap, Transformer, Transformer)}.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the MultiValuedMap to decorate, may not be null\n * @param keyTransformer  the transformer to use for key conversion, null means no conversion\n * @param valueTransformer  the transformer to use for value conversion, null means no conversion\n * @return a new transformed MultiValuedMap\n * @throws NullPointerException if map is null\n */\npublic static <K, V> TransformedMultiValuedMap<K, V> transformedMap(final MultiValuedMap<K, V> map, final Transformer<? super K, ? extends K> keyTransformer, final Transformer<? super V, ? extends V> valueTransformer) {\n    final TransformedMultiValuedMap<K, V> decorated = new TransformedMultiValuedMap<K, V>(map, keyTransformer, valueTransformer);\n    if (!map.isEmpty()) {\n        final MultiValuedMap<K, V> mapCopy = new ArrayListValuedHashMap<K, V>(map);\n        decorated.clear();\n        decorated.putAll(mapCopy);\n    }\n    return decorated;\n}"
            ],
            [
                "lazyList",
                "org.apache.commons.collections4.list",
                "LazyList",
                "/**\n * Factory method to create a lazily instantiating list.\n *\n * @param <E> the type of the elements in the list\n * @param list  the list to decorate, must not be null\n * @param factory  the factory to use for creation, must not be null\n * @return a new lazy list\n * @throws NullPointerException if list or factory is null\n * @since 4.0\n */\npublic static <E> LazyList<E> lazyList(final List<E> list, final Factory<? extends E> factory) {\n    return new LazyList<E>(list, factory);\n}"
            ],
            [
                "setUniqueList",
                "org.apache.commons.collections4.list",
                "SetUniqueList",
                "/**\n * Factory method to create a SetList using the supplied list to retain order.\n * <p>\n * If the list contains duplicates, these are removed (first indexed one\n * kept). A <code>HashSet</code> is used for the set behaviour.\n *\n * @param <E>  the element type\n * @param list  the list to decorate, must not be null\n * @return a new {@link SetUniqueList}\n * @throws NullPointerException if list is null\n * @since 4.0\n */\npublic static <E> SetUniqueList<E> setUniqueList(final List<E> list) {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) {\n        return new SetUniqueList<E>(list, new HashSet<E>());\n    }\n    final List<E> temp = new ArrayList<E>(list);\n    list.clear();\n    final SetUniqueList<E> sl = new SetUniqueList<E>(list, new HashSet<E>());\n    sl.addAll(temp);\n    return sl;\n}"
            ],
            [
                "unmodifiableList",
                "org.apache.commons.collections4.list",
                "UnmodifiableList",
                "/**\n * Factory method to create an unmodifiable list.\n *\n * @param <E> the type of the elements in the list\n * @param list  the list to decorate, must not be null\n * @return a new unmodifiable list\n * @throws NullPointerException if list is null\n * @since 4.0\n */\npublic static <E> List<E> unmodifiableList(final List<? extends E> list) {\n    if (list instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final List<E> tmpList = (List<E>) list;\n        return tmpList;\n    }\n    return new UnmodifiableList<E>(list);\n}"
            ],
            [
                "fixedSizeList",
                "org.apache.commons.collections4.list",
                "FixedSizeList",
                "/**\n * Factory method to create a fixed size list.\n *\n * @param <E> the type of the elements in the list\n * @param list  the list to decorate, must not be null\n * @return a new fixed size list\n * @throws NullPointerException if list is null\n * @since 4.0\n */\npublic static <E> FixedSizeList<E> fixedSizeList(final List<E> list) {\n    return new FixedSizeList<E>(list);\n}"
            ],
            [
                "transformingList",
                "org.apache.commons.collections4.list",
                "TransformedList",
                "/**\n * Factory method to create a transforming list.\n * <p>\n * If there are any elements already in the list being decorated, they\n * are NOT transformed.\n * Contrast this with {@link #transformedList(List, Transformer)}.\n *\n * @param <E> the type of the elements in the list\n * @param list  the list to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed list\n * @throws NullPointerException if list or transformer is null\n * @since 4.0\n */\npublic static <E> TransformedList<E> transformingList(final List<E> list, final Transformer<? super E, ? extends E> transformer) {\n    return new TransformedList<E>(list, transformer);\n}"
            ],
            [
                "transformedList",
                "org.apache.commons.collections4.list",
                "TransformedList",
                "/**\n * Factory method to create a transforming list that will transform\n * existing contents of the specified list.\n * <p>\n * If there are any elements already in the list being decorated, they\n * will be transformed by this method.\n * Contrast this with {@link #transformingList(List, Transformer)}.\n *\n * @param <E> the type of the elements in the list\n * @param list  the list to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed List\n * @throws NullPointerException if list or transformer is null\n * @since 4.0\n */\npublic static <E> TransformedList<E> transformedList(final List<E> list, final Transformer<? super E, ? extends E> transformer) {\n    final TransformedList<E> decorated = new TransformedList<E>(list, transformer);\n    if (list.size() > 0) {\n        // list is of type E\n        @SuppressWarnings(\"unchecked\")\n        final E[] // NOPMD - false positive for generics\n        values = (E[]) list.toArray();\n        list.clear();\n        for (final E value : values) {\n            decorated.decorated().add(transformer.transform(value));\n        }\n    }\n    return decorated;\n}"
            ],
            [
                "growthList",
                "org.apache.commons.collections4.list",
                "GrowthList",
                "/**\n * Factory method to create a growth list.\n *\n * @param <E> the type of the elements in the list\n * @param list  the list to decorate, must not be null\n * @return a new growth list\n * @throws NullPointerException if list is null\n * @since 4.0\n */\npublic static <E> GrowthList<E> growthList(final List<E> list) {\n    return new GrowthList<E>(list);\n}"
            ],
            [
                "predicatedList",
                "org.apache.commons.collections4.list",
                "PredicatedList",
                "/**\n * Factory method to create a predicated (validating) list.\n * <p>\n * If there are any elements already in the list being decorated, they\n * are validated.\n *\n * @param <T> the type of the elements in the list\n * @param list  the list to decorate, must not be null\n * @param predicate  the predicate to use for validation, must not be null\n * @return a new predicated list\n * @throws NullPointerException if list or predicate is null\n * @throws IllegalArgumentException if the list contains invalid elements\n * @since 4.0\n */\npublic static <T> PredicatedList<T> predicatedList(final List<T> list, final Predicate<? super T> predicate) {\n    return new PredicatedList<T>(list, predicate);\n}"
            ],
            [
                "transformingQueue",
                "org.apache.commons.collections4.queue",
                "TransformedQueue",
                "/**\n * Factory method to create a transforming queue.\n * <p>\n * If there are any elements already in the queue being decorated, they\n * are NOT transformed.\n * Contrast this with {@link #transformedQueue(Queue, Transformer)}.\n *\n * @param <E> the type of the elements in the queue\n * @param queue  the queue to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed Queue\n * @throws NullPointerException if queue or transformer is null\n */\npublic static <E> TransformedQueue<E> transformingQueue(final Queue<E> queue, final Transformer<? super E, ? extends E> transformer) {\n    return new TransformedQueue<E>(queue, transformer);\n}"
            ],
            [
                "transformedQueue",
                "org.apache.commons.collections4.queue",
                "TransformedQueue",
                "/**\n * Factory method to create a transforming queue that will transform\n * existing contents of the specified queue.\n * <p>\n * If there are any elements already in the queue being decorated, they\n * will be transformed by this method.\n * Contrast this with {@link #transformingQueue(Queue, Transformer)}.\n *\n * @param <E> the type of the elements in the queue\n * @param queue  the queue to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed Queue\n * @throws NullPointerException if queue or transformer is null\n * @since 4.0\n */\npublic static <E> TransformedQueue<E> transformedQueue(final Queue<E> queue, final Transformer<? super E, ? extends E> transformer) {\n    // throws IAE if queue or transformer is null\n    final TransformedQueue<E> decorated = new TransformedQueue<E>(queue, transformer);\n    if (queue.size() > 0) {\n        // queue is type <E>\n        @SuppressWarnings(\"unchecked\")\n        final E[] // NOPMD - false positive for generics\n        values = (E[]) queue.toArray();\n        queue.clear();\n        for (final E value : values) {\n            decorated.decorated().add(transformer.transform(value));\n        }\n    }\n    return decorated;\n}"
            ],
            [
                "unmodifiableQueue",
                "org.apache.commons.collections4.queue",
                "UnmodifiableQueue",
                "/**\n * Factory method to create an unmodifiable queue.\n * <p>\n * If the queue passed in is already unmodifiable, it is returned.\n *\n * @param <E> the type of the elements in the queue\n * @param queue  the queue to decorate, must not be null\n * @return an unmodifiable Queue\n * @throws NullPointerException if queue is null\n */\npublic static <E> Queue<E> unmodifiableQueue(final Queue<? extends E> queue) {\n    if (queue instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final Queue<E> tmpQueue = (Queue<E>) queue;\n        return tmpQueue;\n    }\n    return new UnmodifiableQueue<E>(queue);\n}"
            ],
            [
                "predicatedQueue",
                "org.apache.commons.collections4.queue",
                "PredicatedQueue",
                "/**\n * Factory method to create a predicated (validating) queue.\n * <p>\n * If there are any elements already in the queue being decorated, they\n * are validated.\n *\n * @param <E> the type of the elements in the queue\n * @param Queue  the queue to decorate, must not be null\n * @param predicate  the predicate to use for validation, must not be null\n * @return a new predicated queue\n * @throws NullPointerException if queue or predicate is null\n * @throws IllegalArgumentException if the queue contains invalid elements\n */\npublic static <E> PredicatedQueue<E> predicatedQueue(final Queue<E> Queue, final Predicate<? super E> predicate) {\n    return new PredicatedQueue<E>(Queue, predicate);\n}"
            ],
            [
                "empty",
                "org.apache.commons.collections4",
                "FluentIterable",
                "// Static factory methods\n// ----------------------------------------------------------------------\n/**\n * Creates a new empty FluentIterable.\n *\n * @param <T>  the element type\n * @return a new empty FluentIterable\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> FluentIterable<T> empty() {\n    return IterableUtils.EMPTY_ITERABLE;\n}"
            ],
            [
                "of",
                "org.apache.commons.collections4",
                "FluentIterable",
                "/**\n * Creates a new FluentIterable of the single provided element.\n * <p>\n * The returned iterable's iterator does not support {@code remove()}.\n *\n * @param <T>  the element type\n * @param singleton  the singleton element\n * @return a new FluentIterable containing the singleton\n */\npublic static <T> FluentIterable<T> of(final T singleton) {\n    return of(IteratorUtils.asIterable(new SingletonIterator<T>(singleton, false)));\n}"
            ],
            [
                "of",
                "org.apache.commons.collections4",
                "FluentIterable",
                "/**\n * Creates a new FluentIterable from the provided elements.\n * <p>\n * The returned iterable's iterator does not support {@code remove()}.\n *\n * @param <T>  the element type\n * @param elements  the elements to be contained in the FluentIterable\n * @return a new FluentIterable containing the provided elements\n */\npublic static <T> FluentIterable<T> of(final T... elements) {\n    return of(Arrays.asList(elements));\n}"
            ],
            [
                "of",
                "org.apache.commons.collections4",
                "FluentIterable",
                "/**\n * Construct a new FluentIterable from the provided iterable. If the\n * iterable is already an instance of FluentIterable, the instance\n * will be returned instead.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the\n * corresponding input iterator supports it.\n *\n * @param <T>  the element type\n * @param iterable  the iterable to wrap into a FluentIterable, may not be null\n * @return a new FluentIterable wrapping the provided iterable\n * @throws NullPointerException if iterable is null\n */\npublic static <T> FluentIterable<T> of(final Iterable<T> iterable) {\n    IterableUtils.checkNotNull(iterable);\n    if (iterable instanceof FluentIterable<?>) {\n        return (FluentIterable<T>) iterable;\n    } else {\n        return new FluentIterable<T>(iterable);\n    }\n}"
            ],
            [
                "exceptionTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Gets a transformer that always throws an exception.\n * This could be useful during testing as a placeholder.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @return the transformer\n * @see ExceptionTransformer\n */\npublic static <I, O> Transformer<I, O> exceptionTransformer() {\n    return ExceptionTransformer.exceptionTransformer();\n}"
            ],
            [
                "nullTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Gets a transformer that always returns null.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @return the transformer\n * @see ConstantTransformer\n */\npublic static <I, O> Transformer<I, O> nullTransformer() {\n    return ConstantTransformer.nullTransformer();\n}"
            ],
            [
                "nopTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Gets a transformer that returns the input object.\n * The input object should be immutable to maintain the\n * contract of Transformer (although this is not checked).\n *\n * @param <T>  the input/output type\n * @return the transformer\n * @see NOPTransformer\n */\npublic static <T> Transformer<T, T> nopTransformer() {\n    return NOPTransformer.nopTransformer();\n}"
            ],
            [
                "cloneTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Gets a transformer that returns a clone of the input object.\n * The input object will be cloned using one of these techniques (in order):\n * <ul>\n * <li>public clone method\n * <li>public copy constructor\n * <li>serialization clone\n * <ul>\n *\n * @param <T>  the input/output type\n * @return the transformer\n * @see CloneTransformer\n */\npublic static <T> Transformer<T, T> cloneTransformer() {\n    return CloneTransformer.cloneTransformer();\n}"
            ],
            [
                "constantTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Creates a Transformer that will return the same object each time the\n * transformer is used.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param constantToReturn  the constant object to return each time in the transformer\n * @return the transformer.\n * @see ConstantTransformer\n */\npublic static <I, O> Transformer<I, O> constantTransformer(final O constantToReturn) {\n    return ConstantTransformer.constantTransformer(constantToReturn);\n}"
            ],
            [
                "asTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Creates a Transformer that calls a Closure each time the transformer is used.\n * The transformer returns the input object.\n *\n * @param <T>  the input/output type\n * @param closure  the closure to run each time in the transformer, not null\n * @return the transformer\n * @throws NullPointerException if the closure is null\n * @see ClosureTransformer\n */\npublic static <T> Transformer<T, T> asTransformer(final Closure<? super T> closure) {\n    return ClosureTransformer.closureTransformer(closure);\n}"
            ],
            [
                "asTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Creates a Transformer that calls a Predicate each time the transformer is used.\n * The transformer will return either Boolean.TRUE or Boolean.FALSE.\n *\n * @param <T>  the input type\n * @param predicate  the predicate to run each time in the transformer, not null\n * @return the transformer\n * @throws NullPointerException if the predicate is null\n * @see PredicateTransformer\n */\npublic static <T> Transformer<T, Boolean> asTransformer(final Predicate<? super T> predicate) {\n    return PredicateTransformer.predicateTransformer(predicate);\n}"
            ],
            [
                "asTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Creates a Transformer that calls a Factory each time the transformer is used.\n * The transformer will return the value returned by the factory.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param factory  the factory to run each time in the transformer, not null\n * @return the transformer\n * @throws NullPointerException if the factory is null\n * @see FactoryTransformer\n */\npublic static <I, O> Transformer<I, O> asTransformer(final Factory<? extends O> factory) {\n    return FactoryTransformer.factoryTransformer(factory);\n}"
            ],
            [
                "chainedTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Create a new Transformer that calls each transformer in turn, passing the\n * result into the next transformer.\n *\n * @param <T>  the input/output type\n * @param transformers  an array of transformers to chain\n * @return the transformer\n * @throws NullPointerException if the transformers array or any of the transformers is null\n * @see ChainedTransformer\n */\npublic static <T> Transformer<T, T> chainedTransformer(final Transformer<? super T, ? extends T>... transformers) {\n    return ChainedTransformer.chainedTransformer(transformers);\n}"
            ],
            [
                "chainedTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Create a new Transformer that calls each transformer in turn, passing the\n * result into the next transformer. The ordering is that of the iterator()\n * method on the collection.\n *\n * @param <T>  the input/output type\n * @param transformers  a collection of transformers to chain\n * @return the transformer\n * @throws NullPointerException if the transformers collection or any of the transformers is null\n * @see ChainedTransformer\n */\npublic static <T> Transformer<T, T> chainedTransformer(final Collection<? extends Transformer<? super T, ? extends T>> transformers) {\n    return ChainedTransformer.chainedTransformer(transformers);\n}"
            ],
            [
                "ifTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Create a new Transformer that calls the transformer if the predicate is true,\n * otherwise the input object is returned unchanged.\n *\n * @param <T>  the input / output type\n * @param predicate  the predicate to switch on\n * @param trueTransformer  the transformer called if the predicate is true\n * @return the transformer\n * @throws NullPointerException if either the predicate or transformer is null\n * @see IfTransformer\n * @since 4.1\n */\npublic static <T> Transformer<T, T> ifTransformer(final Predicate<? super T> predicate, final Transformer<? super T, ? extends T> trueTransformer) {\n    return IfTransformer.ifTransformer(predicate, trueTransformer);\n}"
            ],
            [
                "ifTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Create a new Transformer that calls one of two transformers depending\n * on the specified predicate.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param predicate  the predicate to switch on\n * @param trueTransformer  the transformer called if the predicate is true\n * @param falseTransformer  the transformer called if the predicate is false\n * @return the transformer\n * @throws NullPointerException if either the predicate or transformer is null\n * @see IfTransformer\n * @since 4.1\n */\npublic static <I, O> Transformer<I, O> ifTransformer(final Predicate<? super I> predicate, final Transformer<? super I, ? extends O> trueTransformer, final Transformer<? super I, ? extends O> falseTransformer) {\n    return IfTransformer.ifTransformer(predicate, trueTransformer, falseTransformer);\n}"
            ],
            [
                "switchTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Create a new Transformer that calls one of two transformers depending\n * on the specified predicate.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param predicate  the predicate to switch on\n * @param trueTransformer  the transformer called if the predicate is true\n * @param falseTransformer  the transformer called if the predicate is false\n * @return the transformer\n * @throws NullPointerException if either the predicate or transformer is null\n * @see SwitchTransformer\n * @deprecated as of 4.1, use {@link #ifTransformer(Predicate, Transformer, Transformer))\n */\n@SuppressWarnings(\"unchecked\")\n@Deprecated\npublic static <I, O> Transformer<I, O> switchTransformer(final Predicate<? super I> predicate, final Transformer<? super I, ? extends O> trueTransformer, final Transformer<? super I, ? extends O> falseTransformer) {\n    return SwitchTransformer.switchTransformer(new Predicate[] { predicate }, new Transformer[] { trueTransformer }, falseTransformer);\n}"
            ],
            [
                "switchTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Create a new Transformer that calls one of the transformers depending\n * on the predicates. The transformer at array location 0 is called if the\n * predicate at array location 0 returned true. Each predicate is evaluated\n * until one returns true. If no predicates evaluate to true, null is returned.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param predicates  an array of predicates to check\n * @param transformers  an array of transformers to call\n * @return the transformer\n * @throws NullPointerException if the either array is null\n * @throws NullPointerException if any element in the arrays is null\n * @throws IllegalArgumentException if the arrays have different sizes\n * @see SwitchTransformer\n */\npublic static <I, O> Transformer<I, O> switchTransformer(final Predicate<? super I>[] predicates, final Transformer<? super I, ? extends O>[] transformers) {\n    return SwitchTransformer.switchTransformer(predicates, transformers, null);\n}"
            ],
            [
                "switchTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Create a new Transformer that calls one of the transformers depending\n * on the predicates. The transformer at array location 0 is called if the\n * predicate at array location 0 returned true. Each predicate is evaluated\n * until one returns true. If no predicates evaluate to true, the default\n * transformer is called. If the default transformer is null, null is returned.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param predicates  an array of predicates to check\n * @param transformers  an array of transformers to call\n * @param defaultTransformer  the default to call if no predicate matches, null means return null\n * @return the transformer\n * @throws NullPointerException if the either array is null\n * @throws NullPointerException if any element in the arrays is null\n * @throws IllegalArgumentException if the arrays have different sizes\n * @see SwitchTransformer\n */\npublic static <I, O> Transformer<I, O> switchTransformer(final Predicate<? super I>[] predicates, final Transformer<? super I, ? extends O>[] transformers, final Transformer<? super I, ? extends O> defaultTransformer) {\n    return SwitchTransformer.switchTransformer(predicates, transformers, defaultTransformer);\n}"
            ],
            [
                "switchTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Create a new Transformer that calls one of the transformers depending\n * on the predicates.\n * <p>\n * The Map consists of Predicate keys and Transformer values. A transformer\n * is called if its matching predicate returns true. Each predicate is evaluated\n * until one returns true. If no predicates evaluate to true, the default\n * transformer is called. The default transformer is set in the map with a\n * null key. If no default transformer is set, null will be returned in a default\n * case. The ordering is that of the iterator() method on the entryset collection\n * of the map.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param predicatesAndTransformers  a map of predicates to transformers\n * @return the transformer\n * @throws NullPointerException if the map is null\n * @throws NullPointerException if any transformer in the map is null\n * @throws ClassCastException  if the map elements are of the wrong type\n * @see SwitchTransformer\n */\npublic static <I, O> Transformer<I, O> switchTransformer(final Map<Predicate<I>, Transformer<I, O>> predicatesAndTransformers) {\n    return SwitchTransformer.switchTransformer(predicatesAndTransformers);\n}"
            ],
            [
                "switchMapTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Create a new Transformer that uses the input object as a key to find the\n * transformer to call.\n * <p>\n * The Map consists of object keys and Transformer values. A transformer\n * is called if the input object equals the key. If there is no match, the\n * default transformer is called. The default transformer is set in the map\n * using a null key. If no default is set, null will be returned in a default case.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param objectsAndTransformers  a map of objects to transformers\n * @return the transformer\n * @throws NullPointerException if the map is null\n * @throws NullPointerException if any transformer in the map is null\n * @see SwitchTransformer\n */\n@SuppressWarnings(\"unchecked\")\npublic static <I, O> Transformer<I, O> switchMapTransformer(final Map<I, Transformer<I, O>> objectsAndTransformers) {\n    if (objectsAndTransformers == null) {\n        throw new NullPointerException(\"The object and transformer map must not be null\");\n    }\n    final Transformer<? super I, ? extends O> def = objectsAndTransformers.remove(null);\n    final int size = objectsAndTransformers.size();\n    final Transformer<? super I, ? extends O>[] trs = new Transformer[size];\n    final Predicate<I>[] preds = new Predicate[size];\n    int i = 0;\n    for (final Map.Entry<I, Transformer<I, O>> entry : objectsAndTransformers.entrySet()) {\n        preds[i] = EqualPredicate.<I>equalPredicate(entry.getKey());\n        trs[i++] = entry.getValue();\n    }\n    return TransformerUtils.switchTransformer(preds, trs, def);\n}"
            ],
            [
                "instantiateTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Gets a Transformer that expects an input Class object that it will instantiate.\n *\n * @param <T>  the output type\n * @return the transformer\n * @see InstantiateTransformer\n */\npublic static <T> Transformer<Class<? extends T>, T> instantiateTransformer() {\n    return InstantiateTransformer.instantiateTransformer();\n}"
            ],
            [
                "instantiateTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Creates a Transformer that expects an input Class object that it will\n * instantiate. The constructor used is determined by the arguments specified\n * to this method.\n *\n * @param <T>  the output type\n * @param paramTypes  parameter types for the constructor, can be null\n * @param args  the arguments to pass to the constructor, can be null\n * @return the transformer\n * @throws IllegalArgumentException if the paramTypes and args don't match\n * @see InstantiateTransformer\n */\npublic static <T> Transformer<Class<? extends T>, T> instantiateTransformer(final Class<?>[] paramTypes, final Object[] args) {\n    return InstantiateTransformer.instantiateTransformer(paramTypes, args);\n}"
            ],
            [
                "mapTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Creates a Transformer that uses the passed in Map to transform the input\n * object (as a simple lookup).\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param map  the map to use to transform the objects\n * @return the transformer, or {@link ConstantTransformer#nullTransformer()} if the\n *   {@code map} is {@code null}\n * @see MapTransformer\n */\npublic static <I, O> Transformer<I, O> mapTransformer(final Map<? super I, ? extends O> map) {\n    return MapTransformer.mapTransformer(map);\n}"
            ],
            [
                "invokerTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Gets a Transformer that invokes a method on the input object.\n * The method must have no parameters. If the input object is null,\n * null is returned.\n * <p>\n * For example, <code>TransformerUtils.invokerTransformer(\"getName\");</code>\n * will call the <code>getName/code> method on the input object to\n * determine the transformer result.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param methodName  the method name to call on the input object, may not be null\n * @return the transformer\n * @throws NullPointerException if the methodName is null.\n * @see InvokerTransformer\n */\npublic static <I, O> Transformer<I, O> invokerTransformer(final String methodName) {\n    return InvokerTransformer.invokerTransformer(methodName, null, null);\n}"
            ],
            [
                "invokerTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Gets a Transformer that invokes a method on the input object.\n * The method parameters are specified. If the input object is {@code null},\n * {@code null} is returned.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param methodName  the name of the method\n * @param paramTypes  the parameter types\n * @param args  the arguments\n * @return the transformer\n * @throws NullPointerException if the method name is null\n * @throws IllegalArgumentException if the paramTypes and args don't match\n * @see InvokerTransformer\n */\npublic static <I, O> Transformer<I, O> invokerTransformer(final String methodName, final Class<?>[] paramTypes, final Object[] args) {\n    return InvokerTransformer.invokerTransformer(methodName, paramTypes, args);\n}"
            ],
            [
                "stringValueTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Gets a transformer that returns a <code>java.lang.String</code>\n * representation of the input object. This is achieved via the\n * <code>toString</code> method, <code>null</code> returns 'null'.\n *\n * @param <T>  the input type\n * @return the transformer\n * @see StringValueTransformer\n */\npublic static <T> Transformer<T, String> stringValueTransformer() {\n    return StringValueTransformer.stringValueTransformer();\n}"
            ],
            [
                "exceptionPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "// Simple predicates\n//-----------------------------------------------------------------------------\n/**\n * Gets a Predicate that always throws an exception.\n * This could be useful during testing as a placeholder.\n *\n * @param <T>  the type that the predicate queries\n * @return the predicate\n * @see ExceptionPredicate\n */\npublic static <T> Predicate<T> exceptionPredicate() {\n    return ExceptionPredicate.exceptionPredicate();\n}"
            ],
            [
                "truePredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Gets a Predicate that always returns true.\n *\n * @param <T>  the type that the predicate queries\n * @return the predicate\n * @see TruePredicate\n */\npublic static <T> Predicate<T> truePredicate() {\n    return TruePredicate.truePredicate();\n}"
            ],
            [
                "falsePredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Gets a Predicate that always returns false.\n *\n * @param <T>  the type that the predicate queries\n * @return the predicate\n * @see FalsePredicate\n */\npublic static <T> Predicate<T> falsePredicate() {\n    return FalsePredicate.falsePredicate();\n}"
            ],
            [
                "nullPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Gets a Predicate that checks if the input object passed in is null.\n *\n * @param <T>  the type that the predicate queries\n * @return the predicate\n * @see NullPredicate\n */\npublic static <T> Predicate<T> nullPredicate() {\n    return NullPredicate.nullPredicate();\n}"
            ],
            [
                "notNullPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Gets a Predicate that checks if the input object passed in is not null.\n *\n * @param <T>  the type that the predicate queries\n * @return the predicate\n * @see NotNullPredicate\n */\npublic static <T> Predicate<T> notNullPredicate() {\n    return NotNullPredicate.notNullPredicate();\n}"
            ],
            [
                "equalPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Creates a Predicate that checks if the input object is equal to the\n * specified object using equals().\n *\n * @param <T>  the type that the predicate queries\n * @param value  the value to compare against\n * @return the predicate\n * @see EqualPredicate\n */\npublic static <T> Predicate<T> equalPredicate(final T value) {\n    return EqualPredicate.equalPredicate(value);\n}"
            ],
            [
                "identityPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Creates a Predicate that checks if the input object is equal to the\n * specified object by identity.\n *\n * @param <T>  the type that the predicate queries\n * @param value  the value to compare against\n * @return the predicate\n * @see IdentityPredicate\n */\npublic static <T> Predicate<T> identityPredicate(final T value) {\n    return IdentityPredicate.identityPredicate(value);\n}"
            ],
            [
                "instanceofPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Creates a Predicate that checks if the object passed in is of\n * a particular type, using instanceof. A <code>null</code> input\n * object will return <code>false</code>.\n *\n * @param type  the type to check for, may not be null\n * @return the predicate\n * @throws NullPointerException if the class is null\n * @see InstanceofPredicate\n */\npublic static Predicate<Object> instanceofPredicate(final Class<?> type) {\n    return InstanceofPredicate.instanceOfPredicate(type);\n}"
            ],
            [
                "uniquePredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Creates a Predicate that returns true the first time an object is\n * encountered, and false if the same object is received\n * again. The comparison is by equals(). A <code>null</code> input object\n * is accepted and will return true the first time, and false subsequently\n * as well.\n *\n * @param <T>  the type that the predicate queries\n * @return the predicate\n * @see UniquePredicate\n */\npublic static <T> Predicate<T> uniquePredicate() {\n    // must return new instance each time\n    return UniquePredicate.uniquePredicate();\n}"
            ],
            [
                "invokerPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Creates a Predicate that invokes a method on the input object.\n * The method must return either a boolean or a non-null Boolean,\n * and have no parameters. If the input object is null, a\n * PredicateException is thrown.\n * <p>\n * For example, <code>PredicateUtils.invokerPredicate(\"isEmpty\");</code>\n * will call the <code>isEmpty</code> method on the input object to\n * determine the predicate result.\n *\n * @param <T>  the type that the predicate queries\n * @param methodName  the method name to call on the input object, may not be null\n * @return the predicate\n * @throws NullPointerException if the methodName is null.\n * @see InvokerTransformer\n * @see TransformerPredicate\n */\npublic static <T> Predicate<T> invokerPredicate(final String methodName) {\n    // reuse transformer as it has caching - this is lazy really, should have inner class here\n    return asPredicate(InvokerTransformer.<Object, Boolean>invokerTransformer(methodName));\n}"
            ],
            [
                "invokerPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Creates a Predicate that invokes a method on the input object.\n * The method must return either a boolean or a non-null Boolean,\n * and have no parameters. If the input object is null, a\n * PredicateException is thrown.\n * <p>\n * For example, <code>PredicateUtils.invokerPredicate(\"isEmpty\");</code>\n * will call the <code>isEmpty</code> method on the input object to\n * determine the predicate result.\n *\n * @param <T>  the type that the predicate queries\n * @param methodName  the method name to call on the input object, may not be null\n * @param paramTypes  the parameter types\n * @param args  the arguments\n * @return the predicate\n * @throws NullPointerException if the method name is null\n * @throws IllegalArgumentException if the paramTypes and args don't match\n * @see InvokerTransformer\n * @see TransformerPredicate\n */\npublic static <T> Predicate<T> invokerPredicate(final String methodName, final Class<?>[] paramTypes, final Object[] args) {\n    // reuse transformer as it has caching - this is lazy really, should have inner class here\n    return asPredicate(InvokerTransformer.<Object, Boolean>invokerTransformer(methodName, paramTypes, args));\n}"
            ],
            [
                "andPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "// Boolean combinations\n//-----------------------------------------------------------------------------\n/**\n * Create a new Predicate that returns true only if both of the specified\n * predicates are true.\n *\n * @param <T>  the type that the predicate queries\n * @param predicate1  the first predicate, may not be null\n * @param predicate2  the second predicate, may not be null\n * @return the <code>and</code> predicate\n * @throws NullPointerException if either predicate is null\n * @see AndPredicate\n */\npublic static <T> Predicate<T> andPredicate(final Predicate<? super T> predicate1, final Predicate<? super T> predicate2) {\n    return AndPredicate.andPredicate(predicate1, predicate2);\n}"
            ],
            [
                "allPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true only if all of the specified\n * predicates are true.\n * If the array of predicates is empty, then this predicate returns true.\n *\n * @param <T>  the type that the predicate queries\n * @param predicates  an array of predicates to check, may not be null\n * @return the <code>all</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n * @see AllPredicate\n */\npublic static <T> Predicate<T> allPredicate(final Predicate<? super T>... predicates) {\n    return AllPredicate.allPredicate(predicates);\n}"
            ],
            [
                "allPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true only if all of the specified\n * predicates are true. The predicates are checked in iterator order.\n * If the collection of predicates is empty, then this predicate returns true.\n *\n * @param <T>  the type that the predicate queries\n * @param predicates  a collection of predicates to check, may not be null\n * @return the <code>all</code> predicate\n * @throws NullPointerException if the predicates collection is null\n * @throws NullPointerException if any predicate in the collection is null\n * @see AllPredicate\n */\npublic static <T> Predicate<T> allPredicate(final Collection<? extends Predicate<? super T>> predicates) {\n    return AllPredicate.allPredicate(predicates);\n}"
            ],
            [
                "orPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true if either of the specified\n * predicates are true.\n *\n * @param <T>  the type that the predicate queries\n * @param predicate1  the first predicate, may not be null\n * @param predicate2  the second predicate, may not be null\n * @return the <code>or</code> predicate\n * @throws NullPointerException if either predicate is null\n * @see OrPredicate\n */\npublic static <T> Predicate<T> orPredicate(final Predicate<? super T> predicate1, final Predicate<? super T> predicate2) {\n    return OrPredicate.orPredicate(predicate1, predicate2);\n}"
            ],
            [
                "anyPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true if any of the specified\n * predicates are true.\n * If the array of predicates is empty, then this predicate returns false.\n *\n * @param <T>  the type that the predicate queries\n * @param predicates  an array of predicates to check, may not be null\n * @return the <code>any</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n * @see AnyPredicate\n */\npublic static <T> Predicate<T> anyPredicate(final Predicate<? super T>... predicates) {\n    return AnyPredicate.anyPredicate(predicates);\n}"
            ],
            [
                "anyPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true if any of the specified\n * predicates are true. The predicates are checked in iterator order.\n * If the collection of predicates is empty, then this predicate returns false.\n *\n * @param <T>  the type that the predicate queries\n * @param predicates  a collection of predicates to check, may not be null\n * @return the <code>any</code> predicate\n * @throws NullPointerException if the predicates collection is null\n * @throws NullPointerException if any predicate in the collection is null\n * @see AnyPredicate\n */\npublic static <T> Predicate<T> anyPredicate(final Collection<? extends Predicate<? super T>> predicates) {\n    return AnyPredicate.anyPredicate(predicates);\n}"
            ],
            [
                "eitherPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true if one, but not both, of the\n * specified predicates are true. XOR\n *\n * @param <T>  the type that the predicate queries\n * @param predicate1  the first predicate, may not be null\n * @param predicate2  the second predicate, may not be null\n * @return the <code>either</code> predicate\n * @throws NullPointerException if either predicate is null\n * @see OnePredicate\n */\npublic static <T> Predicate<T> eitherPredicate(final Predicate<? super T> predicate1, final Predicate<? super T> predicate2) {\n    @SuppressWarnings(\"unchecked\")\n    final Predicate<T> onePredicate = PredicateUtils.onePredicate(predicate1, predicate2);\n    return onePredicate;\n}"
            ],
            [
                "onePredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true if only one of the specified\n * predicates are true.\n * If the array of predicates is empty, then this predicate returns false.\n *\n * @param <T>  the type that the predicate queries\n * @param predicates  an array of predicates to check, may not be null\n * @return the <code>one</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n * @see OnePredicate\n */\npublic static <T> Predicate<T> onePredicate(final Predicate<? super T>... predicates) {\n    return OnePredicate.onePredicate(predicates);\n}"
            ],
            [
                "onePredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true if only one of the specified\n * predicates are true. The predicates are checked in iterator order.\n * If the collection of predicates is empty, then this predicate returns false.\n *\n * @param <T>  the type that the predicate queries\n * @param predicates  a collection of predicates to check, may not be null\n * @return the <code>one</code> predicate\n * @throws NullPointerException if the predicates collection is null\n * @throws NullPointerException if any predicate in the collection is null\n * @see OnePredicate\n */\npublic static <T> Predicate<T> onePredicate(final Collection<? extends Predicate<? super T>> predicates) {\n    return OnePredicate.onePredicate(predicates);\n}"
            ],
            [
                "neitherPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true if neither of the specified\n * predicates are true.\n *\n * @param <T>  the type that the predicate queries\n * @param predicate1  the first predicate, may not be null\n * @param predicate2  the second predicate, may not be null\n * @return the <code>neither</code> predicate\n * @throws NullPointerException if either predicate is null\n * @see NonePredicate\n */\npublic static <T> Predicate<T> neitherPredicate(final Predicate<? super T> predicate1, final Predicate<? super T> predicate2) {\n    @SuppressWarnings(\"unchecked\")\n    final Predicate<T> nonePredicate = PredicateUtils.nonePredicate(predicate1, predicate2);\n    return nonePredicate;\n}"
            ],
            [
                "nonePredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true if none of the specified\n * predicates are true.\n * If the array of predicates is empty, then this predicate returns true.\n *\n * @param <T>  the type that the predicate queries\n * @param predicates  an array of predicates to check, may not be null\n * @return the <code>none</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n * @see NonePredicate\n */\npublic static <T> Predicate<T> nonePredicate(final Predicate<? super T>... predicates) {\n    return NonePredicate.nonePredicate(predicates);\n}"
            ],
            [
                "nonePredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true if none of the specified\n * predicates are true. The predicates are checked in iterator order.\n * If the collection of predicates is empty, then this predicate returns true.\n *\n * @param <T>  the type that the predicate queries\n * @param predicates  a collection of predicates to check, may not be null\n * @return the <code>none</code> predicate\n * @throws NullPointerException if the predicates collection is null\n * @throws NullPointerException if any predicate in the collection is null\n * @see NonePredicate\n */\npublic static <T> Predicate<T> nonePredicate(final Collection<? extends Predicate<? super T>> predicates) {\n    return NonePredicate.nonePredicate(predicates);\n}"
            ],
            [
                "notPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true if the specified predicate\n * returns false and vice versa.\n *\n * @param <T>  the type that the predicate queries\n * @param predicate  the predicate to not\n * @return the <code>not</code> predicate\n * @throws NullPointerException if the predicate is null\n * @see NotPredicate\n */\npublic static <T> Predicate<T> notPredicate(final Predicate<? super T> predicate) {\n    return NotPredicate.notPredicate(predicate);\n}"
            ],
            [
                "asPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "// Adaptors\n//-----------------------------------------------------------------------------\n/**\n * Create a new Predicate that wraps a Transformer. The Transformer must\n * return either Boolean.TRUE or Boolean.FALSE otherwise a PredicateException\n * will be thrown.\n *\n * @param <T>  the type that the predicate queries\n * @param transformer  the transformer to wrap, may not be null\n * @return the transformer wrapping predicate\n * @throws NullPointerException if the transformer is null\n * @see TransformerPredicate\n */\npublic static <T> Predicate<T> asPredicate(final Transformer<? super T, Boolean> transformer) {\n    return TransformerPredicate.transformerPredicate(transformer);\n}"
            ],
            [
                "nullIsExceptionPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "// Null handlers\n//-----------------------------------------------------------------------------\n/**\n * Gets a Predicate that throws an exception if the input object is null,\n * otherwise it calls the specified Predicate. This allows null handling\n * behaviour to be added to Predicates that don't support nulls.\n *\n * @param <T>  the type that the predicate queries\n * @param predicate  the predicate to wrap, may not be null\n * @return the predicate\n * @throws NullPointerException if the predicate is null.\n * @see NullIsExceptionPredicate\n */\npublic static <T> Predicate<T> nullIsExceptionPredicate(final Predicate<? super T> predicate) {\n    return NullIsExceptionPredicate.nullIsExceptionPredicate(predicate);\n}"
            ],
            [
                "nullIsFalsePredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Gets a Predicate that returns false if the input object is null, otherwise\n * it calls the specified Predicate. This allows null handling behaviour to\n * be added to Predicates that don't support nulls.\n *\n * @param <T>  the type that the predicate queries\n * @param predicate  the predicate to wrap, may not be null\n * @return the predicate\n * @throws NullPointerException if the predicate is null.\n * @see NullIsFalsePredicate\n */\npublic static <T> Predicate<T> nullIsFalsePredicate(final Predicate<? super T> predicate) {\n    return NullIsFalsePredicate.nullIsFalsePredicate(predicate);\n}"
            ],
            [
                "nullIsTruePredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Gets a Predicate that returns true if the input object is null, otherwise\n * it calls the specified Predicate. This allows null handling behaviour to\n * be added to Predicates that don't support nulls.\n *\n * @param <T>  the type that the predicate queries\n * @param predicate  the predicate to wrap, may not be null\n * @return the predicate\n * @throws NullPointerException if the predicate is null.\n * @see NullIsTruePredicate\n */\npublic static <T> Predicate<T> nullIsTruePredicate(final Predicate<? super T> predicate) {\n    return NullIsTruePredicate.nullIsTruePredicate(predicate);\n}"
            ],
            [
                "transformedPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "// Transformed\n//-----------------------------------------------------------------------\n/**\n * Creates a predicate that transforms the input object before passing it\n * to the predicate.\n *\n * @param <T>  the type that the predicate queries\n * @param transformer  the transformer to call first\n * @param predicate  the predicate to call with the result of the transform\n * @return the predicate\n * @throws NullPointerException if the transformer or the predicate is null\n * @see TransformedPredicate\n * @since 3.1\n */\npublic static <T> Predicate<T> transformedPredicate(final Transformer<? super T, ? extends T> transformer, final Predicate<? super T> predicate) {\n    return TransformedPredicate.transformedPredicate(transformer, predicate);\n}"
            ],
            [
                "emptySet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Get a typed empty unmodifiable Set.\n * @param <E> the element type\n * @return an empty Set\n */\npublic static <E> Set<E> emptySet() {\n    return Collections.<E>emptySet();\n}"
            ],
            [
                "emptySortedSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Get a typed empty unmodifiable sorted set.\n * @param <E> the element type\n * @return an empty sorted Set\n */\n// empty set is OK for any type\n@SuppressWarnings(\"unchecked\")\npublic static <E> SortedSet<E> emptySortedSet() {\n    return EMPTY_SORTED_SET;\n}"
            ],
            [
                "emptyIfNull",
                "org.apache.commons.collections4",
                "SetUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns an immutable empty set if the argument is <code>null</code>,\n * or the argument itself otherwise.\n *\n * @param <T> the element type\n * @param set the set, possibly <code>null</code>\n * @return an empty set if the argument is <code>null</code>\n */\npublic static <T> Set<T> emptyIfNull(final Set<T> set) {\n    return set == null ? Collections.<T>emptySet() : set;\n}"
            ],
            [
                "isEqualSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Tests two sets for equality as per the <code>equals()</code> contract\n * in {@link java.util.Set#equals(java.lang.Object)}.\n * <p>\n * This method is useful for implementing <code>Set</code> when you cannot\n * extend AbstractSet. The method takes Collection instances to enable other\n * collection types to use the Set implementation algorithm.\n * <p>\n * The relevant text (slightly paraphrased as this is a static method) is:\n * <blockquote>\n * <p>Two sets are considered equal if they have\n * the same size, and every member of the first set is contained in\n * the second. This ensures that the {@code equals} method works\n * properly across different implementations of the {@code Set}\n * interface.</p>\n *\n * <p>\n * This implementation first checks if the two sets are the same object:\n * if so it returns {@code true}.  Then, it checks if the two sets are\n * identical in size; if not, it returns false. If so, it returns\n * {@code a.containsAll((Collection) b)}.</p>\n * </blockquote>\n *\n * @see java.util.Set\n * @param set1  the first set, may be null\n * @param set2  the second set, may be null\n * @return whether the sets are equal by value comparison\n */\npublic static boolean isEqualSet(final Collection<?> set1, final Collection<?> set2) {\n    if (set1 == set2) {\n        return true;\n    }\n    if (set1 == null || set2 == null || set1.size() != set2.size()) {\n        return false;\n    }\n    return set1.containsAll(set2);\n}"
            ],
            [
                "hashCodeForSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Generates a hash code using the algorithm specified in\n * {@link java.util.Set#hashCode()}.\n * <p>\n * This method is useful for implementing <code>Set</code> when you cannot\n * extend AbstractSet. The method takes Collection instances to enable other\n * collection types to use the Set implementation algorithm.\n *\n * @param <T> the element type\n * @see java.util.Set#hashCode()\n * @param set  the set to calculate the hash code for, may be null\n * @return the hash code\n */\npublic static <T> int hashCodeForSet(final Collection<T> set) {\n    if (set == null) {\n        return 0;\n    }\n    int hashCode = 0;\n    for (final T obj : set) {\n        if (obj != null) {\n            hashCode += obj.hashCode();\n        }\n    }\n    return hashCode;\n}"
            ],
            [
                "newIdentityHashSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a new hash set that matches elements based on <code>==</code> not\n * <code>equals()</code>.\n * <p>\n * <strong>This set will violate the detail of various Set contracts.</note>\n * As a general rule, don't compare this set to other sets. In particular, you can't\n * use decorators like {@link ListOrderedSet} on it, which silently assume that these\n * contracts are fulfilled.</strong>\n * <p>\n * <strong>Note that the returned set is not synchronized and is not thread-safe.</strong>\n * If you wish to use this set from multiple threads concurrently, you must use\n * appropriate synchronization. The simplest approach is to wrap this map\n * using {@link java.util.Collections#synchronizedSet(Set)}. This class may throw\n * exceptions when accessed by concurrent threads without synchronization.\n *\n * @param <E>  the element type\n * @return a new identity hash set\n * @since 4.1\n */\npublic static <E> Set<E> newIdentityHashSet() {\n    return Collections.newSetFromMap(new IdentityHashMap<E, Boolean>());\n}"
            ],
            [
                "synchronizedSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "// Set\n//-----------------------------------------------------------------------\n/**\n * Returns a synchronized set backed by the given set.\n * <p>\n * You must manually synchronize on the returned set's iterator to\n * avoid non-deterministic behavior:\n *\n * <pre>\n * Set s = SetUtils.synchronizedSet(mySet);\n * synchronized (s) {\n *     Iterator i = s.iterator();\n *     while (i.hasNext()) {\n *         process (i.next());\n *     }\n * }\n * </pre>\n *\n * This method is just a wrapper for {@link Collections#synchronizedSet(Set)}.\n *\n * @param <E> the element type\n * @param set  the set to synchronize, must not be null\n * @return a synchronized set backed by the given set\n * @throws NullPointerException if the set is null\n */\npublic static <E> Set<E> synchronizedSet(final Set<E> set) {\n    return Collections.synchronizedSet(set);\n}"
            ],
            [
                "unmodifiableSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns an unmodifiable set backed by the given set.\n * <p>\n * This method uses the implementation in the decorators subpackage.\n *\n * @param <E> the element type\n * @param set  the set to make unmodifiable, must not be null\n * @return an unmodifiable set backed by the given set\n * @throws NullPointerException if the set is null\n */\npublic static <E> Set<E> unmodifiableSet(final Set<? extends E> set) {\n    return UnmodifiableSet.unmodifiableSet(set);\n}"
            ],
            [
                "predicatedSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a predicated (validating) set backed by the given set.\n * <p>\n * Only objects that pass the test in the given predicate can be added to the set.\n * Trying to add an invalid object results in an IllegalArgumentException.\n * It is important not to use the original set after invoking this method,\n * as it is a backdoor for adding invalid objects.\n *\n * @param <E> the element type\n * @param set  the set to predicate, must not be null\n * @param predicate  the predicate for the set, must not be null\n * @return a predicated set backed by the given set\n * @throws NullPointerException if the set or predicate is null\n */\npublic static <E> Set<E> predicatedSet(final Set<E> set, final Predicate<? super E> predicate) {\n    return PredicatedSet.predicatedSet(set, predicate);\n}"
            ],
            [
                "transformedSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a transformed set backed by the given set.\n * <p>\n * Each object is passed through the transformer as it is added to the\n * Set. It is important not to use the original set after invoking this\n * method, as it is a backdoor for adding untransformed objects.\n * <p>\n * Existing entries in the specified set will not be transformed.\n * If you want that behaviour, see {@link TransformedSet#transformedSet}.\n *\n * @param <E> the element type\n * @param set  the set to transform, must not be null\n * @param transformer  the transformer for the set, must not be null\n * @return a transformed set backed by the given set\n * @throws NullPointerException if the set or transformer is null\n */\npublic static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer) {\n    return TransformedSet.transformingSet(set, transformer);\n}"
            ],
            [
                "orderedSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a set that maintains the order of elements that are added\n * backed by the given set.\n * <p>\n * If an element is added twice, the order is determined by the first add.\n * The order is observed through the iterator or toArray.\n *\n * @param <E> the element type\n * @param set  the set to order, must not be null\n * @return an ordered set backed by the given set\n * @throws NullPointerException if the set is null\n */\npublic static <E> Set<E> orderedSet(final Set<E> set) {\n    return ListOrderedSet.listOrderedSet(set);\n}"
            ],
            [
                "synchronizedSortedSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "// SortedSet\n//-----------------------------------------------------------------------\n/**\n * Returns a synchronized sorted set backed by the given sorted set.\n * <p>\n * You must manually synchronize on the returned set's iterator to\n * avoid non-deterministic behavior:\n *\n * <pre>\n * Set s = SetUtils.synchronizedSortedSet(mySet);\n * synchronized (s) {\n *     Iterator i = s.iterator();\n *     while (i.hasNext()) {\n *         process (i.next());\n *     }\n * }\n * </pre>\n *\n * This method is just a wrapper for {@link Collections#synchronizedSortedSet(SortedSet)}.\n *\n * @param <E> the element type\n * @param set  the sorted set to synchronize, must not be null\n * @return a synchronized set backed by the given set\n * @throws NullPointerException if the set is null\n */\npublic static <E> SortedSet<E> synchronizedSortedSet(final SortedSet<E> set) {\n    return Collections.synchronizedSortedSet(set);\n}"
            ],
            [
                "unmodifiableSortedSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns an unmodifiable sorted set backed by the given sorted set.\n * <p>\n * This method uses the implementation in the decorators subpackage.\n *\n * @param <E> the element type\n * @param set  the sorted set to make unmodifiable, must not be null\n * @return an unmodifiable set backed by the given set\n * @throws NullPointerException if the set is null\n */\npublic static <E> SortedSet<E> unmodifiableSortedSet(final SortedSet<E> set) {\n    return UnmodifiableSortedSet.unmodifiableSortedSet(set);\n}"
            ],
            [
                "predicatedSortedSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a predicated (validating) sorted set backed by the given sorted set.\n * <p>\n * Only objects that pass the test in the given predicate can be added to the set.\n * Trying to add an invalid object results in an IllegalArgumentException.\n * It is important not to use the original set after invoking this method,\n * as it is a backdoor for adding invalid objects.\n *\n * @param <E> the element type\n * @param set  the sorted set to predicate, must not be null\n * @param predicate  the predicate for the sorted set, must not be null\n * @return a predicated sorted set backed by the given sorted set\n * @throws NullPointerException if the set or predicate is null\n */\npublic static <E> SortedSet<E> predicatedSortedSet(final SortedSet<E> set, final Predicate<? super E> predicate) {\n    return PredicatedSortedSet.predicatedSortedSet(set, predicate);\n}"
            ],
            [
                "transformedSortedSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a transformed sorted set backed by the given set.\n * <p>\n * Each object is passed through the transformer as it is added to the\n * Set. It is important not to use the original set after invoking this\n * method, as it is a backdoor for adding untransformed objects.\n * <p>\n * Existing entries in the specified set will not be transformed.\n * If you want that behaviour, see {@link TransformedSortedSet#transformedSortedSet}.\n *\n * @param <E> the element type\n * @param set  the set to transform, must not be null\n * @param transformer  the transformer for the set, must not be null\n * @return a transformed set backed by the given set\n * @throws NullPointerException if the set or transformer is null\n */\npublic static <E> SortedSet<E> transformedSortedSet(final SortedSet<E> set, final Transformer<? super E, ? extends E> transformer) {\n    return TransformedSortedSet.transformingSortedSet(set, transformer);\n}"
            ],
            [
                "unmodifiableNavigableSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "// NavigableSet\n//-----------------------------------------------------------------------\n/**\n * Returns an unmodifiable navigable set backed by the given navigable set.\n * <p>\n * This method uses the implementation in the decorators subpackage.\n *\n * @param <E> the element type\n * @param set  the navigable set to make unmodifiable, must not be null\n * @return an unmodifiable set backed by the given set\n * @throws NullPointerException if the set is null\n * @since 4.1\n */\npublic static <E> SortedSet<E> unmodifiableNavigableSet(final NavigableSet<E> set) {\n    return UnmodifiableNavigableSet.unmodifiableNavigableSet(set);\n}"
            ],
            [
                "predicatedNavigableSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a predicated (validating) navigable set backed by the given navigable set.\n * <p>\n * Only objects that pass the test in the given predicate can be added to the set.\n * Trying to add an invalid object results in an IllegalArgumentException.\n * It is important not to use the original set after invoking this method,\n * as it is a backdoor for adding invalid objects.\n *\n * @param <E> the element type\n * @param set  the navigable set to predicate, must not be null\n * @param predicate  the predicate for the navigable set, must not be null\n * @return a predicated navigable set backed by the given navigable set\n * @throws NullPointerException if the set or predicate is null\n * @since 4.1\n */\npublic static <E> SortedSet<E> predicatedNavigableSet(final NavigableSet<E> set, final Predicate<? super E> predicate) {\n    return PredicatedNavigableSet.predicatedNavigableSet(set, predicate);\n}"
            ],
            [
                "transformedNavigableSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a transformed navigable set backed by the given navigable set.\n * <p>\n * Each object is passed through the transformer as it is added to the\n * Set. It is important not to use the original set after invoking this\n * method, as it is a backdoor for adding untransformed objects.\n * <p>\n * Existing entries in the specified set will not be transformed.\n * If you want that behaviour, see {@link TransformedNavigableSet#transformedNavigableSet}.\n *\n * @param <E> the element type\n * @param set  the navigable set to transform, must not be null\n * @param transformer  the transformer for the set, must not be null\n * @return a transformed set backed by the given set\n * @throws NullPointerException if the set or transformer is null\n * @since 4.1\n */\npublic static <E> SortedSet<E> transformedNavigableSet(final NavigableSet<E> set, final Transformer<? super E, ? extends E> transformer) {\n    return TransformedNavigableSet.transformingNavigableSet(set, transformer);\n}"
            ],
            [
                "union",
                "org.apache.commons.collections4",
                "SetUtils",
                "// Set operations\n//-----------------------------------------------------------------------\n/**\n * Returns a unmodifiable <b>view</b> of the union of the given {@link Set}s.\n * <p>\n * The returned view contains all elements of {@code a} and {@code b}.\n *\n * @param <E> the generic type that is able to represent the types contained\n *   in both input sets.\n * @param a  the first set, must not be null\n * @param b  the second set, must not be null\n * @return a view of the union of the two set\n * @throws NullPointerException if either input set is null\n * @since 4.1\n */\npublic static <E> SetView<E> union(final Set<? extends E> a, final Set<? extends E> b) {\n    if (a == null || b == null) {\n        throw new NullPointerException(\"Sets must not be null.\");\n    }\n    final SetView<E> bMinusA = difference(b, a);\n    return new SetView<E>() {\n\n        @Override\n        public boolean contains(Object o) {\n            return a.contains(o) || b.contains(o);\n        }\n\n        @Override\n        public Iterator<E> createIterator() {\n            return IteratorUtils.chainedIterator(a.iterator(), bMinusA.iterator());\n        }\n\n        @Override\n        public boolean isEmpty() {\n            return a.isEmpty() && b.isEmpty();\n        }\n\n        @Override\n        public int size() {\n            return a.size() + bMinusA.size();\n        }\n    };\n}"
            ],
            [
                "difference",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a unmodifiable <b>view</b> containing the difference of the given\n * {@link Set}s, denoted by {@code a \\ b} (or {@code a - b}).\n * <p>\n * The returned view contains all elements of {@code a} that are not a member\n * of {@code b}.\n *\n * @param <E> the generic type that is able to represent the types contained\n *   in both input sets.\n * @param a  the set to subtract from, must not be null\n * @param b  the set to subtract, must not be null\n * @return a view of the relative complement of  of the two sets\n * @since 4.1\n */\npublic static <E> SetView<E> difference(final Set<? extends E> a, final Set<? extends E> b) {\n    if (a == null || b == null) {\n        throw new NullPointerException(\"Sets must not be null.\");\n    }\n    final Predicate<E> notContainedInB = new Predicate<E>() {\n\n        @Override\n        public boolean evaluate(E object) {\n            return !b.contains(object);\n        }\n    };\n    return new SetView<E>() {\n\n        @Override\n        public boolean contains(Object o) {\n            return a.contains(o) && !b.contains(o);\n        }\n\n        @Override\n        public Iterator<E> createIterator() {\n            return IteratorUtils.filteredIterator(a.iterator(), notContainedInB);\n        }\n    };\n}"
            ],
            [
                "intersection",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a unmodifiable <b>view</b> of the intersection of the given {@link Set}s.\n * <p>\n * The returned view contains all elements that are members of both input sets\n * ({@code a} and {@code b}).\n *\n * @param <E> the generic type that is able to represent the types contained\n *   in both input sets.\n * @param a  the first set, must not be null\n * @param b  the second set, must not be null\n * @return a view of the intersection of the two sets\n * @since 4.1\n */\npublic static <E> SetView<E> intersection(final Set<? extends E> a, final Set<? extends E> b) {\n    if (a == null || b == null) {\n        throw new NullPointerException(\"Sets must not be null.\");\n    }\n    final Predicate<E> containedInB = new Predicate<E>() {\n\n        @Override\n        public boolean evaluate(E object) {\n            return b.contains(object);\n        }\n    };\n    return new SetView<E>() {\n\n        @Override\n        public boolean contains(Object o) {\n            return a.contains(o) && b.contains(o);\n        }\n\n        @Override\n        public Iterator<E> createIterator() {\n            return IteratorUtils.filteredIterator(a.iterator(), containedInB);\n        }\n    };\n}"
            ],
            [
                "disjunction",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a unmodifiable <b>view</b> of the symmetric difference of the given\n * {@link Set}s.\n * <p>\n * The returned view contains all elements of {@code a} and {@code b} that are\n * not a member of the other set.\n * <p>\n * This is equivalent to {@code union(difference(a, b), difference(b, a))}.\n *\n * @param <E> the generic type that is able to represent the types contained\n *   in both input sets.\n * @param a  the first set, must not be null\n * @param b  the second set, must not be null\n * @return a view of the symmetric difference of the two sets\n * @since 4.1\n */\npublic static <E> SetView<E> disjunction(final Set<? extends E> a, final Set<? extends E> b) {\n    if (a == null || b == null) {\n        throw new NullPointerException(\"Sets must not be null.\");\n    }\n    final SetView<E> aMinusB = difference(a, b);\n    final SetView<E> bMinusA = difference(b, a);\n    return new SetView<E>() {\n\n        @Override\n        public boolean contains(Object o) {\n            return a.contains(o) ^ b.contains(o);\n        }\n\n        @Override\n        public Iterator<E> createIterator() {\n            return IteratorUtils.chainedIterator(aMinusB.iterator(), bMinusA.iterator());\n        }\n\n        @Override\n        public boolean isEmpty() {\n            return aMinusB.isEmpty() && bMinusA.isEmpty();\n        }\n\n        @Override\n        public int size() {\n            return aMinusB.size() + bMinusA.size();\n        }\n    };\n}"
            ],
            [
                "transformingSet",
                "org.apache.commons.collections4.set",
                "TransformedSet",
                "/**\n * Factory method to create a transforming set.\n * <p>\n * If there are any elements already in the set being decorated, they\n * are NOT transformed.\n * Contrast this with {@link #transformedSet(Set, Transformer)}.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed set\n * @throws NullPointerException if set or transformer is null\n * @since 4.0\n */\npublic static <E> TransformedSet<E> transformingSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer) {\n    return new TransformedSet<E>(set, transformer);\n}"
            ],
            [
                "transformedSet",
                "org.apache.commons.collections4.set",
                "TransformedSet",
                "/**\n * Factory method to create a transforming set that will transform\n * existing contents of the specified set.\n * <p>\n * If there are any elements already in the set being decorated, they\n * will be transformed by this method.\n * Contrast this with {@link #transformingSet(Set, Transformer)}.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed set\n * @throws NullPointerException if set or transformer is null\n * @since 4.0\n */\npublic static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer) {\n    final TransformedSet<E> decorated = new TransformedSet<E>(set, transformer);\n    if (set.size() > 0) {\n        // set is type E\n        @SuppressWarnings(\"unchecked\")\n        final E[] // NOPMD - false positive for generics\n        values = (E[]) set.toArray();\n        set.clear();\n        for (final E value : values) {\n            decorated.decorated().add(transformer.transform(value));\n        }\n    }\n    return decorated;\n}"
            ],
            [
                "transformingNavigableSet",
                "org.apache.commons.collections4.set",
                "TransformedNavigableSet",
                "/**\n * Factory method to create a transforming navigable set.\n * <p>\n * If there are any elements already in the set being decorated, they\n * are NOT transformed.\n * Contrast this with {@link #transformedNavigableSet(NavigableSet, Transformer)}.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed {@link NavigableSet}\n * @throws NullPointerException if set or transformer is null\n */\npublic static <E> TransformedNavigableSet<E> transformingNavigableSet(final NavigableSet<E> set, final Transformer<? super E, ? extends E> transformer) {\n    return new TransformedNavigableSet<E>(set, transformer);\n}"
            ],
            [
                "transformedNavigableSet",
                "org.apache.commons.collections4.set",
                "TransformedNavigableSet",
                "/**\n * Factory method to create a transforming navigable set that will transform\n * existing contents of the specified navigable set.\n * <p>\n * If there are any elements already in the set being decorated, they\n * will be transformed by this method.\n * Contrast this with {@link #transformingNavigableSet(NavigableSet, Transformer)}.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed {@link NavigableSet}\n * @throws NullPointerException if set or transformer is null\n */\npublic static <E> TransformedNavigableSet<E> transformedNavigableSet(final NavigableSet<E> set, final Transformer<? super E, ? extends E> transformer) {\n    final TransformedNavigableSet<E> decorated = new TransformedNavigableSet<E>(set, transformer);\n    if (set.size() > 0) {\n        // set is type E\n        @SuppressWarnings(\"unchecked\")\n        final E[] // NOPMD - false positive for generics\n        values = (E[]) set.toArray();\n        set.clear();\n        for (final E value : values) {\n            decorated.decorated().add(transformer.transform(value));\n        }\n    }\n    return decorated;\n}"
            ],
            [
                "predicatedNavigableSet",
                "org.apache.commons.collections4.set",
                "PredicatedNavigableSet",
                "/**\n * Factory method to create a predicated (validating) navigable set.\n * <p>\n * If there are any elements already in the set being decorated, they\n * are validated.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @param predicate  the predicate to use for validation, must not be null\n * @return a new predicated navigable set.\n * @throws NullPointerException if set or predicate is null\n * @throws IllegalArgumentException if the set contains invalid elements\n * @since 4.0\n */\npublic static <E> PredicatedNavigableSet<E> predicatedNavigableSet(final NavigableSet<E> set, final Predicate<? super E> predicate) {\n    return new PredicatedNavigableSet<E>(set, predicate);\n}"
            ],
            [
                "listOrderedSet",
                "org.apache.commons.collections4.set",
                "ListOrderedSet",
                "/**\n * Factory method to create an ordered set specifying the list and set to use.\n * <p>\n * The list and set must both be empty.\n *\n * @param <E> the element type\n * @param set the set to decorate, must be empty and not null\n * @param list the list to decorate, must be empty and not null\n * @return a new ordered set\n * @throws NullPointerException if set or list is null\n * @throws IllegalArgumentException if either the set or list is not empty\n * @since 4.0\n */\npublic static <E> ListOrderedSet<E> listOrderedSet(final Set<E> set, final List<E> list) {\n    if (set == null) {\n        throw new NullPointerException(\"Set must not be null\");\n    }\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (set.size() > 0 || list.size() > 0) {\n        throw new IllegalArgumentException(\"Set and List must be empty\");\n    }\n    return new ListOrderedSet<E>(set, list);\n}"
            ],
            [
                "listOrderedSet",
                "org.apache.commons.collections4.set",
                "ListOrderedSet",
                "/**\n * Factory method to create an ordered set.\n * <p>\n * An <code>ArrayList</code> is used to retain order.\n *\n * @param <E> the element type\n * @param set the set to decorate, must not be null\n * @return a new ordered set\n * @throws NullPointerException if set is null\n * @since 4.0\n */\npublic static <E> ListOrderedSet<E> listOrderedSet(final Set<E> set) {\n    return new ListOrderedSet<E>(set);\n}"
            ],
            [
                "listOrderedSet",
                "org.apache.commons.collections4.set",
                "ListOrderedSet",
                "/**\n * Factory method to create an ordered set using the supplied list to retain order.\n * <p>\n * A <code>HashSet</code> is used for the set behaviour.\n * <p>\n * NOTE: If the list contains duplicates, the duplicates are removed,\n * altering the specified list.\n *\n * @param <E> the element type\n * @param list the list to decorate, must not be null\n * @return a new ordered set\n * @throws NullPointerException if list is null\n * @since 4.0\n */\npublic static <E> ListOrderedSet<E> listOrderedSet(final List<E> list) {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n    return new ListOrderedSet<E>(set, list);\n}"
            ],
            [
                "unmodifiableSet",
                "org.apache.commons.collections4.set",
                "UnmodifiableSet",
                "/**\n * Factory method to create an unmodifiable set.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @return a new unmodifiable set\n * @throws NullPointerException if set is null\n * @since 4.0\n */\npublic static <E> Set<E> unmodifiableSet(final Set<? extends E> set) {\n    if (set instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final Set<E> tmpSet = (Set<E>) set;\n        return tmpSet;\n    }\n    return new UnmodifiableSet<E>(set);\n}"
            ],
            [
                "mapBackedSet",
                "org.apache.commons.collections4.set",
                "MapBackedSet",
                "/**\n * Factory method to create a set from a map.\n *\n * @param <E> the element type\n * @param <V> the dummy value type in the map\n * @param map  the map to decorate, must not be null\n * @return a new map backed set\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <E, V> MapBackedSet<E, V> mapBackedSet(final Map<E, ? super V> map) {\n    return mapBackedSet(map, null);\n}"
            ],
            [
                "mapBackedSet",
                "org.apache.commons.collections4.set",
                "MapBackedSet",
                "/**\n * Factory method to create a set from a map.\n *\n * @param <E> the element type\n * @param <V> the dummy value type in the map\n * @param map  the map to decorate, must not be null\n * @param dummyValue  the dummy value to use\n * @return a new map backed set\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <E, V> MapBackedSet<E, V> mapBackedSet(final Map<E, ? super V> map, final V dummyValue) {\n    return new MapBackedSet<E, V>(map, dummyValue);\n}"
            ],
            [
                "unmodifiableSortedSet",
                "org.apache.commons.collections4.set",
                "UnmodifiableSortedSet",
                "/**\n * Factory method to create an unmodifiable set.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @return a new unmodifiable {@link SortedSet}\n * @throws NullPointerException if set is null\n * @since 4.0\n */\npublic static <E> SortedSet<E> unmodifiableSortedSet(final SortedSet<E> set) {\n    if (set instanceof Unmodifiable) {\n        return set;\n    }\n    return new UnmodifiableSortedSet<E>(set);\n}"
            ],
            [
                "predicatedSortedSet",
                "org.apache.commons.collections4.set",
                "PredicatedSortedSet",
                "/**\n * Factory method to create a predicated (validating) sorted set.\n * <p>\n * If there are any elements already in the set being decorated, they\n * are validated.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @param predicate  the predicate to use for validation, must not be null\n * @return a new predicated sorted set.\n * @throws NullPointerException if set or predicate is null\n * @throws IllegalArgumentException if the set contains invalid elements\n * @since 4.0\n */\npublic static <E> PredicatedSortedSet<E> predicatedSortedSet(final SortedSet<E> set, final Predicate<? super E> predicate) {\n    return new PredicatedSortedSet<E>(set, predicate);\n}"
            ],
            [
                "predicatedSet",
                "org.apache.commons.collections4.set",
                "PredicatedSet",
                "/**\n * Factory method to create a predicated (validating) set.\n * <p>\n * If there are any elements already in the set being decorated, they\n * are validated.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @param predicate  the predicate to use for validation, must not be null\n * @return a decorated set\n * @throws NullPointerException if set or predicate is null\n * @throws IllegalArgumentException if the set contains invalid elements\n * @since 4.0\n */\npublic static <E> PredicatedSet<E> predicatedSet(final Set<E> set, final Predicate<? super E> predicate) {\n    return new PredicatedSet<E>(set, predicate);\n}"
            ],
            [
                "unmodifiableNavigableSet",
                "org.apache.commons.collections4.set",
                "UnmodifiableNavigableSet",
                "/**\n * Factory method to create an unmodifiable set.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @return a new unmodifiable {@link NavigableSet}\n * @throws NullPointerException if set is null\n */\npublic static <E> NavigableSet<E> unmodifiableNavigableSet(final NavigableSet<E> set) {\n    if (set instanceof Unmodifiable) {\n        return set;\n    }\n    return new UnmodifiableNavigableSet<E>(set);\n}"
            ],
            [
                "transformingSortedSet",
                "org.apache.commons.collections4.set",
                "TransformedSortedSet",
                "/**\n * Factory method to create a transforming sorted set.\n * <p>\n * If there are any elements already in the set being decorated, they\n * are NOT transformed.\n * Contrast this with {@link #transformedSortedSet(SortedSet, Transformer)}.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed {@link SortedSet}\n * @throws NullPointerException if set or transformer is null\n * @since 4.0\n */\npublic static <E> TransformedSortedSet<E> transformingSortedSet(final SortedSet<E> set, final Transformer<? super E, ? extends E> transformer) {\n    return new TransformedSortedSet<E>(set, transformer);\n}"
            ],
            [
                "transformedSortedSet",
                "org.apache.commons.collections4.set",
                "TransformedSortedSet",
                "/**\n * Factory method to create a transforming sorted set that will transform\n * existing contents of the specified sorted set.\n * <p>\n * If there are any elements already in the set being decorated, they\n * will be transformed by this method.\n * Contrast this with {@link #transformingSortedSet(SortedSet, Transformer)}.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed {@link SortedSet}\n * @throws NullPointerException if set or transformer is null\n * @since 4.0\n */\npublic static <E> TransformedSortedSet<E> transformedSortedSet(final SortedSet<E> set, final Transformer<? super E, ? extends E> transformer) {\n    final TransformedSortedSet<E> decorated = new TransformedSortedSet<E>(set, transformer);\n    if (set.size() > 0) {\n        // set is type E\n        @SuppressWarnings(\"unchecked\")\n        final E[] // NOPMD - false positive for generics\n        values = (E[]) set.toArray();\n        set.clear();\n        for (final E value : values) {\n            decorated.decorated().add(transformer.transform(value));\n        }\n    }\n    return decorated;\n}"
            ],
            [
                "get",
                "org.apache.commons.collections4",
                "EnumerationUtils",
                "/**\n * Returns the <code>index</code>-th value in the {@link Enumeration}, throwing\n * <code>IndexOutOfBoundsException</code> if there is no such element.\n * <p>\n * The Enumeration is advanced to <code>index</code> (or to the end, if\n * <code>index</code> exceeds the number of entries) as a side effect of this method.\n *\n * @param e  the enumeration to get a value from\n * @param index  the index to get\n * @param <T> the type of object in the {@link Enumeration}\n * @return the object at the specified index\n * @throws IndexOutOfBoundsException if the index is invalid\n * @throws IllegalArgumentException if the object type is invalid\n * @since 4.1\n */\npublic static <T> T get(final Enumeration<T> e, final int index) {\n    int i = index;\n    CollectionUtils.checkIndexBounds(i);\n    while (e.hasMoreElements()) {\n        i--;\n        if (i == -1) {\n            return e.nextElement();\n        } else {\n            e.nextElement();\n        }\n    }\n    throw new IndexOutOfBoundsException(\"Entry does not exist: \" + i);\n}"
            ],
            [
                "toList",
                "org.apache.commons.collections4",
                "EnumerationUtils",
                "/**\n * Creates a list based on an enumeration.\n *\n * <p>As the enumeration is traversed, an ArrayList of its values is\n * created. The new list is returned.</p>\n *\n * @param <E> the element type\n * @param enumeration  the enumeration to traverse, which should not be <code>null</code>.\n * @return a list containing all elements of the given enumeration\n * @throws NullPointerException if the enumeration parameter is <code>null</code>.\n */\npublic static <E> List<E> toList(final Enumeration<? extends E> enumeration) {\n    return IteratorUtils.toList(new EnumerationIterator<E>(enumeration));\n}"
            ],
            [
                "toList",
                "org.apache.commons.collections4",
                "EnumerationUtils",
                "/**\n * Override toList(Enumeration) for StringTokenizer as it implements Enumeration&lt;Object&gt;\n * for the sake of backward compatibility.\n *\n * @param stringTokenizer  the tokenizer to convert to a {@link List}&lt;{@link String}&gt;\n * @return a list containing all tokens of the given StringTokenizer\n */\npublic static List<String> toList(final StringTokenizer stringTokenizer) {\n    final List<String> result = new ArrayList<String>(stringTokenizer.countTokens());\n    while (stringTokenizer.hasMoreTokens()) {\n        result.add(stringTokenizer.nextToken());\n    }\n    return result;\n}"
            ],
            [
                "unmodifiableQueue",
                "org.apache.commons.collections4",
                "QueueUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns an unmodifiable queue backed by the given queue.\n *\n * @param <E> the type of the elements in the queue\n * @param queue  the queue to make unmodifiable, must not be null\n * @return an unmodifiable queue backed by that queue\n * @throws NullPointerException if the queue is null\n */\npublic static <E> Queue<E> unmodifiableQueue(final Queue<? extends E> queue) {\n    return UnmodifiableQueue.unmodifiableQueue(queue);\n}"
            ],
            [
                "predicatedQueue",
                "org.apache.commons.collections4",
                "QueueUtils",
                "/**\n * Returns a predicated (validating) queue backed by the given queue.\n * <p>\n * Only objects that pass the test in the given predicate can be added to the queue.\n * Trying to add an invalid object results in an IllegalArgumentException.\n * It is important not to use the original queue after invoking this method,\n * as it is a backdoor for adding invalid objects.\n *\n * @param <E> the type of the elements in the queue\n * @param queue  the queue to predicate, must not be null\n * @param predicate  the predicate used to evaluate new elements, must not be null\n * @return a predicated queue\n * @throws NullPointerException if the queue or predicate is null\n */\npublic static <E> Queue<E> predicatedQueue(final Queue<E> queue, final Predicate<? super E> predicate) {\n    return PredicatedQueue.predicatedQueue(queue, predicate);\n}"
            ],
            [
                "transformingQueue",
                "org.apache.commons.collections4",
                "QueueUtils",
                "/**\n * Returns a transformed queue backed by the given queue.\n * <p>\n * Each object is passed through the transformer as it is added to the\n * Queue. It is important not to use the original queue after invoking this\n * method, as it is a backdoor for adding untransformed objects.\n * <p>\n * Existing entries in the specified queue will not be transformed.\n * If you want that behaviour, see {@link TransformedQueue#transformedQueue}.\n *\n * @param <E> the type of the elements in the queue\n * @param queue  the queue to predicate, must not be null\n * @param transformer  the transformer for the queue, must not be null\n * @return a transformed queue backed by the given queue\n * @throws NullPointerException if the queue or transformer is null\n */\npublic static <E> Queue<E> transformingQueue(final Queue<E> queue, final Transformer<? super E, ? extends E> transformer) {\n    return TransformedQueue.transformingQueue(queue, transformer);\n}"
            ],
            [
                "emptyQueue",
                "org.apache.commons.collections4",
                "QueueUtils",
                "/**\n * Get an empty <code>Queue</code>.\n *\n * @param <E> the type of the elements in the queue\n * @return an empty {@link Queue}\n */\n// OK, empty queue is compatible with any type\n@SuppressWarnings(\"unchecked\")\npublic static <E> Queue<E> emptyQueue() {\n    return (Queue<E>) EMPTY_QUEUE;\n}"
            ],
            [
                "synchronizedBag",
                "org.apache.commons.collections4.bag",
                "SynchronizedBag",
                "/**\n * Factory method to create a synchronized bag.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @return a new synchronized Bag\n * @throws NullPointerException if bag is null\n * @since 4.0\n */\npublic static <E> SynchronizedBag<E> synchronizedBag(final Bag<E> bag) {\n    return new SynchronizedBag<E>(bag);\n}"
            ],
            [
                "collectionBag",
                "org.apache.commons.collections4.bag",
                "CollectionBag",
                "/**\n * Factory method to create a bag that complies to the Collection contract.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @return a Bag that complies to the Collection contract\n * @throws NullPointerException if bag is null\n */\npublic static <E> Bag<E> collectionBag(final Bag<E> bag) {\n    return new CollectionBag<E>(bag);\n}"
            ],
            [
                "unmodifiableBag",
                "org.apache.commons.collections4.bag",
                "UnmodifiableBag",
                "/**\n * Factory method to create an unmodifiable bag.\n * <p>\n * If the bag passed in is already unmodifiable, it is returned.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @return an unmodifiable Bag\n * @throws NullPointerException if bag is null\n * @since 4.0\n */\npublic static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n    if (bag instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final Bag<E> tmpBag = (Bag<E>) bag;\n        return tmpBag;\n    }\n    return new UnmodifiableBag<E>(bag);\n}"
            ],
            [
                "predicatedSortedBag",
                "org.apache.commons.collections4.bag",
                "PredicatedSortedBag",
                "/**\n * Factory method to create a predicated (validating) bag.\n * <p>\n * If there are any elements already in the bag being decorated, they\n * are validated.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @param predicate  the predicate to use for validation, must not be null\n * @return a new predicated SortedBag\n * @throws NullPointerException if bag or predicate is null\n * @throws IllegalArgumentException if the bag contains invalid elements\n * @since 4.0\n */\npublic static <E> PredicatedSortedBag<E> predicatedSortedBag(final SortedBag<E> bag, final Predicate<? super E> predicate) {\n    return new PredicatedSortedBag<E>(bag, predicate);\n}"
            ],
            [
                "unmodifiableSortedBag",
                "org.apache.commons.collections4.bag",
                "UnmodifiableSortedBag",
                "/**\n * Factory method to create an unmodifiable bag.\n * <p>\n * If the bag passed in is already unmodifiable, it is returned.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @return an unmodifiable SortedBag\n * @throws NullPointerException if bag is null\n * @since 4.0\n */\npublic static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n    if (bag instanceof Unmodifiable) {\n        return bag;\n    }\n    return new UnmodifiableSortedBag<E>(bag);\n}"
            ],
            [
                "transformingSortedBag",
                "org.apache.commons.collections4.bag",
                "TransformedSortedBag",
                "/**\n * Factory method to create a transforming sorted bag.\n * <p>\n * If there are any elements already in the bag being decorated, they\n * are NOT transformed. Contrast this with {@link #transformedSortedBag(SortedBag, Transformer)}.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed SortedBag\n * @throws NullPointerException if bag or transformer is null\n * @since 4.0\n */\npublic static <E> TransformedSortedBag<E> transformingSortedBag(final SortedBag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n    return new TransformedSortedBag<E>(bag, transformer);\n}"
            ],
            [
                "transformedSortedBag",
                "org.apache.commons.collections4.bag",
                "TransformedSortedBag",
                "/**\n * Factory method to create a transforming sorted bag that will transform\n * existing contents of the specified sorted bag.\n * <p>\n * If there are any elements already in the bag being decorated, they\n * will be transformed by this method.\n * Contrast this with {@link #transformingSortedBag(SortedBag, Transformer)}.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed SortedBag\n * @throws NullPointerException if bag or transformer is null\n * @since 4.0\n */\npublic static <E> TransformedSortedBag<E> transformedSortedBag(final SortedBag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n    final TransformedSortedBag<E> decorated = new TransformedSortedBag<E>(bag, transformer);\n    if (bag.size() > 0) {\n        // bag is type E\n        @SuppressWarnings(\"unchecked\")\n        final E[] // NOPMD - false positive for generics\n        values = (E[]) bag.toArray();\n        bag.clear();\n        for (final E value : values) {\n            decorated.decorated().add(transformer.transform(value));\n        }\n    }\n    return decorated;\n}"
            ],
            [
                "predicatedBag",
                "org.apache.commons.collections4.bag",
                "PredicatedBag",
                "/**\n * Factory method to create a predicated (validating) bag.\n * <p>\n * If there are any elements already in the bag being decorated, they\n * are validated.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @param predicate  the predicate to use for validation, must not be null\n * @return a new predicated Bag\n * @throws NullPointerException if bag or predicate is null\n * @throws IllegalArgumentException if the bag contains invalid elements\n * @since 4.0\n */\npublic static <E> PredicatedBag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n    return new PredicatedBag<E>(bag, predicate);\n}"
            ],
            [
                "synchronizedSortedBag",
                "org.apache.commons.collections4.bag",
                "SynchronizedSortedBag",
                "/**\n * Factory method to create a synchronized sorted bag.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @return a new synchronized SortedBag\n * @throws NullPointerException if bag is null\n * @since 4.0\n */\npublic static <E> SynchronizedSortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n    return new SynchronizedSortedBag<E>(bag);\n}"
            ],
            [
                "collectionSortedBag",
                "org.apache.commons.collections4.bag",
                "CollectionSortedBag",
                "/**\n * Factory method to create a sorted bag that complies to the Collection contract.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the sorted bag to decorate, must not be null\n * @return a SortedBag that complies to the Collection contract\n * @throws NullPointerException if bag is null\n */\npublic static <E> SortedBag<E> collectionSortedBag(final SortedBag<E> bag) {\n    return new CollectionSortedBag<E>(bag);\n}"
            ],
            [
                "transformingBag",
                "org.apache.commons.collections4.bag",
                "TransformedBag",
                "/**\n * Factory method to create a transforming bag.\n * <p>\n * If there are any elements already in the bag being decorated, they\n * are NOT transformed. Contrast this with {@link #transformedBag(Bag, Transformer)}.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed Bag\n * @throws NullPointerException if bag or transformer is null\n * @since 4.0\n */\npublic static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n    return new TransformedBag<E>(bag, transformer);\n}"
            ],
            [
                "transformedBag",
                "org.apache.commons.collections4.bag",
                "TransformedBag",
                "/**\n * Factory method to create a transforming bag that will transform\n * existing contents of the specified bag.\n * <p>\n * If there are any elements already in the bag being decorated, they\n * will be transformed by this method.\n * Contrast this with {@link #transformingBag(Bag, Transformer)}.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed Bag\n * @throws NullPointerException if bag or transformer is null\n * @since 4.0\n */\npublic static <E> Bag<E> transformedBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n    final TransformedBag<E> decorated = new TransformedBag<E>(bag, transformer);\n    if (bag.size() > 0) {\n        // Bag is of type E\n        @SuppressWarnings(\"unchecked\")\n        final E[] // NOPMD - false positive for generics\n        values = (E[]) bag.toArray();\n        bag.clear();\n        for (final E value : values) {\n            decorated.decorated().add(transformer.transform(value));\n        }\n    }\n    return decorated;\n}"
            ],
            [
                "predicatedMultiSet",
                "org.apache.commons.collections4.multiset",
                "PredicatedMultiSet",
                "/**\n * Factory method to create a predicated (validating) multiset.\n * <p>\n * If there are any elements already in the multiset being decorated, they\n * are validated.\n *\n * @param <E> the type of the elements in the multiset\n * @param multiset  the multiset to decorate, must not be null\n * @param predicate  the predicate to use for validation, must not be null\n * @return a new predicated MultiSet\n * @throws NullPointerException if multiset or predicate is null\n * @throws IllegalArgumentException if the multiset contains invalid elements\n */\npublic static <E> PredicatedMultiSet<E> predicatedMultiSet(final MultiSet<E> multiset, final Predicate<? super E> predicate) {\n    return new PredicatedMultiSet<E>(multiset, predicate);\n}"
            ],
            [
                "unmodifiableMultiSet",
                "org.apache.commons.collections4.multiset",
                "UnmodifiableMultiSet",
                "/**\n * Factory method to create an unmodifiable multiset.\n * <p>\n * If the multiset passed in is already unmodifiable, it is returned.\n *\n * @param <E>  the type of the elements in the multiset\n * @param multiset  the multiset to decorate, may not be null\n * @return an unmodifiable MultiSet\n * @throws NullPointerException if multiset is null\n */\npublic static <E> MultiSet<E> unmodifiableMultiSet(final MultiSet<? extends E> multiset) {\n    if (multiset instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final MultiSet<E> tmpMultiSet = (MultiSet<E>) multiset;\n        return tmpMultiSet;\n    }\n    return new UnmodifiableMultiSet<E>(multiset);\n}"
            ],
            [
                "synchronizedMultiSet",
                "org.apache.commons.collections4.multiset",
                "SynchronizedMultiSet",
                "/**\n * Factory method to create a synchronized multiset.\n *\n * @param <E> the type of the elements in the multiset\n * @param multiset  the multiset to decorate, must not be null\n * @return a new synchronized MultiSet\n * @throws NullPointerException if multiset is null\n */\npublic static <E> SynchronizedMultiSet<E> synchronizedMultiSet(final MultiSet<E> multiset) {\n    return new SynchronizedMultiSet<E>(multiset);\n}"
            ],
            [
                "synchronizedBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns a synchronized (thread-safe) bag backed by the given bag. In\n * order to guarantee serial access, it is critical that all access to the\n * backing bag is accomplished through the returned bag.\n * <p>\n * It is imperative that the user manually synchronize on the returned bag\n * when iterating over it:\n *\n * <pre>\n * Bag bag = BagUtils.synchronizedBag(new HashBag());\n * ...\n * synchronized(bag) {\n *     Iterator i = bag.iterator(); // Must be in synchronized block\n *     while (i.hasNext())\n *         foo(i.next());\n *     }\n * }\n * </pre>\n *\n * Failure to follow this advice may result in non-deterministic behavior.\n *\n * @param <E> the element type\n * @param bag the bag to synchronize, must not be null\n * @return a synchronized bag backed by that bag\n * @throws NullPointerException if the Bag is null\n */\npublic static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n    return SynchronizedBag.synchronizedBag(bag);\n}"
            ],
            [
                "unmodifiableBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * Returns an unmodifiable view of the given bag. Any modification attempts\n * to the returned bag will raise an {@link UnsupportedOperationException}.\n *\n * @param <E> the element type\n * @param bag the bag whose unmodifiable view is to be returned, must not be null\n * @return an unmodifiable view of that bag\n * @throws NullPointerException if the Bag is null\n */\npublic static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n    return UnmodifiableBag.unmodifiableBag(bag);\n}"
            ],
            [
                "predicatedBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * Returns a predicated (validating) bag backed by the given bag.\n * <p>\n * Only objects that pass the test in the given predicate can be added to\n * the bag. Trying to add an invalid object results in an\n * IllegalArgumentException. It is important not to use the original bag\n * after invoking this method, as it is a backdoor for adding invalid\n * objects.\n *\n * @param <E> the element type\n * @param bag the bag to predicate, must not be null\n * @param predicate the predicate for the bag, must not be null\n * @return a predicated bag backed by the given bag\n * @throws NullPointerException if the Bag or Predicate is null\n */\npublic static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n    return PredicatedBag.predicatedBag(bag, predicate);\n}"
            ],
            [
                "transformingBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * Returns a transformed bag backed by the given bag.\n * <p>\n * Each object is passed through the transformer as it is added to the Bag.\n * It is important not to use the original bag after invoking this method,\n * as it is a backdoor for adding untransformed objects.\n * <p>\n * Existing entries in the specified bag will not be transformed.\n * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n *\n * @param <E> the element type\n * @param bag the bag to predicate, must not be null\n * @param transformer the transformer for the bag, must not be null\n * @return a transformed bag backed by the given bag\n * @throws NullPointerException if the Bag or Transformer is null\n */\npublic static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n    return TransformedBag.transformingBag(bag, transformer);\n}"
            ],
            [
                "collectionBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * Returns a bag that complies to the Collection contract, backed by the given bag.\n *\n * @param <E> the element type\n * @param bag the bag to decorate, must not be null\n * @return a Bag that complies to the Collection contract\n * @throws NullPointerException if bag is null\n * @since 4.0\n */\npublic static <E> Bag<E> collectionBag(final Bag<E> bag) {\n    return CollectionBag.collectionBag(bag);\n}"
            ],
            [
                "synchronizedSortedBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns a synchronized (thread-safe) sorted bag backed by the given\n * sorted bag. In order to guarantee serial access, it is critical that all\n * access to the backing bag is accomplished through the returned bag.\n * <p>\n * It is imperative that the user manually synchronize on the returned bag\n * when iterating over it:\n *\n * <pre>\n * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n * ...\n * synchronized(bag) {\n *     Iterator i = bag.iterator(); // Must be in synchronized block\n *     while (i.hasNext())\n *         foo(i.next());\n *     }\n * }\n * </pre>\n *\n * Failure to follow this advice may result in non-deterministic behavior.\n *\n * @param <E> the element type\n * @param bag the bag to synchronize, must not be null\n * @return a synchronized bag backed by that bag\n * @throws NullPointerException if the SortedBag is null\n */\npublic static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n    return SynchronizedSortedBag.synchronizedSortedBag(bag);\n}"
            ],
            [
                "unmodifiableSortedBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * Returns an unmodifiable view of the given sorted bag. Any modification\n * attempts to the returned bag will raise an\n * {@link UnsupportedOperationException}.\n *\n * @param <E> the element type\n * @param bag the bag whose unmodifiable view is to be returned, must not be null\n * @return an unmodifiable view of that bag\n * @throws NullPointerException if the SortedBag is null\n */\npublic static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n    return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n}"
            ],
            [
                "predicatedSortedBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * Returns a predicated (validating) sorted bag backed by the given sorted\n * bag.\n * <p>\n * Only objects that pass the test in the given predicate can be added to\n * the bag. Trying to add an invalid object results in an\n * IllegalArgumentException. It is important not to use the original bag\n * after invoking this method, as it is a backdoor for adding invalid\n * objects.\n *\n * @param <E> the element type\n * @param bag the sorted bag to predicate, must not be null\n * @param predicate the predicate for the bag, must not be null\n * @return a predicated bag backed by the given bag\n * @throws NullPointerException if the SortedBag or Predicate is null\n */\npublic static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag, final Predicate<? super E> predicate) {\n    return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n}"
            ],
            [
                "transformingSortedBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * Returns a transformed sorted bag backed by the given bag.\n * <p>\n * Each object is passed through the transformer as it is added to the Bag.\n * It is important not to use the original bag after invoking this method,\n * as it is a backdoor for adding untransformed objects.\n * <p>\n * Existing entries in the specified bag will not be transformed.\n * If you want that behaviour, see\n * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n *\n * @param <E> the element type\n * @param bag the bag to predicate, must not be null\n * @param transformer the transformer for the bag, must not be null\n * @return a transformed bag backed by the given bag\n * @throws NullPointerException if the Bag or Transformer is null\n */\npublic static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n    return TransformedSortedBag.transformingSortedBag(bag, transformer);\n}"
            ],
            [
                "emptyBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * Get an empty <code>Bag</code>.\n *\n * @param <E> the element type\n * @return an empty Bag\n */\n// OK, empty bag is compatible with any type\n@SuppressWarnings(\"unchecked\")\npublic static <E> Bag<E> emptyBag() {\n    return (Bag<E>) EMPTY_BAG;\n}"
            ],
            [
                "emptySortedBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * Get an empty <code>SortedBag</code>.\n *\n * @param <E> the element type\n * @return an empty sorted Bag\n */\n// OK, empty bag is compatible with any type\n@SuppressWarnings(\"unchecked\")\npublic static <E> SortedBag<E> emptySortedBag() {\n    return (SortedBag<E>) EMPTY_SORTED_BAG;\n}"
            ],
            [
                "resettableEmptyListIterator",
                "org.apache.commons.collections4.iterators",
                "EmptyListIterator",
                "/**\n * Get a typed instance of the iterator.\n * @param <E> the element type\n * @return {@link ResettableListIterator}<E>\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> ResettableListIterator<E> resettableEmptyListIterator() {\n    return (ResettableListIterator<E>) RESETTABLE_INSTANCE;\n}"
            ],
            [
                "emptyListIterator",
                "org.apache.commons.collections4.iterators",
                "EmptyListIterator",
                "/**\n * Get a typed instance of the iterator.\n * @param <E> the element type\n * @return {@link ListIterator}<E>\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> ListIterator<E> emptyListIterator() {\n    return (ListIterator<E>) INSTANCE;\n}"
            ],
            [
                "unmodifiableOrderedMapIterator",
                "org.apache.commons.collections4.iterators",
                "UnmodifiableOrderedMapIterator",
                "//-----------------------------------------------------------------------\n/**\n * Decorates the specified iterator such that it cannot be modified.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param iterator  the iterator to decorate\n * @return a new unmodifiable ordered map iterator\n * @throws NullPointerException if the iterator is null\n */\npublic static <K, V> OrderedMapIterator<K, V> unmodifiableOrderedMapIterator(final OrderedMapIterator<K, ? extends V> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"OrderedMapIterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final OrderedMapIterator<K, V> tmpIterator = (OrderedMapIterator<K, V>) iterator;\n        return tmpIterator;\n    }\n    return new UnmodifiableOrderedMapIterator<K, V>(iterator);\n}"
            ],
            [
                "unmodifiableIterator",
                "org.apache.commons.collections4.iterators",
                "UnmodifiableIterator",
                "//-----------------------------------------------------------------------\n/**\n * Decorates the specified iterator such that it cannot be modified.\n * <p>\n * If the iterator is already unmodifiable it is returned directly.\n *\n * @param <E>  the element type\n * @param iterator  the iterator to decorate\n * @return a new unmodifiable iterator\n * @throws NullPointerException if the iterator is null\n */\npublic static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final Iterator<E> tmpIterator = (Iterator<E>) iterator;\n        return tmpIterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}"
            ],
            [
                "peekingIterator",
                "org.apache.commons.collections4.iterators",
                "PeekingIterator",
                "//-----------------------------------------------------------------------\n/**\n * Decorates the specified iterator to support one-element lookahead.\n * <p>\n * If the iterator is already a {@link PeekingIterator} it is returned directly.\n *\n * @param <E>  the element type\n * @param iterator  the iterator to decorate\n * @return a new peeking iterator\n * @throws NullPointerException if the iterator is null\n */\npublic static <E> PeekingIterator<E> peekingIterator(final Iterator<? extends E> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof PeekingIterator<?>) {\n        // safe cast\n        @SuppressWarnings(\"unchecked\")\n        final PeekingIterator<E> it = (PeekingIterator<E>) iterator;\n        return it;\n    }\n    return new PeekingIterator<E>(iterator);\n}"
            ],
            [
                "emptyMapIterator",
                "org.apache.commons.collections4.iterators",
                "EmptyMapIterator",
                "/**\n * Get a typed instance of the iterator.\n * @param <K> the key type\n * @param <V> the value type\n * @return {@link MapIterator}<K, V>\n */\n@SuppressWarnings(\"unchecked\")\npublic static <K, V> MapIterator<K, V> emptyMapIterator() {\n    return (MapIterator<K, V>) INSTANCE;\n}"
            ],
            [
                "emptyOrderedIterator",
                "org.apache.commons.collections4.iterators",
                "EmptyOrderedIterator",
                "/**\n * Typed instance of the iterator.\n * @param <E> the element type\n * @return OrderedIterator<E>\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> OrderedIterator<E> emptyOrderedIterator() {\n    return (OrderedIterator<E>) INSTANCE;\n}"
            ],
            [
                "umodifiableListIterator",
                "org.apache.commons.collections4.iterators",
                "UnmodifiableListIterator",
                "//-----------------------------------------------------------------------\n/**\n * Decorates the specified iterator such that it cannot be modified.\n *\n * @param <E>  the element type\n * @param iterator  the iterator to decorate\n * @return a new unmodifiable list iterator\n * @throws NullPointerException if the iterator is null\n */\npublic static <E> ListIterator<E> umodifiableListIterator(final ListIterator<? extends E> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"ListIterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final ListIterator<E> tmpIterator = (ListIterator<E>) iterator;\n        return tmpIterator;\n    }\n    return new UnmodifiableListIterator<E>(iterator);\n}"
            ],
            [
                "emptyOrderedMapIterator",
                "org.apache.commons.collections4.iterators",
                "EmptyOrderedMapIterator",
                "/**\n * Get a typed instance of the iterator.\n * @param <K> the key type\n * @param <V> the value type\n * @return {@link OrderedMapIterator}<K, V>\n */\n@SuppressWarnings(\"unchecked\")\npublic static <K, V> OrderedMapIterator<K, V> emptyOrderedMapIterator() {\n    return (OrderedMapIterator<K, V>) INSTANCE;\n}"
            ],
            [
                "unmodifiableMapIterator",
                "org.apache.commons.collections4.iterators",
                "UnmodifiableMapIterator",
                "//-----------------------------------------------------------------------\n/**\n * Decorates the specified iterator such that it cannot be modified.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param iterator  the iterator to decorate\n * @return a new unmodifiable map iterator\n * @throws NullPointerException if the iterator is null\n */\npublic static <K, V> MapIterator<K, V> unmodifiableMapIterator(final MapIterator<? extends K, ? extends V> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"MapIterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final MapIterator<K, V> tmpIterator = (MapIterator<K, V>) iterator;\n        return tmpIterator;\n    }\n    return new UnmodifiableMapIterator<K, V>(iterator);\n}"
            ],
            [
                "resettableEmptyIterator",
                "org.apache.commons.collections4.iterators",
                "EmptyIterator",
                "/**\n * Get a typed resettable empty iterator instance.\n * @param <E> the element type\n * @return ResettableIterator<E>\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> ResettableIterator<E> resettableEmptyIterator() {\n    return (ResettableIterator<E>) RESETTABLE_INSTANCE;\n}"
            ],
            [
                "emptyIterator",
                "org.apache.commons.collections4.iterators",
                "EmptyIterator",
                "/**\n * Get a typed empty iterator instance.\n * @param <E> the element type\n * @return Iterator<E>\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Iterator<E> emptyIterator() {\n    return (Iterator<E>) INSTANCE;\n}"
            ],
            [
                "pushbackIterator",
                "org.apache.commons.collections4.iterators",
                "PushbackIterator",
                "//-----------------------------------------------------------------------\n/**\n * Decorates the specified iterator to support one-element lookahead.\n * <p>\n * If the iterator is already a {@link PushbackIterator} it is returned directly.\n *\n * @param <E>  the element type\n * @param iterator  the iterator to decorate\n * @return a new peeking iterator\n * @throws NullPointerException if the iterator is null\n */\npublic static <E> PushbackIterator<E> pushbackIterator(final Iterator<? extends E> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof PushbackIterator<?>) {\n        // safe cast\n        @SuppressWarnings(\"unchecked\")\n        final PushbackIterator<E> it = (PushbackIterator<E>) iterator;\n        return it;\n    }\n    return new PushbackIterator<E>(iterator);\n}"
            ],
            [
                "readableMap",
                "org.apache.commons.collections4",
                "SplitMapUtils",
                "//-----------------------------------------------------------------------\n/**\n * Get the specified {@link Get} as an instance of {@link IterableMap}.\n * If <code>get</code> implements {@link IterableMap} directly, no conversion will take place.\n * If <code>get</code> implements {@link Map} but not {@link IterableMap} it will be decorated.\n * Otherwise an {@link Unmodifiable} {@link IterableMap} will be returned.\n * @param <K> the key type\n * @param <V> the value type\n * @param get to wrap, must not be null\n * @return {@link IterableMap}\n * @throws NullPointerException if the argument is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <K, V> IterableMap<K, V> readableMap(final Get<K, V> get) {\n    if (get == null) {\n        throw new NullPointerException(\"Get must not be null\");\n    }\n    if (get instanceof Map) {\n        return get instanceof IterableMap ? ((IterableMap<K, V>) get) : MapUtils.iterableMap((Map<K, V>) get);\n    }\n    return new WrappedGet<K, V>(get);\n}"
            ],
            [
                "writableMap",
                "org.apache.commons.collections4",
                "SplitMapUtils",
                "/**\n * Get the specified {@link Put} as an instanceof {@link Map}.\n * If <code>put</code> implements {@link Map} directly, no conversion will take place.\n * Otherwise a <em>write-only</em> {@link Map} will be returned.  On such a {@link Map}\n * it is recommended that the result of #put(K, V) be discarded as it likely will not\n * match <code>V</code> at runtime.\n *\n * @param <K> the key type\n * @param <V> the element type\n * @param put to wrap, must not be null\n * @return {@link Map}\n * @throws NullPointerException if the argument is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <K, V> Map<K, V> writableMap(final Put<K, V> put) {\n    if (put == null) {\n        throw new NullPointerException(\"Put must not be null\");\n    }\n    if (put instanceof Map) {\n        return (Map<K, V>) put;\n    }\n    return new WrappedPut<K, V>(put);\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "EMPTY_ITERATOR",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// validation is done in this class in certain cases because the\n// public classes allow invalid states\n/**\n * An iterator over no elements.\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final ResettableIterator EMPTY_ITERATOR = EmptyIterator.RESETTABLE_INSTANCE;"
            ],
            [
                "EMPTY_LIST_ITERATOR",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * A list iterator over no elements.\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final ResettableListIterator EMPTY_LIST_ITERATOR = EmptyListIterator.RESETTABLE_INSTANCE;"
            ],
            [
                "EMPTY_ORDERED_ITERATOR",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * An ordered iterator over no elements.\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final OrderedIterator EMPTY_ORDERED_ITERATOR = EmptyOrderedIterator.INSTANCE;"
            ],
            [
                "EMPTY_MAP_ITERATOR",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * A map iterator over no elements.\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final MapIterator EMPTY_MAP_ITERATOR = EmptyMapIterator.INSTANCE;"
            ],
            [
                "EMPTY_ORDERED_MAP_ITERATOR",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * An ordered map iterator over no elements.\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final OrderedMapIterator EMPTY_ORDERED_MAP_ITERATOR = EmptyOrderedMapIterator.INSTANCE;"
            ],
            [
                "NATURAL_COMPARATOR",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Comparator for natural sort order.\n *\n * @see ComparableComparator#comparableComparator()\n */\n// explicit type needed for Java 1.5 compilation\n@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\npublic static final Comparator NATURAL_COMPARATOR = ComparableComparator.<Comparable>comparableComparator();"
            ],
            [
                "EMPTY_MULTI_VALUED_MAP",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "/**\n * An empty {@link UnmodifiableMultiValuedMap}.\n */\n@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\npublic static final MultiValuedMap EMPTY_MULTI_VALUED_MAP = UnmodifiableMultiValuedMap.unmodifiableMultiValuedMap(new ArrayListValuedHashMap(0, 0));"
            ],
            [
                "EMPTY_SORTED_MAP",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * An empty unmodifiable sorted map.\n * This is not provided in the JDK.\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final SortedMap EMPTY_SORTED_MAP = UnmodifiableSortedMap.unmodifiableSortedMap(new TreeMap<Object, Object>());"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "DefaultEquator",
                "/**\n * Static instance\n */\n// the static instance works for all types\n@SuppressWarnings(\"rawtypes\")\npublic static final DefaultEquator INSTANCE = new DefaultEquator<Object>();"
            ],
            [
                "HASHCODE_NULL",
                "org.apache.commons.collections4.functors",
                "DefaultEquator",
                "/**\n * Hashcode used for <code>null</code> objects.\n */\npublic static final int HASHCODE_NULL = -1;"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "ExceptionClosure",
                "/**\n * Singleton predicate instance\n */\n// the static instance works for all types\n@SuppressWarnings(\"rawtypes\")\npublic static final Closure INSTANCE = new ExceptionClosure<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "NOPClosure",
                "/**\n * Singleton predicate instance\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final Closure INSTANCE = new NOPClosure<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "NullPredicate",
                "/**\n * Singleton predicate instance\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final Predicate INSTANCE = new NullPredicate<Object>();"
            ],
            [
                "NULL_INSTANCE",
                "org.apache.commons.collections4.functors",
                "ConstantTransformer",
                "/**\n * Returns null each time\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final Transformer NULL_INSTANCE = new ConstantTransformer<Object, Object>(null);"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "ExceptionTransformer",
                "/**\n * Singleton predicate instance\n */\n// the static instance works for all types\n@SuppressWarnings(\"rawtypes\")\npublic static final Transformer INSTANCE = new ExceptionTransformer<Object, Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "NOPTransformer",
                "/**\n * Singleton predicate instance\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final Transformer INSTANCE = new NOPTransformer<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "ExceptionFactory",
                "/**\n * Singleton predicate instance\n */\n// the static instance works for all types\n@SuppressWarnings(\"rawtypes\")\npublic static final Factory INSTANCE = new ExceptionFactory<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "ExceptionPredicate",
                "/**\n * Singleton predicate instance\n */\n// the static instance works for all types\n@SuppressWarnings(\"rawtypes\")\npublic static final Predicate INSTANCE = new ExceptionPredicate<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "FalsePredicate",
                "/**\n * Singleton predicate instance\n */\n// the static instance works for all types\n@SuppressWarnings(\"rawtypes\")\npublic static final Predicate INSTANCE = new FalsePredicate<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "CloneTransformer",
                "/**\n * Singleton predicate instance\n */\n// the singleton instance works for all types\n@SuppressWarnings(\"rawtypes\")\npublic static final Transformer INSTANCE = new CloneTransformer<Object>();"
            ],
            [
                "NULL_INSTANCE",
                "org.apache.commons.collections4.functors",
                "ConstantFactory",
                "/**\n * Returns null each time\n */\n// The null factory works for all object types\n@SuppressWarnings(\"rawtypes\")\npublic static final Factory NULL_INSTANCE = new ConstantFactory<Object>(null);"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "TruePredicate",
                "/**\n * Singleton predicate instance\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final Predicate INSTANCE = new TruePredicate<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "NotNullPredicate",
                "/**\n * Singleton predicate instance\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final Predicate INSTANCE = new NotNullPredicate<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.comparators",
                "ComparableComparator",
                "/**\n * The singleton instance.\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final ComparableComparator INSTANCE = new ComparableComparator();"
            ],
            [
                "EMPTY_COLLECTION",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * An empty unmodifiable collection.\n * The JDK provides empty Set and List implementations which could be used for\n * this purpose. However they could be cast to Set or List which might be\n * undesirable. This implementation only implements Collection.\n */\n// we deliberately use the raw type here\n@SuppressWarnings(\"rawtypes\")\npublic static final Collection EMPTY_COLLECTION = UnmodifiableCollection.unmodifiableCollection(new ArrayList<Object>());"
            ],
            [
                "EMPTY_ITERABLE",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * An empty iterable.\n */\n@SuppressWarnings(\"rawtypes\")\nstatic final FluentIterable EMPTY_ITERABLE = new FluentIterable<Object>() {\n\n    @Override\n    public Iterator<Object> iterator() {\n        return IteratorUtils.emptyIterator();\n    }\n};"
            ],
            [
                "NULL_BIT_KEY",
                "org.apache.commons.collections4.trie",
                "KeyAnalyzer",
                "/**\n * Returned by {@link #bitIndex(Object, int, int, Object, int, int)}\n * if key's bits are all 0.\n */\npublic static final int NULL_BIT_KEY = -1;"
            ],
            [
                "EQUAL_BIT_KEY",
                "org.apache.commons.collections4.trie",
                "KeyAnalyzer",
                "/**\n * Returned by {@link #bitIndex(Object, int, int, Object, int, int)} if key and found key are equal.\n * This is a very very specific case and shouldn't happen on a regular basis.\n */\npublic static final int EQUAL_BIT_KEY = -2;"
            ],
            [
                "OUT_OF_BOUNDS_BIT_KEY",
                "org.apache.commons.collections4.trie",
                "KeyAnalyzer",
                "public static final int OUT_OF_BOUNDS_BIT_KEY = -3;"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.trie.analyzer",
                "StringKeyAnalyzer",
                "/**\n * A singleton instance of {@link StringKeyAnalyzer}.\n */\npublic static final StringKeyAnalyzer INSTANCE = new StringKeyAnalyzer();"
            ],
            [
                "LENGTH",
                "org.apache.commons.collections4.trie.analyzer",
                "StringKeyAnalyzer",
                "/**\n * The number of bits per {@link Character}.\n */\npublic static final int LENGTH = Character.SIZE;"
            ],
            [
                "NO_NEXT_ENTRY",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "protected static final String NO_NEXT_ENTRY = \"No next() entry in the iteration\";"
            ],
            [
                "NO_PREVIOUS_ENTRY",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "protected static final String NO_PREVIOUS_ENTRY = \"No previous() entry in the iteration\";"
            ],
            [
                "REMOVE_INVALID",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "protected static final String REMOVE_INVALID = \"remove() can only be called once after next()\";"
            ],
            [
                "GETKEY_INVALID",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "protected static final String GETKEY_INVALID = \"getKey() can only be called after next() and before remove()\";"
            ],
            [
                "GETVALUE_INVALID",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "protected static final String GETVALUE_INVALID = \"getValue() can only be called after next() and before remove()\";"
            ],
            [
                "SETVALUE_INVALID",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "protected static final String SETVALUE_INVALID = \"setValue() can only be called after next() and before remove()\";"
            ],
            [
                "DEFAULT_CAPACITY",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "/**\n * The default capacity to use\n */\nprotected static final int DEFAULT_CAPACITY = 16;"
            ],
            [
                "DEFAULT_THRESHOLD",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "/**\n * The default threshold to use\n */\nprotected static final int DEFAULT_THRESHOLD = 12;"
            ],
            [
                "DEFAULT_LOAD_FACTOR",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "/**\n * The default load factor to use\n */\nprotected static final float DEFAULT_LOAD_FACTOR = 0.75f;"
            ],
            [
                "MAXIMUM_CAPACITY",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "/**\n * The maximum capacity allowed\n */\nprotected static final int MAXIMUM_CAPACITY = 1 << 30;"
            ],
            [
                "NULL",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "/**\n * An object for masking null\n */\nprotected static final Object NULL = new Object();"
            ],
            [
                "DEFAULT_MAX_SIZE",
                "org.apache.commons.collections4.map",
                "LRUMap",
                "/**\n * Default maximum size\n */\nprotected static final int DEFAULT_MAX_SIZE = 100;"
            ],
            [
                "EMPTY_MULTISET",
                "org.apache.commons.collections4",
                "MultiSetUtils",
                "/**\n * An empty unmodifiable multiset.\n */\n// OK, empty multiset is compatible with any type\n@SuppressWarnings(\"rawtypes\")\npublic static final MultiSet EMPTY_MULTISET = UnmodifiableMultiSet.unmodifiableMultiSet(new HashMultiSet<Object>());"
            ],
            [
                "EMPTY_SORTED_SET",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * An empty unmodifiable sorted set.\n * This is not provided in the JDK.\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final SortedSet EMPTY_SORTED_SET = UnmodifiableSortedSet.unmodifiableSortedSet(new TreeSet<Object>());"
            ],
            [
                "EMPTY_QUEUE",
                "org.apache.commons.collections4",
                "QueueUtils",
                "/**\n * An empty unmodifiable queue.\n */\n// OK, empty queue is compatible with any type\n@SuppressWarnings(\"rawtypes\")\npublic static final Queue EMPTY_QUEUE = UnmodifiableQueue.unmodifiableQueue(new LinkedList<Object>());"
            ],
            [
                "EMPTY_BAG",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * An empty unmodifiable bag.\n */\n// OK, empty bag is compatible with any type\n@SuppressWarnings(\"rawtypes\")\npublic static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());"
            ],
            [
                "EMPTY_SORTED_BAG",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * An empty unmodifiable sorted bag.\n */\n// OK, empty bag is compatible with any type\n@SuppressWarnings(\"rawtypes\")\npublic static final Bag EMPTY_SORTED_BAG = UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());"
            ],
            [
                "RESETTABLE_INSTANCE",
                "org.apache.commons.collections4.iterators",
                "EmptyListIterator",
                "/**\n * Singleton instance of the iterator.\n * @since 3.1\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final ResettableListIterator RESETTABLE_INSTANCE = new EmptyListIterator<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.iterators",
                "EmptyListIterator",
                "/**\n * Singleton instance of the iterator.\n * @since 2.1.1 and 3.1\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final ListIterator INSTANCE = RESETTABLE_INSTANCE;"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.iterators",
                "EmptyMapIterator",
                "/**\n * Singleton instance of the iterator.\n * @since 3.1\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final MapIterator INSTANCE = new EmptyMapIterator<Object, Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.iterators",
                "EmptyOrderedIterator",
                "/**\n * Singleton instance of the iterator.\n * @since 3.1\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final OrderedIterator INSTANCE = new EmptyOrderedIterator<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.iterators",
                "EmptyOrderedMapIterator",
                "/**\n * Singleton instance of the iterator.\n * @since 3.1\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final OrderedMapIterator INSTANCE = new EmptyOrderedMapIterator<Object, Object>();"
            ],
            [
                "RESETTABLE_INSTANCE",
                "org.apache.commons.collections4.iterators",
                "EmptyIterator",
                "/**\n * Singleton instance of the iterator.\n * @since 3.1\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final ResettableIterator RESETTABLE_INSTANCE = new EmptyIterator<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.iterators",
                "EmptyIterator",
                "/**\n * Singleton instance of the iterator.\n * @since 2.1.1 and 3.1\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final Iterator INSTANCE = RESETTABLE_INSTANCE;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [
            [
                "coll",
                "java.util.Collection",
                "Collection<? extends E>"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "containsAll",
                "java.util",
                "Collection",
                "public abstract boolean containsAll(Collection<? extends Object> arg0)"
            ],
            [
                "toArray",
                "org.apache.commons.collections4.collection",
                "AbstractCollectionDecorator",
                "public Object[] toArray()"
            ],
            [
                "parallelStream",
                "java.util",
                "Collection",
                "public default Stream<E> parallelStream()"
            ],
            [
                "decorated",
                "org.apache.commons.collections4.collection",
                "AbstractCollectionDecorator",
                "protected Collection<E> decorated()"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "add",
                "org.apache.commons.collections4.collection",
                "UnmodifiableCollection",
                "@Override\npublic boolean add(final E object) {\n    throw new UnsupportedOperationException();\n}"
            ],
            [
                "remove",
                "org.apache.commons.collections4.collection",
                "UnmodifiableCollection",
                "@Override\npublic boolean remove(final Object object) {\n    throw new UnsupportedOperationException();\n}"
            ],
            [
                "retainAll",
                "org.apache.commons.collections4.collection",
                "UnmodifiableCollection",
                "@Override\npublic boolean retainAll(final Collection<?> coll) {\n    throw new UnsupportedOperationException();\n}"
            ],
            [
                "removeAll",
                "java.util",
                "Collection",
                "public abstract boolean removeAll(Collection<? extends Object> arg0)"
            ],
            [
                "spliterator",
                "java.lang",
                "Iterable",
                "public default Spliterator<T> spliterator()"
            ],
            [
                "isEmpty",
                "org.apache.commons.collections4.collection",
                "AbstractCollectionDecorator",
                "public boolean isEmpty()"
            ],
            [
                "toArray",
                "org.apache.commons.collections4.collection",
                "AbstractCollectionDecorator",
                "public <T> T[] toArray(T[] arg0)"
            ],
            [
                "contains",
                "org.apache.commons.collections4.collection",
                "AbstractCollectionDecorator",
                "public boolean contains(Object arg0)"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "spliterator",
                "java.util",
                "Collection",
                "public default Spliterator<E> spliterator()"
            ],
            [
                "retainAll",
                "java.util",
                "Collection",
                "public abstract boolean retainAll(Collection<? extends Object> arg0)"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "iterator",
                "java.lang",
                "Iterable",
                "public abstract Iterator<T> iterator()"
            ],
            [
                "containsAll",
                "org.apache.commons.collections4.collection",
                "AbstractCollectionDecorator",
                "public boolean containsAll(Collection<?> arg0)"
            ],
            [
                "removeIf",
                "org.apache.commons.collections4.collection",
                "AbstractCollectionDecorator",
                "public boolean removeIf(Predicate<? super E> arg0)"
            ],
            [
                "addAll",
                "org.apache.commons.collections4.collection",
                "UnmodifiableCollection",
                "@Override\npublic boolean addAll(final Collection<? extends E> coll) {\n    throw new UnsupportedOperationException();\n}"
            ],
            [
                "toArray",
                "java.util",
                "Collection",
                "public default <T> T[] toArray(IntFunction<T[]> arg0)"
            ],
            [
                "removeAll",
                "org.apache.commons.collections4.collection",
                "UnmodifiableCollection",
                "@Override\npublic boolean removeAll(final Collection<?> coll) {\n    throw new UnsupportedOperationException();\n}"
            ],
            [
                "iterator",
                "org.apache.commons.collections4.collection",
                "UnmodifiableCollection",
                "//-----------------------------------------------------------------------\n@Override\npublic Iterator<E> iterator() {\n    return UnmodifiableIterator.unmodifiableIterator(decorated().iterator());\n}"
            ],
            [
                "size",
                "org.apache.commons.collections4.collection",
                "AbstractCollectionDecorator",
                "public int size()"
            ],
            [
                "stream",
                "java.util",
                "Collection",
                "public default Stream<E> stream()"
            ],
            [
                "toString",
                "org.apache.commons.collections4.collection",
                "AbstractCollectionDecorator",
                "public String toString()"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "remove",
                "java.util",
                "Collection",
                "public abstract boolean remove(Object arg0)"
            ],
            [
                "size",
                "java.util",
                "Collection",
                "public abstract int size()"
            ],
            [
                "toArray",
                "java.util",
                "Collection",
                "public abstract <T> T[] toArray(T[] arg0)"
            ],
            [
                "equals",
                "java.util",
                "Collection",
                "public abstract boolean equals(Object arg0)"
            ],
            [
                "contains",
                "java.util",
                "Collection",
                "public abstract boolean contains(Object arg0)"
            ],
            [
                "hashCode",
                "java.util",
                "Collection",
                "public abstract int hashCode()"
            ],
            [
                "removeIf",
                "java.util",
                "Collection",
                "public default boolean removeIf(Predicate<? super E> arg0)"
            ],
            [
                "add",
                "java.util",
                "Collection",
                "public abstract boolean add(E arg0)"
            ],
            [
                "isEmpty",
                "java.util",
                "Collection",
                "public abstract boolean isEmpty()"
            ],
            [
                "addAll",
                "java.util",
                "Collection",
                "public abstract boolean addAll(Collection<? extends E> arg0)"
            ],
            [
                "toArray",
                "java.util",
                "Collection",
                "public abstract Object[] toArray()"
            ],
            [
                "iterator",
                "java.util",
                "Collection",
                "public abstract Iterator<E> iterator()"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 6392,
        "oracle": "(paramTypes == null && args != null) || (paramTypes != null && args == null) || (paramTypes != null && args != null && paramTypes.length != args.length);",
        "oracleType": "EXCEPT_POST",
        "projectName": "commons-collections4-4.1",
        "packageName": "org.apache.commons.collections4",
        "className": "FactoryUtils",
        "javadocTag": "@throws IllegalArgumentException if the paramTypes and args don't match",
        "methodJavadoc": "    /**\n     * Creates a Factory that can create objects of a specific type using\n     * the arguments specified to this method.\n     *\n     * @see org.apache.commons.collections4.functors.InstantiateFactory\n     *\n     * @param <T> the type that the factory creates\n     * @param classToInstantiate  the Class to instantiate each time in the factory\n     * @param paramTypes  parameter types for the constructor, can be null\n     * @param args  the arguments to pass to the constructor, can be null\n     * @return the <code>reflection</code> factory\n     * @throws NullPointerException if the classToInstantiate is null\n     * @throws IllegalArgumentException if the paramTypes and args don't match\n     * @throws IllegalArgumentException if the constructor doesn't exist\n     */",
        "methodSourceCode": "public static <T> Factory<T> instantiateFactory(final Class<T> classToInstantiate, final Class<?>[] paramTypes, final Object[] args){\n    return InstantiateFactory.instantiateFactory(classToInstantiate, paramTypes, args);\n}",
        "classJavadoc": "/**\n * <code>FactoryUtils</code> provides reference implementations and utilities\n * for the Factory functor interface. The supplied factories are:\n * <ul>\n * <li>Prototype - clones a specified object\n * <li>Instantiate - creates objects using reflection\n * <li>Constant - always returns the same object\n * <li>Null - always returns null\n * <li>Exception - always throws an exception\n * </ul>\n * <p>\n * Since v4.1 only factories which are considered to be unsafe are\n * Serializable. Factories considered to be unsafe for serialization are:\n * <ul>\n * <li>Prototype\n * <li>Instantiate\n * </ul>\n *\n * @since 3.0\n * @version $Id: FactoryUtils.java 1714362 2015-11-14 20:38:02Z tn $\n */",
        "classSourceCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.functors.ConstantFactory;\nimport org.apache.commons.collections4.functors.ExceptionFactory;\nimport org.apache.commons.collections4.functors.InstantiateFactory;\nimport org.apache.commons.collections4.functors.PrototypeFactory;\n\n/**\n * <code>FactoryUtils</code> provides reference implementations and utilities\n * for the Factory functor interface. The supplied factories are:\n * <ul>\n * <li>Prototype - clones a specified object\n * <li>Instantiate - creates objects using reflection\n * <li>Constant - always returns the same object\n * <li>Null - always returns null\n * <li>Exception - always throws an exception\n * </ul>\n * <p>\n * Since v4.1 only factories which are considered to be unsafe are\n * Serializable. Factories considered to be unsafe for serialization are:\n * <ul>\n * <li>Prototype\n * <li>Instantiate\n * </ul>\n *\n * @since 3.0\n * @version $Id: FactoryUtils.java 1714362 2015-11-14 20:38:02Z tn $\n */\npublic class FactoryUtils {\n\n    /**\n     * This class is not normally instantiated.\n     */\n    private FactoryUtils() {}\n\n    /**\n     * Gets a Factory that always throws an exception.\n     * This could be useful during testing as a placeholder.\n     *\n     * @see org.apache.commons.collections4.functors.ExceptionFactory\n     *\n     * @param <T> the type that the factory creates\n     * @return the factory\n     */\n    public static <T> Factory<T> exceptionFactory() {\n        return ExceptionFactory.<T>exceptionFactory();\n    }\n\n    /**\n     * Gets a Factory that will return null each time the factory is used.\n     * This could be useful during testing as a placeholder.\n     *\n     * @see org.apache.commons.collections4.functors.ConstantFactory\n     * @param <T> the \"type\" of null object the factory should return.\n     * @return the factory\n     */\n    public static <T> Factory<T> nullFactory() {\n        return ConstantFactory.<T>constantFactory(null);\n    }\n\n    /**\n     * Creates a Factory that will return the same object each time the factory\n     * is used. No check is made that the object is immutable. In general, only\n     * immutable objects should use the constant factory. Mutable objects should\n     * use the prototype factory.\n     *\n     * @see org.apache.commons.collections4.functors.ConstantFactory\n     *\n     * @param <T> the type that the factory creates\n     * @param constantToReturn  the constant object to return each time in the factory\n     * @return the <code>constant</code> factory.\n     */\n    public static <T> Factory<T> constantFactory(final T constantToReturn) {\n        return ConstantFactory.constantFactory(constantToReturn);\n    }\n\n    /**\n     * Creates a Factory that will return a clone of the same prototype object\n     * each time the factory is used. The prototype will be cloned using one of these\n     * techniques (in order):\n     * <ul>\n     * <li>public clone method\n     * <li>public copy constructor\n     * <li>serialization clone\n     * <ul>\n     *\n     * @see org.apache.commons.collections4.functors.PrototypeFactory\n     *\n     * @param <T> the type that the factory creates\n     * @param prototype  the object to clone each time in the factory\n     * @return the <code>prototype</code> factory, or a {@link ConstantFactory#NULL_INSTANCE} if\n     * the {@code prototype} is {@code null}\n     * @throws IllegalArgumentException if the prototype cannot be cloned\n     */\n    public static <T> Factory<T> prototypeFactory(final T prototype) {\n        return PrototypeFactory.<T>prototypeFactory(prototype);\n    }\n\n    /**\n     * Creates a Factory that can create objects of a specific type using\n     * a no-args constructor.\n     *\n     * @see org.apache.commons.collections4.functors.InstantiateFactory\n     *\n     * @param <T> the type that the factory creates\n     * @param classToInstantiate  the Class to instantiate each time in the factory\n     * @return the <code>reflection</code> factory\n     * @throws NullPointerException if the classToInstantiate is null\n     */\n    public static <T> Factory<T> instantiateFactory(final Class<T> classToInstantiate) {\n        return InstantiateFactory.instantiateFactory(classToInstantiate, null, null);\n    }\n\n    /**\n     * Creates a Factory that can create objects of a specific type using\n     * the arguments specified to this method.\n     *\n     * @see org.apache.commons.collections4.functors.InstantiateFactory\n     *\n     * @param <T> the type that the factory creates\n     * @param classToInstantiate  the Class to instantiate each time in the factory\n     * @param paramTypes  parameter types for the constructor, can be null\n     * @param args  the arguments to pass to the constructor, can be null\n     * @return the <code>reflection</code> factory\n     * @throws NullPointerException if the classToInstantiate is null\n     * @throws IllegalArgumentException if the paramTypes and args don't match\n     * @throws IllegalArgumentException if the constructor doesn't exist\n     */\n    public static <T> Factory<T> instantiateFactory(final Class<T> classToInstantiate, final Class<?>[] paramTypes,\n                                                    final Object[] args) {\n        return InstantiateFactory.instantiateFactory(classToInstantiate, paramTypes, args);\n    }\n\n}\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "BidiMap",
                "org.apache.commons.collections4"
            ],
            [
                "Equator",
                "org.apache.commons.collections4"
            ],
            [
                "MultiSet",
                "org.apache.commons.collections4"
            ],
            [
                "IteratorUtils",
                "org.apache.commons.collections4"
            ],
            [
                "ComparatorUtils",
                "org.apache.commons.collections4"
            ],
            [
                "FunctorException",
                "org.apache.commons.collections4"
            ],
            [
                "AbstractDualBidiMap",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "UnmodifiableBidiMap",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "AbstractOrderedBidiMapDecorator",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "UnmodifiableOrderedBidiMap",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "AbstractBidiMapDecorator",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "DualLinkedHashBidiMap",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "UnmodifiableSortedBidiMap",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "AbstractSortedBidiMapDecorator",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "DualHashBidiMap",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "DualTreeBidiMap",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "TreeBidiMap",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "MultiMapUtils",
                "org.apache.commons.collections4"
            ],
            [
                "BoundedCollection",
                "org.apache.commons.collections4"
            ],
            [
                "UnmodifiableBoundedCollection",
                "org.apache.commons.collections4.collection"
            ],
            [
                "CompositeCollection",
                "org.apache.commons.collections4.collection"
            ],
            [
                "TransformedCollection",
                "org.apache.commons.collections4.collection"
            ],
            [
                "PredicatedCollection",
                "org.apache.commons.collections4.collection"
            ],
            [
                "IndexedCollection",
                "org.apache.commons.collections4.collection"
            ],
            [
                "SynchronizedCollection",
                "org.apache.commons.collections4.collection"
            ],
            [
                "UnmodifiableCollection",
                "org.apache.commons.collections4.collection"
            ],
            [
                "AbstractCollectionDecorator",
                "org.apache.commons.collections4.collection"
            ],
            [
                "OrderedBidiMap",
                "org.apache.commons.collections4"
            ],
            [
                "FactoryUtils",
                "org.apache.commons.collections4"
            ],
            [
                "IterableGet",
                "org.apache.commons.collections4"
            ],
            [
                "ListUtils",
                "org.apache.commons.collections4"
            ],
            [
                "Closure",
                "org.apache.commons.collections4"
            ],
            [
                "IterableSortedMap",
                "org.apache.commons.collections4"
            ],
            [
                "MapUtils",
                "org.apache.commons.collections4"
            ],
            [
                "Transformer",
                "org.apache.commons.collections4"
            ],
            [
                "DefaultEquator",
                "org.apache.commons.collections4.functors"
            ],
            [
                "StringValueTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "PredicateDecorator",
                "org.apache.commons.collections4.functors"
            ],
            [
                "IfTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "IdentityPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ExceptionClosure",
                "org.apache.commons.collections4.functors"
            ],
            [
                "NOPClosure",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ClosureTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "FunctorUtils",
                "org.apache.commons.collections4.functors"
            ],
            [
                "TransformerPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "NullPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ConstantTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "PredicateTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "WhileClosure",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ForClosure",
                "org.apache.commons.collections4.functors"
            ],
            [
                "NullIsTruePredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "TransformedPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "NonePredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ExceptionTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "SwitchTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "TransformerClosure",
                "org.apache.commons.collections4.functors"
            ],
            [
                "OrPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "NOPTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "MapTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ExceptionFactory",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ChainedClosure",
                "org.apache.commons.collections4.functors"
            ],
            [
                "AndPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "PrototypeFactory",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ExceptionPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "AbstractQuantifierPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "InstanceofPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "InvokerTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "FalsePredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "CloneTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "NotPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ConstantFactory",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ChainedTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ComparatorPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "CatchAndRethrowClosure",
                "org.apache.commons.collections4.functors"
            ],
            [
                "AllPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "NullIsFalsePredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "NullIsExceptionPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "AnyPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "TruePredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "FactoryTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "NotNullPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "SwitchClosure",
                "org.apache.commons.collections4.functors"
            ],
            [
                "UniquePredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "InstantiateTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "OnePredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "EqualPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "InstantiateFactory",
                "org.apache.commons.collections4.functors"
            ],
            [
                "IfClosure",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ResettableListIterator",
                "org.apache.commons.collections4"
            ],
            [
                "OrderedIterator",
                "org.apache.commons.collections4"
            ],
            [
                "ComparatorChain",
                "org.apache.commons.collections4.comparators"
            ],
            [
                "BooleanComparator",
                "org.apache.commons.collections4.comparators"
            ],
            [
                "ReverseComparator",
                "org.apache.commons.collections4.comparators"
            ],
            [
                "ComparableComparator",
                "org.apache.commons.collections4.comparators"
            ],
            [
                "TransformingComparator",
                "org.apache.commons.collections4.comparators"
            ],
            [
                "FixedOrderComparator",
                "org.apache.commons.collections4.comparators"
            ],
            [
                "NullComparator",
                "org.apache.commons.collections4.comparators"
            ],
            [
                "CollectionUtils",
                "org.apache.commons.collections4"
            ],
            [
                "ListValuedMap",
                "org.apache.commons.collections4"
            ],
            [
                "AbstractIterableGetMapDecorator",
                "org.apache.commons.collections4.splitmap"
            ],
            [
                "TransformedSplitMap",
                "org.apache.commons.collections4.splitmap"
            ],
            [
                "Factory",
                "org.apache.commons.collections4"
            ],
            [
                "IterableUtils",
                "org.apache.commons.collections4"
            ],
            [
                "Bag",
                "org.apache.commons.collections4"
            ],
            [
                "Predicate",
                "org.apache.commons.collections4"
            ],
            [
                "SortedBag",
                "org.apache.commons.collections4"
            ],
            [
                "TrieUtils",
                "org.apache.commons.collections4"
            ],
            [
                "ClosureUtils",
                "org.apache.commons.collections4"
            ],
            [
                "PatriciaTrie",
                "org.apache.commons.collections4.trie"
            ],
            [
                "UnmodifiableTrie",
                "org.apache.commons.collections4.trie"
            ],
            [
                "KeyAnalyzer",
                "org.apache.commons.collections4.trie"
            ],
            [
                "AbstractPatriciaTrie",
                "org.apache.commons.collections4.trie"
            ],
            [
                "AbstractBitwiseTrie",
                "org.apache.commons.collections4.trie"
            ],
            [
                "StringKeyAnalyzer",
                "org.apache.commons.collections4.trie.analyzer"
            ],
            [
                "TransformedSortedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "AbstractLinkedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "Flat3Map",
                "org.apache.commons.collections4.map"
            ],
            [
                "PredicatedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "FixedSizeSortedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "UnmodifiableSortedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "PredicatedSortedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "DefaultedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "ReferenceIdentityMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "AbstractSortedMapDecorator",
                "org.apache.commons.collections4.map"
            ],
            [
                "AbstractInputCheckedMapDecorator",
                "org.apache.commons.collections4.map"
            ],
            [
                "FixedSizeMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "LazySortedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "UnmodifiableOrderedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "CaseInsensitiveMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "AbstractHashedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "AbstractOrderedMapDecorator",
                "org.apache.commons.collections4.map"
            ],
            [
                "UnmodifiableMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "EntrySetToMapIteratorAdapter",
                "org.apache.commons.collections4.map"
            ],
            [
                "AbstractIterableMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "ListOrderedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "LinkedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "SingletonMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "UnmodifiableEntrySet",
                "org.apache.commons.collections4.map"
            ],
            [
                "StaticBucketMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "AbstractMapDecorator",
                "org.apache.commons.collections4.map"
            ],
            [
                "AbstractReferenceMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "MultiKeyMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "HashedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "LazyMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "PassiveExpiringMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "MultiValueMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "LRUMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "ReferenceMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "TransformedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "CompositeMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "UnmodifiableMapEntry",
                "org.apache.commons.collections4.keyvalue"
            ],
            [
                "MultiKey",
                "org.apache.commons.collections4.keyvalue"
            ],
            [
                "DefaultMapEntry",
                "org.apache.commons.collections4.keyvalue"
            ],
            [
                "DefaultKeyValue",
                "org.apache.commons.collections4.keyvalue"
            ],
            [
                "AbstractMapEntryDecorator",
                "org.apache.commons.collections4.keyvalue"
            ],
            [
                "AbstractKeyValue",
                "org.apache.commons.collections4.keyvalue"
            ],
            [
                "TiedMapEntry",
                "org.apache.commons.collections4.keyvalue"
            ],
            [
                "AbstractMapEntry",
                "org.apache.commons.collections4.keyvalue"
            ],
            [
                "MultiSetUtils",
                "org.apache.commons.collections4"
            ],
            [
                "MapIterator",
                "org.apache.commons.collections4"
            ],
            [
                "AbstractMultiValuedMap",
                "org.apache.commons.collections4.multimap"
            ],
            [
                "UnmodifiableMultiValuedMap",
                "org.apache.commons.collections4.multimap"
            ],
            [
                "HashSetValuedHashMap",
                "org.apache.commons.collections4.multimap"
            ],
            [
                "TransformedMultiValuedMap",
                "org.apache.commons.collections4.multimap"
            ],
            [
                "AbstractSetValuedMap",
                "org.apache.commons.collections4.multimap"
            ],
            [
                "AbstractListValuedMap",
                "org.apache.commons.collections4.multimap"
            ],
            [
                "ArrayListValuedHashMap",
                "org.apache.commons.collections4.multimap"
            ],
            [
                "AbstractMultiValuedMapDecorator",
                "org.apache.commons.collections4.multimap"
            ],
            [
                "LazyList",
                "org.apache.commons.collections4.list"
            ],
            [
                "AbstractSerializableListDecorator",
                "org.apache.commons.collections4.list"
            ],
            [
                "TreeList",
                "org.apache.commons.collections4.list"
            ],
            [
                "SetUniqueList",
                "org.apache.commons.collections4.list"
            ],
            [
                "AbstractListDecorator",
                "org.apache.commons.collections4.list"
            ],
            [
                "NodeCachingLinkedList",
                "org.apache.commons.collections4.list"
            ],
            [
                "UnmodifiableList",
                "org.apache.commons.collections4.list"
            ],
            [
                "FixedSizeList",
                "org.apache.commons.collections4.list"
            ],
            [
                "TransformedList",
                "org.apache.commons.collections4.list"
            ],
            [
                "GrowthList",
                "org.apache.commons.collections4.list"
            ],
            [
                "AbstractLinkedList",
                "org.apache.commons.collections4.list"
            ],
            [
                "CursorableLinkedList",
                "org.apache.commons.collections4.list"
            ],
            [
                "PredicatedList",
                "org.apache.commons.collections4.list"
            ],
            [
                "OrderedMap",
                "org.apache.commons.collections4"
            ],
            [
                "AbstractQueueDecorator",
                "org.apache.commons.collections4.queue"
            ],
            [
                "TransformedQueue",
                "org.apache.commons.collections4.queue"
            ],
            [
                "UnmodifiableQueue",
                "org.apache.commons.collections4.queue"
            ],
            [
                "CircularFifoQueue",
                "org.apache.commons.collections4.queue"
            ],
            [
                "PredicatedQueue",
                "org.apache.commons.collections4.queue"
            ],
            [
                "FluentIterable",
                "org.apache.commons.collections4"
            ],
            [
                "TransformerUtils",
                "org.apache.commons.collections4"
            ],
            [
                "PredicateUtils",
                "org.apache.commons.collections4"
            ],
            [
                "ResettableIterator",
                "org.apache.commons.collections4"
            ],
            [
                "MultiValuedMap",
                "org.apache.commons.collections4"
            ],
            [
                "SetUtils",
                "org.apache.commons.collections4"
            ],
            [
                "SortedBidiMap",
                "org.apache.commons.collections4"
            ],
            [
                "ArrayStack",
                "org.apache.commons.collections4"
            ],
            [
                "Put",
                "org.apache.commons.collections4"
            ],
            [
                "OrderedMapIterator",
                "org.apache.commons.collections4"
            ],
            [
                "TransformedSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "CompositeSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "TransformedNavigableSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "PredicatedNavigableSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "AbstractSetDecorator",
                "org.apache.commons.collections4.set"
            ],
            [
                "ListOrderedSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "UnmodifiableSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "AbstractSerializableSetDecorator",
                "org.apache.commons.collections4.set"
            ],
            [
                "MapBackedSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "UnmodifiableSortedSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "PredicatedSortedSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "AbstractSortedSetDecorator",
                "org.apache.commons.collections4.set"
            ],
            [
                "PredicatedSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "AbstractNavigableSetDecorator",
                "org.apache.commons.collections4.set"
            ],
            [
                "UnmodifiableNavigableSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "TransformedSortedSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "IterableMap",
                "org.apache.commons.collections4"
            ],
            [
                "EnumerationUtils",
                "org.apache.commons.collections4"
            ],
            [
                "DeleteCommand",
                "org.apache.commons.collections4.sequence"
            ],
            [
                "ReplacementsHandler",
                "org.apache.commons.collections4.sequence"
            ],
            [
                "InsertCommand",
                "org.apache.commons.collections4.sequence"
            ],
            [
                "SequencesComparator",
                "org.apache.commons.collections4.sequence"
            ],
            [
                "ReplacementsFinder",
                "org.apache.commons.collections4.sequence"
            ],
            [
                "KeepCommand",
                "org.apache.commons.collections4.sequence"
            ],
            [
                "EditCommand",
                "org.apache.commons.collections4.sequence"
            ],
            [
                "CommandVisitor",
                "org.apache.commons.collections4.sequence"
            ],
            [
                "EditScript",
                "org.apache.commons.collections4.sequence"
            ],
            [
                "QueueUtils",
                "org.apache.commons.collections4"
            ],
            [
                "SetValuedMap",
                "org.apache.commons.collections4"
            ],
            [
                "SynchronizedBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "AbstractMapBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "CollectionBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "UnmodifiableBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "PredicatedSortedBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "UnmodifiableSortedBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "HashBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "AbstractBagDecorator",
                "org.apache.commons.collections4.bag"
            ],
            [
                "TransformedSortedBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "TreeBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "PredicatedBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "SynchronizedSortedBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "CollectionSortedBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "TransformedBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "AbstractSortedBagDecorator",
                "org.apache.commons.collections4.bag"
            ],
            [
                "HashMultiSet",
                "org.apache.commons.collections4.multiset"
            ],
            [
                "AbstractMultiSet",
                "org.apache.commons.collections4.multiset"
            ],
            [
                "PredicatedMultiSet",
                "org.apache.commons.collections4.multiset"
            ],
            [
                "AbstractMultiSetDecorator",
                "org.apache.commons.collections4.multiset"
            ],
            [
                "AbstractMapMultiSet",
                "org.apache.commons.collections4.multiset"
            ],
            [
                "UnmodifiableMultiSet",
                "org.apache.commons.collections4.multiset"
            ],
            [
                "SynchronizedMultiSet",
                "org.apache.commons.collections4.multiset"
            ],
            [
                "BagUtils",
                "org.apache.commons.collections4"
            ],
            [
                "Unmodifiable",
                "org.apache.commons.collections4"
            ],
            [
                "Get",
                "org.apache.commons.collections4"
            ],
            [
                "Trie",
                "org.apache.commons.collections4"
            ],
            [
                "MultiMap",
                "org.apache.commons.collections4"
            ],
            [
                "KeyValue",
                "org.apache.commons.collections4"
            ],
            [
                "IteratorChain",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "EmptyListIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "UnmodifiableOrderedMapIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "AbstractListIteratorDecorator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "ZippingIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "UnmodifiableIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "CollatingIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "UniqueFilterIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "ReverseListIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "BoundedIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "AbstractIteratorDecorator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "TransformIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "AbstractEmptyIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "NodeListIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "ArrayListIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "LazyIteratorChain",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "LoopingListIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "PeekingIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "ObjectGraphIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "ArrayIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "PermutationIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "SingletonListIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "EmptyMapIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "ObjectArrayIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "EnumerationIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "IteratorIterable",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "AbstractEmptyMapIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "LoopingIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "IteratorEnumeration",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "SingletonIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "ListIteratorWrapper",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "SkippingIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "EmptyOrderedIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "AbstractMapIteratorDecorator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "ObjectArrayListIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "UnmodifiableListIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "EmptyOrderedMapIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "UnmodifiableMapIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "EmptyIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "EntrySetMapIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "PushbackIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "FilterIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "AbstractUntypedIteratorDecorator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "AbstractOrderedMapIteratorDecorator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "FilterListIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "SplitMapUtils",
                "org.apache.commons.collections4"
            ],
            [
                "BoundedMap",
                "org.apache.commons.collections4"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "emptyIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Empty\n//-----------------------------------------------------------------------\n/**\n * Gets an empty iterator.\n * <p>\n * This iterator is a valid iterator object that will iterate over nothing.\n *\n * @param <E> the element type\n * @return an iterator over nothing\n */\npublic static <E> ResettableIterator<E> emptyIterator() {\n    return EmptyIterator.<E>resettableEmptyIterator();\n}"
            ],
            [
                "emptyListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an empty list iterator.\n * <p>\n * This iterator is a valid list iterator object that will iterate\n * over nothing.\n *\n * @param <E> the element type\n * @return a list iterator over nothing\n */\npublic static <E> ResettableListIterator<E> emptyListIterator() {\n    return EmptyListIterator.<E>resettableEmptyListIterator();\n}"
            ],
            [
                "emptyOrderedIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an empty ordered iterator.\n * <p>\n * This iterator is a valid iterator object that will iterate\n * over nothing.\n *\n * @param <E> the element type\n * @return an ordered iterator over nothing\n */\npublic static <E> OrderedIterator<E> emptyOrderedIterator() {\n    return EmptyOrderedIterator.<E>emptyOrderedIterator();\n}"
            ],
            [
                "emptyMapIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an empty map iterator.\n * <p>\n * This iterator is a valid map iterator object that will iterate\n * over nothing.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @return a map iterator over nothing\n */\npublic static <K, V> MapIterator<K, V> emptyMapIterator() {\n    return EmptyMapIterator.<K, V>emptyMapIterator();\n}"
            ],
            [
                "emptyOrderedMapIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an empty ordered map iterator.\n * <p>\n * This iterator is a valid map iterator object that will iterate\n * over nothing.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @return a map iterator over nothing\n */\npublic static <K, V> OrderedMapIterator<K, V> emptyOrderedMapIterator() {\n    return EmptyOrderedMapIterator.<K, V>emptyOrderedMapIterator();\n}"
            ],
            [
                "singletonIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Singleton\n//-----------------------------------------------------------------------\n/**\n * Gets a singleton iterator.\n * <p>\n * This iterator is a valid iterator object that will iterate over\n * the specified object.\n *\n * @param <E> the element type\n * @param object  the single object over which to iterate\n * @return a singleton iterator over the object\n */\npublic static <E> ResettableIterator<E> singletonIterator(final E object) {\n    return new SingletonIterator<E>(object);\n}"
            ],
            [
                "singletonListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a singleton list iterator.\n * <p>\n * This iterator is a valid list iterator object that will iterate over\n * the specified object.\n *\n * @param <E> the element type\n * @param object  the single object over which to iterate\n * @return a singleton list iterator over the object\n */\npublic static <E> ListIterator<E> singletonListIterator(final E object) {\n    return new SingletonListIterator<E>(object);\n}"
            ],
            [
                "arrayIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Arrays\n//-----------------------------------------------------------------------\n/**\n * Gets an iterator over an object array.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @return an iterator over the array\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableIterator<E> arrayIterator(final E... array) {\n    return new ObjectArrayIterator<E>(array);\n}"
            ],
            [
                "arrayIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator over an object or primitive array.\n * <p>\n * This method will handle primitive arrays as well as object arrays.\n * The primitives will be wrapped in the appropriate wrapper class.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @return an iterator over the array\n * @throws IllegalArgumentException if the array is not an array\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableIterator<E> arrayIterator(final Object array) {\n    return new ArrayIterator<E>(array);\n}"
            ],
            [
                "arrayIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator over the end part of an object array.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @param start  the index to start iterating at\n * @return an iterator over part of the array\n * @throws IndexOutOfBoundsException if start is less than zero or greater\n *   than the length of the array\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableIterator<E> arrayIterator(final E[] array, final int start) {\n    return new ObjectArrayIterator<E>(array, start);\n}"
            ],
            [
                "arrayIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator over the end part of an object or primitive array.\n * <p>\n * This method will handle primitive arrays as well as object arrays.\n * The primitives will be wrapped in the appropriate wrapper class.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @param start  the index to start iterating at\n * @return an iterator over part of the array\n * @throws IllegalArgumentException if the array is not an array\n * @throws IndexOutOfBoundsException if start is less than zero or greater\n *   than the length of the array\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableIterator<E> arrayIterator(final Object array, final int start) {\n    return new ArrayIterator<E>(array, start);\n}"
            ],
            [
                "arrayIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator over part of an object array.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @param start  the index to start iterating at\n * @param end  the index to finish iterating at\n * @return an iterator over part of the array\n * @throws IndexOutOfBoundsException if array bounds are invalid\n * @throws IllegalArgumentException if end is before start\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableIterator<E> arrayIterator(final E[] array, final int start, final int end) {\n    return new ObjectArrayIterator<E>(array, start, end);\n}"
            ],
            [
                "arrayIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator over part of an object or primitive array.\n * <p>\n * This method will handle primitive arrays as well as object arrays.\n * The primitives will be wrapped in the appropriate wrapper class.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @param start  the index to start iterating at\n * @param end  the index to finish iterating at\n * @return an iterator over part of the array\n * @throws IllegalArgumentException if the array is not an array or end is before start\n * @throws IndexOutOfBoundsException if array bounds are invalid\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableIterator<E> arrayIterator(final Object array, final int start, final int end) {\n    return new ArrayIterator<E>(array, start, end);\n}"
            ],
            [
                "arrayListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "//-----------------------------------------------------------------------\n/**\n * Gets a list iterator over an object array.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @return a list iterator over the array\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableListIterator<E> arrayListIterator(final E... array) {\n    return new ObjectArrayListIterator<E>(array);\n}"
            ],
            [
                "arrayListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a list iterator over an object or primitive array.\n * <p>\n * This method will handle primitive arrays as well as object arrays.\n * The primitives will be wrapped in the appropriate wrapper class.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @return a list iterator over the array\n * @throws IllegalArgumentException if the array is not an array\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableListIterator<E> arrayListIterator(final Object array) {\n    return new ArrayListIterator<E>(array);\n}"
            ],
            [
                "arrayListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a list iterator over the end part of an object array.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @param start  the index to start iterating at\n * @return a list iterator over part of the array\n * @throws IndexOutOfBoundsException if start is less than zero\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableListIterator<E> arrayListIterator(final E[] array, final int start) {\n    return new ObjectArrayListIterator<E>(array, start);\n}"
            ],
            [
                "arrayListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a list iterator over the end part of an object or primitive array.\n * <p>\n * This method will handle primitive arrays as well as object arrays.\n * The primitives will be wrapped in the appropriate wrapper class.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @param start  the index to start iterating at\n * @return a list iterator over part of the array\n * @throws IllegalArgumentException if the array is not an array\n * @throws IndexOutOfBoundsException if start is less than zero\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableListIterator<E> arrayListIterator(final Object array, final int start) {\n    return new ArrayListIterator<E>(array, start);\n}"
            ],
            [
                "arrayListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a list iterator over part of an object array.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @param start  the index to start iterating at\n * @param end  the index to finish iterating at\n * @return a list iterator over part of the array\n * @throws IndexOutOfBoundsException if array bounds are invalid\n * @throws IllegalArgumentException if end is before start\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableListIterator<E> arrayListIterator(final E[] array, final int start, final int end) {\n    return new ObjectArrayListIterator<E>(array, start, end);\n}"
            ],
            [
                "arrayListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a list iterator over part of an object or primitive array.\n * <p>\n * This method will handle primitive arrays as well as object arrays.\n * The primitives will be wrapped in the appropriate wrapper class.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @param start  the index to start iterating at\n * @param end  the index to finish iterating at\n * @return a list iterator over part of the array\n * @throws IllegalArgumentException if the array is not an array or end is before start\n * @throws IndexOutOfBoundsException if array bounds are invalid\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableListIterator<E> arrayListIterator(final Object array, final int start, final int end) {\n    return new ArrayListIterator<E>(array, start, end);\n}"
            ],
            [
                "boundedIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Bounded\n//-----------------------------------------------------------------------\n/**\n * Decorates the specified iterator to return at most the given number\n * of elements.\n *\n * @param <E> the element type\n * @param iterator  the iterator to decorate\n * @param max  the maximum number of elements returned by this iterator\n * @return a new bounded iterator\n * @throws NullPointerException if the iterator is null\n * @throws IllegalArgumentException if max is negative\n * @since 4.1\n */\npublic static <E> BoundedIterator<E> boundedIterator(final Iterator<? extends E> iterator, long max) {\n    return boundedIterator(iterator, 0, max);\n}"
            ],
            [
                "boundedIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Decorates the specified iterator to return at most the given number\n * of elements, skipping all elements until the iterator reaches the\n * position at {@code offset}.\n * <p>\n * The iterator is immediately advanced until it reaches the position at\n * {@code offset}, incurring O(n) time.\n *\n * @param <E> the element type\n * @param iterator  the iterator to decorate\n * @param offset  the index of the first element of the decorated iterator to return\n * @param max  the maximum number of elements returned by this iterator\n * @return a new bounded iterator\n * @throws NullPointerException if the iterator is null\n * @throws IllegalArgumentException if either offset or max is negative\n * @since 4.1\n */\npublic static <E> BoundedIterator<E> boundedIterator(final Iterator<? extends E> iterator, long offset, long max) {\n    return new BoundedIterator<E>(iterator, offset, max);\n}"
            ],
            [
                "unmodifiableIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Unmodifiable\n//-----------------------------------------------------------------------\n/**\n * Gets an immutable version of an {@link Iterator}. The returned object\n * will always throw an {@link UnsupportedOperationException} for\n * the {@link Iterator#remove} method.\n *\n * @param <E> the element type\n * @param iterator  the iterator to make immutable\n * @return an immutable version of the iterator\n */\npublic static <E> Iterator<E> unmodifiableIterator(final Iterator<E> iterator) {\n    return UnmodifiableIterator.unmodifiableIterator(iterator);\n}"
            ],
            [
                "unmodifiableListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an immutable version of a {@link ListIterator}. The returned object\n * will always throw an {@link UnsupportedOperationException} for\n * the {@link Iterator#remove}, {@link ListIterator#add} and\n * {@link ListIterator#set} methods.\n *\n * @param <E> the element type\n * @param listIterator  the iterator to make immutable\n * @return an immutable version of the iterator\n */\npublic static <E> ListIterator<E> unmodifiableListIterator(final ListIterator<E> listIterator) {\n    return UnmodifiableListIterator.umodifiableListIterator(listIterator);\n}"
            ],
            [
                "unmodifiableMapIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an immutable version of a {@link MapIterator}. The returned object\n * will always throw an {@link UnsupportedOperationException} for\n * the {@link Iterator#remove}, {@link MapIterator#setValue(Object)} methods.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param mapIterator  the iterator to make immutable\n * @return an immutable version of the iterator\n */\npublic static <K, V> MapIterator<K, V> unmodifiableMapIterator(final MapIterator<K, V> mapIterator) {\n    return UnmodifiableMapIterator.unmodifiableMapIterator(mapIterator);\n}"
            ],
            [
                "chainedIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Chained\n//-----------------------------------------------------------------------\n/**\n * Gets an iterator that iterates through two {@link Iterator}s\n * one after another.\n *\n * @param <E> the element type\n * @param iterator1  the first iterator to use, not null\n * @param iterator2  the second iterator to use, not null\n * @return a combination iterator over the iterators\n * @throws NullPointerException if either iterator is null\n */\npublic static <E> Iterator<E> chainedIterator(final Iterator<? extends E> iterator1, final Iterator<? extends E> iterator2) {\n    // keep a version with two iterators to avoid the following warning in client code (Java 5 & 6)\n    // \"A generic array of E is created for a varargs parameter\"\n    return new IteratorChain<E>(iterator1, iterator2);\n}"
            ],
            [
                "chainedIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator that iterates through an array of {@link Iterator}s\n * one after another.\n *\n * @param <E> the element type\n * @param iterators  the iterators to use, not null or empty or contain nulls\n * @return a combination iterator over the iterators\n * @throws NullPointerException if iterators array is null or contains a null\n */\npublic static <E> Iterator<E> chainedIterator(final Iterator<? extends E>... iterators) {\n    return new IteratorChain<E>(iterators);\n}"
            ],
            [
                "chainedIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator that iterates through a collections of {@link Iterator}s\n * one after another.\n *\n * @param <E> the element type\n * @param iterators  the iterators to use, not null or empty or contain nulls\n * @return a combination iterator over the iterators\n * @throws NullPointerException if iterators collection is null or contains a null\n * @throws ClassCastException if the iterators collection contains the wrong object type\n */\npublic static <E> Iterator<E> chainedIterator(final Collection<Iterator<? extends E>> iterators) {\n    return new IteratorChain<E>(iterators);\n}"
            ],
            [
                "collatedIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Collated\n//-----------------------------------------------------------------------\n/**\n * Gets an iterator that provides an ordered iteration over the elements\n * contained in a collection of ordered {@link Iterator}s.\n * <p>\n * Given two ordered {@link Iterator}s <code>A</code> and <code>B</code>,\n * the {@link Iterator#next()} method will return the lesser of\n * <code>A.next()</code> and <code>B.next()</code>.\n * <p>\n * The comparator is optional. If null is specified then natural order is used.\n *\n * @param <E> the element type\n * @param comparator  the comparator to use, may be null for natural order\n * @param iterator1  the first iterators to use, not null\n * @param iterator2  the first iterators to use, not null\n * @return a combination iterator over the iterators\n * @throws NullPointerException if either iterator is null\n */\npublic static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator, final Iterator<? extends E> iterator1, final Iterator<? extends E> iterator2) {\n    @SuppressWarnings(\"unchecked\")\n    final Comparator<E> comp = comparator == null ? ComparatorUtils.NATURAL_COMPARATOR : (Comparator<E>) comparator;\n    return new CollatingIterator<E>(comp, iterator1, iterator2);\n}"
            ],
            [
                "collatedIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator that provides an ordered iteration over the elements\n * contained in an array of {@link Iterator}s.\n * <p>\n * Given two ordered {@link Iterator}s <code>A</code> and <code>B</code>,\n * the {@link Iterator#next()} method will return the lesser of\n * <code>A.next()</code> and <code>B.next()</code> and so on.\n * <p>\n * The comparator is optional. If null is specified then natural order is used.\n *\n * @param <E> the element type\n * @param comparator  the comparator to use, may be null for natural order\n * @param iterators  the iterators to use, not null or empty or contain nulls\n * @return a combination iterator over the iterators\n * @throws NullPointerException if iterators array is null or contains a null value\n */\npublic static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator, final Iterator<? extends E>... iterators) {\n    @SuppressWarnings(\"unchecked\")\n    final Comparator<E> comp = comparator == null ? ComparatorUtils.NATURAL_COMPARATOR : (Comparator<E>) comparator;\n    return new CollatingIterator<E>(comp, iterators);\n}"
            ],
            [
                "collatedIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator that provides an ordered iteration over the elements\n * contained in a collection of {@link Iterator}s.\n * <p>\n * Given two ordered {@link Iterator}s <code>A</code> and <code>B</code>,\n * the {@link Iterator#next()} method will return the lesser of\n * <code>A.next()</code> and <code>B.next()</code> and so on.\n * <p>\n * The comparator is optional. If null is specified then natural order is used.\n *\n * @param <E> the element type\n * @param comparator  the comparator to use, may be null for natural order\n * @param iterators  the iterators to use, not null or empty or contain nulls\n * @return a combination iterator over the iterators\n * @throws NullPointerException if iterators collection is null or contains a null\n * @throws ClassCastException if the iterators collection contains the wrong object type\n */\npublic static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator, final Collection<Iterator<? extends E>> iterators) {\n    @SuppressWarnings(\"unchecked\")\n    final Comparator<E> comp = comparator == null ? ComparatorUtils.NATURAL_COMPARATOR : (Comparator<E>) comparator;\n    return new CollatingIterator<E>(comp, iterators);\n}"
            ],
            [
                "objectGraphIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Object Graph\n//-----------------------------------------------------------------------\n/**\n * Gets an iterator that operates over an object graph.\n * <p>\n * This iterator can extract multiple objects from a complex tree-like object graph.\n * The iteration starts from a single root object.\n * It uses a <code>Transformer</code> to extract the iterators and elements.\n * Its main benefit is that no intermediate <code>List</code> is created.\n * <p>\n * For example, consider an object graph:\n * <pre>\n *                 |- Branch -- Leaf\n *                 |         \\- Leaf\n *         |- Tree |         /- Leaf\n *         |       |- Branch -- Leaf\n *  Forest |                 \\- Leaf\n *         |       |- Branch -- Leaf\n *         |       |         \\- Leaf\n *         |- Tree |         /- Leaf\n *                 |- Branch -- Leaf\n *                 |- Branch -- Leaf</pre>\n * The following <code>Transformer</code>, used in this class, will extract all\n * the Leaf objects without creating a combined intermediate list:\n * <pre>\n * public Object transform(Object input) {\n *   if (input instanceof Forest) {\n *     return ((Forest) input).treeIterator();\n *   }\n *   if (input instanceof Tree) {\n *     return ((Tree) input).branchIterator();\n *   }\n *   if (input instanceof Branch) {\n *     return ((Branch) input).leafIterator();\n *   }\n *   if (input instanceof Leaf) {\n *     return input;\n *   }\n *   throw new ClassCastException();\n * }</pre>\n * <p>\n * Internally, iteration starts from the root object. When next is called,\n * the transformer is called to examine the object. The transformer will return\n * either an iterator or an object. If the object is an Iterator, the next element\n * from that iterator is obtained and the process repeats. If the element is an object\n * it is returned.\n * <p>\n * Under many circumstances, linking Iterators together in this manner is\n * more efficient (and convenient) than using nested for loops to extract a list.\n *\n * @param <E> the element type\n * @param root  the root object to start iterating from, null results in an empty iterator\n * @param transformer  the transformer to use, see above, null uses no effect transformer\n * @return a new object graph iterator\n * @since 3.1\n */\npublic static <E> Iterator<E> objectGraphIterator(final E root, final Transformer<? super E, ? extends E> transformer) {\n    return new ObjectGraphIterator<E>(root, transformer);\n}"
            ],
            [
                "transformedIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Transformed\n//-----------------------------------------------------------------------\n/**\n * Gets an iterator that transforms the elements of another iterator.\n * <p>\n * The transformation occurs during the next() method and the underlying\n * iterator is unaffected by the transformation.\n *\n * @param <I> the input type\n * @param <O> the output type\n * @param iterator  the iterator to use, not null\n * @param transform  the transform to use, not null\n * @return a new transforming iterator\n * @throws NullPointerException if either parameter is null\n */\npublic static <I, O> Iterator<O> transformedIterator(final Iterator<? extends I> iterator, final Transformer<? super I, ? extends O> transform) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (transform == null) {\n        throw new NullPointerException(\"Transformer must not be null\");\n    }\n    return new TransformIterator<I, O>(iterator, transform);\n}"
            ],
            [
                "filteredIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Filtered\n//-----------------------------------------------------------------------\n/**\n * Gets an iterator that filters another iterator.\n * <p>\n * The returned iterator will only return objects that match the specified\n * filtering predicate.\n *\n * @param <E> the element type\n * @param iterator  the iterator to use, not null\n * @param predicate  the predicate to use as a filter, not null\n * @return a new filtered iterator\n * @throws NullPointerException if either parameter is null\n */\npublic static <E> Iterator<E> filteredIterator(final Iterator<? extends E> iterator, final Predicate<? super E> predicate) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    return new FilterIterator<E>(iterator, predicate);\n}"
            ],
            [
                "filteredListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a list iterator that filters another list iterator.\n * <p>\n * The returned iterator will only return objects that match the specified\n * filtering predicate.\n *\n * @param <E> the element type\n * @param listIterator  the list iterator to use, not null\n * @param predicate  the predicate to use as a filter, not null\n * @return a new filtered iterator\n * @throws NullPointerException if either parameter is null\n */\npublic static <E> ListIterator<E> filteredListIterator(final ListIterator<? extends E> listIterator, final Predicate<? super E> predicate) {\n    if (listIterator == null) {\n        throw new NullPointerException(\"ListIterator must not be null\");\n    }\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    return new FilterListIterator<E>(listIterator, predicate);\n}"
            ],
            [
                "loopingIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Looping\n//-----------------------------------------------------------------------\n/**\n * Gets an iterator that loops continuously over the supplied collection.\n * <p>\n * The iterator will only stop looping if the remove method is called\n * enough times to empty the collection, or if the collection is empty\n * to start with.\n *\n * @param <E> the element type\n * @param coll  the collection to iterate over, not null\n * @return a new looping iterator\n * @throws NullPointerException if the collection is null\n */\npublic static <E> ResettableIterator<E> loopingIterator(final Collection<? extends E> coll) {\n    if (coll == null) {\n        throw new NullPointerException(\"Collection must not be null\");\n    }\n    return new LoopingIterator<E>(coll);\n}"
            ],
            [
                "loopingListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator that loops continuously over the supplied list.\n * <p>\n * The iterator will only stop looping if the remove method is called\n * enough times to empty the list, or if the list is empty to start with.\n *\n * @param <E> the element type\n * @param list  the list to iterate over, not null\n * @return a new looping iterator\n * @throws NullPointerException if the list is null\n * @since 3.2\n */\npublic static <E> ResettableListIterator<E> loopingListIterator(final List<E> list) {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    return new LoopingListIterator<E>(list);\n}"
            ],
            [
                "nodeListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// org.w3c.dom.NodeList iterators\n//-----------------------------------------------------------------------\n/**\n * Gets an {@link Iterator} that wraps the specified {@link NodeList}.\n * The returned {@link Iterator} can be used for a single iteration.\n *\n * @param nodeList  the node list to use, may not be null\n * @return a new, single use {@link Iterator}\n * @throws NullPointerException if nodeList is null\n * @since 4.0\n */\npublic static NodeListIterator nodeListIterator(final NodeList nodeList) {\n    if (nodeList == null) {\n        throw new NullPointerException(\"NodeList must not be null\");\n    }\n    return new NodeListIterator(nodeList);\n}"
            ],
            [
                "nodeListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an {@link Iterator} that wraps the specified node's childNodes.\n * The returned {@link Iterator} can be used for a single iteration.\n * <p>\n * Convenience method, allows easy iteration over NodeLists:\n * <pre>\n *   Iterator&lt;Node&gt; iterator = IteratorUtils.nodeListIterator(node);\n *   for(Node childNode : IteratorUtils.asIterable(iterator)) {\n *     ...\n *   }\n * </pre>\n *\n * @param node  the node to use, may not be null\n * @return a new, single use {@link Iterator}\n * @throws NullPointerException if node is null\n * @since 4.0\n */\npublic static NodeListIterator nodeListIterator(final Node node) {\n    if (node == null) {\n        throw new NullPointerException(\"Node must not be null\");\n    }\n    return new NodeListIterator(node);\n}"
            ],
            [
                "peekingIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Peeking\n//-----------------------------------------------------------------------\n/**\n * Gets an iterator that supports one-element lookahead.\n *\n * @param <E> the element type\n * @param iterator  the iterator to decorate, not null\n * @return a peeking iterator\n * @throws NullPointerException if the iterator is null\n * @since 4.0\n */\npublic static <E> Iterator<E> peekingIterator(final Iterator<? extends E> iterator) {\n    return PeekingIterator.peekingIterator(iterator);\n}"
            ],
            [
                "pushbackIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Pushback\n//-----------------------------------------------------------------------\n/**\n * Gets an iterator that supports pushback of elements.\n *\n * @param <E> the element type\n * @param iterator  the iterator to decorate, not null\n * @return a pushback iterator\n * @throws NullPointerException if the iterator is null\n * @since 4.0\n */\npublic static <E> Iterator<E> pushbackIterator(final Iterator<? extends E> iterator) {\n    return PushbackIterator.pushbackIterator(iterator);\n}"
            ],
            [
                "skippingIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Skipping\n//-----------------------------------------------------------------------\n/**\n * Decorates the specified iterator to skip the first N elements.\n *\n * @param <E> the element type\n * @param iterator  the iterator to decorate\n * @param offset  the first number of elements to skip\n * @return a new skipping iterator\n * @throws NullPointerException if the iterator is null\n * @throws IllegalArgumentException if offset is negative\n * @since 4.1\n */\npublic static <E> SkippingIterator<E> skippingIterator(final Iterator<E> iterator, long offset) {\n    return new SkippingIterator<E>(iterator, offset);\n}"
            ],
            [
                "zippingIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Zipping\n//-----------------------------------------------------------------------\n/**\n * Returns an iterator that interleaves elements from the decorated iterators.\n *\n * @param <E> the element type\n * @param a  the first iterator to interleave\n * @param b  the second iterator to interleave\n * @return an iterator, interleaving the decorated iterators\n * @throws NullPointerException if any iterator is null\n * @since 4.1\n */\npublic static <E> ZippingIterator<E> zippingIterator(final Iterator<? extends E> a, final Iterator<? extends E> b) {\n    return new ZippingIterator<E>(a, b);\n}"
            ],
            [
                "zippingIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Returns an iterator that interleaves elements from the decorated iterators.\n *\n * @param <E> the element type\n * @param a  the first iterator to interleave\n * @param b  the second iterator to interleave\n * @param c  the third iterator to interleave\n * @return an iterator, interleaving the decorated iterators\n * @throws NullPointerException if any iterator is null\n * @since 4.1\n */\npublic static <E> ZippingIterator<E> zippingIterator(final Iterator<? extends E> a, final Iterator<? extends E> b, final Iterator<? extends E> c) {\n    return new ZippingIterator<E>(a, b, c);\n}"
            ],
            [
                "zippingIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Returns an iterator that interleaves elements from the decorated iterators.\n *\n * @param <E> the element type\n * @param iterators  the array of iterators to interleave\n * @return an iterator, interleaving the decorated iterators\n * @throws NullPointerException if any iterator is null\n * @since 4.1\n */\npublic static <E> ZippingIterator<E> zippingIterator(final Iterator<? extends E>... iterators) {\n    return new ZippingIterator<E>(iterators);\n}"
            ],
            [
                "asIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Views\n//-----------------------------------------------------------------------\n/**\n * Gets an iterator that provides an iterator view of the given enumeration.\n *\n * @param <E> the element type\n * @param enumeration  the enumeration to use, may not be null\n * @return a new iterator\n * @throws NullPointerException if enumeration is null\n */\npublic static <E> Iterator<E> asIterator(final Enumeration<? extends E> enumeration) {\n    if (enumeration == null) {\n        throw new NullPointerException(\"Enumeration must not be null\");\n    }\n    return new EnumerationIterator<E>(enumeration);\n}"
            ],
            [
                "asIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator that provides an iterator view of the given enumeration\n * that will remove elements from the specified collection.\n *\n * @param <E> the element type\n * @param enumeration  the enumeration to use, may not be null\n * @param removeCollection  the collection to remove elements from, may not be null\n * @return a new iterator\n * @throws NullPointerException if enumeration or removeCollection is null\n */\npublic static <E> Iterator<E> asIterator(final Enumeration<? extends E> enumeration, final Collection<? super E> removeCollection) {\n    if (enumeration == null) {\n        throw new NullPointerException(\"Enumeration must not be null\");\n    }\n    if (removeCollection == null) {\n        throw new NullPointerException(\"Collection must not be null\");\n    }\n    return new EnumerationIterator<E>(enumeration, removeCollection);\n}"
            ],
            [
                "asEnumeration",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an enumeration that wraps an iterator.\n *\n * @param <E> the element type\n * @param iterator  the iterator to use, may not be null\n * @return a new enumeration\n * @throws NullPointerException if iterator is null\n */\npublic static <E> Enumeration<E> asEnumeration(final Iterator<? extends E> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorEnumeration<E>(iterator);\n}"
            ],
            [
                "asIterable",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an {@link Iterable} that wraps an iterator.  The returned {@link Iterable} can be\n * used for a single iteration.\n *\n * @param <E> the element type\n * @param iterator  the iterator to use, may not be null\n * @return a new, single use {@link Iterable}\n * @throws NullPointerException if iterator is null\n */\npublic static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}"
            ],
            [
                "asMultipleUseIterable",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterable that wraps an iterator.  The returned iterable can be\n * used for multiple iterations.\n *\n * @param <E> the element type\n * @param iterator  the iterator to use, may not be null\n * @return a new, multiple use iterable\n * @throws NullPointerException if iterator is null\n */\npublic static <E> Iterable<E> asMultipleUseIterable(final Iterator<? extends E> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, true);\n}"
            ],
            [
                "toListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a list iterator based on a simple iterator.\n * <p>\n * As the wrapped Iterator is traversed, a LinkedList of its values is\n * cached, permitting all required operations of ListIterator.\n *\n * @param <E> the element type\n * @param iterator  the iterator to use, may not be null\n * @return a new iterator\n * @throws NullPointerException if iterator parameter is null\n */\npublic static <E> ListIterator<E> toListIterator(final Iterator<? extends E> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new ListIteratorWrapper<E>(iterator);\n}"
            ],
            [
                "toArray",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an array based on an iterator.\n * <p>\n * As the wrapped Iterator is traversed, an ArrayList of its values is\n * created. At the end, this is converted to an array.\n *\n * @param iterator  the iterator to use, not null\n * @return an array of the iterator contents\n * @throws NullPointerException if iterator parameter is null\n */\npublic static Object[] toArray(final Iterator<?> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    final List<?> list = toList(iterator, 100);\n    return list.toArray();\n}"
            ],
            [
                "toArray",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an array based on an iterator.\n * <p>\n * As the wrapped Iterator is traversed, an ArrayList of its values is\n * created. At the end, this is converted to an array.\n *\n * @param <E> the element type\n * @param iterator  the iterator to use, not null\n * @param arrayClass  the class of array to create\n * @return an array of the iterator contents\n * @throws NullPointerException if iterator parameter or arrayClass is null\n * @throws ArrayStoreException if the arrayClass is invalid\n */\npublic static <E> E[] toArray(final Iterator<? extends E> iterator, final Class<E> arrayClass) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (arrayClass == null) {\n        throw new NullPointerException(\"Array class must not be null\");\n    }\n    final List<E> list = toList(iterator, 100);\n    @SuppressWarnings(\"unchecked\")\n    final E[] array = (E[]) Array.newInstance(arrayClass, list.size());\n    return list.toArray(array);\n}"
            ],
            [
                "toList",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a list based on an iterator.\n * <p>\n * As the wrapped Iterator is traversed, an ArrayList of its values is\n * created. At the end, the list is returned.\n *\n * @param <E> the element type\n * @param iterator  the iterator to use, not null\n * @return a list of the iterator contents\n * @throws NullPointerException if iterator parameter is null\n */\npublic static <E> List<E> toList(final Iterator<? extends E> iterator) {\n    return toList(iterator, 10);\n}"
            ],
            [
                "toList",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a list based on an iterator.\n * <p>\n * As the wrapped Iterator is traversed, an ArrayList of its values is\n * created. At the end, the list is returned.\n *\n * @param <E> the element type\n * @param iterator  the iterator to use, not null\n * @param estimatedSize  the initial size of the ArrayList\n * @return a list of the iterator contents\n * @throws NullPointerException if iterator parameter is null\n * @throws IllegalArgumentException if the size is less than 1\n */\npublic static <E> List<E> toList(final Iterator<? extends E> iterator, final int estimatedSize) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (estimatedSize < 1) {\n        throw new IllegalArgumentException(\"Estimated size must be greater than 0\");\n    }\n    final List<E> list = new ArrayList<E>(estimatedSize);\n    while (iterator.hasNext()) {\n        list.add(iterator.next());\n    }\n    return list;\n}"
            ],
            [
                "getIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a suitable Iterator for the given object.\n * <p>\n * This method can handle objects as follows\n * <ul>\n * <li>null - empty iterator\n * <li>Iterator - returned directly\n * <li>Enumeration - wrapped\n * <li>Collection - iterator from collection returned\n * <li>Map - values iterator returned\n * <li>Dictionary - values (elements) enumeration returned as iterator\n * <li>array - iterator over array returned\n * <li>object with iterator() public method accessed by reflection\n * <li>object - singleton iterator\n * <li>NodeList - iterator over the list\n * <li>Node - iterator over the child nodes\n * </ul>\n *\n * @param obj  the object to convert to an iterator\n * @return a suitable iterator, never null\n */\npublic static Iterator<?> getIterator(final Object obj) {\n    if (obj == null) {\n        return emptyIterator();\n    }\n    if (obj instanceof Iterator) {\n        return (Iterator<?>) obj;\n    }\n    if (obj instanceof Iterable) {\n        return ((Iterable<?>) obj).iterator();\n    }\n    if (obj instanceof Object[]) {\n        return new ObjectArrayIterator<Object>((Object[]) obj);\n    }\n    if (obj instanceof Enumeration) {\n        return new EnumerationIterator<Object>((Enumeration<?>) obj);\n    }\n    if (obj instanceof Map) {\n        return ((Map<?, ?>) obj).values().iterator();\n    }\n    if (obj instanceof NodeList) {\n        return new NodeListIterator((NodeList) obj);\n    }\n    if (obj instanceof Node) {\n        return new NodeListIterator((Node) obj);\n    }\n    if (obj instanceof Dictionary) {\n        return new EnumerationIterator<Object>(((Dictionary<?, ?>) obj).elements());\n    } else if (obj.getClass().isArray()) {\n        return new ArrayIterator<Object>(obj);\n    }\n    try {\n        final Method method = obj.getClass().getMethod(\"iterator\", (Class[]) null);\n        if (Iterator.class.isAssignableFrom(method.getReturnType())) {\n            final Iterator<?> it = (Iterator<?>) method.invoke(obj, (Object[]) null);\n            if (it != null) {\n                return it;\n            }\n        }\n    } catch (final RuntimeException e) {\n        // NOPMD\n        // ignore\n    } catch (final NoSuchMethodException e) {\n        // NOPMD\n        // ignore\n    } catch (final IllegalAccessException e) {\n        // NOPMD\n        // ignore\n    } catch (final InvocationTargetException e) {\n        // NOPMD\n        // ignore\n    }\n    return singletonIterator(obj);\n}"
            ],
            [
                "forEachButLast",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Executes the given closure on each but the last element in the iterator.\n * <p>\n * If the input iterator is null no change is made.\n *\n * @param <E> the type of object the {@link Iterator} contains\n * @param iterator  the iterator to get the input from, may be null\n * @param closure  the closure to perform, may not be null\n * @return the last element in the iterator, or null if iterator is null or empty\n * @throws NullPointerException if closure is null\n * @since 4.1\n */\npublic static <E> E forEachButLast(final Iterator<E> iterator, final Closure<? super E> closure) {\n    if (closure == null) {\n        throw new NullPointerException(\"Closure must not be null.\");\n    }\n    if (iterator != null) {\n        while (iterator.hasNext()) {\n            final E element = iterator.next();\n            if (iterator.hasNext()) {\n                closure.execute(element);\n            } else {\n                return element;\n            }\n        }\n    }\n    return null;\n}"
            ],
            [
                "find",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Finds the first element in the given iterator which matches the given predicate.\n * <p>\n * A <code>null</code> or empty iterator returns null.\n *\n * @param <E> the element type\n * @param iterator  the iterator to search, may be null\n * @param predicate  the predicate to use, may not be null\n * @return the first element of the iterator which matches the predicate or null if none could be found\n * @throws NullPointerException if predicate is null\n * @since 4.1\n */\npublic static <E> E find(final Iterator<E> iterator, final Predicate<? super E> predicate) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    if (iterator != null) {\n        while (iterator.hasNext()) {\n            final E element = iterator.next();\n            if (predicate.evaluate(element)) {\n                return element;\n            }\n        }\n    }\n    return null;\n}"
            ],
            [
                "indexOf",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Returns the index of the first element in the specified iterator that\n * matches the given predicate.\n * <p>\n * A <code>null</code> or empty iterator returns -1.\n *\n * @param <E> the element type\n * @param iterator  the iterator to search, may be null\n * @param predicate  the predicate to use, may not be null\n * @return the index of the first element which matches the predicate or -1 if none matches\n * @throws NullPointerException if predicate is null\n * @since 4.1\n */\npublic static <E> int indexOf(final Iterator<E> iterator, final Predicate<? super E> predicate) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    if (iterator != null) {\n        for (int index = 0; iterator.hasNext(); index++) {\n            final E element = iterator.next();\n            if (predicate.evaluate(element)) {\n                return index;\n            }\n        }\n    }\n    return -1;\n}"
            ],
            [
                "matchesAny",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Answers true if a predicate is true for any element of the iterator.\n * <p>\n * A <code>null</code> or empty iterator returns false.\n *\n * @param <E> the type of object the {@link Iterator} contains\n * @param iterator  the {@link Iterator} to use, may be null\n * @param predicate  the predicate to use, may not be null\n * @return true if any element of the collection matches the predicate, false otherwise\n * @throws NullPointerException if predicate is null\n * @since 4.1\n */\npublic static <E> boolean matchesAny(final Iterator<E> iterator, final Predicate<? super E> predicate) {\n    return indexOf(iterator, predicate) != -1;\n}"
            ],
            [
                "matchesAll",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Answers true if a predicate is true for every element of an iterator.\n * <p>\n * A <code>null</code> or empty iterator returns true.\n *\n * @param <E> the type of object the {@link Iterator} contains\n * @param iterator  the {@link Iterator} to use, may be null\n * @param predicate  the predicate to use, may not be null\n * @return true if every element of the collection matches the predicate or if the\n *   collection is empty, false otherwise\n * @throws NullPointerException if predicate is null\n * @since 4.1\n */\npublic static <E> boolean matchesAll(final Iterator<E> iterator, final Predicate<? super E> predicate) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    if (iterator != null) {\n        while (iterator.hasNext()) {\n            final E element = iterator.next();\n            if (!predicate.evaluate(element)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
            ],
            [
                "isEmpty",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Checks if the given iterator is empty.\n * <p>\n * A <code>null</code> or empty iterator returns true.\n *\n * @param iterator  the {@link Iterator} to use, may be null\n * @return true if the iterator is exhausted or null, false otherwise\n * @since 4.1\n */\npublic static boolean isEmpty(final Iterator<?> iterator) {\n    return iterator == null || !iterator.hasNext();\n}"
            ],
            [
                "contains",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Checks if the object is contained in the given iterator.\n * <p>\n * A <code>null</code> or empty iterator returns false.\n *\n * @param <E> the type of object the {@link Iterator} contains\n * @param iterator  the iterator to check, may be null\n * @param object  the object to check\n * @return true if the object is contained in the iterator, false otherwise\n * @since 4.1\n */\npublic static <E> boolean contains(final Iterator<E> iterator, final Object object) {\n    return matchesAny(iterator, EqualPredicate.equalPredicate(object));\n}"
            ],
            [
                "get",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Returns the <code>index</code>-th value in {@link Iterator}, throwing\n * <code>IndexOutOfBoundsException</code> if there is no such element.\n * <p>\n * The Iterator is advanced to <code>index</code> (or to the end, if\n * <code>index</code> exceeds the number of entries) as a side effect of this method.\n *\n * @param <E> the type of object in the {@link Iterator}\n * @param iterator  the iterator to get a value from\n * @param index  the index to get\n * @return the object at the specified index\n * @throws IndexOutOfBoundsException if the index is invalid\n * @since 4.1\n */\npublic static <E> E get(final Iterator<E> iterator, final int index) {\n    int i = index;\n    CollectionUtils.checkIndexBounds(i);\n    while (iterator.hasNext()) {\n        i--;\n        if (i == -1) {\n            return iterator.next();\n        }\n        iterator.next();\n    }\n    throw new IndexOutOfBoundsException(\"Entry does not exist: \" + i);\n}"
            ],
            [
                "size",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Returns the number of elements contained in the given iterator.\n * <p>\n * A <code>null</code> or empty iterator returns {@code 0}.\n *\n * @param iterator  the iterator to check, may be null\n * @return the number of elements contained in the iterator\n * @since 4.1\n */\npublic static int size(final Iterator<?> iterator) {\n    int size = 0;\n    if (iterator != null) {\n        while (iterator.hasNext()) {\n            iterator.next();\n            size++;\n        }\n    }\n    return size;\n}"
            ],
            [
                "toString",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Returns a string representation of the elements of the specified iterator.\n * <p>\n * The string representation consists of a list of the iterator's elements,\n * enclosed in square brackets ({@code \"[]\"}). Adjacent elements are separated\n * by the characters {@code \", \"} (a comma followed by a space). Elements are\n * converted to strings as by {@code String.valueOf(Object)}.\n *\n * @param <E> the element type\n * @param iterator  the iterator to convert to a string, may be null\n * @return a string representation of {@code iterator}\n * @since 4.1\n */\npublic static <E> String toString(final Iterator<E> iterator) {\n    return toString(iterator, TransformerUtils.stringValueTransformer(), DEFAULT_TOSTRING_DELIMITER, DEFAULT_TOSTRING_PREFIX, DEFAULT_TOSTRING_SUFFIX);\n}"
            ],
            [
                "toString",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Returns a string representation of the elements of the specified iterator.\n * <p>\n * The string representation consists of a list of the iterable's elements,\n * enclosed in square brackets ({@code \"[]\"}). Adjacent elements are separated\n * by the characters {@code \", \"} (a comma followed by a space). Elements are\n * converted to strings as by using the provided {@code transformer}.\n *\n * @param <E> the element type\n * @param iterator  the iterator to convert to a string, may be null\n * @param transformer  the transformer used to get a string representation of an element\n * @return a string representation of {@code iterator}\n * @throws NullPointerException if {@code transformer} is null\n * @since 4.1\n */\npublic static <E> String toString(final Iterator<E> iterator, final Transformer<? super E, String> transformer) {\n    return toString(iterator, transformer, DEFAULT_TOSTRING_DELIMITER, DEFAULT_TOSTRING_PREFIX, DEFAULT_TOSTRING_SUFFIX);\n}"
            ],
            [
                "toString",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Returns a string representation of the elements of the specified iterator.\n * <p>\n * The string representation consists of a list of the iterator's elements,\n * enclosed by the provided {@code prefix} and {@code suffix}. Adjacent elements\n * are separated by the provided {@code delimiter}. Elements are converted to\n * strings as by using the provided {@code transformer}.\n *\n * @param <E> the element type\n * @param iterator  the iterator to convert to a string, may be null\n * @param transformer  the transformer used to get a string representation of an element\n * @param delimiter  the string to delimit elements\n * @param prefix  the prefix, prepended to the string representation\n * @param suffix  the suffix, appended to the string representation\n * @return a string representation of {@code iterator}\n * @throws NullPointerException if either transformer, delimiter, prefix or suffix is null\n * @since 4.1\n */\npublic static <E> String toString(final Iterator<E> iterator, final Transformer<? super E, String> transformer, final String delimiter, final String prefix, final String suffix) {\n    if (transformer == null) {\n        throw new NullPointerException(\"transformer may not be null\");\n    }\n    if (delimiter == null) {\n        throw new NullPointerException(\"delimiter may not be null\");\n    }\n    if (prefix == null) {\n        throw new NullPointerException(\"prefix may not be null\");\n    }\n    if (suffix == null) {\n        throw new NullPointerException(\"suffix may not be null\");\n    }\n    final StringBuilder stringBuilder = new StringBuilder(prefix);\n    if (iterator != null) {\n        while (iterator.hasNext()) {\n            final E element = iterator.next();\n            stringBuilder.append(transformer.transform(element));\n            stringBuilder.append(delimiter);\n        }\n        if (stringBuilder.length() > prefix.length()) {\n            stringBuilder.setLength(stringBuilder.length() - delimiter.length());\n        }\n    }\n    stringBuilder.append(suffix);\n    return stringBuilder.toString();\n}"
            ],
            [
                "naturalComparator",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Gets a comparator that uses the natural order of the objects.\n *\n * @param <E>  the object type to compare\n * @return  a comparator which uses natural order\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E extends Comparable<? super E>> Comparator<E> naturalComparator() {\n    return NATURAL_COMPARATOR;\n}"
            ],
            [
                "chainedComparator",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Gets a comparator that compares using an array of {@link Comparator}s, applied\n * in sequence until one returns not equal or the array is exhausted.\n *\n * @param <E>  the object type to compare\n * @param comparators  the comparators to use, not null or empty or containing nulls\n * @return a {@link ComparatorChain} formed from the input comparators\n * @throws NullPointerException if comparators array is null or contains a null\n * @see ComparatorChain\n */\npublic static <E> Comparator<E> chainedComparator(final Comparator<E>... comparators) {\n    final ComparatorChain<E> chain = new ComparatorChain<E>();\n    for (final Comparator<E> comparator : comparators) {\n        if (comparator == null) {\n            throw new NullPointerException(\"Comparator cannot be null\");\n        }\n        chain.addComparator(comparator);\n    }\n    return chain;\n}"
            ],
            [
                "chainedComparator",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Gets a comparator that compares using a collection of {@link Comparator}s,\n * applied in (default iterator) sequence until one returns not equal or the\n * collection is exhausted.\n *\n * @param <E>  the object type to compare\n * @param comparators  the comparators to use, not null or empty or containing nulls\n * @return a {@link ComparatorChain} formed from the input comparators\n * @throws NullPointerException if comparators collection is null or contains a null\n * @throws ClassCastException if the comparators collection contains the wrong object type\n * @see ComparatorChain\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Comparator<E> chainedComparator(final Collection<Comparator<E>> comparators) {\n    return chainedComparator((Comparator<E>[]) comparators.toArray(new Comparator[comparators.size()]));\n}"
            ],
            [
                "reversedComparator",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Gets a comparator that reverses the order of the given comparator.\n *\n * @param <E>  the object type to compare\n * @param comparator  the comparator to reverse\n * @return  a comparator that reverses the order of the input comparator\n * @see ReverseComparator\n */\npublic static <E> Comparator<E> reversedComparator(final Comparator<E> comparator) {\n    return new ReverseComparator<E>(comparator);\n}"
            ],
            [
                "booleanComparator",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Gets a Comparator that can sort Boolean objects.\n * <p>\n * The parameter specifies whether true or false is sorted first.\n * <p>\n * The comparator throws NullPointerException if a null value is compared.\n *\n * @param trueFirst  when <code>true</code>, sort\n *        <code>true</code> {@link Boolean}s before\n *        <code>false</code> {@link Boolean}s.\n * @return  a comparator that sorts booleans\n */\npublic static Comparator<Boolean> booleanComparator(final boolean trueFirst) {\n    return BooleanComparator.booleanComparator(trueFirst);\n}"
            ],
            [
                "nullLowComparator",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Gets a Comparator that controls the comparison of <code>null</code> values.\n * <p>\n * The returned comparator will consider a null value to be less than\n * any nonnull value, and equal to any other null value.  Two nonnull\n * values will be evaluated with the given comparator.\n *\n * @param <E>  the object type to compare\n * @param comparator the comparator that wants to allow nulls\n * @return  a version of that comparator that allows nulls\n * @see NullComparator\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Comparator<E> nullLowComparator(Comparator<E> comparator) {\n    if (comparator == null) {\n        comparator = NATURAL_COMPARATOR;\n    }\n    return new NullComparator<E>(comparator, false);\n}"
            ],
            [
                "nullHighComparator",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Gets a Comparator that controls the comparison of <code>null</code> values.\n * <p>\n * The returned comparator will consider a null value to be greater than\n * any nonnull value, and equal to any other null value.  Two nonnull\n * values will be evaluated with the given comparator.\n *\n * @param <E>  the object type to compare\n * @param comparator the comparator that wants to allow nulls\n * @return  a version of that comparator that allows nulls\n * @see NullComparator\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Comparator<E> nullHighComparator(Comparator<E> comparator) {\n    if (comparator == null) {\n        comparator = NATURAL_COMPARATOR;\n    }\n    return new NullComparator<E>(comparator, true);\n}"
            ],
            [
                "transformedComparator",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Gets a Comparator that passes transformed objects to the given comparator.\n * <p>\n * Objects passed to the returned comparator will first be transformed\n * by the given transformer before they are compared by the given\n * comparator.\n *\n * @param <I>  the input object type of the transformed comparator\n * @param <O>  the object type of the decorated comparator\n * @param comparator  the sort order to use\n * @param transformer  the transformer to use\n * @return  a comparator that transforms its input objects before comparing them\n * @see  TransformingComparator\n */\n@SuppressWarnings(\"unchecked\")\npublic static <I, O> Comparator<I> transformedComparator(Comparator<O> comparator, final Transformer<? super I, ? extends O> transformer) {\n    if (comparator == null) {\n        comparator = NATURAL_COMPARATOR;\n    }\n    return new TransformingComparator<I, O>(transformer, comparator);\n}"
            ],
            [
                "min",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Returns the smaller of the given objects according to the given\n * comparator, returning the second object if the comparator\n * returns equal.\n *\n * @param <E>  the object type to compare\n * @param o1  the first object to compare\n * @param o2  the second object to compare\n * @param comparator  the sort order to use\n * @return  the smaller of the two objects\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> E min(final E o1, final E o2, Comparator<E> comparator) {\n    if (comparator == null) {\n        comparator = NATURAL_COMPARATOR;\n    }\n    final int c = comparator.compare(o1, o2);\n    return c < 0 ? o1 : o2;\n}"
            ],
            [
                "max",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Returns the larger of the given objects according to the given\n * comparator, returning the second object if the comparator\n * returns equal.\n *\n * @param <E>  the object type to compare\n * @param o1  the first object to compare\n * @param o2  the second object to compare\n * @param comparator  the sort order to use\n * @return  the larger of the two objects\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> E max(final E o1, final E o2, Comparator<E> comparator) {\n    if (comparator == null) {\n        comparator = NATURAL_COMPARATOR;\n    }\n    final int c = comparator.compare(o1, o2);\n    return c > 0 ? o1 : o2;\n}"
            ],
            [
                "unmodifiableBidiMap",
                "org.apache.commons.collections4.bidimap",
                "UnmodifiableBidiMap",
                "/**\n * Factory method to create an unmodifiable map.\n * <p>\n * If the map passed in is already unmodifiable, it is returned.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the map to decorate, must not be null\n * @return an unmodifiable BidiMap\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> BidiMap<K, V> unmodifiableBidiMap(final BidiMap<? extends K, ? extends V> map) {\n    if (map instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final BidiMap<K, V> tmpMap = (BidiMap<K, V>) map;\n        return tmpMap;\n    }\n    return new UnmodifiableBidiMap<K, V>(map);\n}"
            ],
            [
                "unmodifiableOrderedBidiMap",
                "org.apache.commons.collections4.bidimap",
                "UnmodifiableOrderedBidiMap",
                "/**\n * Factory method to create an unmodifiable map.\n * <p>\n * If the map passed in is already unmodifiable, it is returned.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the map to decorate, must not be null\n * @return an unmodifiable OrderedBidiMap\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> OrderedBidiMap<K, V> unmodifiableOrderedBidiMap(final OrderedBidiMap<? extends K, ? extends V> map) {\n    if (map instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final OrderedBidiMap<K, V> tmpMap = (OrderedBidiMap<K, V>) map;\n        return tmpMap;\n    }\n    return new UnmodifiableOrderedBidiMap<K, V>(map);\n}"
            ],
            [
                "unmodifiableSortedBidiMap",
                "org.apache.commons.collections4.bidimap",
                "UnmodifiableSortedBidiMap",
                "/**\n * Factory method to create an unmodifiable map.\n * <p>\n * If the map passed in is already unmodifiable, it is returned.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the map to decorate, must not be null\n * @return an unmodifiable SortedBidiMap\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> SortedBidiMap<K, V> unmodifiableSortedBidiMap(final SortedBidiMap<K, ? extends V> map) {\n    if (map instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final SortedBidiMap<K, V> tmpMap = (SortedBidiMap<K, V>) map;\n        return tmpMap;\n    }\n    return new UnmodifiableSortedBidiMap<K, V>(map);\n}"
            ],
            [
                "emptyMultiValuedMap",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "/**\n * Returns immutable EMPTY_MULTI_VALUED_MAP with generic type safety.\n *\n * @param <K> the type of key in the map\n * @param <V> the type of value in the map\n * @return immutable and empty <code>MultiValuedMap</code>\n */\n@SuppressWarnings(\"unchecked\")\npublic static <K, V> MultiValuedMap<K, V> emptyMultiValuedMap() {\n    return EMPTY_MULTI_VALUED_MAP;\n}"
            ],
            [
                "emptyIfNull",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "// Null safe methods\n/**\n * Returns an immutable empty <code>MultiValuedMap</code> if the argument is\n * <code>null</code>, or the argument itself otherwise.\n *\n * @param <K> the type of key in the map\n * @param <V> the type of value in the map\n * @param map  the map, may be null\n * @return an empty {@link MultiValuedMap} if the argument is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <K, V> MultiValuedMap<K, V> emptyIfNull(final MultiValuedMap<K, V> map) {\n    return map == null ? EMPTY_MULTI_VALUED_MAP : map;\n}"
            ],
            [
                "isEmpty",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "/**\n * Null-safe check if the specified <code>MultiValuedMap</code> is empty.\n * <p>\n * If the provided map is null, returns true.\n *\n * @param map  the map to check, may be null\n * @return true if the map is empty or null\n */\npublic static boolean isEmpty(final MultiValuedMap<?, ?> map) {\n    return map == null || map.isEmpty();\n}"
            ],
            [
                "getCollection",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "// Null safe getters\n// -------------------------------------------------------------------------\n/**\n * Gets a Collection from <code>MultiValuedMap</code> in a null-safe manner.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the {@link MultiValuedMap} to use\n * @param key  the key to look up\n * @return the Collection in the {@link MultiValuedMap}, or null if input map is null\n */\npublic static <K, V> Collection<V> getCollection(final MultiValuedMap<K, V> map, final K key) {\n    if (map != null) {\n        return map.get(key);\n    }\n    return null;\n}"
            ],
            [
                "getValuesAsList",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "// TODO: review the getValuesAsXXX methods - depending on the actual MultiValuedMap type, changes\n// to the returned collection might update the backing map. This should be clarified and/or prevented.\n/**\n * Gets a List from <code>MultiValuedMap</code> in a null-safe manner.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the {@link MultiValuedMap} to use\n * @param key  the key to look up\n * @return the Collection in the {@link MultiValuedMap} as List, or null if input map is null\n */\npublic static <K, V> List<V> getValuesAsList(final MultiValuedMap<K, V> map, final K key) {\n    if (map != null) {\n        Collection<V> col = map.get(key);\n        if (col instanceof List) {\n            return (List<V>) col;\n        }\n        return new ArrayList<V>(col);\n    }\n    return null;\n}"
            ],
            [
                "getValuesAsSet",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "/**\n * Gets a Set from <code>MultiValuedMap</code> in a null-safe manner.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the {@link MultiValuedMap} to use\n * @param key  the key to look up\n * @return the Collection in the {@link MultiValuedMap} as Set, or null if input map is null\n */\npublic static <K, V> Set<V> getValuesAsSet(final MultiValuedMap<K, V> map, final K key) {\n    if (map != null) {\n        Collection<V> col = map.get(key);\n        if (col instanceof Set) {\n            return (Set<V>) col;\n        }\n        return new HashSet<V>(col);\n    }\n    return null;\n}"
            ],
            [
                "getValuesAsBag",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "/**\n * Gets a Bag from <code>MultiValuedMap</code> in a null-safe manner.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the {@link MultiValuedMap} to use\n * @param key  the key to look up\n * @return the Collection in the {@link MultiValuedMap} as Bag, or null if input map is null\n */\npublic static <K, V> Bag<V> getValuesAsBag(final MultiValuedMap<K, V> map, final K key) {\n    if (map != null) {\n        Collection<V> col = map.get(key);\n        if (col instanceof Bag) {\n            return (Bag<V>) col;\n        }\n        return new HashBag<V>(col);\n    }\n    return null;\n}"
            ],
            [
                "newListValuedHashMap",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "// Factory Methods\n// -----------------------------------------------------------------------\n/**\n * Creates a {@link ListValuedMap} with an {@link java.util.ArrayList ArrayList} as\n * collection class to store the values mapped to a key.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @return a new <code>ListValuedMap</code>\n */\npublic static <K, V> ListValuedMap<K, V> newListValuedHashMap() {\n    return new ArrayListValuedHashMap<K, V>();\n}"
            ],
            [
                "newSetValuedHashMap",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "/**\n * Creates a {@link SetValuedMap} with an {@link java.util.HashSet HashSet} as\n * collection class to store the values mapped to a key.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @return a new {@link SetValuedMap}\n */\npublic static <K, V> SetValuedMap<K, V> newSetValuedHashMap() {\n    return new HashSetValuedHashMap<K, V>();\n}"
            ],
            [
                "unmodifiableMultiValuedMap",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "// MultiValuedMap Decorators\n// -----------------------------------------------------------------------\n/**\n * Returns an <code>UnmodifiableMultiValuedMap</code> backed by the given\n * map.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the {@link MultiValuedMap} to decorate, must not be null\n * @return an unmodifiable {@link MultiValuedMap} backed by the provided map\n * @throws NullPointerException if map is null\n */\npublic static <K, V> MultiValuedMap<K, V> unmodifiableMultiValuedMap(final MultiValuedMap<? extends K, ? extends V> map) {\n    return UnmodifiableMultiValuedMap.<K, V>unmodifiableMultiValuedMap(map);\n}"
            ],
            [
                "transformedMultiValuedMap",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "/**\n * Returns a <code>TransformedMultiValuedMap</code> backed by the given map.\n * <p>\n * This method returns a new <code>MultiValuedMap</code> (decorating the\n * specified map) that will transform any new entries added to it. Existing\n * entries in the specified map will not be transformed. If you want that\n * behaviour, see {@link TransformedMultiValuedMap#transformedMap}.\n * <p>\n * Each object is passed through the transformers as it is added to the Map.\n * It is important not to use the original map after invoking this method,\n * as it is a back door for adding untransformed objects.\n * <p>\n * If there are any elements already in the map being decorated, they are\n * NOT transformed.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the {@link MultiValuedMap} to transform, must not be null, typically empty\n * @param keyTransformer  the transformer for the map keys, null means no transformation\n * @param valueTransformer  the transformer for the map values, null means no transformation\n * @return a transformed <code>MultiValuedMap</code> backed by the given map\n * @throws NullPointerException if map is null\n */\npublic static <K, V> MultiValuedMap<K, V> transformedMultiValuedMap(final MultiValuedMap<K, V> map, final Transformer<? super K, ? extends K> keyTransformer, final Transformer<? super V, ? extends V> valueTransformer) {\n    return TransformedMultiValuedMap.transformingMap(map, keyTransformer, valueTransformer);\n}"
            ],
            [
                "unmodifiableBoundedCollection",
                "org.apache.commons.collections4.collection",
                "UnmodifiableBoundedCollection",
                "/**\n * Factory method to create an unmodifiable bounded collection.\n *\n * @param <E> the type of the elements in the collection\n * @param coll  the <code>BoundedCollection</code> to decorate, must not be null\n * @return a new unmodifiable bounded collection\n * @throws NullPointerException if {@code coll} is {@code null}\n * @since 4.0\n */\npublic static <E> BoundedCollection<E> unmodifiableBoundedCollection(final BoundedCollection<? extends E> coll) {\n    if (coll instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final BoundedCollection<E> tmpColl = (BoundedCollection<E>) coll;\n        return tmpColl;\n    }\n    return new UnmodifiableBoundedCollection<E>(coll);\n}"
            ],
            [
                "unmodifiableBoundedCollection",
                "org.apache.commons.collections4.collection",
                "UnmodifiableBoundedCollection",
                "/**\n * Factory method to create an unmodifiable bounded collection.\n * <p>\n * This method is capable of drilling down through up to 1000 other decorators\n * to find a suitable BoundedCollection.\n *\n * @param <E> the type of the elements in the collection\n * @param coll  the <code>BoundedCollection</code> to decorate, must not be null\n * @return a new unmodifiable bounded collection\n * @throws NullPointerException if coll is null\n * @throws IllegalArgumentException if coll is not a {@code BoundedCollection}\n * @since 4.0\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> BoundedCollection<E> unmodifiableBoundedCollection(Collection<? extends E> coll) {\n    if (coll == null) {\n        throw new NullPointerException(\"Collection must not be null.\");\n    }\n    // handle decorators\n    for (int i = 0; i < 1000; i++) {\n        // counter to prevent infinite looping\n        if (coll instanceof BoundedCollection) {\n            // normal loop exit\n            break;\n        }\n        if (coll instanceof AbstractCollectionDecorator) {\n            coll = ((AbstractCollectionDecorator<E>) coll).decorated();\n        } else if (coll instanceof SynchronizedCollection) {\n            coll = ((SynchronizedCollection<E>) coll).decorated();\n        }\n    }\n    if (coll instanceof BoundedCollection == false) {\n        throw new IllegalArgumentException(\"Collection is not a bounded collection.\");\n    }\n    return new UnmodifiableBoundedCollection<E>((BoundedCollection<E>) coll);\n}"
            ],
            [
                "transformingCollection",
                "org.apache.commons.collections4.collection",
                "TransformedCollection",
                "/**\n * Factory method to create a transforming collection.\n * <p>\n * If there are any elements already in the collection being decorated, they\n * are NOT transformed.\n * Contrast this with {@link #transformedCollection(Collection, Transformer)}.\n *\n * @param <E> the type of the elements in the collection\n * @param coll  the collection to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed collection\n * @throws NullPointerException if collection or transformer is null\n * @since 4.0\n */\npublic static <E> TransformedCollection<E> transformingCollection(final Collection<E> coll, final Transformer<? super E, ? extends E> transformer) {\n    return new TransformedCollection<E>(coll, transformer);\n}"
            ],
            [
                "transformedCollection",
                "org.apache.commons.collections4.collection",
                "TransformedCollection",
                "/**\n * Factory method to create a transforming collection that will transform\n * existing contents of the specified collection.\n * <p>\n * If there are any elements already in the collection being decorated, they\n * will be transformed by this method.\n * Contrast this with {@link #transformingCollection(Collection, Transformer)}.\n *\n * @param <E> the type of the elements in the collection\n * @param collection  the collection to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed Collection\n * @throws NullPointerException if collection or transformer is null\n * @since 4.0\n */\npublic static <E> TransformedCollection<E> transformedCollection(final Collection<E> collection, final Transformer<? super E, ? extends E> transformer) {\n    final TransformedCollection<E> decorated = new TransformedCollection<E>(collection, transformer);\n    // null collection & transformer are disallowed by the constructor call above\n    if (collection.size() > 0) {\n        // collection is of type E\n        @SuppressWarnings(\"unchecked\")\n        final E[] // NOPMD - false positive for generics\n        values = (E[]) collection.toArray();\n        collection.clear();\n        for (final E value : values) {\n            decorated.decorated().add(transformer.transform(value));\n        }\n    }\n    return decorated;\n}"
            ],
            [
                "builder",
                "org.apache.commons.collections4.collection",
                "PredicatedCollection",
                "/**\n * Returns a Builder with the given predicate.\n *\n * @param <E>  the element type\n * @param predicate  the predicate to use\n * @return a new Builder for predicated collections\n * @since 4.1\n */\npublic static <E> Builder<E> builder(final Predicate<? super E> predicate) {\n    return new Builder<E>(predicate);\n}"
            ],
            [
                "notNullBuilder",
                "org.apache.commons.collections4.collection",
                "PredicatedCollection",
                "/**\n * Returns a Builder with a NotNullPredicate.\n *\n * @param <E>  the element type\n * @return a new Builder for predicated collections that ignores null values.\n * @since 4.1\n */\npublic static <E> Builder<E> notNullBuilder() {\n    return new Builder<E>(NotNullPredicate.<E>notNullPredicate());\n}"
            ],
            [
                "predicatedCollection",
                "org.apache.commons.collections4.collection",
                "PredicatedCollection",
                "/**\n * Factory method to create a predicated (validating) collection.\n * <p>\n * If there are any elements already in the collection being decorated, they\n * are validated.\n *\n * @param <T> the type of the elements in the collection\n * @param coll  the collection to decorate, must not be null\n * @param predicate  the predicate to use for validation, must not be null\n * @return a new predicated collection\n * @throws NullPointerException if collection or predicate is null\n * @throws IllegalArgumentException if the collection contains invalid elements\n * @since 4.0\n */\npublic static <T> PredicatedCollection<T> predicatedCollection(final Collection<T> coll, final Predicate<? super T> predicate) {\n    return new PredicatedCollection<T>(coll, predicate);\n}"
            ],
            [
                "uniqueIndexedCollection",
                "org.apache.commons.collections4.collection",
                "IndexedCollection",
                "/**\n * Create an {@link IndexedCollection} for a unique index.\n * <p>\n * If an element is added, which maps to an existing key, an {@link IllegalArgumentException}\n * will be thrown.\n *\n * @param <K> the index object type.\n * @param <C> the collection type.\n * @param coll the decorated {@link Collection}.\n * @param keyTransformer the {@link Transformer} for generating index keys.\n * @return the created {@link IndexedCollection}.\n */\npublic static <K, C> IndexedCollection<K, C> uniqueIndexedCollection(final Collection<C> coll, final Transformer<C, K> keyTransformer) {\n    return new IndexedCollection<K, C>(coll, keyTransformer, MultiValueMap.<K, C>multiValueMap(new HashMap<K, Collection<C>>()), true);\n}"
            ],
            [
                "nonUniqueIndexedCollection",
                "org.apache.commons.collections4.collection",
                "IndexedCollection",
                "/**\n * Create an {@link IndexedCollection} for a non-unique index.\n *\n * @param <K> the index object type.\n * @param <C> the collection type.\n * @param coll the decorated {@link Collection}.\n * @param keyTransformer the {@link Transformer} for generating index keys.\n * @return the created {@link IndexedCollection}.\n */\npublic static <K, C> IndexedCollection<K, C> nonUniqueIndexedCollection(final Collection<C> coll, final Transformer<C, K> keyTransformer) {\n    return new IndexedCollection<K, C>(coll, keyTransformer, MultiValueMap.<K, C>multiValueMap(new HashMap<K, Collection<C>>()), false);\n}"
            ],
            [
                "synchronizedCollection",
                "org.apache.commons.collections4.collection",
                "SynchronizedCollection",
                "/**\n * Factory method to create a synchronized collection.\n *\n * @param <T> the type of the elements in the collection\n * @param coll  the collection to decorate, must not be null\n * @return a new synchronized collection\n * @throws NullPointerException if collection is null\n * @since 4.0\n */\npublic static <T> SynchronizedCollection<T> synchronizedCollection(final Collection<T> coll) {\n    return new SynchronizedCollection<T>(coll);\n}"
            ],
            [
                "unmodifiableCollection",
                "org.apache.commons.collections4.collection",
                "UnmodifiableCollection",
                "/**\n * Factory method to create an unmodifiable collection.\n * <p>\n * If the collection passed in is already unmodifiable, it is returned.\n *\n * @param <T> the type of the elements in the collection\n * @param coll  the collection to decorate, must not be null\n * @return an unmodifiable collection\n * @throws NullPointerException if collection is null\n * @since 4.0\n */\npublic static <T> Collection<T> unmodifiableCollection(final Collection<? extends T> coll) {\n    if (coll instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final Collection<T> tmpColl = (Collection<T>) coll;\n        return tmpColl;\n    }\n    return new UnmodifiableCollection<T>(coll);\n}"
            ],
            [
                "exceptionFactory",
                "org.apache.commons.collections4",
                "FactoryUtils",
                "/**\n * Gets a Factory that always throws an exception.\n * This could be useful during testing as a placeholder.\n *\n * @see org.apache.commons.collections4.functors.ExceptionFactory\n *\n * @param <T> the type that the factory creates\n * @return the factory\n */\npublic static <T> Factory<T> exceptionFactory() {\n    return ExceptionFactory.<T>exceptionFactory();\n}"
            ],
            [
                "nullFactory",
                "org.apache.commons.collections4",
                "FactoryUtils",
                "/**\n * Gets a Factory that will return null each time the factory is used.\n * This could be useful during testing as a placeholder.\n *\n * @see org.apache.commons.collections4.functors.ConstantFactory\n * @param <T> the \"type\" of null object the factory should return.\n * @return the factory\n */\npublic static <T> Factory<T> nullFactory() {\n    return ConstantFactory.<T>constantFactory(null);\n}"
            ],
            [
                "constantFactory",
                "org.apache.commons.collections4",
                "FactoryUtils",
                "/**\n * Creates a Factory that will return the same object each time the factory\n * is used. No check is made that the object is immutable. In general, only\n * immutable objects should use the constant factory. Mutable objects should\n * use the prototype factory.\n *\n * @see org.apache.commons.collections4.functors.ConstantFactory\n *\n * @param <T> the type that the factory creates\n * @param constantToReturn  the constant object to return each time in the factory\n * @return the <code>constant</code> factory.\n */\npublic static <T> Factory<T> constantFactory(final T constantToReturn) {\n    return ConstantFactory.constantFactory(constantToReturn);\n}"
            ],
            [
                "prototypeFactory",
                "org.apache.commons.collections4",
                "FactoryUtils",
                "/**\n * Creates a Factory that will return a clone of the same prototype object\n * each time the factory is used. The prototype will be cloned using one of these\n * techniques (in order):\n * <ul>\n * <li>public clone method\n * <li>public copy constructor\n * <li>serialization clone\n * <ul>\n *\n * @see org.apache.commons.collections4.functors.PrototypeFactory\n *\n * @param <T> the type that the factory creates\n * @param prototype  the object to clone each time in the factory\n * @return the <code>prototype</code> factory, or a {@link ConstantFactory#NULL_INSTANCE} if\n * the {@code prototype} is {@code null}\n * @throws IllegalArgumentException if the prototype cannot be cloned\n */\npublic static <T> Factory<T> prototypeFactory(final T prototype) {\n    return PrototypeFactory.<T>prototypeFactory(prototype);\n}"
            ],
            [
                "instantiateFactory",
                "org.apache.commons.collections4",
                "FactoryUtils",
                "/**\n * Creates a Factory that can create objects of a specific type using\n * a no-args constructor.\n *\n * @see org.apache.commons.collections4.functors.InstantiateFactory\n *\n * @param <T> the type that the factory creates\n * @param classToInstantiate  the Class to instantiate each time in the factory\n * @return the <code>reflection</code> factory\n * @throws NullPointerException if the classToInstantiate is null\n */\npublic static <T> Factory<T> instantiateFactory(final Class<T> classToInstantiate) {\n    return InstantiateFactory.instantiateFactory(classToInstantiate, null, null);\n}"
            ],
            [
                "instantiateFactory",
                "org.apache.commons.collections4",
                "FactoryUtils",
                "/**\n * Creates a Factory that can create objects of a specific type using\n * the arguments specified to this method.\n *\n * @see org.apache.commons.collections4.functors.InstantiateFactory\n *\n * @param <T> the type that the factory creates\n * @param classToInstantiate  the Class to instantiate each time in the factory\n * @param paramTypes  parameter types for the constructor, can be null\n * @param args  the arguments to pass to the constructor, can be null\n * @return the <code>reflection</code> factory\n * @throws NullPointerException if the classToInstantiate is null\n * @throws IllegalArgumentException if the paramTypes and args don't match\n * @throws IllegalArgumentException if the constructor doesn't exist\n */\npublic static <T> Factory<T> instantiateFactory(final Class<T> classToInstantiate, final Class<?>[] paramTypes, final Object[] args) {\n    return InstantiateFactory.instantiateFactory(classToInstantiate, paramTypes, args);\n}"
            ],
            [
                "emptyIfNull",
                "org.apache.commons.collections4",
                "ListUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns an immutable empty list if the argument is <code>null</code>,\n * or the argument itself otherwise.\n *\n * @param <T> the element type\n * @param list the list, possibly <code>null</code>\n * @return an empty list if the argument is <code>null</code>\n */\npublic static <T> List<T> emptyIfNull(final List<T> list) {\n    return list == null ? Collections.<T>emptyList() : list;\n}"
            ],
            [
                "defaultIfNull",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns either the passed in list, or if the list is {@code null},\n * the value of {@code defaultList}.\n *\n * @param <T> the element type\n * @param list  the list, possibly {@code null}\n * @param defaultList  the returned values if list is {@code null}\n * @return an empty list if the argument is <code>null</code>\n * @since 4.0\n */\npublic static <T> List<T> defaultIfNull(final List<T> list, final List<T> defaultList) {\n    return list == null ? defaultList : list;\n}"
            ],
            [
                "intersection",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns a new list containing all elements that are contained in\n * both given lists.\n *\n * @param <E> the element type\n * @param list1  the first list\n * @param list2  the second list\n * @return  the intersection of those two lists\n * @throws NullPointerException if either list is null\n */\npublic static <E> List<E> intersection(final List<? extends E> list1, final List<? extends E> list2) {\n    final List<E> result = new ArrayList<E>();\n    List<? extends E> smaller = list1;\n    List<? extends E> larger = list2;\n    if (list1.size() > list2.size()) {\n        smaller = list2;\n        larger = list1;\n    }\n    final HashSet<E> hashSet = new HashSet<E>(smaller);\n    for (final E e : larger) {\n        if (hashSet.contains(e)) {\n            result.add(e);\n            hashSet.remove(e);\n        }\n    }\n    return result;\n}"
            ],
            [
                "subtract",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Subtracts all elements in the second list from the first list,\n * placing the results in a new list.\n * <p>\n * This differs from {@link List#removeAll(Collection)} in that\n * cardinality is respected; if <Code>list1</Code> contains two\n * occurrences of <Code>null</Code> and <Code>list2</Code> only\n * contains one occurrence, then the returned list will still contain\n * one occurrence.\n *\n * @param <E> the element type\n * @param list1  the list to subtract from\n * @param list2  the list to subtract\n * @return a new list containing the results\n * @throws NullPointerException if either list is null\n */\npublic static <E> List<E> subtract(final List<E> list1, final List<? extends E> list2) {\n    final ArrayList<E> result = new ArrayList<E>();\n    final HashBag<E> bag = new HashBag<E>(list2);\n    for (final E e : list1) {\n        if (!bag.remove(e, 1)) {\n            result.add(e);\n        }\n    }\n    return result;\n}"
            ],
            [
                "sum",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns the sum of the given lists.  This is their intersection\n * subtracted from their union.\n *\n * @param <E> the element type\n * @param list1  the first list\n * @param list2  the second list\n * @return  a new list containing the sum of those lists\n * @throws NullPointerException if either list is null\n */\npublic static <E> List<E> sum(final List<? extends E> list1, final List<? extends E> list2) {\n    return subtract(union(list1, list2), intersection(list1, list2));\n}"
            ],
            [
                "union",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns a new list containing the second list appended to the\n * first list.  The {@link List#addAll(Collection)} operation is\n * used to append the two given lists into a new list.\n *\n * @param <E> the element type\n * @param list1  the first list\n * @param list2  the second list\n * @return a new list containing the union of those lists\n * @throws NullPointerException if either list is null\n */\npublic static <E> List<E> union(final List<? extends E> list1, final List<? extends E> list2) {\n    final ArrayList<E> result = new ArrayList<E>(list1);\n    result.addAll(list2);\n    return result;\n}"
            ],
            [
                "select",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Selects all elements from input collection which match the given\n * predicate into an output list.\n * <p>\n * A <code>null</code> predicate matches no elements.\n *\n * @param <E> the element type\n * @param inputCollection  the collection to get the input from, may not be null\n * @param predicate  the predicate to use, may be null\n * @return the elements matching the predicate (new list)\n * @throws NullPointerException if the input list is null\n *\n * @since 4.0\n * @see CollectionUtils#select(Iterable, Predicate)\n */\npublic static <E> List<E> select(final Collection<? extends E> inputCollection, final Predicate<? super E> predicate) {\n    return CollectionUtils.select(inputCollection, predicate, new ArrayList<E>(inputCollection.size()));\n}"
            ],
            [
                "selectRejected",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Selects all elements from inputCollection which don't match the given\n * predicate into an output collection.\n * <p>\n * If the input predicate is <code>null</code>, the result is an empty list.\n *\n * @param <E> the element type\n * @param inputCollection the collection to get the input from, may not be null\n * @param predicate the predicate to use, may be null\n * @return the elements <b>not</b> matching the predicate (new list)\n * @throws NullPointerException if the input collection is null\n *\n * @since 4.0\n * @see CollectionUtils#selectRejected(Iterable, Predicate)\n */\npublic static <E> List<E> selectRejected(final Collection<? extends E> inputCollection, final Predicate<? super E> predicate) {\n    return CollectionUtils.selectRejected(inputCollection, predicate, new ArrayList<E>(inputCollection.size()));\n}"
            ],
            [
                "isEqualList",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Tests two lists for value-equality as per the equality contract in\n * {@link java.util.List#equals(java.lang.Object)}.\n * <p>\n * This method is useful for implementing <code>List</code> when you cannot\n * extend AbstractList. The method takes Collection instances to enable other\n * collection types to use the List implementation algorithm.\n * <p>\n * The relevant text (slightly paraphrased as this is a static method) is:\n * <blockquote>\n * Compares the two list objects for equality.  Returns\n * {@code true} if and only if both\n * lists have the same size, and all corresponding pairs of elements in\n * the two lists are <i>equal</i>.  (Two elements {@code e1} and\n * {@code e2} are <i>equal</i> if <tt>(e1==null ? e2==null :\n * e1.equals(e2))</tt>.)  In other words, two lists are defined to be\n * equal if they contain the same elements in the same order.  This\n * definition ensures that the equals method works properly across\n * different implementations of the {@code List} interface.\n * </blockquote>\n *\n * <b>Note:</b> The behaviour of this method is undefined if the lists are\n * modified during the equals comparison.\n *\n * @see java.util.List\n * @param list1  the first list, may be null\n * @param list2  the second list, may be null\n * @return whether the lists are equal by value comparison\n */\npublic static boolean isEqualList(final Collection<?> list1, final Collection<?> list2) {\n    if (list1 == list2) {\n        return true;\n    }\n    if (list1 == null || list2 == null || list1.size() != list2.size()) {\n        return false;\n    }\n    final Iterator<?> it1 = list1.iterator();\n    final Iterator<?> it2 = list2.iterator();\n    Object obj1 = null;\n    Object obj2 = null;\n    while (it1.hasNext() && it2.hasNext()) {\n        obj1 = it1.next();\n        obj2 = it2.next();\n        if (!(obj1 == null ? obj2 == null : obj1.equals(obj2))) {\n            return false;\n        }\n    }\n    return !(it1.hasNext() || it2.hasNext());\n}"
            ],
            [
                "hashCodeForList",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Generates a hash code using the algorithm specified in\n * {@link java.util.List#hashCode()}.\n * <p>\n * This method is useful for implementing <code>List</code> when you cannot\n * extend AbstractList. The method takes Collection instances to enable other\n * collection types to use the List implementation algorithm.\n *\n * @see java.util.List#hashCode()\n * @param list  the list to generate the hashCode for, may be null\n * @return the hash code\n */\npublic static int hashCodeForList(final Collection<?> list) {\n    if (list == null) {\n        return 0;\n    }\n    int hashCode = 1;\n    final Iterator<?> it = list.iterator();\n    while (it.hasNext()) {\n        final Object obj = it.next();\n        hashCode = 31 * hashCode + (obj == null ? 0 : obj.hashCode());\n    }\n    return hashCode;\n}"
            ],
            [
                "retainAll",
                "org.apache.commons.collections4",
                "ListUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns a List containing all the elements in <code>collection</code>\n * that are also in <code>retain</code>. The cardinality of an element <code>e</code>\n * in the returned list is the same as the cardinality of <code>e</code>\n * in <code>collection</code> unless <code>retain</code> does not contain <code>e</code>, in which\n * case the cardinality is zero. This method is useful if you do not wish to modify\n * the collection <code>c</code> and thus cannot call <code>collection.retainAll(retain);</code>.\n * <p>\n * This implementation iterates over <code>collection</code>, checking each element in\n * turn to see if it's contained in <code>retain</code>. If it's contained, it's added\n * to the returned list. As a consequence, it is advised to use a collection type for\n * <code>retain</code> that provides a fast (e.g. O(1)) implementation of\n * {@link Collection#contains(Object)}.\n *\n * @param <E>  the element type\n * @param collection  the collection whose contents are the target of the #retailAll operation\n * @param retain  the collection containing the elements to be retained in the returned collection\n * @return a <code>List</code> containing all the elements of <code>c</code>\n * that occur at least once in <code>retain</code>.\n * @throws NullPointerException if either parameter is null\n * @since 3.2\n */\npublic static <E> List<E> retainAll(final Collection<E> collection, final Collection<?> retain) {\n    final List<E> list = new ArrayList<E>(Math.min(collection.size(), retain.size()));\n    for (final E obj : collection) {\n        if (retain.contains(obj)) {\n            list.add(obj);\n        }\n    }\n    return list;\n}"
            ],
            [
                "removeAll",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Removes the elements in <code>remove</code> from <code>collection</code>. That is, this\n * method returns a list containing all the elements in <code>collection</code>\n * that are not in <code>remove</code>. The cardinality of an element <code>e</code>\n * in the returned collection is the same as the cardinality of <code>e</code>\n * in <code>collection</code> unless <code>remove</code> contains <code>e</code>, in which\n * case the cardinality is zero. This method is useful if you do not wish to modify\n * <code>collection</code> and thus cannot call <code>collection.removeAll(remove);</code>.\n * <p>\n * This implementation iterates over <code>collection</code>, checking each element in\n * turn to see if it's contained in <code>remove</code>. If it's not contained, it's added\n * to the returned list. As a consequence, it is advised to use a collection type for\n * <code>remove</code> that provides a fast (e.g. O(1)) implementation of\n * {@link Collection#contains(Object)}.\n *\n * @param <E>  the element type\n * @param collection  the collection from which items are removed (in the returned collection)\n * @param remove  the items to be removed from the returned <code>collection</code>\n * @return a <code>List</code> containing all the elements of <code>c</code> except\n * any elements that also occur in <code>remove</code>.\n * @throws NullPointerException if either parameter is null\n * @since 3.2\n */\npublic static <E> List<E> removeAll(final Collection<E> collection, final Collection<?> remove) {\n    final List<E> list = new ArrayList<E>();\n    for (final E obj : collection) {\n        if (!remove.contains(obj)) {\n            list.add(obj);\n        }\n    }\n    return list;\n}"
            ],
            [
                "synchronizedList",
                "org.apache.commons.collections4",
                "ListUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns a synchronized list backed by the given list.\n * <p>\n * You must manually synchronize on the returned list's iterator to\n * avoid non-deterministic behavior:\n *\n * <pre>\n * List list = ListUtils.synchronizedList(myList);\n * synchronized (list) {\n *     Iterator i = list.iterator();\n *     while (i.hasNext()) {\n *         process (i.next());\n *     }\n * }\n * </pre>\n *\n * This method is just a wrapper for {@link Collections#synchronizedList(List)}.\n *\n * @param <E> the element type\n * @param list  the list to synchronize, must not be null\n * @return a synchronized list backed by the given list\n * @throws NullPointerException if the list is null\n */\npublic static <E> List<E> synchronizedList(final List<E> list) {\n    return Collections.synchronizedList(list);\n}"
            ],
            [
                "unmodifiableList",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns an unmodifiable list backed by the given list.\n * <p>\n * This method uses the implementation in the decorators subpackage.\n *\n * @param <E>  the element type\n * @param list  the list to make unmodifiable, must not be null\n * @return an unmodifiable list backed by the given list\n * @throws NullPointerException if the list is null\n */\npublic static <E> List<E> unmodifiableList(final List<? extends E> list) {\n    return UnmodifiableList.unmodifiableList(list);\n}"
            ],
            [
                "predicatedList",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns a predicated (validating) list backed by the given list.\n * <p>\n * Only objects that pass the test in the given predicate can be added to the list.\n * Trying to add an invalid object results in an IllegalArgumentException.\n * It is important not to use the original list after invoking this method,\n * as it is a backdoor for adding invalid objects.\n *\n * @param <E> the element type\n * @param list  the list to predicate, must not be null\n * @param predicate  the predicate for the list, must not be null\n * @return a predicated list backed by the given list\n * @throws NullPointerException if the List or Predicate is null\n */\npublic static <E> List<E> predicatedList(final List<E> list, final Predicate<E> predicate) {\n    return PredicatedList.predicatedList(list, predicate);\n}"
            ],
            [
                "transformedList",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns a transformed list backed by the given list.\n * <p>\n * This method returns a new list (decorating the specified list) that\n * will transform any new entries added to it.\n * Existing entries in the specified list will not be transformed.\n * <p>\n * Each object is passed through the transformer as it is added to the\n * List. It is important not to use the original list after invoking this\n * method, as it is a backdoor for adding untransformed objects.\n * <p>\n * Existing entries in the specified list will not be transformed.\n * If you want that behaviour, see {@link TransformedList#transformedList}.\n *\n * @param <E> the element type\n * @param list  the list to predicate, must not be null\n * @param transformer  the transformer for the list, must not be null\n * @return a transformed list backed by the given list\n * @throws NullPointerException if the List or Transformer is null\n */\npublic static <E> List<E> transformedList(final List<E> list, final Transformer<? super E, ? extends E> transformer) {\n    return TransformedList.transformingList(list, transformer);\n}"
            ],
            [
                "lazyList",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns a \"lazy\" list whose elements will be created on demand.\n * <p>\n * When the index passed to the returned list's {@link List#get(int) get}\n * method is greater than the list's size, then the factory will be used\n * to create a new object and that object will be inserted at that index.\n * <p>\n * For instance:\n *\n * <pre>\n * Factory&lt;Date&gt; factory = new Factory&lt;Date&gt;() {\n *     public Date create() {\n *         return new Date();\n *     }\n * }\n * List&lt;Date&gt; lazy = ListUtils.lazyList(new ArrayList&lt;Date&gt;(), factory);\n * Date date = lazy.get(3);\n * </pre>\n *\n * After the above code is executed, <code>date</code> will refer to\n * a new <code>Date</code> instance.  Furthermore, that <code>Date</code>\n * instance is the fourth element in the list.  The first, second,\n * and third element are all set to <code>null</code>.\n *\n * @param <E> the element type\n * @param list  the list to make lazy, must not be null\n * @param factory  the factory for creating new objects, must not be null\n * @return a lazy list backed by the given list\n * @throws NullPointerException if the List or Factory is null\n */\npublic static <E> List<E> lazyList(final List<E> list, final Factory<? extends E> factory) {\n    return LazyList.lazyList(list, factory);\n}"
            ],
            [
                "fixedSizeList",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns a fixed-sized list backed by the given list.\n * Elements may not be added or removed from the returned list, but\n * existing elements can be changed (for instance, via the\n * {@link List#set(int, Object)} method).\n *\n * @param <E>  the element type\n * @param list  the list whose size to fix, must not be null\n * @return a fixed-size list backed by that list\n * @throws NullPointerException  if the List is null\n */\npublic static <E> List<E> fixedSizeList(final List<E> list) {\n    return FixedSizeList.fixedSizeList(list);\n}"
            ],
            [
                "indexOf",
                "org.apache.commons.collections4",
                "ListUtils",
                "//-----------------------------------------------------------------------\n/**\n * Finds the first index in the given List which matches the given predicate.\n * <p>\n * If the input List or predicate is null, or no element of the List\n * matches the predicate, -1 is returned.\n *\n * @param <E>  the element type\n * @param list the List to search, may be null\n * @param predicate  the predicate to use, may be null\n * @return the first index of an Object in the List which matches the predicate or -1 if none could be found\n */\npublic static <E> int indexOf(final List<E> list, final Predicate<E> predicate) {\n    if (list != null && predicate != null) {\n        for (int i = 0; i < list.size(); i++) {\n            final E item = list.get(i);\n            if (predicate.evaluate(item)) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}"
            ],
            [
                "longestCommonSubsequence",
                "org.apache.commons.collections4",
                "ListUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns the longest common subsequence (LCS) of two sequences (lists).\n *\n * @param <E>  the element type\n * @param a  the first list\n * @param b  the second list\n * @return the longest common subsequence\n * @throws NullPointerException if either list is {@code null}\n * @since 4.0\n */\npublic static <E> List<E> longestCommonSubsequence(final List<E> a, final List<E> b) {\n    return longestCommonSubsequence(a, b, DefaultEquator.defaultEquator());\n}"
            ],
            [
                "longestCommonSubsequence",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns the longest common subsequence (LCS) of two sequences (lists).\n *\n * @param <E>  the element type\n * @param a  the first list\n * @param b  the second list\n * @param equator  the equator used to test object equality\n * @return the longest common subsequence\n * @throws NullPointerException if either list or the equator is {@code null}\n * @since 4.0\n */\npublic static <E> List<E> longestCommonSubsequence(final List<E> a, final List<E> b, final Equator<? super E> equator) {\n    if (a == null || b == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (equator == null) {\n        throw new NullPointerException(\"Equator must not be null\");\n    }\n    final SequencesComparator<E> comparator = new SequencesComparator<E>(a, b, equator);\n    final EditScript<E> script = comparator.getScript();\n    final LcsVisitor<E> visitor = new LcsVisitor<E>();\n    script.visit(visitor);\n    return visitor.getSubSequence();\n}"
            ],
            [
                "longestCommonSubsequence",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns the longest common subsequence (LCS) of two {@link CharSequence} objects.\n * <p>\n * This is a convenience method for using {@link #longestCommonSubsequence(List, List)}\n * with {@link CharSequence} instances.\n *\n * @param a  the first sequence\n * @param b  the second sequence\n * @return the longest common subsequence as {@link String}\n * @throws NullPointerException if either sequence is {@code null}\n * @since 4.0\n */\npublic static String longestCommonSubsequence(final CharSequence a, final CharSequence b) {\n    if (a == null || b == null) {\n        throw new NullPointerException(\"CharSequence must not be null\");\n    }\n    final List<Character> lcs = longestCommonSubsequence(new CharSequenceAsList(a), new CharSequenceAsList(b));\n    final StringBuilder sb = new StringBuilder();\n    for (Character ch : lcs) {\n        sb.append(ch);\n    }\n    return sb.toString();\n}"
            ],
            [
                "partition",
                "org.apache.commons.collections4",
                "ListUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns consecutive {@link List#subList(int, int) sublists} of a\n * list, each of the same size (the final list may be smaller). For example,\n * partitioning a list containing {@code [a, b, c, d, e]} with a partition\n * size of 3 yields {@code [[a, b, c], [d, e]]} -- an outer list containing\n * two inner lists of three and two elements, all in the original order.\n * <p>\n * The outer list is unmodifiable, but reflects the latest state of the\n * source list. The inner lists are sublist views of the original list,\n * produced on demand using {@link List#subList(int, int)}, and are subject\n * to all the usual caveats about modification as explained in that API.\n * <p>\n * Adapted from http://code.google.com/p/guava-libraries/\n *\n * @param <T> the element type\n * @param list  the list to return consecutive sublists of\n * @param size  the desired size of each sublist (the last may be smaller)\n * @return a list of consecutive sublists\n * @throws NullPointerException if list is null\n * @throws IllegalArgumentException if size is not strictly positive\n * @since 4.0\n */\npublic static <T> List<List<T>> partition(final List<T> list, final int size) {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (size <= 0) {\n        throw new IllegalArgumentException(\"Size must be greater than 0\");\n    }\n    return new Partition<T>(list, size);\n}"
            ],
            [
                "getObject",
                "org.apache.commons.collections4",
                "MapUtils",
                "// Type safe getters\n//-------------------------------------------------------------------------\n/**\n * Gets from a Map in a null-safe manner.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map, <code>null</code> if null map input\n */\npublic static <K, V> V getObject(final Map<? super K, V> map, final K key) {\n    if (map != null) {\n        return map.get(key);\n    }\n    return null;\n}"
            ],
            [
                "getString",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a String from a Map in a null-safe manner.\n * <p>\n * The String is obtained via <code>toString</code>.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a String, <code>null</code> if null map input\n */\npublic static <K> String getString(final Map<? super K, ?> map, final K key) {\n    if (map != null) {\n        final Object answer = map.get(key);\n        if (answer != null) {\n            return answer.toString();\n        }\n    }\n    return null;\n}"
            ],
            [
                "getBoolean",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a Boolean from a Map in a null-safe manner.\n * <p>\n * If the value is a <code>Boolean</code> it is returned directly.\n * If the value is a <code>String</code> and it equals 'true' ignoring case\n * then <code>true</code> is returned, otherwise <code>false</code>.\n * If the value is a <code>Number</code> an integer zero value returns\n * <code>false</code> and non-zero returns <code>true</code>.\n * Otherwise, <code>null</code> is returned.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a Boolean, <code>null</code> if null map input\n */\npublic static <K> Boolean getBoolean(final Map<? super K, ?> map, final K key) {\n    if (map != null) {\n        final Object answer = map.get(key);\n        if (answer != null) {\n            if (answer instanceof Boolean) {\n                return (Boolean) answer;\n            }\n            if (answer instanceof String) {\n                return Boolean.valueOf((String) answer);\n            }\n            if (answer instanceof Number) {\n                final Number n = (Number) answer;\n                return n.intValue() != 0 ? Boolean.TRUE : Boolean.FALSE;\n            }\n        }\n    }\n    return null;\n}"
            ],
            [
                "getNumber",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a Number from a Map in a null-safe manner.\n * <p>\n * If the value is a <code>Number</code> it is returned directly.\n * If the value is a <code>String</code> it is converted using\n * {@link NumberFormat#parse(String)} on the system default formatter\n * returning <code>null</code> if the conversion fails.\n * Otherwise, <code>null</code> is returned.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a Number, <code>null</code> if null map input\n */\npublic static <K> Number getNumber(final Map<? super K, ?> map, final K key) {\n    if (map != null) {\n        final Object answer = map.get(key);\n        if (answer != null) {\n            if (answer instanceof Number) {\n                return (Number) answer;\n            }\n            if (answer instanceof String) {\n                try {\n                    final String text = (String) answer;\n                    return NumberFormat.getInstance().parse(text);\n                } catch (final ParseException e) {\n                    // NOPMD\n                    // failure means null is returned\n                }\n            }\n        }\n    }\n    return null;\n}"
            ],
            [
                "getByte",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a Byte from a Map in a null-safe manner.\n * <p>\n * The Byte is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a Byte, <code>null</code> if null map input\n */\npublic static <K> Byte getByte(final Map<? super K, ?> map, final K key) {\n    final Number answer = getNumber(map, key);\n    if (answer == null) {\n        return null;\n    }\n    if (answer instanceof Byte) {\n        return (Byte) answer;\n    }\n    return Byte.valueOf(answer.byteValue());\n}"
            ],
            [
                "getShort",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a Short from a Map in a null-safe manner.\n * <p>\n * The Short is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a Short, <code>null</code> if null map input\n */\npublic static <K> Short getShort(final Map<? super K, ?> map, final K key) {\n    final Number answer = getNumber(map, key);\n    if (answer == null) {\n        return null;\n    }\n    if (answer instanceof Short) {\n        return (Short) answer;\n    }\n    return Short.valueOf(answer.shortValue());\n}"
            ],
            [
                "getInteger",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a Integer from a Map in a null-safe manner.\n * <p>\n * The Integer is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a Integer, <code>null</code> if null map input\n */\npublic static <K> Integer getInteger(final Map<? super K, ?> map, final K key) {\n    final Number answer = getNumber(map, key);\n    if (answer == null) {\n        return null;\n    }\n    if (answer instanceof Integer) {\n        return (Integer) answer;\n    }\n    return Integer.valueOf(answer.intValue());\n}"
            ],
            [
                "getLong",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a Long from a Map in a null-safe manner.\n * <p>\n * The Long is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a Long, <code>null</code> if null map input\n */\npublic static <K> Long getLong(final Map<? super K, ?> map, final K key) {\n    final Number answer = getNumber(map, key);\n    if (answer == null) {\n        return null;\n    }\n    if (answer instanceof Long) {\n        return (Long) answer;\n    }\n    return Long.valueOf(answer.longValue());\n}"
            ],
            [
                "getFloat",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a Float from a Map in a null-safe manner.\n * <p>\n * The Float is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a Float, <code>null</code> if null map input\n */\npublic static <K> Float getFloat(final Map<? super K, ?> map, final K key) {\n    final Number answer = getNumber(map, key);\n    if (answer == null) {\n        return null;\n    }\n    if (answer instanceof Float) {\n        return (Float) answer;\n    }\n    return Float.valueOf(answer.floatValue());\n}"
            ],
            [
                "getDouble",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a Double from a Map in a null-safe manner.\n * <p>\n * The Double is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a Double, <code>null</code> if null map input\n */\npublic static <K> Double getDouble(final Map<? super K, ?> map, final K key) {\n    final Number answer = getNumber(map, key);\n    if (answer == null) {\n        return null;\n    }\n    if (answer instanceof Double) {\n        return (Double) answer;\n    }\n    return Double.valueOf(answer.doubleValue());\n}"
            ],
            [
                "getMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a Map from a Map in a null-safe manner.\n * <p>\n * If the value returned from the specified map is not a Map then\n * <code>null</code> is returned.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a Map, <code>null</code> if null map input\n */\npublic static <K> Map<?, ?> getMap(final Map<? super K, ?> map, final K key) {\n    if (map != null) {\n        final Object answer = map.get(key);\n        if (answer != null && answer instanceof Map) {\n            return (Map<?, ?>) answer;\n        }\n    }\n    return null;\n}"
            ],
            [
                "getObject",
                "org.apache.commons.collections4",
                "MapUtils",
                "// Type safe getters with default values\n//-------------------------------------------------------------------------\n/**\n * Looks up the given key in the given map, converting null into the\n * given default value.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null\n * @return  the value in the map, or defaultValue if the original value\n *   is null or the map is null\n */\npublic static <K, V> V getObject(final Map<K, V> map, final K key, final V defaultValue) {\n    if (map != null) {\n        final V answer = map.get(key);\n        if (answer != null) {\n            return answer;\n        }\n    }\n    return defaultValue;\n}"
            ],
            [
                "getString",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Looks up the given key in the given map, converting the result into\n * a string, using the default value if the the conversion fails.\n *\n * @param <K>  the key type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null or if the\n *   conversion fails\n * @return  the value in the map as a string, or defaultValue if the\n *   original value is null, the map is null or the string conversion fails\n */\npublic static <K> String getString(final Map<? super K, ?> map, final K key, final String defaultValue) {\n    String answer = getString(map, key);\n    if (answer == null) {\n        answer = defaultValue;\n    }\n    return answer;\n}"
            ],
            [
                "getBoolean",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Looks up the given key in the given map, converting the result into\n * a boolean, using the default value if the the conversion fails.\n *\n * @param <K>  the key type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null or if the\n *   conversion fails\n * @return  the value in the map as a boolean, or defaultValue if the\n *   original value is null, the map is null or the boolean conversion fails\n */\npublic static <K> Boolean getBoolean(final Map<? super K, ?> map, final K key, final Boolean defaultValue) {\n    Boolean answer = getBoolean(map, key);\n    if (answer == null) {\n        answer = defaultValue;\n    }\n    return answer;\n}"
            ],
            [
                "getNumber",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Looks up the given key in the given map, converting the result into\n * a number, using the default value if the the conversion fails.\n *\n * @param <K>  the key type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null or if the\n *   conversion fails\n * @return  the value in the map as a number, or defaultValue if the\n *   original value is null, the map is null or the number conversion fails\n */\npublic static <K> Number getNumber(final Map<? super K, ?> map, final K key, final Number defaultValue) {\n    Number answer = getNumber(map, key);\n    if (answer == null) {\n        answer = defaultValue;\n    }\n    return answer;\n}"
            ],
            [
                "getByte",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Looks up the given key in the given map, converting the result into\n * a byte, using the default value if the the conversion fails.\n *\n * @param <K>  the key type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null or if the\n *   conversion fails\n * @return  the value in the map as a number, or defaultValue if the\n *   original value is null, the map is null or the number conversion fails\n */\npublic static <K> Byte getByte(final Map<? super K, ?> map, final K key, final Byte defaultValue) {\n    Byte answer = getByte(map, key);\n    if (answer == null) {\n        answer = defaultValue;\n    }\n    return answer;\n}"
            ],
            [
                "getShort",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Looks up the given key in the given map, converting the result into\n * a short, using the default value if the the conversion fails.\n *\n * @param <K>  the key type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null or if the\n *   conversion fails\n * @return  the value in the map as a number, or defaultValue if the\n *   original value is null, the map is null or the number conversion fails\n */\npublic static <K> Short getShort(final Map<? super K, ?> map, final K key, final Short defaultValue) {\n    Short answer = getShort(map, key);\n    if (answer == null) {\n        answer = defaultValue;\n    }\n    return answer;\n}"
            ],
            [
                "getInteger",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Looks up the given key in the given map, converting the result into\n * an integer, using the default value if the the conversion fails.\n *\n * @param <K>  the key type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null or if the\n *   conversion fails\n * @return  the value in the map as a number, or defaultValue if the\n *   original value is null, the map is null or the number conversion fails\n */\npublic static <K> Integer getInteger(final Map<? super K, ?> map, final K key, final Integer defaultValue) {\n    Integer answer = getInteger(map, key);\n    if (answer == null) {\n        answer = defaultValue;\n    }\n    return answer;\n}"
            ],
            [
                "getLong",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Looks up the given key in the given map, converting the result into\n * a long, using the default value if the the conversion fails.\n *\n * @param <K>  the key type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null or if the\n *   conversion fails\n * @return  the value in the map as a number, or defaultValue if the\n *   original value is null, the map is null or the number conversion fails\n */\npublic static <K> Long getLong(final Map<? super K, ?> map, final K key, final Long defaultValue) {\n    Long answer = getLong(map, key);\n    if (answer == null) {\n        answer = defaultValue;\n    }\n    return answer;\n}"
            ],
            [
                "getFloat",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Looks up the given key in the given map, converting the result into\n * a float, using the default value if the the conversion fails.\n *\n * @param <K>  the key type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null or if the\n *   conversion fails\n * @return  the value in the map as a number, or defaultValue if the\n *   original value is null, the map is null or the number conversion fails\n */\npublic static <K> Float getFloat(final Map<? super K, ?> map, final K key, final Float defaultValue) {\n    Float answer = getFloat(map, key);\n    if (answer == null) {\n        answer = defaultValue;\n    }\n    return answer;\n}"
            ],
            [
                "getDouble",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Looks up the given key in the given map, converting the result into\n * a double, using the default value if the the conversion fails.\n *\n * @param <K>  the key type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null or if the\n *   conversion fails\n * @return  the value in the map as a number, or defaultValue if the\n *   original value is null, the map is null or the number conversion fails\n */\npublic static <K> Double getDouble(final Map<? super K, ?> map, final K key, final Double defaultValue) {\n    Double answer = getDouble(map, key);\n    if (answer == null) {\n        answer = defaultValue;\n    }\n    return answer;\n}"
            ],
            [
                "getMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Looks up the given key in the given map, converting the result into\n * a map, using the default value if the the conversion fails.\n *\n * @param <K>  the key type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null or if the\n *   conversion fails\n * @return  the value in the map as a number, or defaultValue if the\n *   original value is null, the map is null or the map conversion fails\n */\npublic static <K> Map<?, ?> getMap(final Map<? super K, ?> map, final K key, final Map<?, ?> defaultValue) {\n    Map<?, ?> answer = getMap(map, key);\n    if (answer == null) {\n        answer = defaultValue;\n    }\n    return answer;\n}"
            ],
            [
                "getBooleanValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "// Type safe primitive getters\n//-------------------------------------------------------------------------\n/**\n * Gets a boolean from a Map in a null-safe manner.\n * <p>\n * If the value is a <code>Boolean</code> its value is returned.\n * If the value is a <code>String</code> and it equals 'true' ignoring case\n * then <code>true</code> is returned, otherwise <code>false</code>.\n * If the value is a <code>Number</code> an integer zero value returns\n * <code>false</code> and non-zero returns <code>true</code>.\n * Otherwise, <code>false</code> is returned.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a Boolean, <code>false</code> if null map input\n */\npublic static <K> boolean getBooleanValue(final Map<? super K, ?> map, final K key) {\n    return Boolean.TRUE.equals(getBoolean(map, key));\n}"
            ],
            [
                "getByteValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a byte from a Map in a null-safe manner.\n * <p>\n * The byte is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a byte, <code>0</code> if null map input\n */\npublic static <K> byte getByteValue(final Map<? super K, ?> map, final K key) {\n    final Byte byteObject = getByte(map, key);\n    if (byteObject == null) {\n        return 0;\n    }\n    return byteObject.byteValue();\n}"
            ],
            [
                "getShortValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a short from a Map in a null-safe manner.\n * <p>\n * The short is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a short, <code>0</code> if null map input\n */\npublic static <K> short getShortValue(final Map<? super K, ?> map, final K key) {\n    final Short shortObject = getShort(map, key);\n    if (shortObject == null) {\n        return 0;\n    }\n    return shortObject.shortValue();\n}"
            ],
            [
                "getIntValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets an int from a Map in a null-safe manner.\n * <p>\n * The int is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as an int, <code>0</code> if null map input\n */\npublic static <K> int getIntValue(final Map<? super K, ?> map, final K key) {\n    final Integer integerObject = getInteger(map, key);\n    if (integerObject == null) {\n        return 0;\n    }\n    return integerObject.intValue();\n}"
            ],
            [
                "getLongValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a long from a Map in a null-safe manner.\n * <p>\n * The long is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a long, <code>0L</code> if null map input\n */\npublic static <K> long getLongValue(final Map<? super K, ?> map, final K key) {\n    final Long longObject = getLong(map, key);\n    if (longObject == null) {\n        return 0L;\n    }\n    return longObject.longValue();\n}"
            ],
            [
                "getFloatValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a float from a Map in a null-safe manner.\n * <p>\n * The float is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a float, <code>0.0F</code> if null map input\n */\npublic static <K> float getFloatValue(final Map<? super K, ?> map, final K key) {\n    final Float floatObject = getFloat(map, key);\n    if (floatObject == null) {\n        return 0f;\n    }\n    return floatObject.floatValue();\n}"
            ],
            [
                "getDoubleValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a double from a Map in a null-safe manner.\n * <p>\n * The double is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a double, <code>0.0</code> if null map input\n */\npublic static <K> double getDoubleValue(final Map<? super K, ?> map, final K key) {\n    final Double doubleObject = getDouble(map, key);\n    if (doubleObject == null) {\n        return 0d;\n    }\n    return doubleObject.doubleValue();\n}"
            ],
            [
                "getBooleanValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "// Type safe primitive getters with default values\n//-------------------------------------------------------------------------\n/**\n * Gets a boolean from a Map in a null-safe manner,\n * using the default value if the the conversion fails.\n * <p>\n * If the value is a <code>Boolean</code> its value is returned.\n * If the value is a <code>String</code> and it equals 'true' ignoring case\n * then <code>true</code> is returned, otherwise <code>false</code>.\n * If the value is a <code>Number</code> an integer zero value returns\n * <code>false</code> and non-zero returns <code>true</code>.\n * Otherwise, <code>defaultValue</code> is returned.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @param defaultValue  return if the value is null or if the conversion fails\n * @return the value in the Map as a Boolean, <code>defaultValue</code> if null map input\n */\npublic static <K> boolean getBooleanValue(final Map<? super K, ?> map, final K key, final boolean defaultValue) {\n    final Boolean booleanObject = getBoolean(map, key);\n    if (booleanObject == null) {\n        return defaultValue;\n    }\n    return booleanObject.booleanValue();\n}"
            ],
            [
                "getByteValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a byte from a Map in a null-safe manner,\n * using the default value if the the conversion fails.\n * <p>\n * The byte is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @param defaultValue  return if the value is null or if the conversion fails\n * @return the value in the Map as a byte, <code>defaultValue</code> if null map input\n */\npublic static <K> byte getByteValue(final Map<? super K, ?> map, final K key, final byte defaultValue) {\n    final Byte byteObject = getByte(map, key);\n    if (byteObject == null) {\n        return defaultValue;\n    }\n    return byteObject.byteValue();\n}"
            ],
            [
                "getShortValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a short from a Map in a null-safe manner,\n * using the default value if the the conversion fails.\n * <p>\n * The short is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @param defaultValue  return if the value is null or if the conversion fails\n * @return the value in the Map as a short, <code>defaultValue</code> if null map input\n */\npublic static <K> short getShortValue(final Map<? super K, ?> map, final K key, final short defaultValue) {\n    final Short shortObject = getShort(map, key);\n    if (shortObject == null) {\n        return defaultValue;\n    }\n    return shortObject.shortValue();\n}"
            ],
            [
                "getIntValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets an int from a Map in a null-safe manner,\n * using the default value if the the conversion fails.\n * <p>\n * The int is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @param defaultValue  return if the value is null or if the conversion fails\n * @return the value in the Map as an int, <code>defaultValue</code> if null map input\n */\npublic static <K> int getIntValue(final Map<? super K, ?> map, final K key, final int defaultValue) {\n    final Integer integerObject = getInteger(map, key);\n    if (integerObject == null) {\n        return defaultValue;\n    }\n    return integerObject.intValue();\n}"
            ],
            [
                "getLongValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a long from a Map in a null-safe manner,\n * using the default value if the the conversion fails.\n * <p>\n * The long is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @param defaultValue  return if the value is null or if the conversion fails\n * @return the value in the Map as a long, <code>defaultValue</code> if null map input\n */\npublic static <K> long getLongValue(final Map<? super K, ?> map, final K key, final long defaultValue) {\n    final Long longObject = getLong(map, key);\n    if (longObject == null) {\n        return defaultValue;\n    }\n    return longObject.longValue();\n}"
            ],
            [
                "getFloatValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a float from a Map in a null-safe manner,\n * using the default value if the the conversion fails.\n * <p>\n * The float is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @param defaultValue  return if the value is null or if the conversion fails\n * @return the value in the Map as a float, <code>defaultValue</code> if null map input\n */\npublic static <K> float getFloatValue(final Map<? super K, ?> map, final K key, final float defaultValue) {\n    final Float floatObject = getFloat(map, key);\n    if (floatObject == null) {\n        return defaultValue;\n    }\n    return floatObject.floatValue();\n}"
            ],
            [
                "getDoubleValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a double from a Map in a null-safe manner,\n * using the default value if the the conversion fails.\n * <p>\n * The double is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @param defaultValue  return if the value is null or if the conversion fails\n * @return the value in the Map as a double, <code>defaultValue</code> if null map input\n */\npublic static <K> double getDoubleValue(final Map<? super K, ?> map, final K key, final double defaultValue) {\n    final Double doubleObject = getDouble(map, key);\n    if (doubleObject == null) {\n        return defaultValue;\n    }\n    return doubleObject.doubleValue();\n}"
            ],
            [
                "toProperties",
                "org.apache.commons.collections4",
                "MapUtils",
                "// Conversion methods\n//-------------------------------------------------------------------------\n/**\n * Gets a new Properties object initialised with the values from a Map.\n * A null input will return an empty properties object.\n * <p>\n * A Properties object may only store non-null keys and values, thus if\n * the provided map contains either a key or value which is {@code null},\n * a {@link NullPointerException} will be thrown.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to convert to a Properties object\n * @return the properties object\n * @throws NullPointerException if a key or value in the provided map is {@code null}\n */\npublic static <K, V> Properties toProperties(final Map<K, V> map) {\n    final Properties answer = new Properties();\n    if (map != null) {\n        for (final Entry<K, V> entry2 : map.entrySet()) {\n            final Map.Entry<?, ?> entry = entry2;\n            final Object key = entry.getKey();\n            final Object value = entry.getValue();\n            answer.put(key, value);\n        }\n    }\n    return answer;\n}"
            ],
            [
                "toMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Creates a new HashMap using data copied from a ResourceBundle.\n *\n * @param resourceBundle  the resource bundle to convert, may not be null\n * @return the hashmap containing the data\n * @throws NullPointerException if the bundle is null\n */\npublic static Map<String, Object> toMap(final ResourceBundle resourceBundle) {\n    final Enumeration<String> enumeration = resourceBundle.getKeys();\n    final Map<String, Object> map = new HashMap<String, Object>();\n    while (enumeration.hasMoreElements()) {\n        final String key = enumeration.nextElement();\n        final Object value = resourceBundle.getObject(key);\n        map.put(key, value);\n    }\n    return map;\n}"
            ],
            [
                "invertMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "// Misc\n//-----------------------------------------------------------------------\n/**\n * Inverts the supplied map returning a new HashMap such that the keys of\n * the input are swapped with the values.\n * <p>\n * This operation assumes that the inverse mapping is well defined.\n * If the input map had multiple entries with the same value mapped to\n * different keys, the returned map will map one of those keys to the\n * value, but the exact key which will be mapped is undefined.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to invert, may not be null\n * @return a new HashMap containing the inverted data\n * @throws NullPointerException if the map is null\n */\npublic static <K, V> Map<V, K> invertMap(final Map<K, V> map) {\n    final Map<V, K> out = new HashMap<V, K>(map.size());\n    for (final Entry<K, V> entry : map.entrySet()) {\n        out.put(entry.getValue(), entry.getKey());\n    }\n    return out;\n}"
            ],
            [
                "putAll",
                "org.apache.commons.collections4",
                "MapUtils",
                "//-----------------------------------------------------------------------\n/**\n * Puts all the keys and values from the specified array into the map.\n * <p>\n * This method is an alternative to the {@link java.util.Map#putAll(java.util.Map)}\n * method and constructors. It allows you to build a map from an object array\n * of various possible styles.\n * <p>\n * If the first entry in the object array implements {@link java.util.Map.Entry}\n * or {@link KeyValue} then the key and value are added from that object.\n * If the first entry in the object array is an object array itself, then\n * it is assumed that index 0 in the sub-array is the key and index 1 is the value.\n * Otherwise, the array is treated as keys and values in alternate indices.\n * <p>\n * For example, to create a color map:\n * <pre>\n * Map colorMap = MapUtils.putAll(new HashMap(), new String[][] {\n *     {\"RED\", \"#FF0000\"},\n *     {\"GREEN\", \"#00FF00\"},\n *     {\"BLUE\", \"#0000FF\"}\n * });\n * </pre>\n * or:\n * <pre>\n * Map colorMap = MapUtils.putAll(new HashMap(), new String[] {\n *     \"RED\", \"#FF0000\",\n *     \"GREEN\", \"#00FF00\",\n *     \"BLUE\", \"#0000FF\"\n * });\n * </pre>\n * or:\n * <pre>\n * Map colorMap = MapUtils.putAll(new HashMap(), new Map.Entry[] {\n *     new DefaultMapEntry(\"RED\", \"#FF0000\"),\n *     new DefaultMapEntry(\"GREEN\", \"#00FF00\"),\n *     new DefaultMapEntry(\"BLUE\", \"#0000FF\")\n * });\n * </pre>\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to populate, must not be null\n * @param array  an array to populate from, null ignored\n * @return the input map\n * @throws NullPointerException  if map is null\n * @throws IllegalArgumentException  if sub-array or entry matching used and an entry is invalid\n * @throws ClassCastException if the array contents is mixed\n * @since 3.2\n */\n// As per Javadoc throws CCE for invalid array contents\n@SuppressWarnings(\"unchecked\")\npublic static <K, V> Map<K, V> putAll(final Map<K, V> map, final Object[] array) {\n    if (map == null) {\n        throw new NullPointerException(\"The map must not be null\");\n    }\n    if (array == null || array.length == 0) {\n        return map;\n    }\n    final Object obj = array[0];\n    if (obj instanceof Map.Entry) {\n        for (final Object element : array) {\n            // cast ok here, type is checked above\n            final Map.Entry<K, V> entry = (Map.Entry<K, V>) element;\n            map.put(entry.getKey(), entry.getValue());\n        }\n    } else if (obj instanceof KeyValue) {\n        for (final Object element : array) {\n            // cast ok here, type is checked above\n            final KeyValue<K, V> keyval = (KeyValue<K, V>) element;\n            map.put(keyval.getKey(), keyval.getValue());\n        }\n    } else if (obj instanceof Object[]) {\n        for (int i = 0; i < array.length; i++) {\n            final Object[] sub = (Object[]) array[i];\n            if (sub == null || sub.length < 2) {\n                throw new IllegalArgumentException(\"Invalid array element: \" + i);\n            }\n            // these casts can fail if array has incorrect types\n            map.put((K) sub[0], (V) sub[1]);\n        }\n    } else {\n        for (int i = 0; i < array.length - 1; ) {\n            // these casts can fail if array has incorrect types\n            map.put((K) array[i++], (V) array[i++]);\n        }\n    }\n    return map;\n}"
            ],
            [
                "emptyIfNull",
                "org.apache.commons.collections4",
                "MapUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns an immutable empty map if the argument is <code>null</code>,\n * or the argument itself otherwise.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map the map, possibly <code>null</code>\n * @return an empty map if the argument is <code>null</code>\n */\npublic static <K, V> Map<K, V> emptyIfNull(final Map<K, V> map) {\n    return map == null ? Collections.<K, V>emptyMap() : map;\n}"
            ],
            [
                "isEmpty",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Null-safe check if the specified map is empty.\n * <p>\n * Null returns true.\n *\n * @param map  the map to check, may be null\n * @return true if empty or null\n * @since 3.2\n */\npublic static boolean isEmpty(final Map<?, ?> map) {\n    return map == null || map.isEmpty();\n}"
            ],
            [
                "isNotEmpty",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Null-safe check if the specified map is not empty.\n * <p>\n * Null returns false.\n *\n * @param map  the map to check, may be null\n * @return true if non-null and non-empty\n * @since 3.2\n */\npublic static boolean isNotEmpty(final Map<?, ?> map) {\n    return !MapUtils.isEmpty(map);\n}"
            ],
            [
                "synchronizedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "// Map decorators\n//-----------------------------------------------------------------------\n/**\n * Returns a synchronized map backed by the given map.\n * <p>\n * You must manually synchronize on the returned buffer's iterator to\n * avoid non-deterministic behavior:\n *\n * <pre>\n * Map m = MapUtils.synchronizedMap(myMap);\n * Set s = m.keySet();  // outside synchronized block\n * synchronized (m) {  // synchronized on MAP!\n *     Iterator i = s.iterator();\n *     while (i.hasNext()) {\n *         process (i.next());\n *     }\n * }\n * </pre>\n *\n * This method uses the implementation in {@link java.util.Collections Collections}.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to synchronize, must not be null\n * @return a synchronized map backed by the given map\n */\npublic static <K, V> Map<K, V> synchronizedMap(final Map<K, V> map) {\n    return Collections.synchronizedMap(map);\n}"
            ],
            [
                "unmodifiableMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns an unmodifiable map backed by the given map.\n * <p>\n * This method uses the implementation in the decorators subpackage.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to make unmodifiable, must not be null\n * @return an unmodifiable map backed by the given map\n * @throws NullPointerException  if the map is null\n */\npublic static <K, V> Map<K, V> unmodifiableMap(final Map<? extends K, ? extends V> map) {\n    return UnmodifiableMap.unmodifiableMap(map);\n}"
            ],
            [
                "predicatedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a predicated (validating) map backed by the given map.\n * <p>\n * Only objects that pass the tests in the given predicates can be added to the map.\n * Trying to add an invalid object results in an IllegalArgumentException.\n * Keys must pass the key predicate, values must pass the value predicate.\n * It is important not to use the original map after invoking this method,\n * as it is a backdoor for adding invalid objects.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to predicate, must not be null\n * @param keyPred  the predicate for keys, null means no check\n * @param valuePred  the predicate for values, null means no check\n * @return a predicated map backed by the given map\n * @throws NullPointerException  if the Map is null\n */\npublic static <K, V> IterableMap<K, V> predicatedMap(final Map<K, V> map, final Predicate<? super K> keyPred, final Predicate<? super V> valuePred) {\n    return PredicatedMap.predicatedMap(map, keyPred, valuePred);\n}"
            ],
            [
                "transformedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a transformed map backed by the given map.\n * <p>\n * This method returns a new map (decorating the specified map) that\n * will transform any new entries added to it.\n * Existing entries in the specified map will not be transformed.\n * If you want that behaviour, see {@link TransformedMap#transformedMap}.\n * <p>\n * Each object is passed through the transformers as it is added to the\n * Map. It is important not to use the original map after invoking this\n * method, as it is a backdoor for adding untransformed objects.\n * <p>\n * If there are any elements already in the map being decorated, they\n * are NOT transformed.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to transform, must not be null, typically empty\n * @param keyTransformer  the transformer for the map keys, null means no transformation\n * @param valueTransformer  the transformer for the map values, null means no transformation\n * @return a transformed map backed by the given map\n * @throws NullPointerException  if the Map is null\n */\npublic static <K, V> IterableMap<K, V> transformedMap(final Map<K, V> map, final Transformer<? super K, ? extends K> keyTransformer, final Transformer<? super V, ? extends V> valueTransformer) {\n    return TransformedMap.transformingMap(map, keyTransformer, valueTransformer);\n}"
            ],
            [
                "fixedSizeMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a fixed-sized map backed by the given map.\n * Elements may not be added or removed from the returned map, but\n * existing elements can be changed (for instance, via the\n * {@link Map#put(Object,Object)} method).\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map whose size to fix, must not be null\n * @return a fixed-size map backed by that map\n * @throws NullPointerException  if the Map is null\n */\npublic static <K, V> IterableMap<K, V> fixedSizeMap(final Map<K, V> map) {\n    return FixedSizeMap.fixedSizeMap(map);\n}"
            ],
            [
                "lazyMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a \"lazy\" map whose values will be created on demand.\n * <p>\n * When the key passed to the returned map's {@link Map#get(Object)}\n * method is not present in the map, then the factory will be used\n * to create a new object and that object will become the value\n * associated with that key.\n * <p>\n * For instance:\n * <pre>\n * Factory factory = new Factory() {\n *     public Object create() {\n *         return new Date();\n *     }\n * }\n * Map lazyMap = MapUtils.lazyMap(new HashMap(), factory);\n * Object obj = lazyMap.get(\"test\");\n * </pre>\n *\n * After the above code is executed, <code>obj</code> will contain\n * a new <code>Date</code> instance.  Furthermore, that <code>Date</code>\n * instance is the value for the <code>\"test\"</code> key in the map.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to make lazy, must not be null\n * @param factory  the factory for creating new objects, must not be null\n * @return a lazy map backed by the given map\n * @throws NullPointerException  if the Map or Factory is null\n */\npublic static <K, V> IterableMap<K, V> lazyMap(final Map<K, V> map, final Factory<? extends V> factory) {\n    return LazyMap.lazyMap(map, factory);\n}"
            ],
            [
                "lazyMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a \"lazy\" map whose values will be created on demand.\n * <p>\n * When the key passed to the returned map's {@link Map#get(Object)}\n * method is not present in the map, then the factory will be used\n * to create a new object and that object will become the value\n * associated with that key. The factory is a {@link Transformer}\n * that will be passed the key which it must transform into the value.\n * <p>\n * For instance:\n * <pre>\n * Transformer factory = new Transformer() {\n *     public Object transform(Object mapKey) {\n *         return new File(mapKey);\n *     }\n * }\n * Map lazyMap = MapUtils.lazyMap(new HashMap(), factory);\n * Object obj = lazyMap.get(\"C:/dev\");\n * </pre>\n *\n * After the above code is executed, <code>obj</code> will contain\n * a new <code>File</code> instance for the C drive dev directory.\n * Furthermore, that <code>File</code> instance is the value for the\n * <code>\"C:/dev\"</code> key in the map.\n * <p>\n * If a lazy map is wrapped by a synchronized map, the result is a simple\n * synchronized cache. When an object is not is the cache, the cache itself\n * calls back to the factory Transformer to populate itself, all within the\n * same synchronized block.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to make lazy, must not be null\n * @param transformerFactory  the factory for creating new objects, must not be null\n * @return a lazy map backed by the given map\n * @throws NullPointerException  if the Map or Transformer is null\n */\npublic static <K, V> IterableMap<K, V> lazyMap(final Map<K, V> map, final Transformer<? super K, ? extends V> transformerFactory) {\n    return LazyMap.lazyMap(map, transformerFactory);\n}"
            ],
            [
                "orderedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a map that maintains the order of keys that are added\n * backed by the given map.\n * <p>\n * If a key is added twice, the order is determined by the first add.\n * The order is observed through the keySet, values and entrySet.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to order, must not be null\n * @return an ordered map backed by the given map\n * @throws NullPointerException  if the Map is null\n */\npublic static <K, V> OrderedMap<K, V> orderedMap(final Map<K, V> map) {\n    return ListOrderedMap.listOrderedMap(map);\n}"
            ],
            [
                "multiValueMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Creates a mult-value map backed by the given map which returns\n * collections of type ArrayList.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate\n * @return a multi-value map backed by the given map which returns ArrayLists of values.\n * @see MultiValueMap\n * @since 3.2\n * @deprecated since 4.1, use {@link MultiValuedMap} instead\n */\n@Deprecated\npublic static <K, V> MultiValueMap<K, V> multiValueMap(final Map<K, ? super Collection<V>> map) {\n    return MultiValueMap.<K, V>multiValueMap(map);\n}"
            ],
            [
                "multiValueMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Creates a multi-value map backed by the given map which returns\n * collections of the specified type.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param <C>  the collection class type\n * @param map  the map to decorate\n * @param collectionClass  the type of collections to return from the map\n *   (must contain public no-arg constructor and extend Collection)\n * @return a multi-value map backed by the given map which returns collections of the specified type\n * @see MultiValueMap\n * @since 3.2\n * @deprecated since 4.1, use {@link MultiValuedMap} instead\n */\n@Deprecated\npublic static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(final Map<K, C> map, final Class<C> collectionClass) {\n    return MultiValueMap.multiValueMap(map, collectionClass);\n}"
            ],
            [
                "multiValueMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Creates a multi-value map backed by the given map which returns\n * collections created by the specified collection factory.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param <C>  the collection class type\n * @param map  the map to decorate\n * @param collectionFactory  a factor which creates collection objects\n * @return a multi-value map backed by the given map which returns collections\n *   created by the specified collection factory\n * @see MultiValueMap\n * @since 3.2\n * @deprecated since 4.1, use {@link MultiValuedMap} instead\n */\n@Deprecated\npublic static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(final Map<K, C> map, final Factory<C> collectionFactory) {\n    return MultiValueMap.multiValueMap(map, collectionFactory);\n}"
            ],
            [
                "synchronizedSortedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "// SortedMap decorators\n//-----------------------------------------------------------------------\n/**\n * Returns a synchronized sorted map backed by the given sorted map.\n * <p>\n * You must manually synchronize on the returned buffer's iterator to\n * avoid non-deterministic behavior:\n *\n * <pre>\n * Map m = MapUtils.synchronizedSortedMap(myMap);\n * Set s = m.keySet();  // outside synchronized block\n * synchronized (m) {  // synchronized on MAP!\n *     Iterator i = s.iterator();\n *     while (i.hasNext()) {\n *         process (i.next());\n *     }\n * }\n * </pre>\n *\n * This method uses the implementation in {@link java.util.Collections Collections}.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to synchronize, must not be null\n * @return a synchronized map backed by the given map\n * @throws NullPointerException  if the map is null\n */\npublic static <K, V> SortedMap<K, V> synchronizedSortedMap(final SortedMap<K, V> map) {\n    return Collections.synchronizedSortedMap(map);\n}"
            ],
            [
                "unmodifiableSortedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns an unmodifiable sorted map backed by the given sorted map.\n * <p>\n * This method uses the implementation in the decorators subpackage.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the sorted map to make unmodifiable, must not be null\n * @return an unmodifiable map backed by the given map\n * @throws NullPointerException  if the map is null\n */\npublic static <K, V> SortedMap<K, V> unmodifiableSortedMap(final SortedMap<K, ? extends V> map) {\n    return UnmodifiableSortedMap.unmodifiableSortedMap(map);\n}"
            ],
            [
                "predicatedSortedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a predicated (validating) sorted map backed by the given map.\n * <p>\n * Only objects that pass the tests in the given predicates can be added to the map.\n * Trying to add an invalid object results in an IllegalArgumentException.\n * Keys must pass the key predicate, values must pass the value predicate.\n * It is important not to use the original map after invoking this method,\n * as it is a backdoor for adding invalid objects.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to predicate, must not be null\n * @param keyPred  the predicate for keys, null means no check\n * @param valuePred  the predicate for values, null means no check\n * @return a predicated map backed by the given map\n * @throws NullPointerException  if the SortedMap is null\n */\npublic static <K, V> SortedMap<K, V> predicatedSortedMap(final SortedMap<K, V> map, final Predicate<? super K> keyPred, final Predicate<? super V> valuePred) {\n    return PredicatedSortedMap.predicatedSortedMap(map, keyPred, valuePred);\n}"
            ],
            [
                "transformedSortedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a transformed sorted map backed by the given map.\n * <p>\n * This method returns a new sorted map (decorating the specified map) that\n * will transform any new entries added to it.\n * Existing entries in the specified map will not be transformed.\n * If you want that behaviour, see {@link TransformedSortedMap#transformedSortedMap}.\n * <p>\n * Each object is passed through the transformers as it is added to the\n * Map. It is important not to use the original map after invoking this\n * method, as it is a backdoor for adding untransformed objects.\n * <p>\n * If there are any elements already in the map being decorated, they\n * are NOT transformed.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to transform, must not be null, typically empty\n * @param keyTransformer  the transformer for the map keys, null means no transformation\n * @param valueTransformer  the transformer for the map values, null means no transformation\n * @return a transformed map backed by the given map\n * @throws NullPointerException  if the SortedMap is null\n */\npublic static <K, V> SortedMap<K, V> transformedSortedMap(final SortedMap<K, V> map, final Transformer<? super K, ? extends K> keyTransformer, final Transformer<? super V, ? extends V> valueTransformer) {\n    return TransformedSortedMap.transformingSortedMap(map, keyTransformer, valueTransformer);\n}"
            ],
            [
                "fixedSizeSortedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a fixed-sized sorted map backed by the given sorted map.\n * Elements may not be added or removed from the returned map, but\n * existing elements can be changed (for instance, via the\n * {@link Map#put(Object,Object)} method).\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map whose size to fix, must not be null\n * @return a fixed-size map backed by that map\n * @throws NullPointerException  if the SortedMap is null\n */\npublic static <K, V> SortedMap<K, V> fixedSizeSortedMap(final SortedMap<K, V> map) {\n    return FixedSizeSortedMap.fixedSizeSortedMap(map);\n}"
            ],
            [
                "lazySortedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a \"lazy\" sorted map whose values will be created on demand.\n * <p>\n * When the key passed to the returned map's {@link Map#get(Object)}\n * method is not present in the map, then the factory will be used\n * to create a new object and that object will become the value\n * associated with that key.\n * <p>\n * For instance:\n *\n * <pre>\n * Factory factory = new Factory() {\n *     public Object create() {\n *         return new Date();\n *     }\n * }\n * SortedMap lazy = MapUtils.lazySortedMap(new TreeMap(), factory);\n * Object obj = lazy.get(\"test\");\n * </pre>\n *\n * After the above code is executed, <code>obj</code> will contain\n * a new <code>Date</code> instance.  Furthermore, that <code>Date</code>\n * instance is the value for the <code>\"test\"</code> key.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to make lazy, must not be null\n * @param factory  the factory for creating new objects, must not be null\n * @return a lazy map backed by the given map\n * @throws NullPointerException  if the SortedMap or Factory is null\n */\npublic static <K, V> SortedMap<K, V> lazySortedMap(final SortedMap<K, V> map, final Factory<? extends V> factory) {\n    return LazySortedMap.lazySortedMap(map, factory);\n}"
            ],
            [
                "lazySortedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a \"lazy\" sorted map whose values will be created on demand.\n * <p>\n * When the key passed to the returned map's {@link Map#get(Object)}\n * method is not present in the map, then the factory will be used\n * to create a new object and that object will become the value\n * associated with that key. The factory is a {@link Transformer}\n * that will be passed the key which it must transform into the value.\n * <p>\n * For instance:\n * <pre>\n * Transformer factory = new Transformer() {\n *     public Object transform(Object mapKey) {\n *         return new File(mapKey);\n *     }\n * }\n * SortedMap lazy = MapUtils.lazySortedMap(new TreeMap(), factory);\n * Object obj = lazy.get(\"C:/dev\");\n * </pre>\n *\n * After the above code is executed, <code>obj</code> will contain\n * a new <code>File</code> instance for the C drive dev directory.\n * Furthermore, that <code>File</code> instance is the value for the\n * <code>\"C:/dev\"</code> key in the map.\n * <p>\n * If a lazy map is wrapped by a synchronized map, the result is a simple\n * synchronized cache. When an object is not is the cache, the cache itself\n * calls back to the factory Transformer to populate itself, all within the\n * same synchronized block.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to make lazy, must not be null\n * @param transformerFactory  the factory for creating new objects, must not be null\n * @return a lazy map backed by the given map\n * @throws NullPointerException  if the Map or Transformer is null\n */\npublic static <K, V> SortedMap<K, V> lazySortedMap(final SortedMap<K, V> map, final Transformer<? super K, ? extends V> transformerFactory) {\n    return LazySortedMap.lazySortedMap(map, transformerFactory);\n}"
            ],
            [
                "iterableMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Get the specified {@link Map} as an {@link IterableMap}.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map to wrap if necessary.\n * @return IterableMap<K, V>\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> IterableMap<K, V> iterableMap(final Map<K, V> map) {\n    if (map == null) {\n        throw new NullPointerException(\"Map must not be null\");\n    }\n    return map instanceof IterableMap ? (IterableMap<K, V>) map : new AbstractMapDecorator<K, V>(map) {\n    };\n}"
            ],
            [
                "iterableSortedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Get the specified {@link SortedMap} as an {@link IterableSortedMap}.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param sortedMap to wrap if necessary\n * @return {@link IterableSortedMap}<K, V>\n * @throws NullPointerException if sortedMap is null\n * @since 4.0\n */\npublic static <K, V> IterableSortedMap<K, V> iterableSortedMap(final SortedMap<K, V> sortedMap) {\n    if (sortedMap == null) {\n        throw new NullPointerException(\"Map must not be null\");\n    }\n    return sortedMap instanceof IterableSortedMap ? (IterableSortedMap<K, V>) sortedMap : new AbstractSortedMapDecorator<K, V>(sortedMap) {\n    };\n}"
            ],
            [
                "defaultEquator",
                "org.apache.commons.collections4.functors",
                "DefaultEquator",
                "/**\n * Factory returning the typed singleton instance.\n *\n * @param <T>  the object type\n * @return the singleton instance\n */\n// the static instance works for all types\n@SuppressWarnings(\"unchecked\")\npublic static <T> DefaultEquator<T> defaultEquator() {\n    return (DefaultEquator<T>) DefaultEquator.INSTANCE;\n}"
            ],
            [
                "stringValueTransformer",
                "org.apache.commons.collections4.functors",
                "StringValueTransformer",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <T>  the input type\n * @return the singleton instance\n * @since 3.1\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Transformer<T, String> stringValueTransformer() {\n    return (Transformer<T, String>) INSTANCE;\n}"
            ],
            [
                "ifTransformer",
                "org.apache.commons.collections4.functors",
                "IfTransformer",
                "/**\n * Factory method that performs validation.\n *\n * @param <I>  input type for the transformer\n * @param <O>  output type for the transformer\n * @param predicate  predicate to switch on\n * @param trueTransformer  transformer used if true\n * @param falseTransformer  transformer used if false\n * @return the <code>if</code> transformer\n * @throws NullPointerException if either argument is null\n */\npublic static <I, O> Transformer<I, O> ifTransformer(final Predicate<? super I> predicate, final Transformer<? super I, ? extends O> trueTransformer, final Transformer<? super I, ? extends O> falseTransformer) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    if (trueTransformer == null || falseTransformer == null) {\n        throw new NullPointerException(\"Transformers must not be null\");\n    }\n    return new IfTransformer<I, O>(predicate, trueTransformer, falseTransformer);\n}"
            ],
            [
                "ifTransformer",
                "org.apache.commons.collections4.functors",
                "IfTransformer",
                "/**\n * Factory method that performs validation.\n * <p>\n * This factory creates a transformer that just returns the input object when\n * the predicate is false.\n *\n * @param <T>  input and output type for the transformer\n * @param predicate  predicate to switch on\n * @param trueTransformer  transformer used if true\n * @return the <code>if</code> transformer\n * @throws NullPointerException if either argument is null\n */\npublic static <T> Transformer<T, T> ifTransformer(final Predicate<? super T> predicate, final Transformer<? super T, ? extends T> trueTransformer) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    if (trueTransformer == null) {\n        throw new NullPointerException(\"Transformer must not be null\");\n    }\n    return new IfTransformer<T, T>(predicate, trueTransformer, NOPTransformer.<T>nopTransformer());\n}"
            ],
            [
                "identityPredicate",
                "org.apache.commons.collections4.functors",
                "IdentityPredicate",
                "/**\n * Factory to create the identity predicate.\n *\n * @param <T> the type that the predicate queries\n * @param object  the object to compare to\n * @return the predicate\n */\npublic static <T> Predicate<T> identityPredicate(final T object) {\n    if (object == null) {\n        return NullPredicate.<T>nullPredicate();\n    }\n    return new IdentityPredicate<T>(object);\n}"
            ],
            [
                "exceptionClosure",
                "org.apache.commons.collections4.functors",
                "ExceptionClosure",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <E> the type that the closure acts on\n * @return the singleton instance\n * @since 3.1\n */\n// the static instance works for all types\n@SuppressWarnings(\"unchecked\")\npublic static <E> Closure<E> exceptionClosure() {\n    return (Closure<E>) INSTANCE;\n}"
            ],
            [
                "nopClosure",
                "org.apache.commons.collections4.functors",
                "NOPClosure",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <E> the type that the closure acts on\n * @return the singleton instance\n * @since 3.1\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Closure<E> nopClosure() {\n    return (Closure<E>) INSTANCE;\n}"
            ],
            [
                "closureTransformer",
                "org.apache.commons.collections4.functors",
                "ClosureTransformer",
                "/**\n * Factory method that performs validation.\n *\n * @param <T>  the type of the object to transform\n * @param closure  the closure to call, not null\n * @return the <code>closure</code> transformer\n * @throws NullPointerException if the closure is null\n */\npublic static <T> Transformer<T, T> closureTransformer(final Closure<? super T> closure) {\n    if (closure == null) {\n        throw new NullPointerException(\"Closure must not be null\");\n    }\n    return new ClosureTransformer<T>(closure);\n}"
            ],
            [
                "copy",
                "org.apache.commons.collections4.functors",
                "FunctorUtils",
                "/**\n * Clone the predicates to ensure that the internal reference can't be messed with.\n * Due to the {@link Predicate#evaluate(T)} method, Predicate<? super T> is\n * able to be coerced to Predicate<T> without casting issues.\n *\n * @param predicates  the predicates to copy\n * @return the cloned predicates\n */\n@SuppressWarnings(\"unchecked\")\nstatic <T> Predicate<T>[] copy(final Predicate<? super T>... predicates) {\n    if (predicates == null) {\n        return null;\n    }\n    return (Predicate<T>[]) predicates.clone();\n}"
            ],
            [
                "coerce",
                "org.apache.commons.collections4.functors",
                "FunctorUtils",
                "/**\n * A very simple method that coerces Predicate<? super T> to Predicate<T>.\n * Due to the {@link Predicate#evaluate(T)} method, Predicate<? super T> is\n * able to be coerced to Predicate<T> without casting issues.\n * <p>This method exists\n * simply as centralised documentation and atomic unchecked warning\n * suppression.\n *\n * @param <T> the type of object the returned predicate should \"accept\"\n * @param predicate the predicate to coerce.\n * @return the coerced predicate.\n */\n@SuppressWarnings(\"unchecked\")\nstatic <T> Predicate<T> coerce(final Predicate<? super T> predicate) {\n    return (Predicate<T>) predicate;\n}"
            ],
            [
                "validate",
                "org.apache.commons.collections4.functors",
                "FunctorUtils",
                "/**\n * Validate the predicates to ensure that all is well.\n *\n * @param predicates  the predicates to validate\n * @return predicate array\n */\nstatic <T> Predicate<? super T>[] validate(final Collection<? extends Predicate<? super T>> predicates) {\n    if (predicates == null) {\n        throw new NullPointerException(\"The predicate collection must not be null\");\n    }\n    // convert to array like this to guarantee iterator() ordering\n    // OK\n    @SuppressWarnings(\"unchecked\")\n    final Predicate<? super T>[] preds = new Predicate[predicates.size()];\n    int i = 0;\n    for (final Predicate<? super T> predicate : predicates) {\n        preds[i] = predicate;\n        if (preds[i] == null) {\n            throw new NullPointerException(\"The predicate collection must not contain a null predicate, index \" + i + \" was null\");\n        }\n        i++;\n    }\n    return preds;\n}"
            ],
            [
                "copy",
                "org.apache.commons.collections4.functors",
                "FunctorUtils",
                "/**\n * Clone the closures to ensure that the internal reference can't be messed with.\n *\n * @param closures  the closures to copy\n * @return the cloned closures\n */\n@SuppressWarnings(\"unchecked\")\nstatic <E> Closure<E>[] copy(final Closure<? super E>... closures) {\n    if (closures == null) {\n        return null;\n    }\n    return (Closure<E>[]) closures.clone();\n}"
            ],
            [
                "coerce",
                "org.apache.commons.collections4.functors",
                "FunctorUtils",
                "/**\n * A very simple method that coerces Closure<? super T> to Closure<T>.\n * <p>This method exists\n * simply as centralised documentation and atomic unchecked warning\n * suppression.\n *\n * @param <T> the type of object the returned closure should \"accept\"\n * @param closure the closure to coerce.\n * @return the coerced closure.\n */\n@SuppressWarnings(\"unchecked\")\nstatic <T> Closure<T> coerce(final Closure<? super T> closure) {\n    return (Closure<T>) closure;\n}"
            ],
            [
                "copy",
                "org.apache.commons.collections4.functors",
                "FunctorUtils",
                "/**\n * Copy method\n *\n * @param transformers  the transformers to copy\n * @return a clone of the transformers\n */\n@SuppressWarnings(\"unchecked\")\nstatic <I, O> Transformer<I, O>[] copy(final Transformer<? super I, ? extends O>... transformers) {\n    if (transformers == null) {\n        return null;\n    }\n    return (Transformer<I, O>[]) transformers.clone();\n}"
            ],
            [
                "coerce",
                "org.apache.commons.collections4.functors",
                "FunctorUtils",
                "/**\n * A very simple method that coerces Transformer<? super I, ? extends O> to Transformer<I, O>.\n * <p>This method exists\n * simply as centralised documentation and atomic unchecked warning\n * suppression.\n *\n * @param <T> the type of object the returned transformer should \"accept\"\n * @param transformer the transformer to coerce.\n * @return the coerced transformer.\n */\n@SuppressWarnings(\"unchecked\")\nstatic <I, O> Transformer<I, O> coerce(final Transformer<? super I, ? extends O> transformer) {\n    return (Transformer<I, O>) transformer;\n}"
            ],
            [
                "transformerPredicate",
                "org.apache.commons.collections4.functors",
                "TransformerPredicate",
                "/**\n * Factory to create the predicate.\n *\n * @param <T> the type that the predicate queries\n * @param transformer  the transformer to decorate\n * @return the predicate\n * @throws NullPointerException if the transformer is null\n */\npublic static <T> Predicate<T> transformerPredicate(final Transformer<? super T, Boolean> transformer) {\n    if (transformer == null) {\n        throw new NullPointerException(\"The transformer to call must not be null\");\n    }\n    return new TransformerPredicate<T>(transformer);\n}"
            ],
            [
                "nullPredicate",
                "org.apache.commons.collections4.functors",
                "NullPredicate",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <T> the type that the predicate queries\n * @return the singleton instance\n * @since 3.1\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Predicate<T> nullPredicate() {\n    return (Predicate<T>) INSTANCE;\n}"
            ],
            [
                "nullTransformer",
                "org.apache.commons.collections4.functors",
                "ConstantTransformer",
                "/**\n * Get a typed null instance.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @return Transformer<I, O> that always returns null.\n */\n// The null transformer works for all object types\n@SuppressWarnings(\"unchecked\")\npublic static <I, O> Transformer<I, O> nullTransformer() {\n    return (Transformer<I, O>) NULL_INSTANCE;\n}"
            ],
            [
                "constantTransformer",
                "org.apache.commons.collections4.functors",
                "ConstantTransformer",
                "/**\n * Transformer method that performs validation.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param constantToReturn  the constant object to return each time in the factory\n * @return the <code>constant</code> factory.\n */\npublic static <I, O> Transformer<I, O> constantTransformer(final O constantToReturn) {\n    if (constantToReturn == null) {\n        return nullTransformer();\n    }\n    return new ConstantTransformer<I, O>(constantToReturn);\n}"
            ],
            [
                "predicateTransformer",
                "org.apache.commons.collections4.functors",
                "PredicateTransformer",
                "/**\n * Factory method that performs validation.\n *\n * @param <T>  the input type\n * @param predicate  the predicate to call, not null\n * @return the <code>predicate</code> transformer\n * @throws IllegalArgumentException if the predicate is null\n */\npublic static <T> Transformer<T, Boolean> predicateTransformer(final Predicate<? super T> predicate) {\n    if (predicate == null) {\n        throw new IllegalArgumentException(\"Predicate must not be null\");\n    }\n    return new PredicateTransformer<T>(predicate);\n}"
            ],
            [
                "whileClosure",
                "org.apache.commons.collections4.functors",
                "WhileClosure",
                "/**\n * Factory method that performs validation.\n *\n * @param <E> the type that the closure acts on\n * @param predicate  the predicate used to evaluate when the loop terminates, not null\n * @param closure  the closure the execute, not null\n * @param doLoop  true to act as a do-while loop, always executing the closure once\n * @return the <code>while</code> closure\n * @throws NullPointerException if the predicate or closure is null\n */\npublic static <E> Closure<E> whileClosure(final Predicate<? super E> predicate, final Closure<? super E> closure, final boolean doLoop) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    if (closure == null) {\n        throw new NullPointerException(\"Closure must not be null\");\n    }\n    return new WhileClosure<E>(predicate, closure, doLoop);\n}"
            ],
            [
                "forClosure",
                "org.apache.commons.collections4.functors",
                "ForClosure",
                "/**\n * Factory method that performs validation.\n * <p>\n * A null closure or zero count returns the <code>NOPClosure</code>.\n * A count of one returns the specified closure.\n *\n * @param <E> the type that the closure acts on\n * @param count  the number of times to execute the closure\n * @param closure  the closure to execute, not null\n * @return the <code>for</code> closure\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Closure<E> forClosure(final int count, final Closure<? super E> closure) {\n    if (count <= 0 || closure == null) {\n        return NOPClosure.<E>nopClosure();\n    }\n    if (count == 1) {\n        return (Closure<E>) closure;\n    }\n    return new ForClosure<E>(count, closure);\n}"
            ],
            [
                "nullIsTruePredicate",
                "org.apache.commons.collections4.functors",
                "NullIsTruePredicate",
                "/**\n * Factory to create the null true predicate.\n *\n * @param <T> the type that the predicate queries\n * @param predicate  the predicate to decorate, not null\n * @return the predicate\n * @throws NullPointerException if the predicate is null\n */\npublic static <T> Predicate<T> nullIsTruePredicate(final Predicate<? super T> predicate) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    return new NullIsTruePredicate<T>(predicate);\n}"
            ],
            [
                "transformedPredicate",
                "org.apache.commons.collections4.functors",
                "TransformedPredicate",
                "/**\n * Factory to create the predicate.\n *\n * @param <T> the type that the predicate queries\n * @param transformer  the transformer to call\n * @param predicate  the predicate to call with the result of the transform\n * @return the predicate\n * @throws NullPointerException if the transformer or the predicate is null\n */\npublic static <T> Predicate<T> transformedPredicate(final Transformer<? super T, ? extends T> transformer, final Predicate<? super T> predicate) {\n    if (transformer == null) {\n        throw new NullPointerException(\"The transformer to call must not be null\");\n    }\n    if (predicate == null) {\n        throw new NullPointerException(\"The predicate to call must not be null\");\n    }\n    return new TransformedPredicate<T>(transformer, predicate);\n}"
            ],
            [
                "nonePredicate",
                "org.apache.commons.collections4.functors",
                "NonePredicate",
                "/**\n * Factory to create the predicate.\n * <p>\n * If the array is size zero, the predicate always returns true.\n *\n * @param <T> the type that the predicate queries\n * @param predicates  the predicates to check, cloned, not null\n * @return the <code>any</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n */\npublic static <T> Predicate<T> nonePredicate(final Predicate<? super T>... predicates) {\n    FunctorUtils.validate(predicates);\n    if (predicates.length == 0) {\n        return TruePredicate.<T>truePredicate();\n    }\n    return new NonePredicate<T>(FunctorUtils.copy(predicates));\n}"
            ],
            [
                "nonePredicate",
                "org.apache.commons.collections4.functors",
                "NonePredicate",
                "/**\n * Factory to create the predicate.\n * <p>\n * If the collection is size zero, the predicate always returns true.\n *\n * @param <T> the type that the predicate queries\n * @param predicates  the predicates to check, cloned, not null\n * @return the <code>one</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n */\npublic static <T> Predicate<T> nonePredicate(final Collection<? extends Predicate<? super T>> predicates) {\n    final Predicate<? super T>[] preds = FunctorUtils.validate(predicates);\n    if (preds.length == 0) {\n        return TruePredicate.<T>truePredicate();\n    }\n    return new NonePredicate<T>(preds);\n}"
            ],
            [
                "exceptionTransformer",
                "org.apache.commons.collections4.functors",
                "ExceptionTransformer",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @return the singleton instance\n * @since 3.1\n */\n// the static instance works for all types\n@SuppressWarnings(\"unchecked\")\npublic static <I, O> Transformer<I, O> exceptionTransformer() {\n    return (Transformer<I, O>) INSTANCE;\n}"
            ],
            [
                "switchTransformer",
                "org.apache.commons.collections4.functors",
                "SwitchTransformer",
                "/**\n * Factory method that performs validation and copies the parameter arrays.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param predicates  array of predicates, cloned, no nulls\n * @param transformers  matching array of transformers, cloned, no nulls\n * @param defaultTransformer  the transformer to use if no match, null means return null\n * @return the <code>chained</code> transformer\n * @throws NullPointerException if array is null\n * @throws NullPointerException if any element in the array is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <I, O> Transformer<I, O> switchTransformer(final Predicate<? super I>[] predicates, final Transformer<? super I, ? extends O>[] transformers, final Transformer<? super I, ? extends O> defaultTransformer) {\n    FunctorUtils.validate(predicates);\n    FunctorUtils.validate(transformers);\n    if (predicates.length != transformers.length) {\n        throw new IllegalArgumentException(\"The predicate and transformer arrays must be the same size\");\n    }\n    if (predicates.length == 0) {\n        return (Transformer<I, O>) (defaultTransformer == null ? ConstantTransformer.<I, O>nullTransformer() : defaultTransformer);\n    }\n    return new SwitchTransformer<I, O>(predicates, transformers, defaultTransformer);\n}"
            ],
            [
                "switchTransformer",
                "org.apache.commons.collections4.functors",
                "SwitchTransformer",
                "/**\n * Create a new Transformer that calls one of the transformers depending\n * on the predicates.\n * <p>\n * The Map consists of Predicate keys and Transformer values. A transformer\n * is called if its matching predicate returns true. Each predicate is evaluated\n * until one returns true. If no predicates evaluate to true, the default\n * transformer is called. The default transformer is set in the map with a\n * null key. The ordering is that of the iterator() method on the entryset\n * collection of the map.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param map  a map of predicates to transformers\n * @return the <code>switch</code> transformer\n * @throws NullPointerException if the map is null\n * @throws NullPointerException if any transformer in the map is null\n * @throws ClassCastException  if the map elements are of the wrong type\n */\n@SuppressWarnings(\"unchecked\")\npublic static <I, O> Transformer<I, O> switchTransformer(final Map<? extends Predicate<? super I>, ? extends Transformer<? super I, ? extends O>> map) {\n    if (map == null) {\n        throw new NullPointerException(\"The predicate and transformer map must not be null\");\n    }\n    if (map.size() == 0) {\n        return ConstantTransformer.<I, O>nullTransformer();\n    }\n    // convert to array like this to guarantee iterator() ordering\n    final Transformer<? super I, ? extends O> defaultTransformer = map.remove(null);\n    final int size = map.size();\n    if (size == 0) {\n        return (Transformer<I, O>) (defaultTransformer == null ? ConstantTransformer.<I, O>nullTransformer() : defaultTransformer);\n    }\n    final Transformer<? super I, ? extends O>[] transformers = new Transformer[size];\n    final Predicate<? super I>[] preds = new Predicate[size];\n    int i = 0;\n    for (final Map.Entry<? extends Predicate<? super I>, ? extends Transformer<? super I, ? extends O>> entry : map.entrySet()) {\n        preds[i] = entry.getKey();\n        transformers[i] = entry.getValue();\n        i++;\n    }\n    return new SwitchTransformer<I, O>(false, preds, transformers, defaultTransformer);\n}"
            ],
            [
                "transformerClosure",
                "org.apache.commons.collections4.functors",
                "TransformerClosure",
                "/**\n * Factory method that performs validation.\n * <p>\n * A null transformer will return the <code>NOPClosure</code>.\n *\n * @param <E> the type that the closure acts on\n * @param transformer  the transformer to call, null means nop\n * @return the <code>transformer</code> closure\n */\npublic static <E> Closure<E> transformerClosure(final Transformer<? super E, ?> transformer) {\n    if (transformer == null) {\n        return NOPClosure.<E>nopClosure();\n    }\n    return new TransformerClosure<E>(transformer);\n}"
            ],
            [
                "orPredicate",
                "org.apache.commons.collections4.functors",
                "OrPredicate",
                "/**\n * Factory to create the predicate.\n *\n * @param <T> the type that the predicate queries\n * @param predicate1  the first predicate to check, not null\n * @param predicate2  the second predicate to check, not null\n * @return the <code>and</code> predicate\n * @throws NullPointerException if either predicate is null\n */\npublic static <T> Predicate<T> orPredicate(final Predicate<? super T> predicate1, final Predicate<? super T> predicate2) {\n    if (predicate1 == null || predicate2 == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    return new OrPredicate<T>(predicate1, predicate2);\n}"
            ],
            [
                "nopTransformer",
                "org.apache.commons.collections4.functors",
                "NOPTransformer",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <T>  the input/output type\n * @return the singleton instance\n * @since 3.1\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Transformer<T, T> nopTransformer() {\n    return (Transformer<T, T>) INSTANCE;\n}"
            ],
            [
                "mapTransformer",
                "org.apache.commons.collections4.functors",
                "MapTransformer",
                "/**\n * Factory to create the transformer.\n * <p>\n * If the map is null, a transformer that always returns null is returned.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param map the map, not cloned\n * @return the transformer\n */\npublic static <I, O> Transformer<I, O> mapTransformer(final Map<? super I, ? extends O> map) {\n    if (map == null) {\n        return ConstantTransformer.<I, O>nullTransformer();\n    }\n    return new MapTransformer<I, O>(map);\n}"
            ],
            [
                "exceptionFactory",
                "org.apache.commons.collections4.functors",
                "ExceptionFactory",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <T>  the type the factory creates\n * @return the singleton instance\n * @since 3.1\n */\n// the static instance works for all types\n@SuppressWarnings(\"unchecked\")\npublic static <T> Factory<T> exceptionFactory() {\n    return (Factory<T>) INSTANCE;\n}"
            ],
            [
                "chainedClosure",
                "org.apache.commons.collections4.functors",
                "ChainedClosure",
                "/**\n * Factory method that performs validation and copies the parameter array.\n *\n * @param <E> the type that the closure acts on\n * @param closures  the closures to chain, copied, no nulls\n * @return the <code>chained</code> closure\n * @throws NullPointerException if the closures array is null\n * @throws NullPointerException if any closure in the array is null\n */\npublic static <E> Closure<E> chainedClosure(final Closure<? super E>... closures) {\n    FunctorUtils.validate(closures);\n    if (closures.length == 0) {\n        return NOPClosure.<E>nopClosure();\n    }\n    return new ChainedClosure<E>(closures);\n}"
            ],
            [
                "chainedClosure",
                "org.apache.commons.collections4.functors",
                "ChainedClosure",
                "/**\n * Create a new Closure that calls each closure in turn, passing the\n * result into the next closure. The ordering is that of the iterator()\n * method on the collection.\n *\n * @param <E> the type that the closure acts on\n * @param closures  a collection of closures to chain\n * @return the <code>chained</code> closure\n * @throws NullPointerException if the closures collection is null\n * @throws NullPointerException if any closure in the collection is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Closure<E> chainedClosure(final Collection<? extends Closure<? super E>> closures) {\n    if (closures == null) {\n        throw new NullPointerException(\"Closure collection must not be null\");\n    }\n    if (closures.size() == 0) {\n        return NOPClosure.<E>nopClosure();\n    }\n    // convert to array like this to guarantee iterator() ordering\n    final Closure<? super E>[] cmds = new Closure[closures.size()];\n    int i = 0;\n    for (final Closure<? super E> closure : closures) {\n        cmds[i++] = closure;\n    }\n    FunctorUtils.validate(cmds);\n    return new ChainedClosure<E>(false, cmds);\n}"
            ],
            [
                "andPredicate",
                "org.apache.commons.collections4.functors",
                "AndPredicate",
                "/**\n * Factory to create the predicate.\n *\n * @param <T> the type that the predicate queries\n * @param predicate1  the first predicate to check, not null\n * @param predicate2  the second predicate to check, not null\n * @return the <code>and</code> predicate\n * @throws NullPointerException if either predicate is null\n */\npublic static <T> Predicate<T> andPredicate(final Predicate<? super T> predicate1, final Predicate<? super T> predicate2) {\n    if (predicate1 == null || predicate2 == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    return new AndPredicate<T>(predicate1, predicate2);\n}"
            ],
            [
                "prototypeFactory",
                "org.apache.commons.collections4.functors",
                "PrototypeFactory",
                "/**\n * Factory method that performs validation.\n * <p>\n * Creates a Factory that will return a clone of the same prototype object\n * each time the factory is used. The prototype will be cloned using one of these\n * techniques (in order):\n * <ul>\n * <li>public clone method\n * <li>public copy constructor\n * <li>serialization clone\n * <ul>\n *\n * @param <T>  the type the factory creates\n * @param prototype  the object to clone each time in the factory\n * @return the <code>prototype</code> factory, or a {@link ConstantFactory#NULL_INSTANCE} if\n * the {@code prototype} is {@code null}\n * @throws IllegalArgumentException if the prototype cannot be cloned\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Factory<T> prototypeFactory(final T prototype) {\n    if (prototype == null) {\n        return ConstantFactory.<T>constantFactory(null);\n    }\n    try {\n        final Method method = prototype.getClass().getMethod(\"clone\", (Class[]) null);\n        return new PrototypeCloneFactory<T>(prototype, method);\n    } catch (final NoSuchMethodException ex) {\n        try {\n            prototype.getClass().getConstructor(new Class<?>[] { prototype.getClass() });\n            return new InstantiateFactory<T>((Class<T>) prototype.getClass(), new Class<?>[] { prototype.getClass() }, new Object[] { prototype });\n        } catch (final NoSuchMethodException ex2) {\n            if (prototype instanceof Serializable) {\n                return (Factory<T>) new PrototypeSerializationFactory<Serializable>((Serializable) prototype);\n            }\n        }\n    }\n    throw new IllegalArgumentException(\"The prototype must be cloneable via a public clone method\");\n}"
            ],
            [
                "exceptionPredicate",
                "org.apache.commons.collections4.functors",
                "ExceptionPredicate",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <T>  the object type\n * @return the singleton instance\n * @since 3.1\n */\n// the static instance works for all types\n@SuppressWarnings(\"unchecked\")\npublic static <T> Predicate<T> exceptionPredicate() {\n    return (Predicate<T>) INSTANCE;\n}"
            ],
            [
                "instanceOfPredicate",
                "org.apache.commons.collections4.functors",
                "InstanceofPredicate",
                "/**\n * Factory to create the identity predicate.\n *\n * @param type  the type to check for, may not be null\n * @return the predicate\n * @throws NullPointerException if the class is null\n */\npublic static Predicate<Object> instanceOfPredicate(final Class<?> type) {\n    if (type == null) {\n        throw new NullPointerException(\"The type to check instanceof must not be null\");\n    }\n    return new InstanceofPredicate(type);\n}"
            ],
            [
                "invokerTransformer",
                "org.apache.commons.collections4.functors",
                "InvokerTransformer",
                "/**\n * Gets an instance of this transformer calling a specific method with no arguments.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param methodName  the method name to call\n * @return an invoker transformer\n * @throws NullPointerException if methodName is null\n * @since 3.1\n */\npublic static <I, O> Transformer<I, O> invokerTransformer(final String methodName) {\n    if (methodName == null) {\n        throw new NullPointerException(\"The method to invoke must not be null\");\n    }\n    return new InvokerTransformer<I, O>(methodName);\n}"
            ],
            [
                "invokerTransformer",
                "org.apache.commons.collections4.functors",
                "InvokerTransformer",
                "/**\n * Gets an instance of this transformer calling a specific method with specific values.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param methodName  the method name to call\n * @param paramTypes  the parameter types of the method\n * @param args  the arguments to pass to the method\n * @return an invoker transformer\n * @throws NullPointerException if methodName is null\n * @throws IllegalArgumentException if paramTypes does not match args\n */\npublic static <I, O> Transformer<I, O> invokerTransformer(final String methodName, final Class<?>[] paramTypes, final Object[] args) {\n    if (methodName == null) {\n        throw new NullPointerException(\"The method to invoke must not be null\");\n    }\n    if (((paramTypes == null) && (args != null)) || ((paramTypes != null) && (args == null)) || ((paramTypes != null) && (args != null) && (paramTypes.length != args.length))) {\n        throw new IllegalArgumentException(\"The parameter types must match the arguments\");\n    }\n    if (paramTypes == null || paramTypes.length == 0) {\n        return new InvokerTransformer<I, O>(methodName);\n    }\n    return new InvokerTransformer<I, O>(methodName, paramTypes, args);\n}"
            ],
            [
                "falsePredicate",
                "org.apache.commons.collections4.functors",
                "FalsePredicate",
                "/**\n * Get a typed instance.\n *\n * @param <T> the type that the predicate queries\n * @return the singleton instance\n * @since 4.0\n */\n// the static instance works for all types\n@SuppressWarnings(\"unchecked\")\npublic static <T> Predicate<T> falsePredicate() {\n    return (Predicate<T>) INSTANCE;\n}"
            ],
            [
                "cloneTransformer",
                "org.apache.commons.collections4.functors",
                "CloneTransformer",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <T>  the type of the objects to be cloned\n * @return the singleton instance\n * @since 3.1\n */\n// the singleton instance works for all types\n@SuppressWarnings(\"unchecked\")\npublic static <T> Transformer<T, T> cloneTransformer() {\n    return INSTANCE;\n}"
            ],
            [
                "notPredicate",
                "org.apache.commons.collections4.functors",
                "NotPredicate",
                "/**\n * Factory to create the not predicate.\n *\n * @param <T> the type that the predicate queries\n * @param predicate  the predicate to decorate, not null\n * @return the predicate\n * @throws NullPointerException if the predicate is null\n */\npublic static <T> Predicate<T> notPredicate(final Predicate<? super T> predicate) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    return new NotPredicate<T>(predicate);\n}"
            ],
            [
                "constantFactory",
                "org.apache.commons.collections4.functors",
                "ConstantFactory",
                "/**\n * Factory method that performs validation.\n *\n * @param <T>  the type of the constant\n * @param constantToReturn  the constant object to return each time in the factory\n * @return the <code>constant</code> factory.\n */\n// The null factory works for all object types\n@SuppressWarnings(\"unchecked\")\npublic static <T> Factory<T> constantFactory(final T constantToReturn) {\n    if (constantToReturn == null) {\n        return (Factory<T>) NULL_INSTANCE;\n    }\n    return new ConstantFactory<T>(constantToReturn);\n}"
            ],
            [
                "chainedTransformer",
                "org.apache.commons.collections4.functors",
                "ChainedTransformer",
                "/**\n * Factory method that performs validation and copies the parameter array.\n *\n * @param <T>  the object type\n * @param transformers  the transformers to chain, copied, no nulls\n * @return the <code>chained</code> transformer\n * @throws NullPointerException if the transformers array is null\n * @throws NullPointerException if any transformer in the array is null\n */\npublic static <T> Transformer<T, T> chainedTransformer(final Transformer<? super T, ? extends T>... transformers) {\n    FunctorUtils.validate(transformers);\n    if (transformers.length == 0) {\n        return NOPTransformer.<T>nopTransformer();\n    }\n    return new ChainedTransformer<T>(transformers);\n}"
            ],
            [
                "chainedTransformer",
                "org.apache.commons.collections4.functors",
                "ChainedTransformer",
                "/**\n * Create a new Transformer that calls each transformer in turn, passing the\n * result into the next transformer. The ordering is that of the iterator()\n * method on the collection.\n *\n * @param <T>  the object type\n * @param transformers  a collection of transformers to chain\n * @return the <code>chained</code> transformer\n * @throws NullPointerException if the transformers collection is null\n * @throws NullPointerException if any transformer in the collection is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Transformer<T, T> chainedTransformer(final Collection<? extends Transformer<? super T, ? extends T>> transformers) {\n    if (transformers == null) {\n        throw new NullPointerException(\"Transformer collection must not be null\");\n    }\n    if (transformers.size() == 0) {\n        return NOPTransformer.<T>nopTransformer();\n    }\n    // convert to array like this to guarantee iterator() ordering\n    final Transformer<T, T>[] cmds = transformers.toArray(new Transformer[transformers.size()]);\n    FunctorUtils.validate(cmds);\n    return new ChainedTransformer<T>(false, cmds);\n}"
            ],
            [
                "comparatorPredicate",
                "org.apache.commons.collections4.functors",
                "ComparatorPredicate",
                "/**\n * Factory to create the comparator predicate\n *\n * @param <T> the type that the predicate queries\n * @param object  the object to compare to\n * @param comparator  the comparator to use for comparison\n * @return the predicate\n * @throws NullPointerException if comparator is null\n */\npublic static <T> Predicate<T> comparatorPredicate(final T object, final Comparator<T> comparator) {\n    return comparatorPredicate(object, comparator, Criterion.EQUAL);\n}"
            ],
            [
                "comparatorPredicate",
                "org.apache.commons.collections4.functors",
                "ComparatorPredicate",
                "/**\n * Factory to create the comparator predicate\n *\n * @param <T> the type that the predicate queries\n * @param object  the object to compare to\n * @param comparator  the comparator to use for comparison\n * @param criterion  the criterion to use to evaluate comparison\n * @return the predicate\n * @throws NullPointerException if comparator or criterion is null\n */\npublic static <T> Predicate<T> comparatorPredicate(final T object, final Comparator<T> comparator, final Criterion criterion) {\n    if (comparator == null) {\n        throw new NullPointerException(\"Comparator must not be null.\");\n    }\n    if (criterion == null) {\n        throw new NullPointerException(\"Criterion must not be null.\");\n    }\n    return new ComparatorPredicate<T>(object, comparator, criterion);\n}"
            ],
            [
                "allPredicate",
                "org.apache.commons.collections4.functors",
                "AllPredicate",
                "/**\n * Factory to create the predicate.\n * <p>\n * If the array is size zero, the predicate always returns true.\n * If the array is size one, then that predicate is returned.\n *\n * @param <T> the type that the predicate queries\n * @param predicates  the predicates to check, cloned, not null\n * @return the <code>all</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n */\npublic static <T> Predicate<T> allPredicate(final Predicate<? super T>... predicates) {\n    FunctorUtils.validate(predicates);\n    if (predicates.length == 0) {\n        return truePredicate();\n    }\n    if (predicates.length == 1) {\n        return coerce(predicates[0]);\n    }\n    return new AllPredicate<T>(FunctorUtils.copy(predicates));\n}"
            ],
            [
                "allPredicate",
                "org.apache.commons.collections4.functors",
                "AllPredicate",
                "/**\n * Factory to create the predicate.\n * <p>\n * If the collection is size zero, the predicate always returns true.\n * If the collection is size one, then that predicate is returned.\n *\n * @param <T> the type that the predicate queries\n * @param predicates  the predicates to check, cloned, not null\n * @return the <code>all</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n */\npublic static <T> Predicate<T> allPredicate(final Collection<? extends Predicate<? super T>> predicates) {\n    final Predicate<? super T>[] preds = validate(predicates);\n    if (preds.length == 0) {\n        return truePredicate();\n    }\n    if (preds.length == 1) {\n        return coerce(preds[0]);\n    }\n    return new AllPredicate<T>(preds);\n}"
            ],
            [
                "nullIsFalsePredicate",
                "org.apache.commons.collections4.functors",
                "NullIsFalsePredicate",
                "/**\n * Factory to create the null false predicate.\n *\n * @param <T> the type that the predicate queries\n * @param predicate  the predicate to decorate, not null\n * @return the predicate\n * @throws NullPointerException if the predicate is null\n */\npublic static <T> Predicate<T> nullIsFalsePredicate(final Predicate<? super T> predicate) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    return new NullIsFalsePredicate<T>(predicate);\n}"
            ],
            [
                "nullIsExceptionPredicate",
                "org.apache.commons.collections4.functors",
                "NullIsExceptionPredicate",
                "/**\n * Factory to create the null exception predicate.\n *\n * @param <T> the type that the predicate queries\n * @param predicate  the predicate to decorate, not null\n * @return the predicate\n * @throws NullPointerException if the predicate is null\n */\npublic static <T> Predicate<T> nullIsExceptionPredicate(final Predicate<? super T> predicate) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    return new NullIsExceptionPredicate<T>(predicate);\n}"
            ],
            [
                "anyPredicate",
                "org.apache.commons.collections4.functors",
                "AnyPredicate",
                "/**\n * Factory to create the predicate.\n * <p>\n * If the array is size zero, the predicate always returns false.\n * If the array is size one, then that predicate is returned.\n *\n * @param <T> the type that the predicate queries\n * @param predicates  the predicates to check, cloned, not null\n * @return the <code>any</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Predicate<T> anyPredicate(final Predicate<? super T>... predicates) {\n    FunctorUtils.validate(predicates);\n    if (predicates.length == 0) {\n        return FalsePredicate.<T>falsePredicate();\n    }\n    if (predicates.length == 1) {\n        return (Predicate<T>) predicates[0];\n    }\n    return new AnyPredicate<T>(FunctorUtils.copy(predicates));\n}"
            ],
            [
                "anyPredicate",
                "org.apache.commons.collections4.functors",
                "AnyPredicate",
                "/**\n * Factory to create the predicate.\n * <p>\n * If the collection is size zero, the predicate always returns false.\n * If the collection is size one, then that predicate is returned.\n *\n * @param <T> the type that the predicate queries\n * @param predicates  the predicates to check, cloned, not null\n * @return the <code>all</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Predicate<T> anyPredicate(final Collection<? extends Predicate<? super T>> predicates) {\n    final Predicate<? super T>[] preds = FunctorUtils.validate(predicates);\n    if (preds.length == 0) {\n        return FalsePredicate.<T>falsePredicate();\n    }\n    if (preds.length == 1) {\n        return (Predicate<T>) preds[0];\n    }\n    return new AnyPredicate<T>(preds);\n}"
            ],
            [
                "truePredicate",
                "org.apache.commons.collections4.functors",
                "TruePredicate",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <T> the type that the predicate queries\n * @return the singleton instance\n * @since 3.1\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Predicate<T> truePredicate() {\n    return (Predicate<T>) INSTANCE;\n}"
            ],
            [
                "factoryTransformer",
                "org.apache.commons.collections4.functors",
                "FactoryTransformer",
                "/**\n * Factory method that performs validation.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param factory  the factory to call, not null\n * @return the <code>factory</code> transformer\n * @throws NullPointerException if the factory is null\n */\npublic static <I, O> Transformer<I, O> factoryTransformer(final Factory<? extends O> factory) {\n    if (factory == null) {\n        throw new NullPointerException(\"Factory must not be null\");\n    }\n    return new FactoryTransformer<I, O>(factory);\n}"
            ],
            [
                "notNullPredicate",
                "org.apache.commons.collections4.functors",
                "NotNullPredicate",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <T> the type that the predicate queries\n * @return the singleton instance\n * @since 3.1\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Predicate<T> notNullPredicate() {\n    return (Predicate<T>) INSTANCE;\n}"
            ],
            [
                "switchClosure",
                "org.apache.commons.collections4.functors",
                "SwitchClosure",
                "/**\n * Factory method that performs validation and copies the parameter arrays.\n *\n * @param <E> the type that the closure acts on\n * @param predicates  array of predicates, cloned, no nulls\n * @param closures  matching array of closures, cloned, no nulls\n * @param defaultClosure  the closure to use if no match, null means nop\n * @return the <code>chained</code> closure\n * @throws NullPointerException if array is null\n * @throws NullPointerException if any element in the array is null\n * @throws IllegalArgumentException if the array lengths of predicates and closures do not match\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Closure<E> switchClosure(final Predicate<? super E>[] predicates, final Closure<? super E>[] closures, final Closure<? super E> defaultClosure) {\n    FunctorUtils.validate(predicates);\n    FunctorUtils.validate(closures);\n    if (predicates.length != closures.length) {\n        throw new IllegalArgumentException(\"The predicate and closure arrays must be the same size\");\n    }\n    if (predicates.length == 0) {\n        return (Closure<E>) (defaultClosure == null ? NOPClosure.<E>nopClosure() : defaultClosure);\n    }\n    return new SwitchClosure<E>(predicates, closures, defaultClosure);\n}"
            ],
            [
                "switchClosure",
                "org.apache.commons.collections4.functors",
                "SwitchClosure",
                "/**\n * Create a new Closure that calls one of the closures depending\n * on the predicates.\n * <p>\n * The Map consists of Predicate keys and Closure values. A closure\n * is called if its matching predicate returns true. Each predicate is evaluated\n * until one returns true. If no predicates evaluate to true, the default\n * closure is called. The default closure is set in the map with a\n * null key. The ordering is that of the iterator() method on the entryset\n * collection of the map.\n *\n * @param <E> the type that the closure acts on\n * @param predicatesAndClosures  a map of predicates to closures\n * @return the <code>switch</code> closure\n * @throws NullPointerException if the map is null\n * @throws NullPointerException if any closure in the map is null\n * @throws ClassCastException  if the map elements are of the wrong type\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Closure<E> switchClosure(final Map<Predicate<E>, Closure<E>> predicatesAndClosures) {\n    if (predicatesAndClosures == null) {\n        throw new NullPointerException(\"The predicate and closure map must not be null\");\n    }\n    // convert to array like this to guarantee iterator() ordering\n    final Closure<? super E> defaultClosure = predicatesAndClosures.remove(null);\n    final int size = predicatesAndClosures.size();\n    if (size == 0) {\n        return (Closure<E>) (defaultClosure == null ? NOPClosure.<E>nopClosure() : defaultClosure);\n    }\n    final Closure<E>[] closures = new Closure[size];\n    final Predicate<E>[] preds = new Predicate[size];\n    int i = 0;\n    for (final Map.Entry<Predicate<E>, Closure<E>> entry : predicatesAndClosures.entrySet()) {\n        preds[i] = entry.getKey();\n        closures[i] = entry.getValue();\n        i++;\n    }\n    return new SwitchClosure<E>(false, preds, closures, defaultClosure);\n}"
            ],
            [
                "uniquePredicate",
                "org.apache.commons.collections4.functors",
                "UniquePredicate",
                "/**\n * Factory to create the predicate.\n *\n * @param <T> the type that the predicate queries\n * @return the predicate\n * @throws IllegalArgumentException if the predicate is null\n */\npublic static <T> Predicate<T> uniquePredicate() {\n    return new UniquePredicate<T>();\n}"
            ],
            [
                "instantiateTransformer",
                "org.apache.commons.collections4.functors",
                "InstantiateTransformer",
                "/**\n * Get a typed no-arg instance.\n *\n * @param <T>  the type of the objects to be created\n * @return Transformer<Class<? extends T>, T>\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Transformer<Class<? extends T>, T> instantiateTransformer() {\n    return NO_ARG_INSTANCE;\n}"
            ],
            [
                "instantiateTransformer",
                "org.apache.commons.collections4.functors",
                "InstantiateTransformer",
                "/**\n * Transformer method that performs validation.\n *\n * @param <T>  the type of the objects to be created\n * @param paramTypes  the constructor parameter types\n * @param args  the constructor arguments\n * @return an instantiate transformer\n * @throws IllegalArgumentException if paramTypes does not match args\n */\npublic static <T> Transformer<Class<? extends T>, T> instantiateTransformer(final Class<?>[] paramTypes, final Object[] args) {\n    if (((paramTypes == null) && (args != null)) || ((paramTypes != null) && (args == null)) || ((paramTypes != null) && (args != null) && (paramTypes.length != args.length))) {\n        throw new IllegalArgumentException(\"Parameter types must match the arguments\");\n    }\n    if (paramTypes == null || paramTypes.length == 0) {\n        return new InstantiateTransformer<T>();\n    }\n    return new InstantiateTransformer<T>(paramTypes, args);\n}"
            ],
            [
                "onePredicate",
                "org.apache.commons.collections4.functors",
                "OnePredicate",
                "/**\n * Factory to create the predicate.\n * <p>\n * If the array is size zero, the predicate always returns false.\n * If the array is size one, then that predicate is returned.\n *\n * @param <T> the type that the predicate queries\n * @param predicates  the predicates to check, cloned, not null\n * @return the <code>any</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Predicate<T> onePredicate(final Predicate<? super T>... predicates) {\n    FunctorUtils.validate(predicates);\n    if (predicates.length == 0) {\n        return FalsePredicate.<T>falsePredicate();\n    }\n    if (predicates.length == 1) {\n        return (Predicate<T>) predicates[0];\n    }\n    return new OnePredicate<T>(FunctorUtils.copy(predicates));\n}"
            ],
            [
                "onePredicate",
                "org.apache.commons.collections4.functors",
                "OnePredicate",
                "/**\n * Factory to create the predicate.\n *\n * @param <T> the type that the predicate queries\n * @param predicates  the predicates to check, cloned, not null\n * @return the <code>one</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n */\npublic static <T> Predicate<T> onePredicate(final Collection<? extends Predicate<? super T>> predicates) {\n    final Predicate<? super T>[] preds = FunctorUtils.validate(predicates);\n    return new OnePredicate<T>(preds);\n}"
            ],
            [
                "equalPredicate",
                "org.apache.commons.collections4.functors",
                "EqualPredicate",
                "/**\n * Factory to create the predicate.\n *\n * @param <T> the type that the predicate queries\n * @param object  the object to compare to\n * @return the predicate\n */\npublic static <T> Predicate<T> equalPredicate(final T object) {\n    if (object == null) {\n        return NullPredicate.nullPredicate();\n    }\n    return new EqualPredicate<T>(object);\n}"
            ],
            [
                "equalPredicate",
                "org.apache.commons.collections4.functors",
                "EqualPredicate",
                "/**\n * Factory to create the identity predicate.\n *\n * @param <T> the type that the predicate queries\n * @param object  the object to compare to\n * @param equator  the equator to use for comparison\n * @return the predicate\n * @since 4.0\n */\npublic static <T> Predicate<T> equalPredicate(final T object, final Equator<T> equator) {\n    if (object == null) {\n        return NullPredicate.nullPredicate();\n    }\n    return new EqualPredicate<T>(object, equator);\n}"
            ],
            [
                "instantiateFactory",
                "org.apache.commons.collections4.functors",
                "InstantiateFactory",
                "/**\n * Factory method that performs validation.\n *\n * @param <T>  the type the factory creates\n * @param classToInstantiate  the class to instantiate, not null\n * @param paramTypes  the constructor parameter types, cloned\n * @param args  the constructor arguments, cloned\n * @return a new instantiate factory\n * @throws NullPointerException if classToInstantiate is null\n * @throws IllegalArgumentException if paramTypes does not match args\n */\npublic static <T> Factory<T> instantiateFactory(final Class<T> classToInstantiate, final Class<?>[] paramTypes, final Object[] args) {\n    if (classToInstantiate == null) {\n        throw new NullPointerException(\"Class to instantiate must not be null\");\n    }\n    if (paramTypes == null && args != null || paramTypes != null && args == null || paramTypes != null && args != null && paramTypes.length != args.length) {\n        throw new IllegalArgumentException(\"Parameter types must match the arguments\");\n    }\n    if (paramTypes == null || paramTypes.length == 0) {\n        return new InstantiateFactory<T>(classToInstantiate);\n    }\n    return new InstantiateFactory<T>(classToInstantiate, paramTypes, args);\n}"
            ],
            [
                "ifClosure",
                "org.apache.commons.collections4.functors",
                "IfClosure",
                "/**\n * Factory method that performs validation.\n * <p>\n * This factory creates a closure that performs no action when\n * the predicate is false.\n *\n * @param <E> the type that the closure acts on\n * @param predicate  predicate to switch on\n * @param trueClosure  closure used if true\n * @return the <code>if</code> closure\n * @throws NullPointerException if either argument is null\n * @since 3.2\n */\npublic static <E> Closure<E> ifClosure(final Predicate<? super E> predicate, final Closure<? super E> trueClosure) {\n    return IfClosure.<E>ifClosure(predicate, trueClosure, NOPClosure.<E>nopClosure());\n}"
            ],
            [
                "ifClosure",
                "org.apache.commons.collections4.functors",
                "IfClosure",
                "/**\n * Factory method that performs validation.\n *\n * @param <E> the type that the closure acts on\n * @param predicate  predicate to switch on\n * @param trueClosure  closure used if true\n * @param falseClosure  closure used if false\n * @return the <code>if</code> closure\n * @throws NullPointerException if any argument is null\n */\npublic static <E> Closure<E> ifClosure(final Predicate<? super E> predicate, final Closure<? super E> trueClosure, final Closure<? super E> falseClosure) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    if (trueClosure == null || falseClosure == null) {\n        throw new NullPointerException(\"Closures must not be null\");\n    }\n    return new IfClosure<E>(predicate, trueClosure, falseClosure);\n}"
            ],
            [
                "getTrueFirstComparator",
                "org.apache.commons.collections4.comparators",
                "BooleanComparator",
                "//-----------------------------------------------------------------------\n/**\n * Returns a BooleanComparator instance that sorts\n * <code>true</code> values before <code>false</code> values.\n * <p />\n * Clients are encouraged to use the value returned from\n * this method instead of constructing a new instance\n * to reduce allocation and garbage collection overhead when\n * multiple BooleanComparators may be used in the same\n * virtual machine.\n *\n * @return the true first singleton BooleanComparator\n */\npublic static BooleanComparator getTrueFirstComparator() {\n    return TRUE_FIRST;\n}"
            ],
            [
                "getFalseFirstComparator",
                "org.apache.commons.collections4.comparators",
                "BooleanComparator",
                "/**\n * Returns a BooleanComparator instance that sorts\n * <code>false</code> values before <code>true</code> values.\n * <p />\n * Clients are encouraged to use the value returned from\n * this method instead of constructing a new instance\n * to reduce allocation and garbage collection overhead when\n * multiple BooleanComparators may be used in the same\n * virtual machine.\n *\n * @return the false first singleton BooleanComparator\n */\npublic static BooleanComparator getFalseFirstComparator() {\n    return FALSE_FIRST;\n}"
            ],
            [
                "booleanComparator",
                "org.apache.commons.collections4.comparators",
                "BooleanComparator",
                "/**\n * Returns a BooleanComparator instance that sorts\n * <code><i>trueFirst</i></code> values before\n * <code>&#x21;<i>trueFirst</i></code> values.\n * <p />\n * Clients are encouraged to use the value returned from\n * this method instead of constructing a new instance\n * to reduce allocation and garbage collection overhead when\n * multiple BooleanComparators may be used in the same\n * virtual machine.\n *\n * @param trueFirst when <code>true</code>, sort\n * <code>true</code> <code>Boolean</code>s before <code>false</code>\n * @return a singleton BooleanComparator instance\n * @since 4.0\n */\npublic static BooleanComparator booleanComparator(final boolean trueFirst) {\n    return trueFirst ? TRUE_FIRST : FALSE_FIRST;\n}"
            ],
            [
                "comparableComparator",
                "org.apache.commons.collections4.comparators",
                "ComparableComparator",
                "//-----------------------------------------------------------------------\n/**\n * Gets the singleton instance of a ComparableComparator.\n * <p>\n * Developers are encouraged to use the comparator returned from this method\n * instead of constructing a new instance to reduce allocation and GC overhead\n * when multiple comparable comparators may be used in the same VM.\n *\n * @param <E>  the element type\n * @return the singleton ComparableComparator\n * @since 4.0\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E extends Comparable<? super E>> ComparableComparator<E> comparableComparator() {\n    return INSTANCE;\n}"
            ],
            [
                "emptyCollection",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns the immutable EMPTY_COLLECTION with generic type safety.\n *\n * @see #EMPTY_COLLECTION\n * @since 4.0\n * @param <T> the element type\n * @return immutable empty collection\n */\n// OK, empty collection is compatible with any type\n@SuppressWarnings(\"unchecked\")\npublic static <T> Collection<T> emptyCollection() {\n    return EMPTY_COLLECTION;\n}"
            ],
            [
                "emptyIfNull",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns an immutable empty collection if the argument is <code>null</code>,\n * or the argument itself otherwise.\n *\n * @param <T> the element type\n * @param collection the collection, possibly <code>null</code>\n * @return an empty collection if the argument is <code>null</code>\n */\n// OK, empty collection is compatible with any type\n@SuppressWarnings(\"unchecked\")\npublic static <T> Collection<T> emptyIfNull(final Collection<T> collection) {\n    return collection == null ? EMPTY_COLLECTION : collection;\n}"
            ],
            [
                "union",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns a {@link Collection} containing the union of the given\n * {@link Iterable}s.\n * <p>\n * The cardinality of each element in the returned {@link Collection} will\n * be equal to the maximum of the cardinality of that element in the two\n * given {@link Iterable}s.\n *\n * @param a the first collection, must not be null\n * @param b the second collection, must not be null\n * @param <O> the generic type that is able to represent the types contained\n *        in both input collections.\n * @return the union of the two collections\n * @see Collection#addAll\n */\npublic static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}"
            ],
            [
                "intersection",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns a {@link Collection} containing the intersection of the given\n * {@link Iterable}s.\n * <p>\n * The cardinality of each element in the returned {@link Collection} will\n * be equal to the minimum of the cardinality of that element in the two\n * given {@link Iterable}s.\n *\n * @param a the first collection, must not be null\n * @param b the second collection, must not be null\n * @param <O> the generic type that is able to represent the types contained\n *        in both input collections.\n * @return the intersection of the two collections\n * @see Collection#retainAll\n * @see #containsAny\n */\npublic static <O> Collection<O> intersection(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.min(obj));\n    }\n    return helper.list();\n}"
            ],
            [
                "disjunction",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns a {@link Collection} containing the exclusive disjunction\n * (symmetric difference) of the given {@link Iterable}s.\n * <p>\n * The cardinality of each element <i>e</i> in the returned\n * {@link Collection} will be equal to\n * <tt>max(cardinality(<i>e</i>,<i>a</i>),cardinality(<i>e</i>,<i>b</i>)) - min(cardinality(<i>e</i>,<i>a</i>),\n * cardinality(<i>e</i>,<i>b</i>))</tt>.\n * <p>\n * This is equivalent to\n * {@code {@link #subtract subtract}({@link #union union(a,b)},{@link #intersection intersection(a,b)})}\n * or\n * {@code {@link #union union}({@link #subtract subtract(a,b)},{@link #subtract subtract(b,a)})}.\n *\n * @param a the first collection, must not be null\n * @param b the second collection, must not be null\n * @param <O> the generic type that is able to represent the types contained\n *        in both input collections.\n * @return the symmetric difference of the two collections\n */\npublic static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}"
            ],
            [
                "subtract",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns a new {@link Collection} containing {@code <i>a</i> - <i>b</i>}.\n * The cardinality of each element <i>e</i> in the returned {@link Collection}\n * will be the cardinality of <i>e</i> in <i>a</i> minus the cardinality\n * of <i>e</i> in <i>b</i>, or zero, whichever is greater.\n *\n * @param a  the collection to subtract from, must not be null\n * @param b  the collection to subtract, must not be null\n * @param <O> the generic type that is able to represent the types contained\n *        in both input collections.\n * @return a new collection with the results\n * @see Collection#removeAll\n */\npublic static <O> Collection<O> subtract(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n    final Predicate<O> p = TruePredicate.truePredicate();\n    return subtract(a, b, p);\n}"
            ],
            [
                "subtract",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns a new {@link Collection} containing <i>a</i> minus a subset of\n * <i>b</i>.  Only the elements of <i>b</i> that satisfy the predicate\n * condition, <i>p</i> are subtracted from <i>a</i>.\n *\n * <p>The cardinality of each element <i>e</i> in the returned {@link Collection}\n * that satisfies the predicate condition will be the cardinality of <i>e</i> in <i>a</i>\n * minus the cardinality of <i>e</i> in <i>b</i>, or zero, whichever is greater.</p>\n * <p>The cardinality of each element <i>e</i> in the returned {@link Collection} that does <b>not</b>\n * satisfy the predicate condition will be equal to the cardinality of <i>e</i> in <i>a</i>.</p>\n *\n * @param a  the collection to subtract from, must not be null\n * @param b  the collection to subtract, must not be null\n * @param p  the condition used to determine which elements of <i>b</i> are\n *        subtracted.\n * @param <O> the generic type that is able to represent the types contained\n *        in both input collections.\n * @return a new collection with the results\n * @since 4.0\n * @see Collection#removeAll\n */\npublic static <O> Collection<O> subtract(final Iterable<? extends O> a, final Iterable<? extends O> b, final Predicate<O> p) {\n    final ArrayList<O> list = new ArrayList<O>();\n    final HashBag<O> bag = new HashBag<O>();\n    for (final O element : b) {\n        if (p.evaluate(element)) {\n            bag.add(element);\n        }\n    }\n    for (final O element : a) {\n        if (!bag.remove(element, 1)) {\n            list.add(element);\n        }\n    }\n    return list;\n}"
            ],
            [
                "containsAll",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns <code>true</code> iff all elements of {@code coll2} are also contained\n * in {@code coll1}. The cardinality of values in {@code coll2} is not taken into account,\n * which is the same behavior as {@link Collection#containsAll(Collection)}.\n * <p>\n * In other words, this method returns <code>true</code> iff the\n * {@link #intersection} of <i>coll1</i> and <i>coll2</i> has the same cardinality as\n * the set of unique values from {@code coll2}. In case {@code coll2} is empty, {@code true}\n * will be returned.\n * <p>\n * This method is intended as a replacement for {@link Collection#containsAll(Collection)}\n * with a guaranteed runtime complexity of {@code O(n + m)}. Depending on the type of\n * {@link Collection} provided, this method will be much faster than calling\n * {@link Collection#containsAll(Collection)} instead, though this will come at the\n * cost of an additional space complexity O(n).\n *\n * @param coll1  the first collection, must not be null\n * @param coll2  the second collection, must not be null\n * @return <code>true</code> iff the intersection of the collections has the same cardinality\n *   as the set of unique elements from the second collection\n * @since 4.0\n */\npublic static boolean containsAll(final Collection<?> coll1, final Collection<?> coll2) {\n    if (coll2.isEmpty()) {\n        return true;\n    } else {\n        final Iterator<?> it = coll1.iterator();\n        final Set<Object> elementsAlreadySeen = new HashSet<Object>();\n        for (final Object nextElement : coll2) {\n            if (elementsAlreadySeen.contains(nextElement)) {\n                continue;\n            }\n            boolean foundCurrentElement = false;\n            while (it.hasNext()) {\n                final Object p = it.next();\n                elementsAlreadySeen.add(p);\n                if (nextElement == null ? p == null : nextElement.equals(p)) {\n                    foundCurrentElement = true;\n                    break;\n                }\n            }\n            if (foundCurrentElement) {\n                continue;\n            } else {\n                return false;\n            }\n        }\n        return true;\n    }\n}"
            ],
            [
                "containsAny",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns <code>true</code> iff at least one element is in both collections.\n * <p>\n * In other words, this method returns <code>true</code> iff the\n * {@link #intersection} of <i>coll1</i> and <i>coll2</i> is not empty.\n *\n * @param coll1  the first collection, must not be null\n * @param coll2  the second collection, must not be null\n * @return <code>true</code> iff the intersection of the collections is non-empty\n * @since 2.1\n * @see #intersection\n */\npublic static boolean containsAny(final Collection<?> coll1, final Collection<?> coll2) {\n    if (coll1.size() < coll2.size()) {\n        for (final Object aColl1 : coll1) {\n            if (coll2.contains(aColl1)) {\n                return true;\n            }\n        }\n    } else {\n        for (final Object aColl2 : coll2) {\n            if (coll1.contains(aColl2)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}"
            ],
            [
                "getCardinalityMap",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns a {@link Map} mapping each unique element in the given\n * {@link Collection} to an {@link Integer} representing the number\n * of occurrences of that element in the {@link Collection}.\n * <p>\n * Only those elements present in the collection will appear as\n * keys in the map.\n *\n * @param <O>  the type of object in the returned {@link Map}. This is a super type of <I>.\n * @param coll  the collection to get the cardinality map for, must not be null\n * @return the populated cardinality map\n */\npublic static <O> Map<O, Integer> getCardinalityMap(final Iterable<? extends O> coll) {\n    final Map<O, Integer> count = new HashMap<O, Integer>();\n    for (final O obj : coll) {\n        final Integer c = count.get(obj);\n        if (c == null) {\n            count.put(obj, Integer.valueOf(1));\n        } else {\n            count.put(obj, Integer.valueOf(c.intValue() + 1));\n        }\n    }\n    return count;\n}"
            ],
            [
                "isSubCollection",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns {@code true} iff <i>a</i> is a sub-collection of <i>b</i>,\n * that is, iff the cardinality of <i>e</i> in <i>a</i> is less than or\n * equal to the cardinality of <i>e</i> in <i>b</i>, for each element <i>e</i>\n * in <i>a</i>.\n *\n * @param a the first (sub?) collection, must not be null\n * @param b the second (super?) collection, must not be null\n * @return <code>true</code> iff <i>a</i> is a sub-collection of <i>b</i>\n * @see #isProperSubCollection\n * @see Collection#containsAll\n */\npublic static boolean isSubCollection(final Collection<?> a, final Collection<?> b) {\n    final CardinalityHelper<Object> helper = new CardinalityHelper<Object>(a, b);\n    for (final Object obj : a) {\n        if (helper.freqA(obj) > helper.freqB(obj)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isProperSubCollection",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns {@code true} iff <i>a</i> is a <i>proper</i> sub-collection of <i>b</i>,\n * that is, iff the cardinality of <i>e</i> in <i>a</i> is less\n * than or equal to the cardinality of <i>e</i> in <i>b</i>,\n * for each element <i>e</i> in <i>a</i>, and there is at least one\n * element <i>f</i> such that the cardinality of <i>f</i> in <i>b</i>\n * is strictly greater than the cardinality of <i>f</i> in <i>a</i>.\n * <p>\n * The implementation assumes\n * <ul>\n *    <li><code>a.size()</code> and <code>b.size()</code> represent the\n *    total cardinality of <i>a</i> and <i>b</i>, resp. </li>\n *    <li><code>a.size() < Integer.MAXVALUE</code></li>\n * </ul>\n *\n * @param a  the first (sub?) collection, must not be null\n * @param b  the second (super?) collection, must not be null\n * @return <code>true</code> iff <i>a</i> is a <i>proper</i> sub-collection of <i>b</i>\n * @see #isSubCollection\n * @see Collection#containsAll\n */\npublic static boolean isProperSubCollection(final Collection<?> a, final Collection<?> b) {\n    return a.size() < b.size() && CollectionUtils.isSubCollection(a, b);\n}"
            ],
            [
                "isEqualCollection",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns {@code true} iff the given {@link Collection}s contain\n * exactly the same elements with exactly the same cardinalities.\n * <p>\n * That is, iff the cardinality of <i>e</i> in <i>a</i> is\n * equal to the cardinality of <i>e</i> in <i>b</i>,\n * for each element <i>e</i> in <i>a</i> or <i>b</i>.\n *\n * @param a  the first collection, must not be null\n * @param b  the second collection, must not be null\n * @return <code>true</code> iff the collections contain the same elements with the same cardinalities.\n */\npublic static boolean isEqualCollection(final Collection<?> a, final Collection<?> b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n    final CardinalityHelper<Object> helper = new CardinalityHelper<Object>(a, b);\n    if (helper.cardinalityA.size() != helper.cardinalityB.size()) {\n        return false;\n    }\n    for (final Object obj : helper.cardinalityA.keySet()) {\n        if (helper.freqA(obj) != helper.freqB(obj)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isEqualCollection",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns {@code true} iff the given {@link Collection}s contain\n * exactly the same elements with exactly the same cardinalities.\n * <p>\n * That is, iff the cardinality of <i>e</i> in <i>a</i> is\n * equal to the cardinality of <i>e</i> in <i>b</i>,\n * for each element <i>e</i> in <i>a</i> or <i>b</i>.\n * <p>\n * <b>Note:</b> from version 4.1 onwards this method requires the input\n * collections and equator to be of compatible type (using bounded wildcards).\n * Providing incompatible arguments (e.g. by casting to their rawtypes)\n * will result in a {@code ClassCastException} thrown at runtime.\n *\n * @param <E>  the element type\n * @param a  the first collection, must not be null\n * @param b  the second collection, must not be null\n * @param equator  the Equator used for testing equality\n * @return <code>true</code> iff the collections contain the same elements with the same cardinalities.\n * @throws NullPointerException if the equator is null\n * @since 4.0\n */\npublic static <E> boolean isEqualCollection(final Collection<? extends E> a, final Collection<? extends E> b, final Equator<? super E> equator) {\n    if (equator == null) {\n        throw new NullPointerException(\"Equator must not be null.\");\n    }\n    if (a.size() != b.size()) {\n        return false;\n    }\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    final Transformer<E, ?> transformer = new Transformer() {\n\n        public EquatorWrapper<?> transform(final Object input) {\n            return new EquatorWrapper(equator, input);\n        }\n    };\n    return isEqualCollection(collect(a, transformer), collect(b, transformer));\n}"
            ],
            [
                "cardinality",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns the number of occurrences of <i>obj</i> in <i>coll</i>.\n *\n * @param obj the object to find the cardinality of\n * @param coll the {@link Iterable} to search\n * @param <O> the type of object that the {@link Iterable} may contain.\n * @return the the number of occurrences of obj in coll\n * @throws NullPointerException if coll is null\n * @deprecated since 4.1, use {@link IterableUtils#frequency(Iterable, Object)} instead.\n *   Be aware that the order of parameters has changed.\n */\n@Deprecated\npublic static <O> int cardinality(final O obj, final Iterable<? super O> coll) {\n    if (coll == null) {\n        throw new NullPointerException(\"coll must not be null.\");\n    }\n    return IterableUtils.frequency(coll, obj);\n}"
            ],
            [
                "find",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Finds the first element in the given collection which matches the given predicate.\n * <p>\n * If the input collection or predicate is null, or no element of the collection\n * matches the predicate, null is returned.\n *\n * @param <T>  the type of object the {@link Iterable} contains\n * @param collection  the collection to search, may be null\n * @param predicate  the predicate to use, may be null\n * @return the first element of the collection which matches the predicate or null if none could be found\n * @deprecated since 4.1, use {@link IterableUtils#find(Iterable, Predicate)} instead\n */\n@Deprecated\npublic static <T> T find(final Iterable<T> collection, final Predicate<? super T> predicate) {\n    return predicate != null ? IterableUtils.find(collection, predicate) : null;\n}"
            ],
            [
                "forAllDo",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Executes the given closure on each element in the collection.\n * <p>\n * If the input collection or closure is null, there is no change made.\n *\n * @param <T>  the type of object the {@link Iterable} contains\n * @param <C>  the closure type\n * @param collection  the collection to get the input from, may be null\n * @param closure  the closure to perform, may be null\n * @return closure\n * @deprecated since 4.1, use {@link IterableUtils#forEach(Iterable, Closure)} instead\n */\n@Deprecated\npublic static <T, C extends Closure<? super T>> C forAllDo(final Iterable<T> collection, final C closure) {\n    if (closure != null) {\n        IterableUtils.forEach(collection, closure);\n    }\n    return closure;\n}"
            ],
            [
                "forAllDo",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Executes the given closure on each element in the collection.\n * <p>\n * If the input collection or closure is null, there is no change made.\n *\n * @param <T>  the type of object the {@link Iterator} contains\n * @param <C>  the closure type\n * @param iterator  the iterator to get the input from, may be null\n * @param closure  the closure to perform, may be null\n * @return closure\n * @since 4.0\n * @deprecated since 4.1, use {@link IteratorUtils#forEach(Iterator, Closure)} instead\n */\n@Deprecated\npublic static <T, C extends Closure<? super T>> C forAllDo(final Iterator<T> iterator, final C closure) {\n    if (closure != null) {\n        IteratorUtils.forEach(iterator, closure);\n    }\n    return closure;\n}"
            ],
            [
                "forAllButLastDo",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Executes the given closure on each but the last element in the collection.\n * <p>\n * If the input collection or closure is null, there is no change made.\n *\n * @param <T>  the type of object the {@link Iterable} contains\n * @param <C>  the closure type\n * @param collection  the collection to get the input from, may be null\n * @param closure  the closure to perform, may be null\n * @return the last element in the collection, or null if either collection or closure is null\n * @since 4.0\n * @deprecated since 4.1, use {@link IterableUtils#forEachButLast(Iterable, Closure)} instead\n */\n@Deprecated\npublic static <T, C extends Closure<? super T>> T forAllButLastDo(final Iterable<T> collection, final C closure) {\n    return closure != null ? IterableUtils.forEachButLast(collection, closure) : null;\n}"
            ],
            [
                "forAllButLastDo",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Executes the given closure on each but the last element in the collection.\n * <p>\n * If the input collection or closure is null, there is no change made.\n *\n * @param <T>  the type of object the {@link Collection} contains\n * @param <C>  the closure type\n * @param iterator  the iterator to get the input from, may be null\n * @param closure  the closure to perform, may be null\n * @return the last element in the collection, or null if either iterator or closure is null\n * @since 4.0\n * @deprecated since 4.1, use {@link IteratorUtils#forEachButLast(Iterator, Closure)} instead\n */\n@Deprecated\npublic static <T, C extends Closure<? super T>> T forAllButLastDo(final Iterator<T> iterator, final C closure) {\n    return closure != null ? IteratorUtils.forEachButLast(iterator, closure) : null;\n}"
            ],
            [
                "filter",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Filter the collection by applying a Predicate to each element. If the\n * predicate returns false, remove the element.\n * <p>\n * If the input collection or predicate is null, there is no change made.\n *\n * @param <T>  the type of object the {@link Iterable} contains\n * @param collection  the collection to get the input from, may be null\n * @param predicate  the predicate to use as a filter, may be null\n * @return true if the collection is modified by this call, false otherwise.\n */\npublic static <T> boolean filter(final Iterable<T> collection, final Predicate<? super T> predicate) {\n    boolean result = false;\n    if (collection != null && predicate != null) {\n        for (final Iterator<T> it = collection.iterator(); it.hasNext(); ) {\n            if (!predicate.evaluate(it.next())) {\n                it.remove();\n                result = true;\n            }\n        }\n    }\n    return result;\n}"
            ],
            [
                "filterInverse",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Filter the collection by applying a Predicate to each element. If the\n * predicate returns true, remove the element.\n * <p>\n * This is equivalent to <pre>filter(collection, PredicateUtils.notPredicate(predicate))</pre>\n * if predicate is != null.\n * <p>\n * If the input collection or predicate is null, there is no change made.\n *\n * @param <T>  the type of object the {@link Iterable} contains\n * @param collection  the collection to get the input from, may be null\n * @param predicate  the predicate to use as a filter, may be null\n * @return true if the collection is modified by this call, false otherwise.\n */\npublic static <T> boolean filterInverse(final Iterable<T> collection, final Predicate<? super T> predicate) {\n    return filter(collection, predicate == null ? null : PredicateUtils.notPredicate(predicate));\n}"
            ],
            [
                "countMatches",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Counts the number of elements in the input collection that match the\n * predicate.\n * <p>\n * A <code>null</code> collection or predicate matches no elements.\n *\n * @param <C>  the type of object the {@link Iterable} contains\n * @param input  the {@link Iterable} to get the input from, may be null\n * @param predicate  the predicate to use, may be null\n * @return the number of matches for the predicate in the collection\n * @deprecated since 4.1, use {@link IterableUtils#countMatches(Iterable, Predicate)} instead\n */\n@Deprecated\npublic static <C> int countMatches(final Iterable<C> input, final Predicate<? super C> predicate) {\n    return predicate == null ? 0 : (int) IterableUtils.countMatches(input, predicate);\n}"
            ],
            [
                "exists",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Answers true if a predicate is true for at least one element of a\n * collection.\n * <p>\n * A <code>null</code> collection or predicate returns false.\n *\n * @param <C>  the type of object the {@link Iterable} contains\n * @param input  the {@link Iterable} to get the input from, may be null\n * @param predicate  the predicate to use, may be null\n * @return true if at least one element of the collection matches the predicate\n * @deprecated since 4.1, use {@link IterableUtils#matchesAny(Iterable, Predicate)} instead\n */\n@Deprecated\npublic static <C> boolean exists(final Iterable<C> input, final Predicate<? super C> predicate) {\n    return predicate == null ? false : IterableUtils.matchesAny(input, predicate);\n}"
            ],
            [
                "matchesAll",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Answers true if a predicate is true for every element of a\n * collection.\n * <p>\n * A <code>null</code> predicate returns false.<br/>\n * A <code>null</code> or empty collection returns true.\n *\n * @param <C>  the type of object the {@link Iterable} contains\n * @param input  the {@link Iterable} to get the input from, may be null\n * @param predicate  the predicate to use, may be null\n * @return true if every element of the collection matches the predicate or if the\n * collection is empty, false otherwise\n * @since 4.0\n * @deprecated since 4.1, use {@link IterableUtils#matchesAll(Iterable, Predicate)} instead\n */\n@Deprecated\npublic static <C> boolean matchesAll(final Iterable<C> input, final Predicate<? super C> predicate) {\n    return predicate == null ? false : IterableUtils.matchesAll(input, predicate);\n}"
            ],
            [
                "select",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Selects all elements from input collection which match the given\n * predicate into an output collection.\n * <p>\n * A <code>null</code> predicate matches no elements.\n *\n * @param <O>  the type of object the {@link Iterable} contains\n * @param inputCollection  the collection to get the input from, may not be null\n * @param predicate  the predicate to use, may be null\n * @return the elements matching the predicate (new list)\n * @throws NullPointerException if the input collection is null\n */\npublic static <O> Collection<O> select(final Iterable<? extends O> inputCollection, final Predicate<? super O> predicate) {\n    final Collection<O> answer = inputCollection instanceof Collection<?> ? new ArrayList<O>(((Collection<?>) inputCollection).size()) : new ArrayList<O>();\n    return select(inputCollection, predicate, answer);\n}"
            ],
            [
                "select",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Selects all elements from input collection which match the given\n * predicate and adds them to outputCollection.\n * <p>\n * If the input collection or predicate is null, there is no change to the\n * output collection.\n *\n * @param <O>  the type of object the {@link Iterable} contains\n * @param <R>  the type of the output {@link Collection}\n * @param inputCollection  the collection to get the input from, may be null\n * @param predicate  the predicate to use, may be null\n * @param outputCollection  the collection to output into, may not be null if the inputCollection\n *   and predicate or not null\n * @return the outputCollection\n */\npublic static <O, R extends Collection<? super O>> R select(final Iterable<? extends O> inputCollection, final Predicate<? super O> predicate, final R outputCollection) {\n    if (inputCollection != null && predicate != null) {\n        for (final O item : inputCollection) {\n            if (predicate.evaluate(item)) {\n                outputCollection.add(item);\n            }\n        }\n    }\n    return outputCollection;\n}"
            ],
            [
                "select",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Selects all elements from inputCollection into an output and rejected collection,\n * based on the evaluation of the given predicate.\n * <p>\n * Elements matching the predicate are added to the <code>outputCollection</code>,\n * all other elements are added to the <code>rejectedCollection</code>.\n * <p>\n * If the input predicate is <code>null</code>, no elements are added to\n * <code>outputCollection</code> or <code>rejectedCollection</code>.\n * <p>\n * Note: calling the method is equivalent to the following code snippet:\n * <pre>\n *   select(inputCollection, predicate, outputCollection);\n *   selectRejected(inputCollection, predicate, rejectedCollection);\n * </pre>\n *\n * @param <O>  the type of object the {@link Iterable} contains\n * @param <R>  the type of the output {@link Collection}\n * @param inputCollection  the collection to get the input from, may be null\n * @param predicate  the predicate to use, may be null\n * @param outputCollection  the collection to output selected elements into, may not be null if the\n *   inputCollection and predicate are not null\n * @param rejectedCollection  the collection to output rejected elements into, may not be null if the\n *   inputCollection or predicate are not null\n * @return the outputCollection\n * @since 4.1\n */\npublic static <O, R extends Collection<? super O>> R select(final Iterable<? extends O> inputCollection, final Predicate<? super O> predicate, R outputCollection, R rejectedCollection) {\n    if (inputCollection != null && predicate != null) {\n        for (final O element : inputCollection) {\n            if (predicate.evaluate(element)) {\n                outputCollection.add(element);\n            } else {\n                rejectedCollection.add(element);\n            }\n        }\n    }\n    return outputCollection;\n}"
            ],
            [
                "selectRejected",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Selects all elements from inputCollection which don't match the given\n * predicate into an output collection.\n * <p>\n * If the input predicate is <code>null</code>, the result is an empty\n * list.\n *\n * @param <O>  the type of object the {@link Iterable} contains\n * @param inputCollection  the collection to get the input from, may not be null\n * @param predicate  the predicate to use, may be null\n * @return the elements <b>not</b> matching the predicate (new list)\n * @throws NullPointerException if the input collection is null\n */\npublic static <O> Collection<O> selectRejected(final Iterable<? extends O> inputCollection, final Predicate<? super O> predicate) {\n    final Collection<O> answer = inputCollection instanceof Collection<?> ? new ArrayList<O>(((Collection<?>) inputCollection).size()) : new ArrayList<O>();\n    return selectRejected(inputCollection, predicate, answer);\n}"
            ],
            [
                "selectRejected",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Selects all elements from inputCollection which don't match the given\n * predicate and adds them to outputCollection.\n * <p>\n * If the input predicate is <code>null</code>, no elements are added to\n * <code>outputCollection</code>.\n *\n * @param <O>  the type of object the {@link Iterable} contains\n * @param <R>  the type of the output {@link Collection}\n * @param inputCollection  the collection to get the input from, may be null\n * @param predicate  the predicate to use, may be null\n * @param outputCollection  the collection to output into, may not be null if the inputCollection\n *   and predicate or not null\n * @return outputCollection\n */\npublic static <O, R extends Collection<? super O>> R selectRejected(final Iterable<? extends O> inputCollection, final Predicate<? super O> predicate, final R outputCollection) {\n    if (inputCollection != null && predicate != null) {\n        for (final O item : inputCollection) {\n            if (!predicate.evaluate(item)) {\n                outputCollection.add(item);\n            }\n        }\n    }\n    return outputCollection;\n}"
            ],
            [
                "collect",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns a new Collection containing all elements of the input collection\n * transformed by the given transformer.\n * <p>\n * If the input collection or transformer is null, the result is an empty list.\n *\n * @param <I>  the type of object in the input collection\n * @param <O>  the type of object in the output collection\n * @param inputCollection  the collection to get the input from, may not be null\n * @param transformer  the transformer to use, may be null\n * @return the transformed result (new list)\n * @throws NullPointerException if the input collection is null\n */\npublic static <I, O> Collection<O> collect(final Iterable<I> inputCollection, final Transformer<? super I, ? extends O> transformer) {\n    final Collection<O> answer = inputCollection instanceof Collection<?> ? new ArrayList<O>(((Collection<?>) inputCollection).size()) : new ArrayList<O>();\n    return collect(inputCollection, transformer, answer);\n}"
            ],
            [
                "collect",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Transforms all elements from the input iterator with the given transformer\n * and adds them to the output collection.\n * <p>\n * If the input iterator or transformer is null, the result is an empty list.\n *\n * @param <I>  the type of object in the input collection\n * @param <O>  the type of object in the output collection\n * @param inputIterator  the iterator to get the input from, may be null\n * @param transformer  the transformer to use, may be null\n * @return the transformed result (new list)\n */\npublic static <I, O> Collection<O> collect(final Iterator<I> inputIterator, final Transformer<? super I, ? extends O> transformer) {\n    return collect(inputIterator, transformer, new ArrayList<O>());\n}"
            ],
            [
                "collect",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Transforms all elements from input collection with the given transformer\n * and adds them to the output collection.\n * <p>\n * If the input collection or transformer is null, there is no change to the\n * output collection.\n *\n * @param <I>  the type of object in the input collection\n * @param <O>  the type of object in the output collection\n * @param <R>  the type of the output collection\n * @param inputCollection  the collection to get the input from, may be null\n * @param transformer  the transformer to use, may be null\n * @param outputCollection  the collection to output into, may not be null if inputCollection\n *   and transformer are not null\n * @return the output collection with the transformed input added\n * @throws NullPointerException if the outputCollection is null and both, inputCollection and\n *   transformer are not null\n */\npublic static <I, O, R extends Collection<? super O>> R collect(final Iterable<? extends I> inputCollection, final Transformer<? super I, ? extends O> transformer, final R outputCollection) {\n    if (inputCollection != null) {\n        return collect(inputCollection.iterator(), transformer, outputCollection);\n    }\n    return outputCollection;\n}"
            ],
            [
                "collect",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Transforms all elements from the input iterator with the given transformer\n * and adds them to the output collection.\n * <p>\n * If the input iterator or transformer is null, there is no change to the\n * output collection.\n *\n * @param <I>  the type of object in the input collection\n * @param <O>  the type of object in the output collection\n * @param <R>  the type of the output collection\n * @param inputIterator  the iterator to get the input from, may be null\n * @param transformer  the transformer to use, may be null\n * @param outputCollection  the collection to output into, may not be null if inputIterator\n *   and transformer are not null\n * @return the outputCollection with the transformed input added\n * @throws NullPointerException if the output collection is null and both, inputIterator and\n *   transformer are not null\n */\npublic static <I, O, R extends Collection<? super O>> R collect(final Iterator<? extends I> inputIterator, final Transformer<? super I, ? extends O> transformer, final R outputCollection) {\n    if (inputIterator != null && transformer != null) {\n        while (inputIterator.hasNext()) {\n            final I item = inputIterator.next();\n            final O value = transformer.transform(item);\n            outputCollection.add(value);\n        }\n    }\n    return outputCollection;\n}"
            ],
            [
                "addIgnoreNull",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "//-----------------------------------------------------------------------\n/**\n * Adds an element to the collection unless the element is null.\n *\n * @param <T>  the type of object the {@link Collection} contains\n * @param collection  the collection to add to, must not be null\n * @param object  the object to add, if null it will not be added\n * @return true if the collection changed\n * @throws NullPointerException if the collection is null\n * @since 3.2\n */\npublic static <T> boolean addIgnoreNull(final Collection<T> collection, final T object) {\n    if (collection == null) {\n        throw new NullPointerException(\"The collection must not be null\");\n    }\n    return object != null && collection.add(object);\n}"
            ],
            [
                "addAll",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Adds all elements in the {@link Iterable} to the given collection. If the\n * {@link Iterable} is a {@link Collection} then it is cast and will be\n * added using {@link Collection#addAll(Collection)} instead of iterating.\n *\n * @param <C>  the type of object the {@link Collection} contains\n * @param collection  the collection to add to, must not be null\n * @param iterable  the iterable of elements to add, must not be null\n * @return a boolean indicating whether the collection has changed or not.\n * @throws NullPointerException if the collection or iterator is null\n */\npublic static <C> boolean addAll(final Collection<C> collection, final Iterable<? extends C> iterable) {\n    if (iterable instanceof Collection<?>) {\n        return collection.addAll((Collection<? extends C>) iterable);\n    }\n    return addAll(collection, iterable.iterator());\n}"
            ],
            [
                "addAll",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Adds all elements in the iteration to the given collection.\n *\n * @param <C>  the type of object the {@link Collection} contains\n * @param collection  the collection to add to, must not be null\n * @param iterator  the iterator of elements to add, must not be null\n * @return a boolean indicating whether the collection has changed or not.\n * @throws NullPointerException if the collection or iterator is null\n */\npublic static <C> boolean addAll(final Collection<C> collection, final Iterator<? extends C> iterator) {\n    boolean changed = false;\n    while (iterator.hasNext()) {\n        changed |= collection.add(iterator.next());\n    }\n    return changed;\n}"
            ],
            [
                "addAll",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Adds all elements in the enumeration to the given collection.\n *\n * @param <C>  the type of object the {@link Collection} contains\n * @param collection  the collection to add to, must not be null\n * @param enumeration  the enumeration of elements to add, must not be null\n * @return {@code true} if the collections was changed, {@code false} otherwise\n * @throws NullPointerException if the collection or enumeration is null\n */\npublic static <C> boolean addAll(final Collection<C> collection, final Enumeration<? extends C> enumeration) {\n    boolean changed = false;\n    while (enumeration.hasMoreElements()) {\n        changed |= collection.add(enumeration.nextElement());\n    }\n    return changed;\n}"
            ],
            [
                "addAll",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Adds all elements in the array to the given collection.\n *\n * @param <C>  the type of object the {@link Collection} contains\n * @param collection  the collection to add to, must not be null\n * @param elements  the array of elements to add, must not be null\n * @return {@code true} if the collection was changed, {@code false} otherwise\n * @throws NullPointerException if the collection or array is null\n */\npublic static <C> boolean addAll(final Collection<C> collection, final C[] elements) {\n    boolean changed = false;\n    for (final C element : elements) {\n        changed |= collection.add(element);\n    }\n    return changed;\n}"
            ],
            [
                "get",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns the <code>index</code>-th value in {@link Iterator}, throwing\n * <code>IndexOutOfBoundsException</code> if there is no such element.\n * <p>\n * The Iterator is advanced to <code>index</code> (or to the end, if\n * <code>index</code> exceeds the number of entries) as a side effect of this method.\n *\n * @param iterator  the iterator to get a value from\n * @param index  the index to get\n * @param <T> the type of object in the {@link Iterator}\n * @return the object at the specified index\n * @throws IndexOutOfBoundsException if the index is invalid\n * @throws IllegalArgumentException if the object type is invalid\n * @deprecated since 4.1, use {@code IteratorUtils.get(Iterator, int)} instead\n */\n@Deprecated\npublic static <T> T get(final Iterator<T> iterator, final int index) {\n    return IteratorUtils.get(iterator, index);\n}"
            ],
            [
                "get",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns the <code>index</code>-th value in the <code>iterable</code>'s {@link Iterator}, throwing\n * <code>IndexOutOfBoundsException</code> if there is no such element.\n * <p>\n * If the {@link Iterable} is a {@link List}, then it will use {@link List#get(int)}.\n *\n * @param iterable  the {@link Iterable} to get a value from\n * @param index  the index to get\n * @param <T> the type of object in the {@link Iterable}.\n * @return the object at the specified index\n * @throws IndexOutOfBoundsException if the index is invalid\n * @deprecated since 4.1, use {@code IterableUtils.get(Iterable, int)} instead\n */\n@Deprecated\npublic static <T> T get(final Iterable<T> iterable, final int index) {\n    return IterableUtils.get(iterable, index);\n}"
            ],
            [
                "get",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns the <code>index</code>-th value in <code>object</code>, throwing\n * <code>IndexOutOfBoundsException</code> if there is no such element or\n * <code>IllegalArgumentException</code> if <code>object</code> is not an\n * instance of one of the supported types.\n * <p>\n * The supported types, and associated semantics are:\n * <ul>\n * <li> Map -- the value returned is the <code>Map.Entry</code> in position\n *      <code>index</code> in the map's <code>entrySet</code> iterator,\n *      if there is such an entry.</li>\n * <li> List -- this method is equivalent to the list's get method.</li>\n * <li> Array -- the <code>index</code>-th array entry is returned,\n *      if there is such an entry; otherwise an <code>IndexOutOfBoundsException</code>\n *      is thrown.</li>\n * <li> Collection -- the value returned is the <code>index</code>-th object\n *      returned by the collection's default iterator, if there is such an element.</li>\n * <li> Iterator or Enumeration -- the value returned is the\n *      <code>index</code>-th object in the Iterator/Enumeration, if there\n *      is such an element.  The Iterator/Enumeration is advanced to\n *      <code>index</code> (or to the end, if <code>index</code> exceeds the\n *      number of entries) as a side effect of this method.</li>\n * </ul>\n *\n * @param object  the object to get a value from\n * @param index  the index to get\n * @return the object at the specified index\n * @throws IndexOutOfBoundsException if the index is invalid\n * @throws IllegalArgumentException if the object type is invalid\n */\npublic static Object get(final Object object, final int index) {\n    int i = index;\n    if (i < 0) {\n        throw new IndexOutOfBoundsException(\"Index cannot be negative: \" + i);\n    }\n    if (object instanceof Map<?, ?>) {\n        final Map<?, ?> map = (Map<?, ?>) object;\n        final Iterator<?> iterator = map.entrySet().iterator();\n        return IteratorUtils.get(iterator, i);\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object)[i];\n    } else if (object instanceof Iterator<?>) {\n        final Iterator<?> it = (Iterator<?>) object;\n        return IteratorUtils.get(it, i);\n    } else if (object instanceof Iterable<?>) {\n        final Iterable<?> iterable = (Iterable<?>) object;\n        return IterableUtils.get(iterable, i);\n    } else if (object instanceof Collection<?>) {\n        final Iterator<?> iterator = ((Collection<?>) object).iterator();\n        return IteratorUtils.get(iterator, i);\n    } else if (object instanceof Enumeration<?>) {\n        final Enumeration<?> it = (Enumeration<?>) object;\n        return EnumerationUtils.get(it, i);\n    } else if (object == null) {\n        throw new IllegalArgumentException(\"Unsupported object type: null\");\n    } else {\n        try {\n            return Array.get(object, i);\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}"
            ],
            [
                "get",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns the <code>index</code>-th <code>Map.Entry</code> in the <code>map</code>'s <code>entrySet</code>,\n * throwing <code>IndexOutOfBoundsException</code> if there is no such element.\n *\n * @param <K>  the key type in the {@link Map}\n * @param <V>  the key type in the {@link Map}\n * @param map  the object to get a value from\n * @param index  the index to get\n * @return the object at the specified index\n * @throws IndexOutOfBoundsException if the index is invalid\n */\npublic static <K, V> Map.Entry<K, V> get(final Map<K, V> map, final int index) {\n    checkIndexBounds(index);\n    return get(map.entrySet(), index);\n}"
            ],
            [
                "size",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Gets the size of the collection/iterator specified.\n * <p>\n * This method can handles objects as follows\n * <ul>\n * <li>Collection - the collection size\n * <li>Map - the map size\n * <li>Array - the array size\n * <li>Iterator - the number of elements remaining in the iterator\n * <li>Enumeration - the number of elements remaining in the enumeration\n * </ul>\n *\n * @param object  the object to get the size of, may be null\n * @return the size of the specified collection or 0 if the object was null\n * @throws IllegalArgumentException thrown if object is not recognised\n * @since 3.1\n */\npublic static int size(final Object object) {\n    if (object == null) {\n        return 0;\n    }\n    int total = 0;\n    if (object instanceof Map<?, ?>) {\n        total = ((Map<?, ?>) object).size();\n    } else if (object instanceof Collection<?>) {\n        total = ((Collection<?>) object).size();\n    } else if (object instanceof Iterable<?>) {\n        total = IterableUtils.size((Iterable<?>) object);\n    } else if (object instanceof Object[]) {\n        total = ((Object[]) object).length;\n    } else if (object instanceof Iterator<?>) {\n        total = IteratorUtils.size((Iterator<?>) object);\n    } else if (object instanceof Enumeration<?>) {\n        final Enumeration<?> it = (Enumeration<?>) object;\n        while (it.hasMoreElements()) {\n            total++;\n            it.nextElement();\n        }\n    } else {\n        try {\n            total = Array.getLength(object);\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n    return total;\n}"
            ],
            [
                "sizeIsEmpty",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Checks if the specified collection/array/iterator is empty.\n * <p>\n * This method can handles objects as follows\n * <ul>\n * <li>Collection - via collection isEmpty\n * <li>Map - via map isEmpty\n * <li>Array - using array size\n * <li>Iterator - via hasNext\n * <li>Enumeration - via hasMoreElements\n * </ul>\n * <p>\n * Note: This method is named to avoid clashing with\n * {@link #isEmpty(Collection)}.\n *\n * @param object  the object to get the size of, may be null\n * @return true if empty or null\n * @throws IllegalArgumentException thrown if object is not recognised\n * @since 3.2\n */\npublic static boolean sizeIsEmpty(final Object object) {\n    if (object == null) {\n        return true;\n    } else if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Iterable<?>) {\n        return IterableUtils.isEmpty((Iterable<?>) object);\n    } else if (object instanceof Map<?, ?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return ((Iterator<?>) object).hasNext() == false;\n    } else if (object instanceof Enumeration<?>) {\n        return ((Enumeration<?>) object).hasMoreElements() == false;\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}"
            ],
            [
                "isEmpty",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "//-----------------------------------------------------------------------\n/**\n * Null-safe check if the specified collection is empty.\n * <p>\n * Null returns true.\n *\n * @param coll  the collection to check, may be null\n * @return true if empty or null\n * @since 3.2\n */\npublic static boolean isEmpty(final Collection<?> coll) {\n    return coll == null || coll.isEmpty();\n}"
            ],
            [
                "isNotEmpty",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Null-safe check if the specified collection is not empty.\n * <p>\n * Null returns false.\n *\n * @param coll  the collection to check, may be null\n * @return true if non-null and non-empty\n * @since 3.2\n */\npublic static boolean isNotEmpty(final Collection<?> coll) {\n    return !isEmpty(coll);\n}"
            ],
            [
                "isFull",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns true if no more elements can be added to the Collection.\n * <p>\n * This method uses the {@link BoundedCollection} interface to determine the\n * full status. If the collection does not implement this interface then\n * false is returned.\n * <p>\n * The collection does not have to implement this interface directly.\n * If the collection has been decorated using the decorators subpackage\n * then these will be removed to access the BoundedCollection.\n *\n * @param coll  the collection to check\n * @return true if the BoundedCollection is full\n * @throws NullPointerException if the collection is null\n */\npublic static boolean isFull(final Collection<? extends Object> coll) {\n    if (coll == null) {\n        throw new NullPointerException(\"The collection must not be null\");\n    }\n    if (coll instanceof BoundedCollection) {\n        return ((BoundedCollection<?>) coll).isFull();\n    }\n    try {\n        final BoundedCollection<?> bcoll = UnmodifiableBoundedCollection.unmodifiableBoundedCollection(coll);\n        return bcoll.isFull();\n    } catch (final IllegalArgumentException ex) {\n        return false;\n    }\n}"
            ],
            [
                "maxSize",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Get the maximum number of elements that the Collection can contain.\n * <p>\n * This method uses the {@link BoundedCollection} interface to determine the\n * maximum size. If the collection does not implement this interface then\n * -1 is returned.\n * <p>\n * The collection does not have to implement this interface directly.\n * If the collection has been decorated using the decorators subpackage\n * then these will be removed to access the BoundedCollection.\n *\n * @param coll  the collection to check\n * @return the maximum size of the BoundedCollection, -1 if no maximum size\n * @throws NullPointerException if the collection is null\n */\npublic static int maxSize(final Collection<? extends Object> coll) {\n    if (coll == null) {\n        throw new NullPointerException(\"The collection must not be null\");\n    }\n    if (coll instanceof BoundedCollection) {\n        return ((BoundedCollection<?>) coll).maxSize();\n    }\n    try {\n        final BoundedCollection<?> bcoll = UnmodifiableBoundedCollection.unmodifiableBoundedCollection(coll);\n        return bcoll.maxSize();\n    } catch (final IllegalArgumentException ex) {\n        return -1;\n    }\n}"
            ],
            [
                "collate",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "//-----------------------------------------------------------------------\n/**\n * Merges two sorted Collections, a and b, into a single, sorted List\n * such that the natural ordering of the elements is retained.\n * <p>\n * Uses the standard O(n) merge algorithm for combining two sorted lists.\n *\n * @param <O>  the element type\n * @param a  the first collection, must not be null\n * @param b  the second collection, must not be null\n * @return a new sorted List, containing the elements of Collection a and b\n * @throws NullPointerException if either collection is null\n * @since 4.0\n */\npublic static <O extends Comparable<? super O>> List<O> collate(Iterable<? extends O> a, Iterable<? extends O> b) {\n    return collate(a, b, ComparatorUtils.<O>naturalComparator(), true);\n}"
            ],
            [
                "collate",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Merges two sorted Collections, a and b, into a single, sorted List\n * such that the natural ordering of the elements is retained.\n * <p>\n * Uses the standard O(n) merge algorithm for combining two sorted lists.\n *\n * @param <O>  the element type\n * @param a  the first collection, must not be null\n * @param b  the second collection, must not be null\n * @param includeDuplicates  if {@code true} duplicate elements will be retained, otherwise\n *   they will be removed in the output collection\n * @return a new sorted List, containing the elements of Collection a and b\n * @throws NullPointerException if either collection is null\n * @since 4.0\n */\npublic static <O extends Comparable<? super O>> List<O> collate(final Iterable<? extends O> a, final Iterable<? extends O> b, final boolean includeDuplicates) {\n    return collate(a, b, ComparatorUtils.<O>naturalComparator(), includeDuplicates);\n}"
            ],
            [
                "collate",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Merges two sorted Collections, a and b, into a single, sorted List\n * such that the ordering of the elements according to Comparator c is retained.\n * <p>\n * Uses the standard O(n) merge algorithm for combining two sorted lists.\n *\n * @param <O>  the element type\n * @param a  the first collection, must not be null\n * @param b  the second collection, must not be null\n * @param c  the comparator to use for the merge.\n * @return a new sorted List, containing the elements of Collection a and b\n * @throws NullPointerException if either collection or the comparator is null\n * @since 4.0\n */\npublic static <O> List<O> collate(final Iterable<? extends O> a, final Iterable<? extends O> b, final Comparator<? super O> c) {\n    return collate(a, b, c, true);\n}"
            ],
            [
                "collate",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Merges two sorted Collections, a and b, into a single, sorted List\n * such that the ordering of the elements according to Comparator c is retained.\n * <p>\n * Uses the standard O(n) merge algorithm for combining two sorted lists.\n *\n * @param <O>  the element type\n * @param a  the first collection, must not be null\n * @param b  the second collection, must not be null\n * @param c  the comparator to use for the merge.\n * @param includeDuplicates  if {@code true} duplicate elements will be retained, otherwise\n *   they will be removed in the output collection\n * @return a new sorted List, containing the elements of Collection a and b\n * @throws NullPointerException if either collection or the comparator is null\n * @since 4.0\n */\npublic static <O> List<O> collate(final Iterable<? extends O> a, final Iterable<? extends O> b, final Comparator<? super O> c, final boolean includeDuplicates) {\n    if (a == null || b == null) {\n        throw new NullPointerException(\"The collections must not be null\");\n    }\n    if (c == null) {\n        throw new NullPointerException(\"The comparator must not be null\");\n    }\n    // if both Iterables are a Collection, we can estimate the size\n    final int totalSize = a instanceof Collection<?> && b instanceof Collection<?> ? Math.max(1, ((Collection<?>) a).size() + ((Collection<?>) b).size()) : 10;\n    final Iterator<O> iterator = new CollatingIterator<O>(c, a.iterator(), b.iterator());\n    if (includeDuplicates) {\n        return IteratorUtils.toList(iterator, totalSize);\n    } else {\n        final ArrayList<O> mergedList = new ArrayList<O>(totalSize);\n        O lastItem = null;\n        while (iterator.hasNext()) {\n            final O item = iterator.next();\n            if (lastItem == null || !lastItem.equals(item)) {\n                mergedList.add(item);\n            }\n            lastItem = item;\n        }\n        mergedList.trimToSize();\n        return mergedList;\n    }\n}"
            ],
            [
                "permutations",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns a {@link Collection} of all the permutations of the input collection.\n * <p>\n * NOTE: the number of permutations of a given collection is equal to n!, where\n * n is the size of the collection. Thus, the resulting collection will become\n * <b>very</b> large for collections &gt; 10 (e.g. 10! = 3628800, 15! = 1307674368000).\n * <p>\n * For larger collections it is advised to use a {@link PermutationIterator} to\n * iterate over all permutations.\n *\n * @see PermutationIterator\n *\n * @param <E>  the element type\n * @param collection  the collection to create permutations for, may not be null\n * @return an unordered collection of all permutations of the input collection\n * @throws NullPointerException if collection is null\n * @since 4.0\n */\npublic static <E> Collection<List<E>> permutations(final Collection<E> collection) {\n    final PermutationIterator<E> it = new PermutationIterator<E>(collection);\n    final Collection<List<E>> result = new LinkedList<List<E>>();\n    while (it.hasNext()) {\n        result.add(it.next());\n    }\n    return result;\n}"
            ],
            [
                "retainAll",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns a collection containing all the elements in <code>collection</code>\n * that are also in <code>retain</code>. The cardinality of an element <code>e</code>\n * in the returned collection is the same as the cardinality of <code>e</code>\n * in <code>collection</code> unless <code>retain</code> does not contain <code>e</code>, in which\n * case the cardinality is zero. This method is useful if you do not wish to modify\n * the collection <code>c</code> and thus cannot call <code>c.retainAll(retain);</code>.\n * <p>\n * This implementation iterates over <code>collection</code>, checking each element in\n * turn to see if it's contained in <code>retain</code>. If it's contained, it's added\n * to the returned list. As a consequence, it is advised to use a collection type for\n * <code>retain</code> that provides a fast (e.g. O(1)) implementation of\n * {@link Collection#contains(Object)}.\n *\n * @param <C>  the type of object the {@link Collection} contains\n * @param collection  the collection whose contents are the target of the #retailAll operation\n * @param retain  the collection containing the elements to be retained in the returned collection\n * @return a <code>Collection</code> containing all the elements of <code>collection</code>\n * that occur at least once in <code>retain</code>.\n * @throws NullPointerException if either parameter is null\n * @since 3.2\n */\npublic static <C> Collection<C> retainAll(final Collection<C> collection, final Collection<?> retain) {\n    return ListUtils.retainAll(collection, retain);\n}"
            ],
            [
                "retainAll",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns a collection containing all the elements in\n * <code>collection</code> that are also in <code>retain</code>. The\n * cardinality of an element <code>e</code> in the returned collection is\n * the same as the cardinality of <code>e</code> in <code>collection</code>\n * unless <code>retain</code> does not contain <code>e</code>, in which case\n * the cardinality is zero. This method is useful if you do not wish to\n * modify the collection <code>c</code> and thus cannot call\n * <code>c.retainAll(retain);</code>.\n * <p>\n * Moreover this method uses an {@link Equator} instead of\n * {@link Object#equals(Object)} to determine the equality of the elements\n * in <code>collection</code> and <code>retain</code>. Hence this method is\n * useful in cases where the equals behavior of an object needs to be\n * modified without changing the object itself.\n *\n * @param <E> the type of object the {@link Collection} contains\n * @param collection the collection whose contents are the target of the {@code retainAll} operation\n * @param retain the collection containing the elements to be retained in the returned collection\n * @param equator the Equator used for testing equality\n * @return a <code>Collection</code> containing all the elements of <code>collection</code>\n * that occur at least once in <code>retain</code> according to the <code>equator</code>\n * @throws NullPointerException if any of the parameters is null\n * @since 4.1\n */\npublic static <E> Collection<E> retainAll(final Iterable<E> collection, final Iterable<? extends E> retain, final Equator<? super E> equator) {\n    final Transformer<E, EquatorWrapper<E>> transformer = new Transformer<E, EquatorWrapper<E>>() {\n\n        public EquatorWrapper<E> transform(E input) {\n            return new EquatorWrapper<E>(equator, input);\n        }\n    };\n    final Set<EquatorWrapper<E>> retainSet = collect(retain, transformer, new HashSet<EquatorWrapper<E>>());\n    final List<E> list = new ArrayList<E>();\n    for (final E element : collection) {\n        if (retainSet.contains(new EquatorWrapper<E>(equator, element))) {\n            list.add(element);\n        }\n    }\n    return list;\n}"
            ],
            [
                "removeAll",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Removes the elements in <code>remove</code> from <code>collection</code>. That is, this\n * method returns a collection containing all the elements in <code>c</code>\n * that are not in <code>remove</code>. The cardinality of an element <code>e</code>\n * in the returned collection is the same as the cardinality of <code>e</code>\n * in <code>collection</code> unless <code>remove</code> contains <code>e</code>, in which\n * case the cardinality is zero. This method is useful if you do not wish to modify\n * the collection <code>c</code> and thus cannot call <code>collection.removeAll(remove);</code>.\n * <p>\n * This implementation iterates over <code>collection</code>, checking each element in\n * turn to see if it's contained in <code>remove</code>. If it's not contained, it's added\n * to the returned list. As a consequence, it is advised to use a collection type for\n * <code>remove</code> that provides a fast (e.g. O(1)) implementation of\n * {@link Collection#contains(Object)}.\n *\n * @param <E>  the type of object the {@link Collection} contains\n * @param collection  the collection from which items are removed (in the returned collection)\n * @param remove  the items to be removed from the returned <code>collection</code>\n * @return a <code>Collection</code> containing all the elements of <code>collection</code> except\n * any elements that also occur in <code>remove</code>.\n * @throws NullPointerException if either parameter is null\n * @since 4.0 (method existed in 3.2 but was completely broken)\n */\npublic static <E> Collection<E> removeAll(final Collection<E> collection, final Collection<?> remove) {\n    return ListUtils.removeAll(collection, remove);\n}"
            ],
            [
                "removeAll",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Removes all elements in <code>remove</code> from <code>collection</code>.\n * That is, this method returns a collection containing all the elements in\n * <code>collection</code> that are not in <code>remove</code>. The\n * cardinality of an element <code>e</code> in the returned collection is\n * the same as the cardinality of <code>e</code> in <code>collection</code>\n * unless <code>remove</code> contains <code>e</code>, in which case the\n * cardinality is zero. This method is useful if you do not wish to modify\n * the collection <code>c</code> and thus cannot call\n * <code>collection.removeAll(remove)</code>.\n * <p>\n * Moreover this method uses an {@link Equator} instead of\n * {@link Object#equals(Object)} to determine the equality of the elements\n * in <code>collection</code> and <code>remove</code>. Hence this method is\n * useful in cases where the equals behavior of an object needs to be\n * modified without changing the object itself.\n *\n * @param <E> the type of object the {@link Collection} contains\n * @param collection the collection from which items are removed (in the returned collection)\n * @param remove the items to be removed from the returned collection\n * @param equator the Equator used for testing equality\n * @return a <code>Collection</code> containing all the elements of <code>collection</code>\n * except any element that if equal according to the <code>equator</code>\n * @throws NullPointerException if any of the parameters is null\n * @since 4.1\n */\npublic static <E> Collection<E> removeAll(final Iterable<E> collection, final Iterable<? extends E> remove, final Equator<? super E> equator) {\n    final Transformer<E, EquatorWrapper<E>> transformer = new Transformer<E, EquatorWrapper<E>>() {\n\n        public EquatorWrapper<E> transform(E input) {\n            return new EquatorWrapper<E>(equator, input);\n        }\n    };\n    final Set<EquatorWrapper<E>> removeSet = collect(remove, transformer, new HashSet<EquatorWrapper<E>>());\n    final List<E> list = new ArrayList<E>();\n    for (final E element : collection) {\n        if (!removeSet.contains(new EquatorWrapper<E>(equator, element))) {\n            list.add(element);\n        }\n    }\n    return list;\n}"
            ],
            [
                "synchronizedCollection",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns a synchronized collection backed by the given collection.\n * <p>\n * You must manually synchronize on the returned buffer's iterator to\n * avoid non-deterministic behavior:\n *\n * <pre>\n * Collection c = CollectionUtils.synchronizedCollection(myCollection);\n * synchronized (c) {\n *     Iterator i = c.iterator();\n *     while (i.hasNext()) {\n *         process (i.next());\n *     }\n * }\n * </pre>\n *\n * This method uses the implementation in the decorators subpackage.\n *\n * @param <C>  the type of object the {@link Collection} contains\n * @param collection  the collection to synchronize, must not be null\n * @return a synchronized collection backed by the given collection\n * @throws NullPointerException if the collection is null\n * @deprecated since 4.1, use {@link java.util.Collections#synchronizedCollection(Collection)} instead\n */\n@Deprecated\npublic static <C> Collection<C> synchronizedCollection(final Collection<C> collection) {\n    return SynchronizedCollection.synchronizedCollection(collection);\n}"
            ],
            [
                "unmodifiableCollection",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns an unmodifiable collection backed by the given collection.\n * <p>\n * This method uses the implementation in the decorators subpackage.\n *\n * @param <C>  the type of object the {@link Collection} contains\n * @param collection  the collection to make unmodifiable, must not be null\n * @return an unmodifiable collection backed by the given collection\n * @throws NullPointerException if the collection is null\n * @deprecated since 4.1, use {@link java.util.Collections#unmodifiableCollection(Collection)} instead\n */\n@Deprecated\npublic static <C> Collection<C> unmodifiableCollection(final Collection<? extends C> collection) {\n    return UnmodifiableCollection.unmodifiableCollection(collection);\n}"
            ],
            [
                "predicatedCollection",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns a predicated (validating) collection backed by the given collection.\n * <p>\n * Only objects that pass the test in the given predicate can be added to the collection.\n * Trying to add an invalid object results in an IllegalArgumentException.\n * It is important not to use the original collection after invoking this method,\n * as it is a backdoor for adding invalid objects.\n *\n * @param <C> the type of objects in the Collection.\n * @param collection  the collection to predicate, must not be null\n * @param predicate  the predicate for the collection, must not be null\n * @return a predicated collection backed by the given collection\n * @throws NullPointerException if the Collection is null\n */\npublic static <C> Collection<C> predicatedCollection(final Collection<C> collection, final Predicate<? super C> predicate) {\n    return PredicatedCollection.predicatedCollection(collection, predicate);\n}"
            ],
            [
                "transformingCollection",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns a transformed bag backed by the given collection.\n * <p>\n * Each object is passed through the transformer as it is added to the\n * Collection. It is important not to use the original collection after invoking this\n * method, as it is a backdoor for adding untransformed objects.\n * <p>\n * Existing entries in the specified collection will not be transformed.\n * If you want that behaviour, see {@link TransformedCollection#transformedCollection}.\n *\n * @param <E> the type of object the {@link Collection} contains\n * @param collection  the collection to predicate, must not be null\n * @param transformer  the transformer for the collection, must not be null\n * @return a transformed collection backed by the given collection\n * @throws NullPointerException if the Collection or Transformer is null\n */\npublic static <E> Collection<E> transformingCollection(final Collection<E> collection, final Transformer<? super E, ? extends E> transformer) {\n    return TransformedCollection.transformingCollection(collection, transformer);\n}"
            ],
            [
                "extractSingleton",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Extract the lone element of the specified Collection.\n * @param <E> collection type\n * @param collection to read\n * @return sole member of collection\n * @throws NullPointerException if collection is null\n * @throws IllegalArgumentException if collection is empty or contains more than one element\n * @since 4.0\n */\npublic static <E> E extractSingleton(final Collection<E> collection) {\n    if (collection == null) {\n        throw new NullPointerException(\"Collection must not be null.\");\n    }\n    if (collection.size() != 1) {\n        throw new IllegalArgumentException(\"Can extract singleton only when collection size == 1\");\n    }\n    return collection.iterator().next();\n}"
            ],
            [
                "transformingMap",
                "org.apache.commons.collections4.splitmap",
                "TransformedSplitMap",
                "/**\n * Factory method to create a transforming map.\n * <p>\n * If there are any elements already in the map being decorated, they are\n * NOT transformed.\n *\n * @param <J>  the input key type\n * @param <K>  the output key type\n * @param <U>  the input value type\n * @param <V>  the output value type\n * @param map the map to decorate, must not be null\n * @param keyTransformer the transformer to use for key conversion, must not be null\n * @param valueTransformer the transformer to use for value conversion, must not be null\n * @return a new transformed map\n * @throws NullPointerException if map or either of the transformers is null\n */\npublic static <J, K, U, V> TransformedSplitMap<J, K, U, V> transformingMap(final Map<K, V> map, final Transformer<? super J, ? extends K> keyTransformer, final Transformer<? super U, ? extends V> valueTransformer) {\n    return new TransformedSplitMap<J, K, U, V>(map, keyTransformer, valueTransformer);\n}"
            ],
            [
                "emptyIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Empty\n// ----------------------------------------------------------------------\n/**\n * Gets an empty iterable.\n * <p>\n * This iterable does not contain any elements.\n *\n * @param <E> the element type\n * @return an empty iterable\n */\n// OK, empty collection is compatible with any type\n@SuppressWarnings(\"unchecked\")\npublic static <E> Iterable<E> emptyIterable() {\n    return EMPTY_ITERABLE;\n}"
            ],
            [
                "chainedIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Chained\n// ----------------------------------------------------------------------\n/**\n * Combines two iterables into a single iterable.\n * <p>\n * The returned iterable has an iterator that traverses the elements in {@code a},\n * followed by the elements in {@code b}. The source iterators are not polled until\n * necessary.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the corresponding\n * input iterator supports it.\n *\n * @param <E> the element type\n * @param a  the first iterable, may not be null\n * @param b  the second iterable, may not be null\n * @return a new iterable, combining the provided iterables\n * @throws NullPointerException if either a or b is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Iterable<E> chainedIterable(final Iterable<? extends E> a, final Iterable<? extends E> b) {\n    return chainedIterable(new Iterable[] { a, b });\n}"
            ],
            [
                "chainedIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Combines three iterables into a single iterable.\n * <p>\n * The returned iterable has an iterator that traverses the elements in {@code a},\n * followed by the elements in {@code b} and {@code c}. The source iterators are\n * not polled until necessary.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the corresponding\n * input iterator supports it.\n *\n * @param <E> the element type\n * @param a  the first iterable, may not be null\n * @param b  the second iterable, may not be null\n * @param c  the third iterable, may not be null\n * @return a new iterable, combining the provided iterables\n * @throws NullPointerException if either of the provided iterables is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Iterable<E> chainedIterable(final Iterable<? extends E> a, final Iterable<? extends E> b, final Iterable<? extends E> c) {\n    return chainedIterable(new Iterable[] { a, b, c });\n}"
            ],
            [
                "chainedIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Combines four iterables into a single iterable.\n * <p>\n * The returned iterable has an iterator that traverses the elements in {@code a},\n * followed by the elements in {@code b}, {@code c} and {@code d}. The source\n * iterators are not polled until necessary.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the corresponding\n * input iterator supports it.\n *\n * @param <E> the element type\n * @param a  the first iterable, may not be null\n * @param b  the second iterable, may not be null\n * @param c  the third iterable, may not be null\n * @param d  the fourth iterable, may not be null\n * @return a new iterable, combining the provided iterables\n * @throws NullPointerException if either of the provided iterables is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Iterable<E> chainedIterable(final Iterable<? extends E> a, final Iterable<? extends E> b, final Iterable<? extends E> c, final Iterable<? extends E> d) {\n    return chainedIterable(new Iterable[] { a, b, c, d });\n}"
            ],
            [
                "chainedIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Combines the provided iterables into a single iterable.\n * <p>\n * The returned iterable has an iterator that traverses the elements in the order\n * of the arguments, i.e. iterables[0], iterables[1], .... The source iterators\n * are not polled until necessary.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the corresponding\n * input iterator supports it.\n *\n * @param <E> the element type\n * @param iterables  the iterables to combine, may not be null\n * @return a new iterable, combining the provided iterables\n * @throws NullPointerException if either of the provided iterables is null\n */\npublic static <E> Iterable<E> chainedIterable(final Iterable<? extends E>... iterables) {\n    checkNotNull(iterables);\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            return new LazyIteratorChain<E>() {\n\n                @Override\n                protected Iterator<? extends E> nextIterator(int count) {\n                    if (count > iterables.length) {\n                        return null;\n                    } else {\n                        return iterables[count - 1].iterator();\n                    }\n                }\n            };\n        }\n    };\n}"
            ],
            [
                "collatedIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Collated\n// ----------------------------------------------------------------------\n/**\n * Combines the two provided iterables into an ordered iterable using\n * natural ordering.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the\n * corresponding input iterator supports it.\n *\n * @param <E> the element type\n * @param a  the first iterable, may not be null\n * @param b  the second iterable, may not be null\n * @return a filtered view on the specified iterable\n * @throws NullPointerException if either of the provided iterables is null\n */\npublic static <E> Iterable<E> collatedIterable(final Iterable<? extends E> a, final Iterable<? extends E> b) {\n    checkNotNull(a, b);\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            return IteratorUtils.collatedIterator(null, a.iterator(), b.iterator());\n        }\n    };\n}"
            ],
            [
                "collatedIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Combines the two provided iterables into an ordered iterable using the\n * provided comparator. If the comparator is null, natural ordering will be\n * used.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the\n * corresponding input iterator supports it.\n *\n * @param <E> the element type\n * @param comparator  the comparator defining an ordering over the elements,\n *   may be null, in which case natural ordering will be used\n * @param a  the first iterable, may not be null\n * @param b  the second iterable, may not be null\n * @return a filtered view on the specified iterable\n * @throws NullPointerException if either of the provided iterables is null\n */\npublic static <E> Iterable<E> collatedIterable(final Comparator<? super E> comparator, final Iterable<? extends E> a, final Iterable<? extends E> b) {\n    checkNotNull(a, b);\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            return IteratorUtils.collatedIterator(comparator, a.iterator(), b.iterator());\n        }\n    };\n}"
            ],
            [
                "filteredIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Filtered\n// ----------------------------------------------------------------------\n/**\n * Returns a view of the given iterable that only contains elements matching\n * the provided predicate.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the\n * corresponding input iterator supports it.\n *\n * @param <E> the element type\n * @param iterable  the iterable to filter, may not be null\n * @param predicate  the predicate used to filter elements, may not be null\n * @return a filtered view on the specified iterable\n * @throws NullPointerException if either iterable or predicate is null\n */\npublic static <E> Iterable<E> filteredIterable(final Iterable<E> iterable, final Predicate<? super E> predicate) {\n    checkNotNull(iterable);\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null.\");\n    }\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            return IteratorUtils.filteredIterator(emptyIteratorIfNull(iterable), predicate);\n        }\n    };\n}"
            ],
            [
                "boundedIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Bounded\n// ----------------------------------------------------------------------\n/**\n * Returns a view of the given iterable that contains at most the given number\n * of elements.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the corresponding\n * input iterator supports it.\n *\n * @param <E> the element type\n * @param iterable  the iterable to limit, may not be null\n * @param maxSize  the maximum number of elements, must not be negative\n * @return a bounded view on the specified iterable\n * @throws IllegalArgumentException if maxSize is negative\n * @throws NullPointerException if iterable is null\n */\npublic static <E> Iterable<E> boundedIterable(final Iterable<E> iterable, final long maxSize) {\n    checkNotNull(iterable);\n    if (maxSize < 0) {\n        throw new IllegalArgumentException(\"MaxSize parameter must not be negative.\");\n    }\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            return IteratorUtils.boundedIterator(iterable.iterator(), maxSize);\n        }\n    };\n}"
            ],
            [
                "loopingIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Looping\n// ----------------------------------------------------------------------\n/**\n * Returns a view of the given iterable which will cycle infinitely over\n * its elements.\n * <p>\n * The returned iterable's iterator supports {@code remove()} if\n * {@code iterable.iterator()} does. After {@code remove()} is called, subsequent\n * cycles omit the removed element, which is no longer in {@code iterable}. The\n * iterator's {@code hasNext()} method returns {@code true} until {@code iterable}\n * is empty.\n *\n * @param <E> the element type\n * @param iterable  the iterable to loop, may not be null\n * @return a view of the iterable, providing an infinite loop over its elements\n * @throws NullPointerException if iterable is null\n */\npublic static <E> Iterable<E> loopingIterable(final Iterable<E> iterable) {\n    checkNotNull(iterable);\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            return new LazyIteratorChain<E>() {\n\n                @Override\n                protected Iterator<? extends E> nextIterator(int count) {\n                    if (IterableUtils.isEmpty(iterable)) {\n                        return null;\n                    } else {\n                        return iterable.iterator();\n                    }\n                }\n            };\n        }\n    };\n}"
            ],
            [
                "reversedIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Reversed\n// ----------------------------------------------------------------------\n/**\n * Returns a reversed view of the given iterable.\n * <p>\n * In case the provided iterable is a {@link List} instance, a\n * {@link ReverseListIterator} will be used to reverse the traversal\n * order, otherwise an intermediate {@link List} needs to be created.\n * <p>\n * The returned iterable's iterator supports {@code remove()} if the\n * provided iterable is a {@link List} instance.\n *\n * @param <E> the element type\n * @param iterable  the iterable to use, may not be null\n * @return a reversed view of the specified iterable\n * @throws NullPointerException if iterable is null\n * @see ReverseListIterator\n */\npublic static <E> Iterable<E> reversedIterable(final Iterable<E> iterable) {\n    checkNotNull(iterable);\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            final List<E> list = (iterable instanceof List<?>) ? (List<E>) iterable : IteratorUtils.toList(iterable.iterator());\n            return new ReverseListIterator<E>(list);\n        }\n    };\n}"
            ],
            [
                "skippingIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Skipping\n// ----------------------------------------------------------------------\n/**\n * Returns a view of the given iterable that skips the first N elements.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the corresponding\n * input iterator supports it.\n *\n * @param <E> the element type\n * @param iterable  the iterable to use, may not be null\n * @param elementsToSkip  the number of elements to skip from the start, must not be negative\n * @return a view of the specified iterable, skipping the first N elements\n * @throws IllegalArgumentException if elementsToSkip is negative\n * @throws NullPointerException if iterable is null\n */\npublic static <E> Iterable<E> skippingIterable(final Iterable<E> iterable, final long elementsToSkip) {\n    checkNotNull(iterable);\n    if (elementsToSkip < 0) {\n        throw new IllegalArgumentException(\"ElementsToSkip parameter must not be negative.\");\n    }\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            return IteratorUtils.skippingIterator(iterable.iterator(), elementsToSkip);\n        }\n    };\n}"
            ],
            [
                "transformedIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Transformed\n// ----------------------------------------------------------------------\n/**\n * Returns a transformed view of the given iterable where all of its elements\n * have been transformed by the provided transformer.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the corresponding\n * input iterator supports it.\n *\n * @param <I>  the input element type\n * @param <O>  the output element type\n * @param iterable  the iterable to transform, may not be null\n * @param transformer  the transformer, must not be null\n * @return a transformed view of the specified iterable\n * @throws NullPointerException if either iterable or transformer is null\n */\npublic static <I, O> Iterable<O> transformedIterable(final Iterable<I> iterable, final Transformer<? super I, ? extends O> transformer) {\n    checkNotNull(iterable);\n    if (transformer == null) {\n        throw new NullPointerException(\"Transformer must not be null.\");\n    }\n    return new FluentIterable<O>() {\n\n        @Override\n        public Iterator<O> iterator() {\n            return IteratorUtils.transformedIterator(iterable.iterator(), transformer);\n        }\n    };\n}"
            ],
            [
                "uniqueIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Unique\n// ----------------------------------------------------------------------\n/**\n * Returns a unique view of the given iterable.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the\n * corresponding input iterator supports it. Calling {@code remove()}\n * will only remove a single element from the underlying iterator.\n *\n * @param <E> the element type\n * @param iterable  the iterable to use, may not be null\n * @return a unique view of the specified iterable\n * @throws NullPointerException if iterable is null\n */\npublic static <E> Iterable<E> uniqueIterable(final Iterable<E> iterable) {\n    checkNotNull(iterable);\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            return new UniqueFilterIterator<E>(iterable.iterator());\n        }\n    };\n}"
            ],
            [
                "unmodifiableIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Unmodifiable\n// ----------------------------------------------------------------------\n/**\n * Returns an unmodifiable view of the given iterable.\n * <p>\n * The returned iterable's iterator does not support {@code remove()}.\n *\n * @param <E> the element type\n * @param iterable  the iterable to use, may not be null\n * @return an unmodifiable view of the specified iterable\n * @throws NullPointerException if iterable is null\n */\npublic static <E> Iterable<E> unmodifiableIterable(final Iterable<E> iterable) {\n    checkNotNull(iterable);\n    if (iterable instanceof UnmodifiableIterable<?>) {\n        return iterable;\n    }\n    return new UnmodifiableIterable<E>(iterable);\n}"
            ],
            [
                "zippingIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Zipping\n// ----------------------------------------------------------------------\n/**\n * Interleaves two iterables into a single iterable.\n * <p>\n * The returned iterable has an iterator that traverses the elements in {@code a}\n * and {@code b} in alternating order. The source iterators are not polled until\n * necessary.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the corresponding\n * input iterator supports it.\n *\n * @param <E> the element type\n * @param a  the first iterable, may not be null\n * @param b  the second iterable, may not be null\n * @return a new iterable, interleaving the provided iterables\n * @throws NullPointerException if either a or b is null\n */\npublic static <E> Iterable<E> zippingIterable(final Iterable<? extends E> a, final Iterable<? extends E> b) {\n    checkNotNull(a);\n    checkNotNull(b);\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            return IteratorUtils.zippingIterator(a.iterator(), b.iterator());\n        }\n    };\n}"
            ],
            [
                "zippingIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Interleaves two iterables into a single iterable.\n * <p>\n * The returned iterable has an iterator that traverses the elements in {@code a}\n * and {@code b} in alternating order. The source iterators are not polled until\n * necessary.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the corresponding\n * input iterator supports it.\n *\n * @param <E> the element type\n * @param first  the first iterable, may not be null\n * @param others  the array of iterables to interleave, may not be null\n * @return a new iterable, interleaving the provided iterables\n * @throws NullPointerException if either of the provided iterables is null\n */\npublic static <E> Iterable<E> zippingIterable(final Iterable<? extends E> first, final Iterable<? extends E>... others) {\n    checkNotNull(first);\n    checkNotNull(others);\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            // safe\n            @SuppressWarnings(\"unchecked\")\n            Iterator<? extends E>[] iterators = new Iterator[others.length + 1];\n            iterators[0] = first.iterator();\n            for (int i = 0; i < others.length; i++) {\n                iterators[i + 1] = others[i].iterator();\n            }\n            return IteratorUtils.zippingIterator(iterators);\n        }\n    };\n}"
            ],
            [
                "emptyIfNull",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Utility methods\n// ----------------------------------------------------------------------\n/**\n * Returns an immutable empty iterable if the argument is null,\n * or the argument itself otherwise.\n *\n * @param <E> the element type\n * @param iterable  the iterable, may be null\n * @return an empty iterable if the argument is null\n */\npublic static <E> Iterable<E> emptyIfNull(final Iterable<E> iterable) {\n    return iterable == null ? IterableUtils.<E>emptyIterable() : iterable;\n}"
            ],
            [
                "forEachButLast",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Executes the given closure on each but the last element in the iterable.\n * <p>\n * If the input iterable is null no change is made.\n *\n * @param <E> the type of object the {@link Iterable} contains\n * @param iterable  the iterable to get the input from, may be null\n * @param closure  the closure to perform, may not be null\n * @return the last element in the iterable, or null if iterable is null or empty\n */\npublic static <E> E forEachButLast(final Iterable<E> iterable, final Closure<? super E> closure) {\n    return IteratorUtils.forEachButLast(emptyIteratorIfNull(iterable), closure);\n}"
            ],
            [
                "find",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Finds the first element in the given iterable which matches the given predicate.\n * <p>\n * A <code>null</code> or empty iterator returns null.\n *\n * @param <E> the element type\n * @param iterable  the iterable to search, may be null\n * @param predicate  the predicate to use, may not be null\n * @return the first element of the iterable which matches the predicate or null if none could be found\n * @throws NullPointerException if predicate is null\n */\npublic static <E> E find(final Iterable<E> iterable, final Predicate<? super E> predicate) {\n    return IteratorUtils.find(emptyIteratorIfNull(iterable), predicate);\n}"
            ],
            [
                "indexOf",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Returns the index of the first element in the specified iterable that\n * matches the given predicate.\n * <p>\n * A <code>null</code> or empty iterable returns -1.\n *\n * @param <E> the element type\n * @param iterable  the iterable to search, may be null\n * @param predicate  the predicate to use, may not be null\n * @return the index of the first element which matches the predicate or -1 if none matches\n * @throws NullPointerException if predicate is null\n */\npublic static <E> int indexOf(final Iterable<E> iterable, final Predicate<? super E> predicate) {\n    return IteratorUtils.indexOf(emptyIteratorIfNull(iterable), predicate);\n}"
            ],
            [
                "matchesAll",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Answers true if a predicate is true for every element of an iterable.\n * <p>\n * A <code>null</code> or empty iterable returns true.\n *\n * @param <E> the type of object the {@link Iterable} contains\n * @param iterable  the {@link Iterable} to use, may be null\n * @param predicate  the predicate to use, may not be null\n * @return true if every element of the collection matches the predicate or if the\n *   collection is empty, false otherwise\n * @throws NullPointerException if predicate is null\n */\npublic static <E> boolean matchesAll(final Iterable<E> iterable, final Predicate<? super E> predicate) {\n    return IteratorUtils.matchesAll(emptyIteratorIfNull(iterable), predicate);\n}"
            ],
            [
                "matchesAny",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Answers true if a predicate is true for any element of the iterable.\n * <p>\n * A <code>null</code> or empty iterable returns false.\n *\n * @param <E> the type of object the {@link Iterable} contains\n * @param iterable  the {@link Iterable} to use, may be null\n * @param predicate  the predicate to use, may not be null\n * @return true if any element of the collection matches the predicate, false otherwise\n * @throws NullPointerException if predicate is null\n */\npublic static <E> boolean matchesAny(final Iterable<E> iterable, final Predicate<? super E> predicate) {\n    return IteratorUtils.matchesAny(emptyIteratorIfNull(iterable), predicate);\n}"
            ],
            [
                "countMatches",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Counts the number of elements in the input iterable that match the predicate.\n * <p>\n * A <code>null</code> iterable matches no elements.\n *\n * @param <E> the type of object the {@link Iterable} contains\n * @param input  the {@link Iterable} to get the input from, may be null\n * @param predicate  the predicate to use, may not be null\n * @return the number of matches for the predicate in the collection\n * @throws NullPointerException if predicate is null\n */\npublic static <E> long countMatches(final Iterable<E> input, final Predicate<? super E> predicate) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null.\");\n    }\n    return size(filteredIterable(emptyIfNull(input), predicate));\n}"
            ],
            [
                "isEmpty",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Answers true if the provided iterable is empty.\n * <p>\n * A <code>null</code> iterable returns true.\n *\n * @param iterable  the {@link Iterable to use}, may be null\n * @return true if the iterable is null or empty, false otherwise\n */\npublic static boolean isEmpty(final Iterable<?> iterable) {\n    if (iterable instanceof Collection<?>) {\n        return ((Collection<?>) iterable).isEmpty();\n    } else {\n        return IteratorUtils.isEmpty(emptyIteratorIfNull(iterable));\n    }\n}"
            ],
            [
                "contains",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Checks if the object is contained in the given iterable.\n * <p>\n * A <code>null</code> or empty iterable returns false.\n *\n * @param <E> the type of object the {@link Iterable} contains\n * @param iterable  the iterable to check, may be null\n * @param object  the object to check\n * @return true if the object is contained in the iterable, false otherwise\n */\npublic static <E> boolean contains(final Iterable<E> iterable, final Object object) {\n    if (iterable instanceof Collection<?>) {\n        return ((Collection<E>) iterable).contains(object);\n    } else {\n        return IteratorUtils.contains(emptyIteratorIfNull(iterable), object);\n    }\n}"
            ],
            [
                "contains",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Checks if the object is contained in the given iterable. Object equality\n * is tested with an {@code equator} unlike {@link #contains(Iterable, Object)}\n * which uses {@link Object#equals(Object)}.\n * <p>\n * A <code>null</code> or empty iterable returns false.\n * A <code>null</code> object will not be passed to the equator, instead a\n * {@link org.apache.commons.collections4.functors.NullPredicate NullPredicate}\n * will be used.\n *\n * @param <E> the type of object the {@link Iterable} contains\n * @param iterable  the iterable to check, may be null\n * @param object  the object to check\n * @param equator  the equator to use to check, may not be null\n * @return true if the object is contained in the iterable, false otherwise\n * @throws NullPointerException if equator is null\n */\npublic static <E> boolean contains(final Iterable<? extends E> iterable, final E object, final Equator<? super E> equator) {\n    if (equator == null) {\n        throw new NullPointerException(\"Equator must not be null.\");\n    }\n    return matchesAny(iterable, EqualPredicate.equalPredicate(object, equator));\n}"
            ],
            [
                "frequency",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Returns the number of occurrences of the provided object in the iterable.\n *\n * @param <E> the element type that the {@link Iterable} may contain\n * @param <T> the element type of the object to find\n * @param iterable  the {@link Iterable} to search\n * @param obj  the object to find the cardinality of\n * @return the the number of occurrences of obj in iterable\n */\npublic static <E, T extends E> int frequency(final Iterable<E> iterable, final T obj) {\n    if (iterable instanceof Set<?>) {\n        return ((Set<E>) iterable).contains(obj) ? 1 : 0;\n    }\n    if (iterable instanceof Bag<?>) {\n        return ((Bag<E>) iterable).getCount(obj);\n    }\n    return size(filteredIterable(emptyIfNull(iterable), EqualPredicate.<E>equalPredicate(obj)));\n}"
            ],
            [
                "get",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Returns the <code>index</code>-th value in the <code>iterable</code>'s {@link Iterator}, throwing\n * <code>IndexOutOfBoundsException</code> if there is no such element.\n * <p>\n * If the {@link Iterable} is a {@link List}, then it will use {@link List#get(int)}.\n *\n * @param <T> the type of object in the {@link Iterable}.\n * @param iterable  the {@link Iterable} to get a value from, may be null\n * @param index  the index to get\n * @return the object at the specified index\n * @throws IndexOutOfBoundsException if the index is invalid\n */\npublic static <T> T get(final Iterable<T> iterable, final int index) {\n    CollectionUtils.checkIndexBounds(index);\n    if (iterable instanceof List<?>) {\n        return ((List<T>) iterable).get(index);\n    }\n    return IteratorUtils.get(emptyIteratorIfNull(iterable), index);\n}"
            ],
            [
                "size",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Returns the number of elements contained in the given iterator.\n * <p>\n * A <code>null</code> or empty iterator returns {@code 0}.\n *\n * @param iterable  the iterable to check, may be null\n * @return the number of elements contained in the iterable\n */\npublic static int size(final Iterable<?> iterable) {\n    if (iterable instanceof Collection<?>) {\n        return ((Collection<?>) iterable).size();\n    } else {\n        return IteratorUtils.size(emptyIteratorIfNull(iterable));\n    }\n}"
            ],
            [
                "partition",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Partitions all elements from iterable into separate output collections,\n * based on the evaluation of the given predicate.\n * <p>\n * For each predicate, the result will contain a list holding all elements of the\n * input iterable matching the predicate. The last list will hold all elements\n * which didn't match any predicate:\n * <pre>\n *  [C1, R] = partition(I, P1) with\n *  I = input\n *  P1 = first predicate\n *  C1 = collection of elements matching P1\n *  R = collection of elements rejected by all predicates\n * </pre>\n * <p>\n * If the input iterable is <code>null</code>, the same is returned as for an\n * empty iterable.\n * <p>\n * Example: for an input list [1, 2, 3, 4, 5] calling partition with a predicate [x &lt; 3]\n * will result in the following output: [[1, 2], [3, 4, 5]].\n *\n * @param <O>  the type of object the {@link Iterable} contains\n * @param iterable  the iterable to partition, may be null\n * @param predicate  the predicate to use, may not be null\n * @return a list containing the output collections\n * @throws NullPointerException if predicate is null\n */\npublic static <O> List<List<O>> partition(final Iterable<? extends O> iterable, final Predicate<? super O> predicate) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null.\");\n    }\n    // safe\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    final Factory<List<O>> factory = FactoryUtils.instantiateFactory((Class) ArrayList.class);\n    // safe\n    @SuppressWarnings(\"unchecked\")\n    final Predicate<? super O>[] predicates = new Predicate[] { predicate };\n    return partition(iterable, factory, predicates);\n}"
            ],
            [
                "partition",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Partitions all elements from iterable into separate output collections,\n * based on the evaluation of the given predicates.\n * <p>\n * For each predicate, the result will contain a list holding all elements of the\n * input iterable matching the predicate. The last list will hold all elements\n * which didn't match any predicate:\n * <pre>\n *  [C1, C2, R] = partition(I, P1, P2) with\n *  I = input\n *  P1 = first predicate\n *  P2 = second predicate\n *  C1 = collection of elements matching P1\n *  C2 = collection of elements matching P2\n *  R = collection of elements rejected by all predicates\n * </pre>\n * <p>\n * <b>Note</b>: elements are only added to the output collection of the first matching\n * predicate, determined by the order of arguments.\n * <p>\n * If the input iterable is <code>null</code>, the same is returned as for an\n * empty iterable.\n * <p>\n * Example: for an input list [1, 2, 3, 4, 5] calling partition with predicates [x &lt; 3]\n * and [x &lt; 5] will result in the following output: [[1, 2], [3, 4], [5]].\n *\n * @param <O>  the type of object the {@link Iterable} contains\n * @param iterable  the collection to get the input from, may be null\n * @param predicates  the predicates to use, may not be null\n * @return a list containing the output collections\n * @throws NullPointerException if any predicate is null\n */\npublic static <O> List<List<O>> partition(final Iterable<? extends O> iterable, final Predicate<? super O>... predicates) {\n    // safe\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    final Factory<List<O>> factory = FactoryUtils.instantiateFactory((Class) ArrayList.class);\n    return partition(iterable, factory, predicates);\n}"
            ],
            [
                "partition",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Partitions all elements from iterable into separate output collections,\n * based on the evaluation of the given predicates.\n * <p>\n * For each predicate, the returned list will contain a collection holding\n * all elements of the input iterable matching the predicate. The last collection\n * contained in the list will hold all elements which didn't match any predicate:\n * <pre>\n *  [C1, C2, R] = partition(I, P1, P2) with\n *  I = input\n *  P1 = first predicate\n *  P2 = second predicate\n *  C1 = collection of elements matching P1\n *  C2 = collection of elements matching P2\n *  R = collection of elements rejected by all predicates\n * </pre>\n * <p>\n * <b>Note</b>: elements are only added to the output collection of the first matching\n * predicate, determined by the order of arguments.\n * <p>\n * If the input iterable is <code>null</code>, the same is returned as for an\n * empty iterable.\n * If no predicates have been provided, all elements of the input collection\n * will be added to the rejected collection.\n * <p>\n * Example: for an input list [1, 2, 3, 4, 5] calling partition with predicates [x &lt; 3]\n * and [x &lt; 5] will result in the following output: [[1, 2], [3, 4], [5]].\n *\n * @param <O>  the type of object the {@link Iterable} contains\n * @param <R>  the type of the output {@link Collection}\n * @param iterable  the collection to get the input from, may be null\n * @param partitionFactory  the factory used to create the output collections\n * @param predicates  the predicates to use, may not be null\n * @return a list containing the output collections\n * @throws NullPointerException if any predicate is null\n */\npublic static <O, R extends Collection<O>> List<R> partition(final Iterable<? extends O> iterable, final Factory<R> partitionFactory, final Predicate<? super O>... predicates) {\n    if (iterable == null) {\n        final Iterable<O> empty = emptyIterable();\n        return partition(empty, partitionFactory, predicates);\n    }\n    if (predicates == null) {\n        throw new NullPointerException(\"Predicates must not be null.\");\n    }\n    for (Predicate<?> p : predicates) {\n        if (p == null) {\n            throw new NullPointerException(\"Predicate must not be null.\");\n        }\n    }\n    if (predicates.length < 1) {\n        // return the entire input collection as a single partition\n        final R singlePartition = partitionFactory.create();\n        CollectionUtils.addAll(singlePartition, iterable);\n        return Collections.singletonList(singlePartition);\n    }\n    // create the empty partitions\n    final int numberOfPredicates = predicates.length;\n    final int numberOfPartitions = numberOfPredicates + 1;\n    final List<R> partitions = new ArrayList<R>(numberOfPartitions);\n    for (int i = 0; i < numberOfPartitions; ++i) {\n        partitions.add(partitionFactory.create());\n    }\n    // for each element in inputCollection:\n    // find the first predicate that evaluates to true.\n    // if there is a predicate, add the element to the corresponding partition.\n    // if there is no predicate, add it to the last, catch-all partition.\n    for (final O element : iterable) {\n        boolean elementAssigned = false;\n        for (int i = 0; i < numberOfPredicates; ++i) {\n            if (predicates[i].evaluate(element)) {\n                partitions.get(i).add(element);\n                elementAssigned = true;\n                break;\n            }\n        }\n        if (!elementAssigned) {\n            // no predicates evaluated to true\n            // add element to last partition\n            partitions.get(numberOfPredicates).add(element);\n        }\n    }\n    return partitions;\n}"
            ],
            [
                "toList",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Gets a new list with the contents of the provided iterable.\n *\n * @param <E> the element type\n * @param iterable  the iterable to use, may be null\n * @return a list of the iterator contents\n */\npublic static <E> List<E> toList(final Iterable<E> iterable) {\n    return IteratorUtils.toList(emptyIteratorIfNull(iterable));\n}"
            ],
            [
                "toString",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Returns a string representation of the elements of the specified iterable.\n * <p>\n * The string representation consists of a list of the iterable's elements,\n * enclosed in square brackets ({@code \"[]\"}). Adjacent elements are separated\n * by the characters {@code \", \"} (a comma followed by a space). Elements are\n * converted to strings as by {@code String.valueOf(Object)}.\n *\n * @param <E> the element type\n * @param iterable  the iterable to convert to a string, may be null\n * @return a string representation of {@code iterable}\n */\npublic static <E> String toString(final Iterable<E> iterable) {\n    return IteratorUtils.toString(emptyIteratorIfNull(iterable));\n}"
            ],
            [
                "toString",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Returns a string representation of the elements of the specified iterable.\n * <p>\n * The string representation consists of a list of the iterable's elements,\n * enclosed in square brackets ({@code \"[]\"}). Adjacent elements are separated\n * by the characters {@code \", \"} (a comma followed by a space). Elements are\n * converted to strings as by using the provided {@code transformer}.\n *\n * @param <E> the element type\n * @param iterable  the iterable to convert to a string, may be null\n * @param transformer  the transformer used to get a string representation of an element\n * @return a string representation of {@code iterable}\n * @throws NullPointerException if {@code transformer} is null\n */\npublic static <E> String toString(final Iterable<E> iterable, final Transformer<? super E, String> transformer) {\n    if (transformer == null) {\n        throw new NullPointerException(\"Transformer must not be null.\");\n    }\n    return IteratorUtils.toString(emptyIteratorIfNull(iterable), transformer);\n}"
            ],
            [
                "toString",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Returns a string representation of the elements of the specified iterable.\n * <p>\n * The string representation consists of a list of the iterable's elements,\n * enclosed by the provided {@code prefix} and {@code suffix}. Adjacent elements\n * are separated by the provided {@code delimiter}. Elements are converted to\n * strings as by using the provided {@code transformer}.\n *\n * @param <E> the element type\n * @param iterable  the iterable to convert to a string, may be null\n * @param transformer  the transformer used to get a string representation of an element\n * @param delimiter  the string to delimit elements\n * @param prefix  the prefix, prepended to the string representation\n * @param suffix  the suffix, appended to the string representation\n * @return a string representation of {@code iterable}\n * @throws NullPointerException if either transformer, delimiter, prefix or suffix is null\n */\npublic static <E> String toString(final Iterable<E> iterable, final Transformer<? super E, String> transformer, final String delimiter, final String prefix, final String suffix) {\n    return IteratorUtils.toString(emptyIteratorIfNull(iterable), transformer, delimiter, prefix, suffix);\n}"
            ],
            [
                "unmodifiableTrie",
                "org.apache.commons.collections4",
                "TrieUtils",
                "/**\n * Returns an unmodifiable instance of a {@link Trie}\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param trie  the trie to make unmodifiable, must not be null\n * @return an unmodifiable trie backed by the given trie\n * @throws NullPointerException if trie is null\n *\n * @see java.util.Collections#unmodifiableMap(java.util.Map)\n */\npublic static <K, V> Trie<K, V> unmodifiableTrie(final Trie<K, ? extends V> trie) {\n    return UnmodifiableTrie.unmodifiableTrie(trie);\n}"
            ],
            [
                "exceptionClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Gets a Closure that always throws an exception.\n * This could be useful during testing as a placeholder.\n *\n * @see org.apache.commons.collections4.functors.ExceptionClosure\n *\n * @param <E>  the type that the closure acts on\n * @return the closure\n */\npublic static <E> Closure<E> exceptionClosure() {\n    return ExceptionClosure.<E>exceptionClosure();\n}"
            ],
            [
                "nopClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Gets a Closure that will do nothing.\n * This could be useful during testing as a placeholder.\n *\n * @see org.apache.commons.collections4.functors.NOPClosure\n *\n * @param <E>  the type that the closure acts on\n * @return the closure\n */\npublic static <E> Closure<E> nopClosure() {\n    return NOPClosure.<E>nopClosure();\n}"
            ],
            [
                "asClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Creates a Closure that calls a Transformer each time it is called.\n * The transformer will be called using the closure's input object.\n * The transformer's result will be ignored.\n *\n * @see org.apache.commons.collections4.functors.TransformerClosure\n *\n * @param <E>  the type that the closure acts on\n * @param transformer  the transformer to run each time in the closure, null means nop\n * @return the closure\n */\npublic static <E> Closure<E> asClosure(final Transformer<? super E, ?> transformer) {\n    return TransformerClosure.transformerClosure(transformer);\n}"
            ],
            [
                "forClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Creates a Closure that will call the closure <code>count</code> times.\n * <p>\n * A null closure or zero count returns the <code>NOPClosure</code>.\n *\n * @see org.apache.commons.collections4.functors.ForClosure\n *\n * @param <E>  the type that the closure acts on\n * @param count  the number of times to loop\n * @param closure  the closure to call repeatedly\n * @return the <code>for</code> closure\n */\npublic static <E> Closure<E> forClosure(final int count, final Closure<? super E> closure) {\n    return ForClosure.forClosure(count, closure);\n}"
            ],
            [
                "whileClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Creates a Closure that will call the closure repeatedly until the\n * predicate returns false.\n *\n * @see org.apache.commons.collections4.functors.WhileClosure\n *\n * @param <E>  the type that the closure acts on\n * @param predicate  the predicate to use as an end of loop test, not null\n * @param closure  the closure to call repeatedly, not null\n * @return the <code>while</code> closure\n * @throws NullPointerException if either argument is null\n */\npublic static <E> Closure<E> whileClosure(final Predicate<? super E> predicate, final Closure<? super E> closure) {\n    return WhileClosure.<E>whileClosure(predicate, closure, false);\n}"
            ],
            [
                "doWhileClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Creates a Closure that will call the closure once and then repeatedly\n * until the predicate returns false.\n *\n * @see org.apache.commons.collections4.functors.WhileClosure\n *\n * @param <E>  the type that the closure acts on\n * @param closure  the closure to call repeatedly, not null\n * @param predicate  the predicate to use as an end of loop test, not null\n * @return the <code>do-while</code> closure\n * @throws NullPointerException if either argument is null\n */\npublic static <E> Closure<E> doWhileClosure(final Closure<? super E> closure, final Predicate<? super E> predicate) {\n    return WhileClosure.<E>whileClosure(predicate, closure, true);\n}"
            ],
            [
                "invokerClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Creates a Closure that will invoke a specific method on the closure's\n * input object by reflection.\n *\n * @see org.apache.commons.collections4.functors.InvokerTransformer\n * @see org.apache.commons.collections4.functors.TransformerClosure\n *\n * @param <E>  the type that the closure acts on\n * @param methodName  the name of the method\n * @return the <code>invoker</code> closure\n * @throws NullPointerException if the method name is null\n */\npublic static <E> Closure<E> invokerClosure(final String methodName) {\n    // reuse transformer as it has caching - this is lazy really, should have inner class here\n    return asClosure(InvokerTransformer.<E, Object>invokerTransformer(methodName));\n}"
            ],
            [
                "invokerClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Creates a Closure that will invoke a specific method on the closure's\n * input object by reflection.\n *\n * @see org.apache.commons.collections4.functors.InvokerTransformer\n * @see org.apache.commons.collections4.functors.TransformerClosure\n *\n * @param <E>  the type that the closure acts on\n * @param methodName  the name of the method\n * @param paramTypes  the parameter types\n * @param args  the arguments\n * @return the <code>invoker</code> closure\n * @throws NullPointerException if the method name is null\n * @throws IllegalArgumentException if the paramTypes and args don't match\n */\npublic static <E> Closure<E> invokerClosure(final String methodName, final Class<?>[] paramTypes, final Object[] args) {\n    // reuse transformer as it has caching - this is lazy really, should have inner class here\n    return asClosure(InvokerTransformer.<E, Object>invokerTransformer(methodName, paramTypes, args));\n}"
            ],
            [
                "chainedClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Create a new Closure that calls each closure in turn, passing the\n * result into the next closure.\n *\n * @see org.apache.commons.collections4.functors.ChainedClosure\n *\n * @param <E>  the type that the closure acts on\n * @param closures  an array of closures to chain\n * @return the <code>chained</code> closure\n * @throws NullPointerException if the closures array is null\n * @throws NullPointerException if any closure in the array is null\n */\npublic static <E> Closure<E> chainedClosure(final Closure<? super E>... closures) {\n    return ChainedClosure.chainedClosure(closures);\n}"
            ],
            [
                "chainedClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Create a new Closure that calls each closure in turn, passing the\n * result into the next closure. The ordering is that of the iterator()\n * method on the collection.\n *\n * @see org.apache.commons.collections4.functors.ChainedClosure\n *\n * @param <E>  the type that the closure acts on\n * @param closures  a collection of closures to chain\n * @return the <code>chained</code> closure\n * @throws NullPointerException if the closures collection is null\n * @throws NullPointerException if any closure in the collection is null\n * @throws IllegalArgumentException if the closures collection is empty\n */\npublic static <E> Closure<E> chainedClosure(final Collection<? extends Closure<? super E>> closures) {\n    return ChainedClosure.chainedClosure(closures);\n}"
            ],
            [
                "ifClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Create a new Closure that calls another closure based on the\n * result of the specified predicate.\n *\n * @see org.apache.commons.collections4.functors.IfClosure\n *\n * @param <E>  the type that the closure acts on\n * @param predicate  the validating predicate\n * @param trueClosure  the closure called if the predicate is true\n * @return the <code>if</code> closure\n * @throws NullPointerException if the predicate or closure is null\n * @since 3.2\n */\npublic static <E> Closure<E> ifClosure(final Predicate<? super E> predicate, final Closure<? super E> trueClosure) {\n    return IfClosure.<E>ifClosure(predicate, trueClosure);\n}"
            ],
            [
                "ifClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Create a new Closure that calls one of two closures depending\n * on the specified predicate.\n *\n * @see org.apache.commons.collections4.functors.IfClosure\n *\n * @param <E>  the type that the closure acts on\n * @param predicate  the predicate to switch on\n * @param trueClosure  the closure called if the predicate is true\n * @param falseClosure  the closure called if the predicate is false\n * @return the <code>switch</code> closure\n * @throws NullPointerException if the predicate or either closure is null\n */\npublic static <E> Closure<E> ifClosure(final Predicate<? super E> predicate, final Closure<? super E> trueClosure, final Closure<? super E> falseClosure) {\n    return IfClosure.<E>ifClosure(predicate, trueClosure, falseClosure);\n}"
            ],
            [
                "switchClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Create a new Closure that calls one of the closures depending\n * on the predicates.\n * <p>\n * The closure at array location 0 is called if the predicate at array\n * location 0 returned true. Each predicate is evaluated\n * until one returns true.\n *\n * @see org.apache.commons.collections4.functors.SwitchClosure\n *\n * @param <E>  the type that the closure acts on\n * @param predicates  an array of predicates to check, not null\n * @param closures  an array of closures to call, not null\n * @return the <code>switch</code> closure\n * @throws NullPointerException if the either array is null\n * @throws NullPointerException if any element in the arrays is null\n * @throws IllegalArgumentException if the arrays have different sizes\n */\npublic static <E> Closure<E> switchClosure(final Predicate<? super E>[] predicates, final Closure<? super E>[] closures) {\n    return SwitchClosure.<E>switchClosure(predicates, closures, null);\n}"
            ],
            [
                "switchClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Create a new Closure that calls one of the closures depending\n * on the predicates.\n * <p>\n * The closure at array location 0 is called if the predicate at array\n * location 0 returned true. Each predicate is evaluated\n * until one returns true. If no predicates evaluate to true, the default\n * closure is called.\n *\n * @see org.apache.commons.collections4.functors.SwitchClosure\n *\n * @param <E>  the type that the closure acts on\n * @param predicates  an array of predicates to check, not null\n * @param closures  an array of closures to call, not null\n * @param defaultClosure  the default to call if no predicate matches\n * @return the <code>switch</code> closure\n * @throws NullPointerException if the either array is null\n * @throws NullPointerException if any element in the arrays is null\n * @throws IllegalArgumentException if the arrays are different sizes\n */\npublic static <E> Closure<E> switchClosure(final Predicate<? super E>[] predicates, final Closure<? super E>[] closures, final Closure<? super E> defaultClosure) {\n    return SwitchClosure.<E>switchClosure(predicates, closures, defaultClosure);\n}"
            ],
            [
                "switchClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Create a new Closure that calls one of the closures depending\n * on the predicates.\n * <p>\n * The Map consists of Predicate keys and Closure values. A closure\n * is called if its matching predicate returns true. Each predicate is evaluated\n * until one returns true. If no predicates evaluate to true, the default\n * closure is called. The default closure is set in the map with a\n * null key. The ordering is that of the iterator() method on the entryset\n * collection of the map.\n *\n * @see org.apache.commons.collections4.functors.SwitchClosure\n *\n * @param <E>  the type that the closure acts on\n * @param predicatesAndClosures  a map of predicates to closures\n * @return the <code>switch</code> closure\n * @throws NullPointerException if the map is null\n * @throws NullPointerException if any closure in the map is null\n * @throws IllegalArgumentException if the map is empty\n * @throws ClassCastException  if the map elements are of the wrong type\n */\npublic static <E> Closure<E> switchClosure(final Map<Predicate<E>, Closure<E>> predicatesAndClosures) {\n    return SwitchClosure.switchClosure(predicatesAndClosures);\n}"
            ],
            [
                "switchMapClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Create a new Closure that uses the input object as a key to find the\n * closure to call.\n * <p>\n * The Map consists of object keys and Closure values. A closure\n * is called if the input object equals the key. If there is no match, the\n * default closure is called. The default closure is set in the map\n * using a null key.\n *\n * @see org.apache.commons.collections4.functors.SwitchClosure\n *\n * @param <E>  the type that the closure acts on\n * @param objectsAndClosures  a map of objects to closures\n * @return the closure\n * @throws NullPointerException if the map is null\n * @throws NullPointerException if any closure in the map is null\n * @throws IllegalArgumentException if the map is empty\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Closure<E> switchMapClosure(final Map<? extends E, Closure<E>> objectsAndClosures) {\n    if (objectsAndClosures == null) {\n        throw new NullPointerException(\"The object and closure map must not be null\");\n    }\n    final Closure<? super E> def = objectsAndClosures.remove(null);\n    final int size = objectsAndClosures.size();\n    final Closure<? super E>[] trs = new Closure[size];\n    final Predicate<E>[] preds = new Predicate[size];\n    int i = 0;\n    for (final Map.Entry<? extends E, Closure<E>> entry : objectsAndClosures.entrySet()) {\n        preds[i] = EqualPredicate.<E>equalPredicate(entry.getKey());\n        trs[i] = entry.getValue();\n        i++;\n    }\n    return ClosureUtils.<E>switchClosure(preds, trs, def);\n}"
            ],
            [
                "unmodifiableTrie",
                "org.apache.commons.collections4.trie",
                "UnmodifiableTrie",
                "/**\n * Factory method to create a unmodifiable trie.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param trie  the trie to decorate, must not be null\n * @return a new unmodifiable trie\n * @throws NullPointerException if trie is null\n */\npublic static <K, V> Trie<K, V> unmodifiableTrie(final Trie<K, ? extends V> trie) {\n    if (trie instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final Trie<K, V> tmpTrie = (Trie<K, V>) trie;\n        return tmpTrie;\n    }\n    return new UnmodifiableTrie<K, V>(trie);\n}"
            ],
            [
                "isOutOfBoundsIndex",
                "org.apache.commons.collections4.trie",
                "KeyAnalyzer",
                "/**\n * Returns true if bitIndex is a {@link KeyAnalyzer#OUT_OF_BOUNDS_BIT_KEY}.\n */\nstatic boolean isOutOfBoundsIndex(final int bitIndex) {\n    return bitIndex == OUT_OF_BOUNDS_BIT_KEY;\n}"
            ],
            [
                "isEqualBitKey",
                "org.apache.commons.collections4.trie",
                "KeyAnalyzer",
                "/**\n * Returns true if bitIndex is a {@link KeyAnalyzer#EQUAL_BIT_KEY}.\n */\nstatic boolean isEqualBitKey(final int bitIndex) {\n    return bitIndex == EQUAL_BIT_KEY;\n}"
            ],
            [
                "isNullBitKey",
                "org.apache.commons.collections4.trie",
                "KeyAnalyzer",
                "/**\n * Returns true if bitIndex is a {@link KeyAnalyzer#NULL_BIT_KEY}.\n */\nstatic boolean isNullBitKey(final int bitIndex) {\n    return bitIndex == NULL_BIT_KEY;\n}"
            ],
            [
                "isValidBitIndex",
                "org.apache.commons.collections4.trie",
                "KeyAnalyzer",
                "/**\n * Returns true if the given bitIndex is valid.\n * Indices are considered valid if they're between 0 and {@link Integer#MAX_VALUE}\n */\nstatic boolean isValidBitIndex(final int bitIndex) {\n    return bitIndex >= 0;\n}"
            ],
            [
                "isValidUplink",
                "org.apache.commons.collections4.trie",
                "AbstractPatriciaTrie",
                "/**\n * Returns true if 'next' is a valid uplink coming from 'from'.\n */\nstatic boolean isValidUplink(final TrieEntry<?, ?> next, final TrieEntry<?, ?> from) {\n    return next != null && next.bitIndex <= from.bitIndex && !next.isEmpty();\n}"
            ],
            [
                "compare",
                "org.apache.commons.collections4.trie",
                "AbstractBitwiseTrie",
                "/**\n * Returns true if both values are either null or equal.\n */\nstatic boolean compare(final Object a, final Object b) {\n    return a == null ? b == null : a.equals(b);\n}"
            ],
            [
                "transformingSortedMap",
                "org.apache.commons.collections4.map",
                "TransformedSortedMap",
                "/**\n * Factory method to create a transforming sorted map.\n * <p>\n * If there are any elements already in the map being decorated, they are NOT transformed.\n * Contrast this with {@link #transformedSortedMap(SortedMap, Transformer, Transformer)}.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param keyTransformer  the predicate to validate the keys, null means no transformation\n * @param valueTransformer  the predicate to validate to values, null means no transformation\n * @return a new transformed sorted map\n * @throws NullPointerException if the map is null\n * @since 4.0\n */\npublic static <K, V> TransformedSortedMap<K, V> transformingSortedMap(final SortedMap<K, V> map, final Transformer<? super K, ? extends K> keyTransformer, final Transformer<? super V, ? extends V> valueTransformer) {\n    return new TransformedSortedMap<K, V>(map, keyTransformer, valueTransformer);\n}"
            ],
            [
                "transformedSortedMap",
                "org.apache.commons.collections4.map",
                "TransformedSortedMap",
                "/**\n * Factory method to create a transforming sorted map that will transform\n * existing contents of the specified map.\n * <p>\n * If there are any elements already in the map being decorated, they\n * will be transformed by this method.\n * Contrast this with {@link #transformingSortedMap(SortedMap, Transformer, Transformer)}.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param keyTransformer  the transformer to use for key conversion, null means no transformation\n * @param valueTransformer  the transformer to use for value conversion, null means no transformation\n * @return a new transformed sorted map\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> TransformedSortedMap<K, V> transformedSortedMap(final SortedMap<K, V> map, final Transformer<? super K, ? extends K> keyTransformer, final Transformer<? super V, ? extends V> valueTransformer) {\n    final TransformedSortedMap<K, V> decorated = new TransformedSortedMap<K, V>(map, keyTransformer, valueTransformer);\n    if (map.size() > 0) {\n        final Map<K, V> transformed = decorated.transformMap(map);\n        decorated.clear();\n        // avoids double transformation\n        decorated.decorated().putAll(transformed);\n    }\n    return decorated;\n}"
            ],
            [
                "predicatedMap",
                "org.apache.commons.collections4.map",
                "PredicatedMap",
                "/**\n * Factory method to create a predicated (validating) map.\n * <p>\n * If there are any elements already in the list being decorated, they\n * are validated.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param keyPredicate  the predicate to validate the keys, null means no check\n * @param valuePredicate  the predicate to validate to values, null means no check\n * @return a new predicated map\n * @throws NullPointerException if the map is null\n * @since 4.0\n */\npublic static <K, V> PredicatedMap<K, V> predicatedMap(final Map<K, V> map, final Predicate<? super K> keyPredicate, final Predicate<? super V> valuePredicate) {\n    return new PredicatedMap<K, V>(map, keyPredicate, valuePredicate);\n}"
            ],
            [
                "fixedSizeSortedMap",
                "org.apache.commons.collections4.map",
                "FixedSizeSortedMap",
                "/**\n * Factory method to create a fixed size sorted map.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @return a new fixed size sorted map\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> FixedSizeSortedMap<K, V> fixedSizeSortedMap(final SortedMap<K, V> map) {\n    return new FixedSizeSortedMap<K, V>(map);\n}"
            ],
            [
                "unmodifiableSortedMap",
                "org.apache.commons.collections4.map",
                "UnmodifiableSortedMap",
                "/**\n * Factory method to create an unmodifiable sorted map.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @return a new unmodifiable sorted map\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> SortedMap<K, V> unmodifiableSortedMap(final SortedMap<K, ? extends V> map) {\n    if (map instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final SortedMap<K, V> tmpMap = (SortedMap<K, V>) map;\n        return tmpMap;\n    }\n    return new UnmodifiableSortedMap<K, V>(map);\n}"
            ],
            [
                "predicatedSortedMap",
                "org.apache.commons.collections4.map",
                "PredicatedSortedMap",
                "/**\n * Factory method to create a predicated (validating) sorted map.\n * <p>\n * If there are any elements already in the list being decorated, they\n * are validated.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param keyPredicate  the predicate to validate the keys, null means no check\n * @param valuePredicate  the predicate to validate to values, null means no check\n * @return a new predicated sorted map\n * @throws NullPointerException if the map is null\n * @since 4.0\n */\npublic static <K, V> PredicatedSortedMap<K, V> predicatedSortedMap(final SortedMap<K, V> map, final Predicate<? super K> keyPredicate, final Predicate<? super V> valuePredicate) {\n    return new PredicatedSortedMap<K, V>(map, keyPredicate, valuePredicate);\n}"
            ],
            [
                "defaultedMap",
                "org.apache.commons.collections4.map",
                "DefaultedMap",
                "//-----------------------------------------------------------------------\n/**\n * Factory method to create a defaulting map.\n * <p>\n * The value specified is returned when a missing key is found.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param defaultValue  the default value to return when the key is not found\n * @return a new defaulting map\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> DefaultedMap<K, V> defaultedMap(final Map<K, V> map, final V defaultValue) {\n    return new DefaultedMap<K, V>(map, ConstantTransformer.constantTransformer(defaultValue));\n}"
            ],
            [
                "defaultedMap",
                "org.apache.commons.collections4.map",
                "DefaultedMap",
                "/**\n * Factory method to create a defaulting map.\n * <p>\n * The factory specified is called when a missing key is found.\n * The result will be returned as the result of the map get(key) method.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param factory  the factory to use to create entries, must not be null\n * @return a new defaulting map\n * @throws NullPointerException if map or factory is null\n * @since 4.0\n */\npublic static <K, V> DefaultedMap<K, V> defaultedMap(final Map<K, V> map, final Factory<? extends V> factory) {\n    if (factory == null) {\n        throw new IllegalArgumentException(\"Factory must not be null\");\n    }\n    return new DefaultedMap<K, V>(map, FactoryTransformer.factoryTransformer(factory));\n}"
            ],
            [
                "defaultedMap",
                "org.apache.commons.collections4.map",
                "DefaultedMap",
                "/**\n * Factory method to create a defaulting map.\n * <p>\n * The transformer specified is called when a missing key is found.\n * The key is passed to the transformer as the input, and the result\n * will be returned as the result of the map get(key) method.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param transformer  the transformer to use as a factory to create entries, must not be null\n * @return a new defaulting map\n * @throws NullPointerException if map or factory is null\n * @since 4.0\n */\npublic static <K, V> Map<K, V> defaultedMap(final Map<K, V> map, final Transformer<? super K, ? extends V> transformer) {\n    if (transformer == null) {\n        throw new IllegalArgumentException(\"Transformer must not be null\");\n    }\n    return new DefaultedMap<K, V>(map, transformer);\n}"
            ],
            [
                "fixedSizeMap",
                "org.apache.commons.collections4.map",
                "FixedSizeMap",
                "/**\n * Factory method to create a fixed size map.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @return a new fixed size map\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> FixedSizeMap<K, V> fixedSizeMap(final Map<K, V> map) {\n    return new FixedSizeMap<K, V>(map);\n}"
            ],
            [
                "lazySortedMap",
                "org.apache.commons.collections4.map",
                "LazySortedMap",
                "/**\n * Factory method to create a lazily instantiated sorted map.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param factory  the factory to use, must not be null\n * @return a new lazy sorted map\n * @throws NullPointerException if map or factory is null\n * @since 4.0\n */\npublic static <K, V> LazySortedMap<K, V> lazySortedMap(final SortedMap<K, V> map, final Factory<? extends V> factory) {\n    return new LazySortedMap<K, V>(map, factory);\n}"
            ],
            [
                "lazySortedMap",
                "org.apache.commons.collections4.map",
                "LazySortedMap",
                "/**\n * Factory method to create a lazily instantiated sorted map.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param factory  the factory to use, must not be null\n * @return a new lazy sorted map\n * @throws NullPointerException if map or factory is null\n * @since 4.0\n */\npublic static <K, V> LazySortedMap<K, V> lazySortedMap(final SortedMap<K, V> map, final Transformer<? super K, ? extends V> factory) {\n    return new LazySortedMap<K, V>(map, factory);\n}"
            ],
            [
                "unmodifiableOrderedMap",
                "org.apache.commons.collections4.map",
                "UnmodifiableOrderedMap",
                "/**\n * Factory method to create an unmodifiable sorted map.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @return a new ordered map\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> OrderedMap<K, V> unmodifiableOrderedMap(final OrderedMap<? extends K, ? extends V> map) {\n    if (map instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final OrderedMap<K, V> tmpMap = (OrderedMap<K, V>) map;\n        return tmpMap;\n    }\n    return new UnmodifiableOrderedMap<K, V>(map);\n}"
            ],
            [
                "unmodifiableMap",
                "org.apache.commons.collections4.map",
                "UnmodifiableMap",
                "/**\n * Factory method to create an unmodifiable map.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @return a new unmodifiable map\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> Map<K, V> unmodifiableMap(final Map<? extends K, ? extends V> map) {\n    if (map instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final Map<K, V> tmpMap = (Map<K, V>) map;\n        return tmpMap;\n    }\n    return new UnmodifiableMap<K, V>(map);\n}"
            ],
            [
                "listOrderedMap",
                "org.apache.commons.collections4.map",
                "ListOrderedMap",
                "/**\n * Factory method to create an ordered map.\n * <p>\n * An <code>ArrayList</code> is used to retain order.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @return a new list ordered map\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> ListOrderedMap<K, V> listOrderedMap(final Map<K, V> map) {\n    return new ListOrderedMap<K, V>(map);\n}"
            ],
            [
                "unmodifiableEntrySet",
                "org.apache.commons.collections4.map",
                "UnmodifiableEntrySet",
                "/**\n * Factory method to create an unmodifiable set of Map Entry objects.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param set  the set to decorate, must not be null\n * @return a new unmodifiable entry set\n * @throws NullPointerException if set is null\n * @since 4.0\n */\npublic static <K, V> Set<Map.Entry<K, V>> unmodifiableEntrySet(final Set<Map.Entry<K, V>> set) {\n    if (set instanceof Unmodifiable) {\n        return set;\n    }\n    return new UnmodifiableEntrySet<K, V>(set);\n}"
            ],
            [
                "resolve",
                "org.apache.commons.collections4.map",
                "AbstractReferenceMap",
                "/**\n * Resolve enum from int.\n * @param value  the int value\n * @return ReferenceType\n * @throws IllegalArgumentException if the specified value is invalid.\n */\npublic static ReferenceStrength resolve(final int value) {\n    switch(value) {\n        case 0:\n            return HARD;\n        case 1:\n            return SOFT;\n        case 2:\n            return WEAK;\n        default:\n            throw new IllegalArgumentException();\n    }\n}"
            ],
            [
                "resolve",
                "org.apache.commons.collections4.map",
                "ReferenceStrength",
                "/**\n * Resolve enum from int.\n * @param value  the int value\n * @return ReferenceType\n * @throws IllegalArgumentException if the specified value is invalid.\n */\npublic static ReferenceStrength resolve(final int value) {\n    switch(value) {\n        case 0:\n            return HARD;\n        case 1:\n            return SOFT;\n        case 2:\n            return WEAK;\n        default:\n            throw new IllegalArgumentException();\n    }\n}"
            ],
            [
                "multiKeyMap",
                "org.apache.commons.collections4.map",
                "MultiKeyMap",
                "//-----------------------------------------------------------------------\n/**\n * Decorates the specified map to add the MultiKeyMap API and fast query.\n * The map must not be null and must be empty.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, not null\n * @return a new multi key map\n * @throws NullPointerException if map is null\n * @throws IllegalArgumentException if the map is not empty\n * @since 4.0\n */\npublic static <K, V> MultiKeyMap<K, V> multiKeyMap(final AbstractHashedMap<MultiKey<? extends K>, V> map) {\n    if (map == null) {\n        throw new NullPointerException(\"Map must not be null\");\n    }\n    if (map.size() > 0) {\n        throw new IllegalArgumentException(\"Map must be empty\");\n    }\n    return new MultiKeyMap<K, V>(map);\n}"
            ],
            [
                "lazyMap",
                "org.apache.commons.collections4.map",
                "LazyMap",
                "/**\n * Factory method to create a lazily instantiated map.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param factory  the factory to use, must not be null\n * @return a new lazy map\n * @throws NullPointerException if map or factory is null\n * @since 4.0\n */\npublic static <K, V> LazyMap<K, V> lazyMap(final Map<K, V> map, final Factory<? extends V> factory) {\n    return new LazyMap<K, V>(map, factory);\n}"
            ],
            [
                "lazyMap",
                "org.apache.commons.collections4.map",
                "LazyMap",
                "/**\n * Factory method to create a lazily instantiated map.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param factory  the factory to use, must not be null\n * @return a new lazy map\n * @throws NullPointerException if map or factory is null\n * @since 4.0\n */\npublic static <V, K> LazyMap<K, V> lazyMap(final Map<K, V> map, final Transformer<? super K, ? extends V> factory) {\n    return new LazyMap<K, V>(map, factory);\n}"
            ],
            [
                "multiValueMap",
                "org.apache.commons.collections4.map",
                "MultiValueMap",
                "/**\n * Creates a map which wraps the given map and\n * maps keys to ArrayLists.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to wrap\n * @return a new multi-value map\n * @since 4.0\n */\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\npublic static <K, V> MultiValueMap<K, V> multiValueMap(final Map<K, ? super Collection<V>> map) {\n    return MultiValueMap.<K, V, ArrayList>multiValueMap((Map<K, ? super Collection>) map, ArrayList.class);\n}"
            ],
            [
                "multiValueMap",
                "org.apache.commons.collections4.map",
                "MultiValueMap",
                "/**\n * Creates a map which decorates the given <code>map</code> and\n * maps keys to collections of type <code>collectionClass</code>.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param <C>  the collection class type\n * @param map  the map to wrap\n * @param collectionClass  the type of the collection class\n * @return a new multi-value map\n * @since 4.0\n */\npublic static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(final Map<K, ? super C> map, final Class<C> collectionClass) {\n    return new MultiValueMap<K, V>(map, new ReflectionFactory<C>(collectionClass));\n}"
            ],
            [
                "multiValueMap",
                "org.apache.commons.collections4.map",
                "MultiValueMap",
                "/**\n * Creates a map which decorates the given <code>map</code> and\n * creates the value collections using the supplied <code>collectionFactory</code>.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param <C>  the collection class type\n * @param map  the map to decorate\n * @param collectionFactory  the collection factory (must return a Collection object).\n * @return a new multi-value map\n * @since 4.0\n */\npublic static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(final Map<K, ? super C> map, final Factory<C> collectionFactory) {\n    return new MultiValueMap<K, V>(map, collectionFactory);\n}"
            ],
            [
                "transformingMap",
                "org.apache.commons.collections4.map",
                "TransformedMap",
                "/**\n * Factory method to create a transforming map.\n * <p>\n * If there are any elements already in the map being decorated, they\n * are NOT transformed.\n * Contrast this with {@link #transformedMap(Map, Transformer, Transformer)}.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param keyTransformer  the transformer to use for key conversion, null means no transformation\n * @param valueTransformer  the transformer to use for value conversion, null means no transformation\n * @return a new transformed map\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> TransformedMap<K, V> transformingMap(final Map<K, V> map, final Transformer<? super K, ? extends K> keyTransformer, final Transformer<? super V, ? extends V> valueTransformer) {\n    return new TransformedMap<K, V>(map, keyTransformer, valueTransformer);\n}"
            ],
            [
                "transformedMap",
                "org.apache.commons.collections4.map",
                "TransformedMap",
                "/**\n * Factory method to create a transforming map that will transform\n * existing contents of the specified map.\n * <p>\n * If there are any elements already in the map being decorated, they\n * will be transformed by this method.\n * Contrast this with {@link #transformingMap(Map, Transformer, Transformer)}.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param keyTransformer  the transformer to use for key conversion, null means no transformation\n * @param valueTransformer  the transformer to use for value conversion, null means no transformation\n * @return a new transformed map\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> TransformedMap<K, V> transformedMap(final Map<K, V> map, final Transformer<? super K, ? extends K> keyTransformer, final Transformer<? super V, ? extends V> valueTransformer) {\n    final TransformedMap<K, V> decorated = new TransformedMap<K, V>(map, keyTransformer, valueTransformer);\n    if (map.size() > 0) {\n        final Map<K, V> transformed = decorated.transformMap(map);\n        decorated.clear();\n        // avoids double transformation\n        decorated.decorated().putAll(transformed);\n    }\n    return decorated;\n}"
            ],
            [
                "synchronizedMultiSet",
                "org.apache.commons.collections4",
                "MultiSetUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns a synchronized (thread-safe) multiset backed by the given multiset.\n * In order to guarantee serial access, it is critical that all access to the\n * backing multiset is accomplished through the returned multiset.\n * <p>\n * It is imperative that the user manually synchronize on the returned multiset\n * when iterating over it:\n *\n * <pre>\n * MultiSet multiset = MultiSetUtils.synchronizedMultiSet(new HashMultiSet());\n * ...\n * synchronized(multiset) {\n *     Iterator i = multiset.iterator(); // Must be in synchronized block\n *     while (i.hasNext())\n *         foo(i.next());\n *     }\n * }\n * </pre>\n *\n * Failure to follow this advice may result in non-deterministic behavior.\n *\n * @param <E> the element type\n * @param multiset the multiset to synchronize, must not be null\n * @return a synchronized multiset backed by that multiset\n * @throws NullPointerException if the MultiSet is null\n */\npublic static <E> MultiSet<E> synchronizedMultiSet(final MultiSet<E> multiset) {\n    return SynchronizedMultiSet.synchronizedMultiSet(multiset);\n}"
            ],
            [
                "unmodifiableMultiSet",
                "org.apache.commons.collections4",
                "MultiSetUtils",
                "/**\n * Returns an unmodifiable view of the given multiset. Any modification attempts\n * to the returned multiset will raise an {@link UnsupportedOperationException}.\n *\n * @param <E> the element type\n * @param multiset the multiset whose unmodifiable view is to be returned, must not be null\n * @return an unmodifiable view of that multiset\n * @throws NullPointerException if the MultiSet is null\n */\npublic static <E> MultiSet<E> unmodifiableMultiSet(final MultiSet<? extends E> multiset) {\n    return UnmodifiableMultiSet.unmodifiableMultiSet(multiset);\n}"
            ],
            [
                "predicatedMultiSet",
                "org.apache.commons.collections4",
                "MultiSetUtils",
                "/**\n * Returns a predicated (validating) multiset backed by the given multiset.\n * <p>\n * Only objects that pass the test in the given predicate can be added to\n * the multiset. Trying to add an invalid object results in an\n * IllegalArgumentException. It is important not to use the original multiset\n * after invoking this method, as it is a backdoor for adding invalid\n * objects.\n *\n * @param <E> the element type\n * @param multiset the multiset to predicate, must not be null\n * @param predicate the predicate for the multiset, must not be null\n * @return a predicated multiset backed by the given multiset\n * @throws NullPointerException if the MultiSet or Predicate is null\n */\npublic static <E> MultiSet<E> predicatedMultiSet(final MultiSet<E> multiset, final Predicate<? super E> predicate) {\n    return PredicatedMultiSet.predicatedMultiSet(multiset, predicate);\n}"
            ],
            [
                "emptyMultiSet",
                "org.apache.commons.collections4",
                "MultiSetUtils",
                "/**\n * Get an empty <code>MultiSet</code>.\n *\n * @param <E> the element type\n * @return an empty MultiSet\n */\n// OK, empty multiset is compatible with any type\n@SuppressWarnings(\"unchecked\")\npublic static <E> MultiSet<E> emptyMultiSet() {\n    return EMPTY_MULTISET;\n}"
            ],
            [
                "unmodifiableMultiValuedMap",
                "org.apache.commons.collections4.multimap",
                "UnmodifiableMultiValuedMap",
                "/**\n * Factory method to create an unmodifiable MultiValuedMap.\n * <p>\n * If the map passed in is already unmodifiable, it is returned.\n *\n * @param <K> the type of key elements\n * @param <V> the type of value elements\n * @param map  the map to decorate, may not be null\n * @return an unmodifiable MultiValuedMap\n * @throws NullPointerException if map is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <K, V> UnmodifiableMultiValuedMap<K, V> unmodifiableMultiValuedMap(MultiValuedMap<? extends K, ? extends V> map) {\n    if (map instanceof Unmodifiable) {\n        return (UnmodifiableMultiValuedMap<K, V>) map;\n    }\n    return new UnmodifiableMultiValuedMap<K, V>(map);\n}"
            ],
            [
                "transformingMap",
                "org.apache.commons.collections4.multimap",
                "TransformedMultiValuedMap",
                "/**\n * Factory method to create a transforming MultiValuedMap.\n * <p>\n * If there are any elements already in the map being decorated, they are\n * NOT transformed. Contrast this with\n * {@link #transformedMap(MultiValuedMap, Transformer, Transformer)}.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the MultiValuedMap to decorate, may not be null\n * @param keyTransformer  the transformer to use for key conversion, null means no conversion\n * @param valueTransformer  the transformer to use for value conversion, null means no conversion\n * @return a new transformed MultiValuedMap\n * @throws NullPointerException if map is null\n */\npublic static <K, V> TransformedMultiValuedMap<K, V> transformingMap(final MultiValuedMap<K, V> map, final Transformer<? super K, ? extends K> keyTransformer, final Transformer<? super V, ? extends V> valueTransformer) {\n    return new TransformedMultiValuedMap<K, V>(map, keyTransformer, valueTransformer);\n}"
            ],
            [
                "transformedMap",
                "org.apache.commons.collections4.multimap",
                "TransformedMultiValuedMap",
                "/**\n * Factory method to create a transforming MultiValuedMap that will\n * transform existing contents of the specified map.\n * <p>\n * If there are any elements already in the map being decorated, they will\n * be transformed by this method. Contrast this with\n * {@link #transformingMap(MultiValuedMap, Transformer, Transformer)}.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the MultiValuedMap to decorate, may not be null\n * @param keyTransformer  the transformer to use for key conversion, null means no conversion\n * @param valueTransformer  the transformer to use for value conversion, null means no conversion\n * @return a new transformed MultiValuedMap\n * @throws NullPointerException if map is null\n */\npublic static <K, V> TransformedMultiValuedMap<K, V> transformedMap(final MultiValuedMap<K, V> map, final Transformer<? super K, ? extends K> keyTransformer, final Transformer<? super V, ? extends V> valueTransformer) {\n    final TransformedMultiValuedMap<K, V> decorated = new TransformedMultiValuedMap<K, V>(map, keyTransformer, valueTransformer);\n    if (!map.isEmpty()) {\n        final MultiValuedMap<K, V> mapCopy = new ArrayListValuedHashMap<K, V>(map);\n        decorated.clear();\n        decorated.putAll(mapCopy);\n    }\n    return decorated;\n}"
            ],
            [
                "lazyList",
                "org.apache.commons.collections4.list",
                "LazyList",
                "/**\n * Factory method to create a lazily instantiating list.\n *\n * @param <E> the type of the elements in the list\n * @param list  the list to decorate, must not be null\n * @param factory  the factory to use for creation, must not be null\n * @return a new lazy list\n * @throws NullPointerException if list or factory is null\n * @since 4.0\n */\npublic static <E> LazyList<E> lazyList(final List<E> list, final Factory<? extends E> factory) {\n    return new LazyList<E>(list, factory);\n}"
            ],
            [
                "setUniqueList",
                "org.apache.commons.collections4.list",
                "SetUniqueList",
                "/**\n * Factory method to create a SetList using the supplied list to retain order.\n * <p>\n * If the list contains duplicates, these are removed (first indexed one\n * kept). A <code>HashSet</code> is used for the set behaviour.\n *\n * @param <E>  the element type\n * @param list  the list to decorate, must not be null\n * @return a new {@link SetUniqueList}\n * @throws NullPointerException if list is null\n * @since 4.0\n */\npublic static <E> SetUniqueList<E> setUniqueList(final List<E> list) {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) {\n        return new SetUniqueList<E>(list, new HashSet<E>());\n    }\n    final List<E> temp = new ArrayList<E>(list);\n    list.clear();\n    final SetUniqueList<E> sl = new SetUniqueList<E>(list, new HashSet<E>());\n    sl.addAll(temp);\n    return sl;\n}"
            ],
            [
                "unmodifiableList",
                "org.apache.commons.collections4.list",
                "UnmodifiableList",
                "/**\n * Factory method to create an unmodifiable list.\n *\n * @param <E> the type of the elements in the list\n * @param list  the list to decorate, must not be null\n * @return a new unmodifiable list\n * @throws NullPointerException if list is null\n * @since 4.0\n */\npublic static <E> List<E> unmodifiableList(final List<? extends E> list) {\n    if (list instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final List<E> tmpList = (List<E>) list;\n        return tmpList;\n    }\n    return new UnmodifiableList<E>(list);\n}"
            ],
            [
                "fixedSizeList",
                "org.apache.commons.collections4.list",
                "FixedSizeList",
                "/**\n * Factory method to create a fixed size list.\n *\n * @param <E> the type of the elements in the list\n * @param list  the list to decorate, must not be null\n * @return a new fixed size list\n * @throws NullPointerException if list is null\n * @since 4.0\n */\npublic static <E> FixedSizeList<E> fixedSizeList(final List<E> list) {\n    return new FixedSizeList<E>(list);\n}"
            ],
            [
                "transformingList",
                "org.apache.commons.collections4.list",
                "TransformedList",
                "/**\n * Factory method to create a transforming list.\n * <p>\n * If there are any elements already in the list being decorated, they\n * are NOT transformed.\n * Contrast this with {@link #transformedList(List, Transformer)}.\n *\n * @param <E> the type of the elements in the list\n * @param list  the list to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed list\n * @throws NullPointerException if list or transformer is null\n * @since 4.0\n */\npublic static <E> TransformedList<E> transformingList(final List<E> list, final Transformer<? super E, ? extends E> transformer) {\n    return new TransformedList<E>(list, transformer);\n}"
            ],
            [
                "transformedList",
                "org.apache.commons.collections4.list",
                "TransformedList",
                "/**\n * Factory method to create a transforming list that will transform\n * existing contents of the specified list.\n * <p>\n * If there are any elements already in the list being decorated, they\n * will be transformed by this method.\n * Contrast this with {@link #transformingList(List, Transformer)}.\n *\n * @param <E> the type of the elements in the list\n * @param list  the list to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed List\n * @throws NullPointerException if list or transformer is null\n * @since 4.0\n */\npublic static <E> TransformedList<E> transformedList(final List<E> list, final Transformer<? super E, ? extends E> transformer) {\n    final TransformedList<E> decorated = new TransformedList<E>(list, transformer);\n    if (list.size() > 0) {\n        // list is of type E\n        @SuppressWarnings(\"unchecked\")\n        final E[] // NOPMD - false positive for generics\n        values = (E[]) list.toArray();\n        list.clear();\n        for (final E value : values) {\n            decorated.decorated().add(transformer.transform(value));\n        }\n    }\n    return decorated;\n}"
            ],
            [
                "growthList",
                "org.apache.commons.collections4.list",
                "GrowthList",
                "/**\n * Factory method to create a growth list.\n *\n * @param <E> the type of the elements in the list\n * @param list  the list to decorate, must not be null\n * @return a new growth list\n * @throws NullPointerException if list is null\n * @since 4.0\n */\npublic static <E> GrowthList<E> growthList(final List<E> list) {\n    return new GrowthList<E>(list);\n}"
            ],
            [
                "predicatedList",
                "org.apache.commons.collections4.list",
                "PredicatedList",
                "/**\n * Factory method to create a predicated (validating) list.\n * <p>\n * If there are any elements already in the list being decorated, they\n * are validated.\n *\n * @param <T> the type of the elements in the list\n * @param list  the list to decorate, must not be null\n * @param predicate  the predicate to use for validation, must not be null\n * @return a new predicated list\n * @throws NullPointerException if list or predicate is null\n * @throws IllegalArgumentException if the list contains invalid elements\n * @since 4.0\n */\npublic static <T> PredicatedList<T> predicatedList(final List<T> list, final Predicate<? super T> predicate) {\n    return new PredicatedList<T>(list, predicate);\n}"
            ],
            [
                "transformingQueue",
                "org.apache.commons.collections4.queue",
                "TransformedQueue",
                "/**\n * Factory method to create a transforming queue.\n * <p>\n * If there are any elements already in the queue being decorated, they\n * are NOT transformed.\n * Contrast this with {@link #transformedQueue(Queue, Transformer)}.\n *\n * @param <E> the type of the elements in the queue\n * @param queue  the queue to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed Queue\n * @throws NullPointerException if queue or transformer is null\n */\npublic static <E> TransformedQueue<E> transformingQueue(final Queue<E> queue, final Transformer<? super E, ? extends E> transformer) {\n    return new TransformedQueue<E>(queue, transformer);\n}"
            ],
            [
                "transformedQueue",
                "org.apache.commons.collections4.queue",
                "TransformedQueue",
                "/**\n * Factory method to create a transforming queue that will transform\n * existing contents of the specified queue.\n * <p>\n * If there are any elements already in the queue being decorated, they\n * will be transformed by this method.\n * Contrast this with {@link #transformingQueue(Queue, Transformer)}.\n *\n * @param <E> the type of the elements in the queue\n * @param queue  the queue to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed Queue\n * @throws NullPointerException if queue or transformer is null\n * @since 4.0\n */\npublic static <E> TransformedQueue<E> transformedQueue(final Queue<E> queue, final Transformer<? super E, ? extends E> transformer) {\n    // throws IAE if queue or transformer is null\n    final TransformedQueue<E> decorated = new TransformedQueue<E>(queue, transformer);\n    if (queue.size() > 0) {\n        // queue is type <E>\n        @SuppressWarnings(\"unchecked\")\n        final E[] // NOPMD - false positive for generics\n        values = (E[]) queue.toArray();\n        queue.clear();\n        for (final E value : values) {\n            decorated.decorated().add(transformer.transform(value));\n        }\n    }\n    return decorated;\n}"
            ],
            [
                "unmodifiableQueue",
                "org.apache.commons.collections4.queue",
                "UnmodifiableQueue",
                "/**\n * Factory method to create an unmodifiable queue.\n * <p>\n * If the queue passed in is already unmodifiable, it is returned.\n *\n * @param <E> the type of the elements in the queue\n * @param queue  the queue to decorate, must not be null\n * @return an unmodifiable Queue\n * @throws NullPointerException if queue is null\n */\npublic static <E> Queue<E> unmodifiableQueue(final Queue<? extends E> queue) {\n    if (queue instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final Queue<E> tmpQueue = (Queue<E>) queue;\n        return tmpQueue;\n    }\n    return new UnmodifiableQueue<E>(queue);\n}"
            ],
            [
                "predicatedQueue",
                "org.apache.commons.collections4.queue",
                "PredicatedQueue",
                "/**\n * Factory method to create a predicated (validating) queue.\n * <p>\n * If there are any elements already in the queue being decorated, they\n * are validated.\n *\n * @param <E> the type of the elements in the queue\n * @param Queue  the queue to decorate, must not be null\n * @param predicate  the predicate to use for validation, must not be null\n * @return a new predicated queue\n * @throws NullPointerException if queue or predicate is null\n * @throws IllegalArgumentException if the queue contains invalid elements\n */\npublic static <E> PredicatedQueue<E> predicatedQueue(final Queue<E> Queue, final Predicate<? super E> predicate) {\n    return new PredicatedQueue<E>(Queue, predicate);\n}"
            ],
            [
                "empty",
                "org.apache.commons.collections4",
                "FluentIterable",
                "// Static factory methods\n// ----------------------------------------------------------------------\n/**\n * Creates a new empty FluentIterable.\n *\n * @param <T>  the element type\n * @return a new empty FluentIterable\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> FluentIterable<T> empty() {\n    return IterableUtils.EMPTY_ITERABLE;\n}"
            ],
            [
                "of",
                "org.apache.commons.collections4",
                "FluentIterable",
                "/**\n * Creates a new FluentIterable of the single provided element.\n * <p>\n * The returned iterable's iterator does not support {@code remove()}.\n *\n * @param <T>  the element type\n * @param singleton  the singleton element\n * @return a new FluentIterable containing the singleton\n */\npublic static <T> FluentIterable<T> of(final T singleton) {\n    return of(IteratorUtils.asIterable(new SingletonIterator<T>(singleton, false)));\n}"
            ],
            [
                "of",
                "org.apache.commons.collections4",
                "FluentIterable",
                "/**\n * Creates a new FluentIterable from the provided elements.\n * <p>\n * The returned iterable's iterator does not support {@code remove()}.\n *\n * @param <T>  the element type\n * @param elements  the elements to be contained in the FluentIterable\n * @return a new FluentIterable containing the provided elements\n */\npublic static <T> FluentIterable<T> of(final T... elements) {\n    return of(Arrays.asList(elements));\n}"
            ],
            [
                "of",
                "org.apache.commons.collections4",
                "FluentIterable",
                "/**\n * Construct a new FluentIterable from the provided iterable. If the\n * iterable is already an instance of FluentIterable, the instance\n * will be returned instead.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the\n * corresponding input iterator supports it.\n *\n * @param <T>  the element type\n * @param iterable  the iterable to wrap into a FluentIterable, may not be null\n * @return a new FluentIterable wrapping the provided iterable\n * @throws NullPointerException if iterable is null\n */\npublic static <T> FluentIterable<T> of(final Iterable<T> iterable) {\n    IterableUtils.checkNotNull(iterable);\n    if (iterable instanceof FluentIterable<?>) {\n        return (FluentIterable<T>) iterable;\n    } else {\n        return new FluentIterable<T>(iterable);\n    }\n}"
            ],
            [
                "exceptionTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Gets a transformer that always throws an exception.\n * This could be useful during testing as a placeholder.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @return the transformer\n * @see ExceptionTransformer\n */\npublic static <I, O> Transformer<I, O> exceptionTransformer() {\n    return ExceptionTransformer.exceptionTransformer();\n}"
            ],
            [
                "nullTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Gets a transformer that always returns null.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @return the transformer\n * @see ConstantTransformer\n */\npublic static <I, O> Transformer<I, O> nullTransformer() {\n    return ConstantTransformer.nullTransformer();\n}"
            ],
            [
                "nopTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Gets a transformer that returns the input object.\n * The input object should be immutable to maintain the\n * contract of Transformer (although this is not checked).\n *\n * @param <T>  the input/output type\n * @return the transformer\n * @see NOPTransformer\n */\npublic static <T> Transformer<T, T> nopTransformer() {\n    return NOPTransformer.nopTransformer();\n}"
            ],
            [
                "cloneTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Gets a transformer that returns a clone of the input object.\n * The input object will be cloned using one of these techniques (in order):\n * <ul>\n * <li>public clone method\n * <li>public copy constructor\n * <li>serialization clone\n * <ul>\n *\n * @param <T>  the input/output type\n * @return the transformer\n * @see CloneTransformer\n */\npublic static <T> Transformer<T, T> cloneTransformer() {\n    return CloneTransformer.cloneTransformer();\n}"
            ],
            [
                "constantTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Creates a Transformer that will return the same object each time the\n * transformer is used.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param constantToReturn  the constant object to return each time in the transformer\n * @return the transformer.\n * @see ConstantTransformer\n */\npublic static <I, O> Transformer<I, O> constantTransformer(final O constantToReturn) {\n    return ConstantTransformer.constantTransformer(constantToReturn);\n}"
            ],
            [
                "asTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Creates a Transformer that calls a Closure each time the transformer is used.\n * The transformer returns the input object.\n *\n * @param <T>  the input/output type\n * @param closure  the closure to run each time in the transformer, not null\n * @return the transformer\n * @throws NullPointerException if the closure is null\n * @see ClosureTransformer\n */\npublic static <T> Transformer<T, T> asTransformer(final Closure<? super T> closure) {\n    return ClosureTransformer.closureTransformer(closure);\n}"
            ],
            [
                "asTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Creates a Transformer that calls a Predicate each time the transformer is used.\n * The transformer will return either Boolean.TRUE or Boolean.FALSE.\n *\n * @param <T>  the input type\n * @param predicate  the predicate to run each time in the transformer, not null\n * @return the transformer\n * @throws NullPointerException if the predicate is null\n * @see PredicateTransformer\n */\npublic static <T> Transformer<T, Boolean> asTransformer(final Predicate<? super T> predicate) {\n    return PredicateTransformer.predicateTransformer(predicate);\n}"
            ],
            [
                "asTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Creates a Transformer that calls a Factory each time the transformer is used.\n * The transformer will return the value returned by the factory.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param factory  the factory to run each time in the transformer, not null\n * @return the transformer\n * @throws NullPointerException if the factory is null\n * @see FactoryTransformer\n */\npublic static <I, O> Transformer<I, O> asTransformer(final Factory<? extends O> factory) {\n    return FactoryTransformer.factoryTransformer(factory);\n}"
            ],
            [
                "chainedTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Create a new Transformer that calls each transformer in turn, passing the\n * result into the next transformer.\n *\n * @param <T>  the input/output type\n * @param transformers  an array of transformers to chain\n * @return the transformer\n * @throws NullPointerException if the transformers array or any of the transformers is null\n * @see ChainedTransformer\n */\npublic static <T> Transformer<T, T> chainedTransformer(final Transformer<? super T, ? extends T>... transformers) {\n    return ChainedTransformer.chainedTransformer(transformers);\n}"
            ],
            [
                "chainedTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Create a new Transformer that calls each transformer in turn, passing the\n * result into the next transformer. The ordering is that of the iterator()\n * method on the collection.\n *\n * @param <T>  the input/output type\n * @param transformers  a collection of transformers to chain\n * @return the transformer\n * @throws NullPointerException if the transformers collection or any of the transformers is null\n * @see ChainedTransformer\n */\npublic static <T> Transformer<T, T> chainedTransformer(final Collection<? extends Transformer<? super T, ? extends T>> transformers) {\n    return ChainedTransformer.chainedTransformer(transformers);\n}"
            ],
            [
                "ifTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Create a new Transformer that calls the transformer if the predicate is true,\n * otherwise the input object is returned unchanged.\n *\n * @param <T>  the input / output type\n * @param predicate  the predicate to switch on\n * @param trueTransformer  the transformer called if the predicate is true\n * @return the transformer\n * @throws NullPointerException if either the predicate or transformer is null\n * @see IfTransformer\n * @since 4.1\n */\npublic static <T> Transformer<T, T> ifTransformer(final Predicate<? super T> predicate, final Transformer<? super T, ? extends T> trueTransformer) {\n    return IfTransformer.ifTransformer(predicate, trueTransformer);\n}"
            ],
            [
                "ifTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Create a new Transformer that calls one of two transformers depending\n * on the specified predicate.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param predicate  the predicate to switch on\n * @param trueTransformer  the transformer called if the predicate is true\n * @param falseTransformer  the transformer called if the predicate is false\n * @return the transformer\n * @throws NullPointerException if either the predicate or transformer is null\n * @see IfTransformer\n * @since 4.1\n */\npublic static <I, O> Transformer<I, O> ifTransformer(final Predicate<? super I> predicate, final Transformer<? super I, ? extends O> trueTransformer, final Transformer<? super I, ? extends O> falseTransformer) {\n    return IfTransformer.ifTransformer(predicate, trueTransformer, falseTransformer);\n}"
            ],
            [
                "switchTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Create a new Transformer that calls one of two transformers depending\n * on the specified predicate.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param predicate  the predicate to switch on\n * @param trueTransformer  the transformer called if the predicate is true\n * @param falseTransformer  the transformer called if the predicate is false\n * @return the transformer\n * @throws NullPointerException if either the predicate or transformer is null\n * @see SwitchTransformer\n * @deprecated as of 4.1, use {@link #ifTransformer(Predicate, Transformer, Transformer))\n */\n@SuppressWarnings(\"unchecked\")\n@Deprecated\npublic static <I, O> Transformer<I, O> switchTransformer(final Predicate<? super I> predicate, final Transformer<? super I, ? extends O> trueTransformer, final Transformer<? super I, ? extends O> falseTransformer) {\n    return SwitchTransformer.switchTransformer(new Predicate[] { predicate }, new Transformer[] { trueTransformer }, falseTransformer);\n}"
            ],
            [
                "switchTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Create a new Transformer that calls one of the transformers depending\n * on the predicates. The transformer at array location 0 is called if the\n * predicate at array location 0 returned true. Each predicate is evaluated\n * until one returns true. If no predicates evaluate to true, null is returned.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param predicates  an array of predicates to check\n * @param transformers  an array of transformers to call\n * @return the transformer\n * @throws NullPointerException if the either array is null\n * @throws NullPointerException if any element in the arrays is null\n * @throws IllegalArgumentException if the arrays have different sizes\n * @see SwitchTransformer\n */\npublic static <I, O> Transformer<I, O> switchTransformer(final Predicate<? super I>[] predicates, final Transformer<? super I, ? extends O>[] transformers) {\n    return SwitchTransformer.switchTransformer(predicates, transformers, null);\n}"
            ],
            [
                "switchTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Create a new Transformer that calls one of the transformers depending\n * on the predicates. The transformer at array location 0 is called if the\n * predicate at array location 0 returned true. Each predicate is evaluated\n * until one returns true. If no predicates evaluate to true, the default\n * transformer is called. If the default transformer is null, null is returned.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param predicates  an array of predicates to check\n * @param transformers  an array of transformers to call\n * @param defaultTransformer  the default to call if no predicate matches, null means return null\n * @return the transformer\n * @throws NullPointerException if the either array is null\n * @throws NullPointerException if any element in the arrays is null\n * @throws IllegalArgumentException if the arrays have different sizes\n * @see SwitchTransformer\n */\npublic static <I, O> Transformer<I, O> switchTransformer(final Predicate<? super I>[] predicates, final Transformer<? super I, ? extends O>[] transformers, final Transformer<? super I, ? extends O> defaultTransformer) {\n    return SwitchTransformer.switchTransformer(predicates, transformers, defaultTransformer);\n}"
            ],
            [
                "switchTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Create a new Transformer that calls one of the transformers depending\n * on the predicates.\n * <p>\n * The Map consists of Predicate keys and Transformer values. A transformer\n * is called if its matching predicate returns true. Each predicate is evaluated\n * until one returns true. If no predicates evaluate to true, the default\n * transformer is called. The default transformer is set in the map with a\n * null key. If no default transformer is set, null will be returned in a default\n * case. The ordering is that of the iterator() method on the entryset collection\n * of the map.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param predicatesAndTransformers  a map of predicates to transformers\n * @return the transformer\n * @throws NullPointerException if the map is null\n * @throws NullPointerException if any transformer in the map is null\n * @throws ClassCastException  if the map elements are of the wrong type\n * @see SwitchTransformer\n */\npublic static <I, O> Transformer<I, O> switchTransformer(final Map<Predicate<I>, Transformer<I, O>> predicatesAndTransformers) {\n    return SwitchTransformer.switchTransformer(predicatesAndTransformers);\n}"
            ],
            [
                "switchMapTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Create a new Transformer that uses the input object as a key to find the\n * transformer to call.\n * <p>\n * The Map consists of object keys and Transformer values. A transformer\n * is called if the input object equals the key. If there is no match, the\n * default transformer is called. The default transformer is set in the map\n * using a null key. If no default is set, null will be returned in a default case.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param objectsAndTransformers  a map of objects to transformers\n * @return the transformer\n * @throws NullPointerException if the map is null\n * @throws NullPointerException if any transformer in the map is null\n * @see SwitchTransformer\n */\n@SuppressWarnings(\"unchecked\")\npublic static <I, O> Transformer<I, O> switchMapTransformer(final Map<I, Transformer<I, O>> objectsAndTransformers) {\n    if (objectsAndTransformers == null) {\n        throw new NullPointerException(\"The object and transformer map must not be null\");\n    }\n    final Transformer<? super I, ? extends O> def = objectsAndTransformers.remove(null);\n    final int size = objectsAndTransformers.size();\n    final Transformer<? super I, ? extends O>[] trs = new Transformer[size];\n    final Predicate<I>[] preds = new Predicate[size];\n    int i = 0;\n    for (final Map.Entry<I, Transformer<I, O>> entry : objectsAndTransformers.entrySet()) {\n        preds[i] = EqualPredicate.<I>equalPredicate(entry.getKey());\n        trs[i++] = entry.getValue();\n    }\n    return TransformerUtils.switchTransformer(preds, trs, def);\n}"
            ],
            [
                "instantiateTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Gets a Transformer that expects an input Class object that it will instantiate.\n *\n * @param <T>  the output type\n * @return the transformer\n * @see InstantiateTransformer\n */\npublic static <T> Transformer<Class<? extends T>, T> instantiateTransformer() {\n    return InstantiateTransformer.instantiateTransformer();\n}"
            ],
            [
                "instantiateTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Creates a Transformer that expects an input Class object that it will\n * instantiate. The constructor used is determined by the arguments specified\n * to this method.\n *\n * @param <T>  the output type\n * @param paramTypes  parameter types for the constructor, can be null\n * @param args  the arguments to pass to the constructor, can be null\n * @return the transformer\n * @throws IllegalArgumentException if the paramTypes and args don't match\n * @see InstantiateTransformer\n */\npublic static <T> Transformer<Class<? extends T>, T> instantiateTransformer(final Class<?>[] paramTypes, final Object[] args) {\n    return InstantiateTransformer.instantiateTransformer(paramTypes, args);\n}"
            ],
            [
                "mapTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Creates a Transformer that uses the passed in Map to transform the input\n * object (as a simple lookup).\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param map  the map to use to transform the objects\n * @return the transformer, or {@link ConstantTransformer#nullTransformer()} if the\n *   {@code map} is {@code null}\n * @see MapTransformer\n */\npublic static <I, O> Transformer<I, O> mapTransformer(final Map<? super I, ? extends O> map) {\n    return MapTransformer.mapTransformer(map);\n}"
            ],
            [
                "invokerTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Gets a Transformer that invokes a method on the input object.\n * The method must have no parameters. If the input object is null,\n * null is returned.\n * <p>\n * For example, <code>TransformerUtils.invokerTransformer(\"getName\");</code>\n * will call the <code>getName/code> method on the input object to\n * determine the transformer result.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param methodName  the method name to call on the input object, may not be null\n * @return the transformer\n * @throws NullPointerException if the methodName is null.\n * @see InvokerTransformer\n */\npublic static <I, O> Transformer<I, O> invokerTransformer(final String methodName) {\n    return InvokerTransformer.invokerTransformer(methodName, null, null);\n}"
            ],
            [
                "invokerTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Gets a Transformer that invokes a method on the input object.\n * The method parameters are specified. If the input object is {@code null},\n * {@code null} is returned.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param methodName  the name of the method\n * @param paramTypes  the parameter types\n * @param args  the arguments\n * @return the transformer\n * @throws NullPointerException if the method name is null\n * @throws IllegalArgumentException if the paramTypes and args don't match\n * @see InvokerTransformer\n */\npublic static <I, O> Transformer<I, O> invokerTransformer(final String methodName, final Class<?>[] paramTypes, final Object[] args) {\n    return InvokerTransformer.invokerTransformer(methodName, paramTypes, args);\n}"
            ],
            [
                "stringValueTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Gets a transformer that returns a <code>java.lang.String</code>\n * representation of the input object. This is achieved via the\n * <code>toString</code> method, <code>null</code> returns 'null'.\n *\n * @param <T>  the input type\n * @return the transformer\n * @see StringValueTransformer\n */\npublic static <T> Transformer<T, String> stringValueTransformer() {\n    return StringValueTransformer.stringValueTransformer();\n}"
            ],
            [
                "exceptionPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "// Simple predicates\n//-----------------------------------------------------------------------------\n/**\n * Gets a Predicate that always throws an exception.\n * This could be useful during testing as a placeholder.\n *\n * @param <T>  the type that the predicate queries\n * @return the predicate\n * @see ExceptionPredicate\n */\npublic static <T> Predicate<T> exceptionPredicate() {\n    return ExceptionPredicate.exceptionPredicate();\n}"
            ],
            [
                "truePredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Gets a Predicate that always returns true.\n *\n * @param <T>  the type that the predicate queries\n * @return the predicate\n * @see TruePredicate\n */\npublic static <T> Predicate<T> truePredicate() {\n    return TruePredicate.truePredicate();\n}"
            ],
            [
                "falsePredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Gets a Predicate that always returns false.\n *\n * @param <T>  the type that the predicate queries\n * @return the predicate\n * @see FalsePredicate\n */\npublic static <T> Predicate<T> falsePredicate() {\n    return FalsePredicate.falsePredicate();\n}"
            ],
            [
                "nullPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Gets a Predicate that checks if the input object passed in is null.\n *\n * @param <T>  the type that the predicate queries\n * @return the predicate\n * @see NullPredicate\n */\npublic static <T> Predicate<T> nullPredicate() {\n    return NullPredicate.nullPredicate();\n}"
            ],
            [
                "notNullPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Gets a Predicate that checks if the input object passed in is not null.\n *\n * @param <T>  the type that the predicate queries\n * @return the predicate\n * @see NotNullPredicate\n */\npublic static <T> Predicate<T> notNullPredicate() {\n    return NotNullPredicate.notNullPredicate();\n}"
            ],
            [
                "equalPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Creates a Predicate that checks if the input object is equal to the\n * specified object using equals().\n *\n * @param <T>  the type that the predicate queries\n * @param value  the value to compare against\n * @return the predicate\n * @see EqualPredicate\n */\npublic static <T> Predicate<T> equalPredicate(final T value) {\n    return EqualPredicate.equalPredicate(value);\n}"
            ],
            [
                "identityPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Creates a Predicate that checks if the input object is equal to the\n * specified object by identity.\n *\n * @param <T>  the type that the predicate queries\n * @param value  the value to compare against\n * @return the predicate\n * @see IdentityPredicate\n */\npublic static <T> Predicate<T> identityPredicate(final T value) {\n    return IdentityPredicate.identityPredicate(value);\n}"
            ],
            [
                "instanceofPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Creates a Predicate that checks if the object passed in is of\n * a particular type, using instanceof. A <code>null</code> input\n * object will return <code>false</code>.\n *\n * @param type  the type to check for, may not be null\n * @return the predicate\n * @throws NullPointerException if the class is null\n * @see InstanceofPredicate\n */\npublic static Predicate<Object> instanceofPredicate(final Class<?> type) {\n    return InstanceofPredicate.instanceOfPredicate(type);\n}"
            ],
            [
                "uniquePredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Creates a Predicate that returns true the first time an object is\n * encountered, and false if the same object is received\n * again. The comparison is by equals(). A <code>null</code> input object\n * is accepted and will return true the first time, and false subsequently\n * as well.\n *\n * @param <T>  the type that the predicate queries\n * @return the predicate\n * @see UniquePredicate\n */\npublic static <T> Predicate<T> uniquePredicate() {\n    // must return new instance each time\n    return UniquePredicate.uniquePredicate();\n}"
            ],
            [
                "invokerPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Creates a Predicate that invokes a method on the input object.\n * The method must return either a boolean or a non-null Boolean,\n * and have no parameters. If the input object is null, a\n * PredicateException is thrown.\n * <p>\n * For example, <code>PredicateUtils.invokerPredicate(\"isEmpty\");</code>\n * will call the <code>isEmpty</code> method on the input object to\n * determine the predicate result.\n *\n * @param <T>  the type that the predicate queries\n * @param methodName  the method name to call on the input object, may not be null\n * @return the predicate\n * @throws NullPointerException if the methodName is null.\n * @see InvokerTransformer\n * @see TransformerPredicate\n */\npublic static <T> Predicate<T> invokerPredicate(final String methodName) {\n    // reuse transformer as it has caching - this is lazy really, should have inner class here\n    return asPredicate(InvokerTransformer.<Object, Boolean>invokerTransformer(methodName));\n}"
            ],
            [
                "invokerPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Creates a Predicate that invokes a method on the input object.\n * The method must return either a boolean or a non-null Boolean,\n * and have no parameters. If the input object is null, a\n * PredicateException is thrown.\n * <p>\n * For example, <code>PredicateUtils.invokerPredicate(\"isEmpty\");</code>\n * will call the <code>isEmpty</code> method on the input object to\n * determine the predicate result.\n *\n * @param <T>  the type that the predicate queries\n * @param methodName  the method name to call on the input object, may not be null\n * @param paramTypes  the parameter types\n * @param args  the arguments\n * @return the predicate\n * @throws NullPointerException if the method name is null\n * @throws IllegalArgumentException if the paramTypes and args don't match\n * @see InvokerTransformer\n * @see TransformerPredicate\n */\npublic static <T> Predicate<T> invokerPredicate(final String methodName, final Class<?>[] paramTypes, final Object[] args) {\n    // reuse transformer as it has caching - this is lazy really, should have inner class here\n    return asPredicate(InvokerTransformer.<Object, Boolean>invokerTransformer(methodName, paramTypes, args));\n}"
            ],
            [
                "andPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "// Boolean combinations\n//-----------------------------------------------------------------------------\n/**\n * Create a new Predicate that returns true only if both of the specified\n * predicates are true.\n *\n * @param <T>  the type that the predicate queries\n * @param predicate1  the first predicate, may not be null\n * @param predicate2  the second predicate, may not be null\n * @return the <code>and</code> predicate\n * @throws NullPointerException if either predicate is null\n * @see AndPredicate\n */\npublic static <T> Predicate<T> andPredicate(final Predicate<? super T> predicate1, final Predicate<? super T> predicate2) {\n    return AndPredicate.andPredicate(predicate1, predicate2);\n}"
            ],
            [
                "allPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true only if all of the specified\n * predicates are true.\n * If the array of predicates is empty, then this predicate returns true.\n *\n * @param <T>  the type that the predicate queries\n * @param predicates  an array of predicates to check, may not be null\n * @return the <code>all</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n * @see AllPredicate\n */\npublic static <T> Predicate<T> allPredicate(final Predicate<? super T>... predicates) {\n    return AllPredicate.allPredicate(predicates);\n}"
            ],
            [
                "allPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true only if all of the specified\n * predicates are true. The predicates are checked in iterator order.\n * If the collection of predicates is empty, then this predicate returns true.\n *\n * @param <T>  the type that the predicate queries\n * @param predicates  a collection of predicates to check, may not be null\n * @return the <code>all</code> predicate\n * @throws NullPointerException if the predicates collection is null\n * @throws NullPointerException if any predicate in the collection is null\n * @see AllPredicate\n */\npublic static <T> Predicate<T> allPredicate(final Collection<? extends Predicate<? super T>> predicates) {\n    return AllPredicate.allPredicate(predicates);\n}"
            ],
            [
                "orPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true if either of the specified\n * predicates are true.\n *\n * @param <T>  the type that the predicate queries\n * @param predicate1  the first predicate, may not be null\n * @param predicate2  the second predicate, may not be null\n * @return the <code>or</code> predicate\n * @throws NullPointerException if either predicate is null\n * @see OrPredicate\n */\npublic static <T> Predicate<T> orPredicate(final Predicate<? super T> predicate1, final Predicate<? super T> predicate2) {\n    return OrPredicate.orPredicate(predicate1, predicate2);\n}"
            ],
            [
                "anyPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true if any of the specified\n * predicates are true.\n * If the array of predicates is empty, then this predicate returns false.\n *\n * @param <T>  the type that the predicate queries\n * @param predicates  an array of predicates to check, may not be null\n * @return the <code>any</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n * @see AnyPredicate\n */\npublic static <T> Predicate<T> anyPredicate(final Predicate<? super T>... predicates) {\n    return AnyPredicate.anyPredicate(predicates);\n}"
            ],
            [
                "anyPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true if any of the specified\n * predicates are true. The predicates are checked in iterator order.\n * If the collection of predicates is empty, then this predicate returns false.\n *\n * @param <T>  the type that the predicate queries\n * @param predicates  a collection of predicates to check, may not be null\n * @return the <code>any</code> predicate\n * @throws NullPointerException if the predicates collection is null\n * @throws NullPointerException if any predicate in the collection is null\n * @see AnyPredicate\n */\npublic static <T> Predicate<T> anyPredicate(final Collection<? extends Predicate<? super T>> predicates) {\n    return AnyPredicate.anyPredicate(predicates);\n}"
            ],
            [
                "eitherPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true if one, but not both, of the\n * specified predicates are true. XOR\n *\n * @param <T>  the type that the predicate queries\n * @param predicate1  the first predicate, may not be null\n * @param predicate2  the second predicate, may not be null\n * @return the <code>either</code> predicate\n * @throws NullPointerException if either predicate is null\n * @see OnePredicate\n */\npublic static <T> Predicate<T> eitherPredicate(final Predicate<? super T> predicate1, final Predicate<? super T> predicate2) {\n    @SuppressWarnings(\"unchecked\")\n    final Predicate<T> onePredicate = PredicateUtils.onePredicate(predicate1, predicate2);\n    return onePredicate;\n}"
            ],
            [
                "onePredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true if only one of the specified\n * predicates are true.\n * If the array of predicates is empty, then this predicate returns false.\n *\n * @param <T>  the type that the predicate queries\n * @param predicates  an array of predicates to check, may not be null\n * @return the <code>one</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n * @see OnePredicate\n */\npublic static <T> Predicate<T> onePredicate(final Predicate<? super T>... predicates) {\n    return OnePredicate.onePredicate(predicates);\n}"
            ],
            [
                "onePredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true if only one of the specified\n * predicates are true. The predicates are checked in iterator order.\n * If the collection of predicates is empty, then this predicate returns false.\n *\n * @param <T>  the type that the predicate queries\n * @param predicates  a collection of predicates to check, may not be null\n * @return the <code>one</code> predicate\n * @throws NullPointerException if the predicates collection is null\n * @throws NullPointerException if any predicate in the collection is null\n * @see OnePredicate\n */\npublic static <T> Predicate<T> onePredicate(final Collection<? extends Predicate<? super T>> predicates) {\n    return OnePredicate.onePredicate(predicates);\n}"
            ],
            [
                "neitherPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true if neither of the specified\n * predicates are true.\n *\n * @param <T>  the type that the predicate queries\n * @param predicate1  the first predicate, may not be null\n * @param predicate2  the second predicate, may not be null\n * @return the <code>neither</code> predicate\n * @throws NullPointerException if either predicate is null\n * @see NonePredicate\n */\npublic static <T> Predicate<T> neitherPredicate(final Predicate<? super T> predicate1, final Predicate<? super T> predicate2) {\n    @SuppressWarnings(\"unchecked\")\n    final Predicate<T> nonePredicate = PredicateUtils.nonePredicate(predicate1, predicate2);\n    return nonePredicate;\n}"
            ],
            [
                "nonePredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true if none of the specified\n * predicates are true.\n * If the array of predicates is empty, then this predicate returns true.\n *\n * @param <T>  the type that the predicate queries\n * @param predicates  an array of predicates to check, may not be null\n * @return the <code>none</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n * @see NonePredicate\n */\npublic static <T> Predicate<T> nonePredicate(final Predicate<? super T>... predicates) {\n    return NonePredicate.nonePredicate(predicates);\n}"
            ],
            [
                "nonePredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true if none of the specified\n * predicates are true. The predicates are checked in iterator order.\n * If the collection of predicates is empty, then this predicate returns true.\n *\n * @param <T>  the type that the predicate queries\n * @param predicates  a collection of predicates to check, may not be null\n * @return the <code>none</code> predicate\n * @throws NullPointerException if the predicates collection is null\n * @throws NullPointerException if any predicate in the collection is null\n * @see NonePredicate\n */\npublic static <T> Predicate<T> nonePredicate(final Collection<? extends Predicate<? super T>> predicates) {\n    return NonePredicate.nonePredicate(predicates);\n}"
            ],
            [
                "notPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true if the specified predicate\n * returns false and vice versa.\n *\n * @param <T>  the type that the predicate queries\n * @param predicate  the predicate to not\n * @return the <code>not</code> predicate\n * @throws NullPointerException if the predicate is null\n * @see NotPredicate\n */\npublic static <T> Predicate<T> notPredicate(final Predicate<? super T> predicate) {\n    return NotPredicate.notPredicate(predicate);\n}"
            ],
            [
                "asPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "// Adaptors\n//-----------------------------------------------------------------------------\n/**\n * Create a new Predicate that wraps a Transformer. The Transformer must\n * return either Boolean.TRUE or Boolean.FALSE otherwise a PredicateException\n * will be thrown.\n *\n * @param <T>  the type that the predicate queries\n * @param transformer  the transformer to wrap, may not be null\n * @return the transformer wrapping predicate\n * @throws NullPointerException if the transformer is null\n * @see TransformerPredicate\n */\npublic static <T> Predicate<T> asPredicate(final Transformer<? super T, Boolean> transformer) {\n    return TransformerPredicate.transformerPredicate(transformer);\n}"
            ],
            [
                "nullIsExceptionPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "// Null handlers\n//-----------------------------------------------------------------------------\n/**\n * Gets a Predicate that throws an exception if the input object is null,\n * otherwise it calls the specified Predicate. This allows null handling\n * behaviour to be added to Predicates that don't support nulls.\n *\n * @param <T>  the type that the predicate queries\n * @param predicate  the predicate to wrap, may not be null\n * @return the predicate\n * @throws NullPointerException if the predicate is null.\n * @see NullIsExceptionPredicate\n */\npublic static <T> Predicate<T> nullIsExceptionPredicate(final Predicate<? super T> predicate) {\n    return NullIsExceptionPredicate.nullIsExceptionPredicate(predicate);\n}"
            ],
            [
                "nullIsFalsePredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Gets a Predicate that returns false if the input object is null, otherwise\n * it calls the specified Predicate. This allows null handling behaviour to\n * be added to Predicates that don't support nulls.\n *\n * @param <T>  the type that the predicate queries\n * @param predicate  the predicate to wrap, may not be null\n * @return the predicate\n * @throws NullPointerException if the predicate is null.\n * @see NullIsFalsePredicate\n */\npublic static <T> Predicate<T> nullIsFalsePredicate(final Predicate<? super T> predicate) {\n    return NullIsFalsePredicate.nullIsFalsePredicate(predicate);\n}"
            ],
            [
                "nullIsTruePredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Gets a Predicate that returns true if the input object is null, otherwise\n * it calls the specified Predicate. This allows null handling behaviour to\n * be added to Predicates that don't support nulls.\n *\n * @param <T>  the type that the predicate queries\n * @param predicate  the predicate to wrap, may not be null\n * @return the predicate\n * @throws NullPointerException if the predicate is null.\n * @see NullIsTruePredicate\n */\npublic static <T> Predicate<T> nullIsTruePredicate(final Predicate<? super T> predicate) {\n    return NullIsTruePredicate.nullIsTruePredicate(predicate);\n}"
            ],
            [
                "transformedPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "// Transformed\n//-----------------------------------------------------------------------\n/**\n * Creates a predicate that transforms the input object before passing it\n * to the predicate.\n *\n * @param <T>  the type that the predicate queries\n * @param transformer  the transformer to call first\n * @param predicate  the predicate to call with the result of the transform\n * @return the predicate\n * @throws NullPointerException if the transformer or the predicate is null\n * @see TransformedPredicate\n * @since 3.1\n */\npublic static <T> Predicate<T> transformedPredicate(final Transformer<? super T, ? extends T> transformer, final Predicate<? super T> predicate) {\n    return TransformedPredicate.transformedPredicate(transformer, predicate);\n}"
            ],
            [
                "emptySet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Get a typed empty unmodifiable Set.\n * @param <E> the element type\n * @return an empty Set\n */\npublic static <E> Set<E> emptySet() {\n    return Collections.<E>emptySet();\n}"
            ],
            [
                "emptySortedSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Get a typed empty unmodifiable sorted set.\n * @param <E> the element type\n * @return an empty sorted Set\n */\n// empty set is OK for any type\n@SuppressWarnings(\"unchecked\")\npublic static <E> SortedSet<E> emptySortedSet() {\n    return EMPTY_SORTED_SET;\n}"
            ],
            [
                "emptyIfNull",
                "org.apache.commons.collections4",
                "SetUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns an immutable empty set if the argument is <code>null</code>,\n * or the argument itself otherwise.\n *\n * @param <T> the element type\n * @param set the set, possibly <code>null</code>\n * @return an empty set if the argument is <code>null</code>\n */\npublic static <T> Set<T> emptyIfNull(final Set<T> set) {\n    return set == null ? Collections.<T>emptySet() : set;\n}"
            ],
            [
                "isEqualSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Tests two sets for equality as per the <code>equals()</code> contract\n * in {@link java.util.Set#equals(java.lang.Object)}.\n * <p>\n * This method is useful for implementing <code>Set</code> when you cannot\n * extend AbstractSet. The method takes Collection instances to enable other\n * collection types to use the Set implementation algorithm.\n * <p>\n * The relevant text (slightly paraphrased as this is a static method) is:\n * <blockquote>\n * <p>Two sets are considered equal if they have\n * the same size, and every member of the first set is contained in\n * the second. This ensures that the {@code equals} method works\n * properly across different implementations of the {@code Set}\n * interface.</p>\n *\n * <p>\n * This implementation first checks if the two sets are the same object:\n * if so it returns {@code true}.  Then, it checks if the two sets are\n * identical in size; if not, it returns false. If so, it returns\n * {@code a.containsAll((Collection) b)}.</p>\n * </blockquote>\n *\n * @see java.util.Set\n * @param set1  the first set, may be null\n * @param set2  the second set, may be null\n * @return whether the sets are equal by value comparison\n */\npublic static boolean isEqualSet(final Collection<?> set1, final Collection<?> set2) {\n    if (set1 == set2) {\n        return true;\n    }\n    if (set1 == null || set2 == null || set1.size() != set2.size()) {\n        return false;\n    }\n    return set1.containsAll(set2);\n}"
            ],
            [
                "hashCodeForSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Generates a hash code using the algorithm specified in\n * {@link java.util.Set#hashCode()}.\n * <p>\n * This method is useful for implementing <code>Set</code> when you cannot\n * extend AbstractSet. The method takes Collection instances to enable other\n * collection types to use the Set implementation algorithm.\n *\n * @param <T> the element type\n * @see java.util.Set#hashCode()\n * @param set  the set to calculate the hash code for, may be null\n * @return the hash code\n */\npublic static <T> int hashCodeForSet(final Collection<T> set) {\n    if (set == null) {\n        return 0;\n    }\n    int hashCode = 0;\n    for (final T obj : set) {\n        if (obj != null) {\n            hashCode += obj.hashCode();\n        }\n    }\n    return hashCode;\n}"
            ],
            [
                "newIdentityHashSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a new hash set that matches elements based on <code>==</code> not\n * <code>equals()</code>.\n * <p>\n * <strong>This set will violate the detail of various Set contracts.</note>\n * As a general rule, don't compare this set to other sets. In particular, you can't\n * use decorators like {@link ListOrderedSet} on it, which silently assume that these\n * contracts are fulfilled.</strong>\n * <p>\n * <strong>Note that the returned set is not synchronized and is not thread-safe.</strong>\n * If you wish to use this set from multiple threads concurrently, you must use\n * appropriate synchronization. The simplest approach is to wrap this map\n * using {@link java.util.Collections#synchronizedSet(Set)}. This class may throw\n * exceptions when accessed by concurrent threads without synchronization.\n *\n * @param <E>  the element type\n * @return a new identity hash set\n * @since 4.1\n */\npublic static <E> Set<E> newIdentityHashSet() {\n    return Collections.newSetFromMap(new IdentityHashMap<E, Boolean>());\n}"
            ],
            [
                "synchronizedSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "// Set\n//-----------------------------------------------------------------------\n/**\n * Returns a synchronized set backed by the given set.\n * <p>\n * You must manually synchronize on the returned set's iterator to\n * avoid non-deterministic behavior:\n *\n * <pre>\n * Set s = SetUtils.synchronizedSet(mySet);\n * synchronized (s) {\n *     Iterator i = s.iterator();\n *     while (i.hasNext()) {\n *         process (i.next());\n *     }\n * }\n * </pre>\n *\n * This method is just a wrapper for {@link Collections#synchronizedSet(Set)}.\n *\n * @param <E> the element type\n * @param set  the set to synchronize, must not be null\n * @return a synchronized set backed by the given set\n * @throws NullPointerException if the set is null\n */\npublic static <E> Set<E> synchronizedSet(final Set<E> set) {\n    return Collections.synchronizedSet(set);\n}"
            ],
            [
                "unmodifiableSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns an unmodifiable set backed by the given set.\n * <p>\n * This method uses the implementation in the decorators subpackage.\n *\n * @param <E> the element type\n * @param set  the set to make unmodifiable, must not be null\n * @return an unmodifiable set backed by the given set\n * @throws NullPointerException if the set is null\n */\npublic static <E> Set<E> unmodifiableSet(final Set<? extends E> set) {\n    return UnmodifiableSet.unmodifiableSet(set);\n}"
            ],
            [
                "predicatedSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a predicated (validating) set backed by the given set.\n * <p>\n * Only objects that pass the test in the given predicate can be added to the set.\n * Trying to add an invalid object results in an IllegalArgumentException.\n * It is important not to use the original set after invoking this method,\n * as it is a backdoor for adding invalid objects.\n *\n * @param <E> the element type\n * @param set  the set to predicate, must not be null\n * @param predicate  the predicate for the set, must not be null\n * @return a predicated set backed by the given set\n * @throws NullPointerException if the set or predicate is null\n */\npublic static <E> Set<E> predicatedSet(final Set<E> set, final Predicate<? super E> predicate) {\n    return PredicatedSet.predicatedSet(set, predicate);\n}"
            ],
            [
                "transformedSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a transformed set backed by the given set.\n * <p>\n * Each object is passed through the transformer as it is added to the\n * Set. It is important not to use the original set after invoking this\n * method, as it is a backdoor for adding untransformed objects.\n * <p>\n * Existing entries in the specified set will not be transformed.\n * If you want that behaviour, see {@link TransformedSet#transformedSet}.\n *\n * @param <E> the element type\n * @param set  the set to transform, must not be null\n * @param transformer  the transformer for the set, must not be null\n * @return a transformed set backed by the given set\n * @throws NullPointerException if the set or transformer is null\n */\npublic static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer) {\n    return TransformedSet.transformingSet(set, transformer);\n}"
            ],
            [
                "orderedSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a set that maintains the order of elements that are added\n * backed by the given set.\n * <p>\n * If an element is added twice, the order is determined by the first add.\n * The order is observed through the iterator or toArray.\n *\n * @param <E> the element type\n * @param set  the set to order, must not be null\n * @return an ordered set backed by the given set\n * @throws NullPointerException if the set is null\n */\npublic static <E> Set<E> orderedSet(final Set<E> set) {\n    return ListOrderedSet.listOrderedSet(set);\n}"
            ],
            [
                "synchronizedSortedSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "// SortedSet\n//-----------------------------------------------------------------------\n/**\n * Returns a synchronized sorted set backed by the given sorted set.\n * <p>\n * You must manually synchronize on the returned set's iterator to\n * avoid non-deterministic behavior:\n *\n * <pre>\n * Set s = SetUtils.synchronizedSortedSet(mySet);\n * synchronized (s) {\n *     Iterator i = s.iterator();\n *     while (i.hasNext()) {\n *         process (i.next());\n *     }\n * }\n * </pre>\n *\n * This method is just a wrapper for {@link Collections#synchronizedSortedSet(SortedSet)}.\n *\n * @param <E> the element type\n * @param set  the sorted set to synchronize, must not be null\n * @return a synchronized set backed by the given set\n * @throws NullPointerException if the set is null\n */\npublic static <E> SortedSet<E> synchronizedSortedSet(final SortedSet<E> set) {\n    return Collections.synchronizedSortedSet(set);\n}"
            ],
            [
                "unmodifiableSortedSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns an unmodifiable sorted set backed by the given sorted set.\n * <p>\n * This method uses the implementation in the decorators subpackage.\n *\n * @param <E> the element type\n * @param set  the sorted set to make unmodifiable, must not be null\n * @return an unmodifiable set backed by the given set\n * @throws NullPointerException if the set is null\n */\npublic static <E> SortedSet<E> unmodifiableSortedSet(final SortedSet<E> set) {\n    return UnmodifiableSortedSet.unmodifiableSortedSet(set);\n}"
            ],
            [
                "predicatedSortedSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a predicated (validating) sorted set backed by the given sorted set.\n * <p>\n * Only objects that pass the test in the given predicate can be added to the set.\n * Trying to add an invalid object results in an IllegalArgumentException.\n * It is important not to use the original set after invoking this method,\n * as it is a backdoor for adding invalid objects.\n *\n * @param <E> the element type\n * @param set  the sorted set to predicate, must not be null\n * @param predicate  the predicate for the sorted set, must not be null\n * @return a predicated sorted set backed by the given sorted set\n * @throws NullPointerException if the set or predicate is null\n */\npublic static <E> SortedSet<E> predicatedSortedSet(final SortedSet<E> set, final Predicate<? super E> predicate) {\n    return PredicatedSortedSet.predicatedSortedSet(set, predicate);\n}"
            ],
            [
                "transformedSortedSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a transformed sorted set backed by the given set.\n * <p>\n * Each object is passed through the transformer as it is added to the\n * Set. It is important not to use the original set after invoking this\n * method, as it is a backdoor for adding untransformed objects.\n * <p>\n * Existing entries in the specified set will not be transformed.\n * If you want that behaviour, see {@link TransformedSortedSet#transformedSortedSet}.\n *\n * @param <E> the element type\n * @param set  the set to transform, must not be null\n * @param transformer  the transformer for the set, must not be null\n * @return a transformed set backed by the given set\n * @throws NullPointerException if the set or transformer is null\n */\npublic static <E> SortedSet<E> transformedSortedSet(final SortedSet<E> set, final Transformer<? super E, ? extends E> transformer) {\n    return TransformedSortedSet.transformingSortedSet(set, transformer);\n}"
            ],
            [
                "unmodifiableNavigableSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "// NavigableSet\n//-----------------------------------------------------------------------\n/**\n * Returns an unmodifiable navigable set backed by the given navigable set.\n * <p>\n * This method uses the implementation in the decorators subpackage.\n *\n * @param <E> the element type\n * @param set  the navigable set to make unmodifiable, must not be null\n * @return an unmodifiable set backed by the given set\n * @throws NullPointerException if the set is null\n * @since 4.1\n */\npublic static <E> SortedSet<E> unmodifiableNavigableSet(final NavigableSet<E> set) {\n    return UnmodifiableNavigableSet.unmodifiableNavigableSet(set);\n}"
            ],
            [
                "predicatedNavigableSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a predicated (validating) navigable set backed by the given navigable set.\n * <p>\n * Only objects that pass the test in the given predicate can be added to the set.\n * Trying to add an invalid object results in an IllegalArgumentException.\n * It is important not to use the original set after invoking this method,\n * as it is a backdoor for adding invalid objects.\n *\n * @param <E> the element type\n * @param set  the navigable set to predicate, must not be null\n * @param predicate  the predicate for the navigable set, must not be null\n * @return a predicated navigable set backed by the given navigable set\n * @throws NullPointerException if the set or predicate is null\n * @since 4.1\n */\npublic static <E> SortedSet<E> predicatedNavigableSet(final NavigableSet<E> set, final Predicate<? super E> predicate) {\n    return PredicatedNavigableSet.predicatedNavigableSet(set, predicate);\n}"
            ],
            [
                "transformedNavigableSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a transformed navigable set backed by the given navigable set.\n * <p>\n * Each object is passed through the transformer as it is added to the\n * Set. It is important not to use the original set after invoking this\n * method, as it is a backdoor for adding untransformed objects.\n * <p>\n * Existing entries in the specified set will not be transformed.\n * If you want that behaviour, see {@link TransformedNavigableSet#transformedNavigableSet}.\n *\n * @param <E> the element type\n * @param set  the navigable set to transform, must not be null\n * @param transformer  the transformer for the set, must not be null\n * @return a transformed set backed by the given set\n * @throws NullPointerException if the set or transformer is null\n * @since 4.1\n */\npublic static <E> SortedSet<E> transformedNavigableSet(final NavigableSet<E> set, final Transformer<? super E, ? extends E> transformer) {\n    return TransformedNavigableSet.transformingNavigableSet(set, transformer);\n}"
            ],
            [
                "union",
                "org.apache.commons.collections4",
                "SetUtils",
                "// Set operations\n//-----------------------------------------------------------------------\n/**\n * Returns a unmodifiable <b>view</b> of the union of the given {@link Set}s.\n * <p>\n * The returned view contains all elements of {@code a} and {@code b}.\n *\n * @param <E> the generic type that is able to represent the types contained\n *   in both input sets.\n * @param a  the first set, must not be null\n * @param b  the second set, must not be null\n * @return a view of the union of the two set\n * @throws NullPointerException if either input set is null\n * @since 4.1\n */\npublic static <E> SetView<E> union(final Set<? extends E> a, final Set<? extends E> b) {\n    if (a == null || b == null) {\n        throw new NullPointerException(\"Sets must not be null.\");\n    }\n    final SetView<E> bMinusA = difference(b, a);\n    return new SetView<E>() {\n\n        @Override\n        public boolean contains(Object o) {\n            return a.contains(o) || b.contains(o);\n        }\n\n        @Override\n        public Iterator<E> createIterator() {\n            return IteratorUtils.chainedIterator(a.iterator(), bMinusA.iterator());\n        }\n\n        @Override\n        public boolean isEmpty() {\n            return a.isEmpty() && b.isEmpty();\n        }\n\n        @Override\n        public int size() {\n            return a.size() + bMinusA.size();\n        }\n    };\n}"
            ],
            [
                "difference",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a unmodifiable <b>view</b> containing the difference of the given\n * {@link Set}s, denoted by {@code a \\ b} (or {@code a - b}).\n * <p>\n * The returned view contains all elements of {@code a} that are not a member\n * of {@code b}.\n *\n * @param <E> the generic type that is able to represent the types contained\n *   in both input sets.\n * @param a  the set to subtract from, must not be null\n * @param b  the set to subtract, must not be null\n * @return a view of the relative complement of  of the two sets\n * @since 4.1\n */\npublic static <E> SetView<E> difference(final Set<? extends E> a, final Set<? extends E> b) {\n    if (a == null || b == null) {\n        throw new NullPointerException(\"Sets must not be null.\");\n    }\n    final Predicate<E> notContainedInB = new Predicate<E>() {\n\n        @Override\n        public boolean evaluate(E object) {\n            return !b.contains(object);\n        }\n    };\n    return new SetView<E>() {\n\n        @Override\n        public boolean contains(Object o) {\n            return a.contains(o) && !b.contains(o);\n        }\n\n        @Override\n        public Iterator<E> createIterator() {\n            return IteratorUtils.filteredIterator(a.iterator(), notContainedInB);\n        }\n    };\n}"
            ],
            [
                "intersection",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a unmodifiable <b>view</b> of the intersection of the given {@link Set}s.\n * <p>\n * The returned view contains all elements that are members of both input sets\n * ({@code a} and {@code b}).\n *\n * @param <E> the generic type that is able to represent the types contained\n *   in both input sets.\n * @param a  the first set, must not be null\n * @param b  the second set, must not be null\n * @return a view of the intersection of the two sets\n * @since 4.1\n */\npublic static <E> SetView<E> intersection(final Set<? extends E> a, final Set<? extends E> b) {\n    if (a == null || b == null) {\n        throw new NullPointerException(\"Sets must not be null.\");\n    }\n    final Predicate<E> containedInB = new Predicate<E>() {\n\n        @Override\n        public boolean evaluate(E object) {\n            return b.contains(object);\n        }\n    };\n    return new SetView<E>() {\n\n        @Override\n        public boolean contains(Object o) {\n            return a.contains(o) && b.contains(o);\n        }\n\n        @Override\n        public Iterator<E> createIterator() {\n            return IteratorUtils.filteredIterator(a.iterator(), containedInB);\n        }\n    };\n}"
            ],
            [
                "disjunction",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a unmodifiable <b>view</b> of the symmetric difference of the given\n * {@link Set}s.\n * <p>\n * The returned view contains all elements of {@code a} and {@code b} that are\n * not a member of the other set.\n * <p>\n * This is equivalent to {@code union(difference(a, b), difference(b, a))}.\n *\n * @param <E> the generic type that is able to represent the types contained\n *   in both input sets.\n * @param a  the first set, must not be null\n * @param b  the second set, must not be null\n * @return a view of the symmetric difference of the two sets\n * @since 4.1\n */\npublic static <E> SetView<E> disjunction(final Set<? extends E> a, final Set<? extends E> b) {\n    if (a == null || b == null) {\n        throw new NullPointerException(\"Sets must not be null.\");\n    }\n    final SetView<E> aMinusB = difference(a, b);\n    final SetView<E> bMinusA = difference(b, a);\n    return new SetView<E>() {\n\n        @Override\n        public boolean contains(Object o) {\n            return a.contains(o) ^ b.contains(o);\n        }\n\n        @Override\n        public Iterator<E> createIterator() {\n            return IteratorUtils.chainedIterator(aMinusB.iterator(), bMinusA.iterator());\n        }\n\n        @Override\n        public boolean isEmpty() {\n            return aMinusB.isEmpty() && bMinusA.isEmpty();\n        }\n\n        @Override\n        public int size() {\n            return aMinusB.size() + bMinusA.size();\n        }\n    };\n}"
            ],
            [
                "transformingSet",
                "org.apache.commons.collections4.set",
                "TransformedSet",
                "/**\n * Factory method to create a transforming set.\n * <p>\n * If there are any elements already in the set being decorated, they\n * are NOT transformed.\n * Contrast this with {@link #transformedSet(Set, Transformer)}.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed set\n * @throws NullPointerException if set or transformer is null\n * @since 4.0\n */\npublic static <E> TransformedSet<E> transformingSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer) {\n    return new TransformedSet<E>(set, transformer);\n}"
            ],
            [
                "transformedSet",
                "org.apache.commons.collections4.set",
                "TransformedSet",
                "/**\n * Factory method to create a transforming set that will transform\n * existing contents of the specified set.\n * <p>\n * If there are any elements already in the set being decorated, they\n * will be transformed by this method.\n * Contrast this with {@link #transformingSet(Set, Transformer)}.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed set\n * @throws NullPointerException if set or transformer is null\n * @since 4.0\n */\npublic static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer) {\n    final TransformedSet<E> decorated = new TransformedSet<E>(set, transformer);\n    if (set.size() > 0) {\n        // set is type E\n        @SuppressWarnings(\"unchecked\")\n        final E[] // NOPMD - false positive for generics\n        values = (E[]) set.toArray();\n        set.clear();\n        for (final E value : values) {\n            decorated.decorated().add(transformer.transform(value));\n        }\n    }\n    return decorated;\n}"
            ],
            [
                "transformingNavigableSet",
                "org.apache.commons.collections4.set",
                "TransformedNavigableSet",
                "/**\n * Factory method to create a transforming navigable set.\n * <p>\n * If there are any elements already in the set being decorated, they\n * are NOT transformed.\n * Contrast this with {@link #transformedNavigableSet(NavigableSet, Transformer)}.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed {@link NavigableSet}\n * @throws NullPointerException if set or transformer is null\n */\npublic static <E> TransformedNavigableSet<E> transformingNavigableSet(final NavigableSet<E> set, final Transformer<? super E, ? extends E> transformer) {\n    return new TransformedNavigableSet<E>(set, transformer);\n}"
            ],
            [
                "transformedNavigableSet",
                "org.apache.commons.collections4.set",
                "TransformedNavigableSet",
                "/**\n * Factory method to create a transforming navigable set that will transform\n * existing contents of the specified navigable set.\n * <p>\n * If there are any elements already in the set being decorated, they\n * will be transformed by this method.\n * Contrast this with {@link #transformingNavigableSet(NavigableSet, Transformer)}.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed {@link NavigableSet}\n * @throws NullPointerException if set or transformer is null\n */\npublic static <E> TransformedNavigableSet<E> transformedNavigableSet(final NavigableSet<E> set, final Transformer<? super E, ? extends E> transformer) {\n    final TransformedNavigableSet<E> decorated = new TransformedNavigableSet<E>(set, transformer);\n    if (set.size() > 0) {\n        // set is type E\n        @SuppressWarnings(\"unchecked\")\n        final E[] // NOPMD - false positive for generics\n        values = (E[]) set.toArray();\n        set.clear();\n        for (final E value : values) {\n            decorated.decorated().add(transformer.transform(value));\n        }\n    }\n    return decorated;\n}"
            ],
            [
                "predicatedNavigableSet",
                "org.apache.commons.collections4.set",
                "PredicatedNavigableSet",
                "/**\n * Factory method to create a predicated (validating) navigable set.\n * <p>\n * If there are any elements already in the set being decorated, they\n * are validated.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @param predicate  the predicate to use for validation, must not be null\n * @return a new predicated navigable set.\n * @throws NullPointerException if set or predicate is null\n * @throws IllegalArgumentException if the set contains invalid elements\n * @since 4.0\n */\npublic static <E> PredicatedNavigableSet<E> predicatedNavigableSet(final NavigableSet<E> set, final Predicate<? super E> predicate) {\n    return new PredicatedNavigableSet<E>(set, predicate);\n}"
            ],
            [
                "listOrderedSet",
                "org.apache.commons.collections4.set",
                "ListOrderedSet",
                "/**\n * Factory method to create an ordered set specifying the list and set to use.\n * <p>\n * The list and set must both be empty.\n *\n * @param <E> the element type\n * @param set the set to decorate, must be empty and not null\n * @param list the list to decorate, must be empty and not null\n * @return a new ordered set\n * @throws NullPointerException if set or list is null\n * @throws IllegalArgumentException if either the set or list is not empty\n * @since 4.0\n */\npublic static <E> ListOrderedSet<E> listOrderedSet(final Set<E> set, final List<E> list) {\n    if (set == null) {\n        throw new NullPointerException(\"Set must not be null\");\n    }\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (set.size() > 0 || list.size() > 0) {\n        throw new IllegalArgumentException(\"Set and List must be empty\");\n    }\n    return new ListOrderedSet<E>(set, list);\n}"
            ],
            [
                "listOrderedSet",
                "org.apache.commons.collections4.set",
                "ListOrderedSet",
                "/**\n * Factory method to create an ordered set.\n * <p>\n * An <code>ArrayList</code> is used to retain order.\n *\n * @param <E> the element type\n * @param set the set to decorate, must not be null\n * @return a new ordered set\n * @throws NullPointerException if set is null\n * @since 4.0\n */\npublic static <E> ListOrderedSet<E> listOrderedSet(final Set<E> set) {\n    return new ListOrderedSet<E>(set);\n}"
            ],
            [
                "listOrderedSet",
                "org.apache.commons.collections4.set",
                "ListOrderedSet",
                "/**\n * Factory method to create an ordered set using the supplied list to retain order.\n * <p>\n * A <code>HashSet</code> is used for the set behaviour.\n * <p>\n * NOTE: If the list contains duplicates, the duplicates are removed,\n * altering the specified list.\n *\n * @param <E> the element type\n * @param list the list to decorate, must not be null\n * @return a new ordered set\n * @throws NullPointerException if list is null\n * @since 4.0\n */\npublic static <E> ListOrderedSet<E> listOrderedSet(final List<E> list) {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n    return new ListOrderedSet<E>(set, list);\n}"
            ],
            [
                "unmodifiableSet",
                "org.apache.commons.collections4.set",
                "UnmodifiableSet",
                "/**\n * Factory method to create an unmodifiable set.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @return a new unmodifiable set\n * @throws NullPointerException if set is null\n * @since 4.0\n */\npublic static <E> Set<E> unmodifiableSet(final Set<? extends E> set) {\n    if (set instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final Set<E> tmpSet = (Set<E>) set;\n        return tmpSet;\n    }\n    return new UnmodifiableSet<E>(set);\n}"
            ],
            [
                "mapBackedSet",
                "org.apache.commons.collections4.set",
                "MapBackedSet",
                "/**\n * Factory method to create a set from a map.\n *\n * @param <E> the element type\n * @param <V> the dummy value type in the map\n * @param map  the map to decorate, must not be null\n * @return a new map backed set\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <E, V> MapBackedSet<E, V> mapBackedSet(final Map<E, ? super V> map) {\n    return mapBackedSet(map, null);\n}"
            ],
            [
                "mapBackedSet",
                "org.apache.commons.collections4.set",
                "MapBackedSet",
                "/**\n * Factory method to create a set from a map.\n *\n * @param <E> the element type\n * @param <V> the dummy value type in the map\n * @param map  the map to decorate, must not be null\n * @param dummyValue  the dummy value to use\n * @return a new map backed set\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <E, V> MapBackedSet<E, V> mapBackedSet(final Map<E, ? super V> map, final V dummyValue) {\n    return new MapBackedSet<E, V>(map, dummyValue);\n}"
            ],
            [
                "unmodifiableSortedSet",
                "org.apache.commons.collections4.set",
                "UnmodifiableSortedSet",
                "/**\n * Factory method to create an unmodifiable set.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @return a new unmodifiable {@link SortedSet}\n * @throws NullPointerException if set is null\n * @since 4.0\n */\npublic static <E> SortedSet<E> unmodifiableSortedSet(final SortedSet<E> set) {\n    if (set instanceof Unmodifiable) {\n        return set;\n    }\n    return new UnmodifiableSortedSet<E>(set);\n}"
            ],
            [
                "predicatedSortedSet",
                "org.apache.commons.collections4.set",
                "PredicatedSortedSet",
                "/**\n * Factory method to create a predicated (validating) sorted set.\n * <p>\n * If there are any elements already in the set being decorated, they\n * are validated.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @param predicate  the predicate to use for validation, must not be null\n * @return a new predicated sorted set.\n * @throws NullPointerException if set or predicate is null\n * @throws IllegalArgumentException if the set contains invalid elements\n * @since 4.0\n */\npublic static <E> PredicatedSortedSet<E> predicatedSortedSet(final SortedSet<E> set, final Predicate<? super E> predicate) {\n    return new PredicatedSortedSet<E>(set, predicate);\n}"
            ],
            [
                "predicatedSet",
                "org.apache.commons.collections4.set",
                "PredicatedSet",
                "/**\n * Factory method to create a predicated (validating) set.\n * <p>\n * If there are any elements already in the set being decorated, they\n * are validated.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @param predicate  the predicate to use for validation, must not be null\n * @return a decorated set\n * @throws NullPointerException if set or predicate is null\n * @throws IllegalArgumentException if the set contains invalid elements\n * @since 4.0\n */\npublic static <E> PredicatedSet<E> predicatedSet(final Set<E> set, final Predicate<? super E> predicate) {\n    return new PredicatedSet<E>(set, predicate);\n}"
            ],
            [
                "unmodifiableNavigableSet",
                "org.apache.commons.collections4.set",
                "UnmodifiableNavigableSet",
                "/**\n * Factory method to create an unmodifiable set.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @return a new unmodifiable {@link NavigableSet}\n * @throws NullPointerException if set is null\n */\npublic static <E> NavigableSet<E> unmodifiableNavigableSet(final NavigableSet<E> set) {\n    if (set instanceof Unmodifiable) {\n        return set;\n    }\n    return new UnmodifiableNavigableSet<E>(set);\n}"
            ],
            [
                "transformingSortedSet",
                "org.apache.commons.collections4.set",
                "TransformedSortedSet",
                "/**\n * Factory method to create a transforming sorted set.\n * <p>\n * If there are any elements already in the set being decorated, they\n * are NOT transformed.\n * Contrast this with {@link #transformedSortedSet(SortedSet, Transformer)}.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed {@link SortedSet}\n * @throws NullPointerException if set or transformer is null\n * @since 4.0\n */\npublic static <E> TransformedSortedSet<E> transformingSortedSet(final SortedSet<E> set, final Transformer<? super E, ? extends E> transformer) {\n    return new TransformedSortedSet<E>(set, transformer);\n}"
            ],
            [
                "transformedSortedSet",
                "org.apache.commons.collections4.set",
                "TransformedSortedSet",
                "/**\n * Factory method to create a transforming sorted set that will transform\n * existing contents of the specified sorted set.\n * <p>\n * If there are any elements already in the set being decorated, they\n * will be transformed by this method.\n * Contrast this with {@link #transformingSortedSet(SortedSet, Transformer)}.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed {@link SortedSet}\n * @throws NullPointerException if set or transformer is null\n * @since 4.0\n */\npublic static <E> TransformedSortedSet<E> transformedSortedSet(final SortedSet<E> set, final Transformer<? super E, ? extends E> transformer) {\n    final TransformedSortedSet<E> decorated = new TransformedSortedSet<E>(set, transformer);\n    if (set.size() > 0) {\n        // set is type E\n        @SuppressWarnings(\"unchecked\")\n        final E[] // NOPMD - false positive for generics\n        values = (E[]) set.toArray();\n        set.clear();\n        for (final E value : values) {\n            decorated.decorated().add(transformer.transform(value));\n        }\n    }\n    return decorated;\n}"
            ],
            [
                "get",
                "org.apache.commons.collections4",
                "EnumerationUtils",
                "/**\n * Returns the <code>index</code>-th value in the {@link Enumeration}, throwing\n * <code>IndexOutOfBoundsException</code> if there is no such element.\n * <p>\n * The Enumeration is advanced to <code>index</code> (or to the end, if\n * <code>index</code> exceeds the number of entries) as a side effect of this method.\n *\n * @param e  the enumeration to get a value from\n * @param index  the index to get\n * @param <T> the type of object in the {@link Enumeration}\n * @return the object at the specified index\n * @throws IndexOutOfBoundsException if the index is invalid\n * @throws IllegalArgumentException if the object type is invalid\n * @since 4.1\n */\npublic static <T> T get(final Enumeration<T> e, final int index) {\n    int i = index;\n    CollectionUtils.checkIndexBounds(i);\n    while (e.hasMoreElements()) {\n        i--;\n        if (i == -1) {\n            return e.nextElement();\n        } else {\n            e.nextElement();\n        }\n    }\n    throw new IndexOutOfBoundsException(\"Entry does not exist: \" + i);\n}"
            ],
            [
                "toList",
                "org.apache.commons.collections4",
                "EnumerationUtils",
                "/**\n * Creates a list based on an enumeration.\n *\n * <p>As the enumeration is traversed, an ArrayList of its values is\n * created. The new list is returned.</p>\n *\n * @param <E> the element type\n * @param enumeration  the enumeration to traverse, which should not be <code>null</code>.\n * @return a list containing all elements of the given enumeration\n * @throws NullPointerException if the enumeration parameter is <code>null</code>.\n */\npublic static <E> List<E> toList(final Enumeration<? extends E> enumeration) {\n    return IteratorUtils.toList(new EnumerationIterator<E>(enumeration));\n}"
            ],
            [
                "toList",
                "org.apache.commons.collections4",
                "EnumerationUtils",
                "/**\n * Override toList(Enumeration) for StringTokenizer as it implements Enumeration&lt;Object&gt;\n * for the sake of backward compatibility.\n *\n * @param stringTokenizer  the tokenizer to convert to a {@link List}&lt;{@link String}&gt;\n * @return a list containing all tokens of the given StringTokenizer\n */\npublic static List<String> toList(final StringTokenizer stringTokenizer) {\n    final List<String> result = new ArrayList<String>(stringTokenizer.countTokens());\n    while (stringTokenizer.hasMoreTokens()) {\n        result.add(stringTokenizer.nextToken());\n    }\n    return result;\n}"
            ],
            [
                "unmodifiableQueue",
                "org.apache.commons.collections4",
                "QueueUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns an unmodifiable queue backed by the given queue.\n *\n * @param <E> the type of the elements in the queue\n * @param queue  the queue to make unmodifiable, must not be null\n * @return an unmodifiable queue backed by that queue\n * @throws NullPointerException if the queue is null\n */\npublic static <E> Queue<E> unmodifiableQueue(final Queue<? extends E> queue) {\n    return UnmodifiableQueue.unmodifiableQueue(queue);\n}"
            ],
            [
                "predicatedQueue",
                "org.apache.commons.collections4",
                "QueueUtils",
                "/**\n * Returns a predicated (validating) queue backed by the given queue.\n * <p>\n * Only objects that pass the test in the given predicate can be added to the queue.\n * Trying to add an invalid object results in an IllegalArgumentException.\n * It is important not to use the original queue after invoking this method,\n * as it is a backdoor for adding invalid objects.\n *\n * @param <E> the type of the elements in the queue\n * @param queue  the queue to predicate, must not be null\n * @param predicate  the predicate used to evaluate new elements, must not be null\n * @return a predicated queue\n * @throws NullPointerException if the queue or predicate is null\n */\npublic static <E> Queue<E> predicatedQueue(final Queue<E> queue, final Predicate<? super E> predicate) {\n    return PredicatedQueue.predicatedQueue(queue, predicate);\n}"
            ],
            [
                "transformingQueue",
                "org.apache.commons.collections4",
                "QueueUtils",
                "/**\n * Returns a transformed queue backed by the given queue.\n * <p>\n * Each object is passed through the transformer as it is added to the\n * Queue. It is important not to use the original queue after invoking this\n * method, as it is a backdoor for adding untransformed objects.\n * <p>\n * Existing entries in the specified queue will not be transformed.\n * If you want that behaviour, see {@link TransformedQueue#transformedQueue}.\n *\n * @param <E> the type of the elements in the queue\n * @param queue  the queue to predicate, must not be null\n * @param transformer  the transformer for the queue, must not be null\n * @return a transformed queue backed by the given queue\n * @throws NullPointerException if the queue or transformer is null\n */\npublic static <E> Queue<E> transformingQueue(final Queue<E> queue, final Transformer<? super E, ? extends E> transformer) {\n    return TransformedQueue.transformingQueue(queue, transformer);\n}"
            ],
            [
                "emptyQueue",
                "org.apache.commons.collections4",
                "QueueUtils",
                "/**\n * Get an empty <code>Queue</code>.\n *\n * @param <E> the type of the elements in the queue\n * @return an empty {@link Queue}\n */\n// OK, empty queue is compatible with any type\n@SuppressWarnings(\"unchecked\")\npublic static <E> Queue<E> emptyQueue() {\n    return (Queue<E>) EMPTY_QUEUE;\n}"
            ],
            [
                "synchronizedBag",
                "org.apache.commons.collections4.bag",
                "SynchronizedBag",
                "/**\n * Factory method to create a synchronized bag.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @return a new synchronized Bag\n * @throws NullPointerException if bag is null\n * @since 4.0\n */\npublic static <E> SynchronizedBag<E> synchronizedBag(final Bag<E> bag) {\n    return new SynchronizedBag<E>(bag);\n}"
            ],
            [
                "collectionBag",
                "org.apache.commons.collections4.bag",
                "CollectionBag",
                "/**\n * Factory method to create a bag that complies to the Collection contract.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @return a Bag that complies to the Collection contract\n * @throws NullPointerException if bag is null\n */\npublic static <E> Bag<E> collectionBag(final Bag<E> bag) {\n    return new CollectionBag<E>(bag);\n}"
            ],
            [
                "unmodifiableBag",
                "org.apache.commons.collections4.bag",
                "UnmodifiableBag",
                "/**\n * Factory method to create an unmodifiable bag.\n * <p>\n * If the bag passed in is already unmodifiable, it is returned.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @return an unmodifiable Bag\n * @throws NullPointerException if bag is null\n * @since 4.0\n */\npublic static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n    if (bag instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final Bag<E> tmpBag = (Bag<E>) bag;\n        return tmpBag;\n    }\n    return new UnmodifiableBag<E>(bag);\n}"
            ],
            [
                "predicatedSortedBag",
                "org.apache.commons.collections4.bag",
                "PredicatedSortedBag",
                "/**\n * Factory method to create a predicated (validating) bag.\n * <p>\n * If there are any elements already in the bag being decorated, they\n * are validated.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @param predicate  the predicate to use for validation, must not be null\n * @return a new predicated SortedBag\n * @throws NullPointerException if bag or predicate is null\n * @throws IllegalArgumentException if the bag contains invalid elements\n * @since 4.0\n */\npublic static <E> PredicatedSortedBag<E> predicatedSortedBag(final SortedBag<E> bag, final Predicate<? super E> predicate) {\n    return new PredicatedSortedBag<E>(bag, predicate);\n}"
            ],
            [
                "unmodifiableSortedBag",
                "org.apache.commons.collections4.bag",
                "UnmodifiableSortedBag",
                "/**\n * Factory method to create an unmodifiable bag.\n * <p>\n * If the bag passed in is already unmodifiable, it is returned.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @return an unmodifiable SortedBag\n * @throws NullPointerException if bag is null\n * @since 4.0\n */\npublic static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n    if (bag instanceof Unmodifiable) {\n        return bag;\n    }\n    return new UnmodifiableSortedBag<E>(bag);\n}"
            ],
            [
                "transformingSortedBag",
                "org.apache.commons.collections4.bag",
                "TransformedSortedBag",
                "/**\n * Factory method to create a transforming sorted bag.\n * <p>\n * If there are any elements already in the bag being decorated, they\n * are NOT transformed. Contrast this with {@link #transformedSortedBag(SortedBag, Transformer)}.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed SortedBag\n * @throws NullPointerException if bag or transformer is null\n * @since 4.0\n */\npublic static <E> TransformedSortedBag<E> transformingSortedBag(final SortedBag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n    return new TransformedSortedBag<E>(bag, transformer);\n}"
            ],
            [
                "transformedSortedBag",
                "org.apache.commons.collections4.bag",
                "TransformedSortedBag",
                "/**\n * Factory method to create a transforming sorted bag that will transform\n * existing contents of the specified sorted bag.\n * <p>\n * If there are any elements already in the bag being decorated, they\n * will be transformed by this method.\n * Contrast this with {@link #transformingSortedBag(SortedBag, Transformer)}.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed SortedBag\n * @throws NullPointerException if bag or transformer is null\n * @since 4.0\n */\npublic static <E> TransformedSortedBag<E> transformedSortedBag(final SortedBag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n    final TransformedSortedBag<E> decorated = new TransformedSortedBag<E>(bag, transformer);\n    if (bag.size() > 0) {\n        // bag is type E\n        @SuppressWarnings(\"unchecked\")\n        final E[] // NOPMD - false positive for generics\n        values = (E[]) bag.toArray();\n        bag.clear();\n        for (final E value : values) {\n            decorated.decorated().add(transformer.transform(value));\n        }\n    }\n    return decorated;\n}"
            ],
            [
                "predicatedBag",
                "org.apache.commons.collections4.bag",
                "PredicatedBag",
                "/**\n * Factory method to create a predicated (validating) bag.\n * <p>\n * If there are any elements already in the bag being decorated, they\n * are validated.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @param predicate  the predicate to use for validation, must not be null\n * @return a new predicated Bag\n * @throws NullPointerException if bag or predicate is null\n * @throws IllegalArgumentException if the bag contains invalid elements\n * @since 4.0\n */\npublic static <E> PredicatedBag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n    return new PredicatedBag<E>(bag, predicate);\n}"
            ],
            [
                "synchronizedSortedBag",
                "org.apache.commons.collections4.bag",
                "SynchronizedSortedBag",
                "/**\n * Factory method to create a synchronized sorted bag.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @return a new synchronized SortedBag\n * @throws NullPointerException if bag is null\n * @since 4.0\n */\npublic static <E> SynchronizedSortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n    return new SynchronizedSortedBag<E>(bag);\n}"
            ],
            [
                "collectionSortedBag",
                "org.apache.commons.collections4.bag",
                "CollectionSortedBag",
                "/**\n * Factory method to create a sorted bag that complies to the Collection contract.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the sorted bag to decorate, must not be null\n * @return a SortedBag that complies to the Collection contract\n * @throws NullPointerException if bag is null\n */\npublic static <E> SortedBag<E> collectionSortedBag(final SortedBag<E> bag) {\n    return new CollectionSortedBag<E>(bag);\n}"
            ],
            [
                "transformingBag",
                "org.apache.commons.collections4.bag",
                "TransformedBag",
                "/**\n * Factory method to create a transforming bag.\n * <p>\n * If there are any elements already in the bag being decorated, they\n * are NOT transformed. Contrast this with {@link #transformedBag(Bag, Transformer)}.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed Bag\n * @throws NullPointerException if bag or transformer is null\n * @since 4.0\n */\npublic static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n    return new TransformedBag<E>(bag, transformer);\n}"
            ],
            [
                "transformedBag",
                "org.apache.commons.collections4.bag",
                "TransformedBag",
                "/**\n * Factory method to create a transforming bag that will transform\n * existing contents of the specified bag.\n * <p>\n * If there are any elements already in the bag being decorated, they\n * will be transformed by this method.\n * Contrast this with {@link #transformingBag(Bag, Transformer)}.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed Bag\n * @throws NullPointerException if bag or transformer is null\n * @since 4.0\n */\npublic static <E> Bag<E> transformedBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n    final TransformedBag<E> decorated = new TransformedBag<E>(bag, transformer);\n    if (bag.size() > 0) {\n        // Bag is of type E\n        @SuppressWarnings(\"unchecked\")\n        final E[] // NOPMD - false positive for generics\n        values = (E[]) bag.toArray();\n        bag.clear();\n        for (final E value : values) {\n            decorated.decorated().add(transformer.transform(value));\n        }\n    }\n    return decorated;\n}"
            ],
            [
                "predicatedMultiSet",
                "org.apache.commons.collections4.multiset",
                "PredicatedMultiSet",
                "/**\n * Factory method to create a predicated (validating) multiset.\n * <p>\n * If there are any elements already in the multiset being decorated, they\n * are validated.\n *\n * @param <E> the type of the elements in the multiset\n * @param multiset  the multiset to decorate, must not be null\n * @param predicate  the predicate to use for validation, must not be null\n * @return a new predicated MultiSet\n * @throws NullPointerException if multiset or predicate is null\n * @throws IllegalArgumentException if the multiset contains invalid elements\n */\npublic static <E> PredicatedMultiSet<E> predicatedMultiSet(final MultiSet<E> multiset, final Predicate<? super E> predicate) {\n    return new PredicatedMultiSet<E>(multiset, predicate);\n}"
            ],
            [
                "unmodifiableMultiSet",
                "org.apache.commons.collections4.multiset",
                "UnmodifiableMultiSet",
                "/**\n * Factory method to create an unmodifiable multiset.\n * <p>\n * If the multiset passed in is already unmodifiable, it is returned.\n *\n * @param <E>  the type of the elements in the multiset\n * @param multiset  the multiset to decorate, may not be null\n * @return an unmodifiable MultiSet\n * @throws NullPointerException if multiset is null\n */\npublic static <E> MultiSet<E> unmodifiableMultiSet(final MultiSet<? extends E> multiset) {\n    if (multiset instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final MultiSet<E> tmpMultiSet = (MultiSet<E>) multiset;\n        return tmpMultiSet;\n    }\n    return new UnmodifiableMultiSet<E>(multiset);\n}"
            ],
            [
                "synchronizedMultiSet",
                "org.apache.commons.collections4.multiset",
                "SynchronizedMultiSet",
                "/**\n * Factory method to create a synchronized multiset.\n *\n * @param <E> the type of the elements in the multiset\n * @param multiset  the multiset to decorate, must not be null\n * @return a new synchronized MultiSet\n * @throws NullPointerException if multiset is null\n */\npublic static <E> SynchronizedMultiSet<E> synchronizedMultiSet(final MultiSet<E> multiset) {\n    return new SynchronizedMultiSet<E>(multiset);\n}"
            ],
            [
                "synchronizedBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns a synchronized (thread-safe) bag backed by the given bag. In\n * order to guarantee serial access, it is critical that all access to the\n * backing bag is accomplished through the returned bag.\n * <p>\n * It is imperative that the user manually synchronize on the returned bag\n * when iterating over it:\n *\n * <pre>\n * Bag bag = BagUtils.synchronizedBag(new HashBag());\n * ...\n * synchronized(bag) {\n *     Iterator i = bag.iterator(); // Must be in synchronized block\n *     while (i.hasNext())\n *         foo(i.next());\n *     }\n * }\n * </pre>\n *\n * Failure to follow this advice may result in non-deterministic behavior.\n *\n * @param <E> the element type\n * @param bag the bag to synchronize, must not be null\n * @return a synchronized bag backed by that bag\n * @throws NullPointerException if the Bag is null\n */\npublic static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n    return SynchronizedBag.synchronizedBag(bag);\n}"
            ],
            [
                "unmodifiableBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * Returns an unmodifiable view of the given bag. Any modification attempts\n * to the returned bag will raise an {@link UnsupportedOperationException}.\n *\n * @param <E> the element type\n * @param bag the bag whose unmodifiable view is to be returned, must not be null\n * @return an unmodifiable view of that bag\n * @throws NullPointerException if the Bag is null\n */\npublic static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n    return UnmodifiableBag.unmodifiableBag(bag);\n}"
            ],
            [
                "predicatedBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * Returns a predicated (validating) bag backed by the given bag.\n * <p>\n * Only objects that pass the test in the given predicate can be added to\n * the bag. Trying to add an invalid object results in an\n * IllegalArgumentException. It is important not to use the original bag\n * after invoking this method, as it is a backdoor for adding invalid\n * objects.\n *\n * @param <E> the element type\n * @param bag the bag to predicate, must not be null\n * @param predicate the predicate for the bag, must not be null\n * @return a predicated bag backed by the given bag\n * @throws NullPointerException if the Bag or Predicate is null\n */\npublic static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n    return PredicatedBag.predicatedBag(bag, predicate);\n}"
            ],
            [
                "transformingBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * Returns a transformed bag backed by the given bag.\n * <p>\n * Each object is passed through the transformer as it is added to the Bag.\n * It is important not to use the original bag after invoking this method,\n * as it is a backdoor for adding untransformed objects.\n * <p>\n * Existing entries in the specified bag will not be transformed.\n * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n *\n * @param <E> the element type\n * @param bag the bag to predicate, must not be null\n * @param transformer the transformer for the bag, must not be null\n * @return a transformed bag backed by the given bag\n * @throws NullPointerException if the Bag or Transformer is null\n */\npublic static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n    return TransformedBag.transformingBag(bag, transformer);\n}"
            ],
            [
                "collectionBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * Returns a bag that complies to the Collection contract, backed by the given bag.\n *\n * @param <E> the element type\n * @param bag the bag to decorate, must not be null\n * @return a Bag that complies to the Collection contract\n * @throws NullPointerException if bag is null\n * @since 4.0\n */\npublic static <E> Bag<E> collectionBag(final Bag<E> bag) {\n    return CollectionBag.collectionBag(bag);\n}"
            ],
            [
                "synchronizedSortedBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns a synchronized (thread-safe) sorted bag backed by the given\n * sorted bag. In order to guarantee serial access, it is critical that all\n * access to the backing bag is accomplished through the returned bag.\n * <p>\n * It is imperative that the user manually synchronize on the returned bag\n * when iterating over it:\n *\n * <pre>\n * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n * ...\n * synchronized(bag) {\n *     Iterator i = bag.iterator(); // Must be in synchronized block\n *     while (i.hasNext())\n *         foo(i.next());\n *     }\n * }\n * </pre>\n *\n * Failure to follow this advice may result in non-deterministic behavior.\n *\n * @param <E> the element type\n * @param bag the bag to synchronize, must not be null\n * @return a synchronized bag backed by that bag\n * @throws NullPointerException if the SortedBag is null\n */\npublic static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n    return SynchronizedSortedBag.synchronizedSortedBag(bag);\n}"
            ],
            [
                "unmodifiableSortedBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * Returns an unmodifiable view of the given sorted bag. Any modification\n * attempts to the returned bag will raise an\n * {@link UnsupportedOperationException}.\n *\n * @param <E> the element type\n * @param bag the bag whose unmodifiable view is to be returned, must not be null\n * @return an unmodifiable view of that bag\n * @throws NullPointerException if the SortedBag is null\n */\npublic static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n    return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n}"
            ],
            [
                "predicatedSortedBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * Returns a predicated (validating) sorted bag backed by the given sorted\n * bag.\n * <p>\n * Only objects that pass the test in the given predicate can be added to\n * the bag. Trying to add an invalid object results in an\n * IllegalArgumentException. It is important not to use the original bag\n * after invoking this method, as it is a backdoor for adding invalid\n * objects.\n *\n * @param <E> the element type\n * @param bag the sorted bag to predicate, must not be null\n * @param predicate the predicate for the bag, must not be null\n * @return a predicated bag backed by the given bag\n * @throws NullPointerException if the SortedBag or Predicate is null\n */\npublic static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag, final Predicate<? super E> predicate) {\n    return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n}"
            ],
            [
                "transformingSortedBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * Returns a transformed sorted bag backed by the given bag.\n * <p>\n * Each object is passed through the transformer as it is added to the Bag.\n * It is important not to use the original bag after invoking this method,\n * as it is a backdoor for adding untransformed objects.\n * <p>\n * Existing entries in the specified bag will not be transformed.\n * If you want that behaviour, see\n * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n *\n * @param <E> the element type\n * @param bag the bag to predicate, must not be null\n * @param transformer the transformer for the bag, must not be null\n * @return a transformed bag backed by the given bag\n * @throws NullPointerException if the Bag or Transformer is null\n */\npublic static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n    return TransformedSortedBag.transformingSortedBag(bag, transformer);\n}"
            ],
            [
                "emptyBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * Get an empty <code>Bag</code>.\n *\n * @param <E> the element type\n * @return an empty Bag\n */\n// OK, empty bag is compatible with any type\n@SuppressWarnings(\"unchecked\")\npublic static <E> Bag<E> emptyBag() {\n    return (Bag<E>) EMPTY_BAG;\n}"
            ],
            [
                "emptySortedBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * Get an empty <code>SortedBag</code>.\n *\n * @param <E> the element type\n * @return an empty sorted Bag\n */\n// OK, empty bag is compatible with any type\n@SuppressWarnings(\"unchecked\")\npublic static <E> SortedBag<E> emptySortedBag() {\n    return (SortedBag<E>) EMPTY_SORTED_BAG;\n}"
            ],
            [
                "resettableEmptyListIterator",
                "org.apache.commons.collections4.iterators",
                "EmptyListIterator",
                "/**\n * Get a typed instance of the iterator.\n * @param <E> the element type\n * @return {@link ResettableListIterator}<E>\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> ResettableListIterator<E> resettableEmptyListIterator() {\n    return (ResettableListIterator<E>) RESETTABLE_INSTANCE;\n}"
            ],
            [
                "emptyListIterator",
                "org.apache.commons.collections4.iterators",
                "EmptyListIterator",
                "/**\n * Get a typed instance of the iterator.\n * @param <E> the element type\n * @return {@link ListIterator}<E>\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> ListIterator<E> emptyListIterator() {\n    return (ListIterator<E>) INSTANCE;\n}"
            ],
            [
                "unmodifiableOrderedMapIterator",
                "org.apache.commons.collections4.iterators",
                "UnmodifiableOrderedMapIterator",
                "//-----------------------------------------------------------------------\n/**\n * Decorates the specified iterator such that it cannot be modified.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param iterator  the iterator to decorate\n * @return a new unmodifiable ordered map iterator\n * @throws NullPointerException if the iterator is null\n */\npublic static <K, V> OrderedMapIterator<K, V> unmodifiableOrderedMapIterator(final OrderedMapIterator<K, ? extends V> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"OrderedMapIterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final OrderedMapIterator<K, V> tmpIterator = (OrderedMapIterator<K, V>) iterator;\n        return tmpIterator;\n    }\n    return new UnmodifiableOrderedMapIterator<K, V>(iterator);\n}"
            ],
            [
                "unmodifiableIterator",
                "org.apache.commons.collections4.iterators",
                "UnmodifiableIterator",
                "//-----------------------------------------------------------------------\n/**\n * Decorates the specified iterator such that it cannot be modified.\n * <p>\n * If the iterator is already unmodifiable it is returned directly.\n *\n * @param <E>  the element type\n * @param iterator  the iterator to decorate\n * @return a new unmodifiable iterator\n * @throws NullPointerException if the iterator is null\n */\npublic static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final Iterator<E> tmpIterator = (Iterator<E>) iterator;\n        return tmpIterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}"
            ],
            [
                "peekingIterator",
                "org.apache.commons.collections4.iterators",
                "PeekingIterator",
                "//-----------------------------------------------------------------------\n/**\n * Decorates the specified iterator to support one-element lookahead.\n * <p>\n * If the iterator is already a {@link PeekingIterator} it is returned directly.\n *\n * @param <E>  the element type\n * @param iterator  the iterator to decorate\n * @return a new peeking iterator\n * @throws NullPointerException if the iterator is null\n */\npublic static <E> PeekingIterator<E> peekingIterator(final Iterator<? extends E> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof PeekingIterator<?>) {\n        // safe cast\n        @SuppressWarnings(\"unchecked\")\n        final PeekingIterator<E> it = (PeekingIterator<E>) iterator;\n        return it;\n    }\n    return new PeekingIterator<E>(iterator);\n}"
            ],
            [
                "emptyMapIterator",
                "org.apache.commons.collections4.iterators",
                "EmptyMapIterator",
                "/**\n * Get a typed instance of the iterator.\n * @param <K> the key type\n * @param <V> the value type\n * @return {@link MapIterator}<K, V>\n */\n@SuppressWarnings(\"unchecked\")\npublic static <K, V> MapIterator<K, V> emptyMapIterator() {\n    return (MapIterator<K, V>) INSTANCE;\n}"
            ],
            [
                "emptyOrderedIterator",
                "org.apache.commons.collections4.iterators",
                "EmptyOrderedIterator",
                "/**\n * Typed instance of the iterator.\n * @param <E> the element type\n * @return OrderedIterator<E>\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> OrderedIterator<E> emptyOrderedIterator() {\n    return (OrderedIterator<E>) INSTANCE;\n}"
            ],
            [
                "umodifiableListIterator",
                "org.apache.commons.collections4.iterators",
                "UnmodifiableListIterator",
                "//-----------------------------------------------------------------------\n/**\n * Decorates the specified iterator such that it cannot be modified.\n *\n * @param <E>  the element type\n * @param iterator  the iterator to decorate\n * @return a new unmodifiable list iterator\n * @throws NullPointerException if the iterator is null\n */\npublic static <E> ListIterator<E> umodifiableListIterator(final ListIterator<? extends E> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"ListIterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final ListIterator<E> tmpIterator = (ListIterator<E>) iterator;\n        return tmpIterator;\n    }\n    return new UnmodifiableListIterator<E>(iterator);\n}"
            ],
            [
                "emptyOrderedMapIterator",
                "org.apache.commons.collections4.iterators",
                "EmptyOrderedMapIterator",
                "/**\n * Get a typed instance of the iterator.\n * @param <K> the key type\n * @param <V> the value type\n * @return {@link OrderedMapIterator}<K, V>\n */\n@SuppressWarnings(\"unchecked\")\npublic static <K, V> OrderedMapIterator<K, V> emptyOrderedMapIterator() {\n    return (OrderedMapIterator<K, V>) INSTANCE;\n}"
            ],
            [
                "unmodifiableMapIterator",
                "org.apache.commons.collections4.iterators",
                "UnmodifiableMapIterator",
                "//-----------------------------------------------------------------------\n/**\n * Decorates the specified iterator such that it cannot be modified.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param iterator  the iterator to decorate\n * @return a new unmodifiable map iterator\n * @throws NullPointerException if the iterator is null\n */\npublic static <K, V> MapIterator<K, V> unmodifiableMapIterator(final MapIterator<? extends K, ? extends V> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"MapIterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final MapIterator<K, V> tmpIterator = (MapIterator<K, V>) iterator;\n        return tmpIterator;\n    }\n    return new UnmodifiableMapIterator<K, V>(iterator);\n}"
            ],
            [
                "resettableEmptyIterator",
                "org.apache.commons.collections4.iterators",
                "EmptyIterator",
                "/**\n * Get a typed resettable empty iterator instance.\n * @param <E> the element type\n * @return ResettableIterator<E>\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> ResettableIterator<E> resettableEmptyIterator() {\n    return (ResettableIterator<E>) RESETTABLE_INSTANCE;\n}"
            ],
            [
                "emptyIterator",
                "org.apache.commons.collections4.iterators",
                "EmptyIterator",
                "/**\n * Get a typed empty iterator instance.\n * @param <E> the element type\n * @return Iterator<E>\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Iterator<E> emptyIterator() {\n    return (Iterator<E>) INSTANCE;\n}"
            ],
            [
                "pushbackIterator",
                "org.apache.commons.collections4.iterators",
                "PushbackIterator",
                "//-----------------------------------------------------------------------\n/**\n * Decorates the specified iterator to support one-element lookahead.\n * <p>\n * If the iterator is already a {@link PushbackIterator} it is returned directly.\n *\n * @param <E>  the element type\n * @param iterator  the iterator to decorate\n * @return a new peeking iterator\n * @throws NullPointerException if the iterator is null\n */\npublic static <E> PushbackIterator<E> pushbackIterator(final Iterator<? extends E> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof PushbackIterator<?>) {\n        // safe cast\n        @SuppressWarnings(\"unchecked\")\n        final PushbackIterator<E> it = (PushbackIterator<E>) iterator;\n        return it;\n    }\n    return new PushbackIterator<E>(iterator);\n}"
            ],
            [
                "readableMap",
                "org.apache.commons.collections4",
                "SplitMapUtils",
                "//-----------------------------------------------------------------------\n/**\n * Get the specified {@link Get} as an instance of {@link IterableMap}.\n * If <code>get</code> implements {@link IterableMap} directly, no conversion will take place.\n * If <code>get</code> implements {@link Map} but not {@link IterableMap} it will be decorated.\n * Otherwise an {@link Unmodifiable} {@link IterableMap} will be returned.\n * @param <K> the key type\n * @param <V> the value type\n * @param get to wrap, must not be null\n * @return {@link IterableMap}\n * @throws NullPointerException if the argument is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <K, V> IterableMap<K, V> readableMap(final Get<K, V> get) {\n    if (get == null) {\n        throw new NullPointerException(\"Get must not be null\");\n    }\n    if (get instanceof Map) {\n        return get instanceof IterableMap ? ((IterableMap<K, V>) get) : MapUtils.iterableMap((Map<K, V>) get);\n    }\n    return new WrappedGet<K, V>(get);\n}"
            ],
            [
                "writableMap",
                "org.apache.commons.collections4",
                "SplitMapUtils",
                "/**\n * Get the specified {@link Put} as an instanceof {@link Map}.\n * If <code>put</code> implements {@link Map} directly, no conversion will take place.\n * Otherwise a <em>write-only</em> {@link Map} will be returned.  On such a {@link Map}\n * it is recommended that the result of #put(K, V) be discarded as it likely will not\n * match <code>V</code> at runtime.\n *\n * @param <K> the key type\n * @param <V> the element type\n * @param put to wrap, must not be null\n * @return {@link Map}\n * @throws NullPointerException if the argument is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <K, V> Map<K, V> writableMap(final Put<K, V> put) {\n    if (put == null) {\n        throw new NullPointerException(\"Put must not be null\");\n    }\n    if (put instanceof Map) {\n        return (Map<K, V>) put;\n    }\n    return new WrappedPut<K, V>(put);\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "EMPTY_ITERATOR",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// validation is done in this class in certain cases because the\n// public classes allow invalid states\n/**\n * An iterator over no elements.\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final ResettableIterator EMPTY_ITERATOR = EmptyIterator.RESETTABLE_INSTANCE;"
            ],
            [
                "EMPTY_LIST_ITERATOR",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * A list iterator over no elements.\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final ResettableListIterator EMPTY_LIST_ITERATOR = EmptyListIterator.RESETTABLE_INSTANCE;"
            ],
            [
                "EMPTY_ORDERED_ITERATOR",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * An ordered iterator over no elements.\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final OrderedIterator EMPTY_ORDERED_ITERATOR = EmptyOrderedIterator.INSTANCE;"
            ],
            [
                "EMPTY_MAP_ITERATOR",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * A map iterator over no elements.\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final MapIterator EMPTY_MAP_ITERATOR = EmptyMapIterator.INSTANCE;"
            ],
            [
                "EMPTY_ORDERED_MAP_ITERATOR",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * An ordered map iterator over no elements.\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final OrderedMapIterator EMPTY_ORDERED_MAP_ITERATOR = EmptyOrderedMapIterator.INSTANCE;"
            ],
            [
                "NATURAL_COMPARATOR",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Comparator for natural sort order.\n *\n * @see ComparableComparator#comparableComparator()\n */\n// explicit type needed for Java 1.5 compilation\n@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\npublic static final Comparator NATURAL_COMPARATOR = ComparableComparator.<Comparable>comparableComparator();"
            ],
            [
                "EMPTY_MULTI_VALUED_MAP",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "/**\n * An empty {@link UnmodifiableMultiValuedMap}.\n */\n@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\npublic static final MultiValuedMap EMPTY_MULTI_VALUED_MAP = UnmodifiableMultiValuedMap.unmodifiableMultiValuedMap(new ArrayListValuedHashMap(0, 0));"
            ],
            [
                "EMPTY_SORTED_MAP",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * An empty unmodifiable sorted map.\n * This is not provided in the JDK.\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final SortedMap EMPTY_SORTED_MAP = UnmodifiableSortedMap.unmodifiableSortedMap(new TreeMap<Object, Object>());"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "DefaultEquator",
                "/**\n * Static instance\n */\n// the static instance works for all types\n@SuppressWarnings(\"rawtypes\")\npublic static final DefaultEquator INSTANCE = new DefaultEquator<Object>();"
            ],
            [
                "HASHCODE_NULL",
                "org.apache.commons.collections4.functors",
                "DefaultEquator",
                "/**\n * Hashcode used for <code>null</code> objects.\n */\npublic static final int HASHCODE_NULL = -1;"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "ExceptionClosure",
                "/**\n * Singleton predicate instance\n */\n// the static instance works for all types\n@SuppressWarnings(\"rawtypes\")\npublic static final Closure INSTANCE = new ExceptionClosure<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "NOPClosure",
                "/**\n * Singleton predicate instance\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final Closure INSTANCE = new NOPClosure<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "NullPredicate",
                "/**\n * Singleton predicate instance\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final Predicate INSTANCE = new NullPredicate<Object>();"
            ],
            [
                "NULL_INSTANCE",
                "org.apache.commons.collections4.functors",
                "ConstantTransformer",
                "/**\n * Returns null each time\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final Transformer NULL_INSTANCE = new ConstantTransformer<Object, Object>(null);"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "ExceptionTransformer",
                "/**\n * Singleton predicate instance\n */\n// the static instance works for all types\n@SuppressWarnings(\"rawtypes\")\npublic static final Transformer INSTANCE = new ExceptionTransformer<Object, Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "NOPTransformer",
                "/**\n * Singleton predicate instance\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final Transformer INSTANCE = new NOPTransformer<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "ExceptionFactory",
                "/**\n * Singleton predicate instance\n */\n// the static instance works for all types\n@SuppressWarnings(\"rawtypes\")\npublic static final Factory INSTANCE = new ExceptionFactory<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "ExceptionPredicate",
                "/**\n * Singleton predicate instance\n */\n// the static instance works for all types\n@SuppressWarnings(\"rawtypes\")\npublic static final Predicate INSTANCE = new ExceptionPredicate<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "FalsePredicate",
                "/**\n * Singleton predicate instance\n */\n// the static instance works for all types\n@SuppressWarnings(\"rawtypes\")\npublic static final Predicate INSTANCE = new FalsePredicate<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "CloneTransformer",
                "/**\n * Singleton predicate instance\n */\n// the singleton instance works for all types\n@SuppressWarnings(\"rawtypes\")\npublic static final Transformer INSTANCE = new CloneTransformer<Object>();"
            ],
            [
                "NULL_INSTANCE",
                "org.apache.commons.collections4.functors",
                "ConstantFactory",
                "/**\n * Returns null each time\n */\n// The null factory works for all object types\n@SuppressWarnings(\"rawtypes\")\npublic static final Factory NULL_INSTANCE = new ConstantFactory<Object>(null);"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "TruePredicate",
                "/**\n * Singleton predicate instance\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final Predicate INSTANCE = new TruePredicate<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "NotNullPredicate",
                "/**\n * Singleton predicate instance\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final Predicate INSTANCE = new NotNullPredicate<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.comparators",
                "ComparableComparator",
                "/**\n * The singleton instance.\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final ComparableComparator INSTANCE = new ComparableComparator();"
            ],
            [
                "EMPTY_COLLECTION",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * An empty unmodifiable collection.\n * The JDK provides empty Set and List implementations which could be used for\n * this purpose. However they could be cast to Set or List which might be\n * undesirable. This implementation only implements Collection.\n */\n// we deliberately use the raw type here\n@SuppressWarnings(\"rawtypes\")\npublic static final Collection EMPTY_COLLECTION = UnmodifiableCollection.unmodifiableCollection(new ArrayList<Object>());"
            ],
            [
                "EMPTY_ITERABLE",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * An empty iterable.\n */\n@SuppressWarnings(\"rawtypes\")\nstatic final FluentIterable EMPTY_ITERABLE = new FluentIterable<Object>() {\n\n    @Override\n    public Iterator<Object> iterator() {\n        return IteratorUtils.emptyIterator();\n    }\n};"
            ],
            [
                "NULL_BIT_KEY",
                "org.apache.commons.collections4.trie",
                "KeyAnalyzer",
                "/**\n * Returned by {@link #bitIndex(Object, int, int, Object, int, int)}\n * if key's bits are all 0.\n */\npublic static final int NULL_BIT_KEY = -1;"
            ],
            [
                "EQUAL_BIT_KEY",
                "org.apache.commons.collections4.trie",
                "KeyAnalyzer",
                "/**\n * Returned by {@link #bitIndex(Object, int, int, Object, int, int)} if key and found key are equal.\n * This is a very very specific case and shouldn't happen on a regular basis.\n */\npublic static final int EQUAL_BIT_KEY = -2;"
            ],
            [
                "OUT_OF_BOUNDS_BIT_KEY",
                "org.apache.commons.collections4.trie",
                "KeyAnalyzer",
                "public static final int OUT_OF_BOUNDS_BIT_KEY = -3;"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.trie.analyzer",
                "StringKeyAnalyzer",
                "/**\n * A singleton instance of {@link StringKeyAnalyzer}.\n */\npublic static final StringKeyAnalyzer INSTANCE = new StringKeyAnalyzer();"
            ],
            [
                "LENGTH",
                "org.apache.commons.collections4.trie.analyzer",
                "StringKeyAnalyzer",
                "/**\n * The number of bits per {@link Character}.\n */\npublic static final int LENGTH = Character.SIZE;"
            ],
            [
                "NO_NEXT_ENTRY",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "protected static final String NO_NEXT_ENTRY = \"No next() entry in the iteration\";"
            ],
            [
                "NO_PREVIOUS_ENTRY",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "protected static final String NO_PREVIOUS_ENTRY = \"No previous() entry in the iteration\";"
            ],
            [
                "REMOVE_INVALID",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "protected static final String REMOVE_INVALID = \"remove() can only be called once after next()\";"
            ],
            [
                "GETKEY_INVALID",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "protected static final String GETKEY_INVALID = \"getKey() can only be called after next() and before remove()\";"
            ],
            [
                "GETVALUE_INVALID",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "protected static final String GETVALUE_INVALID = \"getValue() can only be called after next() and before remove()\";"
            ],
            [
                "SETVALUE_INVALID",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "protected static final String SETVALUE_INVALID = \"setValue() can only be called after next() and before remove()\";"
            ],
            [
                "DEFAULT_CAPACITY",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "/**\n * The default capacity to use\n */\nprotected static final int DEFAULT_CAPACITY = 16;"
            ],
            [
                "DEFAULT_THRESHOLD",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "/**\n * The default threshold to use\n */\nprotected static final int DEFAULT_THRESHOLD = 12;"
            ],
            [
                "DEFAULT_LOAD_FACTOR",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "/**\n * The default load factor to use\n */\nprotected static final float DEFAULT_LOAD_FACTOR = 0.75f;"
            ],
            [
                "MAXIMUM_CAPACITY",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "/**\n * The maximum capacity allowed\n */\nprotected static final int MAXIMUM_CAPACITY = 1 << 30;"
            ],
            [
                "NULL",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "/**\n * An object for masking null\n */\nprotected static final Object NULL = new Object();"
            ],
            [
                "DEFAULT_MAX_SIZE",
                "org.apache.commons.collections4.map",
                "LRUMap",
                "/**\n * Default maximum size\n */\nprotected static final int DEFAULT_MAX_SIZE = 100;"
            ],
            [
                "EMPTY_MULTISET",
                "org.apache.commons.collections4",
                "MultiSetUtils",
                "/**\n * An empty unmodifiable multiset.\n */\n// OK, empty multiset is compatible with any type\n@SuppressWarnings(\"rawtypes\")\npublic static final MultiSet EMPTY_MULTISET = UnmodifiableMultiSet.unmodifiableMultiSet(new HashMultiSet<Object>());"
            ],
            [
                "EMPTY_SORTED_SET",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * An empty unmodifiable sorted set.\n * This is not provided in the JDK.\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final SortedSet EMPTY_SORTED_SET = UnmodifiableSortedSet.unmodifiableSortedSet(new TreeSet<Object>());"
            ],
            [
                "EMPTY_QUEUE",
                "org.apache.commons.collections4",
                "QueueUtils",
                "/**\n * An empty unmodifiable queue.\n */\n// OK, empty queue is compatible with any type\n@SuppressWarnings(\"rawtypes\")\npublic static final Queue EMPTY_QUEUE = UnmodifiableQueue.unmodifiableQueue(new LinkedList<Object>());"
            ],
            [
                "EMPTY_BAG",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * An empty unmodifiable bag.\n */\n// OK, empty bag is compatible with any type\n@SuppressWarnings(\"rawtypes\")\npublic static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());"
            ],
            [
                "EMPTY_SORTED_BAG",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * An empty unmodifiable sorted bag.\n */\n// OK, empty bag is compatible with any type\n@SuppressWarnings(\"rawtypes\")\npublic static final Bag EMPTY_SORTED_BAG = UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());"
            ],
            [
                "RESETTABLE_INSTANCE",
                "org.apache.commons.collections4.iterators",
                "EmptyListIterator",
                "/**\n * Singleton instance of the iterator.\n * @since 3.1\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final ResettableListIterator RESETTABLE_INSTANCE = new EmptyListIterator<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.iterators",
                "EmptyListIterator",
                "/**\n * Singleton instance of the iterator.\n * @since 2.1.1 and 3.1\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final ListIterator INSTANCE = RESETTABLE_INSTANCE;"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.iterators",
                "EmptyMapIterator",
                "/**\n * Singleton instance of the iterator.\n * @since 3.1\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final MapIterator INSTANCE = new EmptyMapIterator<Object, Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.iterators",
                "EmptyOrderedIterator",
                "/**\n * Singleton instance of the iterator.\n * @since 3.1\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final OrderedIterator INSTANCE = new EmptyOrderedIterator<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.iterators",
                "EmptyOrderedMapIterator",
                "/**\n * Singleton instance of the iterator.\n * @since 3.1\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final OrderedMapIterator INSTANCE = new EmptyOrderedMapIterator<Object, Object>();"
            ],
            [
                "RESETTABLE_INSTANCE",
                "org.apache.commons.collections4.iterators",
                "EmptyIterator",
                "/**\n * Singleton instance of the iterator.\n * @since 3.1\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final ResettableIterator RESETTABLE_INSTANCE = new EmptyIterator<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.iterators",
                "EmptyIterator",
                "/**\n * Singleton instance of the iterator.\n * @since 2.1.1 and 3.1\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final Iterator INSTANCE = RESETTABLE_INSTANCE;"
            ]
        ],
        "tokensMethodJavadocValues": [
            [
                "4",
                "int"
            ]
        ],
        "tokensMethodArguments": [
            [
                "classToInstantiate",
                "java.lang.Class",
                "Class<T>"
            ],
            [
                "paramTypes",
                "",
                "Class<?>[]"
            ],
            [
                "args",
                "",
                "Object[]"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "arrayType",
                "java.lang",
                "Class",
                "public Class<? extends Object> arrayType()"
            ],
            [
                "describeConstable",
                "java.lang",
                "Class",
                "public Optional<ClassDesc> describeConstable()"
            ],
            [
                "getSigners",
                "java.lang",
                "Class",
                "public native Object[] getSigners()"
            ],
            [
                "isInterface",
                "java.lang",
                "Class",
                "public native boolean isInterface()"
            ],
            [
                "getSuperclass",
                "java.lang",
                "Class",
                "public native Class<? super T> getSuperclass()"
            ],
            [
                "descriptorString",
                "java.lang",
                "Class",
                "public String descriptorString()"
            ],
            [
                "isPrimitive",
                "java.lang",
                "Class",
                "public native boolean isPrimitive()"
            ],
            [
                "getDeclaredConstructor",
                "java.lang",
                "Class",
                "public Constructor<T> getDeclaredConstructor(Class<? extends Object>[] arg0) throws NoSuchMethodException, SecurityException"
            ],
            [
                "getDeclaringClass",
                "java.lang",
                "Class",
                "public Class<? extends Object> getDeclaringClass() throws SecurityException"
            ],
            [
                "getName",
                "java.lang",
                "Class",
                "public String getName()"
            ],
            [
                "isMemberClass",
                "java.lang",
                "Class",
                "public boolean isMemberClass()"
            ],
            [
                "getEnclosingMethod",
                "java.lang",
                "Class",
                "public Method getEnclosingMethod() throws SecurityException"
            ],
            [
                "getNestHost",
                "java.lang",
                "Class",
                "public Class<? extends Object> getNestHost()"
            ],
            [
                "getEnumConstants",
                "java.lang",
                "Class",
                "public T[] getEnumConstants()"
            ],
            [
                "isInstance",
                "java.lang",
                "Class",
                "public native boolean isInstance(Object arg0)"
            ],
            [
                "getCanonicalName",
                "java.lang",
                "Class",
                "public String getCanonicalName()"
            ],
            [
                "getAnnotations",
                "java.lang",
                "Class",
                "public Annotation[] getAnnotations()"
            ],
            [
                "getMethods",
                "java.lang",
                "Class",
                "public Method[] getMethods() throws SecurityException"
            ],
            [
                "getPackageName",
                "java.lang",
                "Class",
                "public String getPackageName()"
            ],
            [
                "getTypeName",
                "java.lang",
                "Class",
                "public String getTypeName()"
            ],
            [
                "isEnum",
                "java.lang",
                "Class",
                "public boolean isEnum()"
            ],
            [
                "getGenericInterfaces",
                "java.lang",
                "Class",
                "public Type[] getGenericInterfaces()"
            ],
            [
                "isAnonymousClass",
                "java.lang",
                "Class",
                "public boolean isAnonymousClass()"
            ],
            [
                "getDeclaredConstructors",
                "java.lang",
                "Class",
                "public Constructor<? extends Object>[] getDeclaredConstructors() throws SecurityException"
            ],
            [
                "toString",
                "java.lang",
                "Class",
                "public String toString()"
            ],
            [
                "toGenericString",
                "java.lang",
                "Class",
                "public String toGenericString()"
            ],
            [
                "getDeclaredAnnotation",
                "java.lang",
                "Class",
                "public <A> A getDeclaredAnnotation(Class<A> arg0)"
            ],
            [
                "getModifiers",
                "java.lang",
                "Class",
                "public native int getModifiers()"
            ],
            [
                "isRecord",
                "java.lang",
                "Class",
                "public boolean isRecord()"
            ],
            [
                "isLocalClass",
                "java.lang",
                "Class",
                "public boolean isLocalClass()"
            ],
            [
                "getDeclaredPublicMethods",
                "java.lang",
                "Class",
                "List<Method> getDeclaredPublicMethods(String arg0, Class<? extends Object>[] arg1)"
            ],
            [
                "getResource",
                "java.lang",
                "Class",
                "public URL getResource(String arg0)"
            ],
            [
                "getAnnotationsByType",
                "java.lang",
                "Class",
                "public <A> A[] getAnnotationsByType(Class<A> arg0)"
            ],
            [
                "getClasses",
                "java.lang",
                "Class",
                "public Class<? extends Object>[] getClasses()"
            ],
            [
                "getField",
                "java.lang",
                "Class",
                "public Field getField(String arg0) throws NoSuchFieldException, SecurityException"
            ],
            [
                "isNestmateOf",
                "java.lang",
                "Class",
                "public boolean isNestmateOf(Class<? extends Object> arg0)"
            ],
            [
                "getProtectionDomain",
                "java.lang",
                "Class",
                "public ProtectionDomain getProtectionDomain()"
            ],
            [
                "getConstructors",
                "java.lang",
                "Class",
                "public Constructor<? extends Object>[] getConstructors() throws SecurityException"
            ],
            [
                "getDeclaredAnnotationMap",
                "java.lang",
                "Class",
                "Map<Class<? extends Annotation>, Annotation> getDeclaredAnnotationMap()"
            ],
            [
                "getGenericSuperclass",
                "java.lang",
                "Class",
                "public Type getGenericSuperclass()"
            ],
            [
                "getEnumConstantsShared",
                "java.lang",
                "Class",
                "T[] getEnumConstantsShared()"
            ],
            [
                "isAnnotationPresent",
                "java.lang",
                "Class",
                "public boolean isAnnotationPresent(Class<? extends Annotation> arg0)"
            ],
            [
                "getDeclaredAnnotations",
                "java.lang",
                "Class",
                "public Annotation[] getDeclaredAnnotations()"
            ],
            [
                "getFields",
                "java.lang",
                "Class",
                "public Field[] getFields() throws SecurityException"
            ],
            [
                "getConstantPool",
                "java.lang",
                "Class",
                "native ConstantPool getConstantPool()"
            ],
            [
                "getComponentType",
                "java.lang",
                "Class",
                "public Class<? extends Object> getComponentType()"
            ],
            [
                "getDeclaredClasses",
                "java.lang",
                "Class",
                "public Class<? extends Object>[] getDeclaredClasses() throws SecurityException"
            ],
            [
                "enumConstantDirectory",
                "java.lang",
                "Class",
                "Map<String, T> enumConstantDirectory()"
            ],
            [
                "getDeclaredAnnotationsByType",
                "java.lang",
                "Class",
                "public <A> A[] getDeclaredAnnotationsByType(Class<A> arg0)"
            ],
            [
                "getDeclaredFields",
                "java.lang",
                "Class",
                "public Field[] getDeclaredFields() throws SecurityException"
            ],
            [
                "getAnnotationType",
                "java.lang",
                "Class",
                "AnnotationType getAnnotationType()"
            ],
            [
                "cast",
                "java.lang",
                "Class",
                "public T cast(Object arg0)"
            ],
            [
                "isSynthetic",
                "java.lang",
                "Class",
                "public boolean isSynthetic()"
            ],
            [
                "asSubclass",
                "java.lang",
                "Class",
                "public <U> Class<? extends U> asSubclass(Class<U> arg0)"
            ],
            [
                "getEnclosingConstructor",
                "java.lang",
                "Class",
                "public Constructor<? extends Object> getEnclosingConstructor() throws SecurityException"
            ],
            [
                "getDeclaredField",
                "java.lang",
                "Class",
                "public Field getDeclaredField(String arg0) throws NoSuchFieldException, SecurityException"
            ],
            [
                "componentType",
                "java.lang",
                "Class",
                "public Class<? extends Object> componentType()"
            ],
            [
                "isSealed",
                "java.lang",
                "Class",
                "public boolean isSealed()"
            ],
            [
                "desiredAssertionStatus",
                "java.lang",
                "Class",
                "public boolean desiredAssertionStatus()"
            ],
            [
                "isAnnotation",
                "java.lang",
                "Class",
                "public boolean isAnnotation()"
            ],
            [
                "getRawTypeAnnotations",
                "java.lang",
                "Class",
                "native byte[] getRawTypeAnnotations()"
            ],
            [
                "getDeclaredMethods",
                "java.lang",
                "Class",
                "public Method[] getDeclaredMethods() throws SecurityException"
            ],
            [
                "getRawAnnotations",
                "java.lang",
                "Class",
                "native byte[] getRawAnnotations()"
            ],
            [
                "getPermittedSubclasses",
                "java.lang",
                "Class",
                "public Class<? extends Object>[] getPermittedSubclasses()"
            ],
            [
                "getEnclosingClass",
                "java.lang",
                "Class",
                "public Class<? extends Object> getEnclosingClass() throws SecurityException"
            ],
            [
                "getAnnotation",
                "java.lang",
                "Class",
                "public <A> A getAnnotation(Class<A> arg0)"
            ],
            [
                "getRecordComponents",
                "java.lang",
                "Class",
                "public RecordComponent[] getRecordComponents()"
            ],
            [
                "getNestMembers",
                "java.lang",
                "Class",
                "public Class<? extends Object>[] getNestMembers()"
            ],
            [
                "getClassLoader0",
                "java.lang",
                "Class",
                "ClassLoader getClassLoader0()"
            ],
            [
                "getAnnotatedInterfaces",
                "java.lang",
                "Class",
                "public AnnotatedType[] getAnnotatedInterfaces()"
            ],
            [
                "getClassLoader",
                "java.lang",
                "Class",
                "public ClassLoader getClassLoader()"
            ],
            [
                "protectionDomain",
                "java.lang",
                "Class",
                "ProtectionDomain protectionDomain()"
            ],
            [
                "getDeclaredMethod",
                "java.lang",
                "Class",
                "public Method getDeclaredMethod(String arg0, Class<? extends Object>[] arg1) throws NoSuchMethodException, SecurityException"
            ],
            [
                "isArray",
                "java.lang",
                "Class",
                "public native boolean isArray()"
            ],
            [
                "getMethod",
                "java.lang",
                "Class",
                "public Method getMethod(String arg0, Class<? extends Object>[] arg1) throws NoSuchMethodException, SecurityException"
            ],
            [
                "getPackage",
                "java.lang",
                "Class",
                "public Package getPackage()"
            ],
            [
                "newInstance",
                "java.lang",
                "Class",
                "public T newInstance() throws InstantiationException, IllegalAccessException"
            ],
            [
                "getResourceAsStream",
                "java.lang",
                "Class",
                "public InputStream getResourceAsStream(String arg0)"
            ],
            [
                "getClassData",
                "java.lang",
                "Class",
                "Object getClassData()"
            ],
            [
                "getConstructor",
                "java.lang",
                "Class",
                "public Constructor<T> getConstructor(Class<? extends Object>[] arg0) throws NoSuchMethodException, SecurityException"
            ],
            [
                "getAnnotatedSuperclass",
                "java.lang",
                "Class",
                "public AnnotatedType getAnnotatedSuperclass()"
            ],
            [
                "getSimpleName",
                "java.lang",
                "Class",
                "public String getSimpleName()"
            ],
            [
                "casAnnotationType",
                "java.lang",
                "Class",
                "boolean casAnnotationType(AnnotationType arg0, AnnotationType arg1)"
            ],
            [
                "getModule",
                "java.lang",
                "Class",
                "public Module getModule()"
            ],
            [
                "isAssignableFrom",
                "java.lang",
                "Class",
                "public native boolean isAssignableFrom(Class<? extends Object> arg0)"
            ],
            [
                "isHidden",
                "java.lang",
                "Class",
                "public native boolean isHidden()"
            ],
            [
                "getTypeParameters",
                "java.lang",
                "Class",
                "public TypeVariable<Class<T>>[] getTypeParameters()"
            ],
            [
                "getInterfaces",
                "java.lang",
                "Class",
                "public Class<? extends Object>[] getInterfaces()"
            ],
            [
                "getTypeParameters",
                "java.lang.reflect",
                "GenericDeclaration",
                "public abstract TypeVariable<? extends Object>[] getTypeParameters()"
            ],
            [
                "getAnnotations",
                "java.lang.reflect",
                "AnnotatedElement",
                "public abstract Annotation[] getAnnotations()"
            ],
            [
                "getDeclaredAnnotationsByType",
                "java.lang.reflect",
                "AnnotatedElement",
                "public default <T> T[] getDeclaredAnnotationsByType(Class<T> arg0)"
            ],
            [
                "getDeclaredAnnotation",
                "java.lang.reflect",
                "AnnotatedElement",
                "public default <T> T getDeclaredAnnotation(Class<T> arg0)"
            ],
            [
                "getAnnotation",
                "java.lang.reflect",
                "AnnotatedElement",
                "public abstract <T> T getAnnotation(Class<T> arg0)"
            ],
            [
                "isAnnotationPresent",
                "java.lang.reflect",
                "AnnotatedElement",
                "public default boolean isAnnotationPresent(Class<? extends Annotation> arg0)"
            ],
            [
                "getAnnotationsByType",
                "java.lang.reflect",
                "AnnotatedElement",
                "public default <T> T[] getAnnotationsByType(Class<T> arg0)"
            ],
            [
                "getDeclaredAnnotations",
                "java.lang.reflect",
                "AnnotatedElement",
                "public abstract Annotation[] getDeclaredAnnotations()"
            ],
            [
                "getTypeName",
                "java.lang.reflect",
                "Type",
                "public default String getTypeName()"
            ],
            [
                "arrayType",
                "java.lang.invoke",
                "TypeDescriptor.OfField",
                "public abstract F arrayType()"
            ],
            [
                "componentType",
                "java.lang.invoke",
                "TypeDescriptor.OfField",
                "public abstract F componentType()"
            ],
            [
                "isPrimitive",
                "java.lang.invoke",
                "TypeDescriptor.OfField",
                "public abstract boolean isPrimitive()"
            ],
            [
                "isArray",
                "java.lang.invoke",
                "TypeDescriptor.OfField",
                "public abstract boolean isArray()"
            ],
            [
                "descriptorString",
                "java.lang.invoke",
                "TypeDescriptor",
                "public abstract String descriptorString()"
            ],
            [
                "describeConstable",
                "java.lang.constant",
                "Constable",
                "public abstract Optional<? extends ConstantDesc> describeConstable()"
            ],
            [
                "equals",
                "",
                "java.lang.Class<?>[]",
                "public boolean equals(Object);"
            ],
            [
                "toString",
                "",
                "java.lang.Class<?>[]",
                "public String toString()"
            ],
            [
                "hashCode",
                "",
                "java.lang.Class<?>[]",
                "public native int hashCode()"
            ],
            [
                "getClass",
                "",
                "java.lang.Class<?>[]",
                "public final native Class getClass();"
            ],
            [
                "clone",
                "",
                "java.lang.Class<?>[]",
                "public T[] clone();"
            ],
            [
                "equals",
                "",
                "java.lang.Object[]",
                "public boolean equals(Object);"
            ],
            [
                "toString",
                "",
                "java.lang.Object[]",
                "public String toString()"
            ],
            [
                "hashCode",
                "",
                "java.lang.Object[]",
                "public native int hashCode()"
            ],
            [
                "getClass",
                "",
                "java.lang.Object[]",
                "public final native Class getClass();"
            ],
            [
                "clone",
                "",
                "java.lang.Object[]",
                "public T[] clone();"
            ],
            [
                "create",
                "org.apache.commons.collections4",
                "Factory",
                "public abstract T create()"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [
            [
                "classValueMap",
                "java.lang",
                "Class",
                "transient ClassValue.ClassValueMap classValueMap;"
            ],
            [
                "length",
                "java.lang",
                "Class[]",
                "public final int length;"
            ],
            [
                "length",
                "java.lang",
                "Object[]",
                "public final int length;"
            ]
        ],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 6398,
        "oracle": ";",
        "oracleType": "PRE",
        "projectName": "commons-collections4-4.1",
        "packageName": "org.apache.commons.collections4",
        "className": "ListUtils",
        "javadocTag": "@param <T> the element type",
        "methodJavadoc": "    /**\n     * Returns either the passed in list, or if the list is {@code null},\n     * the value of {@code defaultList}.\n     *\n     * @param <T> the element type\n     * @param list  the list, possibly {@code null}\n     * @param defaultList  the returned values if list is {@code null}\n     * @return an empty list if the argument is <code>null</code>\n     * @since 4.0\n     */",
        "methodSourceCode": "public static <T> List<T> defaultIfNull(final List<T> list, final List<T> defaultList){\n    return list == null ? defaultList : list;\n}",
        "classJavadoc": "/**\n * Provides utility methods and decorators for {@link List} instances.\n *\n * @since 1.0\n * @version $Id: ListUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */",
        "classSourceCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport java.util.AbstractList;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.functors.DefaultEquator;\nimport org.apache.commons.collections4.list.FixedSizeList;\nimport org.apache.commons.collections4.list.LazyList;\nimport org.apache.commons.collections4.list.PredicatedList;\nimport org.apache.commons.collections4.list.TransformedList;\nimport org.apache.commons.collections4.list.UnmodifiableList;\nimport org.apache.commons.collections4.sequence.CommandVisitor;\nimport org.apache.commons.collections4.sequence.EditScript;\nimport org.apache.commons.collections4.sequence.SequencesComparator;\n\n/**\n * Provides utility methods and decorators for {@link List} instances.\n *\n * @since 1.0\n * @version $Id: ListUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class ListUtils {\n\n    /**\n     * <code>ListUtils</code> should not normally be instantiated.\n     */\n    private ListUtils() {}\n\n    //-----------------------------------------------------------------------\n\n    /**\n     * Returns an immutable empty list if the argument is <code>null</code>,\n     * or the argument itself otherwise.\n     *\n     * @param <T> the element type\n     * @param list the list, possibly <code>null</code>\n     * @return an empty list if the argument is <code>null</code>\n     */\n    public static <T> List<T> emptyIfNull(final List<T> list) {\n        return list == null ? Collections.<T>emptyList() : list;\n    }\n\n    /**\n     * Returns either the passed in list, or if the list is {@code null},\n     * the value of {@code defaultList}.\n     *\n     * @param <T> the element type\n     * @param list  the list, possibly {@code null}\n     * @param defaultList  the returned values if list is {@code null}\n     * @return an empty list if the argument is <code>null</code>\n     * @since 4.0\n     */\n    public static <T> List<T> defaultIfNull(final List<T> list, final List<T> defaultList) {\n        return list == null ? defaultList : list;\n    }\n\n    /**\n     * Returns a new list containing all elements that are contained in\n     * both given lists.\n     *\n     * @param <E> the element type\n     * @param list1  the first list\n     * @param list2  the second list\n     * @return  the intersection of those two lists\n     * @throws NullPointerException if either list is null\n     */\n    public static <E> List<E> intersection(final List<? extends E> list1, final List<? extends E> list2) {\n        final List<E> result = new ArrayList<E>();\n\n        List<? extends E> smaller = list1;\n        List<? extends E> larger = list2;\n        if (list1.size() > list2.size()) {\n            smaller = list2;\n            larger = list1;\n        }\n\n        final HashSet<E> hashSet = new HashSet<E>(smaller);\n\n        for (final E e : larger) {\n            if (hashSet.contains(e)) {\n                result.add(e);\n                hashSet.remove(e);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Subtracts all elements in the second list from the first list,\n     * placing the results in a new list.\n     * <p>\n     * This differs from {@link List#removeAll(Collection)} in that\n     * cardinality is respected; if <Code>list1</Code> contains two\n     * occurrences of <Code>null</Code> and <Code>list2</Code> only\n     * contains one occurrence, then the returned list will still contain\n     * one occurrence.\n     *\n     * @param <E> the element type\n     * @param list1  the list to subtract from\n     * @param list2  the list to subtract\n     * @return a new list containing the results\n     * @throws NullPointerException if either list is null\n     */\n    public static <E> List<E> subtract(final List<E> list1, final List<? extends E> list2) {\n        final ArrayList<E> result = new ArrayList<E>();\n        final HashBag<E> bag = new HashBag<E>(list2);\n        for (final E e : list1) {\n            if (!bag.remove(e, 1)) {\n                result.add(e);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the sum of the given lists.  This is their intersection\n     * subtracted from their union.\n     *\n     * @param <E> the element type\n     * @param list1  the first list\n     * @param list2  the second list\n     * @return  a new list containing the sum of those lists\n     * @throws NullPointerException if either list is null\n     */\n    public static <E> List<E> sum(final List<? extends E> list1, final List<? extends E> list2) {\n        return subtract(union(list1, list2), intersection(list1, list2));\n    }\n\n    /**\n     * Returns a new list containing the second list appended to the\n     * first list.  The {@link List#addAll(Collection)} operation is\n     * used to append the two given lists into a new list.\n     *\n     * @param <E> the element type\n     * @param list1  the first list\n     * @param list2  the second list\n     * @return a new list containing the union of those lists\n     * @throws NullPointerException if either list is null\n     */\n    public static <E> List<E> union(final List<? extends E> list1, final List<? extends E> list2) {\n        final ArrayList<E> result = new ArrayList<E>(list1);\n        result.addAll(list2);\n        return result;\n    }\n\n    /**\n     * Selects all elements from input collection which match the given\n     * predicate into an output list.\n     * <p>\n     * A <code>null</code> predicate matches no elements.\n     *\n     * @param <E> the element type\n     * @param inputCollection  the collection to get the input from, may not be null\n     * @param predicate  the predicate to use, may be null\n     * @return the elements matching the predicate (new list)\n     * @throws NullPointerException if the input list is null\n     *\n     * @since 4.0\n     * @see CollectionUtils#select(Iterable, Predicate)\n     */\n    public static <E> List<E> select(final Collection<? extends E> inputCollection,\n            final Predicate<? super E> predicate) {\n        return CollectionUtils.select(inputCollection, predicate, new ArrayList<E>(inputCollection.size()));\n    }\n\n    /**\n     * Selects all elements from inputCollection which don't match the given\n     * predicate into an output collection.\n     * <p>\n     * If the input predicate is <code>null</code>, the result is an empty list.\n     *\n     * @param <E> the element type\n     * @param inputCollection the collection to get the input from, may not be null\n     * @param predicate the predicate to use, may be null\n     * @return the elements <b>not</b> matching the predicate (new list)\n     * @throws NullPointerException if the input collection is null\n     *\n     * @since 4.0\n     * @see CollectionUtils#selectRejected(Iterable, Predicate)\n     */\n    public static <E> List<E> selectRejected(final Collection<? extends E> inputCollection,\n            final Predicate<? super E> predicate) {\n        return CollectionUtils.selectRejected(inputCollection, predicate, new ArrayList<E>(inputCollection.size()));\n    }\n\n    /**\n     * Tests two lists for value-equality as per the equality contract in\n     * {@link java.util.List#equals(java.lang.Object)}.\n     * <p>\n     * This method is useful for implementing <code>List</code> when you cannot\n     * extend AbstractList. The method takes Collection instances to enable other\n     * collection types to use the List implementation algorithm.\n     * <p>\n     * The relevant text (slightly paraphrased as this is a static method) is:\n     * <blockquote>\n     * Compares the two list objects for equality.  Returns\n     * {@code true} if and only if both\n     * lists have the same size, and all corresponding pairs of elements in\n     * the two lists are <i>equal</i>.  (Two elements {@code e1} and\n     * {@code e2} are <i>equal</i> if <tt>(e1==null ? e2==null :\n     * e1.equals(e2))</tt>.)  In other words, two lists are defined to be\n     * equal if they contain the same elements in the same order.  This\n     * definition ensures that the equals method works properly across\n     * different implementations of the {@code List} interface.\n     * </blockquote>\n     *\n     * <b>Note:</b> The behaviour of this method is undefined if the lists are\n     * modified during the equals comparison.\n     *\n     * @see java.util.List\n     * @param list1  the first list, may be null\n     * @param list2  the second list, may be null\n     * @return whether the lists are equal by value comparison\n     */\n    public static boolean isEqualList(final Collection<?> list1, final Collection<?> list2) {\n        if (list1 == list2) {\n            return true;\n        }\n        if (list1 == null || list2 == null || list1.size() != list2.size()) {\n            return false;\n        }\n\n        final Iterator<?> it1 = list1.iterator();\n        final Iterator<?> it2 = list2.iterator();\n        Object obj1 = null;\n        Object obj2 = null;\n\n        while (it1.hasNext() && it2.hasNext()) {\n            obj1 = it1.next();\n            obj2 = it2.next();\n\n            if (!(obj1 == null ? obj2 == null : obj1.equals(obj2))) {\n                return false;\n            }\n        }\n\n        return !(it1.hasNext() || it2.hasNext());\n    }\n\n    /**\n     * Generates a hash code using the algorithm specified in\n     * {@link java.util.List#hashCode()}.\n     * <p>\n     * This method is useful for implementing <code>List</code> when you cannot\n     * extend AbstractList. The method takes Collection instances to enable other\n     * collection types to use the List implementation algorithm.\n     *\n     * @see java.util.List#hashCode()\n     * @param list  the list to generate the hashCode for, may be null\n     * @return the hash code\n     */\n    public static int hashCodeForList(final Collection<?> list) {\n        if (list == null) {\n            return 0;\n        }\n        int hashCode = 1;\n        final Iterator<?> it = list.iterator();\n\n        while (it.hasNext()) {\n            final Object obj = it.next();\n            hashCode = 31 * hashCode + (obj == null ? 0 : obj.hashCode());\n        }\n        return hashCode;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a List containing all the elements in <code>collection</code>\n     * that are also in <code>retain</code>. The cardinality of an element <code>e</code>\n     * in the returned list is the same as the cardinality of <code>e</code>\n     * in <code>collection</code> unless <code>retain</code> does not contain <code>e</code>, in which\n     * case the cardinality is zero. This method is useful if you do not wish to modify\n     * the collection <code>c</code> and thus cannot call <code>collection.retainAll(retain);</code>.\n     * <p>\n     * This implementation iterates over <code>collection</code>, checking each element in\n     * turn to see if it's contained in <code>retain</code>. If it's contained, it's added\n     * to the returned list. As a consequence, it is advised to use a collection type for\n     * <code>retain</code> that provides a fast (e.g. O(1)) implementation of\n     * {@link Collection#contains(Object)}.\n     *\n     * @param <E>  the element type\n     * @param collection  the collection whose contents are the target of the #retailAll operation\n     * @param retain  the collection containing the elements to be retained in the returned collection\n     * @return a <code>List</code> containing all the elements of <code>c</code>\n     * that occur at least once in <code>retain</code>.\n     * @throws NullPointerException if either parameter is null\n     * @since 3.2\n     */\n    public static <E> List<E> retainAll(final Collection<E> collection, final Collection<?> retain) {\n        final List<E> list = new ArrayList<E>(Math.min(collection.size(), retain.size()));\n\n        for (final E obj : collection) {\n            if (retain.contains(obj)) {\n                list.add(obj);\n            }\n        }\n        return list;\n    }\n\n    /**\n     * Removes the elements in <code>remove</code> from <code>collection</code>. That is, this\n     * method returns a list containing all the elements in <code>collection</code>\n     * that are not in <code>remove</code>. The cardinality of an element <code>e</code>\n     * in the returned collection is the same as the cardinality of <code>e</code>\n     * in <code>collection</code> unless <code>remove</code> contains <code>e</code>, in which\n     * case the cardinality is zero. This method is useful if you do not wish to modify\n     * <code>collection</code> and thus cannot call <code>collection.removeAll(remove);</code>.\n     * <p>\n     * This implementation iterates over <code>collection</code>, checking each element in\n     * turn to see if it's contained in <code>remove</code>. If it's not contained, it's added\n     * to the returned list. As a consequence, it is advised to use a collection type for\n     * <code>remove</code> that provides a fast (e.g. O(1)) implementation of\n     * {@link Collection#contains(Object)}.\n     *\n     * @param <E>  the element type\n     * @param collection  the collection from which items are removed (in the returned collection)\n     * @param remove  the items to be removed from the returned <code>collection</code>\n     * @return a <code>List</code> containing all the elements of <code>c</code> except\n     * any elements that also occur in <code>remove</code>.\n     * @throws NullPointerException if either parameter is null\n     * @since 3.2\n     */\n    public static <E> List<E> removeAll(final Collection<E> collection, final Collection<?> remove) {\n        final List<E> list = new ArrayList<E>();\n        for (final E obj : collection) {\n            if (!remove.contains(obj)) {\n                list.add(obj);\n            }\n        }\n        return list;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized list backed by the given list.\n     * <p>\n     * You must manually synchronize on the returned list's iterator to\n     * avoid non-deterministic behavior:\n     *\n     * <pre>\n     * List list = ListUtils.synchronizedList(myList);\n     * synchronized (list) {\n     *     Iterator i = list.iterator();\n     *     while (i.hasNext()) {\n     *         process (i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * This method is just a wrapper for {@link Collections#synchronizedList(List)}.\n     *\n     * @param <E> the element type\n     * @param list  the list to synchronize, must not be null\n     * @return a synchronized list backed by the given list\n     * @throws NullPointerException if the list is null\n     */\n    public static <E> List<E> synchronizedList(final List<E> list) {\n        return Collections.synchronizedList(list);\n    }\n\n    /**\n     * Returns an unmodifiable list backed by the given list.\n     * <p>\n     * This method uses the implementation in the decorators subpackage.\n     *\n     * @param <E>  the element type\n     * @param list  the list to make unmodifiable, must not be null\n     * @return an unmodifiable list backed by the given list\n     * @throws NullPointerException if the list is null\n     */\n    public static <E> List<E> unmodifiableList(final List<? extends E> list) {\n        return UnmodifiableList.unmodifiableList(list);\n    }\n\n    /**\n     * Returns a predicated (validating) list backed by the given list.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to the list.\n     * Trying to add an invalid object results in an IllegalArgumentException.\n     * It is important not to use the original list after invoking this method,\n     * as it is a backdoor for adding invalid objects.\n     *\n     * @param <E> the element type\n     * @param list  the list to predicate, must not be null\n     * @param predicate  the predicate for the list, must not be null\n     * @return a predicated list backed by the given list\n     * @throws NullPointerException if the List or Predicate is null\n     */\n    public static <E> List<E> predicatedList(final List<E> list, final Predicate<E> predicate) {\n        return PredicatedList.predicatedList(list, predicate);\n    }\n\n    /**\n     * Returns a transformed list backed by the given list.\n     * <p>\n     * This method returns a new list (decorating the specified list) that\n     * will transform any new entries added to it.\n     * Existing entries in the specified list will not be transformed.\n     * <p>\n     * Each object is passed through the transformer as it is added to the\n     * List. It is important not to use the original list after invoking this\n     * method, as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified list will not be transformed.\n     * If you want that behaviour, see {@link TransformedList#transformedList}.\n     *\n     * @param <E> the element type\n     * @param list  the list to predicate, must not be null\n     * @param transformer  the transformer for the list, must not be null\n     * @return a transformed list backed by the given list\n     * @throws NullPointerException if the List or Transformer is null\n     */\n    public static <E> List<E> transformedList(final List<E> list,\n                                              final Transformer<? super E, ? extends E> transformer) {\n        return TransformedList.transformingList(list, transformer);\n    }\n\n    /**\n     * Returns a \"lazy\" list whose elements will be created on demand.\n     * <p>\n     * When the index passed to the returned list's {@link List#get(int) get}\n     * method is greater than the list's size, then the factory will be used\n     * to create a new object and that object will be inserted at that index.\n     * <p>\n     * For instance:\n     *\n     * <pre>\n     * Factory&lt;Date&gt; factory = new Factory&lt;Date&gt;() {\n     *     public Date create() {\n     *         return new Date();\n     *     }\n     * }\n     * List&lt;Date&gt; lazy = ListUtils.lazyList(new ArrayList&lt;Date&gt;(), factory);\n     * Date date = lazy.get(3);\n     * </pre>\n     *\n     * After the above code is executed, <code>date</code> will refer to\n     * a new <code>Date</code> instance.  Furthermore, that <code>Date</code>\n     * instance is the fourth element in the list.  The first, second,\n     * and third element are all set to <code>null</code>.\n     *\n     * @param <E> the element type\n     * @param list  the list to make lazy, must not be null\n     * @param factory  the factory for creating new objects, must not be null\n     * @return a lazy list backed by the given list\n     * @throws NullPointerException if the List or Factory is null\n     */\n    public static <E> List<E> lazyList(final List<E> list, final Factory<? extends E> factory) {\n        return LazyList.lazyList(list, factory);\n    }\n\n    /**\n     * Returns a fixed-sized list backed by the given list.\n     * Elements may not be added or removed from the returned list, but\n     * existing elements can be changed (for instance, via the\n     * {@link List#set(int, Object)} method).\n     *\n     * @param <E>  the element type\n     * @param list  the list whose size to fix, must not be null\n     * @return a fixed-size list backed by that list\n     * @throws NullPointerException  if the List is null\n     */\n    public static <E> List<E> fixedSizeList(final List<E> list) {\n        return FixedSizeList.fixedSizeList(list);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Finds the first index in the given List which matches the given predicate.\n     * <p>\n     * If the input List or predicate is null, or no element of the List\n     * matches the predicate, -1 is returned.\n     *\n     * @param <E>  the element type\n     * @param list the List to search, may be null\n     * @param predicate  the predicate to use, may be null\n     * @return the first index of an Object in the List which matches the predicate or -1 if none could be found\n     */\n    public static <E> int indexOf(final List<E> list, final Predicate<E> predicate) {\n        if (list != null && predicate != null) {\n            for (int i = 0; i < list.size(); i++) {\n                final E item = list.get(i);\n                if (predicate.evaluate(item)) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns the longest common subsequence (LCS) of two sequences (lists).\n     *\n     * @param <E>  the element type\n     * @param a  the first list\n     * @param b  the second list\n     * @return the longest common subsequence\n     * @throws NullPointerException if either list is {@code null}\n     * @since 4.0\n     */\n    public static <E> List<E> longestCommonSubsequence(final List<E> a, final List<E> b) {\n      return longestCommonSubsequence( a, b, DefaultEquator.defaultEquator() );\n    }\n\n    /**\n     * Returns the longest common subsequence (LCS) of two sequences (lists).\n     *\n     * @param <E>  the element type\n     * @param a  the first list\n     * @param b  the second list\n     * @param equator  the equator used to test object equality\n     * @return the longest common subsequence\n     * @throws NullPointerException if either list or the equator is {@code null}\n     * @since 4.0\n     */\n    public static <E> List<E> longestCommonSubsequence(final List<E> a, final List<E> b,\n                                                       final Equator<? super E> equator) {\n        if (a == null || b == null) {\n            throw new NullPointerException(\"List must not be null\");\n        }\n        if (equator == null) {\n          throw new NullPointerException(\"Equator must not be null\");\n        }\n\n        final SequencesComparator<E> comparator = new SequencesComparator<E>(a, b, equator);\n        final EditScript<E> script = comparator.getScript();\n        final LcsVisitor<E> visitor = new LcsVisitor<E>();\n        script.visit(visitor);\n        return visitor.getSubSequence();\n    }\n\n    /**\n     * Returns the longest common subsequence (LCS) of two {@link CharSequence} objects.\n     * <p>\n     * This is a convenience method for using {@link #longestCommonSubsequence(List, List)}\n     * with {@link CharSequence} instances.\n     *\n     * @param a  the first sequence\n     * @param b  the second sequence\n     * @return the longest common subsequence as {@link String}\n     * @throws NullPointerException if either sequence is {@code null}\n     * @since 4.0\n     */\n    public static String longestCommonSubsequence(final CharSequence a, final CharSequence b) {\n        if (a == null || b == null) {\n            throw new NullPointerException(\"CharSequence must not be null\");\n        }\n        final List<Character> lcs = longestCommonSubsequence(new CharSequenceAsList( a ), new CharSequenceAsList( b ));\n        final StringBuilder sb = new StringBuilder();\n        for ( Character ch : lcs ) {\n          sb.append(ch);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * A helper class used to construct the longest common subsequence.\n     */\n    private static final class LcsVisitor<E> implements CommandVisitor<E> {\n        private ArrayList<E> sequence;\n\n        public LcsVisitor() {\n            sequence = new ArrayList<E>();\n        }\n\n        public void visitInsertCommand(final E object) {}\n\n        public void visitDeleteCommand(final E object) {}\n\n        public void visitKeepCommand(final E object) {\n            sequence.add(object);\n        }\n\n        public List<E> getSubSequence() {\n            return sequence;\n        }\n    }\n\n    /**\n     * A simple wrapper to use a CharSequence as List.\n     */\n    private static final class CharSequenceAsList extends AbstractList<Character> {\n\n      private final CharSequence sequence;\n\n      public CharSequenceAsList(final CharSequence sequence) {\n        this.sequence = sequence;\n      }\n\n      @Override\n      public Character get( int index ) {\n        return Character.valueOf(sequence.charAt( index ));\n      }\n\n      @Override\n      public int size() {\n        return sequence.length();\n      }\n\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns consecutive {@link List#subList(int, int) sublists} of a\n     * list, each of the same size (the final list may be smaller). For example,\n     * partitioning a list containing {@code [a, b, c, d, e]} with a partition\n     * size of 3 yields {@code [[a, b, c], [d, e]]} -- an outer list containing\n     * two inner lists of three and two elements, all in the original order.\n     * <p>\n     * The outer list is unmodifiable, but reflects the latest state of the\n     * source list. The inner lists are sublist views of the original list,\n     * produced on demand using {@link List#subList(int, int)}, and are subject\n     * to all the usual caveats about modification as explained in that API.\n     * <p>\n     * Adapted from http://code.google.com/p/guava-libraries/\n     *\n     * @param <T> the element type\n     * @param list  the list to return consecutive sublists of\n     * @param size  the desired size of each sublist (the last may be smaller)\n     * @return a list of consecutive sublists\n     * @throws NullPointerException if list is null\n     * @throws IllegalArgumentException if size is not strictly positive\n     * @since 4.0\n     */\n    public static <T> List<List<T>> partition(final List<T> list, final int size) {\n        if (list == null) {\n            throw new NullPointerException(\"List must not be null\");\n        }\n        if (size <= 0) {\n            throw new IllegalArgumentException(\"Size must be greater than 0\");\n        }\n        return new Partition<T>(list, size);\n    }\n\n    /**\n     * Provides a partition view on a {@link List}.\n     * @since 4.0\n     */\n    private static class Partition<T> extends AbstractList<List<T>> {\n        private final List<T> list;\n        private final int size;\n\n        private Partition(final List<T> list, final int size) {\n            this.list = list;\n            this.size = size;\n        }\n\n        @Override\n        public List<T> get(final int index) {\n            final int listSize = size();\n            if (listSize < 0) {\n                throw new IllegalArgumentException(\"negative size: \" + listSize);\n            }\n            if (index < 0) {\n                throw new IndexOutOfBoundsException(\"Index \" + index + \" must not be negative\");\n            }\n            if (index >= listSize) {\n                throw new IndexOutOfBoundsException(\"Index \" + index + \" must be less than size \" +\n                                                    listSize);\n            }\n            final int start = index * size;\n            final int end = Math.min(start + size, list.size());\n            return list.subList(start, end);\n        }\n\n        @Override\n        public int size() {\n            return (list.size() + size - 1) / size;\n        }\n\n        @Override\n        public boolean isEmpty() {\n            return list.isEmpty();\n        }\n    }\n}\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "BidiMap",
                "org.apache.commons.collections4"
            ],
            [
                "Equator",
                "org.apache.commons.collections4"
            ],
            [
                "MultiSet",
                "org.apache.commons.collections4"
            ],
            [
                "IteratorUtils",
                "org.apache.commons.collections4"
            ],
            [
                "ComparatorUtils",
                "org.apache.commons.collections4"
            ],
            [
                "FunctorException",
                "org.apache.commons.collections4"
            ],
            [
                "AbstractDualBidiMap",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "UnmodifiableBidiMap",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "AbstractOrderedBidiMapDecorator",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "UnmodifiableOrderedBidiMap",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "AbstractBidiMapDecorator",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "DualLinkedHashBidiMap",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "UnmodifiableSortedBidiMap",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "AbstractSortedBidiMapDecorator",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "DualHashBidiMap",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "DualTreeBidiMap",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "TreeBidiMap",
                "org.apache.commons.collections4.bidimap"
            ],
            [
                "MultiMapUtils",
                "org.apache.commons.collections4"
            ],
            [
                "BoundedCollection",
                "org.apache.commons.collections4"
            ],
            [
                "UnmodifiableBoundedCollection",
                "org.apache.commons.collections4.collection"
            ],
            [
                "CompositeCollection",
                "org.apache.commons.collections4.collection"
            ],
            [
                "TransformedCollection",
                "org.apache.commons.collections4.collection"
            ],
            [
                "PredicatedCollection",
                "org.apache.commons.collections4.collection"
            ],
            [
                "IndexedCollection",
                "org.apache.commons.collections4.collection"
            ],
            [
                "SynchronizedCollection",
                "org.apache.commons.collections4.collection"
            ],
            [
                "UnmodifiableCollection",
                "org.apache.commons.collections4.collection"
            ],
            [
                "AbstractCollectionDecorator",
                "org.apache.commons.collections4.collection"
            ],
            [
                "OrderedBidiMap",
                "org.apache.commons.collections4"
            ],
            [
                "FactoryUtils",
                "org.apache.commons.collections4"
            ],
            [
                "IterableGet",
                "org.apache.commons.collections4"
            ],
            [
                "ListUtils",
                "org.apache.commons.collections4"
            ],
            [
                "Closure",
                "org.apache.commons.collections4"
            ],
            [
                "IterableSortedMap",
                "org.apache.commons.collections4"
            ],
            [
                "MapUtils",
                "org.apache.commons.collections4"
            ],
            [
                "Transformer",
                "org.apache.commons.collections4"
            ],
            [
                "DefaultEquator",
                "org.apache.commons.collections4.functors"
            ],
            [
                "StringValueTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "PredicateDecorator",
                "org.apache.commons.collections4.functors"
            ],
            [
                "IfTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "IdentityPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ExceptionClosure",
                "org.apache.commons.collections4.functors"
            ],
            [
                "NOPClosure",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ClosureTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "FunctorUtils",
                "org.apache.commons.collections4.functors"
            ],
            [
                "TransformerPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "NullPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ConstantTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "PredicateTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "WhileClosure",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ForClosure",
                "org.apache.commons.collections4.functors"
            ],
            [
                "NullIsTruePredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "TransformedPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "NonePredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ExceptionTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "SwitchTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "TransformerClosure",
                "org.apache.commons.collections4.functors"
            ],
            [
                "OrPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "NOPTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "MapTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ExceptionFactory",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ChainedClosure",
                "org.apache.commons.collections4.functors"
            ],
            [
                "AndPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "PrototypeFactory",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ExceptionPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "AbstractQuantifierPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "InstanceofPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "InvokerTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "FalsePredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "CloneTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "NotPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ConstantFactory",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ChainedTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ComparatorPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "CatchAndRethrowClosure",
                "org.apache.commons.collections4.functors"
            ],
            [
                "AllPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "NullIsFalsePredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "NullIsExceptionPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "AnyPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "TruePredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "FactoryTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "NotNullPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "SwitchClosure",
                "org.apache.commons.collections4.functors"
            ],
            [
                "UniquePredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "InstantiateTransformer",
                "org.apache.commons.collections4.functors"
            ],
            [
                "OnePredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "EqualPredicate",
                "org.apache.commons.collections4.functors"
            ],
            [
                "InstantiateFactory",
                "org.apache.commons.collections4.functors"
            ],
            [
                "IfClosure",
                "org.apache.commons.collections4.functors"
            ],
            [
                "ResettableListIterator",
                "org.apache.commons.collections4"
            ],
            [
                "OrderedIterator",
                "org.apache.commons.collections4"
            ],
            [
                "ComparatorChain",
                "org.apache.commons.collections4.comparators"
            ],
            [
                "BooleanComparator",
                "org.apache.commons.collections4.comparators"
            ],
            [
                "ReverseComparator",
                "org.apache.commons.collections4.comparators"
            ],
            [
                "ComparableComparator",
                "org.apache.commons.collections4.comparators"
            ],
            [
                "TransformingComparator",
                "org.apache.commons.collections4.comparators"
            ],
            [
                "FixedOrderComparator",
                "org.apache.commons.collections4.comparators"
            ],
            [
                "NullComparator",
                "org.apache.commons.collections4.comparators"
            ],
            [
                "CollectionUtils",
                "org.apache.commons.collections4"
            ],
            [
                "ListValuedMap",
                "org.apache.commons.collections4"
            ],
            [
                "AbstractIterableGetMapDecorator",
                "org.apache.commons.collections4.splitmap"
            ],
            [
                "TransformedSplitMap",
                "org.apache.commons.collections4.splitmap"
            ],
            [
                "Factory",
                "org.apache.commons.collections4"
            ],
            [
                "IterableUtils",
                "org.apache.commons.collections4"
            ],
            [
                "Bag",
                "org.apache.commons.collections4"
            ],
            [
                "Predicate",
                "org.apache.commons.collections4"
            ],
            [
                "SortedBag",
                "org.apache.commons.collections4"
            ],
            [
                "TrieUtils",
                "org.apache.commons.collections4"
            ],
            [
                "ClosureUtils",
                "org.apache.commons.collections4"
            ],
            [
                "PatriciaTrie",
                "org.apache.commons.collections4.trie"
            ],
            [
                "UnmodifiableTrie",
                "org.apache.commons.collections4.trie"
            ],
            [
                "KeyAnalyzer",
                "org.apache.commons.collections4.trie"
            ],
            [
                "AbstractPatriciaTrie",
                "org.apache.commons.collections4.trie"
            ],
            [
                "AbstractBitwiseTrie",
                "org.apache.commons.collections4.trie"
            ],
            [
                "StringKeyAnalyzer",
                "org.apache.commons.collections4.trie.analyzer"
            ],
            [
                "TransformedSortedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "AbstractLinkedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "Flat3Map",
                "org.apache.commons.collections4.map"
            ],
            [
                "PredicatedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "FixedSizeSortedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "UnmodifiableSortedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "PredicatedSortedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "DefaultedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "ReferenceIdentityMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "AbstractSortedMapDecorator",
                "org.apache.commons.collections4.map"
            ],
            [
                "AbstractInputCheckedMapDecorator",
                "org.apache.commons.collections4.map"
            ],
            [
                "FixedSizeMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "LazySortedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "UnmodifiableOrderedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "CaseInsensitiveMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "AbstractHashedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "AbstractOrderedMapDecorator",
                "org.apache.commons.collections4.map"
            ],
            [
                "UnmodifiableMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "EntrySetToMapIteratorAdapter",
                "org.apache.commons.collections4.map"
            ],
            [
                "AbstractIterableMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "ListOrderedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "LinkedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "SingletonMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "UnmodifiableEntrySet",
                "org.apache.commons.collections4.map"
            ],
            [
                "StaticBucketMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "AbstractMapDecorator",
                "org.apache.commons.collections4.map"
            ],
            [
                "AbstractReferenceMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "MultiKeyMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "HashedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "LazyMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "PassiveExpiringMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "MultiValueMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "LRUMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "ReferenceMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "TransformedMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "CompositeMap",
                "org.apache.commons.collections4.map"
            ],
            [
                "UnmodifiableMapEntry",
                "org.apache.commons.collections4.keyvalue"
            ],
            [
                "MultiKey",
                "org.apache.commons.collections4.keyvalue"
            ],
            [
                "DefaultMapEntry",
                "org.apache.commons.collections4.keyvalue"
            ],
            [
                "DefaultKeyValue",
                "org.apache.commons.collections4.keyvalue"
            ],
            [
                "AbstractMapEntryDecorator",
                "org.apache.commons.collections4.keyvalue"
            ],
            [
                "AbstractKeyValue",
                "org.apache.commons.collections4.keyvalue"
            ],
            [
                "TiedMapEntry",
                "org.apache.commons.collections4.keyvalue"
            ],
            [
                "AbstractMapEntry",
                "org.apache.commons.collections4.keyvalue"
            ],
            [
                "MultiSetUtils",
                "org.apache.commons.collections4"
            ],
            [
                "MapIterator",
                "org.apache.commons.collections4"
            ],
            [
                "AbstractMultiValuedMap",
                "org.apache.commons.collections4.multimap"
            ],
            [
                "UnmodifiableMultiValuedMap",
                "org.apache.commons.collections4.multimap"
            ],
            [
                "HashSetValuedHashMap",
                "org.apache.commons.collections4.multimap"
            ],
            [
                "TransformedMultiValuedMap",
                "org.apache.commons.collections4.multimap"
            ],
            [
                "AbstractSetValuedMap",
                "org.apache.commons.collections4.multimap"
            ],
            [
                "AbstractListValuedMap",
                "org.apache.commons.collections4.multimap"
            ],
            [
                "ArrayListValuedHashMap",
                "org.apache.commons.collections4.multimap"
            ],
            [
                "AbstractMultiValuedMapDecorator",
                "org.apache.commons.collections4.multimap"
            ],
            [
                "LazyList",
                "org.apache.commons.collections4.list"
            ],
            [
                "AbstractSerializableListDecorator",
                "org.apache.commons.collections4.list"
            ],
            [
                "TreeList",
                "org.apache.commons.collections4.list"
            ],
            [
                "SetUniqueList",
                "org.apache.commons.collections4.list"
            ],
            [
                "AbstractListDecorator",
                "org.apache.commons.collections4.list"
            ],
            [
                "NodeCachingLinkedList",
                "org.apache.commons.collections4.list"
            ],
            [
                "UnmodifiableList",
                "org.apache.commons.collections4.list"
            ],
            [
                "FixedSizeList",
                "org.apache.commons.collections4.list"
            ],
            [
                "TransformedList",
                "org.apache.commons.collections4.list"
            ],
            [
                "GrowthList",
                "org.apache.commons.collections4.list"
            ],
            [
                "AbstractLinkedList",
                "org.apache.commons.collections4.list"
            ],
            [
                "CursorableLinkedList",
                "org.apache.commons.collections4.list"
            ],
            [
                "PredicatedList",
                "org.apache.commons.collections4.list"
            ],
            [
                "OrderedMap",
                "org.apache.commons.collections4"
            ],
            [
                "AbstractQueueDecorator",
                "org.apache.commons.collections4.queue"
            ],
            [
                "TransformedQueue",
                "org.apache.commons.collections4.queue"
            ],
            [
                "UnmodifiableQueue",
                "org.apache.commons.collections4.queue"
            ],
            [
                "CircularFifoQueue",
                "org.apache.commons.collections4.queue"
            ],
            [
                "PredicatedQueue",
                "org.apache.commons.collections4.queue"
            ],
            [
                "FluentIterable",
                "org.apache.commons.collections4"
            ],
            [
                "TransformerUtils",
                "org.apache.commons.collections4"
            ],
            [
                "PredicateUtils",
                "org.apache.commons.collections4"
            ],
            [
                "ResettableIterator",
                "org.apache.commons.collections4"
            ],
            [
                "MultiValuedMap",
                "org.apache.commons.collections4"
            ],
            [
                "SetUtils",
                "org.apache.commons.collections4"
            ],
            [
                "SortedBidiMap",
                "org.apache.commons.collections4"
            ],
            [
                "ArrayStack",
                "org.apache.commons.collections4"
            ],
            [
                "Put",
                "org.apache.commons.collections4"
            ],
            [
                "OrderedMapIterator",
                "org.apache.commons.collections4"
            ],
            [
                "TransformedSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "CompositeSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "TransformedNavigableSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "PredicatedNavigableSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "AbstractSetDecorator",
                "org.apache.commons.collections4.set"
            ],
            [
                "ListOrderedSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "UnmodifiableSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "AbstractSerializableSetDecorator",
                "org.apache.commons.collections4.set"
            ],
            [
                "MapBackedSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "UnmodifiableSortedSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "PredicatedSortedSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "AbstractSortedSetDecorator",
                "org.apache.commons.collections4.set"
            ],
            [
                "PredicatedSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "AbstractNavigableSetDecorator",
                "org.apache.commons.collections4.set"
            ],
            [
                "UnmodifiableNavigableSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "TransformedSortedSet",
                "org.apache.commons.collections4.set"
            ],
            [
                "IterableMap",
                "org.apache.commons.collections4"
            ],
            [
                "EnumerationUtils",
                "org.apache.commons.collections4"
            ],
            [
                "DeleteCommand",
                "org.apache.commons.collections4.sequence"
            ],
            [
                "ReplacementsHandler",
                "org.apache.commons.collections4.sequence"
            ],
            [
                "InsertCommand",
                "org.apache.commons.collections4.sequence"
            ],
            [
                "SequencesComparator",
                "org.apache.commons.collections4.sequence"
            ],
            [
                "ReplacementsFinder",
                "org.apache.commons.collections4.sequence"
            ],
            [
                "KeepCommand",
                "org.apache.commons.collections4.sequence"
            ],
            [
                "EditCommand",
                "org.apache.commons.collections4.sequence"
            ],
            [
                "CommandVisitor",
                "org.apache.commons.collections4.sequence"
            ],
            [
                "EditScript",
                "org.apache.commons.collections4.sequence"
            ],
            [
                "QueueUtils",
                "org.apache.commons.collections4"
            ],
            [
                "SetValuedMap",
                "org.apache.commons.collections4"
            ],
            [
                "SynchronizedBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "AbstractMapBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "CollectionBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "UnmodifiableBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "PredicatedSortedBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "UnmodifiableSortedBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "HashBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "AbstractBagDecorator",
                "org.apache.commons.collections4.bag"
            ],
            [
                "TransformedSortedBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "TreeBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "PredicatedBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "SynchronizedSortedBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "CollectionSortedBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "TransformedBag",
                "org.apache.commons.collections4.bag"
            ],
            [
                "AbstractSortedBagDecorator",
                "org.apache.commons.collections4.bag"
            ],
            [
                "HashMultiSet",
                "org.apache.commons.collections4.multiset"
            ],
            [
                "AbstractMultiSet",
                "org.apache.commons.collections4.multiset"
            ],
            [
                "PredicatedMultiSet",
                "org.apache.commons.collections4.multiset"
            ],
            [
                "AbstractMultiSetDecorator",
                "org.apache.commons.collections4.multiset"
            ],
            [
                "AbstractMapMultiSet",
                "org.apache.commons.collections4.multiset"
            ],
            [
                "UnmodifiableMultiSet",
                "org.apache.commons.collections4.multiset"
            ],
            [
                "SynchronizedMultiSet",
                "org.apache.commons.collections4.multiset"
            ],
            [
                "BagUtils",
                "org.apache.commons.collections4"
            ],
            [
                "Unmodifiable",
                "org.apache.commons.collections4"
            ],
            [
                "Get",
                "org.apache.commons.collections4"
            ],
            [
                "Trie",
                "org.apache.commons.collections4"
            ],
            [
                "MultiMap",
                "org.apache.commons.collections4"
            ],
            [
                "KeyValue",
                "org.apache.commons.collections4"
            ],
            [
                "IteratorChain",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "EmptyListIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "UnmodifiableOrderedMapIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "AbstractListIteratorDecorator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "ZippingIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "UnmodifiableIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "CollatingIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "UniqueFilterIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "ReverseListIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "BoundedIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "AbstractIteratorDecorator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "TransformIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "AbstractEmptyIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "NodeListIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "ArrayListIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "LazyIteratorChain",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "LoopingListIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "PeekingIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "ObjectGraphIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "ArrayIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "PermutationIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "SingletonListIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "EmptyMapIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "ObjectArrayIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "EnumerationIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "IteratorIterable",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "AbstractEmptyMapIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "LoopingIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "IteratorEnumeration",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "SingletonIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "ListIteratorWrapper",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "SkippingIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "EmptyOrderedIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "AbstractMapIteratorDecorator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "ObjectArrayListIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "UnmodifiableListIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "EmptyOrderedMapIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "UnmodifiableMapIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "EmptyIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "EntrySetMapIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "PushbackIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "FilterIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "AbstractUntypedIteratorDecorator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "AbstractOrderedMapIteratorDecorator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "FilterListIterator",
                "org.apache.commons.collections4.iterators"
            ],
            [
                "SplitMapUtils",
                "org.apache.commons.collections4"
            ],
            [
                "BoundedMap",
                "org.apache.commons.collections4"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "emptyIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Empty\n//-----------------------------------------------------------------------\n/**\n * Gets an empty iterator.\n * <p>\n * This iterator is a valid iterator object that will iterate over nothing.\n *\n * @param <E> the element type\n * @return an iterator over nothing\n */\npublic static <E> ResettableIterator<E> emptyIterator() {\n    return EmptyIterator.<E>resettableEmptyIterator();\n}"
            ],
            [
                "emptyListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an empty list iterator.\n * <p>\n * This iterator is a valid list iterator object that will iterate\n * over nothing.\n *\n * @param <E> the element type\n * @return a list iterator over nothing\n */\npublic static <E> ResettableListIterator<E> emptyListIterator() {\n    return EmptyListIterator.<E>resettableEmptyListIterator();\n}"
            ],
            [
                "emptyOrderedIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an empty ordered iterator.\n * <p>\n * This iterator is a valid iterator object that will iterate\n * over nothing.\n *\n * @param <E> the element type\n * @return an ordered iterator over nothing\n */\npublic static <E> OrderedIterator<E> emptyOrderedIterator() {\n    return EmptyOrderedIterator.<E>emptyOrderedIterator();\n}"
            ],
            [
                "emptyMapIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an empty map iterator.\n * <p>\n * This iterator is a valid map iterator object that will iterate\n * over nothing.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @return a map iterator over nothing\n */\npublic static <K, V> MapIterator<K, V> emptyMapIterator() {\n    return EmptyMapIterator.<K, V>emptyMapIterator();\n}"
            ],
            [
                "emptyOrderedMapIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an empty ordered map iterator.\n * <p>\n * This iterator is a valid map iterator object that will iterate\n * over nothing.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @return a map iterator over nothing\n */\npublic static <K, V> OrderedMapIterator<K, V> emptyOrderedMapIterator() {\n    return EmptyOrderedMapIterator.<K, V>emptyOrderedMapIterator();\n}"
            ],
            [
                "singletonIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Singleton\n//-----------------------------------------------------------------------\n/**\n * Gets a singleton iterator.\n * <p>\n * This iterator is a valid iterator object that will iterate over\n * the specified object.\n *\n * @param <E> the element type\n * @param object  the single object over which to iterate\n * @return a singleton iterator over the object\n */\npublic static <E> ResettableIterator<E> singletonIterator(final E object) {\n    return new SingletonIterator<E>(object);\n}"
            ],
            [
                "singletonListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a singleton list iterator.\n * <p>\n * This iterator is a valid list iterator object that will iterate over\n * the specified object.\n *\n * @param <E> the element type\n * @param object  the single object over which to iterate\n * @return a singleton list iterator over the object\n */\npublic static <E> ListIterator<E> singletonListIterator(final E object) {\n    return new SingletonListIterator<E>(object);\n}"
            ],
            [
                "arrayIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Arrays\n//-----------------------------------------------------------------------\n/**\n * Gets an iterator over an object array.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @return an iterator over the array\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableIterator<E> arrayIterator(final E... array) {\n    return new ObjectArrayIterator<E>(array);\n}"
            ],
            [
                "arrayIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator over an object or primitive array.\n * <p>\n * This method will handle primitive arrays as well as object arrays.\n * The primitives will be wrapped in the appropriate wrapper class.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @return an iterator over the array\n * @throws IllegalArgumentException if the array is not an array\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableIterator<E> arrayIterator(final Object array) {\n    return new ArrayIterator<E>(array);\n}"
            ],
            [
                "arrayIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator over the end part of an object array.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @param start  the index to start iterating at\n * @return an iterator over part of the array\n * @throws IndexOutOfBoundsException if start is less than zero or greater\n *   than the length of the array\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableIterator<E> arrayIterator(final E[] array, final int start) {\n    return new ObjectArrayIterator<E>(array, start);\n}"
            ],
            [
                "arrayIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator over the end part of an object or primitive array.\n * <p>\n * This method will handle primitive arrays as well as object arrays.\n * The primitives will be wrapped in the appropriate wrapper class.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @param start  the index to start iterating at\n * @return an iterator over part of the array\n * @throws IllegalArgumentException if the array is not an array\n * @throws IndexOutOfBoundsException if start is less than zero or greater\n *   than the length of the array\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableIterator<E> arrayIterator(final Object array, final int start) {\n    return new ArrayIterator<E>(array, start);\n}"
            ],
            [
                "arrayIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator over part of an object array.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @param start  the index to start iterating at\n * @param end  the index to finish iterating at\n * @return an iterator over part of the array\n * @throws IndexOutOfBoundsException if array bounds are invalid\n * @throws IllegalArgumentException if end is before start\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableIterator<E> arrayIterator(final E[] array, final int start, final int end) {\n    return new ObjectArrayIterator<E>(array, start, end);\n}"
            ],
            [
                "arrayIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator over part of an object or primitive array.\n * <p>\n * This method will handle primitive arrays as well as object arrays.\n * The primitives will be wrapped in the appropriate wrapper class.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @param start  the index to start iterating at\n * @param end  the index to finish iterating at\n * @return an iterator over part of the array\n * @throws IllegalArgumentException if the array is not an array or end is before start\n * @throws IndexOutOfBoundsException if array bounds are invalid\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableIterator<E> arrayIterator(final Object array, final int start, final int end) {\n    return new ArrayIterator<E>(array, start, end);\n}"
            ],
            [
                "arrayListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "//-----------------------------------------------------------------------\n/**\n * Gets a list iterator over an object array.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @return a list iterator over the array\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableListIterator<E> arrayListIterator(final E... array) {\n    return new ObjectArrayListIterator<E>(array);\n}"
            ],
            [
                "arrayListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a list iterator over an object or primitive array.\n * <p>\n * This method will handle primitive arrays as well as object arrays.\n * The primitives will be wrapped in the appropriate wrapper class.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @return a list iterator over the array\n * @throws IllegalArgumentException if the array is not an array\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableListIterator<E> arrayListIterator(final Object array) {\n    return new ArrayListIterator<E>(array);\n}"
            ],
            [
                "arrayListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a list iterator over the end part of an object array.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @param start  the index to start iterating at\n * @return a list iterator over part of the array\n * @throws IndexOutOfBoundsException if start is less than zero\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableListIterator<E> arrayListIterator(final E[] array, final int start) {\n    return new ObjectArrayListIterator<E>(array, start);\n}"
            ],
            [
                "arrayListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a list iterator over the end part of an object or primitive array.\n * <p>\n * This method will handle primitive arrays as well as object arrays.\n * The primitives will be wrapped in the appropriate wrapper class.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @param start  the index to start iterating at\n * @return a list iterator over part of the array\n * @throws IllegalArgumentException if the array is not an array\n * @throws IndexOutOfBoundsException if start is less than zero\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableListIterator<E> arrayListIterator(final Object array, final int start) {\n    return new ArrayListIterator<E>(array, start);\n}"
            ],
            [
                "arrayListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a list iterator over part of an object array.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @param start  the index to start iterating at\n * @param end  the index to finish iterating at\n * @return a list iterator over part of the array\n * @throws IndexOutOfBoundsException if array bounds are invalid\n * @throws IllegalArgumentException if end is before start\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableListIterator<E> arrayListIterator(final E[] array, final int start, final int end) {\n    return new ObjectArrayListIterator<E>(array, start, end);\n}"
            ],
            [
                "arrayListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a list iterator over part of an object or primitive array.\n * <p>\n * This method will handle primitive arrays as well as object arrays.\n * The primitives will be wrapped in the appropriate wrapper class.\n *\n * @param <E> the element type\n * @param array  the array over which to iterate\n * @param start  the index to start iterating at\n * @param end  the index to finish iterating at\n * @return a list iterator over part of the array\n * @throws IllegalArgumentException if the array is not an array or end is before start\n * @throws IndexOutOfBoundsException if array bounds are invalid\n * @throws NullPointerException if array is null\n */\npublic static <E> ResettableListIterator<E> arrayListIterator(final Object array, final int start, final int end) {\n    return new ArrayListIterator<E>(array, start, end);\n}"
            ],
            [
                "boundedIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Bounded\n//-----------------------------------------------------------------------\n/**\n * Decorates the specified iterator to return at most the given number\n * of elements.\n *\n * @param <E> the element type\n * @param iterator  the iterator to decorate\n * @param max  the maximum number of elements returned by this iterator\n * @return a new bounded iterator\n * @throws NullPointerException if the iterator is null\n * @throws IllegalArgumentException if max is negative\n * @since 4.1\n */\npublic static <E> BoundedIterator<E> boundedIterator(final Iterator<? extends E> iterator, long max) {\n    return boundedIterator(iterator, 0, max);\n}"
            ],
            [
                "boundedIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Decorates the specified iterator to return at most the given number\n * of elements, skipping all elements until the iterator reaches the\n * position at {@code offset}.\n * <p>\n * The iterator is immediately advanced until it reaches the position at\n * {@code offset}, incurring O(n) time.\n *\n * @param <E> the element type\n * @param iterator  the iterator to decorate\n * @param offset  the index of the first element of the decorated iterator to return\n * @param max  the maximum number of elements returned by this iterator\n * @return a new bounded iterator\n * @throws NullPointerException if the iterator is null\n * @throws IllegalArgumentException if either offset or max is negative\n * @since 4.1\n */\npublic static <E> BoundedIterator<E> boundedIterator(final Iterator<? extends E> iterator, long offset, long max) {\n    return new BoundedIterator<E>(iterator, offset, max);\n}"
            ],
            [
                "unmodifiableIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Unmodifiable\n//-----------------------------------------------------------------------\n/**\n * Gets an immutable version of an {@link Iterator}. The returned object\n * will always throw an {@link UnsupportedOperationException} for\n * the {@link Iterator#remove} method.\n *\n * @param <E> the element type\n * @param iterator  the iterator to make immutable\n * @return an immutable version of the iterator\n */\npublic static <E> Iterator<E> unmodifiableIterator(final Iterator<E> iterator) {\n    return UnmodifiableIterator.unmodifiableIterator(iterator);\n}"
            ],
            [
                "unmodifiableListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an immutable version of a {@link ListIterator}. The returned object\n * will always throw an {@link UnsupportedOperationException} for\n * the {@link Iterator#remove}, {@link ListIterator#add} and\n * {@link ListIterator#set} methods.\n *\n * @param <E> the element type\n * @param listIterator  the iterator to make immutable\n * @return an immutable version of the iterator\n */\npublic static <E> ListIterator<E> unmodifiableListIterator(final ListIterator<E> listIterator) {\n    return UnmodifiableListIterator.umodifiableListIterator(listIterator);\n}"
            ],
            [
                "unmodifiableMapIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an immutable version of a {@link MapIterator}. The returned object\n * will always throw an {@link UnsupportedOperationException} for\n * the {@link Iterator#remove}, {@link MapIterator#setValue(Object)} methods.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param mapIterator  the iterator to make immutable\n * @return an immutable version of the iterator\n */\npublic static <K, V> MapIterator<K, V> unmodifiableMapIterator(final MapIterator<K, V> mapIterator) {\n    return UnmodifiableMapIterator.unmodifiableMapIterator(mapIterator);\n}"
            ],
            [
                "chainedIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Chained\n//-----------------------------------------------------------------------\n/**\n * Gets an iterator that iterates through two {@link Iterator}s\n * one after another.\n *\n * @param <E> the element type\n * @param iterator1  the first iterator to use, not null\n * @param iterator2  the second iterator to use, not null\n * @return a combination iterator over the iterators\n * @throws NullPointerException if either iterator is null\n */\npublic static <E> Iterator<E> chainedIterator(final Iterator<? extends E> iterator1, final Iterator<? extends E> iterator2) {\n    // keep a version with two iterators to avoid the following warning in client code (Java 5 & 6)\n    // \"A generic array of E is created for a varargs parameter\"\n    return new IteratorChain<E>(iterator1, iterator2);\n}"
            ],
            [
                "chainedIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator that iterates through an array of {@link Iterator}s\n * one after another.\n *\n * @param <E> the element type\n * @param iterators  the iterators to use, not null or empty or contain nulls\n * @return a combination iterator over the iterators\n * @throws NullPointerException if iterators array is null or contains a null\n */\npublic static <E> Iterator<E> chainedIterator(final Iterator<? extends E>... iterators) {\n    return new IteratorChain<E>(iterators);\n}"
            ],
            [
                "chainedIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator that iterates through a collections of {@link Iterator}s\n * one after another.\n *\n * @param <E> the element type\n * @param iterators  the iterators to use, not null or empty or contain nulls\n * @return a combination iterator over the iterators\n * @throws NullPointerException if iterators collection is null or contains a null\n * @throws ClassCastException if the iterators collection contains the wrong object type\n */\npublic static <E> Iterator<E> chainedIterator(final Collection<Iterator<? extends E>> iterators) {\n    return new IteratorChain<E>(iterators);\n}"
            ],
            [
                "collatedIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Collated\n//-----------------------------------------------------------------------\n/**\n * Gets an iterator that provides an ordered iteration over the elements\n * contained in a collection of ordered {@link Iterator}s.\n * <p>\n * Given two ordered {@link Iterator}s <code>A</code> and <code>B</code>,\n * the {@link Iterator#next()} method will return the lesser of\n * <code>A.next()</code> and <code>B.next()</code>.\n * <p>\n * The comparator is optional. If null is specified then natural order is used.\n *\n * @param <E> the element type\n * @param comparator  the comparator to use, may be null for natural order\n * @param iterator1  the first iterators to use, not null\n * @param iterator2  the first iterators to use, not null\n * @return a combination iterator over the iterators\n * @throws NullPointerException if either iterator is null\n */\npublic static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator, final Iterator<? extends E> iterator1, final Iterator<? extends E> iterator2) {\n    @SuppressWarnings(\"unchecked\")\n    final Comparator<E> comp = comparator == null ? ComparatorUtils.NATURAL_COMPARATOR : (Comparator<E>) comparator;\n    return new CollatingIterator<E>(comp, iterator1, iterator2);\n}"
            ],
            [
                "collatedIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator that provides an ordered iteration over the elements\n * contained in an array of {@link Iterator}s.\n * <p>\n * Given two ordered {@link Iterator}s <code>A</code> and <code>B</code>,\n * the {@link Iterator#next()} method will return the lesser of\n * <code>A.next()</code> and <code>B.next()</code> and so on.\n * <p>\n * The comparator is optional. If null is specified then natural order is used.\n *\n * @param <E> the element type\n * @param comparator  the comparator to use, may be null for natural order\n * @param iterators  the iterators to use, not null or empty or contain nulls\n * @return a combination iterator over the iterators\n * @throws NullPointerException if iterators array is null or contains a null value\n */\npublic static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator, final Iterator<? extends E>... iterators) {\n    @SuppressWarnings(\"unchecked\")\n    final Comparator<E> comp = comparator == null ? ComparatorUtils.NATURAL_COMPARATOR : (Comparator<E>) comparator;\n    return new CollatingIterator<E>(comp, iterators);\n}"
            ],
            [
                "collatedIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator that provides an ordered iteration over the elements\n * contained in a collection of {@link Iterator}s.\n * <p>\n * Given two ordered {@link Iterator}s <code>A</code> and <code>B</code>,\n * the {@link Iterator#next()} method will return the lesser of\n * <code>A.next()</code> and <code>B.next()</code> and so on.\n * <p>\n * The comparator is optional. If null is specified then natural order is used.\n *\n * @param <E> the element type\n * @param comparator  the comparator to use, may be null for natural order\n * @param iterators  the iterators to use, not null or empty or contain nulls\n * @return a combination iterator over the iterators\n * @throws NullPointerException if iterators collection is null or contains a null\n * @throws ClassCastException if the iterators collection contains the wrong object type\n */\npublic static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator, final Collection<Iterator<? extends E>> iterators) {\n    @SuppressWarnings(\"unchecked\")\n    final Comparator<E> comp = comparator == null ? ComparatorUtils.NATURAL_COMPARATOR : (Comparator<E>) comparator;\n    return new CollatingIterator<E>(comp, iterators);\n}"
            ],
            [
                "objectGraphIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Object Graph\n//-----------------------------------------------------------------------\n/**\n * Gets an iterator that operates over an object graph.\n * <p>\n * This iterator can extract multiple objects from a complex tree-like object graph.\n * The iteration starts from a single root object.\n * It uses a <code>Transformer</code> to extract the iterators and elements.\n * Its main benefit is that no intermediate <code>List</code> is created.\n * <p>\n * For example, consider an object graph:\n * <pre>\n *                 |- Branch -- Leaf\n *                 |         \\- Leaf\n *         |- Tree |         /- Leaf\n *         |       |- Branch -- Leaf\n *  Forest |                 \\- Leaf\n *         |       |- Branch -- Leaf\n *         |       |         \\- Leaf\n *         |- Tree |         /- Leaf\n *                 |- Branch -- Leaf\n *                 |- Branch -- Leaf</pre>\n * The following <code>Transformer</code>, used in this class, will extract all\n * the Leaf objects without creating a combined intermediate list:\n * <pre>\n * public Object transform(Object input) {\n *   if (input instanceof Forest) {\n *     return ((Forest) input).treeIterator();\n *   }\n *   if (input instanceof Tree) {\n *     return ((Tree) input).branchIterator();\n *   }\n *   if (input instanceof Branch) {\n *     return ((Branch) input).leafIterator();\n *   }\n *   if (input instanceof Leaf) {\n *     return input;\n *   }\n *   throw new ClassCastException();\n * }</pre>\n * <p>\n * Internally, iteration starts from the root object. When next is called,\n * the transformer is called to examine the object. The transformer will return\n * either an iterator or an object. If the object is an Iterator, the next element\n * from that iterator is obtained and the process repeats. If the element is an object\n * it is returned.\n * <p>\n * Under many circumstances, linking Iterators together in this manner is\n * more efficient (and convenient) than using nested for loops to extract a list.\n *\n * @param <E> the element type\n * @param root  the root object to start iterating from, null results in an empty iterator\n * @param transformer  the transformer to use, see above, null uses no effect transformer\n * @return a new object graph iterator\n * @since 3.1\n */\npublic static <E> Iterator<E> objectGraphIterator(final E root, final Transformer<? super E, ? extends E> transformer) {\n    return new ObjectGraphIterator<E>(root, transformer);\n}"
            ],
            [
                "transformedIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Transformed\n//-----------------------------------------------------------------------\n/**\n * Gets an iterator that transforms the elements of another iterator.\n * <p>\n * The transformation occurs during the next() method and the underlying\n * iterator is unaffected by the transformation.\n *\n * @param <I> the input type\n * @param <O> the output type\n * @param iterator  the iterator to use, not null\n * @param transform  the transform to use, not null\n * @return a new transforming iterator\n * @throws NullPointerException if either parameter is null\n */\npublic static <I, O> Iterator<O> transformedIterator(final Iterator<? extends I> iterator, final Transformer<? super I, ? extends O> transform) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (transform == null) {\n        throw new NullPointerException(\"Transformer must not be null\");\n    }\n    return new TransformIterator<I, O>(iterator, transform);\n}"
            ],
            [
                "filteredIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Filtered\n//-----------------------------------------------------------------------\n/**\n * Gets an iterator that filters another iterator.\n * <p>\n * The returned iterator will only return objects that match the specified\n * filtering predicate.\n *\n * @param <E> the element type\n * @param iterator  the iterator to use, not null\n * @param predicate  the predicate to use as a filter, not null\n * @return a new filtered iterator\n * @throws NullPointerException if either parameter is null\n */\npublic static <E> Iterator<E> filteredIterator(final Iterator<? extends E> iterator, final Predicate<? super E> predicate) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    return new FilterIterator<E>(iterator, predicate);\n}"
            ],
            [
                "filteredListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a list iterator that filters another list iterator.\n * <p>\n * The returned iterator will only return objects that match the specified\n * filtering predicate.\n *\n * @param <E> the element type\n * @param listIterator  the list iterator to use, not null\n * @param predicate  the predicate to use as a filter, not null\n * @return a new filtered iterator\n * @throws NullPointerException if either parameter is null\n */\npublic static <E> ListIterator<E> filteredListIterator(final ListIterator<? extends E> listIterator, final Predicate<? super E> predicate) {\n    if (listIterator == null) {\n        throw new NullPointerException(\"ListIterator must not be null\");\n    }\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    return new FilterListIterator<E>(listIterator, predicate);\n}"
            ],
            [
                "loopingIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Looping\n//-----------------------------------------------------------------------\n/**\n * Gets an iterator that loops continuously over the supplied collection.\n * <p>\n * The iterator will only stop looping if the remove method is called\n * enough times to empty the collection, or if the collection is empty\n * to start with.\n *\n * @param <E> the element type\n * @param coll  the collection to iterate over, not null\n * @return a new looping iterator\n * @throws NullPointerException if the collection is null\n */\npublic static <E> ResettableIterator<E> loopingIterator(final Collection<? extends E> coll) {\n    if (coll == null) {\n        throw new NullPointerException(\"Collection must not be null\");\n    }\n    return new LoopingIterator<E>(coll);\n}"
            ],
            [
                "loopingListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator that loops continuously over the supplied list.\n * <p>\n * The iterator will only stop looping if the remove method is called\n * enough times to empty the list, or if the list is empty to start with.\n *\n * @param <E> the element type\n * @param list  the list to iterate over, not null\n * @return a new looping iterator\n * @throws NullPointerException if the list is null\n * @since 3.2\n */\npublic static <E> ResettableListIterator<E> loopingListIterator(final List<E> list) {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    return new LoopingListIterator<E>(list);\n}"
            ],
            [
                "nodeListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// org.w3c.dom.NodeList iterators\n//-----------------------------------------------------------------------\n/**\n * Gets an {@link Iterator} that wraps the specified {@link NodeList}.\n * The returned {@link Iterator} can be used for a single iteration.\n *\n * @param nodeList  the node list to use, may not be null\n * @return a new, single use {@link Iterator}\n * @throws NullPointerException if nodeList is null\n * @since 4.0\n */\npublic static NodeListIterator nodeListIterator(final NodeList nodeList) {\n    if (nodeList == null) {\n        throw new NullPointerException(\"NodeList must not be null\");\n    }\n    return new NodeListIterator(nodeList);\n}"
            ],
            [
                "nodeListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an {@link Iterator} that wraps the specified node's childNodes.\n * The returned {@link Iterator} can be used for a single iteration.\n * <p>\n * Convenience method, allows easy iteration over NodeLists:\n * <pre>\n *   Iterator&lt;Node&gt; iterator = IteratorUtils.nodeListIterator(node);\n *   for(Node childNode : IteratorUtils.asIterable(iterator)) {\n *     ...\n *   }\n * </pre>\n *\n * @param node  the node to use, may not be null\n * @return a new, single use {@link Iterator}\n * @throws NullPointerException if node is null\n * @since 4.0\n */\npublic static NodeListIterator nodeListIterator(final Node node) {\n    if (node == null) {\n        throw new NullPointerException(\"Node must not be null\");\n    }\n    return new NodeListIterator(node);\n}"
            ],
            [
                "peekingIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Peeking\n//-----------------------------------------------------------------------\n/**\n * Gets an iterator that supports one-element lookahead.\n *\n * @param <E> the element type\n * @param iterator  the iterator to decorate, not null\n * @return a peeking iterator\n * @throws NullPointerException if the iterator is null\n * @since 4.0\n */\npublic static <E> Iterator<E> peekingIterator(final Iterator<? extends E> iterator) {\n    return PeekingIterator.peekingIterator(iterator);\n}"
            ],
            [
                "pushbackIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Pushback\n//-----------------------------------------------------------------------\n/**\n * Gets an iterator that supports pushback of elements.\n *\n * @param <E> the element type\n * @param iterator  the iterator to decorate, not null\n * @return a pushback iterator\n * @throws NullPointerException if the iterator is null\n * @since 4.0\n */\npublic static <E> Iterator<E> pushbackIterator(final Iterator<? extends E> iterator) {\n    return PushbackIterator.pushbackIterator(iterator);\n}"
            ],
            [
                "skippingIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Skipping\n//-----------------------------------------------------------------------\n/**\n * Decorates the specified iterator to skip the first N elements.\n *\n * @param <E> the element type\n * @param iterator  the iterator to decorate\n * @param offset  the first number of elements to skip\n * @return a new skipping iterator\n * @throws NullPointerException if the iterator is null\n * @throws IllegalArgumentException if offset is negative\n * @since 4.1\n */\npublic static <E> SkippingIterator<E> skippingIterator(final Iterator<E> iterator, long offset) {\n    return new SkippingIterator<E>(iterator, offset);\n}"
            ],
            [
                "zippingIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Zipping\n//-----------------------------------------------------------------------\n/**\n * Returns an iterator that interleaves elements from the decorated iterators.\n *\n * @param <E> the element type\n * @param a  the first iterator to interleave\n * @param b  the second iterator to interleave\n * @return an iterator, interleaving the decorated iterators\n * @throws NullPointerException if any iterator is null\n * @since 4.1\n */\npublic static <E> ZippingIterator<E> zippingIterator(final Iterator<? extends E> a, final Iterator<? extends E> b) {\n    return new ZippingIterator<E>(a, b);\n}"
            ],
            [
                "zippingIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Returns an iterator that interleaves elements from the decorated iterators.\n *\n * @param <E> the element type\n * @param a  the first iterator to interleave\n * @param b  the second iterator to interleave\n * @param c  the third iterator to interleave\n * @return an iterator, interleaving the decorated iterators\n * @throws NullPointerException if any iterator is null\n * @since 4.1\n */\npublic static <E> ZippingIterator<E> zippingIterator(final Iterator<? extends E> a, final Iterator<? extends E> b, final Iterator<? extends E> c) {\n    return new ZippingIterator<E>(a, b, c);\n}"
            ],
            [
                "zippingIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Returns an iterator that interleaves elements from the decorated iterators.\n *\n * @param <E> the element type\n * @param iterators  the array of iterators to interleave\n * @return an iterator, interleaving the decorated iterators\n * @throws NullPointerException if any iterator is null\n * @since 4.1\n */\npublic static <E> ZippingIterator<E> zippingIterator(final Iterator<? extends E>... iterators) {\n    return new ZippingIterator<E>(iterators);\n}"
            ],
            [
                "asIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// Views\n//-----------------------------------------------------------------------\n/**\n * Gets an iterator that provides an iterator view of the given enumeration.\n *\n * @param <E> the element type\n * @param enumeration  the enumeration to use, may not be null\n * @return a new iterator\n * @throws NullPointerException if enumeration is null\n */\npublic static <E> Iterator<E> asIterator(final Enumeration<? extends E> enumeration) {\n    if (enumeration == null) {\n        throw new NullPointerException(\"Enumeration must not be null\");\n    }\n    return new EnumerationIterator<E>(enumeration);\n}"
            ],
            [
                "asIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterator that provides an iterator view of the given enumeration\n * that will remove elements from the specified collection.\n *\n * @param <E> the element type\n * @param enumeration  the enumeration to use, may not be null\n * @param removeCollection  the collection to remove elements from, may not be null\n * @return a new iterator\n * @throws NullPointerException if enumeration or removeCollection is null\n */\npublic static <E> Iterator<E> asIterator(final Enumeration<? extends E> enumeration, final Collection<? super E> removeCollection) {\n    if (enumeration == null) {\n        throw new NullPointerException(\"Enumeration must not be null\");\n    }\n    if (removeCollection == null) {\n        throw new NullPointerException(\"Collection must not be null\");\n    }\n    return new EnumerationIterator<E>(enumeration, removeCollection);\n}"
            ],
            [
                "asEnumeration",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an enumeration that wraps an iterator.\n *\n * @param <E> the element type\n * @param iterator  the iterator to use, may not be null\n * @return a new enumeration\n * @throws NullPointerException if iterator is null\n */\npublic static <E> Enumeration<E> asEnumeration(final Iterator<? extends E> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorEnumeration<E>(iterator);\n}"
            ],
            [
                "asIterable",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an {@link Iterable} that wraps an iterator.  The returned {@link Iterable} can be\n * used for a single iteration.\n *\n * @param <E> the element type\n * @param iterator  the iterator to use, may not be null\n * @return a new, single use {@link Iterable}\n * @throws NullPointerException if iterator is null\n */\npublic static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}"
            ],
            [
                "asMultipleUseIterable",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an iterable that wraps an iterator.  The returned iterable can be\n * used for multiple iterations.\n *\n * @param <E> the element type\n * @param iterator  the iterator to use, may not be null\n * @return a new, multiple use iterable\n * @throws NullPointerException if iterator is null\n */\npublic static <E> Iterable<E> asMultipleUseIterable(final Iterator<? extends E> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, true);\n}"
            ],
            [
                "toListIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a list iterator based on a simple iterator.\n * <p>\n * As the wrapped Iterator is traversed, a LinkedList of its values is\n * cached, permitting all required operations of ListIterator.\n *\n * @param <E> the element type\n * @param iterator  the iterator to use, may not be null\n * @return a new iterator\n * @throws NullPointerException if iterator parameter is null\n */\npublic static <E> ListIterator<E> toListIterator(final Iterator<? extends E> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new ListIteratorWrapper<E>(iterator);\n}"
            ],
            [
                "toArray",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an array based on an iterator.\n * <p>\n * As the wrapped Iterator is traversed, an ArrayList of its values is\n * created. At the end, this is converted to an array.\n *\n * @param iterator  the iterator to use, not null\n * @return an array of the iterator contents\n * @throws NullPointerException if iterator parameter is null\n */\npublic static Object[] toArray(final Iterator<?> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    final List<?> list = toList(iterator, 100);\n    return list.toArray();\n}"
            ],
            [
                "toArray",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets an array based on an iterator.\n * <p>\n * As the wrapped Iterator is traversed, an ArrayList of its values is\n * created. At the end, this is converted to an array.\n *\n * @param <E> the element type\n * @param iterator  the iterator to use, not null\n * @param arrayClass  the class of array to create\n * @return an array of the iterator contents\n * @throws NullPointerException if iterator parameter or arrayClass is null\n * @throws ArrayStoreException if the arrayClass is invalid\n */\npublic static <E> E[] toArray(final Iterator<? extends E> iterator, final Class<E> arrayClass) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (arrayClass == null) {\n        throw new NullPointerException(\"Array class must not be null\");\n    }\n    final List<E> list = toList(iterator, 100);\n    @SuppressWarnings(\"unchecked\")\n    final E[] array = (E[]) Array.newInstance(arrayClass, list.size());\n    return list.toArray(array);\n}"
            ],
            [
                "toList",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a list based on an iterator.\n * <p>\n * As the wrapped Iterator is traversed, an ArrayList of its values is\n * created. At the end, the list is returned.\n *\n * @param <E> the element type\n * @param iterator  the iterator to use, not null\n * @return a list of the iterator contents\n * @throws NullPointerException if iterator parameter is null\n */\npublic static <E> List<E> toList(final Iterator<? extends E> iterator) {\n    return toList(iterator, 10);\n}"
            ],
            [
                "toList",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a list based on an iterator.\n * <p>\n * As the wrapped Iterator is traversed, an ArrayList of its values is\n * created. At the end, the list is returned.\n *\n * @param <E> the element type\n * @param iterator  the iterator to use, not null\n * @param estimatedSize  the initial size of the ArrayList\n * @return a list of the iterator contents\n * @throws NullPointerException if iterator parameter is null\n * @throws IllegalArgumentException if the size is less than 1\n */\npublic static <E> List<E> toList(final Iterator<? extends E> iterator, final int estimatedSize) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (estimatedSize < 1) {\n        throw new IllegalArgumentException(\"Estimated size must be greater than 0\");\n    }\n    final List<E> list = new ArrayList<E>(estimatedSize);\n    while (iterator.hasNext()) {\n        list.add(iterator.next());\n    }\n    return list;\n}"
            ],
            [
                "getIterator",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Gets a suitable Iterator for the given object.\n * <p>\n * This method can handle objects as follows\n * <ul>\n * <li>null - empty iterator\n * <li>Iterator - returned directly\n * <li>Enumeration - wrapped\n * <li>Collection - iterator from collection returned\n * <li>Map - values iterator returned\n * <li>Dictionary - values (elements) enumeration returned as iterator\n * <li>array - iterator over array returned\n * <li>object with iterator() public method accessed by reflection\n * <li>object - singleton iterator\n * <li>NodeList - iterator over the list\n * <li>Node - iterator over the child nodes\n * </ul>\n *\n * @param obj  the object to convert to an iterator\n * @return a suitable iterator, never null\n */\npublic static Iterator<?> getIterator(final Object obj) {\n    if (obj == null) {\n        return emptyIterator();\n    }\n    if (obj instanceof Iterator) {\n        return (Iterator<?>) obj;\n    }\n    if (obj instanceof Iterable) {\n        return ((Iterable<?>) obj).iterator();\n    }\n    if (obj instanceof Object[]) {\n        return new ObjectArrayIterator<Object>((Object[]) obj);\n    }\n    if (obj instanceof Enumeration) {\n        return new EnumerationIterator<Object>((Enumeration<?>) obj);\n    }\n    if (obj instanceof Map) {\n        return ((Map<?, ?>) obj).values().iterator();\n    }\n    if (obj instanceof NodeList) {\n        return new NodeListIterator((NodeList) obj);\n    }\n    if (obj instanceof Node) {\n        return new NodeListIterator((Node) obj);\n    }\n    if (obj instanceof Dictionary) {\n        return new EnumerationIterator<Object>(((Dictionary<?, ?>) obj).elements());\n    } else if (obj.getClass().isArray()) {\n        return new ArrayIterator<Object>(obj);\n    }\n    try {\n        final Method method = obj.getClass().getMethod(\"iterator\", (Class[]) null);\n        if (Iterator.class.isAssignableFrom(method.getReturnType())) {\n            final Iterator<?> it = (Iterator<?>) method.invoke(obj, (Object[]) null);\n            if (it != null) {\n                return it;\n            }\n        }\n    } catch (final RuntimeException e) {\n        // NOPMD\n        // ignore\n    } catch (final NoSuchMethodException e) {\n        // NOPMD\n        // ignore\n    } catch (final IllegalAccessException e) {\n        // NOPMD\n        // ignore\n    } catch (final InvocationTargetException e) {\n        // NOPMD\n        // ignore\n    }\n    return singletonIterator(obj);\n}"
            ],
            [
                "forEachButLast",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Executes the given closure on each but the last element in the iterator.\n * <p>\n * If the input iterator is null no change is made.\n *\n * @param <E> the type of object the {@link Iterator} contains\n * @param iterator  the iterator to get the input from, may be null\n * @param closure  the closure to perform, may not be null\n * @return the last element in the iterator, or null if iterator is null or empty\n * @throws NullPointerException if closure is null\n * @since 4.1\n */\npublic static <E> E forEachButLast(final Iterator<E> iterator, final Closure<? super E> closure) {\n    if (closure == null) {\n        throw new NullPointerException(\"Closure must not be null.\");\n    }\n    if (iterator != null) {\n        while (iterator.hasNext()) {\n            final E element = iterator.next();\n            if (iterator.hasNext()) {\n                closure.execute(element);\n            } else {\n                return element;\n            }\n        }\n    }\n    return null;\n}"
            ],
            [
                "find",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Finds the first element in the given iterator which matches the given predicate.\n * <p>\n * A <code>null</code> or empty iterator returns null.\n *\n * @param <E> the element type\n * @param iterator  the iterator to search, may be null\n * @param predicate  the predicate to use, may not be null\n * @return the first element of the iterator which matches the predicate or null if none could be found\n * @throws NullPointerException if predicate is null\n * @since 4.1\n */\npublic static <E> E find(final Iterator<E> iterator, final Predicate<? super E> predicate) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    if (iterator != null) {\n        while (iterator.hasNext()) {\n            final E element = iterator.next();\n            if (predicate.evaluate(element)) {\n                return element;\n            }\n        }\n    }\n    return null;\n}"
            ],
            [
                "indexOf",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Returns the index of the first element in the specified iterator that\n * matches the given predicate.\n * <p>\n * A <code>null</code> or empty iterator returns -1.\n *\n * @param <E> the element type\n * @param iterator  the iterator to search, may be null\n * @param predicate  the predicate to use, may not be null\n * @return the index of the first element which matches the predicate or -1 if none matches\n * @throws NullPointerException if predicate is null\n * @since 4.1\n */\npublic static <E> int indexOf(final Iterator<E> iterator, final Predicate<? super E> predicate) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    if (iterator != null) {\n        for (int index = 0; iterator.hasNext(); index++) {\n            final E element = iterator.next();\n            if (predicate.evaluate(element)) {\n                return index;\n            }\n        }\n    }\n    return -1;\n}"
            ],
            [
                "matchesAny",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Answers true if a predicate is true for any element of the iterator.\n * <p>\n * A <code>null</code> or empty iterator returns false.\n *\n * @param <E> the type of object the {@link Iterator} contains\n * @param iterator  the {@link Iterator} to use, may be null\n * @param predicate  the predicate to use, may not be null\n * @return true if any element of the collection matches the predicate, false otherwise\n * @throws NullPointerException if predicate is null\n * @since 4.1\n */\npublic static <E> boolean matchesAny(final Iterator<E> iterator, final Predicate<? super E> predicate) {\n    return indexOf(iterator, predicate) != -1;\n}"
            ],
            [
                "matchesAll",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Answers true if a predicate is true for every element of an iterator.\n * <p>\n * A <code>null</code> or empty iterator returns true.\n *\n * @param <E> the type of object the {@link Iterator} contains\n * @param iterator  the {@link Iterator} to use, may be null\n * @param predicate  the predicate to use, may not be null\n * @return true if every element of the collection matches the predicate or if the\n *   collection is empty, false otherwise\n * @throws NullPointerException if predicate is null\n * @since 4.1\n */\npublic static <E> boolean matchesAll(final Iterator<E> iterator, final Predicate<? super E> predicate) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    if (iterator != null) {\n        while (iterator.hasNext()) {\n            final E element = iterator.next();\n            if (!predicate.evaluate(element)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
            ],
            [
                "isEmpty",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Checks if the given iterator is empty.\n * <p>\n * A <code>null</code> or empty iterator returns true.\n *\n * @param iterator  the {@link Iterator} to use, may be null\n * @return true if the iterator is exhausted or null, false otherwise\n * @since 4.1\n */\npublic static boolean isEmpty(final Iterator<?> iterator) {\n    return iterator == null || !iterator.hasNext();\n}"
            ],
            [
                "contains",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Checks if the object is contained in the given iterator.\n * <p>\n * A <code>null</code> or empty iterator returns false.\n *\n * @param <E> the type of object the {@link Iterator} contains\n * @param iterator  the iterator to check, may be null\n * @param object  the object to check\n * @return true if the object is contained in the iterator, false otherwise\n * @since 4.1\n */\npublic static <E> boolean contains(final Iterator<E> iterator, final Object object) {\n    return matchesAny(iterator, EqualPredicate.equalPredicate(object));\n}"
            ],
            [
                "get",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Returns the <code>index</code>-th value in {@link Iterator}, throwing\n * <code>IndexOutOfBoundsException</code> if there is no such element.\n * <p>\n * The Iterator is advanced to <code>index</code> (or to the end, if\n * <code>index</code> exceeds the number of entries) as a side effect of this method.\n *\n * @param <E> the type of object in the {@link Iterator}\n * @param iterator  the iterator to get a value from\n * @param index  the index to get\n * @return the object at the specified index\n * @throws IndexOutOfBoundsException if the index is invalid\n * @since 4.1\n */\npublic static <E> E get(final Iterator<E> iterator, final int index) {\n    int i = index;\n    CollectionUtils.checkIndexBounds(i);\n    while (iterator.hasNext()) {\n        i--;\n        if (i == -1) {\n            return iterator.next();\n        }\n        iterator.next();\n    }\n    throw new IndexOutOfBoundsException(\"Entry does not exist: \" + i);\n}"
            ],
            [
                "size",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Returns the number of elements contained in the given iterator.\n * <p>\n * A <code>null</code> or empty iterator returns {@code 0}.\n *\n * @param iterator  the iterator to check, may be null\n * @return the number of elements contained in the iterator\n * @since 4.1\n */\npublic static int size(final Iterator<?> iterator) {\n    int size = 0;\n    if (iterator != null) {\n        while (iterator.hasNext()) {\n            iterator.next();\n            size++;\n        }\n    }\n    return size;\n}"
            ],
            [
                "toString",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Returns a string representation of the elements of the specified iterator.\n * <p>\n * The string representation consists of a list of the iterator's elements,\n * enclosed in square brackets ({@code \"[]\"}). Adjacent elements are separated\n * by the characters {@code \", \"} (a comma followed by a space). Elements are\n * converted to strings as by {@code String.valueOf(Object)}.\n *\n * @param <E> the element type\n * @param iterator  the iterator to convert to a string, may be null\n * @return a string representation of {@code iterator}\n * @since 4.1\n */\npublic static <E> String toString(final Iterator<E> iterator) {\n    return toString(iterator, TransformerUtils.stringValueTransformer(), DEFAULT_TOSTRING_DELIMITER, DEFAULT_TOSTRING_PREFIX, DEFAULT_TOSTRING_SUFFIX);\n}"
            ],
            [
                "toString",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Returns a string representation of the elements of the specified iterator.\n * <p>\n * The string representation consists of a list of the iterable's elements,\n * enclosed in square brackets ({@code \"[]\"}). Adjacent elements are separated\n * by the characters {@code \", \"} (a comma followed by a space). Elements are\n * converted to strings as by using the provided {@code transformer}.\n *\n * @param <E> the element type\n * @param iterator  the iterator to convert to a string, may be null\n * @param transformer  the transformer used to get a string representation of an element\n * @return a string representation of {@code iterator}\n * @throws NullPointerException if {@code transformer} is null\n * @since 4.1\n */\npublic static <E> String toString(final Iterator<E> iterator, final Transformer<? super E, String> transformer) {\n    return toString(iterator, transformer, DEFAULT_TOSTRING_DELIMITER, DEFAULT_TOSTRING_PREFIX, DEFAULT_TOSTRING_SUFFIX);\n}"
            ],
            [
                "toString",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * Returns a string representation of the elements of the specified iterator.\n * <p>\n * The string representation consists of a list of the iterator's elements,\n * enclosed by the provided {@code prefix} and {@code suffix}. Adjacent elements\n * are separated by the provided {@code delimiter}. Elements are converted to\n * strings as by using the provided {@code transformer}.\n *\n * @param <E> the element type\n * @param iterator  the iterator to convert to a string, may be null\n * @param transformer  the transformer used to get a string representation of an element\n * @param delimiter  the string to delimit elements\n * @param prefix  the prefix, prepended to the string representation\n * @param suffix  the suffix, appended to the string representation\n * @return a string representation of {@code iterator}\n * @throws NullPointerException if either transformer, delimiter, prefix or suffix is null\n * @since 4.1\n */\npublic static <E> String toString(final Iterator<E> iterator, final Transformer<? super E, String> transformer, final String delimiter, final String prefix, final String suffix) {\n    if (transformer == null) {\n        throw new NullPointerException(\"transformer may not be null\");\n    }\n    if (delimiter == null) {\n        throw new NullPointerException(\"delimiter may not be null\");\n    }\n    if (prefix == null) {\n        throw new NullPointerException(\"prefix may not be null\");\n    }\n    if (suffix == null) {\n        throw new NullPointerException(\"suffix may not be null\");\n    }\n    final StringBuilder stringBuilder = new StringBuilder(prefix);\n    if (iterator != null) {\n        while (iterator.hasNext()) {\n            final E element = iterator.next();\n            stringBuilder.append(transformer.transform(element));\n            stringBuilder.append(delimiter);\n        }\n        if (stringBuilder.length() > prefix.length()) {\n            stringBuilder.setLength(stringBuilder.length() - delimiter.length());\n        }\n    }\n    stringBuilder.append(suffix);\n    return stringBuilder.toString();\n}"
            ],
            [
                "naturalComparator",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Gets a comparator that uses the natural order of the objects.\n *\n * @param <E>  the object type to compare\n * @return  a comparator which uses natural order\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E extends Comparable<? super E>> Comparator<E> naturalComparator() {\n    return NATURAL_COMPARATOR;\n}"
            ],
            [
                "chainedComparator",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Gets a comparator that compares using an array of {@link Comparator}s, applied\n * in sequence until one returns not equal or the array is exhausted.\n *\n * @param <E>  the object type to compare\n * @param comparators  the comparators to use, not null or empty or containing nulls\n * @return a {@link ComparatorChain} formed from the input comparators\n * @throws NullPointerException if comparators array is null or contains a null\n * @see ComparatorChain\n */\npublic static <E> Comparator<E> chainedComparator(final Comparator<E>... comparators) {\n    final ComparatorChain<E> chain = new ComparatorChain<E>();\n    for (final Comparator<E> comparator : comparators) {\n        if (comparator == null) {\n            throw new NullPointerException(\"Comparator cannot be null\");\n        }\n        chain.addComparator(comparator);\n    }\n    return chain;\n}"
            ],
            [
                "chainedComparator",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Gets a comparator that compares using a collection of {@link Comparator}s,\n * applied in (default iterator) sequence until one returns not equal or the\n * collection is exhausted.\n *\n * @param <E>  the object type to compare\n * @param comparators  the comparators to use, not null or empty or containing nulls\n * @return a {@link ComparatorChain} formed from the input comparators\n * @throws NullPointerException if comparators collection is null or contains a null\n * @throws ClassCastException if the comparators collection contains the wrong object type\n * @see ComparatorChain\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Comparator<E> chainedComparator(final Collection<Comparator<E>> comparators) {\n    return chainedComparator((Comparator<E>[]) comparators.toArray(new Comparator[comparators.size()]));\n}"
            ],
            [
                "reversedComparator",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Gets a comparator that reverses the order of the given comparator.\n *\n * @param <E>  the object type to compare\n * @param comparator  the comparator to reverse\n * @return  a comparator that reverses the order of the input comparator\n * @see ReverseComparator\n */\npublic static <E> Comparator<E> reversedComparator(final Comparator<E> comparator) {\n    return new ReverseComparator<E>(comparator);\n}"
            ],
            [
                "booleanComparator",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Gets a Comparator that can sort Boolean objects.\n * <p>\n * The parameter specifies whether true or false is sorted first.\n * <p>\n * The comparator throws NullPointerException if a null value is compared.\n *\n * @param trueFirst  when <code>true</code>, sort\n *        <code>true</code> {@link Boolean}s before\n *        <code>false</code> {@link Boolean}s.\n * @return  a comparator that sorts booleans\n */\npublic static Comparator<Boolean> booleanComparator(final boolean trueFirst) {\n    return BooleanComparator.booleanComparator(trueFirst);\n}"
            ],
            [
                "nullLowComparator",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Gets a Comparator that controls the comparison of <code>null</code> values.\n * <p>\n * The returned comparator will consider a null value to be less than\n * any nonnull value, and equal to any other null value.  Two nonnull\n * values will be evaluated with the given comparator.\n *\n * @param <E>  the object type to compare\n * @param comparator the comparator that wants to allow nulls\n * @return  a version of that comparator that allows nulls\n * @see NullComparator\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Comparator<E> nullLowComparator(Comparator<E> comparator) {\n    if (comparator == null) {\n        comparator = NATURAL_COMPARATOR;\n    }\n    return new NullComparator<E>(comparator, false);\n}"
            ],
            [
                "nullHighComparator",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Gets a Comparator that controls the comparison of <code>null</code> values.\n * <p>\n * The returned comparator will consider a null value to be greater than\n * any nonnull value, and equal to any other null value.  Two nonnull\n * values will be evaluated with the given comparator.\n *\n * @param <E>  the object type to compare\n * @param comparator the comparator that wants to allow nulls\n * @return  a version of that comparator that allows nulls\n * @see NullComparator\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Comparator<E> nullHighComparator(Comparator<E> comparator) {\n    if (comparator == null) {\n        comparator = NATURAL_COMPARATOR;\n    }\n    return new NullComparator<E>(comparator, true);\n}"
            ],
            [
                "transformedComparator",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Gets a Comparator that passes transformed objects to the given comparator.\n * <p>\n * Objects passed to the returned comparator will first be transformed\n * by the given transformer before they are compared by the given\n * comparator.\n *\n * @param <I>  the input object type of the transformed comparator\n * @param <O>  the object type of the decorated comparator\n * @param comparator  the sort order to use\n * @param transformer  the transformer to use\n * @return  a comparator that transforms its input objects before comparing them\n * @see  TransformingComparator\n */\n@SuppressWarnings(\"unchecked\")\npublic static <I, O> Comparator<I> transformedComparator(Comparator<O> comparator, final Transformer<? super I, ? extends O> transformer) {\n    if (comparator == null) {\n        comparator = NATURAL_COMPARATOR;\n    }\n    return new TransformingComparator<I, O>(transformer, comparator);\n}"
            ],
            [
                "min",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Returns the smaller of the given objects according to the given\n * comparator, returning the second object if the comparator\n * returns equal.\n *\n * @param <E>  the object type to compare\n * @param o1  the first object to compare\n * @param o2  the second object to compare\n * @param comparator  the sort order to use\n * @return  the smaller of the two objects\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> E min(final E o1, final E o2, Comparator<E> comparator) {\n    if (comparator == null) {\n        comparator = NATURAL_COMPARATOR;\n    }\n    final int c = comparator.compare(o1, o2);\n    return c < 0 ? o1 : o2;\n}"
            ],
            [
                "max",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Returns the larger of the given objects according to the given\n * comparator, returning the second object if the comparator\n * returns equal.\n *\n * @param <E>  the object type to compare\n * @param o1  the first object to compare\n * @param o2  the second object to compare\n * @param comparator  the sort order to use\n * @return  the larger of the two objects\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> E max(final E o1, final E o2, Comparator<E> comparator) {\n    if (comparator == null) {\n        comparator = NATURAL_COMPARATOR;\n    }\n    final int c = comparator.compare(o1, o2);\n    return c > 0 ? o1 : o2;\n}"
            ],
            [
                "unmodifiableBidiMap",
                "org.apache.commons.collections4.bidimap",
                "UnmodifiableBidiMap",
                "/**\n * Factory method to create an unmodifiable map.\n * <p>\n * If the map passed in is already unmodifiable, it is returned.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the map to decorate, must not be null\n * @return an unmodifiable BidiMap\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> BidiMap<K, V> unmodifiableBidiMap(final BidiMap<? extends K, ? extends V> map) {\n    if (map instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final BidiMap<K, V> tmpMap = (BidiMap<K, V>) map;\n        return tmpMap;\n    }\n    return new UnmodifiableBidiMap<K, V>(map);\n}"
            ],
            [
                "unmodifiableOrderedBidiMap",
                "org.apache.commons.collections4.bidimap",
                "UnmodifiableOrderedBidiMap",
                "/**\n * Factory method to create an unmodifiable map.\n * <p>\n * If the map passed in is already unmodifiable, it is returned.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the map to decorate, must not be null\n * @return an unmodifiable OrderedBidiMap\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> OrderedBidiMap<K, V> unmodifiableOrderedBidiMap(final OrderedBidiMap<? extends K, ? extends V> map) {\n    if (map instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final OrderedBidiMap<K, V> tmpMap = (OrderedBidiMap<K, V>) map;\n        return tmpMap;\n    }\n    return new UnmodifiableOrderedBidiMap<K, V>(map);\n}"
            ],
            [
                "unmodifiableSortedBidiMap",
                "org.apache.commons.collections4.bidimap",
                "UnmodifiableSortedBidiMap",
                "/**\n * Factory method to create an unmodifiable map.\n * <p>\n * If the map passed in is already unmodifiable, it is returned.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the map to decorate, must not be null\n * @return an unmodifiable SortedBidiMap\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> SortedBidiMap<K, V> unmodifiableSortedBidiMap(final SortedBidiMap<K, ? extends V> map) {\n    if (map instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final SortedBidiMap<K, V> tmpMap = (SortedBidiMap<K, V>) map;\n        return tmpMap;\n    }\n    return new UnmodifiableSortedBidiMap<K, V>(map);\n}"
            ],
            [
                "emptyMultiValuedMap",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "/**\n * Returns immutable EMPTY_MULTI_VALUED_MAP with generic type safety.\n *\n * @param <K> the type of key in the map\n * @param <V> the type of value in the map\n * @return immutable and empty <code>MultiValuedMap</code>\n */\n@SuppressWarnings(\"unchecked\")\npublic static <K, V> MultiValuedMap<K, V> emptyMultiValuedMap() {\n    return EMPTY_MULTI_VALUED_MAP;\n}"
            ],
            [
                "emptyIfNull",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "// Null safe methods\n/**\n * Returns an immutable empty <code>MultiValuedMap</code> if the argument is\n * <code>null</code>, or the argument itself otherwise.\n *\n * @param <K> the type of key in the map\n * @param <V> the type of value in the map\n * @param map  the map, may be null\n * @return an empty {@link MultiValuedMap} if the argument is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <K, V> MultiValuedMap<K, V> emptyIfNull(final MultiValuedMap<K, V> map) {\n    return map == null ? EMPTY_MULTI_VALUED_MAP : map;\n}"
            ],
            [
                "isEmpty",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "/**\n * Null-safe check if the specified <code>MultiValuedMap</code> is empty.\n * <p>\n * If the provided map is null, returns true.\n *\n * @param map  the map to check, may be null\n * @return true if the map is empty or null\n */\npublic static boolean isEmpty(final MultiValuedMap<?, ?> map) {\n    return map == null || map.isEmpty();\n}"
            ],
            [
                "getCollection",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "// Null safe getters\n// -------------------------------------------------------------------------\n/**\n * Gets a Collection from <code>MultiValuedMap</code> in a null-safe manner.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the {@link MultiValuedMap} to use\n * @param key  the key to look up\n * @return the Collection in the {@link MultiValuedMap}, or null if input map is null\n */\npublic static <K, V> Collection<V> getCollection(final MultiValuedMap<K, V> map, final K key) {\n    if (map != null) {\n        return map.get(key);\n    }\n    return null;\n}"
            ],
            [
                "getValuesAsList",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "// TODO: review the getValuesAsXXX methods - depending on the actual MultiValuedMap type, changes\n// to the returned collection might update the backing map. This should be clarified and/or prevented.\n/**\n * Gets a List from <code>MultiValuedMap</code> in a null-safe manner.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the {@link MultiValuedMap} to use\n * @param key  the key to look up\n * @return the Collection in the {@link MultiValuedMap} as List, or null if input map is null\n */\npublic static <K, V> List<V> getValuesAsList(final MultiValuedMap<K, V> map, final K key) {\n    if (map != null) {\n        Collection<V> col = map.get(key);\n        if (col instanceof List) {\n            return (List<V>) col;\n        }\n        return new ArrayList<V>(col);\n    }\n    return null;\n}"
            ],
            [
                "getValuesAsSet",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "/**\n * Gets a Set from <code>MultiValuedMap</code> in a null-safe manner.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the {@link MultiValuedMap} to use\n * @param key  the key to look up\n * @return the Collection in the {@link MultiValuedMap} as Set, or null if input map is null\n */\npublic static <K, V> Set<V> getValuesAsSet(final MultiValuedMap<K, V> map, final K key) {\n    if (map != null) {\n        Collection<V> col = map.get(key);\n        if (col instanceof Set) {\n            return (Set<V>) col;\n        }\n        return new HashSet<V>(col);\n    }\n    return null;\n}"
            ],
            [
                "getValuesAsBag",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "/**\n * Gets a Bag from <code>MultiValuedMap</code> in a null-safe manner.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the {@link MultiValuedMap} to use\n * @param key  the key to look up\n * @return the Collection in the {@link MultiValuedMap} as Bag, or null if input map is null\n */\npublic static <K, V> Bag<V> getValuesAsBag(final MultiValuedMap<K, V> map, final K key) {\n    if (map != null) {\n        Collection<V> col = map.get(key);\n        if (col instanceof Bag) {\n            return (Bag<V>) col;\n        }\n        return new HashBag<V>(col);\n    }\n    return null;\n}"
            ],
            [
                "newListValuedHashMap",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "// Factory Methods\n// -----------------------------------------------------------------------\n/**\n * Creates a {@link ListValuedMap} with an {@link java.util.ArrayList ArrayList} as\n * collection class to store the values mapped to a key.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @return a new <code>ListValuedMap</code>\n */\npublic static <K, V> ListValuedMap<K, V> newListValuedHashMap() {\n    return new ArrayListValuedHashMap<K, V>();\n}"
            ],
            [
                "newSetValuedHashMap",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "/**\n * Creates a {@link SetValuedMap} with an {@link java.util.HashSet HashSet} as\n * collection class to store the values mapped to a key.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @return a new {@link SetValuedMap}\n */\npublic static <K, V> SetValuedMap<K, V> newSetValuedHashMap() {\n    return new HashSetValuedHashMap<K, V>();\n}"
            ],
            [
                "unmodifiableMultiValuedMap",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "// MultiValuedMap Decorators\n// -----------------------------------------------------------------------\n/**\n * Returns an <code>UnmodifiableMultiValuedMap</code> backed by the given\n * map.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the {@link MultiValuedMap} to decorate, must not be null\n * @return an unmodifiable {@link MultiValuedMap} backed by the provided map\n * @throws NullPointerException if map is null\n */\npublic static <K, V> MultiValuedMap<K, V> unmodifiableMultiValuedMap(final MultiValuedMap<? extends K, ? extends V> map) {\n    return UnmodifiableMultiValuedMap.<K, V>unmodifiableMultiValuedMap(map);\n}"
            ],
            [
                "transformedMultiValuedMap",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "/**\n * Returns a <code>TransformedMultiValuedMap</code> backed by the given map.\n * <p>\n * This method returns a new <code>MultiValuedMap</code> (decorating the\n * specified map) that will transform any new entries added to it. Existing\n * entries in the specified map will not be transformed. If you want that\n * behaviour, see {@link TransformedMultiValuedMap#transformedMap}.\n * <p>\n * Each object is passed through the transformers as it is added to the Map.\n * It is important not to use the original map after invoking this method,\n * as it is a back door for adding untransformed objects.\n * <p>\n * If there are any elements already in the map being decorated, they are\n * NOT transformed.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the {@link MultiValuedMap} to transform, must not be null, typically empty\n * @param keyTransformer  the transformer for the map keys, null means no transformation\n * @param valueTransformer  the transformer for the map values, null means no transformation\n * @return a transformed <code>MultiValuedMap</code> backed by the given map\n * @throws NullPointerException if map is null\n */\npublic static <K, V> MultiValuedMap<K, V> transformedMultiValuedMap(final MultiValuedMap<K, V> map, final Transformer<? super K, ? extends K> keyTransformer, final Transformer<? super V, ? extends V> valueTransformer) {\n    return TransformedMultiValuedMap.transformingMap(map, keyTransformer, valueTransformer);\n}"
            ],
            [
                "unmodifiableBoundedCollection",
                "org.apache.commons.collections4.collection",
                "UnmodifiableBoundedCollection",
                "/**\n * Factory method to create an unmodifiable bounded collection.\n *\n * @param <E> the type of the elements in the collection\n * @param coll  the <code>BoundedCollection</code> to decorate, must not be null\n * @return a new unmodifiable bounded collection\n * @throws NullPointerException if {@code coll} is {@code null}\n * @since 4.0\n */\npublic static <E> BoundedCollection<E> unmodifiableBoundedCollection(final BoundedCollection<? extends E> coll) {\n    if (coll instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final BoundedCollection<E> tmpColl = (BoundedCollection<E>) coll;\n        return tmpColl;\n    }\n    return new UnmodifiableBoundedCollection<E>(coll);\n}"
            ],
            [
                "unmodifiableBoundedCollection",
                "org.apache.commons.collections4.collection",
                "UnmodifiableBoundedCollection",
                "/**\n * Factory method to create an unmodifiable bounded collection.\n * <p>\n * This method is capable of drilling down through up to 1000 other decorators\n * to find a suitable BoundedCollection.\n *\n * @param <E> the type of the elements in the collection\n * @param coll  the <code>BoundedCollection</code> to decorate, must not be null\n * @return a new unmodifiable bounded collection\n * @throws NullPointerException if coll is null\n * @throws IllegalArgumentException if coll is not a {@code BoundedCollection}\n * @since 4.0\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> BoundedCollection<E> unmodifiableBoundedCollection(Collection<? extends E> coll) {\n    if (coll == null) {\n        throw new NullPointerException(\"Collection must not be null.\");\n    }\n    // handle decorators\n    for (int i = 0; i < 1000; i++) {\n        // counter to prevent infinite looping\n        if (coll instanceof BoundedCollection) {\n            // normal loop exit\n            break;\n        }\n        if (coll instanceof AbstractCollectionDecorator) {\n            coll = ((AbstractCollectionDecorator<E>) coll).decorated();\n        } else if (coll instanceof SynchronizedCollection) {\n            coll = ((SynchronizedCollection<E>) coll).decorated();\n        }\n    }\n    if (coll instanceof BoundedCollection == false) {\n        throw new IllegalArgumentException(\"Collection is not a bounded collection.\");\n    }\n    return new UnmodifiableBoundedCollection<E>((BoundedCollection<E>) coll);\n}"
            ],
            [
                "transformingCollection",
                "org.apache.commons.collections4.collection",
                "TransformedCollection",
                "/**\n * Factory method to create a transforming collection.\n * <p>\n * If there are any elements already in the collection being decorated, they\n * are NOT transformed.\n * Contrast this with {@link #transformedCollection(Collection, Transformer)}.\n *\n * @param <E> the type of the elements in the collection\n * @param coll  the collection to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed collection\n * @throws NullPointerException if collection or transformer is null\n * @since 4.0\n */\npublic static <E> TransformedCollection<E> transformingCollection(final Collection<E> coll, final Transformer<? super E, ? extends E> transformer) {\n    return new TransformedCollection<E>(coll, transformer);\n}"
            ],
            [
                "transformedCollection",
                "org.apache.commons.collections4.collection",
                "TransformedCollection",
                "/**\n * Factory method to create a transforming collection that will transform\n * existing contents of the specified collection.\n * <p>\n * If there are any elements already in the collection being decorated, they\n * will be transformed by this method.\n * Contrast this with {@link #transformingCollection(Collection, Transformer)}.\n *\n * @param <E> the type of the elements in the collection\n * @param collection  the collection to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed Collection\n * @throws NullPointerException if collection or transformer is null\n * @since 4.0\n */\npublic static <E> TransformedCollection<E> transformedCollection(final Collection<E> collection, final Transformer<? super E, ? extends E> transformer) {\n    final TransformedCollection<E> decorated = new TransformedCollection<E>(collection, transformer);\n    // null collection & transformer are disallowed by the constructor call above\n    if (collection.size() > 0) {\n        // collection is of type E\n        @SuppressWarnings(\"unchecked\")\n        final E[] // NOPMD - false positive for generics\n        values = (E[]) collection.toArray();\n        collection.clear();\n        for (final E value : values) {\n            decorated.decorated().add(transformer.transform(value));\n        }\n    }\n    return decorated;\n}"
            ],
            [
                "builder",
                "org.apache.commons.collections4.collection",
                "PredicatedCollection",
                "/**\n * Returns a Builder with the given predicate.\n *\n * @param <E>  the element type\n * @param predicate  the predicate to use\n * @return a new Builder for predicated collections\n * @since 4.1\n */\npublic static <E> Builder<E> builder(final Predicate<? super E> predicate) {\n    return new Builder<E>(predicate);\n}"
            ],
            [
                "notNullBuilder",
                "org.apache.commons.collections4.collection",
                "PredicatedCollection",
                "/**\n * Returns a Builder with a NotNullPredicate.\n *\n * @param <E>  the element type\n * @return a new Builder for predicated collections that ignores null values.\n * @since 4.1\n */\npublic static <E> Builder<E> notNullBuilder() {\n    return new Builder<E>(NotNullPredicate.<E>notNullPredicate());\n}"
            ],
            [
                "predicatedCollection",
                "org.apache.commons.collections4.collection",
                "PredicatedCollection",
                "/**\n * Factory method to create a predicated (validating) collection.\n * <p>\n * If there are any elements already in the collection being decorated, they\n * are validated.\n *\n * @param <T> the type of the elements in the collection\n * @param coll  the collection to decorate, must not be null\n * @param predicate  the predicate to use for validation, must not be null\n * @return a new predicated collection\n * @throws NullPointerException if collection or predicate is null\n * @throws IllegalArgumentException if the collection contains invalid elements\n * @since 4.0\n */\npublic static <T> PredicatedCollection<T> predicatedCollection(final Collection<T> coll, final Predicate<? super T> predicate) {\n    return new PredicatedCollection<T>(coll, predicate);\n}"
            ],
            [
                "uniqueIndexedCollection",
                "org.apache.commons.collections4.collection",
                "IndexedCollection",
                "/**\n * Create an {@link IndexedCollection} for a unique index.\n * <p>\n * If an element is added, which maps to an existing key, an {@link IllegalArgumentException}\n * will be thrown.\n *\n * @param <K> the index object type.\n * @param <C> the collection type.\n * @param coll the decorated {@link Collection}.\n * @param keyTransformer the {@link Transformer} for generating index keys.\n * @return the created {@link IndexedCollection}.\n */\npublic static <K, C> IndexedCollection<K, C> uniqueIndexedCollection(final Collection<C> coll, final Transformer<C, K> keyTransformer) {\n    return new IndexedCollection<K, C>(coll, keyTransformer, MultiValueMap.<K, C>multiValueMap(new HashMap<K, Collection<C>>()), true);\n}"
            ],
            [
                "nonUniqueIndexedCollection",
                "org.apache.commons.collections4.collection",
                "IndexedCollection",
                "/**\n * Create an {@link IndexedCollection} for a non-unique index.\n *\n * @param <K> the index object type.\n * @param <C> the collection type.\n * @param coll the decorated {@link Collection}.\n * @param keyTransformer the {@link Transformer} for generating index keys.\n * @return the created {@link IndexedCollection}.\n */\npublic static <K, C> IndexedCollection<K, C> nonUniqueIndexedCollection(final Collection<C> coll, final Transformer<C, K> keyTransformer) {\n    return new IndexedCollection<K, C>(coll, keyTransformer, MultiValueMap.<K, C>multiValueMap(new HashMap<K, Collection<C>>()), false);\n}"
            ],
            [
                "synchronizedCollection",
                "org.apache.commons.collections4.collection",
                "SynchronizedCollection",
                "/**\n * Factory method to create a synchronized collection.\n *\n * @param <T> the type of the elements in the collection\n * @param coll  the collection to decorate, must not be null\n * @return a new synchronized collection\n * @throws NullPointerException if collection is null\n * @since 4.0\n */\npublic static <T> SynchronizedCollection<T> synchronizedCollection(final Collection<T> coll) {\n    return new SynchronizedCollection<T>(coll);\n}"
            ],
            [
                "unmodifiableCollection",
                "org.apache.commons.collections4.collection",
                "UnmodifiableCollection",
                "/**\n * Factory method to create an unmodifiable collection.\n * <p>\n * If the collection passed in is already unmodifiable, it is returned.\n *\n * @param <T> the type of the elements in the collection\n * @param coll  the collection to decorate, must not be null\n * @return an unmodifiable collection\n * @throws NullPointerException if collection is null\n * @since 4.0\n */\npublic static <T> Collection<T> unmodifiableCollection(final Collection<? extends T> coll) {\n    if (coll instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final Collection<T> tmpColl = (Collection<T>) coll;\n        return tmpColl;\n    }\n    return new UnmodifiableCollection<T>(coll);\n}"
            ],
            [
                "exceptionFactory",
                "org.apache.commons.collections4",
                "FactoryUtils",
                "/**\n * Gets a Factory that always throws an exception.\n * This could be useful during testing as a placeholder.\n *\n * @see org.apache.commons.collections4.functors.ExceptionFactory\n *\n * @param <T> the type that the factory creates\n * @return the factory\n */\npublic static <T> Factory<T> exceptionFactory() {\n    return ExceptionFactory.<T>exceptionFactory();\n}"
            ],
            [
                "nullFactory",
                "org.apache.commons.collections4",
                "FactoryUtils",
                "/**\n * Gets a Factory that will return null each time the factory is used.\n * This could be useful during testing as a placeholder.\n *\n * @see org.apache.commons.collections4.functors.ConstantFactory\n * @param <T> the \"type\" of null object the factory should return.\n * @return the factory\n */\npublic static <T> Factory<T> nullFactory() {\n    return ConstantFactory.<T>constantFactory(null);\n}"
            ],
            [
                "constantFactory",
                "org.apache.commons.collections4",
                "FactoryUtils",
                "/**\n * Creates a Factory that will return the same object each time the factory\n * is used. No check is made that the object is immutable. In general, only\n * immutable objects should use the constant factory. Mutable objects should\n * use the prototype factory.\n *\n * @see org.apache.commons.collections4.functors.ConstantFactory\n *\n * @param <T> the type that the factory creates\n * @param constantToReturn  the constant object to return each time in the factory\n * @return the <code>constant</code> factory.\n */\npublic static <T> Factory<T> constantFactory(final T constantToReturn) {\n    return ConstantFactory.constantFactory(constantToReturn);\n}"
            ],
            [
                "prototypeFactory",
                "org.apache.commons.collections4",
                "FactoryUtils",
                "/**\n * Creates a Factory that will return a clone of the same prototype object\n * each time the factory is used. The prototype will be cloned using one of these\n * techniques (in order):\n * <ul>\n * <li>public clone method\n * <li>public copy constructor\n * <li>serialization clone\n * <ul>\n *\n * @see org.apache.commons.collections4.functors.PrototypeFactory\n *\n * @param <T> the type that the factory creates\n * @param prototype  the object to clone each time in the factory\n * @return the <code>prototype</code> factory, or a {@link ConstantFactory#NULL_INSTANCE} if\n * the {@code prototype} is {@code null}\n * @throws IllegalArgumentException if the prototype cannot be cloned\n */\npublic static <T> Factory<T> prototypeFactory(final T prototype) {\n    return PrototypeFactory.<T>prototypeFactory(prototype);\n}"
            ],
            [
                "instantiateFactory",
                "org.apache.commons.collections4",
                "FactoryUtils",
                "/**\n * Creates a Factory that can create objects of a specific type using\n * a no-args constructor.\n *\n * @see org.apache.commons.collections4.functors.InstantiateFactory\n *\n * @param <T> the type that the factory creates\n * @param classToInstantiate  the Class to instantiate each time in the factory\n * @return the <code>reflection</code> factory\n * @throws NullPointerException if the classToInstantiate is null\n */\npublic static <T> Factory<T> instantiateFactory(final Class<T> classToInstantiate) {\n    return InstantiateFactory.instantiateFactory(classToInstantiate, null, null);\n}"
            ],
            [
                "instantiateFactory",
                "org.apache.commons.collections4",
                "FactoryUtils",
                "/**\n * Creates a Factory that can create objects of a specific type using\n * the arguments specified to this method.\n *\n * @see org.apache.commons.collections4.functors.InstantiateFactory\n *\n * @param <T> the type that the factory creates\n * @param classToInstantiate  the Class to instantiate each time in the factory\n * @param paramTypes  parameter types for the constructor, can be null\n * @param args  the arguments to pass to the constructor, can be null\n * @return the <code>reflection</code> factory\n * @throws NullPointerException if the classToInstantiate is null\n * @throws IllegalArgumentException if the paramTypes and args don't match\n * @throws IllegalArgumentException if the constructor doesn't exist\n */\npublic static <T> Factory<T> instantiateFactory(final Class<T> classToInstantiate, final Class<?>[] paramTypes, final Object[] args) {\n    return InstantiateFactory.instantiateFactory(classToInstantiate, paramTypes, args);\n}"
            ],
            [
                "emptyIfNull",
                "org.apache.commons.collections4",
                "ListUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns an immutable empty list if the argument is <code>null</code>,\n * or the argument itself otherwise.\n *\n * @param <T> the element type\n * @param list the list, possibly <code>null</code>\n * @return an empty list if the argument is <code>null</code>\n */\npublic static <T> List<T> emptyIfNull(final List<T> list) {\n    return list == null ? Collections.<T>emptyList() : list;\n}"
            ],
            [
                "defaultIfNull",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns either the passed in list, or if the list is {@code null},\n * the value of {@code defaultList}.\n *\n * @param <T> the element type\n * @param list  the list, possibly {@code null}\n * @param defaultList  the returned values if list is {@code null}\n * @return an empty list if the argument is <code>null</code>\n * @since 4.0\n */\npublic static <T> List<T> defaultIfNull(final List<T> list, final List<T> defaultList) {\n    return list == null ? defaultList : list;\n}"
            ],
            [
                "intersection",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns a new list containing all elements that are contained in\n * both given lists.\n *\n * @param <E> the element type\n * @param list1  the first list\n * @param list2  the second list\n * @return  the intersection of those two lists\n * @throws NullPointerException if either list is null\n */\npublic static <E> List<E> intersection(final List<? extends E> list1, final List<? extends E> list2) {\n    final List<E> result = new ArrayList<E>();\n    List<? extends E> smaller = list1;\n    List<? extends E> larger = list2;\n    if (list1.size() > list2.size()) {\n        smaller = list2;\n        larger = list1;\n    }\n    final HashSet<E> hashSet = new HashSet<E>(smaller);\n    for (final E e : larger) {\n        if (hashSet.contains(e)) {\n            result.add(e);\n            hashSet.remove(e);\n        }\n    }\n    return result;\n}"
            ],
            [
                "subtract",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Subtracts all elements in the second list from the first list,\n * placing the results in a new list.\n * <p>\n * This differs from {@link List#removeAll(Collection)} in that\n * cardinality is respected; if <Code>list1</Code> contains two\n * occurrences of <Code>null</Code> and <Code>list2</Code> only\n * contains one occurrence, then the returned list will still contain\n * one occurrence.\n *\n * @param <E> the element type\n * @param list1  the list to subtract from\n * @param list2  the list to subtract\n * @return a new list containing the results\n * @throws NullPointerException if either list is null\n */\npublic static <E> List<E> subtract(final List<E> list1, final List<? extends E> list2) {\n    final ArrayList<E> result = new ArrayList<E>();\n    final HashBag<E> bag = new HashBag<E>(list2);\n    for (final E e : list1) {\n        if (!bag.remove(e, 1)) {\n            result.add(e);\n        }\n    }\n    return result;\n}"
            ],
            [
                "sum",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns the sum of the given lists.  This is their intersection\n * subtracted from their union.\n *\n * @param <E> the element type\n * @param list1  the first list\n * @param list2  the second list\n * @return  a new list containing the sum of those lists\n * @throws NullPointerException if either list is null\n */\npublic static <E> List<E> sum(final List<? extends E> list1, final List<? extends E> list2) {\n    return subtract(union(list1, list2), intersection(list1, list2));\n}"
            ],
            [
                "union",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns a new list containing the second list appended to the\n * first list.  The {@link List#addAll(Collection)} operation is\n * used to append the two given lists into a new list.\n *\n * @param <E> the element type\n * @param list1  the first list\n * @param list2  the second list\n * @return a new list containing the union of those lists\n * @throws NullPointerException if either list is null\n */\npublic static <E> List<E> union(final List<? extends E> list1, final List<? extends E> list2) {\n    final ArrayList<E> result = new ArrayList<E>(list1);\n    result.addAll(list2);\n    return result;\n}"
            ],
            [
                "select",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Selects all elements from input collection which match the given\n * predicate into an output list.\n * <p>\n * A <code>null</code> predicate matches no elements.\n *\n * @param <E> the element type\n * @param inputCollection  the collection to get the input from, may not be null\n * @param predicate  the predicate to use, may be null\n * @return the elements matching the predicate (new list)\n * @throws NullPointerException if the input list is null\n *\n * @since 4.0\n * @see CollectionUtils#select(Iterable, Predicate)\n */\npublic static <E> List<E> select(final Collection<? extends E> inputCollection, final Predicate<? super E> predicate) {\n    return CollectionUtils.select(inputCollection, predicate, new ArrayList<E>(inputCollection.size()));\n}"
            ],
            [
                "selectRejected",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Selects all elements from inputCollection which don't match the given\n * predicate into an output collection.\n * <p>\n * If the input predicate is <code>null</code>, the result is an empty list.\n *\n * @param <E> the element type\n * @param inputCollection the collection to get the input from, may not be null\n * @param predicate the predicate to use, may be null\n * @return the elements <b>not</b> matching the predicate (new list)\n * @throws NullPointerException if the input collection is null\n *\n * @since 4.0\n * @see CollectionUtils#selectRejected(Iterable, Predicate)\n */\npublic static <E> List<E> selectRejected(final Collection<? extends E> inputCollection, final Predicate<? super E> predicate) {\n    return CollectionUtils.selectRejected(inputCollection, predicate, new ArrayList<E>(inputCollection.size()));\n}"
            ],
            [
                "isEqualList",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Tests two lists for value-equality as per the equality contract in\n * {@link java.util.List#equals(java.lang.Object)}.\n * <p>\n * This method is useful for implementing <code>List</code> when you cannot\n * extend AbstractList. The method takes Collection instances to enable other\n * collection types to use the List implementation algorithm.\n * <p>\n * The relevant text (slightly paraphrased as this is a static method) is:\n * <blockquote>\n * Compares the two list objects for equality.  Returns\n * {@code true} if and only if both\n * lists have the same size, and all corresponding pairs of elements in\n * the two lists are <i>equal</i>.  (Two elements {@code e1} and\n * {@code e2} are <i>equal</i> if <tt>(e1==null ? e2==null :\n * e1.equals(e2))</tt>.)  In other words, two lists are defined to be\n * equal if they contain the same elements in the same order.  This\n * definition ensures that the equals method works properly across\n * different implementations of the {@code List} interface.\n * </blockquote>\n *\n * <b>Note:</b> The behaviour of this method is undefined if the lists are\n * modified during the equals comparison.\n *\n * @see java.util.List\n * @param list1  the first list, may be null\n * @param list2  the second list, may be null\n * @return whether the lists are equal by value comparison\n */\npublic static boolean isEqualList(final Collection<?> list1, final Collection<?> list2) {\n    if (list1 == list2) {\n        return true;\n    }\n    if (list1 == null || list2 == null || list1.size() != list2.size()) {\n        return false;\n    }\n    final Iterator<?> it1 = list1.iterator();\n    final Iterator<?> it2 = list2.iterator();\n    Object obj1 = null;\n    Object obj2 = null;\n    while (it1.hasNext() && it2.hasNext()) {\n        obj1 = it1.next();\n        obj2 = it2.next();\n        if (!(obj1 == null ? obj2 == null : obj1.equals(obj2))) {\n            return false;\n        }\n    }\n    return !(it1.hasNext() || it2.hasNext());\n}"
            ],
            [
                "hashCodeForList",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Generates a hash code using the algorithm specified in\n * {@link java.util.List#hashCode()}.\n * <p>\n * This method is useful for implementing <code>List</code> when you cannot\n * extend AbstractList. The method takes Collection instances to enable other\n * collection types to use the List implementation algorithm.\n *\n * @see java.util.List#hashCode()\n * @param list  the list to generate the hashCode for, may be null\n * @return the hash code\n */\npublic static int hashCodeForList(final Collection<?> list) {\n    if (list == null) {\n        return 0;\n    }\n    int hashCode = 1;\n    final Iterator<?> it = list.iterator();\n    while (it.hasNext()) {\n        final Object obj = it.next();\n        hashCode = 31 * hashCode + (obj == null ? 0 : obj.hashCode());\n    }\n    return hashCode;\n}"
            ],
            [
                "retainAll",
                "org.apache.commons.collections4",
                "ListUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns a List containing all the elements in <code>collection</code>\n * that are also in <code>retain</code>. The cardinality of an element <code>e</code>\n * in the returned list is the same as the cardinality of <code>e</code>\n * in <code>collection</code> unless <code>retain</code> does not contain <code>e</code>, in which\n * case the cardinality is zero. This method is useful if you do not wish to modify\n * the collection <code>c</code> and thus cannot call <code>collection.retainAll(retain);</code>.\n * <p>\n * This implementation iterates over <code>collection</code>, checking each element in\n * turn to see if it's contained in <code>retain</code>. If it's contained, it's added\n * to the returned list. As a consequence, it is advised to use a collection type for\n * <code>retain</code> that provides a fast (e.g. O(1)) implementation of\n * {@link Collection#contains(Object)}.\n *\n * @param <E>  the element type\n * @param collection  the collection whose contents are the target of the #retailAll operation\n * @param retain  the collection containing the elements to be retained in the returned collection\n * @return a <code>List</code> containing all the elements of <code>c</code>\n * that occur at least once in <code>retain</code>.\n * @throws NullPointerException if either parameter is null\n * @since 3.2\n */\npublic static <E> List<E> retainAll(final Collection<E> collection, final Collection<?> retain) {\n    final List<E> list = new ArrayList<E>(Math.min(collection.size(), retain.size()));\n    for (final E obj : collection) {\n        if (retain.contains(obj)) {\n            list.add(obj);\n        }\n    }\n    return list;\n}"
            ],
            [
                "removeAll",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Removes the elements in <code>remove</code> from <code>collection</code>. That is, this\n * method returns a list containing all the elements in <code>collection</code>\n * that are not in <code>remove</code>. The cardinality of an element <code>e</code>\n * in the returned collection is the same as the cardinality of <code>e</code>\n * in <code>collection</code> unless <code>remove</code> contains <code>e</code>, in which\n * case the cardinality is zero. This method is useful if you do not wish to modify\n * <code>collection</code> and thus cannot call <code>collection.removeAll(remove);</code>.\n * <p>\n * This implementation iterates over <code>collection</code>, checking each element in\n * turn to see if it's contained in <code>remove</code>. If it's not contained, it's added\n * to the returned list. As a consequence, it is advised to use a collection type for\n * <code>remove</code> that provides a fast (e.g. O(1)) implementation of\n * {@link Collection#contains(Object)}.\n *\n * @param <E>  the element type\n * @param collection  the collection from which items are removed (in the returned collection)\n * @param remove  the items to be removed from the returned <code>collection</code>\n * @return a <code>List</code> containing all the elements of <code>c</code> except\n * any elements that also occur in <code>remove</code>.\n * @throws NullPointerException if either parameter is null\n * @since 3.2\n */\npublic static <E> List<E> removeAll(final Collection<E> collection, final Collection<?> remove) {\n    final List<E> list = new ArrayList<E>();\n    for (final E obj : collection) {\n        if (!remove.contains(obj)) {\n            list.add(obj);\n        }\n    }\n    return list;\n}"
            ],
            [
                "synchronizedList",
                "org.apache.commons.collections4",
                "ListUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns a synchronized list backed by the given list.\n * <p>\n * You must manually synchronize on the returned list's iterator to\n * avoid non-deterministic behavior:\n *\n * <pre>\n * List list = ListUtils.synchronizedList(myList);\n * synchronized (list) {\n *     Iterator i = list.iterator();\n *     while (i.hasNext()) {\n *         process (i.next());\n *     }\n * }\n * </pre>\n *\n * This method is just a wrapper for {@link Collections#synchronizedList(List)}.\n *\n * @param <E> the element type\n * @param list  the list to synchronize, must not be null\n * @return a synchronized list backed by the given list\n * @throws NullPointerException if the list is null\n */\npublic static <E> List<E> synchronizedList(final List<E> list) {\n    return Collections.synchronizedList(list);\n}"
            ],
            [
                "unmodifiableList",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns an unmodifiable list backed by the given list.\n * <p>\n * This method uses the implementation in the decorators subpackage.\n *\n * @param <E>  the element type\n * @param list  the list to make unmodifiable, must not be null\n * @return an unmodifiable list backed by the given list\n * @throws NullPointerException if the list is null\n */\npublic static <E> List<E> unmodifiableList(final List<? extends E> list) {\n    return UnmodifiableList.unmodifiableList(list);\n}"
            ],
            [
                "predicatedList",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns a predicated (validating) list backed by the given list.\n * <p>\n * Only objects that pass the test in the given predicate can be added to the list.\n * Trying to add an invalid object results in an IllegalArgumentException.\n * It is important not to use the original list after invoking this method,\n * as it is a backdoor for adding invalid objects.\n *\n * @param <E> the element type\n * @param list  the list to predicate, must not be null\n * @param predicate  the predicate for the list, must not be null\n * @return a predicated list backed by the given list\n * @throws NullPointerException if the List or Predicate is null\n */\npublic static <E> List<E> predicatedList(final List<E> list, final Predicate<E> predicate) {\n    return PredicatedList.predicatedList(list, predicate);\n}"
            ],
            [
                "transformedList",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns a transformed list backed by the given list.\n * <p>\n * This method returns a new list (decorating the specified list) that\n * will transform any new entries added to it.\n * Existing entries in the specified list will not be transformed.\n * <p>\n * Each object is passed through the transformer as it is added to the\n * List. It is important not to use the original list after invoking this\n * method, as it is a backdoor for adding untransformed objects.\n * <p>\n * Existing entries in the specified list will not be transformed.\n * If you want that behaviour, see {@link TransformedList#transformedList}.\n *\n * @param <E> the element type\n * @param list  the list to predicate, must not be null\n * @param transformer  the transformer for the list, must not be null\n * @return a transformed list backed by the given list\n * @throws NullPointerException if the List or Transformer is null\n */\npublic static <E> List<E> transformedList(final List<E> list, final Transformer<? super E, ? extends E> transformer) {\n    return TransformedList.transformingList(list, transformer);\n}"
            ],
            [
                "lazyList",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns a \"lazy\" list whose elements will be created on demand.\n * <p>\n * When the index passed to the returned list's {@link List#get(int) get}\n * method is greater than the list's size, then the factory will be used\n * to create a new object and that object will be inserted at that index.\n * <p>\n * For instance:\n *\n * <pre>\n * Factory&lt;Date&gt; factory = new Factory&lt;Date&gt;() {\n *     public Date create() {\n *         return new Date();\n *     }\n * }\n * List&lt;Date&gt; lazy = ListUtils.lazyList(new ArrayList&lt;Date&gt;(), factory);\n * Date date = lazy.get(3);\n * </pre>\n *\n * After the above code is executed, <code>date</code> will refer to\n * a new <code>Date</code> instance.  Furthermore, that <code>Date</code>\n * instance is the fourth element in the list.  The first, second,\n * and third element are all set to <code>null</code>.\n *\n * @param <E> the element type\n * @param list  the list to make lazy, must not be null\n * @param factory  the factory for creating new objects, must not be null\n * @return a lazy list backed by the given list\n * @throws NullPointerException if the List or Factory is null\n */\npublic static <E> List<E> lazyList(final List<E> list, final Factory<? extends E> factory) {\n    return LazyList.lazyList(list, factory);\n}"
            ],
            [
                "fixedSizeList",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns a fixed-sized list backed by the given list.\n * Elements may not be added or removed from the returned list, but\n * existing elements can be changed (for instance, via the\n * {@link List#set(int, Object)} method).\n *\n * @param <E>  the element type\n * @param list  the list whose size to fix, must not be null\n * @return a fixed-size list backed by that list\n * @throws NullPointerException  if the List is null\n */\npublic static <E> List<E> fixedSizeList(final List<E> list) {\n    return FixedSizeList.fixedSizeList(list);\n}"
            ],
            [
                "indexOf",
                "org.apache.commons.collections4",
                "ListUtils",
                "//-----------------------------------------------------------------------\n/**\n * Finds the first index in the given List which matches the given predicate.\n * <p>\n * If the input List or predicate is null, or no element of the List\n * matches the predicate, -1 is returned.\n *\n * @param <E>  the element type\n * @param list the List to search, may be null\n * @param predicate  the predicate to use, may be null\n * @return the first index of an Object in the List which matches the predicate or -1 if none could be found\n */\npublic static <E> int indexOf(final List<E> list, final Predicate<E> predicate) {\n    if (list != null && predicate != null) {\n        for (int i = 0; i < list.size(); i++) {\n            final E item = list.get(i);\n            if (predicate.evaluate(item)) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}"
            ],
            [
                "longestCommonSubsequence",
                "org.apache.commons.collections4",
                "ListUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns the longest common subsequence (LCS) of two sequences (lists).\n *\n * @param <E>  the element type\n * @param a  the first list\n * @param b  the second list\n * @return the longest common subsequence\n * @throws NullPointerException if either list is {@code null}\n * @since 4.0\n */\npublic static <E> List<E> longestCommonSubsequence(final List<E> a, final List<E> b) {\n    return longestCommonSubsequence(a, b, DefaultEquator.defaultEquator());\n}"
            ],
            [
                "longestCommonSubsequence",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns the longest common subsequence (LCS) of two sequences (lists).\n *\n * @param <E>  the element type\n * @param a  the first list\n * @param b  the second list\n * @param equator  the equator used to test object equality\n * @return the longest common subsequence\n * @throws NullPointerException if either list or the equator is {@code null}\n * @since 4.0\n */\npublic static <E> List<E> longestCommonSubsequence(final List<E> a, final List<E> b, final Equator<? super E> equator) {\n    if (a == null || b == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (equator == null) {\n        throw new NullPointerException(\"Equator must not be null\");\n    }\n    final SequencesComparator<E> comparator = new SequencesComparator<E>(a, b, equator);\n    final EditScript<E> script = comparator.getScript();\n    final LcsVisitor<E> visitor = new LcsVisitor<E>();\n    script.visit(visitor);\n    return visitor.getSubSequence();\n}"
            ],
            [
                "longestCommonSubsequence",
                "org.apache.commons.collections4",
                "ListUtils",
                "/**\n * Returns the longest common subsequence (LCS) of two {@link CharSequence} objects.\n * <p>\n * This is a convenience method for using {@link #longestCommonSubsequence(List, List)}\n * with {@link CharSequence} instances.\n *\n * @param a  the first sequence\n * @param b  the second sequence\n * @return the longest common subsequence as {@link String}\n * @throws NullPointerException if either sequence is {@code null}\n * @since 4.0\n */\npublic static String longestCommonSubsequence(final CharSequence a, final CharSequence b) {\n    if (a == null || b == null) {\n        throw new NullPointerException(\"CharSequence must not be null\");\n    }\n    final List<Character> lcs = longestCommonSubsequence(new CharSequenceAsList(a), new CharSequenceAsList(b));\n    final StringBuilder sb = new StringBuilder();\n    for (Character ch : lcs) {\n        sb.append(ch);\n    }\n    return sb.toString();\n}"
            ],
            [
                "partition",
                "org.apache.commons.collections4",
                "ListUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns consecutive {@link List#subList(int, int) sublists} of a\n * list, each of the same size (the final list may be smaller). For example,\n * partitioning a list containing {@code [a, b, c, d, e]} with a partition\n * size of 3 yields {@code [[a, b, c], [d, e]]} -- an outer list containing\n * two inner lists of three and two elements, all in the original order.\n * <p>\n * The outer list is unmodifiable, but reflects the latest state of the\n * source list. The inner lists are sublist views of the original list,\n * produced on demand using {@link List#subList(int, int)}, and are subject\n * to all the usual caveats about modification as explained in that API.\n * <p>\n * Adapted from http://code.google.com/p/guava-libraries/\n *\n * @param <T> the element type\n * @param list  the list to return consecutive sublists of\n * @param size  the desired size of each sublist (the last may be smaller)\n * @return a list of consecutive sublists\n * @throws NullPointerException if list is null\n * @throws IllegalArgumentException if size is not strictly positive\n * @since 4.0\n */\npublic static <T> List<List<T>> partition(final List<T> list, final int size) {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (size <= 0) {\n        throw new IllegalArgumentException(\"Size must be greater than 0\");\n    }\n    return new Partition<T>(list, size);\n}"
            ],
            [
                "getObject",
                "org.apache.commons.collections4",
                "MapUtils",
                "// Type safe getters\n//-------------------------------------------------------------------------\n/**\n * Gets from a Map in a null-safe manner.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map, <code>null</code> if null map input\n */\npublic static <K, V> V getObject(final Map<? super K, V> map, final K key) {\n    if (map != null) {\n        return map.get(key);\n    }\n    return null;\n}"
            ],
            [
                "getString",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a String from a Map in a null-safe manner.\n * <p>\n * The String is obtained via <code>toString</code>.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a String, <code>null</code> if null map input\n */\npublic static <K> String getString(final Map<? super K, ?> map, final K key) {\n    if (map != null) {\n        final Object answer = map.get(key);\n        if (answer != null) {\n            return answer.toString();\n        }\n    }\n    return null;\n}"
            ],
            [
                "getBoolean",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a Boolean from a Map in a null-safe manner.\n * <p>\n * If the value is a <code>Boolean</code> it is returned directly.\n * If the value is a <code>String</code> and it equals 'true' ignoring case\n * then <code>true</code> is returned, otherwise <code>false</code>.\n * If the value is a <code>Number</code> an integer zero value returns\n * <code>false</code> and non-zero returns <code>true</code>.\n * Otherwise, <code>null</code> is returned.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a Boolean, <code>null</code> if null map input\n */\npublic static <K> Boolean getBoolean(final Map<? super K, ?> map, final K key) {\n    if (map != null) {\n        final Object answer = map.get(key);\n        if (answer != null) {\n            if (answer instanceof Boolean) {\n                return (Boolean) answer;\n            }\n            if (answer instanceof String) {\n                return Boolean.valueOf((String) answer);\n            }\n            if (answer instanceof Number) {\n                final Number n = (Number) answer;\n                return n.intValue() != 0 ? Boolean.TRUE : Boolean.FALSE;\n            }\n        }\n    }\n    return null;\n}"
            ],
            [
                "getNumber",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a Number from a Map in a null-safe manner.\n * <p>\n * If the value is a <code>Number</code> it is returned directly.\n * If the value is a <code>String</code> it is converted using\n * {@link NumberFormat#parse(String)} on the system default formatter\n * returning <code>null</code> if the conversion fails.\n * Otherwise, <code>null</code> is returned.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a Number, <code>null</code> if null map input\n */\npublic static <K> Number getNumber(final Map<? super K, ?> map, final K key) {\n    if (map != null) {\n        final Object answer = map.get(key);\n        if (answer != null) {\n            if (answer instanceof Number) {\n                return (Number) answer;\n            }\n            if (answer instanceof String) {\n                try {\n                    final String text = (String) answer;\n                    return NumberFormat.getInstance().parse(text);\n                } catch (final ParseException e) {\n                    // NOPMD\n                    // failure means null is returned\n                }\n            }\n        }\n    }\n    return null;\n}"
            ],
            [
                "getByte",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a Byte from a Map in a null-safe manner.\n * <p>\n * The Byte is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a Byte, <code>null</code> if null map input\n */\npublic static <K> Byte getByte(final Map<? super K, ?> map, final K key) {\n    final Number answer = getNumber(map, key);\n    if (answer == null) {\n        return null;\n    }\n    if (answer instanceof Byte) {\n        return (Byte) answer;\n    }\n    return Byte.valueOf(answer.byteValue());\n}"
            ],
            [
                "getShort",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a Short from a Map in a null-safe manner.\n * <p>\n * The Short is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a Short, <code>null</code> if null map input\n */\npublic static <K> Short getShort(final Map<? super K, ?> map, final K key) {\n    final Number answer = getNumber(map, key);\n    if (answer == null) {\n        return null;\n    }\n    if (answer instanceof Short) {\n        return (Short) answer;\n    }\n    return Short.valueOf(answer.shortValue());\n}"
            ],
            [
                "getInteger",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a Integer from a Map in a null-safe manner.\n * <p>\n * The Integer is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a Integer, <code>null</code> if null map input\n */\npublic static <K> Integer getInteger(final Map<? super K, ?> map, final K key) {\n    final Number answer = getNumber(map, key);\n    if (answer == null) {\n        return null;\n    }\n    if (answer instanceof Integer) {\n        return (Integer) answer;\n    }\n    return Integer.valueOf(answer.intValue());\n}"
            ],
            [
                "getLong",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a Long from a Map in a null-safe manner.\n * <p>\n * The Long is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a Long, <code>null</code> if null map input\n */\npublic static <K> Long getLong(final Map<? super K, ?> map, final K key) {\n    final Number answer = getNumber(map, key);\n    if (answer == null) {\n        return null;\n    }\n    if (answer instanceof Long) {\n        return (Long) answer;\n    }\n    return Long.valueOf(answer.longValue());\n}"
            ],
            [
                "getFloat",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a Float from a Map in a null-safe manner.\n * <p>\n * The Float is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a Float, <code>null</code> if null map input\n */\npublic static <K> Float getFloat(final Map<? super K, ?> map, final K key) {\n    final Number answer = getNumber(map, key);\n    if (answer == null) {\n        return null;\n    }\n    if (answer instanceof Float) {\n        return (Float) answer;\n    }\n    return Float.valueOf(answer.floatValue());\n}"
            ],
            [
                "getDouble",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a Double from a Map in a null-safe manner.\n * <p>\n * The Double is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a Double, <code>null</code> if null map input\n */\npublic static <K> Double getDouble(final Map<? super K, ?> map, final K key) {\n    final Number answer = getNumber(map, key);\n    if (answer == null) {\n        return null;\n    }\n    if (answer instanceof Double) {\n        return (Double) answer;\n    }\n    return Double.valueOf(answer.doubleValue());\n}"
            ],
            [
                "getMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a Map from a Map in a null-safe manner.\n * <p>\n * If the value returned from the specified map is not a Map then\n * <code>null</code> is returned.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a Map, <code>null</code> if null map input\n */\npublic static <K> Map<?, ?> getMap(final Map<? super K, ?> map, final K key) {\n    if (map != null) {\n        final Object answer = map.get(key);\n        if (answer != null && answer instanceof Map) {\n            return (Map<?, ?>) answer;\n        }\n    }\n    return null;\n}"
            ],
            [
                "getObject",
                "org.apache.commons.collections4",
                "MapUtils",
                "// Type safe getters with default values\n//-------------------------------------------------------------------------\n/**\n * Looks up the given key in the given map, converting null into the\n * given default value.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null\n * @return  the value in the map, or defaultValue if the original value\n *   is null or the map is null\n */\npublic static <K, V> V getObject(final Map<K, V> map, final K key, final V defaultValue) {\n    if (map != null) {\n        final V answer = map.get(key);\n        if (answer != null) {\n            return answer;\n        }\n    }\n    return defaultValue;\n}"
            ],
            [
                "getString",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Looks up the given key in the given map, converting the result into\n * a string, using the default value if the the conversion fails.\n *\n * @param <K>  the key type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null or if the\n *   conversion fails\n * @return  the value in the map as a string, or defaultValue if the\n *   original value is null, the map is null or the string conversion fails\n */\npublic static <K> String getString(final Map<? super K, ?> map, final K key, final String defaultValue) {\n    String answer = getString(map, key);\n    if (answer == null) {\n        answer = defaultValue;\n    }\n    return answer;\n}"
            ],
            [
                "getBoolean",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Looks up the given key in the given map, converting the result into\n * a boolean, using the default value if the the conversion fails.\n *\n * @param <K>  the key type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null or if the\n *   conversion fails\n * @return  the value in the map as a boolean, or defaultValue if the\n *   original value is null, the map is null or the boolean conversion fails\n */\npublic static <K> Boolean getBoolean(final Map<? super K, ?> map, final K key, final Boolean defaultValue) {\n    Boolean answer = getBoolean(map, key);\n    if (answer == null) {\n        answer = defaultValue;\n    }\n    return answer;\n}"
            ],
            [
                "getNumber",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Looks up the given key in the given map, converting the result into\n * a number, using the default value if the the conversion fails.\n *\n * @param <K>  the key type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null or if the\n *   conversion fails\n * @return  the value in the map as a number, or defaultValue if the\n *   original value is null, the map is null or the number conversion fails\n */\npublic static <K> Number getNumber(final Map<? super K, ?> map, final K key, final Number defaultValue) {\n    Number answer = getNumber(map, key);\n    if (answer == null) {\n        answer = defaultValue;\n    }\n    return answer;\n}"
            ],
            [
                "getByte",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Looks up the given key in the given map, converting the result into\n * a byte, using the default value if the the conversion fails.\n *\n * @param <K>  the key type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null or if the\n *   conversion fails\n * @return  the value in the map as a number, or defaultValue if the\n *   original value is null, the map is null or the number conversion fails\n */\npublic static <K> Byte getByte(final Map<? super K, ?> map, final K key, final Byte defaultValue) {\n    Byte answer = getByte(map, key);\n    if (answer == null) {\n        answer = defaultValue;\n    }\n    return answer;\n}"
            ],
            [
                "getShort",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Looks up the given key in the given map, converting the result into\n * a short, using the default value if the the conversion fails.\n *\n * @param <K>  the key type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null or if the\n *   conversion fails\n * @return  the value in the map as a number, or defaultValue if the\n *   original value is null, the map is null or the number conversion fails\n */\npublic static <K> Short getShort(final Map<? super K, ?> map, final K key, final Short defaultValue) {\n    Short answer = getShort(map, key);\n    if (answer == null) {\n        answer = defaultValue;\n    }\n    return answer;\n}"
            ],
            [
                "getInteger",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Looks up the given key in the given map, converting the result into\n * an integer, using the default value if the the conversion fails.\n *\n * @param <K>  the key type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null or if the\n *   conversion fails\n * @return  the value in the map as a number, or defaultValue if the\n *   original value is null, the map is null or the number conversion fails\n */\npublic static <K> Integer getInteger(final Map<? super K, ?> map, final K key, final Integer defaultValue) {\n    Integer answer = getInteger(map, key);\n    if (answer == null) {\n        answer = defaultValue;\n    }\n    return answer;\n}"
            ],
            [
                "getLong",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Looks up the given key in the given map, converting the result into\n * a long, using the default value if the the conversion fails.\n *\n * @param <K>  the key type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null or if the\n *   conversion fails\n * @return  the value in the map as a number, or defaultValue if the\n *   original value is null, the map is null or the number conversion fails\n */\npublic static <K> Long getLong(final Map<? super K, ?> map, final K key, final Long defaultValue) {\n    Long answer = getLong(map, key);\n    if (answer == null) {\n        answer = defaultValue;\n    }\n    return answer;\n}"
            ],
            [
                "getFloat",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Looks up the given key in the given map, converting the result into\n * a float, using the default value if the the conversion fails.\n *\n * @param <K>  the key type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null or if the\n *   conversion fails\n * @return  the value in the map as a number, or defaultValue if the\n *   original value is null, the map is null or the number conversion fails\n */\npublic static <K> Float getFloat(final Map<? super K, ?> map, final K key, final Float defaultValue) {\n    Float answer = getFloat(map, key);\n    if (answer == null) {\n        answer = defaultValue;\n    }\n    return answer;\n}"
            ],
            [
                "getDouble",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Looks up the given key in the given map, converting the result into\n * a double, using the default value if the the conversion fails.\n *\n * @param <K>  the key type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null or if the\n *   conversion fails\n * @return  the value in the map as a number, or defaultValue if the\n *   original value is null, the map is null or the number conversion fails\n */\npublic static <K> Double getDouble(final Map<? super K, ?> map, final K key, final Double defaultValue) {\n    Double answer = getDouble(map, key);\n    if (answer == null) {\n        answer = defaultValue;\n    }\n    return answer;\n}"
            ],
            [
                "getMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Looks up the given key in the given map, converting the result into\n * a map, using the default value if the the conversion fails.\n *\n * @param <K>  the key type\n * @param map  the map whose value to look up\n * @param key  the key of the value to look up in that map\n * @param defaultValue  what to return if the value is null or if the\n *   conversion fails\n * @return  the value in the map as a number, or defaultValue if the\n *   original value is null, the map is null or the map conversion fails\n */\npublic static <K> Map<?, ?> getMap(final Map<? super K, ?> map, final K key, final Map<?, ?> defaultValue) {\n    Map<?, ?> answer = getMap(map, key);\n    if (answer == null) {\n        answer = defaultValue;\n    }\n    return answer;\n}"
            ],
            [
                "getBooleanValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "// Type safe primitive getters\n//-------------------------------------------------------------------------\n/**\n * Gets a boolean from a Map in a null-safe manner.\n * <p>\n * If the value is a <code>Boolean</code> its value is returned.\n * If the value is a <code>String</code> and it equals 'true' ignoring case\n * then <code>true</code> is returned, otherwise <code>false</code>.\n * If the value is a <code>Number</code> an integer zero value returns\n * <code>false</code> and non-zero returns <code>true</code>.\n * Otherwise, <code>false</code> is returned.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a Boolean, <code>false</code> if null map input\n */\npublic static <K> boolean getBooleanValue(final Map<? super K, ?> map, final K key) {\n    return Boolean.TRUE.equals(getBoolean(map, key));\n}"
            ],
            [
                "getByteValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a byte from a Map in a null-safe manner.\n * <p>\n * The byte is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a byte, <code>0</code> if null map input\n */\npublic static <K> byte getByteValue(final Map<? super K, ?> map, final K key) {\n    final Byte byteObject = getByte(map, key);\n    if (byteObject == null) {\n        return 0;\n    }\n    return byteObject.byteValue();\n}"
            ],
            [
                "getShortValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a short from a Map in a null-safe manner.\n * <p>\n * The short is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a short, <code>0</code> if null map input\n */\npublic static <K> short getShortValue(final Map<? super K, ?> map, final K key) {\n    final Short shortObject = getShort(map, key);\n    if (shortObject == null) {\n        return 0;\n    }\n    return shortObject.shortValue();\n}"
            ],
            [
                "getIntValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets an int from a Map in a null-safe manner.\n * <p>\n * The int is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as an int, <code>0</code> if null map input\n */\npublic static <K> int getIntValue(final Map<? super K, ?> map, final K key) {\n    final Integer integerObject = getInteger(map, key);\n    if (integerObject == null) {\n        return 0;\n    }\n    return integerObject.intValue();\n}"
            ],
            [
                "getLongValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a long from a Map in a null-safe manner.\n * <p>\n * The long is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a long, <code>0L</code> if null map input\n */\npublic static <K> long getLongValue(final Map<? super K, ?> map, final K key) {\n    final Long longObject = getLong(map, key);\n    if (longObject == null) {\n        return 0L;\n    }\n    return longObject.longValue();\n}"
            ],
            [
                "getFloatValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a float from a Map in a null-safe manner.\n * <p>\n * The float is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a float, <code>0.0F</code> if null map input\n */\npublic static <K> float getFloatValue(final Map<? super K, ?> map, final K key) {\n    final Float floatObject = getFloat(map, key);\n    if (floatObject == null) {\n        return 0f;\n    }\n    return floatObject.floatValue();\n}"
            ],
            [
                "getDoubleValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a double from a Map in a null-safe manner.\n * <p>\n * The double is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @return the value in the Map as a double, <code>0.0</code> if null map input\n */\npublic static <K> double getDoubleValue(final Map<? super K, ?> map, final K key) {\n    final Double doubleObject = getDouble(map, key);\n    if (doubleObject == null) {\n        return 0d;\n    }\n    return doubleObject.doubleValue();\n}"
            ],
            [
                "getBooleanValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "// Type safe primitive getters with default values\n//-------------------------------------------------------------------------\n/**\n * Gets a boolean from a Map in a null-safe manner,\n * using the default value if the the conversion fails.\n * <p>\n * If the value is a <code>Boolean</code> its value is returned.\n * If the value is a <code>String</code> and it equals 'true' ignoring case\n * then <code>true</code> is returned, otherwise <code>false</code>.\n * If the value is a <code>Number</code> an integer zero value returns\n * <code>false</code> and non-zero returns <code>true</code>.\n * Otherwise, <code>defaultValue</code> is returned.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @param defaultValue  return if the value is null or if the conversion fails\n * @return the value in the Map as a Boolean, <code>defaultValue</code> if null map input\n */\npublic static <K> boolean getBooleanValue(final Map<? super K, ?> map, final K key, final boolean defaultValue) {\n    final Boolean booleanObject = getBoolean(map, key);\n    if (booleanObject == null) {\n        return defaultValue;\n    }\n    return booleanObject.booleanValue();\n}"
            ],
            [
                "getByteValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a byte from a Map in a null-safe manner,\n * using the default value if the the conversion fails.\n * <p>\n * The byte is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @param defaultValue  return if the value is null or if the conversion fails\n * @return the value in the Map as a byte, <code>defaultValue</code> if null map input\n */\npublic static <K> byte getByteValue(final Map<? super K, ?> map, final K key, final byte defaultValue) {\n    final Byte byteObject = getByte(map, key);\n    if (byteObject == null) {\n        return defaultValue;\n    }\n    return byteObject.byteValue();\n}"
            ],
            [
                "getShortValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a short from a Map in a null-safe manner,\n * using the default value if the the conversion fails.\n * <p>\n * The short is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @param defaultValue  return if the value is null or if the conversion fails\n * @return the value in the Map as a short, <code>defaultValue</code> if null map input\n */\npublic static <K> short getShortValue(final Map<? super K, ?> map, final K key, final short defaultValue) {\n    final Short shortObject = getShort(map, key);\n    if (shortObject == null) {\n        return defaultValue;\n    }\n    return shortObject.shortValue();\n}"
            ],
            [
                "getIntValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets an int from a Map in a null-safe manner,\n * using the default value if the the conversion fails.\n * <p>\n * The int is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @param defaultValue  return if the value is null or if the conversion fails\n * @return the value in the Map as an int, <code>defaultValue</code> if null map input\n */\npublic static <K> int getIntValue(final Map<? super K, ?> map, final K key, final int defaultValue) {\n    final Integer integerObject = getInteger(map, key);\n    if (integerObject == null) {\n        return defaultValue;\n    }\n    return integerObject.intValue();\n}"
            ],
            [
                "getLongValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a long from a Map in a null-safe manner,\n * using the default value if the the conversion fails.\n * <p>\n * The long is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @param defaultValue  return if the value is null or if the conversion fails\n * @return the value in the Map as a long, <code>defaultValue</code> if null map input\n */\npublic static <K> long getLongValue(final Map<? super K, ?> map, final K key, final long defaultValue) {\n    final Long longObject = getLong(map, key);\n    if (longObject == null) {\n        return defaultValue;\n    }\n    return longObject.longValue();\n}"
            ],
            [
                "getFloatValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a float from a Map in a null-safe manner,\n * using the default value if the the conversion fails.\n * <p>\n * The float is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @param defaultValue  return if the value is null or if the conversion fails\n * @return the value in the Map as a float, <code>defaultValue</code> if null map input\n */\npublic static <K> float getFloatValue(final Map<? super K, ?> map, final K key, final float defaultValue) {\n    final Float floatObject = getFloat(map, key);\n    if (floatObject == null) {\n        return defaultValue;\n    }\n    return floatObject.floatValue();\n}"
            ],
            [
                "getDoubleValue",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Gets a double from a Map in a null-safe manner,\n * using the default value if the the conversion fails.\n * <p>\n * The double is obtained from the results of {@link #getNumber(Map,Object)}.\n *\n * @param <K>  the key type\n * @param map  the map to use\n * @param key  the key to look up\n * @param defaultValue  return if the value is null or if the conversion fails\n * @return the value in the Map as a double, <code>defaultValue</code> if null map input\n */\npublic static <K> double getDoubleValue(final Map<? super K, ?> map, final K key, final double defaultValue) {\n    final Double doubleObject = getDouble(map, key);\n    if (doubleObject == null) {\n        return defaultValue;\n    }\n    return doubleObject.doubleValue();\n}"
            ],
            [
                "toProperties",
                "org.apache.commons.collections4",
                "MapUtils",
                "// Conversion methods\n//-------------------------------------------------------------------------\n/**\n * Gets a new Properties object initialised with the values from a Map.\n * A null input will return an empty properties object.\n * <p>\n * A Properties object may only store non-null keys and values, thus if\n * the provided map contains either a key or value which is {@code null},\n * a {@link NullPointerException} will be thrown.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to convert to a Properties object\n * @return the properties object\n * @throws NullPointerException if a key or value in the provided map is {@code null}\n */\npublic static <K, V> Properties toProperties(final Map<K, V> map) {\n    final Properties answer = new Properties();\n    if (map != null) {\n        for (final Entry<K, V> entry2 : map.entrySet()) {\n            final Map.Entry<?, ?> entry = entry2;\n            final Object key = entry.getKey();\n            final Object value = entry.getValue();\n            answer.put(key, value);\n        }\n    }\n    return answer;\n}"
            ],
            [
                "toMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Creates a new HashMap using data copied from a ResourceBundle.\n *\n * @param resourceBundle  the resource bundle to convert, may not be null\n * @return the hashmap containing the data\n * @throws NullPointerException if the bundle is null\n */\npublic static Map<String, Object> toMap(final ResourceBundle resourceBundle) {\n    final Enumeration<String> enumeration = resourceBundle.getKeys();\n    final Map<String, Object> map = new HashMap<String, Object>();\n    while (enumeration.hasMoreElements()) {\n        final String key = enumeration.nextElement();\n        final Object value = resourceBundle.getObject(key);\n        map.put(key, value);\n    }\n    return map;\n}"
            ],
            [
                "invertMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "// Misc\n//-----------------------------------------------------------------------\n/**\n * Inverts the supplied map returning a new HashMap such that the keys of\n * the input are swapped with the values.\n * <p>\n * This operation assumes that the inverse mapping is well defined.\n * If the input map had multiple entries with the same value mapped to\n * different keys, the returned map will map one of those keys to the\n * value, but the exact key which will be mapped is undefined.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to invert, may not be null\n * @return a new HashMap containing the inverted data\n * @throws NullPointerException if the map is null\n */\npublic static <K, V> Map<V, K> invertMap(final Map<K, V> map) {\n    final Map<V, K> out = new HashMap<V, K>(map.size());\n    for (final Entry<K, V> entry : map.entrySet()) {\n        out.put(entry.getValue(), entry.getKey());\n    }\n    return out;\n}"
            ],
            [
                "putAll",
                "org.apache.commons.collections4",
                "MapUtils",
                "//-----------------------------------------------------------------------\n/**\n * Puts all the keys and values from the specified array into the map.\n * <p>\n * This method is an alternative to the {@link java.util.Map#putAll(java.util.Map)}\n * method and constructors. It allows you to build a map from an object array\n * of various possible styles.\n * <p>\n * If the first entry in the object array implements {@link java.util.Map.Entry}\n * or {@link KeyValue} then the key and value are added from that object.\n * If the first entry in the object array is an object array itself, then\n * it is assumed that index 0 in the sub-array is the key and index 1 is the value.\n * Otherwise, the array is treated as keys and values in alternate indices.\n * <p>\n * For example, to create a color map:\n * <pre>\n * Map colorMap = MapUtils.putAll(new HashMap(), new String[][] {\n *     {\"RED\", \"#FF0000\"},\n *     {\"GREEN\", \"#00FF00\"},\n *     {\"BLUE\", \"#0000FF\"}\n * });\n * </pre>\n * or:\n * <pre>\n * Map colorMap = MapUtils.putAll(new HashMap(), new String[] {\n *     \"RED\", \"#FF0000\",\n *     \"GREEN\", \"#00FF00\",\n *     \"BLUE\", \"#0000FF\"\n * });\n * </pre>\n * or:\n * <pre>\n * Map colorMap = MapUtils.putAll(new HashMap(), new Map.Entry[] {\n *     new DefaultMapEntry(\"RED\", \"#FF0000\"),\n *     new DefaultMapEntry(\"GREEN\", \"#00FF00\"),\n *     new DefaultMapEntry(\"BLUE\", \"#0000FF\")\n * });\n * </pre>\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to populate, must not be null\n * @param array  an array to populate from, null ignored\n * @return the input map\n * @throws NullPointerException  if map is null\n * @throws IllegalArgumentException  if sub-array or entry matching used and an entry is invalid\n * @throws ClassCastException if the array contents is mixed\n * @since 3.2\n */\n// As per Javadoc throws CCE for invalid array contents\n@SuppressWarnings(\"unchecked\")\npublic static <K, V> Map<K, V> putAll(final Map<K, V> map, final Object[] array) {\n    if (map == null) {\n        throw new NullPointerException(\"The map must not be null\");\n    }\n    if (array == null || array.length == 0) {\n        return map;\n    }\n    final Object obj = array[0];\n    if (obj instanceof Map.Entry) {\n        for (final Object element : array) {\n            // cast ok here, type is checked above\n            final Map.Entry<K, V> entry = (Map.Entry<K, V>) element;\n            map.put(entry.getKey(), entry.getValue());\n        }\n    } else if (obj instanceof KeyValue) {\n        for (final Object element : array) {\n            // cast ok here, type is checked above\n            final KeyValue<K, V> keyval = (KeyValue<K, V>) element;\n            map.put(keyval.getKey(), keyval.getValue());\n        }\n    } else if (obj instanceof Object[]) {\n        for (int i = 0; i < array.length; i++) {\n            final Object[] sub = (Object[]) array[i];\n            if (sub == null || sub.length < 2) {\n                throw new IllegalArgumentException(\"Invalid array element: \" + i);\n            }\n            // these casts can fail if array has incorrect types\n            map.put((K) sub[0], (V) sub[1]);\n        }\n    } else {\n        for (int i = 0; i < array.length - 1; ) {\n            // these casts can fail if array has incorrect types\n            map.put((K) array[i++], (V) array[i++]);\n        }\n    }\n    return map;\n}"
            ],
            [
                "emptyIfNull",
                "org.apache.commons.collections4",
                "MapUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns an immutable empty map if the argument is <code>null</code>,\n * or the argument itself otherwise.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map the map, possibly <code>null</code>\n * @return an empty map if the argument is <code>null</code>\n */\npublic static <K, V> Map<K, V> emptyIfNull(final Map<K, V> map) {\n    return map == null ? Collections.<K, V>emptyMap() : map;\n}"
            ],
            [
                "isEmpty",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Null-safe check if the specified map is empty.\n * <p>\n * Null returns true.\n *\n * @param map  the map to check, may be null\n * @return true if empty or null\n * @since 3.2\n */\npublic static boolean isEmpty(final Map<?, ?> map) {\n    return map == null || map.isEmpty();\n}"
            ],
            [
                "isNotEmpty",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Null-safe check if the specified map is not empty.\n * <p>\n * Null returns false.\n *\n * @param map  the map to check, may be null\n * @return true if non-null and non-empty\n * @since 3.2\n */\npublic static boolean isNotEmpty(final Map<?, ?> map) {\n    return !MapUtils.isEmpty(map);\n}"
            ],
            [
                "synchronizedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "// Map decorators\n//-----------------------------------------------------------------------\n/**\n * Returns a synchronized map backed by the given map.\n * <p>\n * You must manually synchronize on the returned buffer's iterator to\n * avoid non-deterministic behavior:\n *\n * <pre>\n * Map m = MapUtils.synchronizedMap(myMap);\n * Set s = m.keySet();  // outside synchronized block\n * synchronized (m) {  // synchronized on MAP!\n *     Iterator i = s.iterator();\n *     while (i.hasNext()) {\n *         process (i.next());\n *     }\n * }\n * </pre>\n *\n * This method uses the implementation in {@link java.util.Collections Collections}.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to synchronize, must not be null\n * @return a synchronized map backed by the given map\n */\npublic static <K, V> Map<K, V> synchronizedMap(final Map<K, V> map) {\n    return Collections.synchronizedMap(map);\n}"
            ],
            [
                "unmodifiableMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns an unmodifiable map backed by the given map.\n * <p>\n * This method uses the implementation in the decorators subpackage.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to make unmodifiable, must not be null\n * @return an unmodifiable map backed by the given map\n * @throws NullPointerException  if the map is null\n */\npublic static <K, V> Map<K, V> unmodifiableMap(final Map<? extends K, ? extends V> map) {\n    return UnmodifiableMap.unmodifiableMap(map);\n}"
            ],
            [
                "predicatedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a predicated (validating) map backed by the given map.\n * <p>\n * Only objects that pass the tests in the given predicates can be added to the map.\n * Trying to add an invalid object results in an IllegalArgumentException.\n * Keys must pass the key predicate, values must pass the value predicate.\n * It is important not to use the original map after invoking this method,\n * as it is a backdoor for adding invalid objects.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to predicate, must not be null\n * @param keyPred  the predicate for keys, null means no check\n * @param valuePred  the predicate for values, null means no check\n * @return a predicated map backed by the given map\n * @throws NullPointerException  if the Map is null\n */\npublic static <K, V> IterableMap<K, V> predicatedMap(final Map<K, V> map, final Predicate<? super K> keyPred, final Predicate<? super V> valuePred) {\n    return PredicatedMap.predicatedMap(map, keyPred, valuePred);\n}"
            ],
            [
                "transformedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a transformed map backed by the given map.\n * <p>\n * This method returns a new map (decorating the specified map) that\n * will transform any new entries added to it.\n * Existing entries in the specified map will not be transformed.\n * If you want that behaviour, see {@link TransformedMap#transformedMap}.\n * <p>\n * Each object is passed through the transformers as it is added to the\n * Map. It is important not to use the original map after invoking this\n * method, as it is a backdoor for adding untransformed objects.\n * <p>\n * If there are any elements already in the map being decorated, they\n * are NOT transformed.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to transform, must not be null, typically empty\n * @param keyTransformer  the transformer for the map keys, null means no transformation\n * @param valueTransformer  the transformer for the map values, null means no transformation\n * @return a transformed map backed by the given map\n * @throws NullPointerException  if the Map is null\n */\npublic static <K, V> IterableMap<K, V> transformedMap(final Map<K, V> map, final Transformer<? super K, ? extends K> keyTransformer, final Transformer<? super V, ? extends V> valueTransformer) {\n    return TransformedMap.transformingMap(map, keyTransformer, valueTransformer);\n}"
            ],
            [
                "fixedSizeMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a fixed-sized map backed by the given map.\n * Elements may not be added or removed from the returned map, but\n * existing elements can be changed (for instance, via the\n * {@link Map#put(Object,Object)} method).\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map whose size to fix, must not be null\n * @return a fixed-size map backed by that map\n * @throws NullPointerException  if the Map is null\n */\npublic static <K, V> IterableMap<K, V> fixedSizeMap(final Map<K, V> map) {\n    return FixedSizeMap.fixedSizeMap(map);\n}"
            ],
            [
                "lazyMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a \"lazy\" map whose values will be created on demand.\n * <p>\n * When the key passed to the returned map's {@link Map#get(Object)}\n * method is not present in the map, then the factory will be used\n * to create a new object and that object will become the value\n * associated with that key.\n * <p>\n * For instance:\n * <pre>\n * Factory factory = new Factory() {\n *     public Object create() {\n *         return new Date();\n *     }\n * }\n * Map lazyMap = MapUtils.lazyMap(new HashMap(), factory);\n * Object obj = lazyMap.get(\"test\");\n * </pre>\n *\n * After the above code is executed, <code>obj</code> will contain\n * a new <code>Date</code> instance.  Furthermore, that <code>Date</code>\n * instance is the value for the <code>\"test\"</code> key in the map.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to make lazy, must not be null\n * @param factory  the factory for creating new objects, must not be null\n * @return a lazy map backed by the given map\n * @throws NullPointerException  if the Map or Factory is null\n */\npublic static <K, V> IterableMap<K, V> lazyMap(final Map<K, V> map, final Factory<? extends V> factory) {\n    return LazyMap.lazyMap(map, factory);\n}"
            ],
            [
                "lazyMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a \"lazy\" map whose values will be created on demand.\n * <p>\n * When the key passed to the returned map's {@link Map#get(Object)}\n * method is not present in the map, then the factory will be used\n * to create a new object and that object will become the value\n * associated with that key. The factory is a {@link Transformer}\n * that will be passed the key which it must transform into the value.\n * <p>\n * For instance:\n * <pre>\n * Transformer factory = new Transformer() {\n *     public Object transform(Object mapKey) {\n *         return new File(mapKey);\n *     }\n * }\n * Map lazyMap = MapUtils.lazyMap(new HashMap(), factory);\n * Object obj = lazyMap.get(\"C:/dev\");\n * </pre>\n *\n * After the above code is executed, <code>obj</code> will contain\n * a new <code>File</code> instance for the C drive dev directory.\n * Furthermore, that <code>File</code> instance is the value for the\n * <code>\"C:/dev\"</code> key in the map.\n * <p>\n * If a lazy map is wrapped by a synchronized map, the result is a simple\n * synchronized cache. When an object is not is the cache, the cache itself\n * calls back to the factory Transformer to populate itself, all within the\n * same synchronized block.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to make lazy, must not be null\n * @param transformerFactory  the factory for creating new objects, must not be null\n * @return a lazy map backed by the given map\n * @throws NullPointerException  if the Map or Transformer is null\n */\npublic static <K, V> IterableMap<K, V> lazyMap(final Map<K, V> map, final Transformer<? super K, ? extends V> transformerFactory) {\n    return LazyMap.lazyMap(map, transformerFactory);\n}"
            ],
            [
                "orderedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a map that maintains the order of keys that are added\n * backed by the given map.\n * <p>\n * If a key is added twice, the order is determined by the first add.\n * The order is observed through the keySet, values and entrySet.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to order, must not be null\n * @return an ordered map backed by the given map\n * @throws NullPointerException  if the Map is null\n */\npublic static <K, V> OrderedMap<K, V> orderedMap(final Map<K, V> map) {\n    return ListOrderedMap.listOrderedMap(map);\n}"
            ],
            [
                "multiValueMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Creates a mult-value map backed by the given map which returns\n * collections of type ArrayList.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate\n * @return a multi-value map backed by the given map which returns ArrayLists of values.\n * @see MultiValueMap\n * @since 3.2\n * @deprecated since 4.1, use {@link MultiValuedMap} instead\n */\n@Deprecated\npublic static <K, V> MultiValueMap<K, V> multiValueMap(final Map<K, ? super Collection<V>> map) {\n    return MultiValueMap.<K, V>multiValueMap(map);\n}"
            ],
            [
                "multiValueMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Creates a multi-value map backed by the given map which returns\n * collections of the specified type.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param <C>  the collection class type\n * @param map  the map to decorate\n * @param collectionClass  the type of collections to return from the map\n *   (must contain public no-arg constructor and extend Collection)\n * @return a multi-value map backed by the given map which returns collections of the specified type\n * @see MultiValueMap\n * @since 3.2\n * @deprecated since 4.1, use {@link MultiValuedMap} instead\n */\n@Deprecated\npublic static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(final Map<K, C> map, final Class<C> collectionClass) {\n    return MultiValueMap.multiValueMap(map, collectionClass);\n}"
            ],
            [
                "multiValueMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Creates a multi-value map backed by the given map which returns\n * collections created by the specified collection factory.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param <C>  the collection class type\n * @param map  the map to decorate\n * @param collectionFactory  a factor which creates collection objects\n * @return a multi-value map backed by the given map which returns collections\n *   created by the specified collection factory\n * @see MultiValueMap\n * @since 3.2\n * @deprecated since 4.1, use {@link MultiValuedMap} instead\n */\n@Deprecated\npublic static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(final Map<K, C> map, final Factory<C> collectionFactory) {\n    return MultiValueMap.multiValueMap(map, collectionFactory);\n}"
            ],
            [
                "synchronizedSortedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "// SortedMap decorators\n//-----------------------------------------------------------------------\n/**\n * Returns a synchronized sorted map backed by the given sorted map.\n * <p>\n * You must manually synchronize on the returned buffer's iterator to\n * avoid non-deterministic behavior:\n *\n * <pre>\n * Map m = MapUtils.synchronizedSortedMap(myMap);\n * Set s = m.keySet();  // outside synchronized block\n * synchronized (m) {  // synchronized on MAP!\n *     Iterator i = s.iterator();\n *     while (i.hasNext()) {\n *         process (i.next());\n *     }\n * }\n * </pre>\n *\n * This method uses the implementation in {@link java.util.Collections Collections}.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to synchronize, must not be null\n * @return a synchronized map backed by the given map\n * @throws NullPointerException  if the map is null\n */\npublic static <K, V> SortedMap<K, V> synchronizedSortedMap(final SortedMap<K, V> map) {\n    return Collections.synchronizedSortedMap(map);\n}"
            ],
            [
                "unmodifiableSortedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns an unmodifiable sorted map backed by the given sorted map.\n * <p>\n * This method uses the implementation in the decorators subpackage.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the sorted map to make unmodifiable, must not be null\n * @return an unmodifiable map backed by the given map\n * @throws NullPointerException  if the map is null\n */\npublic static <K, V> SortedMap<K, V> unmodifiableSortedMap(final SortedMap<K, ? extends V> map) {\n    return UnmodifiableSortedMap.unmodifiableSortedMap(map);\n}"
            ],
            [
                "predicatedSortedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a predicated (validating) sorted map backed by the given map.\n * <p>\n * Only objects that pass the tests in the given predicates can be added to the map.\n * Trying to add an invalid object results in an IllegalArgumentException.\n * Keys must pass the key predicate, values must pass the value predicate.\n * It is important not to use the original map after invoking this method,\n * as it is a backdoor for adding invalid objects.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to predicate, must not be null\n * @param keyPred  the predicate for keys, null means no check\n * @param valuePred  the predicate for values, null means no check\n * @return a predicated map backed by the given map\n * @throws NullPointerException  if the SortedMap is null\n */\npublic static <K, V> SortedMap<K, V> predicatedSortedMap(final SortedMap<K, V> map, final Predicate<? super K> keyPred, final Predicate<? super V> valuePred) {\n    return PredicatedSortedMap.predicatedSortedMap(map, keyPred, valuePred);\n}"
            ],
            [
                "transformedSortedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a transformed sorted map backed by the given map.\n * <p>\n * This method returns a new sorted map (decorating the specified map) that\n * will transform any new entries added to it.\n * Existing entries in the specified map will not be transformed.\n * If you want that behaviour, see {@link TransformedSortedMap#transformedSortedMap}.\n * <p>\n * Each object is passed through the transformers as it is added to the\n * Map. It is important not to use the original map after invoking this\n * method, as it is a backdoor for adding untransformed objects.\n * <p>\n * If there are any elements already in the map being decorated, they\n * are NOT transformed.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to transform, must not be null, typically empty\n * @param keyTransformer  the transformer for the map keys, null means no transformation\n * @param valueTransformer  the transformer for the map values, null means no transformation\n * @return a transformed map backed by the given map\n * @throws NullPointerException  if the SortedMap is null\n */\npublic static <K, V> SortedMap<K, V> transformedSortedMap(final SortedMap<K, V> map, final Transformer<? super K, ? extends K> keyTransformer, final Transformer<? super V, ? extends V> valueTransformer) {\n    return TransformedSortedMap.transformingSortedMap(map, keyTransformer, valueTransformer);\n}"
            ],
            [
                "fixedSizeSortedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a fixed-sized sorted map backed by the given sorted map.\n * Elements may not be added or removed from the returned map, but\n * existing elements can be changed (for instance, via the\n * {@link Map#put(Object,Object)} method).\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map whose size to fix, must not be null\n * @return a fixed-size map backed by that map\n * @throws NullPointerException  if the SortedMap is null\n */\npublic static <K, V> SortedMap<K, V> fixedSizeSortedMap(final SortedMap<K, V> map) {\n    return FixedSizeSortedMap.fixedSizeSortedMap(map);\n}"
            ],
            [
                "lazySortedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a \"lazy\" sorted map whose values will be created on demand.\n * <p>\n * When the key passed to the returned map's {@link Map#get(Object)}\n * method is not present in the map, then the factory will be used\n * to create a new object and that object will become the value\n * associated with that key.\n * <p>\n * For instance:\n *\n * <pre>\n * Factory factory = new Factory() {\n *     public Object create() {\n *         return new Date();\n *     }\n * }\n * SortedMap lazy = MapUtils.lazySortedMap(new TreeMap(), factory);\n * Object obj = lazy.get(\"test\");\n * </pre>\n *\n * After the above code is executed, <code>obj</code> will contain\n * a new <code>Date</code> instance.  Furthermore, that <code>Date</code>\n * instance is the value for the <code>\"test\"</code> key.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to make lazy, must not be null\n * @param factory  the factory for creating new objects, must not be null\n * @return a lazy map backed by the given map\n * @throws NullPointerException  if the SortedMap or Factory is null\n */\npublic static <K, V> SortedMap<K, V> lazySortedMap(final SortedMap<K, V> map, final Factory<? extends V> factory) {\n    return LazySortedMap.lazySortedMap(map, factory);\n}"
            ],
            [
                "lazySortedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Returns a \"lazy\" sorted map whose values will be created on demand.\n * <p>\n * When the key passed to the returned map's {@link Map#get(Object)}\n * method is not present in the map, then the factory will be used\n * to create a new object and that object will become the value\n * associated with that key. The factory is a {@link Transformer}\n * that will be passed the key which it must transform into the value.\n * <p>\n * For instance:\n * <pre>\n * Transformer factory = new Transformer() {\n *     public Object transform(Object mapKey) {\n *         return new File(mapKey);\n *     }\n * }\n * SortedMap lazy = MapUtils.lazySortedMap(new TreeMap(), factory);\n * Object obj = lazy.get(\"C:/dev\");\n * </pre>\n *\n * After the above code is executed, <code>obj</code> will contain\n * a new <code>File</code> instance for the C drive dev directory.\n * Furthermore, that <code>File</code> instance is the value for the\n * <code>\"C:/dev\"</code> key in the map.\n * <p>\n * If a lazy map is wrapped by a synchronized map, the result is a simple\n * synchronized cache. When an object is not is the cache, the cache itself\n * calls back to the factory Transformer to populate itself, all within the\n * same synchronized block.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to make lazy, must not be null\n * @param transformerFactory  the factory for creating new objects, must not be null\n * @return a lazy map backed by the given map\n * @throws NullPointerException  if the Map or Transformer is null\n */\npublic static <K, V> SortedMap<K, V> lazySortedMap(final SortedMap<K, V> map, final Transformer<? super K, ? extends V> transformerFactory) {\n    return LazySortedMap.lazySortedMap(map, transformerFactory);\n}"
            ],
            [
                "iterableMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Get the specified {@link Map} as an {@link IterableMap}.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map to wrap if necessary.\n * @return IterableMap<K, V>\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> IterableMap<K, V> iterableMap(final Map<K, V> map) {\n    if (map == null) {\n        throw new NullPointerException(\"Map must not be null\");\n    }\n    return map instanceof IterableMap ? (IterableMap<K, V>) map : new AbstractMapDecorator<K, V>(map) {\n    };\n}"
            ],
            [
                "iterableSortedMap",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * Get the specified {@link SortedMap} as an {@link IterableSortedMap}.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param sortedMap to wrap if necessary\n * @return {@link IterableSortedMap}<K, V>\n * @throws NullPointerException if sortedMap is null\n * @since 4.0\n */\npublic static <K, V> IterableSortedMap<K, V> iterableSortedMap(final SortedMap<K, V> sortedMap) {\n    if (sortedMap == null) {\n        throw new NullPointerException(\"Map must not be null\");\n    }\n    return sortedMap instanceof IterableSortedMap ? (IterableSortedMap<K, V>) sortedMap : new AbstractSortedMapDecorator<K, V>(sortedMap) {\n    };\n}"
            ],
            [
                "defaultEquator",
                "org.apache.commons.collections4.functors",
                "DefaultEquator",
                "/**\n * Factory returning the typed singleton instance.\n *\n * @param <T>  the object type\n * @return the singleton instance\n */\n// the static instance works for all types\n@SuppressWarnings(\"unchecked\")\npublic static <T> DefaultEquator<T> defaultEquator() {\n    return (DefaultEquator<T>) DefaultEquator.INSTANCE;\n}"
            ],
            [
                "stringValueTransformer",
                "org.apache.commons.collections4.functors",
                "StringValueTransformer",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <T>  the input type\n * @return the singleton instance\n * @since 3.1\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Transformer<T, String> stringValueTransformer() {\n    return (Transformer<T, String>) INSTANCE;\n}"
            ],
            [
                "ifTransformer",
                "org.apache.commons.collections4.functors",
                "IfTransformer",
                "/**\n * Factory method that performs validation.\n *\n * @param <I>  input type for the transformer\n * @param <O>  output type for the transformer\n * @param predicate  predicate to switch on\n * @param trueTransformer  transformer used if true\n * @param falseTransformer  transformer used if false\n * @return the <code>if</code> transformer\n * @throws NullPointerException if either argument is null\n */\npublic static <I, O> Transformer<I, O> ifTransformer(final Predicate<? super I> predicate, final Transformer<? super I, ? extends O> trueTransformer, final Transformer<? super I, ? extends O> falseTransformer) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    if (trueTransformer == null || falseTransformer == null) {\n        throw new NullPointerException(\"Transformers must not be null\");\n    }\n    return new IfTransformer<I, O>(predicate, trueTransformer, falseTransformer);\n}"
            ],
            [
                "ifTransformer",
                "org.apache.commons.collections4.functors",
                "IfTransformer",
                "/**\n * Factory method that performs validation.\n * <p>\n * This factory creates a transformer that just returns the input object when\n * the predicate is false.\n *\n * @param <T>  input and output type for the transformer\n * @param predicate  predicate to switch on\n * @param trueTransformer  transformer used if true\n * @return the <code>if</code> transformer\n * @throws NullPointerException if either argument is null\n */\npublic static <T> Transformer<T, T> ifTransformer(final Predicate<? super T> predicate, final Transformer<? super T, ? extends T> trueTransformer) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    if (trueTransformer == null) {\n        throw new NullPointerException(\"Transformer must not be null\");\n    }\n    return new IfTransformer<T, T>(predicate, trueTransformer, NOPTransformer.<T>nopTransformer());\n}"
            ],
            [
                "identityPredicate",
                "org.apache.commons.collections4.functors",
                "IdentityPredicate",
                "/**\n * Factory to create the identity predicate.\n *\n * @param <T> the type that the predicate queries\n * @param object  the object to compare to\n * @return the predicate\n */\npublic static <T> Predicate<T> identityPredicate(final T object) {\n    if (object == null) {\n        return NullPredicate.<T>nullPredicate();\n    }\n    return new IdentityPredicate<T>(object);\n}"
            ],
            [
                "exceptionClosure",
                "org.apache.commons.collections4.functors",
                "ExceptionClosure",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <E> the type that the closure acts on\n * @return the singleton instance\n * @since 3.1\n */\n// the static instance works for all types\n@SuppressWarnings(\"unchecked\")\npublic static <E> Closure<E> exceptionClosure() {\n    return (Closure<E>) INSTANCE;\n}"
            ],
            [
                "nopClosure",
                "org.apache.commons.collections4.functors",
                "NOPClosure",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <E> the type that the closure acts on\n * @return the singleton instance\n * @since 3.1\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Closure<E> nopClosure() {\n    return (Closure<E>) INSTANCE;\n}"
            ],
            [
                "closureTransformer",
                "org.apache.commons.collections4.functors",
                "ClosureTransformer",
                "/**\n * Factory method that performs validation.\n *\n * @param <T>  the type of the object to transform\n * @param closure  the closure to call, not null\n * @return the <code>closure</code> transformer\n * @throws NullPointerException if the closure is null\n */\npublic static <T> Transformer<T, T> closureTransformer(final Closure<? super T> closure) {\n    if (closure == null) {\n        throw new NullPointerException(\"Closure must not be null\");\n    }\n    return new ClosureTransformer<T>(closure);\n}"
            ],
            [
                "copy",
                "org.apache.commons.collections4.functors",
                "FunctorUtils",
                "/**\n * Clone the predicates to ensure that the internal reference can't be messed with.\n * Due to the {@link Predicate#evaluate(T)} method, Predicate<? super T> is\n * able to be coerced to Predicate<T> without casting issues.\n *\n * @param predicates  the predicates to copy\n * @return the cloned predicates\n */\n@SuppressWarnings(\"unchecked\")\nstatic <T> Predicate<T>[] copy(final Predicate<? super T>... predicates) {\n    if (predicates == null) {\n        return null;\n    }\n    return (Predicate<T>[]) predicates.clone();\n}"
            ],
            [
                "coerce",
                "org.apache.commons.collections4.functors",
                "FunctorUtils",
                "/**\n * A very simple method that coerces Predicate<? super T> to Predicate<T>.\n * Due to the {@link Predicate#evaluate(T)} method, Predicate<? super T> is\n * able to be coerced to Predicate<T> without casting issues.\n * <p>This method exists\n * simply as centralised documentation and atomic unchecked warning\n * suppression.\n *\n * @param <T> the type of object the returned predicate should \"accept\"\n * @param predicate the predicate to coerce.\n * @return the coerced predicate.\n */\n@SuppressWarnings(\"unchecked\")\nstatic <T> Predicate<T> coerce(final Predicate<? super T> predicate) {\n    return (Predicate<T>) predicate;\n}"
            ],
            [
                "validate",
                "org.apache.commons.collections4.functors",
                "FunctorUtils",
                "/**\n * Validate the predicates to ensure that all is well.\n *\n * @param predicates  the predicates to validate\n * @return predicate array\n */\nstatic <T> Predicate<? super T>[] validate(final Collection<? extends Predicate<? super T>> predicates) {\n    if (predicates == null) {\n        throw new NullPointerException(\"The predicate collection must not be null\");\n    }\n    // convert to array like this to guarantee iterator() ordering\n    // OK\n    @SuppressWarnings(\"unchecked\")\n    final Predicate<? super T>[] preds = new Predicate[predicates.size()];\n    int i = 0;\n    for (final Predicate<? super T> predicate : predicates) {\n        preds[i] = predicate;\n        if (preds[i] == null) {\n            throw new NullPointerException(\"The predicate collection must not contain a null predicate, index \" + i + \" was null\");\n        }\n        i++;\n    }\n    return preds;\n}"
            ],
            [
                "copy",
                "org.apache.commons.collections4.functors",
                "FunctorUtils",
                "/**\n * Clone the closures to ensure that the internal reference can't be messed with.\n *\n * @param closures  the closures to copy\n * @return the cloned closures\n */\n@SuppressWarnings(\"unchecked\")\nstatic <E> Closure<E>[] copy(final Closure<? super E>... closures) {\n    if (closures == null) {\n        return null;\n    }\n    return (Closure<E>[]) closures.clone();\n}"
            ],
            [
                "coerce",
                "org.apache.commons.collections4.functors",
                "FunctorUtils",
                "/**\n * A very simple method that coerces Closure<? super T> to Closure<T>.\n * <p>This method exists\n * simply as centralised documentation and atomic unchecked warning\n * suppression.\n *\n * @param <T> the type of object the returned closure should \"accept\"\n * @param closure the closure to coerce.\n * @return the coerced closure.\n */\n@SuppressWarnings(\"unchecked\")\nstatic <T> Closure<T> coerce(final Closure<? super T> closure) {\n    return (Closure<T>) closure;\n}"
            ],
            [
                "copy",
                "org.apache.commons.collections4.functors",
                "FunctorUtils",
                "/**\n * Copy method\n *\n * @param transformers  the transformers to copy\n * @return a clone of the transformers\n */\n@SuppressWarnings(\"unchecked\")\nstatic <I, O> Transformer<I, O>[] copy(final Transformer<? super I, ? extends O>... transformers) {\n    if (transformers == null) {\n        return null;\n    }\n    return (Transformer<I, O>[]) transformers.clone();\n}"
            ],
            [
                "coerce",
                "org.apache.commons.collections4.functors",
                "FunctorUtils",
                "/**\n * A very simple method that coerces Transformer<? super I, ? extends O> to Transformer<I, O>.\n * <p>This method exists\n * simply as centralised documentation and atomic unchecked warning\n * suppression.\n *\n * @param <T> the type of object the returned transformer should \"accept\"\n * @param transformer the transformer to coerce.\n * @return the coerced transformer.\n */\n@SuppressWarnings(\"unchecked\")\nstatic <I, O> Transformer<I, O> coerce(final Transformer<? super I, ? extends O> transformer) {\n    return (Transformer<I, O>) transformer;\n}"
            ],
            [
                "transformerPredicate",
                "org.apache.commons.collections4.functors",
                "TransformerPredicate",
                "/**\n * Factory to create the predicate.\n *\n * @param <T> the type that the predicate queries\n * @param transformer  the transformer to decorate\n * @return the predicate\n * @throws NullPointerException if the transformer is null\n */\npublic static <T> Predicate<T> transformerPredicate(final Transformer<? super T, Boolean> transformer) {\n    if (transformer == null) {\n        throw new NullPointerException(\"The transformer to call must not be null\");\n    }\n    return new TransformerPredicate<T>(transformer);\n}"
            ],
            [
                "nullPredicate",
                "org.apache.commons.collections4.functors",
                "NullPredicate",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <T> the type that the predicate queries\n * @return the singleton instance\n * @since 3.1\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Predicate<T> nullPredicate() {\n    return (Predicate<T>) INSTANCE;\n}"
            ],
            [
                "nullTransformer",
                "org.apache.commons.collections4.functors",
                "ConstantTransformer",
                "/**\n * Get a typed null instance.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @return Transformer<I, O> that always returns null.\n */\n// The null transformer works for all object types\n@SuppressWarnings(\"unchecked\")\npublic static <I, O> Transformer<I, O> nullTransformer() {\n    return (Transformer<I, O>) NULL_INSTANCE;\n}"
            ],
            [
                "constantTransformer",
                "org.apache.commons.collections4.functors",
                "ConstantTransformer",
                "/**\n * Transformer method that performs validation.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param constantToReturn  the constant object to return each time in the factory\n * @return the <code>constant</code> factory.\n */\npublic static <I, O> Transformer<I, O> constantTransformer(final O constantToReturn) {\n    if (constantToReturn == null) {\n        return nullTransformer();\n    }\n    return new ConstantTransformer<I, O>(constantToReturn);\n}"
            ],
            [
                "predicateTransformer",
                "org.apache.commons.collections4.functors",
                "PredicateTransformer",
                "/**\n * Factory method that performs validation.\n *\n * @param <T>  the input type\n * @param predicate  the predicate to call, not null\n * @return the <code>predicate</code> transformer\n * @throws IllegalArgumentException if the predicate is null\n */\npublic static <T> Transformer<T, Boolean> predicateTransformer(final Predicate<? super T> predicate) {\n    if (predicate == null) {\n        throw new IllegalArgumentException(\"Predicate must not be null\");\n    }\n    return new PredicateTransformer<T>(predicate);\n}"
            ],
            [
                "whileClosure",
                "org.apache.commons.collections4.functors",
                "WhileClosure",
                "/**\n * Factory method that performs validation.\n *\n * @param <E> the type that the closure acts on\n * @param predicate  the predicate used to evaluate when the loop terminates, not null\n * @param closure  the closure the execute, not null\n * @param doLoop  true to act as a do-while loop, always executing the closure once\n * @return the <code>while</code> closure\n * @throws NullPointerException if the predicate or closure is null\n */\npublic static <E> Closure<E> whileClosure(final Predicate<? super E> predicate, final Closure<? super E> closure, final boolean doLoop) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    if (closure == null) {\n        throw new NullPointerException(\"Closure must not be null\");\n    }\n    return new WhileClosure<E>(predicate, closure, doLoop);\n}"
            ],
            [
                "forClosure",
                "org.apache.commons.collections4.functors",
                "ForClosure",
                "/**\n * Factory method that performs validation.\n * <p>\n * A null closure or zero count returns the <code>NOPClosure</code>.\n * A count of one returns the specified closure.\n *\n * @param <E> the type that the closure acts on\n * @param count  the number of times to execute the closure\n * @param closure  the closure to execute, not null\n * @return the <code>for</code> closure\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Closure<E> forClosure(final int count, final Closure<? super E> closure) {\n    if (count <= 0 || closure == null) {\n        return NOPClosure.<E>nopClosure();\n    }\n    if (count == 1) {\n        return (Closure<E>) closure;\n    }\n    return new ForClosure<E>(count, closure);\n}"
            ],
            [
                "nullIsTruePredicate",
                "org.apache.commons.collections4.functors",
                "NullIsTruePredicate",
                "/**\n * Factory to create the null true predicate.\n *\n * @param <T> the type that the predicate queries\n * @param predicate  the predicate to decorate, not null\n * @return the predicate\n * @throws NullPointerException if the predicate is null\n */\npublic static <T> Predicate<T> nullIsTruePredicate(final Predicate<? super T> predicate) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    return new NullIsTruePredicate<T>(predicate);\n}"
            ],
            [
                "transformedPredicate",
                "org.apache.commons.collections4.functors",
                "TransformedPredicate",
                "/**\n * Factory to create the predicate.\n *\n * @param <T> the type that the predicate queries\n * @param transformer  the transformer to call\n * @param predicate  the predicate to call with the result of the transform\n * @return the predicate\n * @throws NullPointerException if the transformer or the predicate is null\n */\npublic static <T> Predicate<T> transformedPredicate(final Transformer<? super T, ? extends T> transformer, final Predicate<? super T> predicate) {\n    if (transformer == null) {\n        throw new NullPointerException(\"The transformer to call must not be null\");\n    }\n    if (predicate == null) {\n        throw new NullPointerException(\"The predicate to call must not be null\");\n    }\n    return new TransformedPredicate<T>(transformer, predicate);\n}"
            ],
            [
                "nonePredicate",
                "org.apache.commons.collections4.functors",
                "NonePredicate",
                "/**\n * Factory to create the predicate.\n * <p>\n * If the array is size zero, the predicate always returns true.\n *\n * @param <T> the type that the predicate queries\n * @param predicates  the predicates to check, cloned, not null\n * @return the <code>any</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n */\npublic static <T> Predicate<T> nonePredicate(final Predicate<? super T>... predicates) {\n    FunctorUtils.validate(predicates);\n    if (predicates.length == 0) {\n        return TruePredicate.<T>truePredicate();\n    }\n    return new NonePredicate<T>(FunctorUtils.copy(predicates));\n}"
            ],
            [
                "nonePredicate",
                "org.apache.commons.collections4.functors",
                "NonePredicate",
                "/**\n * Factory to create the predicate.\n * <p>\n * If the collection is size zero, the predicate always returns true.\n *\n * @param <T> the type that the predicate queries\n * @param predicates  the predicates to check, cloned, not null\n * @return the <code>one</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n */\npublic static <T> Predicate<T> nonePredicate(final Collection<? extends Predicate<? super T>> predicates) {\n    final Predicate<? super T>[] preds = FunctorUtils.validate(predicates);\n    if (preds.length == 0) {\n        return TruePredicate.<T>truePredicate();\n    }\n    return new NonePredicate<T>(preds);\n}"
            ],
            [
                "exceptionTransformer",
                "org.apache.commons.collections4.functors",
                "ExceptionTransformer",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @return the singleton instance\n * @since 3.1\n */\n// the static instance works for all types\n@SuppressWarnings(\"unchecked\")\npublic static <I, O> Transformer<I, O> exceptionTransformer() {\n    return (Transformer<I, O>) INSTANCE;\n}"
            ],
            [
                "switchTransformer",
                "org.apache.commons.collections4.functors",
                "SwitchTransformer",
                "/**\n * Factory method that performs validation and copies the parameter arrays.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param predicates  array of predicates, cloned, no nulls\n * @param transformers  matching array of transformers, cloned, no nulls\n * @param defaultTransformer  the transformer to use if no match, null means return null\n * @return the <code>chained</code> transformer\n * @throws NullPointerException if array is null\n * @throws NullPointerException if any element in the array is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <I, O> Transformer<I, O> switchTransformer(final Predicate<? super I>[] predicates, final Transformer<? super I, ? extends O>[] transformers, final Transformer<? super I, ? extends O> defaultTransformer) {\n    FunctorUtils.validate(predicates);\n    FunctorUtils.validate(transformers);\n    if (predicates.length != transformers.length) {\n        throw new IllegalArgumentException(\"The predicate and transformer arrays must be the same size\");\n    }\n    if (predicates.length == 0) {\n        return (Transformer<I, O>) (defaultTransformer == null ? ConstantTransformer.<I, O>nullTransformer() : defaultTransformer);\n    }\n    return new SwitchTransformer<I, O>(predicates, transformers, defaultTransformer);\n}"
            ],
            [
                "switchTransformer",
                "org.apache.commons.collections4.functors",
                "SwitchTransformer",
                "/**\n * Create a new Transformer that calls one of the transformers depending\n * on the predicates.\n * <p>\n * The Map consists of Predicate keys and Transformer values. A transformer\n * is called if its matching predicate returns true. Each predicate is evaluated\n * until one returns true. If no predicates evaluate to true, the default\n * transformer is called. The default transformer is set in the map with a\n * null key. The ordering is that of the iterator() method on the entryset\n * collection of the map.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param map  a map of predicates to transformers\n * @return the <code>switch</code> transformer\n * @throws NullPointerException if the map is null\n * @throws NullPointerException if any transformer in the map is null\n * @throws ClassCastException  if the map elements are of the wrong type\n */\n@SuppressWarnings(\"unchecked\")\npublic static <I, O> Transformer<I, O> switchTransformer(final Map<? extends Predicate<? super I>, ? extends Transformer<? super I, ? extends O>> map) {\n    if (map == null) {\n        throw new NullPointerException(\"The predicate and transformer map must not be null\");\n    }\n    if (map.size() == 0) {\n        return ConstantTransformer.<I, O>nullTransformer();\n    }\n    // convert to array like this to guarantee iterator() ordering\n    final Transformer<? super I, ? extends O> defaultTransformer = map.remove(null);\n    final int size = map.size();\n    if (size == 0) {\n        return (Transformer<I, O>) (defaultTransformer == null ? ConstantTransformer.<I, O>nullTransformer() : defaultTransformer);\n    }\n    final Transformer<? super I, ? extends O>[] transformers = new Transformer[size];\n    final Predicate<? super I>[] preds = new Predicate[size];\n    int i = 0;\n    for (final Map.Entry<? extends Predicate<? super I>, ? extends Transformer<? super I, ? extends O>> entry : map.entrySet()) {\n        preds[i] = entry.getKey();\n        transformers[i] = entry.getValue();\n        i++;\n    }\n    return new SwitchTransformer<I, O>(false, preds, transformers, defaultTransformer);\n}"
            ],
            [
                "transformerClosure",
                "org.apache.commons.collections4.functors",
                "TransformerClosure",
                "/**\n * Factory method that performs validation.\n * <p>\n * A null transformer will return the <code>NOPClosure</code>.\n *\n * @param <E> the type that the closure acts on\n * @param transformer  the transformer to call, null means nop\n * @return the <code>transformer</code> closure\n */\npublic static <E> Closure<E> transformerClosure(final Transformer<? super E, ?> transformer) {\n    if (transformer == null) {\n        return NOPClosure.<E>nopClosure();\n    }\n    return new TransformerClosure<E>(transformer);\n}"
            ],
            [
                "orPredicate",
                "org.apache.commons.collections4.functors",
                "OrPredicate",
                "/**\n * Factory to create the predicate.\n *\n * @param <T> the type that the predicate queries\n * @param predicate1  the first predicate to check, not null\n * @param predicate2  the second predicate to check, not null\n * @return the <code>and</code> predicate\n * @throws NullPointerException if either predicate is null\n */\npublic static <T> Predicate<T> orPredicate(final Predicate<? super T> predicate1, final Predicate<? super T> predicate2) {\n    if (predicate1 == null || predicate2 == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    return new OrPredicate<T>(predicate1, predicate2);\n}"
            ],
            [
                "nopTransformer",
                "org.apache.commons.collections4.functors",
                "NOPTransformer",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <T>  the input/output type\n * @return the singleton instance\n * @since 3.1\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Transformer<T, T> nopTransformer() {\n    return (Transformer<T, T>) INSTANCE;\n}"
            ],
            [
                "mapTransformer",
                "org.apache.commons.collections4.functors",
                "MapTransformer",
                "/**\n * Factory to create the transformer.\n * <p>\n * If the map is null, a transformer that always returns null is returned.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param map the map, not cloned\n * @return the transformer\n */\npublic static <I, O> Transformer<I, O> mapTransformer(final Map<? super I, ? extends O> map) {\n    if (map == null) {\n        return ConstantTransformer.<I, O>nullTransformer();\n    }\n    return new MapTransformer<I, O>(map);\n}"
            ],
            [
                "exceptionFactory",
                "org.apache.commons.collections4.functors",
                "ExceptionFactory",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <T>  the type the factory creates\n * @return the singleton instance\n * @since 3.1\n */\n// the static instance works for all types\n@SuppressWarnings(\"unchecked\")\npublic static <T> Factory<T> exceptionFactory() {\n    return (Factory<T>) INSTANCE;\n}"
            ],
            [
                "chainedClosure",
                "org.apache.commons.collections4.functors",
                "ChainedClosure",
                "/**\n * Factory method that performs validation and copies the parameter array.\n *\n * @param <E> the type that the closure acts on\n * @param closures  the closures to chain, copied, no nulls\n * @return the <code>chained</code> closure\n * @throws NullPointerException if the closures array is null\n * @throws NullPointerException if any closure in the array is null\n */\npublic static <E> Closure<E> chainedClosure(final Closure<? super E>... closures) {\n    FunctorUtils.validate(closures);\n    if (closures.length == 0) {\n        return NOPClosure.<E>nopClosure();\n    }\n    return new ChainedClosure<E>(closures);\n}"
            ],
            [
                "chainedClosure",
                "org.apache.commons.collections4.functors",
                "ChainedClosure",
                "/**\n * Create a new Closure that calls each closure in turn, passing the\n * result into the next closure. The ordering is that of the iterator()\n * method on the collection.\n *\n * @param <E> the type that the closure acts on\n * @param closures  a collection of closures to chain\n * @return the <code>chained</code> closure\n * @throws NullPointerException if the closures collection is null\n * @throws NullPointerException if any closure in the collection is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Closure<E> chainedClosure(final Collection<? extends Closure<? super E>> closures) {\n    if (closures == null) {\n        throw new NullPointerException(\"Closure collection must not be null\");\n    }\n    if (closures.size() == 0) {\n        return NOPClosure.<E>nopClosure();\n    }\n    // convert to array like this to guarantee iterator() ordering\n    final Closure<? super E>[] cmds = new Closure[closures.size()];\n    int i = 0;\n    for (final Closure<? super E> closure : closures) {\n        cmds[i++] = closure;\n    }\n    FunctorUtils.validate(cmds);\n    return new ChainedClosure<E>(false, cmds);\n}"
            ],
            [
                "andPredicate",
                "org.apache.commons.collections4.functors",
                "AndPredicate",
                "/**\n * Factory to create the predicate.\n *\n * @param <T> the type that the predicate queries\n * @param predicate1  the first predicate to check, not null\n * @param predicate2  the second predicate to check, not null\n * @return the <code>and</code> predicate\n * @throws NullPointerException if either predicate is null\n */\npublic static <T> Predicate<T> andPredicate(final Predicate<? super T> predicate1, final Predicate<? super T> predicate2) {\n    if (predicate1 == null || predicate2 == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    return new AndPredicate<T>(predicate1, predicate2);\n}"
            ],
            [
                "prototypeFactory",
                "org.apache.commons.collections4.functors",
                "PrototypeFactory",
                "/**\n * Factory method that performs validation.\n * <p>\n * Creates a Factory that will return a clone of the same prototype object\n * each time the factory is used. The prototype will be cloned using one of these\n * techniques (in order):\n * <ul>\n * <li>public clone method\n * <li>public copy constructor\n * <li>serialization clone\n * <ul>\n *\n * @param <T>  the type the factory creates\n * @param prototype  the object to clone each time in the factory\n * @return the <code>prototype</code> factory, or a {@link ConstantFactory#NULL_INSTANCE} if\n * the {@code prototype} is {@code null}\n * @throws IllegalArgumentException if the prototype cannot be cloned\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Factory<T> prototypeFactory(final T prototype) {\n    if (prototype == null) {\n        return ConstantFactory.<T>constantFactory(null);\n    }\n    try {\n        final Method method = prototype.getClass().getMethod(\"clone\", (Class[]) null);\n        return new PrototypeCloneFactory<T>(prototype, method);\n    } catch (final NoSuchMethodException ex) {\n        try {\n            prototype.getClass().getConstructor(new Class<?>[] { prototype.getClass() });\n            return new InstantiateFactory<T>((Class<T>) prototype.getClass(), new Class<?>[] { prototype.getClass() }, new Object[] { prototype });\n        } catch (final NoSuchMethodException ex2) {\n            if (prototype instanceof Serializable) {\n                return (Factory<T>) new PrototypeSerializationFactory<Serializable>((Serializable) prototype);\n            }\n        }\n    }\n    throw new IllegalArgumentException(\"The prototype must be cloneable via a public clone method\");\n}"
            ],
            [
                "exceptionPredicate",
                "org.apache.commons.collections4.functors",
                "ExceptionPredicate",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <T>  the object type\n * @return the singleton instance\n * @since 3.1\n */\n// the static instance works for all types\n@SuppressWarnings(\"unchecked\")\npublic static <T> Predicate<T> exceptionPredicate() {\n    return (Predicate<T>) INSTANCE;\n}"
            ],
            [
                "instanceOfPredicate",
                "org.apache.commons.collections4.functors",
                "InstanceofPredicate",
                "/**\n * Factory to create the identity predicate.\n *\n * @param type  the type to check for, may not be null\n * @return the predicate\n * @throws NullPointerException if the class is null\n */\npublic static Predicate<Object> instanceOfPredicate(final Class<?> type) {\n    if (type == null) {\n        throw new NullPointerException(\"The type to check instanceof must not be null\");\n    }\n    return new InstanceofPredicate(type);\n}"
            ],
            [
                "invokerTransformer",
                "org.apache.commons.collections4.functors",
                "InvokerTransformer",
                "/**\n * Gets an instance of this transformer calling a specific method with no arguments.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param methodName  the method name to call\n * @return an invoker transformer\n * @throws NullPointerException if methodName is null\n * @since 3.1\n */\npublic static <I, O> Transformer<I, O> invokerTransformer(final String methodName) {\n    if (methodName == null) {\n        throw new NullPointerException(\"The method to invoke must not be null\");\n    }\n    return new InvokerTransformer<I, O>(methodName);\n}"
            ],
            [
                "invokerTransformer",
                "org.apache.commons.collections4.functors",
                "InvokerTransformer",
                "/**\n * Gets an instance of this transformer calling a specific method with specific values.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param methodName  the method name to call\n * @param paramTypes  the parameter types of the method\n * @param args  the arguments to pass to the method\n * @return an invoker transformer\n * @throws NullPointerException if methodName is null\n * @throws IllegalArgumentException if paramTypes does not match args\n */\npublic static <I, O> Transformer<I, O> invokerTransformer(final String methodName, final Class<?>[] paramTypes, final Object[] args) {\n    if (methodName == null) {\n        throw new NullPointerException(\"The method to invoke must not be null\");\n    }\n    if (((paramTypes == null) && (args != null)) || ((paramTypes != null) && (args == null)) || ((paramTypes != null) && (args != null) && (paramTypes.length != args.length))) {\n        throw new IllegalArgumentException(\"The parameter types must match the arguments\");\n    }\n    if (paramTypes == null || paramTypes.length == 0) {\n        return new InvokerTransformer<I, O>(methodName);\n    }\n    return new InvokerTransformer<I, O>(methodName, paramTypes, args);\n}"
            ],
            [
                "falsePredicate",
                "org.apache.commons.collections4.functors",
                "FalsePredicate",
                "/**\n * Get a typed instance.\n *\n * @param <T> the type that the predicate queries\n * @return the singleton instance\n * @since 4.0\n */\n// the static instance works for all types\n@SuppressWarnings(\"unchecked\")\npublic static <T> Predicate<T> falsePredicate() {\n    return (Predicate<T>) INSTANCE;\n}"
            ],
            [
                "cloneTransformer",
                "org.apache.commons.collections4.functors",
                "CloneTransformer",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <T>  the type of the objects to be cloned\n * @return the singleton instance\n * @since 3.1\n */\n// the singleton instance works for all types\n@SuppressWarnings(\"unchecked\")\npublic static <T> Transformer<T, T> cloneTransformer() {\n    return INSTANCE;\n}"
            ],
            [
                "notPredicate",
                "org.apache.commons.collections4.functors",
                "NotPredicate",
                "/**\n * Factory to create the not predicate.\n *\n * @param <T> the type that the predicate queries\n * @param predicate  the predicate to decorate, not null\n * @return the predicate\n * @throws NullPointerException if the predicate is null\n */\npublic static <T> Predicate<T> notPredicate(final Predicate<? super T> predicate) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    return new NotPredicate<T>(predicate);\n}"
            ],
            [
                "constantFactory",
                "org.apache.commons.collections4.functors",
                "ConstantFactory",
                "/**\n * Factory method that performs validation.\n *\n * @param <T>  the type of the constant\n * @param constantToReturn  the constant object to return each time in the factory\n * @return the <code>constant</code> factory.\n */\n// The null factory works for all object types\n@SuppressWarnings(\"unchecked\")\npublic static <T> Factory<T> constantFactory(final T constantToReturn) {\n    if (constantToReturn == null) {\n        return (Factory<T>) NULL_INSTANCE;\n    }\n    return new ConstantFactory<T>(constantToReturn);\n}"
            ],
            [
                "chainedTransformer",
                "org.apache.commons.collections4.functors",
                "ChainedTransformer",
                "/**\n * Factory method that performs validation and copies the parameter array.\n *\n * @param <T>  the object type\n * @param transformers  the transformers to chain, copied, no nulls\n * @return the <code>chained</code> transformer\n * @throws NullPointerException if the transformers array is null\n * @throws NullPointerException if any transformer in the array is null\n */\npublic static <T> Transformer<T, T> chainedTransformer(final Transformer<? super T, ? extends T>... transformers) {\n    FunctorUtils.validate(transformers);\n    if (transformers.length == 0) {\n        return NOPTransformer.<T>nopTransformer();\n    }\n    return new ChainedTransformer<T>(transformers);\n}"
            ],
            [
                "chainedTransformer",
                "org.apache.commons.collections4.functors",
                "ChainedTransformer",
                "/**\n * Create a new Transformer that calls each transformer in turn, passing the\n * result into the next transformer. The ordering is that of the iterator()\n * method on the collection.\n *\n * @param <T>  the object type\n * @param transformers  a collection of transformers to chain\n * @return the <code>chained</code> transformer\n * @throws NullPointerException if the transformers collection is null\n * @throws NullPointerException if any transformer in the collection is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Transformer<T, T> chainedTransformer(final Collection<? extends Transformer<? super T, ? extends T>> transformers) {\n    if (transformers == null) {\n        throw new NullPointerException(\"Transformer collection must not be null\");\n    }\n    if (transformers.size() == 0) {\n        return NOPTransformer.<T>nopTransformer();\n    }\n    // convert to array like this to guarantee iterator() ordering\n    final Transformer<T, T>[] cmds = transformers.toArray(new Transformer[transformers.size()]);\n    FunctorUtils.validate(cmds);\n    return new ChainedTransformer<T>(false, cmds);\n}"
            ],
            [
                "comparatorPredicate",
                "org.apache.commons.collections4.functors",
                "ComparatorPredicate",
                "/**\n * Factory to create the comparator predicate\n *\n * @param <T> the type that the predicate queries\n * @param object  the object to compare to\n * @param comparator  the comparator to use for comparison\n * @return the predicate\n * @throws NullPointerException if comparator is null\n */\npublic static <T> Predicate<T> comparatorPredicate(final T object, final Comparator<T> comparator) {\n    return comparatorPredicate(object, comparator, Criterion.EQUAL);\n}"
            ],
            [
                "comparatorPredicate",
                "org.apache.commons.collections4.functors",
                "ComparatorPredicate",
                "/**\n * Factory to create the comparator predicate\n *\n * @param <T> the type that the predicate queries\n * @param object  the object to compare to\n * @param comparator  the comparator to use for comparison\n * @param criterion  the criterion to use to evaluate comparison\n * @return the predicate\n * @throws NullPointerException if comparator or criterion is null\n */\npublic static <T> Predicate<T> comparatorPredicate(final T object, final Comparator<T> comparator, final Criterion criterion) {\n    if (comparator == null) {\n        throw new NullPointerException(\"Comparator must not be null.\");\n    }\n    if (criterion == null) {\n        throw new NullPointerException(\"Criterion must not be null.\");\n    }\n    return new ComparatorPredicate<T>(object, comparator, criterion);\n}"
            ],
            [
                "allPredicate",
                "org.apache.commons.collections4.functors",
                "AllPredicate",
                "/**\n * Factory to create the predicate.\n * <p>\n * If the array is size zero, the predicate always returns true.\n * If the array is size one, then that predicate is returned.\n *\n * @param <T> the type that the predicate queries\n * @param predicates  the predicates to check, cloned, not null\n * @return the <code>all</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n */\npublic static <T> Predicate<T> allPredicate(final Predicate<? super T>... predicates) {\n    FunctorUtils.validate(predicates);\n    if (predicates.length == 0) {\n        return truePredicate();\n    }\n    if (predicates.length == 1) {\n        return coerce(predicates[0]);\n    }\n    return new AllPredicate<T>(FunctorUtils.copy(predicates));\n}"
            ],
            [
                "allPredicate",
                "org.apache.commons.collections4.functors",
                "AllPredicate",
                "/**\n * Factory to create the predicate.\n * <p>\n * If the collection is size zero, the predicate always returns true.\n * If the collection is size one, then that predicate is returned.\n *\n * @param <T> the type that the predicate queries\n * @param predicates  the predicates to check, cloned, not null\n * @return the <code>all</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n */\npublic static <T> Predicate<T> allPredicate(final Collection<? extends Predicate<? super T>> predicates) {\n    final Predicate<? super T>[] preds = validate(predicates);\n    if (preds.length == 0) {\n        return truePredicate();\n    }\n    if (preds.length == 1) {\n        return coerce(preds[0]);\n    }\n    return new AllPredicate<T>(preds);\n}"
            ],
            [
                "nullIsFalsePredicate",
                "org.apache.commons.collections4.functors",
                "NullIsFalsePredicate",
                "/**\n * Factory to create the null false predicate.\n *\n * @param <T> the type that the predicate queries\n * @param predicate  the predicate to decorate, not null\n * @return the predicate\n * @throws NullPointerException if the predicate is null\n */\npublic static <T> Predicate<T> nullIsFalsePredicate(final Predicate<? super T> predicate) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    return new NullIsFalsePredicate<T>(predicate);\n}"
            ],
            [
                "nullIsExceptionPredicate",
                "org.apache.commons.collections4.functors",
                "NullIsExceptionPredicate",
                "/**\n * Factory to create the null exception predicate.\n *\n * @param <T> the type that the predicate queries\n * @param predicate  the predicate to decorate, not null\n * @return the predicate\n * @throws NullPointerException if the predicate is null\n */\npublic static <T> Predicate<T> nullIsExceptionPredicate(final Predicate<? super T> predicate) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    return new NullIsExceptionPredicate<T>(predicate);\n}"
            ],
            [
                "anyPredicate",
                "org.apache.commons.collections4.functors",
                "AnyPredicate",
                "/**\n * Factory to create the predicate.\n * <p>\n * If the array is size zero, the predicate always returns false.\n * If the array is size one, then that predicate is returned.\n *\n * @param <T> the type that the predicate queries\n * @param predicates  the predicates to check, cloned, not null\n * @return the <code>any</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Predicate<T> anyPredicate(final Predicate<? super T>... predicates) {\n    FunctorUtils.validate(predicates);\n    if (predicates.length == 0) {\n        return FalsePredicate.<T>falsePredicate();\n    }\n    if (predicates.length == 1) {\n        return (Predicate<T>) predicates[0];\n    }\n    return new AnyPredicate<T>(FunctorUtils.copy(predicates));\n}"
            ],
            [
                "anyPredicate",
                "org.apache.commons.collections4.functors",
                "AnyPredicate",
                "/**\n * Factory to create the predicate.\n * <p>\n * If the collection is size zero, the predicate always returns false.\n * If the collection is size one, then that predicate is returned.\n *\n * @param <T> the type that the predicate queries\n * @param predicates  the predicates to check, cloned, not null\n * @return the <code>all</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Predicate<T> anyPredicate(final Collection<? extends Predicate<? super T>> predicates) {\n    final Predicate<? super T>[] preds = FunctorUtils.validate(predicates);\n    if (preds.length == 0) {\n        return FalsePredicate.<T>falsePredicate();\n    }\n    if (preds.length == 1) {\n        return (Predicate<T>) preds[0];\n    }\n    return new AnyPredicate<T>(preds);\n}"
            ],
            [
                "truePredicate",
                "org.apache.commons.collections4.functors",
                "TruePredicate",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <T> the type that the predicate queries\n * @return the singleton instance\n * @since 3.1\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Predicate<T> truePredicate() {\n    return (Predicate<T>) INSTANCE;\n}"
            ],
            [
                "factoryTransformer",
                "org.apache.commons.collections4.functors",
                "FactoryTransformer",
                "/**\n * Factory method that performs validation.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param factory  the factory to call, not null\n * @return the <code>factory</code> transformer\n * @throws NullPointerException if the factory is null\n */\npublic static <I, O> Transformer<I, O> factoryTransformer(final Factory<? extends O> factory) {\n    if (factory == null) {\n        throw new NullPointerException(\"Factory must not be null\");\n    }\n    return new FactoryTransformer<I, O>(factory);\n}"
            ],
            [
                "notNullPredicate",
                "org.apache.commons.collections4.functors",
                "NotNullPredicate",
                "/**\n * Factory returning the singleton instance.\n *\n * @param <T> the type that the predicate queries\n * @return the singleton instance\n * @since 3.1\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Predicate<T> notNullPredicate() {\n    return (Predicate<T>) INSTANCE;\n}"
            ],
            [
                "switchClosure",
                "org.apache.commons.collections4.functors",
                "SwitchClosure",
                "/**\n * Factory method that performs validation and copies the parameter arrays.\n *\n * @param <E> the type that the closure acts on\n * @param predicates  array of predicates, cloned, no nulls\n * @param closures  matching array of closures, cloned, no nulls\n * @param defaultClosure  the closure to use if no match, null means nop\n * @return the <code>chained</code> closure\n * @throws NullPointerException if array is null\n * @throws NullPointerException if any element in the array is null\n * @throws IllegalArgumentException if the array lengths of predicates and closures do not match\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Closure<E> switchClosure(final Predicate<? super E>[] predicates, final Closure<? super E>[] closures, final Closure<? super E> defaultClosure) {\n    FunctorUtils.validate(predicates);\n    FunctorUtils.validate(closures);\n    if (predicates.length != closures.length) {\n        throw new IllegalArgumentException(\"The predicate and closure arrays must be the same size\");\n    }\n    if (predicates.length == 0) {\n        return (Closure<E>) (defaultClosure == null ? NOPClosure.<E>nopClosure() : defaultClosure);\n    }\n    return new SwitchClosure<E>(predicates, closures, defaultClosure);\n}"
            ],
            [
                "switchClosure",
                "org.apache.commons.collections4.functors",
                "SwitchClosure",
                "/**\n * Create a new Closure that calls one of the closures depending\n * on the predicates.\n * <p>\n * The Map consists of Predicate keys and Closure values. A closure\n * is called if its matching predicate returns true. Each predicate is evaluated\n * until one returns true. If no predicates evaluate to true, the default\n * closure is called. The default closure is set in the map with a\n * null key. The ordering is that of the iterator() method on the entryset\n * collection of the map.\n *\n * @param <E> the type that the closure acts on\n * @param predicatesAndClosures  a map of predicates to closures\n * @return the <code>switch</code> closure\n * @throws NullPointerException if the map is null\n * @throws NullPointerException if any closure in the map is null\n * @throws ClassCastException  if the map elements are of the wrong type\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Closure<E> switchClosure(final Map<Predicate<E>, Closure<E>> predicatesAndClosures) {\n    if (predicatesAndClosures == null) {\n        throw new NullPointerException(\"The predicate and closure map must not be null\");\n    }\n    // convert to array like this to guarantee iterator() ordering\n    final Closure<? super E> defaultClosure = predicatesAndClosures.remove(null);\n    final int size = predicatesAndClosures.size();\n    if (size == 0) {\n        return (Closure<E>) (defaultClosure == null ? NOPClosure.<E>nopClosure() : defaultClosure);\n    }\n    final Closure<E>[] closures = new Closure[size];\n    final Predicate<E>[] preds = new Predicate[size];\n    int i = 0;\n    for (final Map.Entry<Predicate<E>, Closure<E>> entry : predicatesAndClosures.entrySet()) {\n        preds[i] = entry.getKey();\n        closures[i] = entry.getValue();\n        i++;\n    }\n    return new SwitchClosure<E>(false, preds, closures, defaultClosure);\n}"
            ],
            [
                "uniquePredicate",
                "org.apache.commons.collections4.functors",
                "UniquePredicate",
                "/**\n * Factory to create the predicate.\n *\n * @param <T> the type that the predicate queries\n * @return the predicate\n * @throws IllegalArgumentException if the predicate is null\n */\npublic static <T> Predicate<T> uniquePredicate() {\n    return new UniquePredicate<T>();\n}"
            ],
            [
                "instantiateTransformer",
                "org.apache.commons.collections4.functors",
                "InstantiateTransformer",
                "/**\n * Get a typed no-arg instance.\n *\n * @param <T>  the type of the objects to be created\n * @return Transformer<Class<? extends T>, T>\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Transformer<Class<? extends T>, T> instantiateTransformer() {\n    return NO_ARG_INSTANCE;\n}"
            ],
            [
                "instantiateTransformer",
                "org.apache.commons.collections4.functors",
                "InstantiateTransformer",
                "/**\n * Transformer method that performs validation.\n *\n * @param <T>  the type of the objects to be created\n * @param paramTypes  the constructor parameter types\n * @param args  the constructor arguments\n * @return an instantiate transformer\n * @throws IllegalArgumentException if paramTypes does not match args\n */\npublic static <T> Transformer<Class<? extends T>, T> instantiateTransformer(final Class<?>[] paramTypes, final Object[] args) {\n    if (((paramTypes == null) && (args != null)) || ((paramTypes != null) && (args == null)) || ((paramTypes != null) && (args != null) && (paramTypes.length != args.length))) {\n        throw new IllegalArgumentException(\"Parameter types must match the arguments\");\n    }\n    if (paramTypes == null || paramTypes.length == 0) {\n        return new InstantiateTransformer<T>();\n    }\n    return new InstantiateTransformer<T>(paramTypes, args);\n}"
            ],
            [
                "onePredicate",
                "org.apache.commons.collections4.functors",
                "OnePredicate",
                "/**\n * Factory to create the predicate.\n * <p>\n * If the array is size zero, the predicate always returns false.\n * If the array is size one, then that predicate is returned.\n *\n * @param <T> the type that the predicate queries\n * @param predicates  the predicates to check, cloned, not null\n * @return the <code>any</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> Predicate<T> onePredicate(final Predicate<? super T>... predicates) {\n    FunctorUtils.validate(predicates);\n    if (predicates.length == 0) {\n        return FalsePredicate.<T>falsePredicate();\n    }\n    if (predicates.length == 1) {\n        return (Predicate<T>) predicates[0];\n    }\n    return new OnePredicate<T>(FunctorUtils.copy(predicates));\n}"
            ],
            [
                "onePredicate",
                "org.apache.commons.collections4.functors",
                "OnePredicate",
                "/**\n * Factory to create the predicate.\n *\n * @param <T> the type that the predicate queries\n * @param predicates  the predicates to check, cloned, not null\n * @return the <code>one</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n */\npublic static <T> Predicate<T> onePredicate(final Collection<? extends Predicate<? super T>> predicates) {\n    final Predicate<? super T>[] preds = FunctorUtils.validate(predicates);\n    return new OnePredicate<T>(preds);\n}"
            ],
            [
                "equalPredicate",
                "org.apache.commons.collections4.functors",
                "EqualPredicate",
                "/**\n * Factory to create the predicate.\n *\n * @param <T> the type that the predicate queries\n * @param object  the object to compare to\n * @return the predicate\n */\npublic static <T> Predicate<T> equalPredicate(final T object) {\n    if (object == null) {\n        return NullPredicate.nullPredicate();\n    }\n    return new EqualPredicate<T>(object);\n}"
            ],
            [
                "equalPredicate",
                "org.apache.commons.collections4.functors",
                "EqualPredicate",
                "/**\n * Factory to create the identity predicate.\n *\n * @param <T> the type that the predicate queries\n * @param object  the object to compare to\n * @param equator  the equator to use for comparison\n * @return the predicate\n * @since 4.0\n */\npublic static <T> Predicate<T> equalPredicate(final T object, final Equator<T> equator) {\n    if (object == null) {\n        return NullPredicate.nullPredicate();\n    }\n    return new EqualPredicate<T>(object, equator);\n}"
            ],
            [
                "instantiateFactory",
                "org.apache.commons.collections4.functors",
                "InstantiateFactory",
                "/**\n * Factory method that performs validation.\n *\n * @param <T>  the type the factory creates\n * @param classToInstantiate  the class to instantiate, not null\n * @param paramTypes  the constructor parameter types, cloned\n * @param args  the constructor arguments, cloned\n * @return a new instantiate factory\n * @throws NullPointerException if classToInstantiate is null\n * @throws IllegalArgumentException if paramTypes does not match args\n */\npublic static <T> Factory<T> instantiateFactory(final Class<T> classToInstantiate, final Class<?>[] paramTypes, final Object[] args) {\n    if (classToInstantiate == null) {\n        throw new NullPointerException(\"Class to instantiate must not be null\");\n    }\n    if (paramTypes == null && args != null || paramTypes != null && args == null || paramTypes != null && args != null && paramTypes.length != args.length) {\n        throw new IllegalArgumentException(\"Parameter types must match the arguments\");\n    }\n    if (paramTypes == null || paramTypes.length == 0) {\n        return new InstantiateFactory<T>(classToInstantiate);\n    }\n    return new InstantiateFactory<T>(classToInstantiate, paramTypes, args);\n}"
            ],
            [
                "ifClosure",
                "org.apache.commons.collections4.functors",
                "IfClosure",
                "/**\n * Factory method that performs validation.\n * <p>\n * This factory creates a closure that performs no action when\n * the predicate is false.\n *\n * @param <E> the type that the closure acts on\n * @param predicate  predicate to switch on\n * @param trueClosure  closure used if true\n * @return the <code>if</code> closure\n * @throws NullPointerException if either argument is null\n * @since 3.2\n */\npublic static <E> Closure<E> ifClosure(final Predicate<? super E> predicate, final Closure<? super E> trueClosure) {\n    return IfClosure.<E>ifClosure(predicate, trueClosure, NOPClosure.<E>nopClosure());\n}"
            ],
            [
                "ifClosure",
                "org.apache.commons.collections4.functors",
                "IfClosure",
                "/**\n * Factory method that performs validation.\n *\n * @param <E> the type that the closure acts on\n * @param predicate  predicate to switch on\n * @param trueClosure  closure used if true\n * @param falseClosure  closure used if false\n * @return the <code>if</code> closure\n * @throws NullPointerException if any argument is null\n */\npublic static <E> Closure<E> ifClosure(final Predicate<? super E> predicate, final Closure<? super E> trueClosure, final Closure<? super E> falseClosure) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null\");\n    }\n    if (trueClosure == null || falseClosure == null) {\n        throw new NullPointerException(\"Closures must not be null\");\n    }\n    return new IfClosure<E>(predicate, trueClosure, falseClosure);\n}"
            ],
            [
                "getTrueFirstComparator",
                "org.apache.commons.collections4.comparators",
                "BooleanComparator",
                "//-----------------------------------------------------------------------\n/**\n * Returns a BooleanComparator instance that sorts\n * <code>true</code> values before <code>false</code> values.\n * <p />\n * Clients are encouraged to use the value returned from\n * this method instead of constructing a new instance\n * to reduce allocation and garbage collection overhead when\n * multiple BooleanComparators may be used in the same\n * virtual machine.\n *\n * @return the true first singleton BooleanComparator\n */\npublic static BooleanComparator getTrueFirstComparator() {\n    return TRUE_FIRST;\n}"
            ],
            [
                "getFalseFirstComparator",
                "org.apache.commons.collections4.comparators",
                "BooleanComparator",
                "/**\n * Returns a BooleanComparator instance that sorts\n * <code>false</code> values before <code>true</code> values.\n * <p />\n * Clients are encouraged to use the value returned from\n * this method instead of constructing a new instance\n * to reduce allocation and garbage collection overhead when\n * multiple BooleanComparators may be used in the same\n * virtual machine.\n *\n * @return the false first singleton BooleanComparator\n */\npublic static BooleanComparator getFalseFirstComparator() {\n    return FALSE_FIRST;\n}"
            ],
            [
                "booleanComparator",
                "org.apache.commons.collections4.comparators",
                "BooleanComparator",
                "/**\n * Returns a BooleanComparator instance that sorts\n * <code><i>trueFirst</i></code> values before\n * <code>&#x21;<i>trueFirst</i></code> values.\n * <p />\n * Clients are encouraged to use the value returned from\n * this method instead of constructing a new instance\n * to reduce allocation and garbage collection overhead when\n * multiple BooleanComparators may be used in the same\n * virtual machine.\n *\n * @param trueFirst when <code>true</code>, sort\n * <code>true</code> <code>Boolean</code>s before <code>false</code>\n * @return a singleton BooleanComparator instance\n * @since 4.0\n */\npublic static BooleanComparator booleanComparator(final boolean trueFirst) {\n    return trueFirst ? TRUE_FIRST : FALSE_FIRST;\n}"
            ],
            [
                "comparableComparator",
                "org.apache.commons.collections4.comparators",
                "ComparableComparator",
                "//-----------------------------------------------------------------------\n/**\n * Gets the singleton instance of a ComparableComparator.\n * <p>\n * Developers are encouraged to use the comparator returned from this method\n * instead of constructing a new instance to reduce allocation and GC overhead\n * when multiple comparable comparators may be used in the same VM.\n *\n * @param <E>  the element type\n * @return the singleton ComparableComparator\n * @since 4.0\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E extends Comparable<? super E>> ComparableComparator<E> comparableComparator() {\n    return INSTANCE;\n}"
            ],
            [
                "emptyCollection",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns the immutable EMPTY_COLLECTION with generic type safety.\n *\n * @see #EMPTY_COLLECTION\n * @since 4.0\n * @param <T> the element type\n * @return immutable empty collection\n */\n// OK, empty collection is compatible with any type\n@SuppressWarnings(\"unchecked\")\npublic static <T> Collection<T> emptyCollection() {\n    return EMPTY_COLLECTION;\n}"
            ],
            [
                "emptyIfNull",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns an immutable empty collection if the argument is <code>null</code>,\n * or the argument itself otherwise.\n *\n * @param <T> the element type\n * @param collection the collection, possibly <code>null</code>\n * @return an empty collection if the argument is <code>null</code>\n */\n// OK, empty collection is compatible with any type\n@SuppressWarnings(\"unchecked\")\npublic static <T> Collection<T> emptyIfNull(final Collection<T> collection) {\n    return collection == null ? EMPTY_COLLECTION : collection;\n}"
            ],
            [
                "union",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns a {@link Collection} containing the union of the given\n * {@link Iterable}s.\n * <p>\n * The cardinality of each element in the returned {@link Collection} will\n * be equal to the maximum of the cardinality of that element in the two\n * given {@link Iterable}s.\n *\n * @param a the first collection, must not be null\n * @param b the second collection, must not be null\n * @param <O> the generic type that is able to represent the types contained\n *        in both input collections.\n * @return the union of the two collections\n * @see Collection#addAll\n */\npublic static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}"
            ],
            [
                "intersection",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns a {@link Collection} containing the intersection of the given\n * {@link Iterable}s.\n * <p>\n * The cardinality of each element in the returned {@link Collection} will\n * be equal to the minimum of the cardinality of that element in the two\n * given {@link Iterable}s.\n *\n * @param a the first collection, must not be null\n * @param b the second collection, must not be null\n * @param <O> the generic type that is able to represent the types contained\n *        in both input collections.\n * @return the intersection of the two collections\n * @see Collection#retainAll\n * @see #containsAny\n */\npublic static <O> Collection<O> intersection(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.min(obj));\n    }\n    return helper.list();\n}"
            ],
            [
                "disjunction",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns a {@link Collection} containing the exclusive disjunction\n * (symmetric difference) of the given {@link Iterable}s.\n * <p>\n * The cardinality of each element <i>e</i> in the returned\n * {@link Collection} will be equal to\n * <tt>max(cardinality(<i>e</i>,<i>a</i>),cardinality(<i>e</i>,<i>b</i>)) - min(cardinality(<i>e</i>,<i>a</i>),\n * cardinality(<i>e</i>,<i>b</i>))</tt>.\n * <p>\n * This is equivalent to\n * {@code {@link #subtract subtract}({@link #union union(a,b)},{@link #intersection intersection(a,b)})}\n * or\n * {@code {@link #union union}({@link #subtract subtract(a,b)},{@link #subtract subtract(b,a)})}.\n *\n * @param a the first collection, must not be null\n * @param b the second collection, must not be null\n * @param <O> the generic type that is able to represent the types contained\n *        in both input collections.\n * @return the symmetric difference of the two collections\n */\npublic static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}"
            ],
            [
                "subtract",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns a new {@link Collection} containing {@code <i>a</i> - <i>b</i>}.\n * The cardinality of each element <i>e</i> in the returned {@link Collection}\n * will be the cardinality of <i>e</i> in <i>a</i> minus the cardinality\n * of <i>e</i> in <i>b</i>, or zero, whichever is greater.\n *\n * @param a  the collection to subtract from, must not be null\n * @param b  the collection to subtract, must not be null\n * @param <O> the generic type that is able to represent the types contained\n *        in both input collections.\n * @return a new collection with the results\n * @see Collection#removeAll\n */\npublic static <O> Collection<O> subtract(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n    final Predicate<O> p = TruePredicate.truePredicate();\n    return subtract(a, b, p);\n}"
            ],
            [
                "subtract",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns a new {@link Collection} containing <i>a</i> minus a subset of\n * <i>b</i>.  Only the elements of <i>b</i> that satisfy the predicate\n * condition, <i>p</i> are subtracted from <i>a</i>.\n *\n * <p>The cardinality of each element <i>e</i> in the returned {@link Collection}\n * that satisfies the predicate condition will be the cardinality of <i>e</i> in <i>a</i>\n * minus the cardinality of <i>e</i> in <i>b</i>, or zero, whichever is greater.</p>\n * <p>The cardinality of each element <i>e</i> in the returned {@link Collection} that does <b>not</b>\n * satisfy the predicate condition will be equal to the cardinality of <i>e</i> in <i>a</i>.</p>\n *\n * @param a  the collection to subtract from, must not be null\n * @param b  the collection to subtract, must not be null\n * @param p  the condition used to determine which elements of <i>b</i> are\n *        subtracted.\n * @param <O> the generic type that is able to represent the types contained\n *        in both input collections.\n * @return a new collection with the results\n * @since 4.0\n * @see Collection#removeAll\n */\npublic static <O> Collection<O> subtract(final Iterable<? extends O> a, final Iterable<? extends O> b, final Predicate<O> p) {\n    final ArrayList<O> list = new ArrayList<O>();\n    final HashBag<O> bag = new HashBag<O>();\n    for (final O element : b) {\n        if (p.evaluate(element)) {\n            bag.add(element);\n        }\n    }\n    for (final O element : a) {\n        if (!bag.remove(element, 1)) {\n            list.add(element);\n        }\n    }\n    return list;\n}"
            ],
            [
                "containsAll",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns <code>true</code> iff all elements of {@code coll2} are also contained\n * in {@code coll1}. The cardinality of values in {@code coll2} is not taken into account,\n * which is the same behavior as {@link Collection#containsAll(Collection)}.\n * <p>\n * In other words, this method returns <code>true</code> iff the\n * {@link #intersection} of <i>coll1</i> and <i>coll2</i> has the same cardinality as\n * the set of unique values from {@code coll2}. In case {@code coll2} is empty, {@code true}\n * will be returned.\n * <p>\n * This method is intended as a replacement for {@link Collection#containsAll(Collection)}\n * with a guaranteed runtime complexity of {@code O(n + m)}. Depending on the type of\n * {@link Collection} provided, this method will be much faster than calling\n * {@link Collection#containsAll(Collection)} instead, though this will come at the\n * cost of an additional space complexity O(n).\n *\n * @param coll1  the first collection, must not be null\n * @param coll2  the second collection, must not be null\n * @return <code>true</code> iff the intersection of the collections has the same cardinality\n *   as the set of unique elements from the second collection\n * @since 4.0\n */\npublic static boolean containsAll(final Collection<?> coll1, final Collection<?> coll2) {\n    if (coll2.isEmpty()) {\n        return true;\n    } else {\n        final Iterator<?> it = coll1.iterator();\n        final Set<Object> elementsAlreadySeen = new HashSet<Object>();\n        for (final Object nextElement : coll2) {\n            if (elementsAlreadySeen.contains(nextElement)) {\n                continue;\n            }\n            boolean foundCurrentElement = false;\n            while (it.hasNext()) {\n                final Object p = it.next();\n                elementsAlreadySeen.add(p);\n                if (nextElement == null ? p == null : nextElement.equals(p)) {\n                    foundCurrentElement = true;\n                    break;\n                }\n            }\n            if (foundCurrentElement) {\n                continue;\n            } else {\n                return false;\n            }\n        }\n        return true;\n    }\n}"
            ],
            [
                "containsAny",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns <code>true</code> iff at least one element is in both collections.\n * <p>\n * In other words, this method returns <code>true</code> iff the\n * {@link #intersection} of <i>coll1</i> and <i>coll2</i> is not empty.\n *\n * @param coll1  the first collection, must not be null\n * @param coll2  the second collection, must not be null\n * @return <code>true</code> iff the intersection of the collections is non-empty\n * @since 2.1\n * @see #intersection\n */\npublic static boolean containsAny(final Collection<?> coll1, final Collection<?> coll2) {\n    if (coll1.size() < coll2.size()) {\n        for (final Object aColl1 : coll1) {\n            if (coll2.contains(aColl1)) {\n                return true;\n            }\n        }\n    } else {\n        for (final Object aColl2 : coll2) {\n            if (coll1.contains(aColl2)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}"
            ],
            [
                "getCardinalityMap",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns a {@link Map} mapping each unique element in the given\n * {@link Collection} to an {@link Integer} representing the number\n * of occurrences of that element in the {@link Collection}.\n * <p>\n * Only those elements present in the collection will appear as\n * keys in the map.\n *\n * @param <O>  the type of object in the returned {@link Map}. This is a super type of <I>.\n * @param coll  the collection to get the cardinality map for, must not be null\n * @return the populated cardinality map\n */\npublic static <O> Map<O, Integer> getCardinalityMap(final Iterable<? extends O> coll) {\n    final Map<O, Integer> count = new HashMap<O, Integer>();\n    for (final O obj : coll) {\n        final Integer c = count.get(obj);\n        if (c == null) {\n            count.put(obj, Integer.valueOf(1));\n        } else {\n            count.put(obj, Integer.valueOf(c.intValue() + 1));\n        }\n    }\n    return count;\n}"
            ],
            [
                "isSubCollection",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns {@code true} iff <i>a</i> is a sub-collection of <i>b</i>,\n * that is, iff the cardinality of <i>e</i> in <i>a</i> is less than or\n * equal to the cardinality of <i>e</i> in <i>b</i>, for each element <i>e</i>\n * in <i>a</i>.\n *\n * @param a the first (sub?) collection, must not be null\n * @param b the second (super?) collection, must not be null\n * @return <code>true</code> iff <i>a</i> is a sub-collection of <i>b</i>\n * @see #isProperSubCollection\n * @see Collection#containsAll\n */\npublic static boolean isSubCollection(final Collection<?> a, final Collection<?> b) {\n    final CardinalityHelper<Object> helper = new CardinalityHelper<Object>(a, b);\n    for (final Object obj : a) {\n        if (helper.freqA(obj) > helper.freqB(obj)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isProperSubCollection",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns {@code true} iff <i>a</i> is a <i>proper</i> sub-collection of <i>b</i>,\n * that is, iff the cardinality of <i>e</i> in <i>a</i> is less\n * than or equal to the cardinality of <i>e</i> in <i>b</i>,\n * for each element <i>e</i> in <i>a</i>, and there is at least one\n * element <i>f</i> such that the cardinality of <i>f</i> in <i>b</i>\n * is strictly greater than the cardinality of <i>f</i> in <i>a</i>.\n * <p>\n * The implementation assumes\n * <ul>\n *    <li><code>a.size()</code> and <code>b.size()</code> represent the\n *    total cardinality of <i>a</i> and <i>b</i>, resp. </li>\n *    <li><code>a.size() < Integer.MAXVALUE</code></li>\n * </ul>\n *\n * @param a  the first (sub?) collection, must not be null\n * @param b  the second (super?) collection, must not be null\n * @return <code>true</code> iff <i>a</i> is a <i>proper</i> sub-collection of <i>b</i>\n * @see #isSubCollection\n * @see Collection#containsAll\n */\npublic static boolean isProperSubCollection(final Collection<?> a, final Collection<?> b) {\n    return a.size() < b.size() && CollectionUtils.isSubCollection(a, b);\n}"
            ],
            [
                "isEqualCollection",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns {@code true} iff the given {@link Collection}s contain\n * exactly the same elements with exactly the same cardinalities.\n * <p>\n * That is, iff the cardinality of <i>e</i> in <i>a</i> is\n * equal to the cardinality of <i>e</i> in <i>b</i>,\n * for each element <i>e</i> in <i>a</i> or <i>b</i>.\n *\n * @param a  the first collection, must not be null\n * @param b  the second collection, must not be null\n * @return <code>true</code> iff the collections contain the same elements with the same cardinalities.\n */\npublic static boolean isEqualCollection(final Collection<?> a, final Collection<?> b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n    final CardinalityHelper<Object> helper = new CardinalityHelper<Object>(a, b);\n    if (helper.cardinalityA.size() != helper.cardinalityB.size()) {\n        return false;\n    }\n    for (final Object obj : helper.cardinalityA.keySet()) {\n        if (helper.freqA(obj) != helper.freqB(obj)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isEqualCollection",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns {@code true} iff the given {@link Collection}s contain\n * exactly the same elements with exactly the same cardinalities.\n * <p>\n * That is, iff the cardinality of <i>e</i> in <i>a</i> is\n * equal to the cardinality of <i>e</i> in <i>b</i>,\n * for each element <i>e</i> in <i>a</i> or <i>b</i>.\n * <p>\n * <b>Note:</b> from version 4.1 onwards this method requires the input\n * collections and equator to be of compatible type (using bounded wildcards).\n * Providing incompatible arguments (e.g. by casting to their rawtypes)\n * will result in a {@code ClassCastException} thrown at runtime.\n *\n * @param <E>  the element type\n * @param a  the first collection, must not be null\n * @param b  the second collection, must not be null\n * @param equator  the Equator used for testing equality\n * @return <code>true</code> iff the collections contain the same elements with the same cardinalities.\n * @throws NullPointerException if the equator is null\n * @since 4.0\n */\npublic static <E> boolean isEqualCollection(final Collection<? extends E> a, final Collection<? extends E> b, final Equator<? super E> equator) {\n    if (equator == null) {\n        throw new NullPointerException(\"Equator must not be null.\");\n    }\n    if (a.size() != b.size()) {\n        return false;\n    }\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    final Transformer<E, ?> transformer = new Transformer() {\n\n        public EquatorWrapper<?> transform(final Object input) {\n            return new EquatorWrapper(equator, input);\n        }\n    };\n    return isEqualCollection(collect(a, transformer), collect(b, transformer));\n}"
            ],
            [
                "cardinality",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns the number of occurrences of <i>obj</i> in <i>coll</i>.\n *\n * @param obj the object to find the cardinality of\n * @param coll the {@link Iterable} to search\n * @param <O> the type of object that the {@link Iterable} may contain.\n * @return the the number of occurrences of obj in coll\n * @throws NullPointerException if coll is null\n * @deprecated since 4.1, use {@link IterableUtils#frequency(Iterable, Object)} instead.\n *   Be aware that the order of parameters has changed.\n */\n@Deprecated\npublic static <O> int cardinality(final O obj, final Iterable<? super O> coll) {\n    if (coll == null) {\n        throw new NullPointerException(\"coll must not be null.\");\n    }\n    return IterableUtils.frequency(coll, obj);\n}"
            ],
            [
                "find",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Finds the first element in the given collection which matches the given predicate.\n * <p>\n * If the input collection or predicate is null, or no element of the collection\n * matches the predicate, null is returned.\n *\n * @param <T>  the type of object the {@link Iterable} contains\n * @param collection  the collection to search, may be null\n * @param predicate  the predicate to use, may be null\n * @return the first element of the collection which matches the predicate or null if none could be found\n * @deprecated since 4.1, use {@link IterableUtils#find(Iterable, Predicate)} instead\n */\n@Deprecated\npublic static <T> T find(final Iterable<T> collection, final Predicate<? super T> predicate) {\n    return predicate != null ? IterableUtils.find(collection, predicate) : null;\n}"
            ],
            [
                "forAllDo",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Executes the given closure on each element in the collection.\n * <p>\n * If the input collection or closure is null, there is no change made.\n *\n * @param <T>  the type of object the {@link Iterable} contains\n * @param <C>  the closure type\n * @param collection  the collection to get the input from, may be null\n * @param closure  the closure to perform, may be null\n * @return closure\n * @deprecated since 4.1, use {@link IterableUtils#forEach(Iterable, Closure)} instead\n */\n@Deprecated\npublic static <T, C extends Closure<? super T>> C forAllDo(final Iterable<T> collection, final C closure) {\n    if (closure != null) {\n        IterableUtils.forEach(collection, closure);\n    }\n    return closure;\n}"
            ],
            [
                "forAllDo",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Executes the given closure on each element in the collection.\n * <p>\n * If the input collection or closure is null, there is no change made.\n *\n * @param <T>  the type of object the {@link Iterator} contains\n * @param <C>  the closure type\n * @param iterator  the iterator to get the input from, may be null\n * @param closure  the closure to perform, may be null\n * @return closure\n * @since 4.0\n * @deprecated since 4.1, use {@link IteratorUtils#forEach(Iterator, Closure)} instead\n */\n@Deprecated\npublic static <T, C extends Closure<? super T>> C forAllDo(final Iterator<T> iterator, final C closure) {\n    if (closure != null) {\n        IteratorUtils.forEach(iterator, closure);\n    }\n    return closure;\n}"
            ],
            [
                "forAllButLastDo",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Executes the given closure on each but the last element in the collection.\n * <p>\n * If the input collection or closure is null, there is no change made.\n *\n * @param <T>  the type of object the {@link Iterable} contains\n * @param <C>  the closure type\n * @param collection  the collection to get the input from, may be null\n * @param closure  the closure to perform, may be null\n * @return the last element in the collection, or null if either collection or closure is null\n * @since 4.0\n * @deprecated since 4.1, use {@link IterableUtils#forEachButLast(Iterable, Closure)} instead\n */\n@Deprecated\npublic static <T, C extends Closure<? super T>> T forAllButLastDo(final Iterable<T> collection, final C closure) {\n    return closure != null ? IterableUtils.forEachButLast(collection, closure) : null;\n}"
            ],
            [
                "forAllButLastDo",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Executes the given closure on each but the last element in the collection.\n * <p>\n * If the input collection or closure is null, there is no change made.\n *\n * @param <T>  the type of object the {@link Collection} contains\n * @param <C>  the closure type\n * @param iterator  the iterator to get the input from, may be null\n * @param closure  the closure to perform, may be null\n * @return the last element in the collection, or null if either iterator or closure is null\n * @since 4.0\n * @deprecated since 4.1, use {@link IteratorUtils#forEachButLast(Iterator, Closure)} instead\n */\n@Deprecated\npublic static <T, C extends Closure<? super T>> T forAllButLastDo(final Iterator<T> iterator, final C closure) {\n    return closure != null ? IteratorUtils.forEachButLast(iterator, closure) : null;\n}"
            ],
            [
                "filter",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Filter the collection by applying a Predicate to each element. If the\n * predicate returns false, remove the element.\n * <p>\n * If the input collection or predicate is null, there is no change made.\n *\n * @param <T>  the type of object the {@link Iterable} contains\n * @param collection  the collection to get the input from, may be null\n * @param predicate  the predicate to use as a filter, may be null\n * @return true if the collection is modified by this call, false otherwise.\n */\npublic static <T> boolean filter(final Iterable<T> collection, final Predicate<? super T> predicate) {\n    boolean result = false;\n    if (collection != null && predicate != null) {\n        for (final Iterator<T> it = collection.iterator(); it.hasNext(); ) {\n            if (!predicate.evaluate(it.next())) {\n                it.remove();\n                result = true;\n            }\n        }\n    }\n    return result;\n}"
            ],
            [
                "filterInverse",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Filter the collection by applying a Predicate to each element. If the\n * predicate returns true, remove the element.\n * <p>\n * This is equivalent to <pre>filter(collection, PredicateUtils.notPredicate(predicate))</pre>\n * if predicate is != null.\n * <p>\n * If the input collection or predicate is null, there is no change made.\n *\n * @param <T>  the type of object the {@link Iterable} contains\n * @param collection  the collection to get the input from, may be null\n * @param predicate  the predicate to use as a filter, may be null\n * @return true if the collection is modified by this call, false otherwise.\n */\npublic static <T> boolean filterInverse(final Iterable<T> collection, final Predicate<? super T> predicate) {\n    return filter(collection, predicate == null ? null : PredicateUtils.notPredicate(predicate));\n}"
            ],
            [
                "countMatches",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Counts the number of elements in the input collection that match the\n * predicate.\n * <p>\n * A <code>null</code> collection or predicate matches no elements.\n *\n * @param <C>  the type of object the {@link Iterable} contains\n * @param input  the {@link Iterable} to get the input from, may be null\n * @param predicate  the predicate to use, may be null\n * @return the number of matches for the predicate in the collection\n * @deprecated since 4.1, use {@link IterableUtils#countMatches(Iterable, Predicate)} instead\n */\n@Deprecated\npublic static <C> int countMatches(final Iterable<C> input, final Predicate<? super C> predicate) {\n    return predicate == null ? 0 : (int) IterableUtils.countMatches(input, predicate);\n}"
            ],
            [
                "exists",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Answers true if a predicate is true for at least one element of a\n * collection.\n * <p>\n * A <code>null</code> collection or predicate returns false.\n *\n * @param <C>  the type of object the {@link Iterable} contains\n * @param input  the {@link Iterable} to get the input from, may be null\n * @param predicate  the predicate to use, may be null\n * @return true if at least one element of the collection matches the predicate\n * @deprecated since 4.1, use {@link IterableUtils#matchesAny(Iterable, Predicate)} instead\n */\n@Deprecated\npublic static <C> boolean exists(final Iterable<C> input, final Predicate<? super C> predicate) {\n    return predicate == null ? false : IterableUtils.matchesAny(input, predicate);\n}"
            ],
            [
                "matchesAll",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Answers true if a predicate is true for every element of a\n * collection.\n * <p>\n * A <code>null</code> predicate returns false.<br/>\n * A <code>null</code> or empty collection returns true.\n *\n * @param <C>  the type of object the {@link Iterable} contains\n * @param input  the {@link Iterable} to get the input from, may be null\n * @param predicate  the predicate to use, may be null\n * @return true if every element of the collection matches the predicate or if the\n * collection is empty, false otherwise\n * @since 4.0\n * @deprecated since 4.1, use {@link IterableUtils#matchesAll(Iterable, Predicate)} instead\n */\n@Deprecated\npublic static <C> boolean matchesAll(final Iterable<C> input, final Predicate<? super C> predicate) {\n    return predicate == null ? false : IterableUtils.matchesAll(input, predicate);\n}"
            ],
            [
                "select",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Selects all elements from input collection which match the given\n * predicate into an output collection.\n * <p>\n * A <code>null</code> predicate matches no elements.\n *\n * @param <O>  the type of object the {@link Iterable} contains\n * @param inputCollection  the collection to get the input from, may not be null\n * @param predicate  the predicate to use, may be null\n * @return the elements matching the predicate (new list)\n * @throws NullPointerException if the input collection is null\n */\npublic static <O> Collection<O> select(final Iterable<? extends O> inputCollection, final Predicate<? super O> predicate) {\n    final Collection<O> answer = inputCollection instanceof Collection<?> ? new ArrayList<O>(((Collection<?>) inputCollection).size()) : new ArrayList<O>();\n    return select(inputCollection, predicate, answer);\n}"
            ],
            [
                "select",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Selects all elements from input collection which match the given\n * predicate and adds them to outputCollection.\n * <p>\n * If the input collection or predicate is null, there is no change to the\n * output collection.\n *\n * @param <O>  the type of object the {@link Iterable} contains\n * @param <R>  the type of the output {@link Collection}\n * @param inputCollection  the collection to get the input from, may be null\n * @param predicate  the predicate to use, may be null\n * @param outputCollection  the collection to output into, may not be null if the inputCollection\n *   and predicate or not null\n * @return the outputCollection\n */\npublic static <O, R extends Collection<? super O>> R select(final Iterable<? extends O> inputCollection, final Predicate<? super O> predicate, final R outputCollection) {\n    if (inputCollection != null && predicate != null) {\n        for (final O item : inputCollection) {\n            if (predicate.evaluate(item)) {\n                outputCollection.add(item);\n            }\n        }\n    }\n    return outputCollection;\n}"
            ],
            [
                "select",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Selects all elements from inputCollection into an output and rejected collection,\n * based on the evaluation of the given predicate.\n * <p>\n * Elements matching the predicate are added to the <code>outputCollection</code>,\n * all other elements are added to the <code>rejectedCollection</code>.\n * <p>\n * If the input predicate is <code>null</code>, no elements are added to\n * <code>outputCollection</code> or <code>rejectedCollection</code>.\n * <p>\n * Note: calling the method is equivalent to the following code snippet:\n * <pre>\n *   select(inputCollection, predicate, outputCollection);\n *   selectRejected(inputCollection, predicate, rejectedCollection);\n * </pre>\n *\n * @param <O>  the type of object the {@link Iterable} contains\n * @param <R>  the type of the output {@link Collection}\n * @param inputCollection  the collection to get the input from, may be null\n * @param predicate  the predicate to use, may be null\n * @param outputCollection  the collection to output selected elements into, may not be null if the\n *   inputCollection and predicate are not null\n * @param rejectedCollection  the collection to output rejected elements into, may not be null if the\n *   inputCollection or predicate are not null\n * @return the outputCollection\n * @since 4.1\n */\npublic static <O, R extends Collection<? super O>> R select(final Iterable<? extends O> inputCollection, final Predicate<? super O> predicate, R outputCollection, R rejectedCollection) {\n    if (inputCollection != null && predicate != null) {\n        for (final O element : inputCollection) {\n            if (predicate.evaluate(element)) {\n                outputCollection.add(element);\n            } else {\n                rejectedCollection.add(element);\n            }\n        }\n    }\n    return outputCollection;\n}"
            ],
            [
                "selectRejected",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Selects all elements from inputCollection which don't match the given\n * predicate into an output collection.\n * <p>\n * If the input predicate is <code>null</code>, the result is an empty\n * list.\n *\n * @param <O>  the type of object the {@link Iterable} contains\n * @param inputCollection  the collection to get the input from, may not be null\n * @param predicate  the predicate to use, may be null\n * @return the elements <b>not</b> matching the predicate (new list)\n * @throws NullPointerException if the input collection is null\n */\npublic static <O> Collection<O> selectRejected(final Iterable<? extends O> inputCollection, final Predicate<? super O> predicate) {\n    final Collection<O> answer = inputCollection instanceof Collection<?> ? new ArrayList<O>(((Collection<?>) inputCollection).size()) : new ArrayList<O>();\n    return selectRejected(inputCollection, predicate, answer);\n}"
            ],
            [
                "selectRejected",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Selects all elements from inputCollection which don't match the given\n * predicate and adds them to outputCollection.\n * <p>\n * If the input predicate is <code>null</code>, no elements are added to\n * <code>outputCollection</code>.\n *\n * @param <O>  the type of object the {@link Iterable} contains\n * @param <R>  the type of the output {@link Collection}\n * @param inputCollection  the collection to get the input from, may be null\n * @param predicate  the predicate to use, may be null\n * @param outputCollection  the collection to output into, may not be null if the inputCollection\n *   and predicate or not null\n * @return outputCollection\n */\npublic static <O, R extends Collection<? super O>> R selectRejected(final Iterable<? extends O> inputCollection, final Predicate<? super O> predicate, final R outputCollection) {\n    if (inputCollection != null && predicate != null) {\n        for (final O item : inputCollection) {\n            if (!predicate.evaluate(item)) {\n                outputCollection.add(item);\n            }\n        }\n    }\n    return outputCollection;\n}"
            ],
            [
                "collect",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns a new Collection containing all elements of the input collection\n * transformed by the given transformer.\n * <p>\n * If the input collection or transformer is null, the result is an empty list.\n *\n * @param <I>  the type of object in the input collection\n * @param <O>  the type of object in the output collection\n * @param inputCollection  the collection to get the input from, may not be null\n * @param transformer  the transformer to use, may be null\n * @return the transformed result (new list)\n * @throws NullPointerException if the input collection is null\n */\npublic static <I, O> Collection<O> collect(final Iterable<I> inputCollection, final Transformer<? super I, ? extends O> transformer) {\n    final Collection<O> answer = inputCollection instanceof Collection<?> ? new ArrayList<O>(((Collection<?>) inputCollection).size()) : new ArrayList<O>();\n    return collect(inputCollection, transformer, answer);\n}"
            ],
            [
                "collect",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Transforms all elements from the input iterator with the given transformer\n * and adds them to the output collection.\n * <p>\n * If the input iterator or transformer is null, the result is an empty list.\n *\n * @param <I>  the type of object in the input collection\n * @param <O>  the type of object in the output collection\n * @param inputIterator  the iterator to get the input from, may be null\n * @param transformer  the transformer to use, may be null\n * @return the transformed result (new list)\n */\npublic static <I, O> Collection<O> collect(final Iterator<I> inputIterator, final Transformer<? super I, ? extends O> transformer) {\n    return collect(inputIterator, transformer, new ArrayList<O>());\n}"
            ],
            [
                "collect",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Transforms all elements from input collection with the given transformer\n * and adds them to the output collection.\n * <p>\n * If the input collection or transformer is null, there is no change to the\n * output collection.\n *\n * @param <I>  the type of object in the input collection\n * @param <O>  the type of object in the output collection\n * @param <R>  the type of the output collection\n * @param inputCollection  the collection to get the input from, may be null\n * @param transformer  the transformer to use, may be null\n * @param outputCollection  the collection to output into, may not be null if inputCollection\n *   and transformer are not null\n * @return the output collection with the transformed input added\n * @throws NullPointerException if the outputCollection is null and both, inputCollection and\n *   transformer are not null\n */\npublic static <I, O, R extends Collection<? super O>> R collect(final Iterable<? extends I> inputCollection, final Transformer<? super I, ? extends O> transformer, final R outputCollection) {\n    if (inputCollection != null) {\n        return collect(inputCollection.iterator(), transformer, outputCollection);\n    }\n    return outputCollection;\n}"
            ],
            [
                "collect",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Transforms all elements from the input iterator with the given transformer\n * and adds them to the output collection.\n * <p>\n * If the input iterator or transformer is null, there is no change to the\n * output collection.\n *\n * @param <I>  the type of object in the input collection\n * @param <O>  the type of object in the output collection\n * @param <R>  the type of the output collection\n * @param inputIterator  the iterator to get the input from, may be null\n * @param transformer  the transformer to use, may be null\n * @param outputCollection  the collection to output into, may not be null if inputIterator\n *   and transformer are not null\n * @return the outputCollection with the transformed input added\n * @throws NullPointerException if the output collection is null and both, inputIterator and\n *   transformer are not null\n */\npublic static <I, O, R extends Collection<? super O>> R collect(final Iterator<? extends I> inputIterator, final Transformer<? super I, ? extends O> transformer, final R outputCollection) {\n    if (inputIterator != null && transformer != null) {\n        while (inputIterator.hasNext()) {\n            final I item = inputIterator.next();\n            final O value = transformer.transform(item);\n            outputCollection.add(value);\n        }\n    }\n    return outputCollection;\n}"
            ],
            [
                "addIgnoreNull",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "//-----------------------------------------------------------------------\n/**\n * Adds an element to the collection unless the element is null.\n *\n * @param <T>  the type of object the {@link Collection} contains\n * @param collection  the collection to add to, must not be null\n * @param object  the object to add, if null it will not be added\n * @return true if the collection changed\n * @throws NullPointerException if the collection is null\n * @since 3.2\n */\npublic static <T> boolean addIgnoreNull(final Collection<T> collection, final T object) {\n    if (collection == null) {\n        throw new NullPointerException(\"The collection must not be null\");\n    }\n    return object != null && collection.add(object);\n}"
            ],
            [
                "addAll",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Adds all elements in the {@link Iterable} to the given collection. If the\n * {@link Iterable} is a {@link Collection} then it is cast and will be\n * added using {@link Collection#addAll(Collection)} instead of iterating.\n *\n * @param <C>  the type of object the {@link Collection} contains\n * @param collection  the collection to add to, must not be null\n * @param iterable  the iterable of elements to add, must not be null\n * @return a boolean indicating whether the collection has changed or not.\n * @throws NullPointerException if the collection or iterator is null\n */\npublic static <C> boolean addAll(final Collection<C> collection, final Iterable<? extends C> iterable) {\n    if (iterable instanceof Collection<?>) {\n        return collection.addAll((Collection<? extends C>) iterable);\n    }\n    return addAll(collection, iterable.iterator());\n}"
            ],
            [
                "addAll",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Adds all elements in the iteration to the given collection.\n *\n * @param <C>  the type of object the {@link Collection} contains\n * @param collection  the collection to add to, must not be null\n * @param iterator  the iterator of elements to add, must not be null\n * @return a boolean indicating whether the collection has changed or not.\n * @throws NullPointerException if the collection or iterator is null\n */\npublic static <C> boolean addAll(final Collection<C> collection, final Iterator<? extends C> iterator) {\n    boolean changed = false;\n    while (iterator.hasNext()) {\n        changed |= collection.add(iterator.next());\n    }\n    return changed;\n}"
            ],
            [
                "addAll",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Adds all elements in the enumeration to the given collection.\n *\n * @param <C>  the type of object the {@link Collection} contains\n * @param collection  the collection to add to, must not be null\n * @param enumeration  the enumeration of elements to add, must not be null\n * @return {@code true} if the collections was changed, {@code false} otherwise\n * @throws NullPointerException if the collection or enumeration is null\n */\npublic static <C> boolean addAll(final Collection<C> collection, final Enumeration<? extends C> enumeration) {\n    boolean changed = false;\n    while (enumeration.hasMoreElements()) {\n        changed |= collection.add(enumeration.nextElement());\n    }\n    return changed;\n}"
            ],
            [
                "addAll",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Adds all elements in the array to the given collection.\n *\n * @param <C>  the type of object the {@link Collection} contains\n * @param collection  the collection to add to, must not be null\n * @param elements  the array of elements to add, must not be null\n * @return {@code true} if the collection was changed, {@code false} otherwise\n * @throws NullPointerException if the collection or array is null\n */\npublic static <C> boolean addAll(final Collection<C> collection, final C[] elements) {\n    boolean changed = false;\n    for (final C element : elements) {\n        changed |= collection.add(element);\n    }\n    return changed;\n}"
            ],
            [
                "get",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns the <code>index</code>-th value in {@link Iterator}, throwing\n * <code>IndexOutOfBoundsException</code> if there is no such element.\n * <p>\n * The Iterator is advanced to <code>index</code> (or to the end, if\n * <code>index</code> exceeds the number of entries) as a side effect of this method.\n *\n * @param iterator  the iterator to get a value from\n * @param index  the index to get\n * @param <T> the type of object in the {@link Iterator}\n * @return the object at the specified index\n * @throws IndexOutOfBoundsException if the index is invalid\n * @throws IllegalArgumentException if the object type is invalid\n * @deprecated since 4.1, use {@code IteratorUtils.get(Iterator, int)} instead\n */\n@Deprecated\npublic static <T> T get(final Iterator<T> iterator, final int index) {\n    return IteratorUtils.get(iterator, index);\n}"
            ],
            [
                "get",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns the <code>index</code>-th value in the <code>iterable</code>'s {@link Iterator}, throwing\n * <code>IndexOutOfBoundsException</code> if there is no such element.\n * <p>\n * If the {@link Iterable} is a {@link List}, then it will use {@link List#get(int)}.\n *\n * @param iterable  the {@link Iterable} to get a value from\n * @param index  the index to get\n * @param <T> the type of object in the {@link Iterable}.\n * @return the object at the specified index\n * @throws IndexOutOfBoundsException if the index is invalid\n * @deprecated since 4.1, use {@code IterableUtils.get(Iterable, int)} instead\n */\n@Deprecated\npublic static <T> T get(final Iterable<T> iterable, final int index) {\n    return IterableUtils.get(iterable, index);\n}"
            ],
            [
                "get",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns the <code>index</code>-th value in <code>object</code>, throwing\n * <code>IndexOutOfBoundsException</code> if there is no such element or\n * <code>IllegalArgumentException</code> if <code>object</code> is not an\n * instance of one of the supported types.\n * <p>\n * The supported types, and associated semantics are:\n * <ul>\n * <li> Map -- the value returned is the <code>Map.Entry</code> in position\n *      <code>index</code> in the map's <code>entrySet</code> iterator,\n *      if there is such an entry.</li>\n * <li> List -- this method is equivalent to the list's get method.</li>\n * <li> Array -- the <code>index</code>-th array entry is returned,\n *      if there is such an entry; otherwise an <code>IndexOutOfBoundsException</code>\n *      is thrown.</li>\n * <li> Collection -- the value returned is the <code>index</code>-th object\n *      returned by the collection's default iterator, if there is such an element.</li>\n * <li> Iterator or Enumeration -- the value returned is the\n *      <code>index</code>-th object in the Iterator/Enumeration, if there\n *      is such an element.  The Iterator/Enumeration is advanced to\n *      <code>index</code> (or to the end, if <code>index</code> exceeds the\n *      number of entries) as a side effect of this method.</li>\n * </ul>\n *\n * @param object  the object to get a value from\n * @param index  the index to get\n * @return the object at the specified index\n * @throws IndexOutOfBoundsException if the index is invalid\n * @throws IllegalArgumentException if the object type is invalid\n */\npublic static Object get(final Object object, final int index) {\n    int i = index;\n    if (i < 0) {\n        throw new IndexOutOfBoundsException(\"Index cannot be negative: \" + i);\n    }\n    if (object instanceof Map<?, ?>) {\n        final Map<?, ?> map = (Map<?, ?>) object;\n        final Iterator<?> iterator = map.entrySet().iterator();\n        return IteratorUtils.get(iterator, i);\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object)[i];\n    } else if (object instanceof Iterator<?>) {\n        final Iterator<?> it = (Iterator<?>) object;\n        return IteratorUtils.get(it, i);\n    } else if (object instanceof Iterable<?>) {\n        final Iterable<?> iterable = (Iterable<?>) object;\n        return IterableUtils.get(iterable, i);\n    } else if (object instanceof Collection<?>) {\n        final Iterator<?> iterator = ((Collection<?>) object).iterator();\n        return IteratorUtils.get(iterator, i);\n    } else if (object instanceof Enumeration<?>) {\n        final Enumeration<?> it = (Enumeration<?>) object;\n        return EnumerationUtils.get(it, i);\n    } else if (object == null) {\n        throw new IllegalArgumentException(\"Unsupported object type: null\");\n    } else {\n        try {\n            return Array.get(object, i);\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}"
            ],
            [
                "get",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns the <code>index</code>-th <code>Map.Entry</code> in the <code>map</code>'s <code>entrySet</code>,\n * throwing <code>IndexOutOfBoundsException</code> if there is no such element.\n *\n * @param <K>  the key type in the {@link Map}\n * @param <V>  the key type in the {@link Map}\n * @param map  the object to get a value from\n * @param index  the index to get\n * @return the object at the specified index\n * @throws IndexOutOfBoundsException if the index is invalid\n */\npublic static <K, V> Map.Entry<K, V> get(final Map<K, V> map, final int index) {\n    checkIndexBounds(index);\n    return get(map.entrySet(), index);\n}"
            ],
            [
                "size",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Gets the size of the collection/iterator specified.\n * <p>\n * This method can handles objects as follows\n * <ul>\n * <li>Collection - the collection size\n * <li>Map - the map size\n * <li>Array - the array size\n * <li>Iterator - the number of elements remaining in the iterator\n * <li>Enumeration - the number of elements remaining in the enumeration\n * </ul>\n *\n * @param object  the object to get the size of, may be null\n * @return the size of the specified collection or 0 if the object was null\n * @throws IllegalArgumentException thrown if object is not recognised\n * @since 3.1\n */\npublic static int size(final Object object) {\n    if (object == null) {\n        return 0;\n    }\n    int total = 0;\n    if (object instanceof Map<?, ?>) {\n        total = ((Map<?, ?>) object).size();\n    } else if (object instanceof Collection<?>) {\n        total = ((Collection<?>) object).size();\n    } else if (object instanceof Iterable<?>) {\n        total = IterableUtils.size((Iterable<?>) object);\n    } else if (object instanceof Object[]) {\n        total = ((Object[]) object).length;\n    } else if (object instanceof Iterator<?>) {\n        total = IteratorUtils.size((Iterator<?>) object);\n    } else if (object instanceof Enumeration<?>) {\n        final Enumeration<?> it = (Enumeration<?>) object;\n        while (it.hasMoreElements()) {\n            total++;\n            it.nextElement();\n        }\n    } else {\n        try {\n            total = Array.getLength(object);\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n    return total;\n}"
            ],
            [
                "sizeIsEmpty",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Checks if the specified collection/array/iterator is empty.\n * <p>\n * This method can handles objects as follows\n * <ul>\n * <li>Collection - via collection isEmpty\n * <li>Map - via map isEmpty\n * <li>Array - using array size\n * <li>Iterator - via hasNext\n * <li>Enumeration - via hasMoreElements\n * </ul>\n * <p>\n * Note: This method is named to avoid clashing with\n * {@link #isEmpty(Collection)}.\n *\n * @param object  the object to get the size of, may be null\n * @return true if empty or null\n * @throws IllegalArgumentException thrown if object is not recognised\n * @since 3.2\n */\npublic static boolean sizeIsEmpty(final Object object) {\n    if (object == null) {\n        return true;\n    } else if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Iterable<?>) {\n        return IterableUtils.isEmpty((Iterable<?>) object);\n    } else if (object instanceof Map<?, ?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return ((Iterator<?>) object).hasNext() == false;\n    } else if (object instanceof Enumeration<?>) {\n        return ((Enumeration<?>) object).hasMoreElements() == false;\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}"
            ],
            [
                "isEmpty",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "//-----------------------------------------------------------------------\n/**\n * Null-safe check if the specified collection is empty.\n * <p>\n * Null returns true.\n *\n * @param coll  the collection to check, may be null\n * @return true if empty or null\n * @since 3.2\n */\npublic static boolean isEmpty(final Collection<?> coll) {\n    return coll == null || coll.isEmpty();\n}"
            ],
            [
                "isNotEmpty",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Null-safe check if the specified collection is not empty.\n * <p>\n * Null returns false.\n *\n * @param coll  the collection to check, may be null\n * @return true if non-null and non-empty\n * @since 3.2\n */\npublic static boolean isNotEmpty(final Collection<?> coll) {\n    return !isEmpty(coll);\n}"
            ],
            [
                "isFull",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns true if no more elements can be added to the Collection.\n * <p>\n * This method uses the {@link BoundedCollection} interface to determine the\n * full status. If the collection does not implement this interface then\n * false is returned.\n * <p>\n * The collection does not have to implement this interface directly.\n * If the collection has been decorated using the decorators subpackage\n * then these will be removed to access the BoundedCollection.\n *\n * @param coll  the collection to check\n * @return true if the BoundedCollection is full\n * @throws NullPointerException if the collection is null\n */\npublic static boolean isFull(final Collection<? extends Object> coll) {\n    if (coll == null) {\n        throw new NullPointerException(\"The collection must not be null\");\n    }\n    if (coll instanceof BoundedCollection) {\n        return ((BoundedCollection<?>) coll).isFull();\n    }\n    try {\n        final BoundedCollection<?> bcoll = UnmodifiableBoundedCollection.unmodifiableBoundedCollection(coll);\n        return bcoll.isFull();\n    } catch (final IllegalArgumentException ex) {\n        return false;\n    }\n}"
            ],
            [
                "maxSize",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Get the maximum number of elements that the Collection can contain.\n * <p>\n * This method uses the {@link BoundedCollection} interface to determine the\n * maximum size. If the collection does not implement this interface then\n * -1 is returned.\n * <p>\n * The collection does not have to implement this interface directly.\n * If the collection has been decorated using the decorators subpackage\n * then these will be removed to access the BoundedCollection.\n *\n * @param coll  the collection to check\n * @return the maximum size of the BoundedCollection, -1 if no maximum size\n * @throws NullPointerException if the collection is null\n */\npublic static int maxSize(final Collection<? extends Object> coll) {\n    if (coll == null) {\n        throw new NullPointerException(\"The collection must not be null\");\n    }\n    if (coll instanceof BoundedCollection) {\n        return ((BoundedCollection<?>) coll).maxSize();\n    }\n    try {\n        final BoundedCollection<?> bcoll = UnmodifiableBoundedCollection.unmodifiableBoundedCollection(coll);\n        return bcoll.maxSize();\n    } catch (final IllegalArgumentException ex) {\n        return -1;\n    }\n}"
            ],
            [
                "collate",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "//-----------------------------------------------------------------------\n/**\n * Merges two sorted Collections, a and b, into a single, sorted List\n * such that the natural ordering of the elements is retained.\n * <p>\n * Uses the standard O(n) merge algorithm for combining two sorted lists.\n *\n * @param <O>  the element type\n * @param a  the first collection, must not be null\n * @param b  the second collection, must not be null\n * @return a new sorted List, containing the elements of Collection a and b\n * @throws NullPointerException if either collection is null\n * @since 4.0\n */\npublic static <O extends Comparable<? super O>> List<O> collate(Iterable<? extends O> a, Iterable<? extends O> b) {\n    return collate(a, b, ComparatorUtils.<O>naturalComparator(), true);\n}"
            ],
            [
                "collate",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Merges two sorted Collections, a and b, into a single, sorted List\n * such that the natural ordering of the elements is retained.\n * <p>\n * Uses the standard O(n) merge algorithm for combining two sorted lists.\n *\n * @param <O>  the element type\n * @param a  the first collection, must not be null\n * @param b  the second collection, must not be null\n * @param includeDuplicates  if {@code true} duplicate elements will be retained, otherwise\n *   they will be removed in the output collection\n * @return a new sorted List, containing the elements of Collection a and b\n * @throws NullPointerException if either collection is null\n * @since 4.0\n */\npublic static <O extends Comparable<? super O>> List<O> collate(final Iterable<? extends O> a, final Iterable<? extends O> b, final boolean includeDuplicates) {\n    return collate(a, b, ComparatorUtils.<O>naturalComparator(), includeDuplicates);\n}"
            ],
            [
                "collate",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Merges two sorted Collections, a and b, into a single, sorted List\n * such that the ordering of the elements according to Comparator c is retained.\n * <p>\n * Uses the standard O(n) merge algorithm for combining two sorted lists.\n *\n * @param <O>  the element type\n * @param a  the first collection, must not be null\n * @param b  the second collection, must not be null\n * @param c  the comparator to use for the merge.\n * @return a new sorted List, containing the elements of Collection a and b\n * @throws NullPointerException if either collection or the comparator is null\n * @since 4.0\n */\npublic static <O> List<O> collate(final Iterable<? extends O> a, final Iterable<? extends O> b, final Comparator<? super O> c) {\n    return collate(a, b, c, true);\n}"
            ],
            [
                "collate",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Merges two sorted Collections, a and b, into a single, sorted List\n * such that the ordering of the elements according to Comparator c is retained.\n * <p>\n * Uses the standard O(n) merge algorithm for combining two sorted lists.\n *\n * @param <O>  the element type\n * @param a  the first collection, must not be null\n * @param b  the second collection, must not be null\n * @param c  the comparator to use for the merge.\n * @param includeDuplicates  if {@code true} duplicate elements will be retained, otherwise\n *   they will be removed in the output collection\n * @return a new sorted List, containing the elements of Collection a and b\n * @throws NullPointerException if either collection or the comparator is null\n * @since 4.0\n */\npublic static <O> List<O> collate(final Iterable<? extends O> a, final Iterable<? extends O> b, final Comparator<? super O> c, final boolean includeDuplicates) {\n    if (a == null || b == null) {\n        throw new NullPointerException(\"The collections must not be null\");\n    }\n    if (c == null) {\n        throw new NullPointerException(\"The comparator must not be null\");\n    }\n    // if both Iterables are a Collection, we can estimate the size\n    final int totalSize = a instanceof Collection<?> && b instanceof Collection<?> ? Math.max(1, ((Collection<?>) a).size() + ((Collection<?>) b).size()) : 10;\n    final Iterator<O> iterator = new CollatingIterator<O>(c, a.iterator(), b.iterator());\n    if (includeDuplicates) {\n        return IteratorUtils.toList(iterator, totalSize);\n    } else {\n        final ArrayList<O> mergedList = new ArrayList<O>(totalSize);\n        O lastItem = null;\n        while (iterator.hasNext()) {\n            final O item = iterator.next();\n            if (lastItem == null || !lastItem.equals(item)) {\n                mergedList.add(item);\n            }\n            lastItem = item;\n        }\n        mergedList.trimToSize();\n        return mergedList;\n    }\n}"
            ],
            [
                "permutations",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns a {@link Collection} of all the permutations of the input collection.\n * <p>\n * NOTE: the number of permutations of a given collection is equal to n!, where\n * n is the size of the collection. Thus, the resulting collection will become\n * <b>very</b> large for collections &gt; 10 (e.g. 10! = 3628800, 15! = 1307674368000).\n * <p>\n * For larger collections it is advised to use a {@link PermutationIterator} to\n * iterate over all permutations.\n *\n * @see PermutationIterator\n *\n * @param <E>  the element type\n * @param collection  the collection to create permutations for, may not be null\n * @return an unordered collection of all permutations of the input collection\n * @throws NullPointerException if collection is null\n * @since 4.0\n */\npublic static <E> Collection<List<E>> permutations(final Collection<E> collection) {\n    final PermutationIterator<E> it = new PermutationIterator<E>(collection);\n    final Collection<List<E>> result = new LinkedList<List<E>>();\n    while (it.hasNext()) {\n        result.add(it.next());\n    }\n    return result;\n}"
            ],
            [
                "retainAll",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns a collection containing all the elements in <code>collection</code>\n * that are also in <code>retain</code>. The cardinality of an element <code>e</code>\n * in the returned collection is the same as the cardinality of <code>e</code>\n * in <code>collection</code> unless <code>retain</code> does not contain <code>e</code>, in which\n * case the cardinality is zero. This method is useful if you do not wish to modify\n * the collection <code>c</code> and thus cannot call <code>c.retainAll(retain);</code>.\n * <p>\n * This implementation iterates over <code>collection</code>, checking each element in\n * turn to see if it's contained in <code>retain</code>. If it's contained, it's added\n * to the returned list. As a consequence, it is advised to use a collection type for\n * <code>retain</code> that provides a fast (e.g. O(1)) implementation of\n * {@link Collection#contains(Object)}.\n *\n * @param <C>  the type of object the {@link Collection} contains\n * @param collection  the collection whose contents are the target of the #retailAll operation\n * @param retain  the collection containing the elements to be retained in the returned collection\n * @return a <code>Collection</code> containing all the elements of <code>collection</code>\n * that occur at least once in <code>retain</code>.\n * @throws NullPointerException if either parameter is null\n * @since 3.2\n */\npublic static <C> Collection<C> retainAll(final Collection<C> collection, final Collection<?> retain) {\n    return ListUtils.retainAll(collection, retain);\n}"
            ],
            [
                "retainAll",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns a collection containing all the elements in\n * <code>collection</code> that are also in <code>retain</code>. The\n * cardinality of an element <code>e</code> in the returned collection is\n * the same as the cardinality of <code>e</code> in <code>collection</code>\n * unless <code>retain</code> does not contain <code>e</code>, in which case\n * the cardinality is zero. This method is useful if you do not wish to\n * modify the collection <code>c</code> and thus cannot call\n * <code>c.retainAll(retain);</code>.\n * <p>\n * Moreover this method uses an {@link Equator} instead of\n * {@link Object#equals(Object)} to determine the equality of the elements\n * in <code>collection</code> and <code>retain</code>. Hence this method is\n * useful in cases where the equals behavior of an object needs to be\n * modified without changing the object itself.\n *\n * @param <E> the type of object the {@link Collection} contains\n * @param collection the collection whose contents are the target of the {@code retainAll} operation\n * @param retain the collection containing the elements to be retained in the returned collection\n * @param equator the Equator used for testing equality\n * @return a <code>Collection</code> containing all the elements of <code>collection</code>\n * that occur at least once in <code>retain</code> according to the <code>equator</code>\n * @throws NullPointerException if any of the parameters is null\n * @since 4.1\n */\npublic static <E> Collection<E> retainAll(final Iterable<E> collection, final Iterable<? extends E> retain, final Equator<? super E> equator) {\n    final Transformer<E, EquatorWrapper<E>> transformer = new Transformer<E, EquatorWrapper<E>>() {\n\n        public EquatorWrapper<E> transform(E input) {\n            return new EquatorWrapper<E>(equator, input);\n        }\n    };\n    final Set<EquatorWrapper<E>> retainSet = collect(retain, transformer, new HashSet<EquatorWrapper<E>>());\n    final List<E> list = new ArrayList<E>();\n    for (final E element : collection) {\n        if (retainSet.contains(new EquatorWrapper<E>(equator, element))) {\n            list.add(element);\n        }\n    }\n    return list;\n}"
            ],
            [
                "removeAll",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Removes the elements in <code>remove</code> from <code>collection</code>. That is, this\n * method returns a collection containing all the elements in <code>c</code>\n * that are not in <code>remove</code>. The cardinality of an element <code>e</code>\n * in the returned collection is the same as the cardinality of <code>e</code>\n * in <code>collection</code> unless <code>remove</code> contains <code>e</code>, in which\n * case the cardinality is zero. This method is useful if you do not wish to modify\n * the collection <code>c</code> and thus cannot call <code>collection.removeAll(remove);</code>.\n * <p>\n * This implementation iterates over <code>collection</code>, checking each element in\n * turn to see if it's contained in <code>remove</code>. If it's not contained, it's added\n * to the returned list. As a consequence, it is advised to use a collection type for\n * <code>remove</code> that provides a fast (e.g. O(1)) implementation of\n * {@link Collection#contains(Object)}.\n *\n * @param <E>  the type of object the {@link Collection} contains\n * @param collection  the collection from which items are removed (in the returned collection)\n * @param remove  the items to be removed from the returned <code>collection</code>\n * @return a <code>Collection</code> containing all the elements of <code>collection</code> except\n * any elements that also occur in <code>remove</code>.\n * @throws NullPointerException if either parameter is null\n * @since 4.0 (method existed in 3.2 but was completely broken)\n */\npublic static <E> Collection<E> removeAll(final Collection<E> collection, final Collection<?> remove) {\n    return ListUtils.removeAll(collection, remove);\n}"
            ],
            [
                "removeAll",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Removes all elements in <code>remove</code> from <code>collection</code>.\n * That is, this method returns a collection containing all the elements in\n * <code>collection</code> that are not in <code>remove</code>. The\n * cardinality of an element <code>e</code> in the returned collection is\n * the same as the cardinality of <code>e</code> in <code>collection</code>\n * unless <code>remove</code> contains <code>e</code>, in which case the\n * cardinality is zero. This method is useful if you do not wish to modify\n * the collection <code>c</code> and thus cannot call\n * <code>collection.removeAll(remove)</code>.\n * <p>\n * Moreover this method uses an {@link Equator} instead of\n * {@link Object#equals(Object)} to determine the equality of the elements\n * in <code>collection</code> and <code>remove</code>. Hence this method is\n * useful in cases where the equals behavior of an object needs to be\n * modified without changing the object itself.\n *\n * @param <E> the type of object the {@link Collection} contains\n * @param collection the collection from which items are removed (in the returned collection)\n * @param remove the items to be removed from the returned collection\n * @param equator the Equator used for testing equality\n * @return a <code>Collection</code> containing all the elements of <code>collection</code>\n * except any element that if equal according to the <code>equator</code>\n * @throws NullPointerException if any of the parameters is null\n * @since 4.1\n */\npublic static <E> Collection<E> removeAll(final Iterable<E> collection, final Iterable<? extends E> remove, final Equator<? super E> equator) {\n    final Transformer<E, EquatorWrapper<E>> transformer = new Transformer<E, EquatorWrapper<E>>() {\n\n        public EquatorWrapper<E> transform(E input) {\n            return new EquatorWrapper<E>(equator, input);\n        }\n    };\n    final Set<EquatorWrapper<E>> removeSet = collect(remove, transformer, new HashSet<EquatorWrapper<E>>());\n    final List<E> list = new ArrayList<E>();\n    for (final E element : collection) {\n        if (!removeSet.contains(new EquatorWrapper<E>(equator, element))) {\n            list.add(element);\n        }\n    }\n    return list;\n}"
            ],
            [
                "synchronizedCollection",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns a synchronized collection backed by the given collection.\n * <p>\n * You must manually synchronize on the returned buffer's iterator to\n * avoid non-deterministic behavior:\n *\n * <pre>\n * Collection c = CollectionUtils.synchronizedCollection(myCollection);\n * synchronized (c) {\n *     Iterator i = c.iterator();\n *     while (i.hasNext()) {\n *         process (i.next());\n *     }\n * }\n * </pre>\n *\n * This method uses the implementation in the decorators subpackage.\n *\n * @param <C>  the type of object the {@link Collection} contains\n * @param collection  the collection to synchronize, must not be null\n * @return a synchronized collection backed by the given collection\n * @throws NullPointerException if the collection is null\n * @deprecated since 4.1, use {@link java.util.Collections#synchronizedCollection(Collection)} instead\n */\n@Deprecated\npublic static <C> Collection<C> synchronizedCollection(final Collection<C> collection) {\n    return SynchronizedCollection.synchronizedCollection(collection);\n}"
            ],
            [
                "unmodifiableCollection",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns an unmodifiable collection backed by the given collection.\n * <p>\n * This method uses the implementation in the decorators subpackage.\n *\n * @param <C>  the type of object the {@link Collection} contains\n * @param collection  the collection to make unmodifiable, must not be null\n * @return an unmodifiable collection backed by the given collection\n * @throws NullPointerException if the collection is null\n * @deprecated since 4.1, use {@link java.util.Collections#unmodifiableCollection(Collection)} instead\n */\n@Deprecated\npublic static <C> Collection<C> unmodifiableCollection(final Collection<? extends C> collection) {\n    return UnmodifiableCollection.unmodifiableCollection(collection);\n}"
            ],
            [
                "predicatedCollection",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns a predicated (validating) collection backed by the given collection.\n * <p>\n * Only objects that pass the test in the given predicate can be added to the collection.\n * Trying to add an invalid object results in an IllegalArgumentException.\n * It is important not to use the original collection after invoking this method,\n * as it is a backdoor for adding invalid objects.\n *\n * @param <C> the type of objects in the Collection.\n * @param collection  the collection to predicate, must not be null\n * @param predicate  the predicate for the collection, must not be null\n * @return a predicated collection backed by the given collection\n * @throws NullPointerException if the Collection is null\n */\npublic static <C> Collection<C> predicatedCollection(final Collection<C> collection, final Predicate<? super C> predicate) {\n    return PredicatedCollection.predicatedCollection(collection, predicate);\n}"
            ],
            [
                "transformingCollection",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Returns a transformed bag backed by the given collection.\n * <p>\n * Each object is passed through the transformer as it is added to the\n * Collection. It is important not to use the original collection after invoking this\n * method, as it is a backdoor for adding untransformed objects.\n * <p>\n * Existing entries in the specified collection will not be transformed.\n * If you want that behaviour, see {@link TransformedCollection#transformedCollection}.\n *\n * @param <E> the type of object the {@link Collection} contains\n * @param collection  the collection to predicate, must not be null\n * @param transformer  the transformer for the collection, must not be null\n * @return a transformed collection backed by the given collection\n * @throws NullPointerException if the Collection or Transformer is null\n */\npublic static <E> Collection<E> transformingCollection(final Collection<E> collection, final Transformer<? super E, ? extends E> transformer) {\n    return TransformedCollection.transformingCollection(collection, transformer);\n}"
            ],
            [
                "extractSingleton",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * Extract the lone element of the specified Collection.\n * @param <E> collection type\n * @param collection to read\n * @return sole member of collection\n * @throws NullPointerException if collection is null\n * @throws IllegalArgumentException if collection is empty or contains more than one element\n * @since 4.0\n */\npublic static <E> E extractSingleton(final Collection<E> collection) {\n    if (collection == null) {\n        throw new NullPointerException(\"Collection must not be null.\");\n    }\n    if (collection.size() != 1) {\n        throw new IllegalArgumentException(\"Can extract singleton only when collection size == 1\");\n    }\n    return collection.iterator().next();\n}"
            ],
            [
                "transformingMap",
                "org.apache.commons.collections4.splitmap",
                "TransformedSplitMap",
                "/**\n * Factory method to create a transforming map.\n * <p>\n * If there are any elements already in the map being decorated, they are\n * NOT transformed.\n *\n * @param <J>  the input key type\n * @param <K>  the output key type\n * @param <U>  the input value type\n * @param <V>  the output value type\n * @param map the map to decorate, must not be null\n * @param keyTransformer the transformer to use for key conversion, must not be null\n * @param valueTransformer the transformer to use for value conversion, must not be null\n * @return a new transformed map\n * @throws NullPointerException if map or either of the transformers is null\n */\npublic static <J, K, U, V> TransformedSplitMap<J, K, U, V> transformingMap(final Map<K, V> map, final Transformer<? super J, ? extends K> keyTransformer, final Transformer<? super U, ? extends V> valueTransformer) {\n    return new TransformedSplitMap<J, K, U, V>(map, keyTransformer, valueTransformer);\n}"
            ],
            [
                "emptyIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Empty\n// ----------------------------------------------------------------------\n/**\n * Gets an empty iterable.\n * <p>\n * This iterable does not contain any elements.\n *\n * @param <E> the element type\n * @return an empty iterable\n */\n// OK, empty collection is compatible with any type\n@SuppressWarnings(\"unchecked\")\npublic static <E> Iterable<E> emptyIterable() {\n    return EMPTY_ITERABLE;\n}"
            ],
            [
                "chainedIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Chained\n// ----------------------------------------------------------------------\n/**\n * Combines two iterables into a single iterable.\n * <p>\n * The returned iterable has an iterator that traverses the elements in {@code a},\n * followed by the elements in {@code b}. The source iterators are not polled until\n * necessary.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the corresponding\n * input iterator supports it.\n *\n * @param <E> the element type\n * @param a  the first iterable, may not be null\n * @param b  the second iterable, may not be null\n * @return a new iterable, combining the provided iterables\n * @throws NullPointerException if either a or b is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Iterable<E> chainedIterable(final Iterable<? extends E> a, final Iterable<? extends E> b) {\n    return chainedIterable(new Iterable[] { a, b });\n}"
            ],
            [
                "chainedIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Combines three iterables into a single iterable.\n * <p>\n * The returned iterable has an iterator that traverses the elements in {@code a},\n * followed by the elements in {@code b} and {@code c}. The source iterators are\n * not polled until necessary.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the corresponding\n * input iterator supports it.\n *\n * @param <E> the element type\n * @param a  the first iterable, may not be null\n * @param b  the second iterable, may not be null\n * @param c  the third iterable, may not be null\n * @return a new iterable, combining the provided iterables\n * @throws NullPointerException if either of the provided iterables is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Iterable<E> chainedIterable(final Iterable<? extends E> a, final Iterable<? extends E> b, final Iterable<? extends E> c) {\n    return chainedIterable(new Iterable[] { a, b, c });\n}"
            ],
            [
                "chainedIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Combines four iterables into a single iterable.\n * <p>\n * The returned iterable has an iterator that traverses the elements in {@code a},\n * followed by the elements in {@code b}, {@code c} and {@code d}. The source\n * iterators are not polled until necessary.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the corresponding\n * input iterator supports it.\n *\n * @param <E> the element type\n * @param a  the first iterable, may not be null\n * @param b  the second iterable, may not be null\n * @param c  the third iterable, may not be null\n * @param d  the fourth iterable, may not be null\n * @return a new iterable, combining the provided iterables\n * @throws NullPointerException if either of the provided iterables is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Iterable<E> chainedIterable(final Iterable<? extends E> a, final Iterable<? extends E> b, final Iterable<? extends E> c, final Iterable<? extends E> d) {\n    return chainedIterable(new Iterable[] { a, b, c, d });\n}"
            ],
            [
                "chainedIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Combines the provided iterables into a single iterable.\n * <p>\n * The returned iterable has an iterator that traverses the elements in the order\n * of the arguments, i.e. iterables[0], iterables[1], .... The source iterators\n * are not polled until necessary.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the corresponding\n * input iterator supports it.\n *\n * @param <E> the element type\n * @param iterables  the iterables to combine, may not be null\n * @return a new iterable, combining the provided iterables\n * @throws NullPointerException if either of the provided iterables is null\n */\npublic static <E> Iterable<E> chainedIterable(final Iterable<? extends E>... iterables) {\n    checkNotNull(iterables);\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            return new LazyIteratorChain<E>() {\n\n                @Override\n                protected Iterator<? extends E> nextIterator(int count) {\n                    if (count > iterables.length) {\n                        return null;\n                    } else {\n                        return iterables[count - 1].iterator();\n                    }\n                }\n            };\n        }\n    };\n}"
            ],
            [
                "collatedIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Collated\n// ----------------------------------------------------------------------\n/**\n * Combines the two provided iterables into an ordered iterable using\n * natural ordering.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the\n * corresponding input iterator supports it.\n *\n * @param <E> the element type\n * @param a  the first iterable, may not be null\n * @param b  the second iterable, may not be null\n * @return a filtered view on the specified iterable\n * @throws NullPointerException if either of the provided iterables is null\n */\npublic static <E> Iterable<E> collatedIterable(final Iterable<? extends E> a, final Iterable<? extends E> b) {\n    checkNotNull(a, b);\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            return IteratorUtils.collatedIterator(null, a.iterator(), b.iterator());\n        }\n    };\n}"
            ],
            [
                "collatedIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Combines the two provided iterables into an ordered iterable using the\n * provided comparator. If the comparator is null, natural ordering will be\n * used.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the\n * corresponding input iterator supports it.\n *\n * @param <E> the element type\n * @param comparator  the comparator defining an ordering over the elements,\n *   may be null, in which case natural ordering will be used\n * @param a  the first iterable, may not be null\n * @param b  the second iterable, may not be null\n * @return a filtered view on the specified iterable\n * @throws NullPointerException if either of the provided iterables is null\n */\npublic static <E> Iterable<E> collatedIterable(final Comparator<? super E> comparator, final Iterable<? extends E> a, final Iterable<? extends E> b) {\n    checkNotNull(a, b);\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            return IteratorUtils.collatedIterator(comparator, a.iterator(), b.iterator());\n        }\n    };\n}"
            ],
            [
                "filteredIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Filtered\n// ----------------------------------------------------------------------\n/**\n * Returns a view of the given iterable that only contains elements matching\n * the provided predicate.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the\n * corresponding input iterator supports it.\n *\n * @param <E> the element type\n * @param iterable  the iterable to filter, may not be null\n * @param predicate  the predicate used to filter elements, may not be null\n * @return a filtered view on the specified iterable\n * @throws NullPointerException if either iterable or predicate is null\n */\npublic static <E> Iterable<E> filteredIterable(final Iterable<E> iterable, final Predicate<? super E> predicate) {\n    checkNotNull(iterable);\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null.\");\n    }\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            return IteratorUtils.filteredIterator(emptyIteratorIfNull(iterable), predicate);\n        }\n    };\n}"
            ],
            [
                "boundedIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Bounded\n// ----------------------------------------------------------------------\n/**\n * Returns a view of the given iterable that contains at most the given number\n * of elements.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the corresponding\n * input iterator supports it.\n *\n * @param <E> the element type\n * @param iterable  the iterable to limit, may not be null\n * @param maxSize  the maximum number of elements, must not be negative\n * @return a bounded view on the specified iterable\n * @throws IllegalArgumentException if maxSize is negative\n * @throws NullPointerException if iterable is null\n */\npublic static <E> Iterable<E> boundedIterable(final Iterable<E> iterable, final long maxSize) {\n    checkNotNull(iterable);\n    if (maxSize < 0) {\n        throw new IllegalArgumentException(\"MaxSize parameter must not be negative.\");\n    }\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            return IteratorUtils.boundedIterator(iterable.iterator(), maxSize);\n        }\n    };\n}"
            ],
            [
                "loopingIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Looping\n// ----------------------------------------------------------------------\n/**\n * Returns a view of the given iterable which will cycle infinitely over\n * its elements.\n * <p>\n * The returned iterable's iterator supports {@code remove()} if\n * {@code iterable.iterator()} does. After {@code remove()} is called, subsequent\n * cycles omit the removed element, which is no longer in {@code iterable}. The\n * iterator's {@code hasNext()} method returns {@code true} until {@code iterable}\n * is empty.\n *\n * @param <E> the element type\n * @param iterable  the iterable to loop, may not be null\n * @return a view of the iterable, providing an infinite loop over its elements\n * @throws NullPointerException if iterable is null\n */\npublic static <E> Iterable<E> loopingIterable(final Iterable<E> iterable) {\n    checkNotNull(iterable);\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            return new LazyIteratorChain<E>() {\n\n                @Override\n                protected Iterator<? extends E> nextIterator(int count) {\n                    if (IterableUtils.isEmpty(iterable)) {\n                        return null;\n                    } else {\n                        return iterable.iterator();\n                    }\n                }\n            };\n        }\n    };\n}"
            ],
            [
                "reversedIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Reversed\n// ----------------------------------------------------------------------\n/**\n * Returns a reversed view of the given iterable.\n * <p>\n * In case the provided iterable is a {@link List} instance, a\n * {@link ReverseListIterator} will be used to reverse the traversal\n * order, otherwise an intermediate {@link List} needs to be created.\n * <p>\n * The returned iterable's iterator supports {@code remove()} if the\n * provided iterable is a {@link List} instance.\n *\n * @param <E> the element type\n * @param iterable  the iterable to use, may not be null\n * @return a reversed view of the specified iterable\n * @throws NullPointerException if iterable is null\n * @see ReverseListIterator\n */\npublic static <E> Iterable<E> reversedIterable(final Iterable<E> iterable) {\n    checkNotNull(iterable);\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            final List<E> list = (iterable instanceof List<?>) ? (List<E>) iterable : IteratorUtils.toList(iterable.iterator());\n            return new ReverseListIterator<E>(list);\n        }\n    };\n}"
            ],
            [
                "skippingIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Skipping\n// ----------------------------------------------------------------------\n/**\n * Returns a view of the given iterable that skips the first N elements.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the corresponding\n * input iterator supports it.\n *\n * @param <E> the element type\n * @param iterable  the iterable to use, may not be null\n * @param elementsToSkip  the number of elements to skip from the start, must not be negative\n * @return a view of the specified iterable, skipping the first N elements\n * @throws IllegalArgumentException if elementsToSkip is negative\n * @throws NullPointerException if iterable is null\n */\npublic static <E> Iterable<E> skippingIterable(final Iterable<E> iterable, final long elementsToSkip) {\n    checkNotNull(iterable);\n    if (elementsToSkip < 0) {\n        throw new IllegalArgumentException(\"ElementsToSkip parameter must not be negative.\");\n    }\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            return IteratorUtils.skippingIterator(iterable.iterator(), elementsToSkip);\n        }\n    };\n}"
            ],
            [
                "transformedIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Transformed\n// ----------------------------------------------------------------------\n/**\n * Returns a transformed view of the given iterable where all of its elements\n * have been transformed by the provided transformer.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the corresponding\n * input iterator supports it.\n *\n * @param <I>  the input element type\n * @param <O>  the output element type\n * @param iterable  the iterable to transform, may not be null\n * @param transformer  the transformer, must not be null\n * @return a transformed view of the specified iterable\n * @throws NullPointerException if either iterable or transformer is null\n */\npublic static <I, O> Iterable<O> transformedIterable(final Iterable<I> iterable, final Transformer<? super I, ? extends O> transformer) {\n    checkNotNull(iterable);\n    if (transformer == null) {\n        throw new NullPointerException(\"Transformer must not be null.\");\n    }\n    return new FluentIterable<O>() {\n\n        @Override\n        public Iterator<O> iterator() {\n            return IteratorUtils.transformedIterator(iterable.iterator(), transformer);\n        }\n    };\n}"
            ],
            [
                "uniqueIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Unique\n// ----------------------------------------------------------------------\n/**\n * Returns a unique view of the given iterable.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the\n * corresponding input iterator supports it. Calling {@code remove()}\n * will only remove a single element from the underlying iterator.\n *\n * @param <E> the element type\n * @param iterable  the iterable to use, may not be null\n * @return a unique view of the specified iterable\n * @throws NullPointerException if iterable is null\n */\npublic static <E> Iterable<E> uniqueIterable(final Iterable<E> iterable) {\n    checkNotNull(iterable);\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            return new UniqueFilterIterator<E>(iterable.iterator());\n        }\n    };\n}"
            ],
            [
                "unmodifiableIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Unmodifiable\n// ----------------------------------------------------------------------\n/**\n * Returns an unmodifiable view of the given iterable.\n * <p>\n * The returned iterable's iterator does not support {@code remove()}.\n *\n * @param <E> the element type\n * @param iterable  the iterable to use, may not be null\n * @return an unmodifiable view of the specified iterable\n * @throws NullPointerException if iterable is null\n */\npublic static <E> Iterable<E> unmodifiableIterable(final Iterable<E> iterable) {\n    checkNotNull(iterable);\n    if (iterable instanceof UnmodifiableIterable<?>) {\n        return iterable;\n    }\n    return new UnmodifiableIterable<E>(iterable);\n}"
            ],
            [
                "zippingIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Zipping\n// ----------------------------------------------------------------------\n/**\n * Interleaves two iterables into a single iterable.\n * <p>\n * The returned iterable has an iterator that traverses the elements in {@code a}\n * and {@code b} in alternating order. The source iterators are not polled until\n * necessary.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the corresponding\n * input iterator supports it.\n *\n * @param <E> the element type\n * @param a  the first iterable, may not be null\n * @param b  the second iterable, may not be null\n * @return a new iterable, interleaving the provided iterables\n * @throws NullPointerException if either a or b is null\n */\npublic static <E> Iterable<E> zippingIterable(final Iterable<? extends E> a, final Iterable<? extends E> b) {\n    checkNotNull(a);\n    checkNotNull(b);\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            return IteratorUtils.zippingIterator(a.iterator(), b.iterator());\n        }\n    };\n}"
            ],
            [
                "zippingIterable",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Interleaves two iterables into a single iterable.\n * <p>\n * The returned iterable has an iterator that traverses the elements in {@code a}\n * and {@code b} in alternating order. The source iterators are not polled until\n * necessary.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the corresponding\n * input iterator supports it.\n *\n * @param <E> the element type\n * @param first  the first iterable, may not be null\n * @param others  the array of iterables to interleave, may not be null\n * @return a new iterable, interleaving the provided iterables\n * @throws NullPointerException if either of the provided iterables is null\n */\npublic static <E> Iterable<E> zippingIterable(final Iterable<? extends E> first, final Iterable<? extends E>... others) {\n    checkNotNull(first);\n    checkNotNull(others);\n    return new FluentIterable<E>() {\n\n        @Override\n        public Iterator<E> iterator() {\n            // safe\n            @SuppressWarnings(\"unchecked\")\n            Iterator<? extends E>[] iterators = new Iterator[others.length + 1];\n            iterators[0] = first.iterator();\n            for (int i = 0; i < others.length; i++) {\n                iterators[i + 1] = others[i].iterator();\n            }\n            return IteratorUtils.zippingIterator(iterators);\n        }\n    };\n}"
            ],
            [
                "emptyIfNull",
                "org.apache.commons.collections4",
                "IterableUtils",
                "// Utility methods\n// ----------------------------------------------------------------------\n/**\n * Returns an immutable empty iterable if the argument is null,\n * or the argument itself otherwise.\n *\n * @param <E> the element type\n * @param iterable  the iterable, may be null\n * @return an empty iterable if the argument is null\n */\npublic static <E> Iterable<E> emptyIfNull(final Iterable<E> iterable) {\n    return iterable == null ? IterableUtils.<E>emptyIterable() : iterable;\n}"
            ],
            [
                "forEachButLast",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Executes the given closure on each but the last element in the iterable.\n * <p>\n * If the input iterable is null no change is made.\n *\n * @param <E> the type of object the {@link Iterable} contains\n * @param iterable  the iterable to get the input from, may be null\n * @param closure  the closure to perform, may not be null\n * @return the last element in the iterable, or null if iterable is null or empty\n */\npublic static <E> E forEachButLast(final Iterable<E> iterable, final Closure<? super E> closure) {\n    return IteratorUtils.forEachButLast(emptyIteratorIfNull(iterable), closure);\n}"
            ],
            [
                "find",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Finds the first element in the given iterable which matches the given predicate.\n * <p>\n * A <code>null</code> or empty iterator returns null.\n *\n * @param <E> the element type\n * @param iterable  the iterable to search, may be null\n * @param predicate  the predicate to use, may not be null\n * @return the first element of the iterable which matches the predicate or null if none could be found\n * @throws NullPointerException if predicate is null\n */\npublic static <E> E find(final Iterable<E> iterable, final Predicate<? super E> predicate) {\n    return IteratorUtils.find(emptyIteratorIfNull(iterable), predicate);\n}"
            ],
            [
                "indexOf",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Returns the index of the first element in the specified iterable that\n * matches the given predicate.\n * <p>\n * A <code>null</code> or empty iterable returns -1.\n *\n * @param <E> the element type\n * @param iterable  the iterable to search, may be null\n * @param predicate  the predicate to use, may not be null\n * @return the index of the first element which matches the predicate or -1 if none matches\n * @throws NullPointerException if predicate is null\n */\npublic static <E> int indexOf(final Iterable<E> iterable, final Predicate<? super E> predicate) {\n    return IteratorUtils.indexOf(emptyIteratorIfNull(iterable), predicate);\n}"
            ],
            [
                "matchesAll",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Answers true if a predicate is true for every element of an iterable.\n * <p>\n * A <code>null</code> or empty iterable returns true.\n *\n * @param <E> the type of object the {@link Iterable} contains\n * @param iterable  the {@link Iterable} to use, may be null\n * @param predicate  the predicate to use, may not be null\n * @return true if every element of the collection matches the predicate or if the\n *   collection is empty, false otherwise\n * @throws NullPointerException if predicate is null\n */\npublic static <E> boolean matchesAll(final Iterable<E> iterable, final Predicate<? super E> predicate) {\n    return IteratorUtils.matchesAll(emptyIteratorIfNull(iterable), predicate);\n}"
            ],
            [
                "matchesAny",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Answers true if a predicate is true for any element of the iterable.\n * <p>\n * A <code>null</code> or empty iterable returns false.\n *\n * @param <E> the type of object the {@link Iterable} contains\n * @param iterable  the {@link Iterable} to use, may be null\n * @param predicate  the predicate to use, may not be null\n * @return true if any element of the collection matches the predicate, false otherwise\n * @throws NullPointerException if predicate is null\n */\npublic static <E> boolean matchesAny(final Iterable<E> iterable, final Predicate<? super E> predicate) {\n    return IteratorUtils.matchesAny(emptyIteratorIfNull(iterable), predicate);\n}"
            ],
            [
                "countMatches",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Counts the number of elements in the input iterable that match the predicate.\n * <p>\n * A <code>null</code> iterable matches no elements.\n *\n * @param <E> the type of object the {@link Iterable} contains\n * @param input  the {@link Iterable} to get the input from, may be null\n * @param predicate  the predicate to use, may not be null\n * @return the number of matches for the predicate in the collection\n * @throws NullPointerException if predicate is null\n */\npublic static <E> long countMatches(final Iterable<E> input, final Predicate<? super E> predicate) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null.\");\n    }\n    return size(filteredIterable(emptyIfNull(input), predicate));\n}"
            ],
            [
                "isEmpty",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Answers true if the provided iterable is empty.\n * <p>\n * A <code>null</code> iterable returns true.\n *\n * @param iterable  the {@link Iterable to use}, may be null\n * @return true if the iterable is null or empty, false otherwise\n */\npublic static boolean isEmpty(final Iterable<?> iterable) {\n    if (iterable instanceof Collection<?>) {\n        return ((Collection<?>) iterable).isEmpty();\n    } else {\n        return IteratorUtils.isEmpty(emptyIteratorIfNull(iterable));\n    }\n}"
            ],
            [
                "contains",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Checks if the object is contained in the given iterable.\n * <p>\n * A <code>null</code> or empty iterable returns false.\n *\n * @param <E> the type of object the {@link Iterable} contains\n * @param iterable  the iterable to check, may be null\n * @param object  the object to check\n * @return true if the object is contained in the iterable, false otherwise\n */\npublic static <E> boolean contains(final Iterable<E> iterable, final Object object) {\n    if (iterable instanceof Collection<?>) {\n        return ((Collection<E>) iterable).contains(object);\n    } else {\n        return IteratorUtils.contains(emptyIteratorIfNull(iterable), object);\n    }\n}"
            ],
            [
                "contains",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Checks if the object is contained in the given iterable. Object equality\n * is tested with an {@code equator} unlike {@link #contains(Iterable, Object)}\n * which uses {@link Object#equals(Object)}.\n * <p>\n * A <code>null</code> or empty iterable returns false.\n * A <code>null</code> object will not be passed to the equator, instead a\n * {@link org.apache.commons.collections4.functors.NullPredicate NullPredicate}\n * will be used.\n *\n * @param <E> the type of object the {@link Iterable} contains\n * @param iterable  the iterable to check, may be null\n * @param object  the object to check\n * @param equator  the equator to use to check, may not be null\n * @return true if the object is contained in the iterable, false otherwise\n * @throws NullPointerException if equator is null\n */\npublic static <E> boolean contains(final Iterable<? extends E> iterable, final E object, final Equator<? super E> equator) {\n    if (equator == null) {\n        throw new NullPointerException(\"Equator must not be null.\");\n    }\n    return matchesAny(iterable, EqualPredicate.equalPredicate(object, equator));\n}"
            ],
            [
                "frequency",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Returns the number of occurrences of the provided object in the iterable.\n *\n * @param <E> the element type that the {@link Iterable} may contain\n * @param <T> the element type of the object to find\n * @param iterable  the {@link Iterable} to search\n * @param obj  the object to find the cardinality of\n * @return the the number of occurrences of obj in iterable\n */\npublic static <E, T extends E> int frequency(final Iterable<E> iterable, final T obj) {\n    if (iterable instanceof Set<?>) {\n        return ((Set<E>) iterable).contains(obj) ? 1 : 0;\n    }\n    if (iterable instanceof Bag<?>) {\n        return ((Bag<E>) iterable).getCount(obj);\n    }\n    return size(filteredIterable(emptyIfNull(iterable), EqualPredicate.<E>equalPredicate(obj)));\n}"
            ],
            [
                "get",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Returns the <code>index</code>-th value in the <code>iterable</code>'s {@link Iterator}, throwing\n * <code>IndexOutOfBoundsException</code> if there is no such element.\n * <p>\n * If the {@link Iterable} is a {@link List}, then it will use {@link List#get(int)}.\n *\n * @param <T> the type of object in the {@link Iterable}.\n * @param iterable  the {@link Iterable} to get a value from, may be null\n * @param index  the index to get\n * @return the object at the specified index\n * @throws IndexOutOfBoundsException if the index is invalid\n */\npublic static <T> T get(final Iterable<T> iterable, final int index) {\n    CollectionUtils.checkIndexBounds(index);\n    if (iterable instanceof List<?>) {\n        return ((List<T>) iterable).get(index);\n    }\n    return IteratorUtils.get(emptyIteratorIfNull(iterable), index);\n}"
            ],
            [
                "size",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Returns the number of elements contained in the given iterator.\n * <p>\n * A <code>null</code> or empty iterator returns {@code 0}.\n *\n * @param iterable  the iterable to check, may be null\n * @return the number of elements contained in the iterable\n */\npublic static int size(final Iterable<?> iterable) {\n    if (iterable instanceof Collection<?>) {\n        return ((Collection<?>) iterable).size();\n    } else {\n        return IteratorUtils.size(emptyIteratorIfNull(iterable));\n    }\n}"
            ],
            [
                "partition",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Partitions all elements from iterable into separate output collections,\n * based on the evaluation of the given predicate.\n * <p>\n * For each predicate, the result will contain a list holding all elements of the\n * input iterable matching the predicate. The last list will hold all elements\n * which didn't match any predicate:\n * <pre>\n *  [C1, R] = partition(I, P1) with\n *  I = input\n *  P1 = first predicate\n *  C1 = collection of elements matching P1\n *  R = collection of elements rejected by all predicates\n * </pre>\n * <p>\n * If the input iterable is <code>null</code>, the same is returned as for an\n * empty iterable.\n * <p>\n * Example: for an input list [1, 2, 3, 4, 5] calling partition with a predicate [x &lt; 3]\n * will result in the following output: [[1, 2], [3, 4, 5]].\n *\n * @param <O>  the type of object the {@link Iterable} contains\n * @param iterable  the iterable to partition, may be null\n * @param predicate  the predicate to use, may not be null\n * @return a list containing the output collections\n * @throws NullPointerException if predicate is null\n */\npublic static <O> List<List<O>> partition(final Iterable<? extends O> iterable, final Predicate<? super O> predicate) {\n    if (predicate == null) {\n        throw new NullPointerException(\"Predicate must not be null.\");\n    }\n    // safe\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    final Factory<List<O>> factory = FactoryUtils.instantiateFactory((Class) ArrayList.class);\n    // safe\n    @SuppressWarnings(\"unchecked\")\n    final Predicate<? super O>[] predicates = new Predicate[] { predicate };\n    return partition(iterable, factory, predicates);\n}"
            ],
            [
                "partition",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Partitions all elements from iterable into separate output collections,\n * based on the evaluation of the given predicates.\n * <p>\n * For each predicate, the result will contain a list holding all elements of the\n * input iterable matching the predicate. The last list will hold all elements\n * which didn't match any predicate:\n * <pre>\n *  [C1, C2, R] = partition(I, P1, P2) with\n *  I = input\n *  P1 = first predicate\n *  P2 = second predicate\n *  C1 = collection of elements matching P1\n *  C2 = collection of elements matching P2\n *  R = collection of elements rejected by all predicates\n * </pre>\n * <p>\n * <b>Note</b>: elements are only added to the output collection of the first matching\n * predicate, determined by the order of arguments.\n * <p>\n * If the input iterable is <code>null</code>, the same is returned as for an\n * empty iterable.\n * <p>\n * Example: for an input list [1, 2, 3, 4, 5] calling partition with predicates [x &lt; 3]\n * and [x &lt; 5] will result in the following output: [[1, 2], [3, 4], [5]].\n *\n * @param <O>  the type of object the {@link Iterable} contains\n * @param iterable  the collection to get the input from, may be null\n * @param predicates  the predicates to use, may not be null\n * @return a list containing the output collections\n * @throws NullPointerException if any predicate is null\n */\npublic static <O> List<List<O>> partition(final Iterable<? extends O> iterable, final Predicate<? super O>... predicates) {\n    // safe\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    final Factory<List<O>> factory = FactoryUtils.instantiateFactory((Class) ArrayList.class);\n    return partition(iterable, factory, predicates);\n}"
            ],
            [
                "partition",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Partitions all elements from iterable into separate output collections,\n * based on the evaluation of the given predicates.\n * <p>\n * For each predicate, the returned list will contain a collection holding\n * all elements of the input iterable matching the predicate. The last collection\n * contained in the list will hold all elements which didn't match any predicate:\n * <pre>\n *  [C1, C2, R] = partition(I, P1, P2) with\n *  I = input\n *  P1 = first predicate\n *  P2 = second predicate\n *  C1 = collection of elements matching P1\n *  C2 = collection of elements matching P2\n *  R = collection of elements rejected by all predicates\n * </pre>\n * <p>\n * <b>Note</b>: elements are only added to the output collection of the first matching\n * predicate, determined by the order of arguments.\n * <p>\n * If the input iterable is <code>null</code>, the same is returned as for an\n * empty iterable.\n * If no predicates have been provided, all elements of the input collection\n * will be added to the rejected collection.\n * <p>\n * Example: for an input list [1, 2, 3, 4, 5] calling partition with predicates [x &lt; 3]\n * and [x &lt; 5] will result in the following output: [[1, 2], [3, 4], [5]].\n *\n * @param <O>  the type of object the {@link Iterable} contains\n * @param <R>  the type of the output {@link Collection}\n * @param iterable  the collection to get the input from, may be null\n * @param partitionFactory  the factory used to create the output collections\n * @param predicates  the predicates to use, may not be null\n * @return a list containing the output collections\n * @throws NullPointerException if any predicate is null\n */\npublic static <O, R extends Collection<O>> List<R> partition(final Iterable<? extends O> iterable, final Factory<R> partitionFactory, final Predicate<? super O>... predicates) {\n    if (iterable == null) {\n        final Iterable<O> empty = emptyIterable();\n        return partition(empty, partitionFactory, predicates);\n    }\n    if (predicates == null) {\n        throw new NullPointerException(\"Predicates must not be null.\");\n    }\n    for (Predicate<?> p : predicates) {\n        if (p == null) {\n            throw new NullPointerException(\"Predicate must not be null.\");\n        }\n    }\n    if (predicates.length < 1) {\n        // return the entire input collection as a single partition\n        final R singlePartition = partitionFactory.create();\n        CollectionUtils.addAll(singlePartition, iterable);\n        return Collections.singletonList(singlePartition);\n    }\n    // create the empty partitions\n    final int numberOfPredicates = predicates.length;\n    final int numberOfPartitions = numberOfPredicates + 1;\n    final List<R> partitions = new ArrayList<R>(numberOfPartitions);\n    for (int i = 0; i < numberOfPartitions; ++i) {\n        partitions.add(partitionFactory.create());\n    }\n    // for each element in inputCollection:\n    // find the first predicate that evaluates to true.\n    // if there is a predicate, add the element to the corresponding partition.\n    // if there is no predicate, add it to the last, catch-all partition.\n    for (final O element : iterable) {\n        boolean elementAssigned = false;\n        for (int i = 0; i < numberOfPredicates; ++i) {\n            if (predicates[i].evaluate(element)) {\n                partitions.get(i).add(element);\n                elementAssigned = true;\n                break;\n            }\n        }\n        if (!elementAssigned) {\n            // no predicates evaluated to true\n            // add element to last partition\n            partitions.get(numberOfPredicates).add(element);\n        }\n    }\n    return partitions;\n}"
            ],
            [
                "toList",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Gets a new list with the contents of the provided iterable.\n *\n * @param <E> the element type\n * @param iterable  the iterable to use, may be null\n * @return a list of the iterator contents\n */\npublic static <E> List<E> toList(final Iterable<E> iterable) {\n    return IteratorUtils.toList(emptyIteratorIfNull(iterable));\n}"
            ],
            [
                "toString",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Returns a string representation of the elements of the specified iterable.\n * <p>\n * The string representation consists of a list of the iterable's elements,\n * enclosed in square brackets ({@code \"[]\"}). Adjacent elements are separated\n * by the characters {@code \", \"} (a comma followed by a space). Elements are\n * converted to strings as by {@code String.valueOf(Object)}.\n *\n * @param <E> the element type\n * @param iterable  the iterable to convert to a string, may be null\n * @return a string representation of {@code iterable}\n */\npublic static <E> String toString(final Iterable<E> iterable) {\n    return IteratorUtils.toString(emptyIteratorIfNull(iterable));\n}"
            ],
            [
                "toString",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Returns a string representation of the elements of the specified iterable.\n * <p>\n * The string representation consists of a list of the iterable's elements,\n * enclosed in square brackets ({@code \"[]\"}). Adjacent elements are separated\n * by the characters {@code \", \"} (a comma followed by a space). Elements are\n * converted to strings as by using the provided {@code transformer}.\n *\n * @param <E> the element type\n * @param iterable  the iterable to convert to a string, may be null\n * @param transformer  the transformer used to get a string representation of an element\n * @return a string representation of {@code iterable}\n * @throws NullPointerException if {@code transformer} is null\n */\npublic static <E> String toString(final Iterable<E> iterable, final Transformer<? super E, String> transformer) {\n    if (transformer == null) {\n        throw new NullPointerException(\"Transformer must not be null.\");\n    }\n    return IteratorUtils.toString(emptyIteratorIfNull(iterable), transformer);\n}"
            ],
            [
                "toString",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * Returns a string representation of the elements of the specified iterable.\n * <p>\n * The string representation consists of a list of the iterable's elements,\n * enclosed by the provided {@code prefix} and {@code suffix}. Adjacent elements\n * are separated by the provided {@code delimiter}. Elements are converted to\n * strings as by using the provided {@code transformer}.\n *\n * @param <E> the element type\n * @param iterable  the iterable to convert to a string, may be null\n * @param transformer  the transformer used to get a string representation of an element\n * @param delimiter  the string to delimit elements\n * @param prefix  the prefix, prepended to the string representation\n * @param suffix  the suffix, appended to the string representation\n * @return a string representation of {@code iterable}\n * @throws NullPointerException if either transformer, delimiter, prefix or suffix is null\n */\npublic static <E> String toString(final Iterable<E> iterable, final Transformer<? super E, String> transformer, final String delimiter, final String prefix, final String suffix) {\n    return IteratorUtils.toString(emptyIteratorIfNull(iterable), transformer, delimiter, prefix, suffix);\n}"
            ],
            [
                "unmodifiableTrie",
                "org.apache.commons.collections4",
                "TrieUtils",
                "/**\n * Returns an unmodifiable instance of a {@link Trie}\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param trie  the trie to make unmodifiable, must not be null\n * @return an unmodifiable trie backed by the given trie\n * @throws NullPointerException if trie is null\n *\n * @see java.util.Collections#unmodifiableMap(java.util.Map)\n */\npublic static <K, V> Trie<K, V> unmodifiableTrie(final Trie<K, ? extends V> trie) {\n    return UnmodifiableTrie.unmodifiableTrie(trie);\n}"
            ],
            [
                "exceptionClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Gets a Closure that always throws an exception.\n * This could be useful during testing as a placeholder.\n *\n * @see org.apache.commons.collections4.functors.ExceptionClosure\n *\n * @param <E>  the type that the closure acts on\n * @return the closure\n */\npublic static <E> Closure<E> exceptionClosure() {\n    return ExceptionClosure.<E>exceptionClosure();\n}"
            ],
            [
                "nopClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Gets a Closure that will do nothing.\n * This could be useful during testing as a placeholder.\n *\n * @see org.apache.commons.collections4.functors.NOPClosure\n *\n * @param <E>  the type that the closure acts on\n * @return the closure\n */\npublic static <E> Closure<E> nopClosure() {\n    return NOPClosure.<E>nopClosure();\n}"
            ],
            [
                "asClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Creates a Closure that calls a Transformer each time it is called.\n * The transformer will be called using the closure's input object.\n * The transformer's result will be ignored.\n *\n * @see org.apache.commons.collections4.functors.TransformerClosure\n *\n * @param <E>  the type that the closure acts on\n * @param transformer  the transformer to run each time in the closure, null means nop\n * @return the closure\n */\npublic static <E> Closure<E> asClosure(final Transformer<? super E, ?> transformer) {\n    return TransformerClosure.transformerClosure(transformer);\n}"
            ],
            [
                "forClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Creates a Closure that will call the closure <code>count</code> times.\n * <p>\n * A null closure or zero count returns the <code>NOPClosure</code>.\n *\n * @see org.apache.commons.collections4.functors.ForClosure\n *\n * @param <E>  the type that the closure acts on\n * @param count  the number of times to loop\n * @param closure  the closure to call repeatedly\n * @return the <code>for</code> closure\n */\npublic static <E> Closure<E> forClosure(final int count, final Closure<? super E> closure) {\n    return ForClosure.forClosure(count, closure);\n}"
            ],
            [
                "whileClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Creates a Closure that will call the closure repeatedly until the\n * predicate returns false.\n *\n * @see org.apache.commons.collections4.functors.WhileClosure\n *\n * @param <E>  the type that the closure acts on\n * @param predicate  the predicate to use as an end of loop test, not null\n * @param closure  the closure to call repeatedly, not null\n * @return the <code>while</code> closure\n * @throws NullPointerException if either argument is null\n */\npublic static <E> Closure<E> whileClosure(final Predicate<? super E> predicate, final Closure<? super E> closure) {\n    return WhileClosure.<E>whileClosure(predicate, closure, false);\n}"
            ],
            [
                "doWhileClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Creates a Closure that will call the closure once and then repeatedly\n * until the predicate returns false.\n *\n * @see org.apache.commons.collections4.functors.WhileClosure\n *\n * @param <E>  the type that the closure acts on\n * @param closure  the closure to call repeatedly, not null\n * @param predicate  the predicate to use as an end of loop test, not null\n * @return the <code>do-while</code> closure\n * @throws NullPointerException if either argument is null\n */\npublic static <E> Closure<E> doWhileClosure(final Closure<? super E> closure, final Predicate<? super E> predicate) {\n    return WhileClosure.<E>whileClosure(predicate, closure, true);\n}"
            ],
            [
                "invokerClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Creates a Closure that will invoke a specific method on the closure's\n * input object by reflection.\n *\n * @see org.apache.commons.collections4.functors.InvokerTransformer\n * @see org.apache.commons.collections4.functors.TransformerClosure\n *\n * @param <E>  the type that the closure acts on\n * @param methodName  the name of the method\n * @return the <code>invoker</code> closure\n * @throws NullPointerException if the method name is null\n */\npublic static <E> Closure<E> invokerClosure(final String methodName) {\n    // reuse transformer as it has caching - this is lazy really, should have inner class here\n    return asClosure(InvokerTransformer.<E, Object>invokerTransformer(methodName));\n}"
            ],
            [
                "invokerClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Creates a Closure that will invoke a specific method on the closure's\n * input object by reflection.\n *\n * @see org.apache.commons.collections4.functors.InvokerTransformer\n * @see org.apache.commons.collections4.functors.TransformerClosure\n *\n * @param <E>  the type that the closure acts on\n * @param methodName  the name of the method\n * @param paramTypes  the parameter types\n * @param args  the arguments\n * @return the <code>invoker</code> closure\n * @throws NullPointerException if the method name is null\n * @throws IllegalArgumentException if the paramTypes and args don't match\n */\npublic static <E> Closure<E> invokerClosure(final String methodName, final Class<?>[] paramTypes, final Object[] args) {\n    // reuse transformer as it has caching - this is lazy really, should have inner class here\n    return asClosure(InvokerTransformer.<E, Object>invokerTransformer(methodName, paramTypes, args));\n}"
            ],
            [
                "chainedClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Create a new Closure that calls each closure in turn, passing the\n * result into the next closure.\n *\n * @see org.apache.commons.collections4.functors.ChainedClosure\n *\n * @param <E>  the type that the closure acts on\n * @param closures  an array of closures to chain\n * @return the <code>chained</code> closure\n * @throws NullPointerException if the closures array is null\n * @throws NullPointerException if any closure in the array is null\n */\npublic static <E> Closure<E> chainedClosure(final Closure<? super E>... closures) {\n    return ChainedClosure.chainedClosure(closures);\n}"
            ],
            [
                "chainedClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Create a new Closure that calls each closure in turn, passing the\n * result into the next closure. The ordering is that of the iterator()\n * method on the collection.\n *\n * @see org.apache.commons.collections4.functors.ChainedClosure\n *\n * @param <E>  the type that the closure acts on\n * @param closures  a collection of closures to chain\n * @return the <code>chained</code> closure\n * @throws NullPointerException if the closures collection is null\n * @throws NullPointerException if any closure in the collection is null\n * @throws IllegalArgumentException if the closures collection is empty\n */\npublic static <E> Closure<E> chainedClosure(final Collection<? extends Closure<? super E>> closures) {\n    return ChainedClosure.chainedClosure(closures);\n}"
            ],
            [
                "ifClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Create a new Closure that calls another closure based on the\n * result of the specified predicate.\n *\n * @see org.apache.commons.collections4.functors.IfClosure\n *\n * @param <E>  the type that the closure acts on\n * @param predicate  the validating predicate\n * @param trueClosure  the closure called if the predicate is true\n * @return the <code>if</code> closure\n * @throws NullPointerException if the predicate or closure is null\n * @since 3.2\n */\npublic static <E> Closure<E> ifClosure(final Predicate<? super E> predicate, final Closure<? super E> trueClosure) {\n    return IfClosure.<E>ifClosure(predicate, trueClosure);\n}"
            ],
            [
                "ifClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Create a new Closure that calls one of two closures depending\n * on the specified predicate.\n *\n * @see org.apache.commons.collections4.functors.IfClosure\n *\n * @param <E>  the type that the closure acts on\n * @param predicate  the predicate to switch on\n * @param trueClosure  the closure called if the predicate is true\n * @param falseClosure  the closure called if the predicate is false\n * @return the <code>switch</code> closure\n * @throws NullPointerException if the predicate or either closure is null\n */\npublic static <E> Closure<E> ifClosure(final Predicate<? super E> predicate, final Closure<? super E> trueClosure, final Closure<? super E> falseClosure) {\n    return IfClosure.<E>ifClosure(predicate, trueClosure, falseClosure);\n}"
            ],
            [
                "switchClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Create a new Closure that calls one of the closures depending\n * on the predicates.\n * <p>\n * The closure at array location 0 is called if the predicate at array\n * location 0 returned true. Each predicate is evaluated\n * until one returns true.\n *\n * @see org.apache.commons.collections4.functors.SwitchClosure\n *\n * @param <E>  the type that the closure acts on\n * @param predicates  an array of predicates to check, not null\n * @param closures  an array of closures to call, not null\n * @return the <code>switch</code> closure\n * @throws NullPointerException if the either array is null\n * @throws NullPointerException if any element in the arrays is null\n * @throws IllegalArgumentException if the arrays have different sizes\n */\npublic static <E> Closure<E> switchClosure(final Predicate<? super E>[] predicates, final Closure<? super E>[] closures) {\n    return SwitchClosure.<E>switchClosure(predicates, closures, null);\n}"
            ],
            [
                "switchClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Create a new Closure that calls one of the closures depending\n * on the predicates.\n * <p>\n * The closure at array location 0 is called if the predicate at array\n * location 0 returned true. Each predicate is evaluated\n * until one returns true. If no predicates evaluate to true, the default\n * closure is called.\n *\n * @see org.apache.commons.collections4.functors.SwitchClosure\n *\n * @param <E>  the type that the closure acts on\n * @param predicates  an array of predicates to check, not null\n * @param closures  an array of closures to call, not null\n * @param defaultClosure  the default to call if no predicate matches\n * @return the <code>switch</code> closure\n * @throws NullPointerException if the either array is null\n * @throws NullPointerException if any element in the arrays is null\n * @throws IllegalArgumentException if the arrays are different sizes\n */\npublic static <E> Closure<E> switchClosure(final Predicate<? super E>[] predicates, final Closure<? super E>[] closures, final Closure<? super E> defaultClosure) {\n    return SwitchClosure.<E>switchClosure(predicates, closures, defaultClosure);\n}"
            ],
            [
                "switchClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Create a new Closure that calls one of the closures depending\n * on the predicates.\n * <p>\n * The Map consists of Predicate keys and Closure values. A closure\n * is called if its matching predicate returns true. Each predicate is evaluated\n * until one returns true. If no predicates evaluate to true, the default\n * closure is called. The default closure is set in the map with a\n * null key. The ordering is that of the iterator() method on the entryset\n * collection of the map.\n *\n * @see org.apache.commons.collections4.functors.SwitchClosure\n *\n * @param <E>  the type that the closure acts on\n * @param predicatesAndClosures  a map of predicates to closures\n * @return the <code>switch</code> closure\n * @throws NullPointerException if the map is null\n * @throws NullPointerException if any closure in the map is null\n * @throws IllegalArgumentException if the map is empty\n * @throws ClassCastException  if the map elements are of the wrong type\n */\npublic static <E> Closure<E> switchClosure(final Map<Predicate<E>, Closure<E>> predicatesAndClosures) {\n    return SwitchClosure.switchClosure(predicatesAndClosures);\n}"
            ],
            [
                "switchMapClosure",
                "org.apache.commons.collections4",
                "ClosureUtils",
                "/**\n * Create a new Closure that uses the input object as a key to find the\n * closure to call.\n * <p>\n * The Map consists of object keys and Closure values. A closure\n * is called if the input object equals the key. If there is no match, the\n * default closure is called. The default closure is set in the map\n * using a null key.\n *\n * @see org.apache.commons.collections4.functors.SwitchClosure\n *\n * @param <E>  the type that the closure acts on\n * @param objectsAndClosures  a map of objects to closures\n * @return the closure\n * @throws NullPointerException if the map is null\n * @throws NullPointerException if any closure in the map is null\n * @throws IllegalArgumentException if the map is empty\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Closure<E> switchMapClosure(final Map<? extends E, Closure<E>> objectsAndClosures) {\n    if (objectsAndClosures == null) {\n        throw new NullPointerException(\"The object and closure map must not be null\");\n    }\n    final Closure<? super E> def = objectsAndClosures.remove(null);\n    final int size = objectsAndClosures.size();\n    final Closure<? super E>[] trs = new Closure[size];\n    final Predicate<E>[] preds = new Predicate[size];\n    int i = 0;\n    for (final Map.Entry<? extends E, Closure<E>> entry : objectsAndClosures.entrySet()) {\n        preds[i] = EqualPredicate.<E>equalPredicate(entry.getKey());\n        trs[i] = entry.getValue();\n        i++;\n    }\n    return ClosureUtils.<E>switchClosure(preds, trs, def);\n}"
            ],
            [
                "unmodifiableTrie",
                "org.apache.commons.collections4.trie",
                "UnmodifiableTrie",
                "/**\n * Factory method to create a unmodifiable trie.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param trie  the trie to decorate, must not be null\n * @return a new unmodifiable trie\n * @throws NullPointerException if trie is null\n */\npublic static <K, V> Trie<K, V> unmodifiableTrie(final Trie<K, ? extends V> trie) {\n    if (trie instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final Trie<K, V> tmpTrie = (Trie<K, V>) trie;\n        return tmpTrie;\n    }\n    return new UnmodifiableTrie<K, V>(trie);\n}"
            ],
            [
                "isOutOfBoundsIndex",
                "org.apache.commons.collections4.trie",
                "KeyAnalyzer",
                "/**\n * Returns true if bitIndex is a {@link KeyAnalyzer#OUT_OF_BOUNDS_BIT_KEY}.\n */\nstatic boolean isOutOfBoundsIndex(final int bitIndex) {\n    return bitIndex == OUT_OF_BOUNDS_BIT_KEY;\n}"
            ],
            [
                "isEqualBitKey",
                "org.apache.commons.collections4.trie",
                "KeyAnalyzer",
                "/**\n * Returns true if bitIndex is a {@link KeyAnalyzer#EQUAL_BIT_KEY}.\n */\nstatic boolean isEqualBitKey(final int bitIndex) {\n    return bitIndex == EQUAL_BIT_KEY;\n}"
            ],
            [
                "isNullBitKey",
                "org.apache.commons.collections4.trie",
                "KeyAnalyzer",
                "/**\n * Returns true if bitIndex is a {@link KeyAnalyzer#NULL_BIT_KEY}.\n */\nstatic boolean isNullBitKey(final int bitIndex) {\n    return bitIndex == NULL_BIT_KEY;\n}"
            ],
            [
                "isValidBitIndex",
                "org.apache.commons.collections4.trie",
                "KeyAnalyzer",
                "/**\n * Returns true if the given bitIndex is valid.\n * Indices are considered valid if they're between 0 and {@link Integer#MAX_VALUE}\n */\nstatic boolean isValidBitIndex(final int bitIndex) {\n    return bitIndex >= 0;\n}"
            ],
            [
                "isValidUplink",
                "org.apache.commons.collections4.trie",
                "AbstractPatriciaTrie",
                "/**\n * Returns true if 'next' is a valid uplink coming from 'from'.\n */\nstatic boolean isValidUplink(final TrieEntry<?, ?> next, final TrieEntry<?, ?> from) {\n    return next != null && next.bitIndex <= from.bitIndex && !next.isEmpty();\n}"
            ],
            [
                "compare",
                "org.apache.commons.collections4.trie",
                "AbstractBitwiseTrie",
                "/**\n * Returns true if both values are either null or equal.\n */\nstatic boolean compare(final Object a, final Object b) {\n    return a == null ? b == null : a.equals(b);\n}"
            ],
            [
                "transformingSortedMap",
                "org.apache.commons.collections4.map",
                "TransformedSortedMap",
                "/**\n * Factory method to create a transforming sorted map.\n * <p>\n * If there are any elements already in the map being decorated, they are NOT transformed.\n * Contrast this with {@link #transformedSortedMap(SortedMap, Transformer, Transformer)}.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param keyTransformer  the predicate to validate the keys, null means no transformation\n * @param valueTransformer  the predicate to validate to values, null means no transformation\n * @return a new transformed sorted map\n * @throws NullPointerException if the map is null\n * @since 4.0\n */\npublic static <K, V> TransformedSortedMap<K, V> transformingSortedMap(final SortedMap<K, V> map, final Transformer<? super K, ? extends K> keyTransformer, final Transformer<? super V, ? extends V> valueTransformer) {\n    return new TransformedSortedMap<K, V>(map, keyTransformer, valueTransformer);\n}"
            ],
            [
                "transformedSortedMap",
                "org.apache.commons.collections4.map",
                "TransformedSortedMap",
                "/**\n * Factory method to create a transforming sorted map that will transform\n * existing contents of the specified map.\n * <p>\n * If there are any elements already in the map being decorated, they\n * will be transformed by this method.\n * Contrast this with {@link #transformingSortedMap(SortedMap, Transformer, Transformer)}.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param keyTransformer  the transformer to use for key conversion, null means no transformation\n * @param valueTransformer  the transformer to use for value conversion, null means no transformation\n * @return a new transformed sorted map\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> TransformedSortedMap<K, V> transformedSortedMap(final SortedMap<K, V> map, final Transformer<? super K, ? extends K> keyTransformer, final Transformer<? super V, ? extends V> valueTransformer) {\n    final TransformedSortedMap<K, V> decorated = new TransformedSortedMap<K, V>(map, keyTransformer, valueTransformer);\n    if (map.size() > 0) {\n        final Map<K, V> transformed = decorated.transformMap(map);\n        decorated.clear();\n        // avoids double transformation\n        decorated.decorated().putAll(transformed);\n    }\n    return decorated;\n}"
            ],
            [
                "predicatedMap",
                "org.apache.commons.collections4.map",
                "PredicatedMap",
                "/**\n * Factory method to create a predicated (validating) map.\n * <p>\n * If there are any elements already in the list being decorated, they\n * are validated.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param keyPredicate  the predicate to validate the keys, null means no check\n * @param valuePredicate  the predicate to validate to values, null means no check\n * @return a new predicated map\n * @throws NullPointerException if the map is null\n * @since 4.0\n */\npublic static <K, V> PredicatedMap<K, V> predicatedMap(final Map<K, V> map, final Predicate<? super K> keyPredicate, final Predicate<? super V> valuePredicate) {\n    return new PredicatedMap<K, V>(map, keyPredicate, valuePredicate);\n}"
            ],
            [
                "fixedSizeSortedMap",
                "org.apache.commons.collections4.map",
                "FixedSizeSortedMap",
                "/**\n * Factory method to create a fixed size sorted map.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @return a new fixed size sorted map\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> FixedSizeSortedMap<K, V> fixedSizeSortedMap(final SortedMap<K, V> map) {\n    return new FixedSizeSortedMap<K, V>(map);\n}"
            ],
            [
                "unmodifiableSortedMap",
                "org.apache.commons.collections4.map",
                "UnmodifiableSortedMap",
                "/**\n * Factory method to create an unmodifiable sorted map.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @return a new unmodifiable sorted map\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> SortedMap<K, V> unmodifiableSortedMap(final SortedMap<K, ? extends V> map) {\n    if (map instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final SortedMap<K, V> tmpMap = (SortedMap<K, V>) map;\n        return tmpMap;\n    }\n    return new UnmodifiableSortedMap<K, V>(map);\n}"
            ],
            [
                "predicatedSortedMap",
                "org.apache.commons.collections4.map",
                "PredicatedSortedMap",
                "/**\n * Factory method to create a predicated (validating) sorted map.\n * <p>\n * If there are any elements already in the list being decorated, they\n * are validated.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param keyPredicate  the predicate to validate the keys, null means no check\n * @param valuePredicate  the predicate to validate to values, null means no check\n * @return a new predicated sorted map\n * @throws NullPointerException if the map is null\n * @since 4.0\n */\npublic static <K, V> PredicatedSortedMap<K, V> predicatedSortedMap(final SortedMap<K, V> map, final Predicate<? super K> keyPredicate, final Predicate<? super V> valuePredicate) {\n    return new PredicatedSortedMap<K, V>(map, keyPredicate, valuePredicate);\n}"
            ],
            [
                "defaultedMap",
                "org.apache.commons.collections4.map",
                "DefaultedMap",
                "//-----------------------------------------------------------------------\n/**\n * Factory method to create a defaulting map.\n * <p>\n * The value specified is returned when a missing key is found.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param defaultValue  the default value to return when the key is not found\n * @return a new defaulting map\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> DefaultedMap<K, V> defaultedMap(final Map<K, V> map, final V defaultValue) {\n    return new DefaultedMap<K, V>(map, ConstantTransformer.constantTransformer(defaultValue));\n}"
            ],
            [
                "defaultedMap",
                "org.apache.commons.collections4.map",
                "DefaultedMap",
                "/**\n * Factory method to create a defaulting map.\n * <p>\n * The factory specified is called when a missing key is found.\n * The result will be returned as the result of the map get(key) method.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param factory  the factory to use to create entries, must not be null\n * @return a new defaulting map\n * @throws NullPointerException if map or factory is null\n * @since 4.0\n */\npublic static <K, V> DefaultedMap<K, V> defaultedMap(final Map<K, V> map, final Factory<? extends V> factory) {\n    if (factory == null) {\n        throw new IllegalArgumentException(\"Factory must not be null\");\n    }\n    return new DefaultedMap<K, V>(map, FactoryTransformer.factoryTransformer(factory));\n}"
            ],
            [
                "defaultedMap",
                "org.apache.commons.collections4.map",
                "DefaultedMap",
                "/**\n * Factory method to create a defaulting map.\n * <p>\n * The transformer specified is called when a missing key is found.\n * The key is passed to the transformer as the input, and the result\n * will be returned as the result of the map get(key) method.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param transformer  the transformer to use as a factory to create entries, must not be null\n * @return a new defaulting map\n * @throws NullPointerException if map or factory is null\n * @since 4.0\n */\npublic static <K, V> Map<K, V> defaultedMap(final Map<K, V> map, final Transformer<? super K, ? extends V> transformer) {\n    if (transformer == null) {\n        throw new IllegalArgumentException(\"Transformer must not be null\");\n    }\n    return new DefaultedMap<K, V>(map, transformer);\n}"
            ],
            [
                "fixedSizeMap",
                "org.apache.commons.collections4.map",
                "FixedSizeMap",
                "/**\n * Factory method to create a fixed size map.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @return a new fixed size map\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> FixedSizeMap<K, V> fixedSizeMap(final Map<K, V> map) {\n    return new FixedSizeMap<K, V>(map);\n}"
            ],
            [
                "lazySortedMap",
                "org.apache.commons.collections4.map",
                "LazySortedMap",
                "/**\n * Factory method to create a lazily instantiated sorted map.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param factory  the factory to use, must not be null\n * @return a new lazy sorted map\n * @throws NullPointerException if map or factory is null\n * @since 4.0\n */\npublic static <K, V> LazySortedMap<K, V> lazySortedMap(final SortedMap<K, V> map, final Factory<? extends V> factory) {\n    return new LazySortedMap<K, V>(map, factory);\n}"
            ],
            [
                "lazySortedMap",
                "org.apache.commons.collections4.map",
                "LazySortedMap",
                "/**\n * Factory method to create a lazily instantiated sorted map.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param factory  the factory to use, must not be null\n * @return a new lazy sorted map\n * @throws NullPointerException if map or factory is null\n * @since 4.0\n */\npublic static <K, V> LazySortedMap<K, V> lazySortedMap(final SortedMap<K, V> map, final Transformer<? super K, ? extends V> factory) {\n    return new LazySortedMap<K, V>(map, factory);\n}"
            ],
            [
                "unmodifiableOrderedMap",
                "org.apache.commons.collections4.map",
                "UnmodifiableOrderedMap",
                "/**\n * Factory method to create an unmodifiable sorted map.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @return a new ordered map\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> OrderedMap<K, V> unmodifiableOrderedMap(final OrderedMap<? extends K, ? extends V> map) {\n    if (map instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final OrderedMap<K, V> tmpMap = (OrderedMap<K, V>) map;\n        return tmpMap;\n    }\n    return new UnmodifiableOrderedMap<K, V>(map);\n}"
            ],
            [
                "unmodifiableMap",
                "org.apache.commons.collections4.map",
                "UnmodifiableMap",
                "/**\n * Factory method to create an unmodifiable map.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @return a new unmodifiable map\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> Map<K, V> unmodifiableMap(final Map<? extends K, ? extends V> map) {\n    if (map instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final Map<K, V> tmpMap = (Map<K, V>) map;\n        return tmpMap;\n    }\n    return new UnmodifiableMap<K, V>(map);\n}"
            ],
            [
                "listOrderedMap",
                "org.apache.commons.collections4.map",
                "ListOrderedMap",
                "/**\n * Factory method to create an ordered map.\n * <p>\n * An <code>ArrayList</code> is used to retain order.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @return a new list ordered map\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> ListOrderedMap<K, V> listOrderedMap(final Map<K, V> map) {\n    return new ListOrderedMap<K, V>(map);\n}"
            ],
            [
                "unmodifiableEntrySet",
                "org.apache.commons.collections4.map",
                "UnmodifiableEntrySet",
                "/**\n * Factory method to create an unmodifiable set of Map Entry objects.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param set  the set to decorate, must not be null\n * @return a new unmodifiable entry set\n * @throws NullPointerException if set is null\n * @since 4.0\n */\npublic static <K, V> Set<Map.Entry<K, V>> unmodifiableEntrySet(final Set<Map.Entry<K, V>> set) {\n    if (set instanceof Unmodifiable) {\n        return set;\n    }\n    return new UnmodifiableEntrySet<K, V>(set);\n}"
            ],
            [
                "resolve",
                "org.apache.commons.collections4.map",
                "AbstractReferenceMap",
                "/**\n * Resolve enum from int.\n * @param value  the int value\n * @return ReferenceType\n * @throws IllegalArgumentException if the specified value is invalid.\n */\npublic static ReferenceStrength resolve(final int value) {\n    switch(value) {\n        case 0:\n            return HARD;\n        case 1:\n            return SOFT;\n        case 2:\n            return WEAK;\n        default:\n            throw new IllegalArgumentException();\n    }\n}"
            ],
            [
                "resolve",
                "org.apache.commons.collections4.map",
                "ReferenceStrength",
                "/**\n * Resolve enum from int.\n * @param value  the int value\n * @return ReferenceType\n * @throws IllegalArgumentException if the specified value is invalid.\n */\npublic static ReferenceStrength resolve(final int value) {\n    switch(value) {\n        case 0:\n            return HARD;\n        case 1:\n            return SOFT;\n        case 2:\n            return WEAK;\n        default:\n            throw new IllegalArgumentException();\n    }\n}"
            ],
            [
                "multiKeyMap",
                "org.apache.commons.collections4.map",
                "MultiKeyMap",
                "//-----------------------------------------------------------------------\n/**\n * Decorates the specified map to add the MultiKeyMap API and fast query.\n * The map must not be null and must be empty.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, not null\n * @return a new multi key map\n * @throws NullPointerException if map is null\n * @throws IllegalArgumentException if the map is not empty\n * @since 4.0\n */\npublic static <K, V> MultiKeyMap<K, V> multiKeyMap(final AbstractHashedMap<MultiKey<? extends K>, V> map) {\n    if (map == null) {\n        throw new NullPointerException(\"Map must not be null\");\n    }\n    if (map.size() > 0) {\n        throw new IllegalArgumentException(\"Map must be empty\");\n    }\n    return new MultiKeyMap<K, V>(map);\n}"
            ],
            [
                "lazyMap",
                "org.apache.commons.collections4.map",
                "LazyMap",
                "/**\n * Factory method to create a lazily instantiated map.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param factory  the factory to use, must not be null\n * @return a new lazy map\n * @throws NullPointerException if map or factory is null\n * @since 4.0\n */\npublic static <K, V> LazyMap<K, V> lazyMap(final Map<K, V> map, final Factory<? extends V> factory) {\n    return new LazyMap<K, V>(map, factory);\n}"
            ],
            [
                "lazyMap",
                "org.apache.commons.collections4.map",
                "LazyMap",
                "/**\n * Factory method to create a lazily instantiated map.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param factory  the factory to use, must not be null\n * @return a new lazy map\n * @throws NullPointerException if map or factory is null\n * @since 4.0\n */\npublic static <V, K> LazyMap<K, V> lazyMap(final Map<K, V> map, final Transformer<? super K, ? extends V> factory) {\n    return new LazyMap<K, V>(map, factory);\n}"
            ],
            [
                "multiValueMap",
                "org.apache.commons.collections4.map",
                "MultiValueMap",
                "/**\n * Creates a map which wraps the given map and\n * maps keys to ArrayLists.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to wrap\n * @return a new multi-value map\n * @since 4.0\n */\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\npublic static <K, V> MultiValueMap<K, V> multiValueMap(final Map<K, ? super Collection<V>> map) {\n    return MultiValueMap.<K, V, ArrayList>multiValueMap((Map<K, ? super Collection>) map, ArrayList.class);\n}"
            ],
            [
                "multiValueMap",
                "org.apache.commons.collections4.map",
                "MultiValueMap",
                "/**\n * Creates a map which decorates the given <code>map</code> and\n * maps keys to collections of type <code>collectionClass</code>.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param <C>  the collection class type\n * @param map  the map to wrap\n * @param collectionClass  the type of the collection class\n * @return a new multi-value map\n * @since 4.0\n */\npublic static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(final Map<K, ? super C> map, final Class<C> collectionClass) {\n    return new MultiValueMap<K, V>(map, new ReflectionFactory<C>(collectionClass));\n}"
            ],
            [
                "multiValueMap",
                "org.apache.commons.collections4.map",
                "MultiValueMap",
                "/**\n * Creates a map which decorates the given <code>map</code> and\n * creates the value collections using the supplied <code>collectionFactory</code>.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param <C>  the collection class type\n * @param map  the map to decorate\n * @param collectionFactory  the collection factory (must return a Collection object).\n * @return a new multi-value map\n * @since 4.0\n */\npublic static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(final Map<K, ? super C> map, final Factory<C> collectionFactory) {\n    return new MultiValueMap<K, V>(map, collectionFactory);\n}"
            ],
            [
                "transformingMap",
                "org.apache.commons.collections4.map",
                "TransformedMap",
                "/**\n * Factory method to create a transforming map.\n * <p>\n * If there are any elements already in the map being decorated, they\n * are NOT transformed.\n * Contrast this with {@link #transformedMap(Map, Transformer, Transformer)}.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param keyTransformer  the transformer to use for key conversion, null means no transformation\n * @param valueTransformer  the transformer to use for value conversion, null means no transformation\n * @return a new transformed map\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> TransformedMap<K, V> transformingMap(final Map<K, V> map, final Transformer<? super K, ? extends K> keyTransformer, final Transformer<? super V, ? extends V> valueTransformer) {\n    return new TransformedMap<K, V>(map, keyTransformer, valueTransformer);\n}"
            ],
            [
                "transformedMap",
                "org.apache.commons.collections4.map",
                "TransformedMap",
                "/**\n * Factory method to create a transforming map that will transform\n * existing contents of the specified map.\n * <p>\n * If there are any elements already in the map being decorated, they\n * will be transformed by this method.\n * Contrast this with {@link #transformingMap(Map, Transformer, Transformer)}.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param map  the map to decorate, must not be null\n * @param keyTransformer  the transformer to use for key conversion, null means no transformation\n * @param valueTransformer  the transformer to use for value conversion, null means no transformation\n * @return a new transformed map\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <K, V> TransformedMap<K, V> transformedMap(final Map<K, V> map, final Transformer<? super K, ? extends K> keyTransformer, final Transformer<? super V, ? extends V> valueTransformer) {\n    final TransformedMap<K, V> decorated = new TransformedMap<K, V>(map, keyTransformer, valueTransformer);\n    if (map.size() > 0) {\n        final Map<K, V> transformed = decorated.transformMap(map);\n        decorated.clear();\n        // avoids double transformation\n        decorated.decorated().putAll(transformed);\n    }\n    return decorated;\n}"
            ],
            [
                "synchronizedMultiSet",
                "org.apache.commons.collections4",
                "MultiSetUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns a synchronized (thread-safe) multiset backed by the given multiset.\n * In order to guarantee serial access, it is critical that all access to the\n * backing multiset is accomplished through the returned multiset.\n * <p>\n * It is imperative that the user manually synchronize on the returned multiset\n * when iterating over it:\n *\n * <pre>\n * MultiSet multiset = MultiSetUtils.synchronizedMultiSet(new HashMultiSet());\n * ...\n * synchronized(multiset) {\n *     Iterator i = multiset.iterator(); // Must be in synchronized block\n *     while (i.hasNext())\n *         foo(i.next());\n *     }\n * }\n * </pre>\n *\n * Failure to follow this advice may result in non-deterministic behavior.\n *\n * @param <E> the element type\n * @param multiset the multiset to synchronize, must not be null\n * @return a synchronized multiset backed by that multiset\n * @throws NullPointerException if the MultiSet is null\n */\npublic static <E> MultiSet<E> synchronizedMultiSet(final MultiSet<E> multiset) {\n    return SynchronizedMultiSet.synchronizedMultiSet(multiset);\n}"
            ],
            [
                "unmodifiableMultiSet",
                "org.apache.commons.collections4",
                "MultiSetUtils",
                "/**\n * Returns an unmodifiable view of the given multiset. Any modification attempts\n * to the returned multiset will raise an {@link UnsupportedOperationException}.\n *\n * @param <E> the element type\n * @param multiset the multiset whose unmodifiable view is to be returned, must not be null\n * @return an unmodifiable view of that multiset\n * @throws NullPointerException if the MultiSet is null\n */\npublic static <E> MultiSet<E> unmodifiableMultiSet(final MultiSet<? extends E> multiset) {\n    return UnmodifiableMultiSet.unmodifiableMultiSet(multiset);\n}"
            ],
            [
                "predicatedMultiSet",
                "org.apache.commons.collections4",
                "MultiSetUtils",
                "/**\n * Returns a predicated (validating) multiset backed by the given multiset.\n * <p>\n * Only objects that pass the test in the given predicate can be added to\n * the multiset. Trying to add an invalid object results in an\n * IllegalArgumentException. It is important not to use the original multiset\n * after invoking this method, as it is a backdoor for adding invalid\n * objects.\n *\n * @param <E> the element type\n * @param multiset the multiset to predicate, must not be null\n * @param predicate the predicate for the multiset, must not be null\n * @return a predicated multiset backed by the given multiset\n * @throws NullPointerException if the MultiSet or Predicate is null\n */\npublic static <E> MultiSet<E> predicatedMultiSet(final MultiSet<E> multiset, final Predicate<? super E> predicate) {\n    return PredicatedMultiSet.predicatedMultiSet(multiset, predicate);\n}"
            ],
            [
                "emptyMultiSet",
                "org.apache.commons.collections4",
                "MultiSetUtils",
                "/**\n * Get an empty <code>MultiSet</code>.\n *\n * @param <E> the element type\n * @return an empty MultiSet\n */\n// OK, empty multiset is compatible with any type\n@SuppressWarnings(\"unchecked\")\npublic static <E> MultiSet<E> emptyMultiSet() {\n    return EMPTY_MULTISET;\n}"
            ],
            [
                "unmodifiableMultiValuedMap",
                "org.apache.commons.collections4.multimap",
                "UnmodifiableMultiValuedMap",
                "/**\n * Factory method to create an unmodifiable MultiValuedMap.\n * <p>\n * If the map passed in is already unmodifiable, it is returned.\n *\n * @param <K> the type of key elements\n * @param <V> the type of value elements\n * @param map  the map to decorate, may not be null\n * @return an unmodifiable MultiValuedMap\n * @throws NullPointerException if map is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <K, V> UnmodifiableMultiValuedMap<K, V> unmodifiableMultiValuedMap(MultiValuedMap<? extends K, ? extends V> map) {\n    if (map instanceof Unmodifiable) {\n        return (UnmodifiableMultiValuedMap<K, V>) map;\n    }\n    return new UnmodifiableMultiValuedMap<K, V>(map);\n}"
            ],
            [
                "transformingMap",
                "org.apache.commons.collections4.multimap",
                "TransformedMultiValuedMap",
                "/**\n * Factory method to create a transforming MultiValuedMap.\n * <p>\n * If there are any elements already in the map being decorated, they are\n * NOT transformed. Contrast this with\n * {@link #transformedMap(MultiValuedMap, Transformer, Transformer)}.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the MultiValuedMap to decorate, may not be null\n * @param keyTransformer  the transformer to use for key conversion, null means no conversion\n * @param valueTransformer  the transformer to use for value conversion, null means no conversion\n * @return a new transformed MultiValuedMap\n * @throws NullPointerException if map is null\n */\npublic static <K, V> TransformedMultiValuedMap<K, V> transformingMap(final MultiValuedMap<K, V> map, final Transformer<? super K, ? extends K> keyTransformer, final Transformer<? super V, ? extends V> valueTransformer) {\n    return new TransformedMultiValuedMap<K, V>(map, keyTransformer, valueTransformer);\n}"
            ],
            [
                "transformedMap",
                "org.apache.commons.collections4.multimap",
                "TransformedMultiValuedMap",
                "/**\n * Factory method to create a transforming MultiValuedMap that will\n * transform existing contents of the specified map.\n * <p>\n * If there are any elements already in the map being decorated, they will\n * be transformed by this method. Contrast this with\n * {@link #transformingMap(MultiValuedMap, Transformer, Transformer)}.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param map  the MultiValuedMap to decorate, may not be null\n * @param keyTransformer  the transformer to use for key conversion, null means no conversion\n * @param valueTransformer  the transformer to use for value conversion, null means no conversion\n * @return a new transformed MultiValuedMap\n * @throws NullPointerException if map is null\n */\npublic static <K, V> TransformedMultiValuedMap<K, V> transformedMap(final MultiValuedMap<K, V> map, final Transformer<? super K, ? extends K> keyTransformer, final Transformer<? super V, ? extends V> valueTransformer) {\n    final TransformedMultiValuedMap<K, V> decorated = new TransformedMultiValuedMap<K, V>(map, keyTransformer, valueTransformer);\n    if (!map.isEmpty()) {\n        final MultiValuedMap<K, V> mapCopy = new ArrayListValuedHashMap<K, V>(map);\n        decorated.clear();\n        decorated.putAll(mapCopy);\n    }\n    return decorated;\n}"
            ],
            [
                "lazyList",
                "org.apache.commons.collections4.list",
                "LazyList",
                "/**\n * Factory method to create a lazily instantiating list.\n *\n * @param <E> the type of the elements in the list\n * @param list  the list to decorate, must not be null\n * @param factory  the factory to use for creation, must not be null\n * @return a new lazy list\n * @throws NullPointerException if list or factory is null\n * @since 4.0\n */\npublic static <E> LazyList<E> lazyList(final List<E> list, final Factory<? extends E> factory) {\n    return new LazyList<E>(list, factory);\n}"
            ],
            [
                "setUniqueList",
                "org.apache.commons.collections4.list",
                "SetUniqueList",
                "/**\n * Factory method to create a SetList using the supplied list to retain order.\n * <p>\n * If the list contains duplicates, these are removed (first indexed one\n * kept). A <code>HashSet</code> is used for the set behaviour.\n *\n * @param <E>  the element type\n * @param list  the list to decorate, must not be null\n * @return a new {@link SetUniqueList}\n * @throws NullPointerException if list is null\n * @since 4.0\n */\npublic static <E> SetUniqueList<E> setUniqueList(final List<E> list) {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) {\n        return new SetUniqueList<E>(list, new HashSet<E>());\n    }\n    final List<E> temp = new ArrayList<E>(list);\n    list.clear();\n    final SetUniqueList<E> sl = new SetUniqueList<E>(list, new HashSet<E>());\n    sl.addAll(temp);\n    return sl;\n}"
            ],
            [
                "unmodifiableList",
                "org.apache.commons.collections4.list",
                "UnmodifiableList",
                "/**\n * Factory method to create an unmodifiable list.\n *\n * @param <E> the type of the elements in the list\n * @param list  the list to decorate, must not be null\n * @return a new unmodifiable list\n * @throws NullPointerException if list is null\n * @since 4.0\n */\npublic static <E> List<E> unmodifiableList(final List<? extends E> list) {\n    if (list instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final List<E> tmpList = (List<E>) list;\n        return tmpList;\n    }\n    return new UnmodifiableList<E>(list);\n}"
            ],
            [
                "fixedSizeList",
                "org.apache.commons.collections4.list",
                "FixedSizeList",
                "/**\n * Factory method to create a fixed size list.\n *\n * @param <E> the type of the elements in the list\n * @param list  the list to decorate, must not be null\n * @return a new fixed size list\n * @throws NullPointerException if list is null\n * @since 4.0\n */\npublic static <E> FixedSizeList<E> fixedSizeList(final List<E> list) {\n    return new FixedSizeList<E>(list);\n}"
            ],
            [
                "transformingList",
                "org.apache.commons.collections4.list",
                "TransformedList",
                "/**\n * Factory method to create a transforming list.\n * <p>\n * If there are any elements already in the list being decorated, they\n * are NOT transformed.\n * Contrast this with {@link #transformedList(List, Transformer)}.\n *\n * @param <E> the type of the elements in the list\n * @param list  the list to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed list\n * @throws NullPointerException if list or transformer is null\n * @since 4.0\n */\npublic static <E> TransformedList<E> transformingList(final List<E> list, final Transformer<? super E, ? extends E> transformer) {\n    return new TransformedList<E>(list, transformer);\n}"
            ],
            [
                "transformedList",
                "org.apache.commons.collections4.list",
                "TransformedList",
                "/**\n * Factory method to create a transforming list that will transform\n * existing contents of the specified list.\n * <p>\n * If there are any elements already in the list being decorated, they\n * will be transformed by this method.\n * Contrast this with {@link #transformingList(List, Transformer)}.\n *\n * @param <E> the type of the elements in the list\n * @param list  the list to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed List\n * @throws NullPointerException if list or transformer is null\n * @since 4.0\n */\npublic static <E> TransformedList<E> transformedList(final List<E> list, final Transformer<? super E, ? extends E> transformer) {\n    final TransformedList<E> decorated = new TransformedList<E>(list, transformer);\n    if (list.size() > 0) {\n        // list is of type E\n        @SuppressWarnings(\"unchecked\")\n        final E[] // NOPMD - false positive for generics\n        values = (E[]) list.toArray();\n        list.clear();\n        for (final E value : values) {\n            decorated.decorated().add(transformer.transform(value));\n        }\n    }\n    return decorated;\n}"
            ],
            [
                "growthList",
                "org.apache.commons.collections4.list",
                "GrowthList",
                "/**\n * Factory method to create a growth list.\n *\n * @param <E> the type of the elements in the list\n * @param list  the list to decorate, must not be null\n * @return a new growth list\n * @throws NullPointerException if list is null\n * @since 4.0\n */\npublic static <E> GrowthList<E> growthList(final List<E> list) {\n    return new GrowthList<E>(list);\n}"
            ],
            [
                "predicatedList",
                "org.apache.commons.collections4.list",
                "PredicatedList",
                "/**\n * Factory method to create a predicated (validating) list.\n * <p>\n * If there are any elements already in the list being decorated, they\n * are validated.\n *\n * @param <T> the type of the elements in the list\n * @param list  the list to decorate, must not be null\n * @param predicate  the predicate to use for validation, must not be null\n * @return a new predicated list\n * @throws NullPointerException if list or predicate is null\n * @throws IllegalArgumentException if the list contains invalid elements\n * @since 4.0\n */\npublic static <T> PredicatedList<T> predicatedList(final List<T> list, final Predicate<? super T> predicate) {\n    return new PredicatedList<T>(list, predicate);\n}"
            ],
            [
                "transformingQueue",
                "org.apache.commons.collections4.queue",
                "TransformedQueue",
                "/**\n * Factory method to create a transforming queue.\n * <p>\n * If there are any elements already in the queue being decorated, they\n * are NOT transformed.\n * Contrast this with {@link #transformedQueue(Queue, Transformer)}.\n *\n * @param <E> the type of the elements in the queue\n * @param queue  the queue to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed Queue\n * @throws NullPointerException if queue or transformer is null\n */\npublic static <E> TransformedQueue<E> transformingQueue(final Queue<E> queue, final Transformer<? super E, ? extends E> transformer) {\n    return new TransformedQueue<E>(queue, transformer);\n}"
            ],
            [
                "transformedQueue",
                "org.apache.commons.collections4.queue",
                "TransformedQueue",
                "/**\n * Factory method to create a transforming queue that will transform\n * existing contents of the specified queue.\n * <p>\n * If there are any elements already in the queue being decorated, they\n * will be transformed by this method.\n * Contrast this with {@link #transformingQueue(Queue, Transformer)}.\n *\n * @param <E> the type of the elements in the queue\n * @param queue  the queue to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed Queue\n * @throws NullPointerException if queue or transformer is null\n * @since 4.0\n */\npublic static <E> TransformedQueue<E> transformedQueue(final Queue<E> queue, final Transformer<? super E, ? extends E> transformer) {\n    // throws IAE if queue or transformer is null\n    final TransformedQueue<E> decorated = new TransformedQueue<E>(queue, transformer);\n    if (queue.size() > 0) {\n        // queue is type <E>\n        @SuppressWarnings(\"unchecked\")\n        final E[] // NOPMD - false positive for generics\n        values = (E[]) queue.toArray();\n        queue.clear();\n        for (final E value : values) {\n            decorated.decorated().add(transformer.transform(value));\n        }\n    }\n    return decorated;\n}"
            ],
            [
                "unmodifiableQueue",
                "org.apache.commons.collections4.queue",
                "UnmodifiableQueue",
                "/**\n * Factory method to create an unmodifiable queue.\n * <p>\n * If the queue passed in is already unmodifiable, it is returned.\n *\n * @param <E> the type of the elements in the queue\n * @param queue  the queue to decorate, must not be null\n * @return an unmodifiable Queue\n * @throws NullPointerException if queue is null\n */\npublic static <E> Queue<E> unmodifiableQueue(final Queue<? extends E> queue) {\n    if (queue instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final Queue<E> tmpQueue = (Queue<E>) queue;\n        return tmpQueue;\n    }\n    return new UnmodifiableQueue<E>(queue);\n}"
            ],
            [
                "predicatedQueue",
                "org.apache.commons.collections4.queue",
                "PredicatedQueue",
                "/**\n * Factory method to create a predicated (validating) queue.\n * <p>\n * If there are any elements already in the queue being decorated, they\n * are validated.\n *\n * @param <E> the type of the elements in the queue\n * @param Queue  the queue to decorate, must not be null\n * @param predicate  the predicate to use for validation, must not be null\n * @return a new predicated queue\n * @throws NullPointerException if queue or predicate is null\n * @throws IllegalArgumentException if the queue contains invalid elements\n */\npublic static <E> PredicatedQueue<E> predicatedQueue(final Queue<E> Queue, final Predicate<? super E> predicate) {\n    return new PredicatedQueue<E>(Queue, predicate);\n}"
            ],
            [
                "empty",
                "org.apache.commons.collections4",
                "FluentIterable",
                "// Static factory methods\n// ----------------------------------------------------------------------\n/**\n * Creates a new empty FluentIterable.\n *\n * @param <T>  the element type\n * @return a new empty FluentIterable\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> FluentIterable<T> empty() {\n    return IterableUtils.EMPTY_ITERABLE;\n}"
            ],
            [
                "of",
                "org.apache.commons.collections4",
                "FluentIterable",
                "/**\n * Creates a new FluentIterable of the single provided element.\n * <p>\n * The returned iterable's iterator does not support {@code remove()}.\n *\n * @param <T>  the element type\n * @param singleton  the singleton element\n * @return a new FluentIterable containing the singleton\n */\npublic static <T> FluentIterable<T> of(final T singleton) {\n    return of(IteratorUtils.asIterable(new SingletonIterator<T>(singleton, false)));\n}"
            ],
            [
                "of",
                "org.apache.commons.collections4",
                "FluentIterable",
                "/**\n * Creates a new FluentIterable from the provided elements.\n * <p>\n * The returned iterable's iterator does not support {@code remove()}.\n *\n * @param <T>  the element type\n * @param elements  the elements to be contained in the FluentIterable\n * @return a new FluentIterable containing the provided elements\n */\npublic static <T> FluentIterable<T> of(final T... elements) {\n    return of(Arrays.asList(elements));\n}"
            ],
            [
                "of",
                "org.apache.commons.collections4",
                "FluentIterable",
                "/**\n * Construct a new FluentIterable from the provided iterable. If the\n * iterable is already an instance of FluentIterable, the instance\n * will be returned instead.\n * <p>\n * The returned iterable's iterator supports {@code remove()} when the\n * corresponding input iterator supports it.\n *\n * @param <T>  the element type\n * @param iterable  the iterable to wrap into a FluentIterable, may not be null\n * @return a new FluentIterable wrapping the provided iterable\n * @throws NullPointerException if iterable is null\n */\npublic static <T> FluentIterable<T> of(final Iterable<T> iterable) {\n    IterableUtils.checkNotNull(iterable);\n    if (iterable instanceof FluentIterable<?>) {\n        return (FluentIterable<T>) iterable;\n    } else {\n        return new FluentIterable<T>(iterable);\n    }\n}"
            ],
            [
                "exceptionTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Gets a transformer that always throws an exception.\n * This could be useful during testing as a placeholder.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @return the transformer\n * @see ExceptionTransformer\n */\npublic static <I, O> Transformer<I, O> exceptionTransformer() {\n    return ExceptionTransformer.exceptionTransformer();\n}"
            ],
            [
                "nullTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Gets a transformer that always returns null.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @return the transformer\n * @see ConstantTransformer\n */\npublic static <I, O> Transformer<I, O> nullTransformer() {\n    return ConstantTransformer.nullTransformer();\n}"
            ],
            [
                "nopTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Gets a transformer that returns the input object.\n * The input object should be immutable to maintain the\n * contract of Transformer (although this is not checked).\n *\n * @param <T>  the input/output type\n * @return the transformer\n * @see NOPTransformer\n */\npublic static <T> Transformer<T, T> nopTransformer() {\n    return NOPTransformer.nopTransformer();\n}"
            ],
            [
                "cloneTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Gets a transformer that returns a clone of the input object.\n * The input object will be cloned using one of these techniques (in order):\n * <ul>\n * <li>public clone method\n * <li>public copy constructor\n * <li>serialization clone\n * <ul>\n *\n * @param <T>  the input/output type\n * @return the transformer\n * @see CloneTransformer\n */\npublic static <T> Transformer<T, T> cloneTransformer() {\n    return CloneTransformer.cloneTransformer();\n}"
            ],
            [
                "constantTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Creates a Transformer that will return the same object each time the\n * transformer is used.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param constantToReturn  the constant object to return each time in the transformer\n * @return the transformer.\n * @see ConstantTransformer\n */\npublic static <I, O> Transformer<I, O> constantTransformer(final O constantToReturn) {\n    return ConstantTransformer.constantTransformer(constantToReturn);\n}"
            ],
            [
                "asTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Creates a Transformer that calls a Closure each time the transformer is used.\n * The transformer returns the input object.\n *\n * @param <T>  the input/output type\n * @param closure  the closure to run each time in the transformer, not null\n * @return the transformer\n * @throws NullPointerException if the closure is null\n * @see ClosureTransformer\n */\npublic static <T> Transformer<T, T> asTransformer(final Closure<? super T> closure) {\n    return ClosureTransformer.closureTransformer(closure);\n}"
            ],
            [
                "asTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Creates a Transformer that calls a Predicate each time the transformer is used.\n * The transformer will return either Boolean.TRUE or Boolean.FALSE.\n *\n * @param <T>  the input type\n * @param predicate  the predicate to run each time in the transformer, not null\n * @return the transformer\n * @throws NullPointerException if the predicate is null\n * @see PredicateTransformer\n */\npublic static <T> Transformer<T, Boolean> asTransformer(final Predicate<? super T> predicate) {\n    return PredicateTransformer.predicateTransformer(predicate);\n}"
            ],
            [
                "asTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Creates a Transformer that calls a Factory each time the transformer is used.\n * The transformer will return the value returned by the factory.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param factory  the factory to run each time in the transformer, not null\n * @return the transformer\n * @throws NullPointerException if the factory is null\n * @see FactoryTransformer\n */\npublic static <I, O> Transformer<I, O> asTransformer(final Factory<? extends O> factory) {\n    return FactoryTransformer.factoryTransformer(factory);\n}"
            ],
            [
                "chainedTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Create a new Transformer that calls each transformer in turn, passing the\n * result into the next transformer.\n *\n * @param <T>  the input/output type\n * @param transformers  an array of transformers to chain\n * @return the transformer\n * @throws NullPointerException if the transformers array or any of the transformers is null\n * @see ChainedTransformer\n */\npublic static <T> Transformer<T, T> chainedTransformer(final Transformer<? super T, ? extends T>... transformers) {\n    return ChainedTransformer.chainedTransformer(transformers);\n}"
            ],
            [
                "chainedTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Create a new Transformer that calls each transformer in turn, passing the\n * result into the next transformer. The ordering is that of the iterator()\n * method on the collection.\n *\n * @param <T>  the input/output type\n * @param transformers  a collection of transformers to chain\n * @return the transformer\n * @throws NullPointerException if the transformers collection or any of the transformers is null\n * @see ChainedTransformer\n */\npublic static <T> Transformer<T, T> chainedTransformer(final Collection<? extends Transformer<? super T, ? extends T>> transformers) {\n    return ChainedTransformer.chainedTransformer(transformers);\n}"
            ],
            [
                "ifTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Create a new Transformer that calls the transformer if the predicate is true,\n * otherwise the input object is returned unchanged.\n *\n * @param <T>  the input / output type\n * @param predicate  the predicate to switch on\n * @param trueTransformer  the transformer called if the predicate is true\n * @return the transformer\n * @throws NullPointerException if either the predicate or transformer is null\n * @see IfTransformer\n * @since 4.1\n */\npublic static <T> Transformer<T, T> ifTransformer(final Predicate<? super T> predicate, final Transformer<? super T, ? extends T> trueTransformer) {\n    return IfTransformer.ifTransformer(predicate, trueTransformer);\n}"
            ],
            [
                "ifTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Create a new Transformer that calls one of two transformers depending\n * on the specified predicate.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param predicate  the predicate to switch on\n * @param trueTransformer  the transformer called if the predicate is true\n * @param falseTransformer  the transformer called if the predicate is false\n * @return the transformer\n * @throws NullPointerException if either the predicate or transformer is null\n * @see IfTransformer\n * @since 4.1\n */\npublic static <I, O> Transformer<I, O> ifTransformer(final Predicate<? super I> predicate, final Transformer<? super I, ? extends O> trueTransformer, final Transformer<? super I, ? extends O> falseTransformer) {\n    return IfTransformer.ifTransformer(predicate, trueTransformer, falseTransformer);\n}"
            ],
            [
                "switchTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Create a new Transformer that calls one of two transformers depending\n * on the specified predicate.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param predicate  the predicate to switch on\n * @param trueTransformer  the transformer called if the predicate is true\n * @param falseTransformer  the transformer called if the predicate is false\n * @return the transformer\n * @throws NullPointerException if either the predicate or transformer is null\n * @see SwitchTransformer\n * @deprecated as of 4.1, use {@link #ifTransformer(Predicate, Transformer, Transformer))\n */\n@SuppressWarnings(\"unchecked\")\n@Deprecated\npublic static <I, O> Transformer<I, O> switchTransformer(final Predicate<? super I> predicate, final Transformer<? super I, ? extends O> trueTransformer, final Transformer<? super I, ? extends O> falseTransformer) {\n    return SwitchTransformer.switchTransformer(new Predicate[] { predicate }, new Transformer[] { trueTransformer }, falseTransformer);\n}"
            ],
            [
                "switchTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Create a new Transformer that calls one of the transformers depending\n * on the predicates. The transformer at array location 0 is called if the\n * predicate at array location 0 returned true. Each predicate is evaluated\n * until one returns true. If no predicates evaluate to true, null is returned.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param predicates  an array of predicates to check\n * @param transformers  an array of transformers to call\n * @return the transformer\n * @throws NullPointerException if the either array is null\n * @throws NullPointerException if any element in the arrays is null\n * @throws IllegalArgumentException if the arrays have different sizes\n * @see SwitchTransformer\n */\npublic static <I, O> Transformer<I, O> switchTransformer(final Predicate<? super I>[] predicates, final Transformer<? super I, ? extends O>[] transformers) {\n    return SwitchTransformer.switchTransformer(predicates, transformers, null);\n}"
            ],
            [
                "switchTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Create a new Transformer that calls one of the transformers depending\n * on the predicates. The transformer at array location 0 is called if the\n * predicate at array location 0 returned true. Each predicate is evaluated\n * until one returns true. If no predicates evaluate to true, the default\n * transformer is called. If the default transformer is null, null is returned.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param predicates  an array of predicates to check\n * @param transformers  an array of transformers to call\n * @param defaultTransformer  the default to call if no predicate matches, null means return null\n * @return the transformer\n * @throws NullPointerException if the either array is null\n * @throws NullPointerException if any element in the arrays is null\n * @throws IllegalArgumentException if the arrays have different sizes\n * @see SwitchTransformer\n */\npublic static <I, O> Transformer<I, O> switchTransformer(final Predicate<? super I>[] predicates, final Transformer<? super I, ? extends O>[] transformers, final Transformer<? super I, ? extends O> defaultTransformer) {\n    return SwitchTransformer.switchTransformer(predicates, transformers, defaultTransformer);\n}"
            ],
            [
                "switchTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Create a new Transformer that calls one of the transformers depending\n * on the predicates.\n * <p>\n * The Map consists of Predicate keys and Transformer values. A transformer\n * is called if its matching predicate returns true. Each predicate is evaluated\n * until one returns true. If no predicates evaluate to true, the default\n * transformer is called. The default transformer is set in the map with a\n * null key. If no default transformer is set, null will be returned in a default\n * case. The ordering is that of the iterator() method on the entryset collection\n * of the map.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param predicatesAndTransformers  a map of predicates to transformers\n * @return the transformer\n * @throws NullPointerException if the map is null\n * @throws NullPointerException if any transformer in the map is null\n * @throws ClassCastException  if the map elements are of the wrong type\n * @see SwitchTransformer\n */\npublic static <I, O> Transformer<I, O> switchTransformer(final Map<Predicate<I>, Transformer<I, O>> predicatesAndTransformers) {\n    return SwitchTransformer.switchTransformer(predicatesAndTransformers);\n}"
            ],
            [
                "switchMapTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Create a new Transformer that uses the input object as a key to find the\n * transformer to call.\n * <p>\n * The Map consists of object keys and Transformer values. A transformer\n * is called if the input object equals the key. If there is no match, the\n * default transformer is called. The default transformer is set in the map\n * using a null key. If no default is set, null will be returned in a default case.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param objectsAndTransformers  a map of objects to transformers\n * @return the transformer\n * @throws NullPointerException if the map is null\n * @throws NullPointerException if any transformer in the map is null\n * @see SwitchTransformer\n */\n@SuppressWarnings(\"unchecked\")\npublic static <I, O> Transformer<I, O> switchMapTransformer(final Map<I, Transformer<I, O>> objectsAndTransformers) {\n    if (objectsAndTransformers == null) {\n        throw new NullPointerException(\"The object and transformer map must not be null\");\n    }\n    final Transformer<? super I, ? extends O> def = objectsAndTransformers.remove(null);\n    final int size = objectsAndTransformers.size();\n    final Transformer<? super I, ? extends O>[] trs = new Transformer[size];\n    final Predicate<I>[] preds = new Predicate[size];\n    int i = 0;\n    for (final Map.Entry<I, Transformer<I, O>> entry : objectsAndTransformers.entrySet()) {\n        preds[i] = EqualPredicate.<I>equalPredicate(entry.getKey());\n        trs[i++] = entry.getValue();\n    }\n    return TransformerUtils.switchTransformer(preds, trs, def);\n}"
            ],
            [
                "instantiateTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Gets a Transformer that expects an input Class object that it will instantiate.\n *\n * @param <T>  the output type\n * @return the transformer\n * @see InstantiateTransformer\n */\npublic static <T> Transformer<Class<? extends T>, T> instantiateTransformer() {\n    return InstantiateTransformer.instantiateTransformer();\n}"
            ],
            [
                "instantiateTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Creates a Transformer that expects an input Class object that it will\n * instantiate. The constructor used is determined by the arguments specified\n * to this method.\n *\n * @param <T>  the output type\n * @param paramTypes  parameter types for the constructor, can be null\n * @param args  the arguments to pass to the constructor, can be null\n * @return the transformer\n * @throws IllegalArgumentException if the paramTypes and args don't match\n * @see InstantiateTransformer\n */\npublic static <T> Transformer<Class<? extends T>, T> instantiateTransformer(final Class<?>[] paramTypes, final Object[] args) {\n    return InstantiateTransformer.instantiateTransformer(paramTypes, args);\n}"
            ],
            [
                "mapTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Creates a Transformer that uses the passed in Map to transform the input\n * object (as a simple lookup).\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param map  the map to use to transform the objects\n * @return the transformer, or {@link ConstantTransformer#nullTransformer()} if the\n *   {@code map} is {@code null}\n * @see MapTransformer\n */\npublic static <I, O> Transformer<I, O> mapTransformer(final Map<? super I, ? extends O> map) {\n    return MapTransformer.mapTransformer(map);\n}"
            ],
            [
                "invokerTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Gets a Transformer that invokes a method on the input object.\n * The method must have no parameters. If the input object is null,\n * null is returned.\n * <p>\n * For example, <code>TransformerUtils.invokerTransformer(\"getName\");</code>\n * will call the <code>getName/code> method on the input object to\n * determine the transformer result.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param methodName  the method name to call on the input object, may not be null\n * @return the transformer\n * @throws NullPointerException if the methodName is null.\n * @see InvokerTransformer\n */\npublic static <I, O> Transformer<I, O> invokerTransformer(final String methodName) {\n    return InvokerTransformer.invokerTransformer(methodName, null, null);\n}"
            ],
            [
                "invokerTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Gets a Transformer that invokes a method on the input object.\n * The method parameters are specified. If the input object is {@code null},\n * {@code null} is returned.\n *\n * @param <I>  the input type\n * @param <O>  the output type\n * @param methodName  the name of the method\n * @param paramTypes  the parameter types\n * @param args  the arguments\n * @return the transformer\n * @throws NullPointerException if the method name is null\n * @throws IllegalArgumentException if the paramTypes and args don't match\n * @see InvokerTransformer\n */\npublic static <I, O> Transformer<I, O> invokerTransformer(final String methodName, final Class<?>[] paramTypes, final Object[] args) {\n    return InvokerTransformer.invokerTransformer(methodName, paramTypes, args);\n}"
            ],
            [
                "stringValueTransformer",
                "org.apache.commons.collections4",
                "TransformerUtils",
                "/**\n * Gets a transformer that returns a <code>java.lang.String</code>\n * representation of the input object. This is achieved via the\n * <code>toString</code> method, <code>null</code> returns 'null'.\n *\n * @param <T>  the input type\n * @return the transformer\n * @see StringValueTransformer\n */\npublic static <T> Transformer<T, String> stringValueTransformer() {\n    return StringValueTransformer.stringValueTransformer();\n}"
            ],
            [
                "exceptionPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "// Simple predicates\n//-----------------------------------------------------------------------------\n/**\n * Gets a Predicate that always throws an exception.\n * This could be useful during testing as a placeholder.\n *\n * @param <T>  the type that the predicate queries\n * @return the predicate\n * @see ExceptionPredicate\n */\npublic static <T> Predicate<T> exceptionPredicate() {\n    return ExceptionPredicate.exceptionPredicate();\n}"
            ],
            [
                "truePredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Gets a Predicate that always returns true.\n *\n * @param <T>  the type that the predicate queries\n * @return the predicate\n * @see TruePredicate\n */\npublic static <T> Predicate<T> truePredicate() {\n    return TruePredicate.truePredicate();\n}"
            ],
            [
                "falsePredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Gets a Predicate that always returns false.\n *\n * @param <T>  the type that the predicate queries\n * @return the predicate\n * @see FalsePredicate\n */\npublic static <T> Predicate<T> falsePredicate() {\n    return FalsePredicate.falsePredicate();\n}"
            ],
            [
                "nullPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Gets a Predicate that checks if the input object passed in is null.\n *\n * @param <T>  the type that the predicate queries\n * @return the predicate\n * @see NullPredicate\n */\npublic static <T> Predicate<T> nullPredicate() {\n    return NullPredicate.nullPredicate();\n}"
            ],
            [
                "notNullPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Gets a Predicate that checks if the input object passed in is not null.\n *\n * @param <T>  the type that the predicate queries\n * @return the predicate\n * @see NotNullPredicate\n */\npublic static <T> Predicate<T> notNullPredicate() {\n    return NotNullPredicate.notNullPredicate();\n}"
            ],
            [
                "equalPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Creates a Predicate that checks if the input object is equal to the\n * specified object using equals().\n *\n * @param <T>  the type that the predicate queries\n * @param value  the value to compare against\n * @return the predicate\n * @see EqualPredicate\n */\npublic static <T> Predicate<T> equalPredicate(final T value) {\n    return EqualPredicate.equalPredicate(value);\n}"
            ],
            [
                "identityPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Creates a Predicate that checks if the input object is equal to the\n * specified object by identity.\n *\n * @param <T>  the type that the predicate queries\n * @param value  the value to compare against\n * @return the predicate\n * @see IdentityPredicate\n */\npublic static <T> Predicate<T> identityPredicate(final T value) {\n    return IdentityPredicate.identityPredicate(value);\n}"
            ],
            [
                "instanceofPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Creates a Predicate that checks if the object passed in is of\n * a particular type, using instanceof. A <code>null</code> input\n * object will return <code>false</code>.\n *\n * @param type  the type to check for, may not be null\n * @return the predicate\n * @throws NullPointerException if the class is null\n * @see InstanceofPredicate\n */\npublic static Predicate<Object> instanceofPredicate(final Class<?> type) {\n    return InstanceofPredicate.instanceOfPredicate(type);\n}"
            ],
            [
                "uniquePredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Creates a Predicate that returns true the first time an object is\n * encountered, and false if the same object is received\n * again. The comparison is by equals(). A <code>null</code> input object\n * is accepted and will return true the first time, and false subsequently\n * as well.\n *\n * @param <T>  the type that the predicate queries\n * @return the predicate\n * @see UniquePredicate\n */\npublic static <T> Predicate<T> uniquePredicate() {\n    // must return new instance each time\n    return UniquePredicate.uniquePredicate();\n}"
            ],
            [
                "invokerPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Creates a Predicate that invokes a method on the input object.\n * The method must return either a boolean or a non-null Boolean,\n * and have no parameters. If the input object is null, a\n * PredicateException is thrown.\n * <p>\n * For example, <code>PredicateUtils.invokerPredicate(\"isEmpty\");</code>\n * will call the <code>isEmpty</code> method on the input object to\n * determine the predicate result.\n *\n * @param <T>  the type that the predicate queries\n * @param methodName  the method name to call on the input object, may not be null\n * @return the predicate\n * @throws NullPointerException if the methodName is null.\n * @see InvokerTransformer\n * @see TransformerPredicate\n */\npublic static <T> Predicate<T> invokerPredicate(final String methodName) {\n    // reuse transformer as it has caching - this is lazy really, should have inner class here\n    return asPredicate(InvokerTransformer.<Object, Boolean>invokerTransformer(methodName));\n}"
            ],
            [
                "invokerPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Creates a Predicate that invokes a method on the input object.\n * The method must return either a boolean or a non-null Boolean,\n * and have no parameters. If the input object is null, a\n * PredicateException is thrown.\n * <p>\n * For example, <code>PredicateUtils.invokerPredicate(\"isEmpty\");</code>\n * will call the <code>isEmpty</code> method on the input object to\n * determine the predicate result.\n *\n * @param <T>  the type that the predicate queries\n * @param methodName  the method name to call on the input object, may not be null\n * @param paramTypes  the parameter types\n * @param args  the arguments\n * @return the predicate\n * @throws NullPointerException if the method name is null\n * @throws IllegalArgumentException if the paramTypes and args don't match\n * @see InvokerTransformer\n * @see TransformerPredicate\n */\npublic static <T> Predicate<T> invokerPredicate(final String methodName, final Class<?>[] paramTypes, final Object[] args) {\n    // reuse transformer as it has caching - this is lazy really, should have inner class here\n    return asPredicate(InvokerTransformer.<Object, Boolean>invokerTransformer(methodName, paramTypes, args));\n}"
            ],
            [
                "andPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "// Boolean combinations\n//-----------------------------------------------------------------------------\n/**\n * Create a new Predicate that returns true only if both of the specified\n * predicates are true.\n *\n * @param <T>  the type that the predicate queries\n * @param predicate1  the first predicate, may not be null\n * @param predicate2  the second predicate, may not be null\n * @return the <code>and</code> predicate\n * @throws NullPointerException if either predicate is null\n * @see AndPredicate\n */\npublic static <T> Predicate<T> andPredicate(final Predicate<? super T> predicate1, final Predicate<? super T> predicate2) {\n    return AndPredicate.andPredicate(predicate1, predicate2);\n}"
            ],
            [
                "allPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true only if all of the specified\n * predicates are true.\n * If the array of predicates is empty, then this predicate returns true.\n *\n * @param <T>  the type that the predicate queries\n * @param predicates  an array of predicates to check, may not be null\n * @return the <code>all</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n * @see AllPredicate\n */\npublic static <T> Predicate<T> allPredicate(final Predicate<? super T>... predicates) {\n    return AllPredicate.allPredicate(predicates);\n}"
            ],
            [
                "allPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true only if all of the specified\n * predicates are true. The predicates are checked in iterator order.\n * If the collection of predicates is empty, then this predicate returns true.\n *\n * @param <T>  the type that the predicate queries\n * @param predicates  a collection of predicates to check, may not be null\n * @return the <code>all</code> predicate\n * @throws NullPointerException if the predicates collection is null\n * @throws NullPointerException if any predicate in the collection is null\n * @see AllPredicate\n */\npublic static <T> Predicate<T> allPredicate(final Collection<? extends Predicate<? super T>> predicates) {\n    return AllPredicate.allPredicate(predicates);\n}"
            ],
            [
                "orPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true if either of the specified\n * predicates are true.\n *\n * @param <T>  the type that the predicate queries\n * @param predicate1  the first predicate, may not be null\n * @param predicate2  the second predicate, may not be null\n * @return the <code>or</code> predicate\n * @throws NullPointerException if either predicate is null\n * @see OrPredicate\n */\npublic static <T> Predicate<T> orPredicate(final Predicate<? super T> predicate1, final Predicate<? super T> predicate2) {\n    return OrPredicate.orPredicate(predicate1, predicate2);\n}"
            ],
            [
                "anyPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true if any of the specified\n * predicates are true.\n * If the array of predicates is empty, then this predicate returns false.\n *\n * @param <T>  the type that the predicate queries\n * @param predicates  an array of predicates to check, may not be null\n * @return the <code>any</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n * @see AnyPredicate\n */\npublic static <T> Predicate<T> anyPredicate(final Predicate<? super T>... predicates) {\n    return AnyPredicate.anyPredicate(predicates);\n}"
            ],
            [
                "anyPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true if any of the specified\n * predicates are true. The predicates are checked in iterator order.\n * If the collection of predicates is empty, then this predicate returns false.\n *\n * @param <T>  the type that the predicate queries\n * @param predicates  a collection of predicates to check, may not be null\n * @return the <code>any</code> predicate\n * @throws NullPointerException if the predicates collection is null\n * @throws NullPointerException if any predicate in the collection is null\n * @see AnyPredicate\n */\npublic static <T> Predicate<T> anyPredicate(final Collection<? extends Predicate<? super T>> predicates) {\n    return AnyPredicate.anyPredicate(predicates);\n}"
            ],
            [
                "eitherPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true if one, but not both, of the\n * specified predicates are true. XOR\n *\n * @param <T>  the type that the predicate queries\n * @param predicate1  the first predicate, may not be null\n * @param predicate2  the second predicate, may not be null\n * @return the <code>either</code> predicate\n * @throws NullPointerException if either predicate is null\n * @see OnePredicate\n */\npublic static <T> Predicate<T> eitherPredicate(final Predicate<? super T> predicate1, final Predicate<? super T> predicate2) {\n    @SuppressWarnings(\"unchecked\")\n    final Predicate<T> onePredicate = PredicateUtils.onePredicate(predicate1, predicate2);\n    return onePredicate;\n}"
            ],
            [
                "onePredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true if only one of the specified\n * predicates are true.\n * If the array of predicates is empty, then this predicate returns false.\n *\n * @param <T>  the type that the predicate queries\n * @param predicates  an array of predicates to check, may not be null\n * @return the <code>one</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n * @see OnePredicate\n */\npublic static <T> Predicate<T> onePredicate(final Predicate<? super T>... predicates) {\n    return OnePredicate.onePredicate(predicates);\n}"
            ],
            [
                "onePredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true if only one of the specified\n * predicates are true. The predicates are checked in iterator order.\n * If the collection of predicates is empty, then this predicate returns false.\n *\n * @param <T>  the type that the predicate queries\n * @param predicates  a collection of predicates to check, may not be null\n * @return the <code>one</code> predicate\n * @throws NullPointerException if the predicates collection is null\n * @throws NullPointerException if any predicate in the collection is null\n * @see OnePredicate\n */\npublic static <T> Predicate<T> onePredicate(final Collection<? extends Predicate<? super T>> predicates) {\n    return OnePredicate.onePredicate(predicates);\n}"
            ],
            [
                "neitherPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true if neither of the specified\n * predicates are true.\n *\n * @param <T>  the type that the predicate queries\n * @param predicate1  the first predicate, may not be null\n * @param predicate2  the second predicate, may not be null\n * @return the <code>neither</code> predicate\n * @throws NullPointerException if either predicate is null\n * @see NonePredicate\n */\npublic static <T> Predicate<T> neitherPredicate(final Predicate<? super T> predicate1, final Predicate<? super T> predicate2) {\n    @SuppressWarnings(\"unchecked\")\n    final Predicate<T> nonePredicate = PredicateUtils.nonePredicate(predicate1, predicate2);\n    return nonePredicate;\n}"
            ],
            [
                "nonePredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true if none of the specified\n * predicates are true.\n * If the array of predicates is empty, then this predicate returns true.\n *\n * @param <T>  the type that the predicate queries\n * @param predicates  an array of predicates to check, may not be null\n * @return the <code>none</code> predicate\n * @throws NullPointerException if the predicates array is null\n * @throws NullPointerException if any predicate in the array is null\n * @see NonePredicate\n */\npublic static <T> Predicate<T> nonePredicate(final Predicate<? super T>... predicates) {\n    return NonePredicate.nonePredicate(predicates);\n}"
            ],
            [
                "nonePredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true if none of the specified\n * predicates are true. The predicates are checked in iterator order.\n * If the collection of predicates is empty, then this predicate returns true.\n *\n * @param <T>  the type that the predicate queries\n * @param predicates  a collection of predicates to check, may not be null\n * @return the <code>none</code> predicate\n * @throws NullPointerException if the predicates collection is null\n * @throws NullPointerException if any predicate in the collection is null\n * @see NonePredicate\n */\npublic static <T> Predicate<T> nonePredicate(final Collection<? extends Predicate<? super T>> predicates) {\n    return NonePredicate.nonePredicate(predicates);\n}"
            ],
            [
                "notPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Create a new Predicate that returns true if the specified predicate\n * returns false and vice versa.\n *\n * @param <T>  the type that the predicate queries\n * @param predicate  the predicate to not\n * @return the <code>not</code> predicate\n * @throws NullPointerException if the predicate is null\n * @see NotPredicate\n */\npublic static <T> Predicate<T> notPredicate(final Predicate<? super T> predicate) {\n    return NotPredicate.notPredicate(predicate);\n}"
            ],
            [
                "asPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "// Adaptors\n//-----------------------------------------------------------------------------\n/**\n * Create a new Predicate that wraps a Transformer. The Transformer must\n * return either Boolean.TRUE or Boolean.FALSE otherwise a PredicateException\n * will be thrown.\n *\n * @param <T>  the type that the predicate queries\n * @param transformer  the transformer to wrap, may not be null\n * @return the transformer wrapping predicate\n * @throws NullPointerException if the transformer is null\n * @see TransformerPredicate\n */\npublic static <T> Predicate<T> asPredicate(final Transformer<? super T, Boolean> transformer) {\n    return TransformerPredicate.transformerPredicate(transformer);\n}"
            ],
            [
                "nullIsExceptionPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "// Null handlers\n//-----------------------------------------------------------------------------\n/**\n * Gets a Predicate that throws an exception if the input object is null,\n * otherwise it calls the specified Predicate. This allows null handling\n * behaviour to be added to Predicates that don't support nulls.\n *\n * @param <T>  the type that the predicate queries\n * @param predicate  the predicate to wrap, may not be null\n * @return the predicate\n * @throws NullPointerException if the predicate is null.\n * @see NullIsExceptionPredicate\n */\npublic static <T> Predicate<T> nullIsExceptionPredicate(final Predicate<? super T> predicate) {\n    return NullIsExceptionPredicate.nullIsExceptionPredicate(predicate);\n}"
            ],
            [
                "nullIsFalsePredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Gets a Predicate that returns false if the input object is null, otherwise\n * it calls the specified Predicate. This allows null handling behaviour to\n * be added to Predicates that don't support nulls.\n *\n * @param <T>  the type that the predicate queries\n * @param predicate  the predicate to wrap, may not be null\n * @return the predicate\n * @throws NullPointerException if the predicate is null.\n * @see NullIsFalsePredicate\n */\npublic static <T> Predicate<T> nullIsFalsePredicate(final Predicate<? super T> predicate) {\n    return NullIsFalsePredicate.nullIsFalsePredicate(predicate);\n}"
            ],
            [
                "nullIsTruePredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "/**\n * Gets a Predicate that returns true if the input object is null, otherwise\n * it calls the specified Predicate. This allows null handling behaviour to\n * be added to Predicates that don't support nulls.\n *\n * @param <T>  the type that the predicate queries\n * @param predicate  the predicate to wrap, may not be null\n * @return the predicate\n * @throws NullPointerException if the predicate is null.\n * @see NullIsTruePredicate\n */\npublic static <T> Predicate<T> nullIsTruePredicate(final Predicate<? super T> predicate) {\n    return NullIsTruePredicate.nullIsTruePredicate(predicate);\n}"
            ],
            [
                "transformedPredicate",
                "org.apache.commons.collections4",
                "PredicateUtils",
                "// Transformed\n//-----------------------------------------------------------------------\n/**\n * Creates a predicate that transforms the input object before passing it\n * to the predicate.\n *\n * @param <T>  the type that the predicate queries\n * @param transformer  the transformer to call first\n * @param predicate  the predicate to call with the result of the transform\n * @return the predicate\n * @throws NullPointerException if the transformer or the predicate is null\n * @see TransformedPredicate\n * @since 3.1\n */\npublic static <T> Predicate<T> transformedPredicate(final Transformer<? super T, ? extends T> transformer, final Predicate<? super T> predicate) {\n    return TransformedPredicate.transformedPredicate(transformer, predicate);\n}"
            ],
            [
                "emptySet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Get a typed empty unmodifiable Set.\n * @param <E> the element type\n * @return an empty Set\n */\npublic static <E> Set<E> emptySet() {\n    return Collections.<E>emptySet();\n}"
            ],
            [
                "emptySortedSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Get a typed empty unmodifiable sorted set.\n * @param <E> the element type\n * @return an empty sorted Set\n */\n// empty set is OK for any type\n@SuppressWarnings(\"unchecked\")\npublic static <E> SortedSet<E> emptySortedSet() {\n    return EMPTY_SORTED_SET;\n}"
            ],
            [
                "emptyIfNull",
                "org.apache.commons.collections4",
                "SetUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns an immutable empty set if the argument is <code>null</code>,\n * or the argument itself otherwise.\n *\n * @param <T> the element type\n * @param set the set, possibly <code>null</code>\n * @return an empty set if the argument is <code>null</code>\n */\npublic static <T> Set<T> emptyIfNull(final Set<T> set) {\n    return set == null ? Collections.<T>emptySet() : set;\n}"
            ],
            [
                "isEqualSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Tests two sets for equality as per the <code>equals()</code> contract\n * in {@link java.util.Set#equals(java.lang.Object)}.\n * <p>\n * This method is useful for implementing <code>Set</code> when you cannot\n * extend AbstractSet. The method takes Collection instances to enable other\n * collection types to use the Set implementation algorithm.\n * <p>\n * The relevant text (slightly paraphrased as this is a static method) is:\n * <blockquote>\n * <p>Two sets are considered equal if they have\n * the same size, and every member of the first set is contained in\n * the second. This ensures that the {@code equals} method works\n * properly across different implementations of the {@code Set}\n * interface.</p>\n *\n * <p>\n * This implementation first checks if the two sets are the same object:\n * if so it returns {@code true}.  Then, it checks if the two sets are\n * identical in size; if not, it returns false. If so, it returns\n * {@code a.containsAll((Collection) b)}.</p>\n * </blockquote>\n *\n * @see java.util.Set\n * @param set1  the first set, may be null\n * @param set2  the second set, may be null\n * @return whether the sets are equal by value comparison\n */\npublic static boolean isEqualSet(final Collection<?> set1, final Collection<?> set2) {\n    if (set1 == set2) {\n        return true;\n    }\n    if (set1 == null || set2 == null || set1.size() != set2.size()) {\n        return false;\n    }\n    return set1.containsAll(set2);\n}"
            ],
            [
                "hashCodeForSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Generates a hash code using the algorithm specified in\n * {@link java.util.Set#hashCode()}.\n * <p>\n * This method is useful for implementing <code>Set</code> when you cannot\n * extend AbstractSet. The method takes Collection instances to enable other\n * collection types to use the Set implementation algorithm.\n *\n * @param <T> the element type\n * @see java.util.Set#hashCode()\n * @param set  the set to calculate the hash code for, may be null\n * @return the hash code\n */\npublic static <T> int hashCodeForSet(final Collection<T> set) {\n    if (set == null) {\n        return 0;\n    }\n    int hashCode = 0;\n    for (final T obj : set) {\n        if (obj != null) {\n            hashCode += obj.hashCode();\n        }\n    }\n    return hashCode;\n}"
            ],
            [
                "newIdentityHashSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a new hash set that matches elements based on <code>==</code> not\n * <code>equals()</code>.\n * <p>\n * <strong>This set will violate the detail of various Set contracts.</note>\n * As a general rule, don't compare this set to other sets. In particular, you can't\n * use decorators like {@link ListOrderedSet} on it, which silently assume that these\n * contracts are fulfilled.</strong>\n * <p>\n * <strong>Note that the returned set is not synchronized and is not thread-safe.</strong>\n * If you wish to use this set from multiple threads concurrently, you must use\n * appropriate synchronization. The simplest approach is to wrap this map\n * using {@link java.util.Collections#synchronizedSet(Set)}. This class may throw\n * exceptions when accessed by concurrent threads without synchronization.\n *\n * @param <E>  the element type\n * @return a new identity hash set\n * @since 4.1\n */\npublic static <E> Set<E> newIdentityHashSet() {\n    return Collections.newSetFromMap(new IdentityHashMap<E, Boolean>());\n}"
            ],
            [
                "synchronizedSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "// Set\n//-----------------------------------------------------------------------\n/**\n * Returns a synchronized set backed by the given set.\n * <p>\n * You must manually synchronize on the returned set's iterator to\n * avoid non-deterministic behavior:\n *\n * <pre>\n * Set s = SetUtils.synchronizedSet(mySet);\n * synchronized (s) {\n *     Iterator i = s.iterator();\n *     while (i.hasNext()) {\n *         process (i.next());\n *     }\n * }\n * </pre>\n *\n * This method is just a wrapper for {@link Collections#synchronizedSet(Set)}.\n *\n * @param <E> the element type\n * @param set  the set to synchronize, must not be null\n * @return a synchronized set backed by the given set\n * @throws NullPointerException if the set is null\n */\npublic static <E> Set<E> synchronizedSet(final Set<E> set) {\n    return Collections.synchronizedSet(set);\n}"
            ],
            [
                "unmodifiableSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns an unmodifiable set backed by the given set.\n * <p>\n * This method uses the implementation in the decorators subpackage.\n *\n * @param <E> the element type\n * @param set  the set to make unmodifiable, must not be null\n * @return an unmodifiable set backed by the given set\n * @throws NullPointerException if the set is null\n */\npublic static <E> Set<E> unmodifiableSet(final Set<? extends E> set) {\n    return UnmodifiableSet.unmodifiableSet(set);\n}"
            ],
            [
                "predicatedSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a predicated (validating) set backed by the given set.\n * <p>\n * Only objects that pass the test in the given predicate can be added to the set.\n * Trying to add an invalid object results in an IllegalArgumentException.\n * It is important not to use the original set after invoking this method,\n * as it is a backdoor for adding invalid objects.\n *\n * @param <E> the element type\n * @param set  the set to predicate, must not be null\n * @param predicate  the predicate for the set, must not be null\n * @return a predicated set backed by the given set\n * @throws NullPointerException if the set or predicate is null\n */\npublic static <E> Set<E> predicatedSet(final Set<E> set, final Predicate<? super E> predicate) {\n    return PredicatedSet.predicatedSet(set, predicate);\n}"
            ],
            [
                "transformedSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a transformed set backed by the given set.\n * <p>\n * Each object is passed through the transformer as it is added to the\n * Set. It is important not to use the original set after invoking this\n * method, as it is a backdoor for adding untransformed objects.\n * <p>\n * Existing entries in the specified set will not be transformed.\n * If you want that behaviour, see {@link TransformedSet#transformedSet}.\n *\n * @param <E> the element type\n * @param set  the set to transform, must not be null\n * @param transformer  the transformer for the set, must not be null\n * @return a transformed set backed by the given set\n * @throws NullPointerException if the set or transformer is null\n */\npublic static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer) {\n    return TransformedSet.transformingSet(set, transformer);\n}"
            ],
            [
                "orderedSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a set that maintains the order of elements that are added\n * backed by the given set.\n * <p>\n * If an element is added twice, the order is determined by the first add.\n * The order is observed through the iterator or toArray.\n *\n * @param <E> the element type\n * @param set  the set to order, must not be null\n * @return an ordered set backed by the given set\n * @throws NullPointerException if the set is null\n */\npublic static <E> Set<E> orderedSet(final Set<E> set) {\n    return ListOrderedSet.listOrderedSet(set);\n}"
            ],
            [
                "synchronizedSortedSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "// SortedSet\n//-----------------------------------------------------------------------\n/**\n * Returns a synchronized sorted set backed by the given sorted set.\n * <p>\n * You must manually synchronize on the returned set's iterator to\n * avoid non-deterministic behavior:\n *\n * <pre>\n * Set s = SetUtils.synchronizedSortedSet(mySet);\n * synchronized (s) {\n *     Iterator i = s.iterator();\n *     while (i.hasNext()) {\n *         process (i.next());\n *     }\n * }\n * </pre>\n *\n * This method is just a wrapper for {@link Collections#synchronizedSortedSet(SortedSet)}.\n *\n * @param <E> the element type\n * @param set  the sorted set to synchronize, must not be null\n * @return a synchronized set backed by the given set\n * @throws NullPointerException if the set is null\n */\npublic static <E> SortedSet<E> synchronizedSortedSet(final SortedSet<E> set) {\n    return Collections.synchronizedSortedSet(set);\n}"
            ],
            [
                "unmodifiableSortedSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns an unmodifiable sorted set backed by the given sorted set.\n * <p>\n * This method uses the implementation in the decorators subpackage.\n *\n * @param <E> the element type\n * @param set  the sorted set to make unmodifiable, must not be null\n * @return an unmodifiable set backed by the given set\n * @throws NullPointerException if the set is null\n */\npublic static <E> SortedSet<E> unmodifiableSortedSet(final SortedSet<E> set) {\n    return UnmodifiableSortedSet.unmodifiableSortedSet(set);\n}"
            ],
            [
                "predicatedSortedSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a predicated (validating) sorted set backed by the given sorted set.\n * <p>\n * Only objects that pass the test in the given predicate can be added to the set.\n * Trying to add an invalid object results in an IllegalArgumentException.\n * It is important not to use the original set after invoking this method,\n * as it is a backdoor for adding invalid objects.\n *\n * @param <E> the element type\n * @param set  the sorted set to predicate, must not be null\n * @param predicate  the predicate for the sorted set, must not be null\n * @return a predicated sorted set backed by the given sorted set\n * @throws NullPointerException if the set or predicate is null\n */\npublic static <E> SortedSet<E> predicatedSortedSet(final SortedSet<E> set, final Predicate<? super E> predicate) {\n    return PredicatedSortedSet.predicatedSortedSet(set, predicate);\n}"
            ],
            [
                "transformedSortedSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a transformed sorted set backed by the given set.\n * <p>\n * Each object is passed through the transformer as it is added to the\n * Set. It is important not to use the original set after invoking this\n * method, as it is a backdoor for adding untransformed objects.\n * <p>\n * Existing entries in the specified set will not be transformed.\n * If you want that behaviour, see {@link TransformedSortedSet#transformedSortedSet}.\n *\n * @param <E> the element type\n * @param set  the set to transform, must not be null\n * @param transformer  the transformer for the set, must not be null\n * @return a transformed set backed by the given set\n * @throws NullPointerException if the set or transformer is null\n */\npublic static <E> SortedSet<E> transformedSortedSet(final SortedSet<E> set, final Transformer<? super E, ? extends E> transformer) {\n    return TransformedSortedSet.transformingSortedSet(set, transformer);\n}"
            ],
            [
                "unmodifiableNavigableSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "// NavigableSet\n//-----------------------------------------------------------------------\n/**\n * Returns an unmodifiable navigable set backed by the given navigable set.\n * <p>\n * This method uses the implementation in the decorators subpackage.\n *\n * @param <E> the element type\n * @param set  the navigable set to make unmodifiable, must not be null\n * @return an unmodifiable set backed by the given set\n * @throws NullPointerException if the set is null\n * @since 4.1\n */\npublic static <E> SortedSet<E> unmodifiableNavigableSet(final NavigableSet<E> set) {\n    return UnmodifiableNavigableSet.unmodifiableNavigableSet(set);\n}"
            ],
            [
                "predicatedNavigableSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a predicated (validating) navigable set backed by the given navigable set.\n * <p>\n * Only objects that pass the test in the given predicate can be added to the set.\n * Trying to add an invalid object results in an IllegalArgumentException.\n * It is important not to use the original set after invoking this method,\n * as it is a backdoor for adding invalid objects.\n *\n * @param <E> the element type\n * @param set  the navigable set to predicate, must not be null\n * @param predicate  the predicate for the navigable set, must not be null\n * @return a predicated navigable set backed by the given navigable set\n * @throws NullPointerException if the set or predicate is null\n * @since 4.1\n */\npublic static <E> SortedSet<E> predicatedNavigableSet(final NavigableSet<E> set, final Predicate<? super E> predicate) {\n    return PredicatedNavigableSet.predicatedNavigableSet(set, predicate);\n}"
            ],
            [
                "transformedNavigableSet",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a transformed navigable set backed by the given navigable set.\n * <p>\n * Each object is passed through the transformer as it is added to the\n * Set. It is important not to use the original set after invoking this\n * method, as it is a backdoor for adding untransformed objects.\n * <p>\n * Existing entries in the specified set will not be transformed.\n * If you want that behaviour, see {@link TransformedNavigableSet#transformedNavigableSet}.\n *\n * @param <E> the element type\n * @param set  the navigable set to transform, must not be null\n * @param transformer  the transformer for the set, must not be null\n * @return a transformed set backed by the given set\n * @throws NullPointerException if the set or transformer is null\n * @since 4.1\n */\npublic static <E> SortedSet<E> transformedNavigableSet(final NavigableSet<E> set, final Transformer<? super E, ? extends E> transformer) {\n    return TransformedNavigableSet.transformingNavigableSet(set, transformer);\n}"
            ],
            [
                "union",
                "org.apache.commons.collections4",
                "SetUtils",
                "// Set operations\n//-----------------------------------------------------------------------\n/**\n * Returns a unmodifiable <b>view</b> of the union of the given {@link Set}s.\n * <p>\n * The returned view contains all elements of {@code a} and {@code b}.\n *\n * @param <E> the generic type that is able to represent the types contained\n *   in both input sets.\n * @param a  the first set, must not be null\n * @param b  the second set, must not be null\n * @return a view of the union of the two set\n * @throws NullPointerException if either input set is null\n * @since 4.1\n */\npublic static <E> SetView<E> union(final Set<? extends E> a, final Set<? extends E> b) {\n    if (a == null || b == null) {\n        throw new NullPointerException(\"Sets must not be null.\");\n    }\n    final SetView<E> bMinusA = difference(b, a);\n    return new SetView<E>() {\n\n        @Override\n        public boolean contains(Object o) {\n            return a.contains(o) || b.contains(o);\n        }\n\n        @Override\n        public Iterator<E> createIterator() {\n            return IteratorUtils.chainedIterator(a.iterator(), bMinusA.iterator());\n        }\n\n        @Override\n        public boolean isEmpty() {\n            return a.isEmpty() && b.isEmpty();\n        }\n\n        @Override\n        public int size() {\n            return a.size() + bMinusA.size();\n        }\n    };\n}"
            ],
            [
                "difference",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a unmodifiable <b>view</b> containing the difference of the given\n * {@link Set}s, denoted by {@code a \\ b} (or {@code a - b}).\n * <p>\n * The returned view contains all elements of {@code a} that are not a member\n * of {@code b}.\n *\n * @param <E> the generic type that is able to represent the types contained\n *   in both input sets.\n * @param a  the set to subtract from, must not be null\n * @param b  the set to subtract, must not be null\n * @return a view of the relative complement of  of the two sets\n * @since 4.1\n */\npublic static <E> SetView<E> difference(final Set<? extends E> a, final Set<? extends E> b) {\n    if (a == null || b == null) {\n        throw new NullPointerException(\"Sets must not be null.\");\n    }\n    final Predicate<E> notContainedInB = new Predicate<E>() {\n\n        @Override\n        public boolean evaluate(E object) {\n            return !b.contains(object);\n        }\n    };\n    return new SetView<E>() {\n\n        @Override\n        public boolean contains(Object o) {\n            return a.contains(o) && !b.contains(o);\n        }\n\n        @Override\n        public Iterator<E> createIterator() {\n            return IteratorUtils.filteredIterator(a.iterator(), notContainedInB);\n        }\n    };\n}"
            ],
            [
                "intersection",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a unmodifiable <b>view</b> of the intersection of the given {@link Set}s.\n * <p>\n * The returned view contains all elements that are members of both input sets\n * ({@code a} and {@code b}).\n *\n * @param <E> the generic type that is able to represent the types contained\n *   in both input sets.\n * @param a  the first set, must not be null\n * @param b  the second set, must not be null\n * @return a view of the intersection of the two sets\n * @since 4.1\n */\npublic static <E> SetView<E> intersection(final Set<? extends E> a, final Set<? extends E> b) {\n    if (a == null || b == null) {\n        throw new NullPointerException(\"Sets must not be null.\");\n    }\n    final Predicate<E> containedInB = new Predicate<E>() {\n\n        @Override\n        public boolean evaluate(E object) {\n            return b.contains(object);\n        }\n    };\n    return new SetView<E>() {\n\n        @Override\n        public boolean contains(Object o) {\n            return a.contains(o) && b.contains(o);\n        }\n\n        @Override\n        public Iterator<E> createIterator() {\n            return IteratorUtils.filteredIterator(a.iterator(), containedInB);\n        }\n    };\n}"
            ],
            [
                "disjunction",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * Returns a unmodifiable <b>view</b> of the symmetric difference of the given\n * {@link Set}s.\n * <p>\n * The returned view contains all elements of {@code a} and {@code b} that are\n * not a member of the other set.\n * <p>\n * This is equivalent to {@code union(difference(a, b), difference(b, a))}.\n *\n * @param <E> the generic type that is able to represent the types contained\n *   in both input sets.\n * @param a  the first set, must not be null\n * @param b  the second set, must not be null\n * @return a view of the symmetric difference of the two sets\n * @since 4.1\n */\npublic static <E> SetView<E> disjunction(final Set<? extends E> a, final Set<? extends E> b) {\n    if (a == null || b == null) {\n        throw new NullPointerException(\"Sets must not be null.\");\n    }\n    final SetView<E> aMinusB = difference(a, b);\n    final SetView<E> bMinusA = difference(b, a);\n    return new SetView<E>() {\n\n        @Override\n        public boolean contains(Object o) {\n            return a.contains(o) ^ b.contains(o);\n        }\n\n        @Override\n        public Iterator<E> createIterator() {\n            return IteratorUtils.chainedIterator(aMinusB.iterator(), bMinusA.iterator());\n        }\n\n        @Override\n        public boolean isEmpty() {\n            return aMinusB.isEmpty() && bMinusA.isEmpty();\n        }\n\n        @Override\n        public int size() {\n            return aMinusB.size() + bMinusA.size();\n        }\n    };\n}"
            ],
            [
                "transformingSet",
                "org.apache.commons.collections4.set",
                "TransformedSet",
                "/**\n * Factory method to create a transforming set.\n * <p>\n * If there are any elements already in the set being decorated, they\n * are NOT transformed.\n * Contrast this with {@link #transformedSet(Set, Transformer)}.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed set\n * @throws NullPointerException if set or transformer is null\n * @since 4.0\n */\npublic static <E> TransformedSet<E> transformingSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer) {\n    return new TransformedSet<E>(set, transformer);\n}"
            ],
            [
                "transformedSet",
                "org.apache.commons.collections4.set",
                "TransformedSet",
                "/**\n * Factory method to create a transforming set that will transform\n * existing contents of the specified set.\n * <p>\n * If there are any elements already in the set being decorated, they\n * will be transformed by this method.\n * Contrast this with {@link #transformingSet(Set, Transformer)}.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed set\n * @throws NullPointerException if set or transformer is null\n * @since 4.0\n */\npublic static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer) {\n    final TransformedSet<E> decorated = new TransformedSet<E>(set, transformer);\n    if (set.size() > 0) {\n        // set is type E\n        @SuppressWarnings(\"unchecked\")\n        final E[] // NOPMD - false positive for generics\n        values = (E[]) set.toArray();\n        set.clear();\n        for (final E value : values) {\n            decorated.decorated().add(transformer.transform(value));\n        }\n    }\n    return decorated;\n}"
            ],
            [
                "transformingNavigableSet",
                "org.apache.commons.collections4.set",
                "TransformedNavigableSet",
                "/**\n * Factory method to create a transforming navigable set.\n * <p>\n * If there are any elements already in the set being decorated, they\n * are NOT transformed.\n * Contrast this with {@link #transformedNavigableSet(NavigableSet, Transformer)}.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed {@link NavigableSet}\n * @throws NullPointerException if set or transformer is null\n */\npublic static <E> TransformedNavigableSet<E> transformingNavigableSet(final NavigableSet<E> set, final Transformer<? super E, ? extends E> transformer) {\n    return new TransformedNavigableSet<E>(set, transformer);\n}"
            ],
            [
                "transformedNavigableSet",
                "org.apache.commons.collections4.set",
                "TransformedNavigableSet",
                "/**\n * Factory method to create a transforming navigable set that will transform\n * existing contents of the specified navigable set.\n * <p>\n * If there are any elements already in the set being decorated, they\n * will be transformed by this method.\n * Contrast this with {@link #transformingNavigableSet(NavigableSet, Transformer)}.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed {@link NavigableSet}\n * @throws NullPointerException if set or transformer is null\n */\npublic static <E> TransformedNavigableSet<E> transformedNavigableSet(final NavigableSet<E> set, final Transformer<? super E, ? extends E> transformer) {\n    final TransformedNavigableSet<E> decorated = new TransformedNavigableSet<E>(set, transformer);\n    if (set.size() > 0) {\n        // set is type E\n        @SuppressWarnings(\"unchecked\")\n        final E[] // NOPMD - false positive for generics\n        values = (E[]) set.toArray();\n        set.clear();\n        for (final E value : values) {\n            decorated.decorated().add(transformer.transform(value));\n        }\n    }\n    return decorated;\n}"
            ],
            [
                "predicatedNavigableSet",
                "org.apache.commons.collections4.set",
                "PredicatedNavigableSet",
                "/**\n * Factory method to create a predicated (validating) navigable set.\n * <p>\n * If there are any elements already in the set being decorated, they\n * are validated.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @param predicate  the predicate to use for validation, must not be null\n * @return a new predicated navigable set.\n * @throws NullPointerException if set or predicate is null\n * @throws IllegalArgumentException if the set contains invalid elements\n * @since 4.0\n */\npublic static <E> PredicatedNavigableSet<E> predicatedNavigableSet(final NavigableSet<E> set, final Predicate<? super E> predicate) {\n    return new PredicatedNavigableSet<E>(set, predicate);\n}"
            ],
            [
                "listOrderedSet",
                "org.apache.commons.collections4.set",
                "ListOrderedSet",
                "/**\n * Factory method to create an ordered set specifying the list and set to use.\n * <p>\n * The list and set must both be empty.\n *\n * @param <E> the element type\n * @param set the set to decorate, must be empty and not null\n * @param list the list to decorate, must be empty and not null\n * @return a new ordered set\n * @throws NullPointerException if set or list is null\n * @throws IllegalArgumentException if either the set or list is not empty\n * @since 4.0\n */\npublic static <E> ListOrderedSet<E> listOrderedSet(final Set<E> set, final List<E> list) {\n    if (set == null) {\n        throw new NullPointerException(\"Set must not be null\");\n    }\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (set.size() > 0 || list.size() > 0) {\n        throw new IllegalArgumentException(\"Set and List must be empty\");\n    }\n    return new ListOrderedSet<E>(set, list);\n}"
            ],
            [
                "listOrderedSet",
                "org.apache.commons.collections4.set",
                "ListOrderedSet",
                "/**\n * Factory method to create an ordered set.\n * <p>\n * An <code>ArrayList</code> is used to retain order.\n *\n * @param <E> the element type\n * @param set the set to decorate, must not be null\n * @return a new ordered set\n * @throws NullPointerException if set is null\n * @since 4.0\n */\npublic static <E> ListOrderedSet<E> listOrderedSet(final Set<E> set) {\n    return new ListOrderedSet<E>(set);\n}"
            ],
            [
                "listOrderedSet",
                "org.apache.commons.collections4.set",
                "ListOrderedSet",
                "/**\n * Factory method to create an ordered set using the supplied list to retain order.\n * <p>\n * A <code>HashSet</code> is used for the set behaviour.\n * <p>\n * NOTE: If the list contains duplicates, the duplicates are removed,\n * altering the specified list.\n *\n * @param <E> the element type\n * @param list the list to decorate, must not be null\n * @return a new ordered set\n * @throws NullPointerException if list is null\n * @since 4.0\n */\npublic static <E> ListOrderedSet<E> listOrderedSet(final List<E> list) {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n    return new ListOrderedSet<E>(set, list);\n}"
            ],
            [
                "unmodifiableSet",
                "org.apache.commons.collections4.set",
                "UnmodifiableSet",
                "/**\n * Factory method to create an unmodifiable set.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @return a new unmodifiable set\n * @throws NullPointerException if set is null\n * @since 4.0\n */\npublic static <E> Set<E> unmodifiableSet(final Set<? extends E> set) {\n    if (set instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final Set<E> tmpSet = (Set<E>) set;\n        return tmpSet;\n    }\n    return new UnmodifiableSet<E>(set);\n}"
            ],
            [
                "mapBackedSet",
                "org.apache.commons.collections4.set",
                "MapBackedSet",
                "/**\n * Factory method to create a set from a map.\n *\n * @param <E> the element type\n * @param <V> the dummy value type in the map\n * @param map  the map to decorate, must not be null\n * @return a new map backed set\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <E, V> MapBackedSet<E, V> mapBackedSet(final Map<E, ? super V> map) {\n    return mapBackedSet(map, null);\n}"
            ],
            [
                "mapBackedSet",
                "org.apache.commons.collections4.set",
                "MapBackedSet",
                "/**\n * Factory method to create a set from a map.\n *\n * @param <E> the element type\n * @param <V> the dummy value type in the map\n * @param map  the map to decorate, must not be null\n * @param dummyValue  the dummy value to use\n * @return a new map backed set\n * @throws NullPointerException if map is null\n * @since 4.0\n */\npublic static <E, V> MapBackedSet<E, V> mapBackedSet(final Map<E, ? super V> map, final V dummyValue) {\n    return new MapBackedSet<E, V>(map, dummyValue);\n}"
            ],
            [
                "unmodifiableSortedSet",
                "org.apache.commons.collections4.set",
                "UnmodifiableSortedSet",
                "/**\n * Factory method to create an unmodifiable set.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @return a new unmodifiable {@link SortedSet}\n * @throws NullPointerException if set is null\n * @since 4.0\n */\npublic static <E> SortedSet<E> unmodifiableSortedSet(final SortedSet<E> set) {\n    if (set instanceof Unmodifiable) {\n        return set;\n    }\n    return new UnmodifiableSortedSet<E>(set);\n}"
            ],
            [
                "predicatedSortedSet",
                "org.apache.commons.collections4.set",
                "PredicatedSortedSet",
                "/**\n * Factory method to create a predicated (validating) sorted set.\n * <p>\n * If there are any elements already in the set being decorated, they\n * are validated.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @param predicate  the predicate to use for validation, must not be null\n * @return a new predicated sorted set.\n * @throws NullPointerException if set or predicate is null\n * @throws IllegalArgumentException if the set contains invalid elements\n * @since 4.0\n */\npublic static <E> PredicatedSortedSet<E> predicatedSortedSet(final SortedSet<E> set, final Predicate<? super E> predicate) {\n    return new PredicatedSortedSet<E>(set, predicate);\n}"
            ],
            [
                "predicatedSet",
                "org.apache.commons.collections4.set",
                "PredicatedSet",
                "/**\n * Factory method to create a predicated (validating) set.\n * <p>\n * If there are any elements already in the set being decorated, they\n * are validated.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @param predicate  the predicate to use for validation, must not be null\n * @return a decorated set\n * @throws NullPointerException if set or predicate is null\n * @throws IllegalArgumentException if the set contains invalid elements\n * @since 4.0\n */\npublic static <E> PredicatedSet<E> predicatedSet(final Set<E> set, final Predicate<? super E> predicate) {\n    return new PredicatedSet<E>(set, predicate);\n}"
            ],
            [
                "unmodifiableNavigableSet",
                "org.apache.commons.collections4.set",
                "UnmodifiableNavigableSet",
                "/**\n * Factory method to create an unmodifiable set.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @return a new unmodifiable {@link NavigableSet}\n * @throws NullPointerException if set is null\n */\npublic static <E> NavigableSet<E> unmodifiableNavigableSet(final NavigableSet<E> set) {\n    if (set instanceof Unmodifiable) {\n        return set;\n    }\n    return new UnmodifiableNavigableSet<E>(set);\n}"
            ],
            [
                "transformingSortedSet",
                "org.apache.commons.collections4.set",
                "TransformedSortedSet",
                "/**\n * Factory method to create a transforming sorted set.\n * <p>\n * If there are any elements already in the set being decorated, they\n * are NOT transformed.\n * Contrast this with {@link #transformedSortedSet(SortedSet, Transformer)}.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed {@link SortedSet}\n * @throws NullPointerException if set or transformer is null\n * @since 4.0\n */\npublic static <E> TransformedSortedSet<E> transformingSortedSet(final SortedSet<E> set, final Transformer<? super E, ? extends E> transformer) {\n    return new TransformedSortedSet<E>(set, transformer);\n}"
            ],
            [
                "transformedSortedSet",
                "org.apache.commons.collections4.set",
                "TransformedSortedSet",
                "/**\n * Factory method to create a transforming sorted set that will transform\n * existing contents of the specified sorted set.\n * <p>\n * If there are any elements already in the set being decorated, they\n * will be transformed by this method.\n * Contrast this with {@link #transformingSortedSet(SortedSet, Transformer)}.\n *\n * @param <E> the element type\n * @param set  the set to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed {@link SortedSet}\n * @throws NullPointerException if set or transformer is null\n * @since 4.0\n */\npublic static <E> TransformedSortedSet<E> transformedSortedSet(final SortedSet<E> set, final Transformer<? super E, ? extends E> transformer) {\n    final TransformedSortedSet<E> decorated = new TransformedSortedSet<E>(set, transformer);\n    if (set.size() > 0) {\n        // set is type E\n        @SuppressWarnings(\"unchecked\")\n        final E[] // NOPMD - false positive for generics\n        values = (E[]) set.toArray();\n        set.clear();\n        for (final E value : values) {\n            decorated.decorated().add(transformer.transform(value));\n        }\n    }\n    return decorated;\n}"
            ],
            [
                "get",
                "org.apache.commons.collections4",
                "EnumerationUtils",
                "/**\n * Returns the <code>index</code>-th value in the {@link Enumeration}, throwing\n * <code>IndexOutOfBoundsException</code> if there is no such element.\n * <p>\n * The Enumeration is advanced to <code>index</code> (or to the end, if\n * <code>index</code> exceeds the number of entries) as a side effect of this method.\n *\n * @param e  the enumeration to get a value from\n * @param index  the index to get\n * @param <T> the type of object in the {@link Enumeration}\n * @return the object at the specified index\n * @throws IndexOutOfBoundsException if the index is invalid\n * @throws IllegalArgumentException if the object type is invalid\n * @since 4.1\n */\npublic static <T> T get(final Enumeration<T> e, final int index) {\n    int i = index;\n    CollectionUtils.checkIndexBounds(i);\n    while (e.hasMoreElements()) {\n        i--;\n        if (i == -1) {\n            return e.nextElement();\n        } else {\n            e.nextElement();\n        }\n    }\n    throw new IndexOutOfBoundsException(\"Entry does not exist: \" + i);\n}"
            ],
            [
                "toList",
                "org.apache.commons.collections4",
                "EnumerationUtils",
                "/**\n * Creates a list based on an enumeration.\n *\n * <p>As the enumeration is traversed, an ArrayList of its values is\n * created. The new list is returned.</p>\n *\n * @param <E> the element type\n * @param enumeration  the enumeration to traverse, which should not be <code>null</code>.\n * @return a list containing all elements of the given enumeration\n * @throws NullPointerException if the enumeration parameter is <code>null</code>.\n */\npublic static <E> List<E> toList(final Enumeration<? extends E> enumeration) {\n    return IteratorUtils.toList(new EnumerationIterator<E>(enumeration));\n}"
            ],
            [
                "toList",
                "org.apache.commons.collections4",
                "EnumerationUtils",
                "/**\n * Override toList(Enumeration) for StringTokenizer as it implements Enumeration&lt;Object&gt;\n * for the sake of backward compatibility.\n *\n * @param stringTokenizer  the tokenizer to convert to a {@link List}&lt;{@link String}&gt;\n * @return a list containing all tokens of the given StringTokenizer\n */\npublic static List<String> toList(final StringTokenizer stringTokenizer) {\n    final List<String> result = new ArrayList<String>(stringTokenizer.countTokens());\n    while (stringTokenizer.hasMoreTokens()) {\n        result.add(stringTokenizer.nextToken());\n    }\n    return result;\n}"
            ],
            [
                "unmodifiableQueue",
                "org.apache.commons.collections4",
                "QueueUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns an unmodifiable queue backed by the given queue.\n *\n * @param <E> the type of the elements in the queue\n * @param queue  the queue to make unmodifiable, must not be null\n * @return an unmodifiable queue backed by that queue\n * @throws NullPointerException if the queue is null\n */\npublic static <E> Queue<E> unmodifiableQueue(final Queue<? extends E> queue) {\n    return UnmodifiableQueue.unmodifiableQueue(queue);\n}"
            ],
            [
                "predicatedQueue",
                "org.apache.commons.collections4",
                "QueueUtils",
                "/**\n * Returns a predicated (validating) queue backed by the given queue.\n * <p>\n * Only objects that pass the test in the given predicate can be added to the queue.\n * Trying to add an invalid object results in an IllegalArgumentException.\n * It is important not to use the original queue after invoking this method,\n * as it is a backdoor for adding invalid objects.\n *\n * @param <E> the type of the elements in the queue\n * @param queue  the queue to predicate, must not be null\n * @param predicate  the predicate used to evaluate new elements, must not be null\n * @return a predicated queue\n * @throws NullPointerException if the queue or predicate is null\n */\npublic static <E> Queue<E> predicatedQueue(final Queue<E> queue, final Predicate<? super E> predicate) {\n    return PredicatedQueue.predicatedQueue(queue, predicate);\n}"
            ],
            [
                "transformingQueue",
                "org.apache.commons.collections4",
                "QueueUtils",
                "/**\n * Returns a transformed queue backed by the given queue.\n * <p>\n * Each object is passed through the transformer as it is added to the\n * Queue. It is important not to use the original queue after invoking this\n * method, as it is a backdoor for adding untransformed objects.\n * <p>\n * Existing entries in the specified queue will not be transformed.\n * If you want that behaviour, see {@link TransformedQueue#transformedQueue}.\n *\n * @param <E> the type of the elements in the queue\n * @param queue  the queue to predicate, must not be null\n * @param transformer  the transformer for the queue, must not be null\n * @return a transformed queue backed by the given queue\n * @throws NullPointerException if the queue or transformer is null\n */\npublic static <E> Queue<E> transformingQueue(final Queue<E> queue, final Transformer<? super E, ? extends E> transformer) {\n    return TransformedQueue.transformingQueue(queue, transformer);\n}"
            ],
            [
                "emptyQueue",
                "org.apache.commons.collections4",
                "QueueUtils",
                "/**\n * Get an empty <code>Queue</code>.\n *\n * @param <E> the type of the elements in the queue\n * @return an empty {@link Queue}\n */\n// OK, empty queue is compatible with any type\n@SuppressWarnings(\"unchecked\")\npublic static <E> Queue<E> emptyQueue() {\n    return (Queue<E>) EMPTY_QUEUE;\n}"
            ],
            [
                "synchronizedBag",
                "org.apache.commons.collections4.bag",
                "SynchronizedBag",
                "/**\n * Factory method to create a synchronized bag.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @return a new synchronized Bag\n * @throws NullPointerException if bag is null\n * @since 4.0\n */\npublic static <E> SynchronizedBag<E> synchronizedBag(final Bag<E> bag) {\n    return new SynchronizedBag<E>(bag);\n}"
            ],
            [
                "collectionBag",
                "org.apache.commons.collections4.bag",
                "CollectionBag",
                "/**\n * Factory method to create a bag that complies to the Collection contract.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @return a Bag that complies to the Collection contract\n * @throws NullPointerException if bag is null\n */\npublic static <E> Bag<E> collectionBag(final Bag<E> bag) {\n    return new CollectionBag<E>(bag);\n}"
            ],
            [
                "unmodifiableBag",
                "org.apache.commons.collections4.bag",
                "UnmodifiableBag",
                "/**\n * Factory method to create an unmodifiable bag.\n * <p>\n * If the bag passed in is already unmodifiable, it is returned.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @return an unmodifiable Bag\n * @throws NullPointerException if bag is null\n * @since 4.0\n */\npublic static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n    if (bag instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final Bag<E> tmpBag = (Bag<E>) bag;\n        return tmpBag;\n    }\n    return new UnmodifiableBag<E>(bag);\n}"
            ],
            [
                "predicatedSortedBag",
                "org.apache.commons.collections4.bag",
                "PredicatedSortedBag",
                "/**\n * Factory method to create a predicated (validating) bag.\n * <p>\n * If there are any elements already in the bag being decorated, they\n * are validated.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @param predicate  the predicate to use for validation, must not be null\n * @return a new predicated SortedBag\n * @throws NullPointerException if bag or predicate is null\n * @throws IllegalArgumentException if the bag contains invalid elements\n * @since 4.0\n */\npublic static <E> PredicatedSortedBag<E> predicatedSortedBag(final SortedBag<E> bag, final Predicate<? super E> predicate) {\n    return new PredicatedSortedBag<E>(bag, predicate);\n}"
            ],
            [
                "unmodifiableSortedBag",
                "org.apache.commons.collections4.bag",
                "UnmodifiableSortedBag",
                "/**\n * Factory method to create an unmodifiable bag.\n * <p>\n * If the bag passed in is already unmodifiable, it is returned.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @return an unmodifiable SortedBag\n * @throws NullPointerException if bag is null\n * @since 4.0\n */\npublic static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n    if (bag instanceof Unmodifiable) {\n        return bag;\n    }\n    return new UnmodifiableSortedBag<E>(bag);\n}"
            ],
            [
                "transformingSortedBag",
                "org.apache.commons.collections4.bag",
                "TransformedSortedBag",
                "/**\n * Factory method to create a transforming sorted bag.\n * <p>\n * If there are any elements already in the bag being decorated, they\n * are NOT transformed. Contrast this with {@link #transformedSortedBag(SortedBag, Transformer)}.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed SortedBag\n * @throws NullPointerException if bag or transformer is null\n * @since 4.0\n */\npublic static <E> TransformedSortedBag<E> transformingSortedBag(final SortedBag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n    return new TransformedSortedBag<E>(bag, transformer);\n}"
            ],
            [
                "transformedSortedBag",
                "org.apache.commons.collections4.bag",
                "TransformedSortedBag",
                "/**\n * Factory method to create a transforming sorted bag that will transform\n * existing contents of the specified sorted bag.\n * <p>\n * If there are any elements already in the bag being decorated, they\n * will be transformed by this method.\n * Contrast this with {@link #transformingSortedBag(SortedBag, Transformer)}.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed SortedBag\n * @throws NullPointerException if bag or transformer is null\n * @since 4.0\n */\npublic static <E> TransformedSortedBag<E> transformedSortedBag(final SortedBag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n    final TransformedSortedBag<E> decorated = new TransformedSortedBag<E>(bag, transformer);\n    if (bag.size() > 0) {\n        // bag is type E\n        @SuppressWarnings(\"unchecked\")\n        final E[] // NOPMD - false positive for generics\n        values = (E[]) bag.toArray();\n        bag.clear();\n        for (final E value : values) {\n            decorated.decorated().add(transformer.transform(value));\n        }\n    }\n    return decorated;\n}"
            ],
            [
                "predicatedBag",
                "org.apache.commons.collections4.bag",
                "PredicatedBag",
                "/**\n * Factory method to create a predicated (validating) bag.\n * <p>\n * If there are any elements already in the bag being decorated, they\n * are validated.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @param predicate  the predicate to use for validation, must not be null\n * @return a new predicated Bag\n * @throws NullPointerException if bag or predicate is null\n * @throws IllegalArgumentException if the bag contains invalid elements\n * @since 4.0\n */\npublic static <E> PredicatedBag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n    return new PredicatedBag<E>(bag, predicate);\n}"
            ],
            [
                "synchronizedSortedBag",
                "org.apache.commons.collections4.bag",
                "SynchronizedSortedBag",
                "/**\n * Factory method to create a synchronized sorted bag.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @return a new synchronized SortedBag\n * @throws NullPointerException if bag is null\n * @since 4.0\n */\npublic static <E> SynchronizedSortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n    return new SynchronizedSortedBag<E>(bag);\n}"
            ],
            [
                "collectionSortedBag",
                "org.apache.commons.collections4.bag",
                "CollectionSortedBag",
                "/**\n * Factory method to create a sorted bag that complies to the Collection contract.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the sorted bag to decorate, must not be null\n * @return a SortedBag that complies to the Collection contract\n * @throws NullPointerException if bag is null\n */\npublic static <E> SortedBag<E> collectionSortedBag(final SortedBag<E> bag) {\n    return new CollectionSortedBag<E>(bag);\n}"
            ],
            [
                "transformingBag",
                "org.apache.commons.collections4.bag",
                "TransformedBag",
                "/**\n * Factory method to create a transforming bag.\n * <p>\n * If there are any elements already in the bag being decorated, they\n * are NOT transformed. Contrast this with {@link #transformedBag(Bag, Transformer)}.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed Bag\n * @throws NullPointerException if bag or transformer is null\n * @since 4.0\n */\npublic static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n    return new TransformedBag<E>(bag, transformer);\n}"
            ],
            [
                "transformedBag",
                "org.apache.commons.collections4.bag",
                "TransformedBag",
                "/**\n * Factory method to create a transforming bag that will transform\n * existing contents of the specified bag.\n * <p>\n * If there are any elements already in the bag being decorated, they\n * will be transformed by this method.\n * Contrast this with {@link #transformingBag(Bag, Transformer)}.\n *\n * @param <E> the type of the elements in the bag\n * @param bag  the bag to decorate, must not be null\n * @param transformer  the transformer to use for conversion, must not be null\n * @return a new transformed Bag\n * @throws NullPointerException if bag or transformer is null\n * @since 4.0\n */\npublic static <E> Bag<E> transformedBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n    final TransformedBag<E> decorated = new TransformedBag<E>(bag, transformer);\n    if (bag.size() > 0) {\n        // Bag is of type E\n        @SuppressWarnings(\"unchecked\")\n        final E[] // NOPMD - false positive for generics\n        values = (E[]) bag.toArray();\n        bag.clear();\n        for (final E value : values) {\n            decorated.decorated().add(transformer.transform(value));\n        }\n    }\n    return decorated;\n}"
            ],
            [
                "predicatedMultiSet",
                "org.apache.commons.collections4.multiset",
                "PredicatedMultiSet",
                "/**\n * Factory method to create a predicated (validating) multiset.\n * <p>\n * If there are any elements already in the multiset being decorated, they\n * are validated.\n *\n * @param <E> the type of the elements in the multiset\n * @param multiset  the multiset to decorate, must not be null\n * @param predicate  the predicate to use for validation, must not be null\n * @return a new predicated MultiSet\n * @throws NullPointerException if multiset or predicate is null\n * @throws IllegalArgumentException if the multiset contains invalid elements\n */\npublic static <E> PredicatedMultiSet<E> predicatedMultiSet(final MultiSet<E> multiset, final Predicate<? super E> predicate) {\n    return new PredicatedMultiSet<E>(multiset, predicate);\n}"
            ],
            [
                "unmodifiableMultiSet",
                "org.apache.commons.collections4.multiset",
                "UnmodifiableMultiSet",
                "/**\n * Factory method to create an unmodifiable multiset.\n * <p>\n * If the multiset passed in is already unmodifiable, it is returned.\n *\n * @param <E>  the type of the elements in the multiset\n * @param multiset  the multiset to decorate, may not be null\n * @return an unmodifiable MultiSet\n * @throws NullPointerException if multiset is null\n */\npublic static <E> MultiSet<E> unmodifiableMultiSet(final MultiSet<? extends E> multiset) {\n    if (multiset instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final MultiSet<E> tmpMultiSet = (MultiSet<E>) multiset;\n        return tmpMultiSet;\n    }\n    return new UnmodifiableMultiSet<E>(multiset);\n}"
            ],
            [
                "synchronizedMultiSet",
                "org.apache.commons.collections4.multiset",
                "SynchronizedMultiSet",
                "/**\n * Factory method to create a synchronized multiset.\n *\n * @param <E> the type of the elements in the multiset\n * @param multiset  the multiset to decorate, must not be null\n * @return a new synchronized MultiSet\n * @throws NullPointerException if multiset is null\n */\npublic static <E> SynchronizedMultiSet<E> synchronizedMultiSet(final MultiSet<E> multiset) {\n    return new SynchronizedMultiSet<E>(multiset);\n}"
            ],
            [
                "synchronizedBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns a synchronized (thread-safe) bag backed by the given bag. In\n * order to guarantee serial access, it is critical that all access to the\n * backing bag is accomplished through the returned bag.\n * <p>\n * It is imperative that the user manually synchronize on the returned bag\n * when iterating over it:\n *\n * <pre>\n * Bag bag = BagUtils.synchronizedBag(new HashBag());\n * ...\n * synchronized(bag) {\n *     Iterator i = bag.iterator(); // Must be in synchronized block\n *     while (i.hasNext())\n *         foo(i.next());\n *     }\n * }\n * </pre>\n *\n * Failure to follow this advice may result in non-deterministic behavior.\n *\n * @param <E> the element type\n * @param bag the bag to synchronize, must not be null\n * @return a synchronized bag backed by that bag\n * @throws NullPointerException if the Bag is null\n */\npublic static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n    return SynchronizedBag.synchronizedBag(bag);\n}"
            ],
            [
                "unmodifiableBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * Returns an unmodifiable view of the given bag. Any modification attempts\n * to the returned bag will raise an {@link UnsupportedOperationException}.\n *\n * @param <E> the element type\n * @param bag the bag whose unmodifiable view is to be returned, must not be null\n * @return an unmodifiable view of that bag\n * @throws NullPointerException if the Bag is null\n */\npublic static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n    return UnmodifiableBag.unmodifiableBag(bag);\n}"
            ],
            [
                "predicatedBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * Returns a predicated (validating) bag backed by the given bag.\n * <p>\n * Only objects that pass the test in the given predicate can be added to\n * the bag. Trying to add an invalid object results in an\n * IllegalArgumentException. It is important not to use the original bag\n * after invoking this method, as it is a backdoor for adding invalid\n * objects.\n *\n * @param <E> the element type\n * @param bag the bag to predicate, must not be null\n * @param predicate the predicate for the bag, must not be null\n * @return a predicated bag backed by the given bag\n * @throws NullPointerException if the Bag or Predicate is null\n */\npublic static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n    return PredicatedBag.predicatedBag(bag, predicate);\n}"
            ],
            [
                "transformingBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * Returns a transformed bag backed by the given bag.\n * <p>\n * Each object is passed through the transformer as it is added to the Bag.\n * It is important not to use the original bag after invoking this method,\n * as it is a backdoor for adding untransformed objects.\n * <p>\n * Existing entries in the specified bag will not be transformed.\n * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n *\n * @param <E> the element type\n * @param bag the bag to predicate, must not be null\n * @param transformer the transformer for the bag, must not be null\n * @return a transformed bag backed by the given bag\n * @throws NullPointerException if the Bag or Transformer is null\n */\npublic static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n    return TransformedBag.transformingBag(bag, transformer);\n}"
            ],
            [
                "collectionBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * Returns a bag that complies to the Collection contract, backed by the given bag.\n *\n * @param <E> the element type\n * @param bag the bag to decorate, must not be null\n * @return a Bag that complies to the Collection contract\n * @throws NullPointerException if bag is null\n * @since 4.0\n */\npublic static <E> Bag<E> collectionBag(final Bag<E> bag) {\n    return CollectionBag.collectionBag(bag);\n}"
            ],
            [
                "synchronizedSortedBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "//-----------------------------------------------------------------------\n/**\n * Returns a synchronized (thread-safe) sorted bag backed by the given\n * sorted bag. In order to guarantee serial access, it is critical that all\n * access to the backing bag is accomplished through the returned bag.\n * <p>\n * It is imperative that the user manually synchronize on the returned bag\n * when iterating over it:\n *\n * <pre>\n * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n * ...\n * synchronized(bag) {\n *     Iterator i = bag.iterator(); // Must be in synchronized block\n *     while (i.hasNext())\n *         foo(i.next());\n *     }\n * }\n * </pre>\n *\n * Failure to follow this advice may result in non-deterministic behavior.\n *\n * @param <E> the element type\n * @param bag the bag to synchronize, must not be null\n * @return a synchronized bag backed by that bag\n * @throws NullPointerException if the SortedBag is null\n */\npublic static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n    return SynchronizedSortedBag.synchronizedSortedBag(bag);\n}"
            ],
            [
                "unmodifiableSortedBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * Returns an unmodifiable view of the given sorted bag. Any modification\n * attempts to the returned bag will raise an\n * {@link UnsupportedOperationException}.\n *\n * @param <E> the element type\n * @param bag the bag whose unmodifiable view is to be returned, must not be null\n * @return an unmodifiable view of that bag\n * @throws NullPointerException if the SortedBag is null\n */\npublic static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n    return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n}"
            ],
            [
                "predicatedSortedBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * Returns a predicated (validating) sorted bag backed by the given sorted\n * bag.\n * <p>\n * Only objects that pass the test in the given predicate can be added to\n * the bag. Trying to add an invalid object results in an\n * IllegalArgumentException. It is important not to use the original bag\n * after invoking this method, as it is a backdoor for adding invalid\n * objects.\n *\n * @param <E> the element type\n * @param bag the sorted bag to predicate, must not be null\n * @param predicate the predicate for the bag, must not be null\n * @return a predicated bag backed by the given bag\n * @throws NullPointerException if the SortedBag or Predicate is null\n */\npublic static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag, final Predicate<? super E> predicate) {\n    return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n}"
            ],
            [
                "transformingSortedBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * Returns a transformed sorted bag backed by the given bag.\n * <p>\n * Each object is passed through the transformer as it is added to the Bag.\n * It is important not to use the original bag after invoking this method,\n * as it is a backdoor for adding untransformed objects.\n * <p>\n * Existing entries in the specified bag will not be transformed.\n * If you want that behaviour, see\n * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n *\n * @param <E> the element type\n * @param bag the bag to predicate, must not be null\n * @param transformer the transformer for the bag, must not be null\n * @return a transformed bag backed by the given bag\n * @throws NullPointerException if the Bag or Transformer is null\n */\npublic static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n    return TransformedSortedBag.transformingSortedBag(bag, transformer);\n}"
            ],
            [
                "emptyBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * Get an empty <code>Bag</code>.\n *\n * @param <E> the element type\n * @return an empty Bag\n */\n// OK, empty bag is compatible with any type\n@SuppressWarnings(\"unchecked\")\npublic static <E> Bag<E> emptyBag() {\n    return (Bag<E>) EMPTY_BAG;\n}"
            ],
            [
                "emptySortedBag",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * Get an empty <code>SortedBag</code>.\n *\n * @param <E> the element type\n * @return an empty sorted Bag\n */\n// OK, empty bag is compatible with any type\n@SuppressWarnings(\"unchecked\")\npublic static <E> SortedBag<E> emptySortedBag() {\n    return (SortedBag<E>) EMPTY_SORTED_BAG;\n}"
            ],
            [
                "resettableEmptyListIterator",
                "org.apache.commons.collections4.iterators",
                "EmptyListIterator",
                "/**\n * Get a typed instance of the iterator.\n * @param <E> the element type\n * @return {@link ResettableListIterator}<E>\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> ResettableListIterator<E> resettableEmptyListIterator() {\n    return (ResettableListIterator<E>) RESETTABLE_INSTANCE;\n}"
            ],
            [
                "emptyListIterator",
                "org.apache.commons.collections4.iterators",
                "EmptyListIterator",
                "/**\n * Get a typed instance of the iterator.\n * @param <E> the element type\n * @return {@link ListIterator}<E>\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> ListIterator<E> emptyListIterator() {\n    return (ListIterator<E>) INSTANCE;\n}"
            ],
            [
                "unmodifiableOrderedMapIterator",
                "org.apache.commons.collections4.iterators",
                "UnmodifiableOrderedMapIterator",
                "//-----------------------------------------------------------------------\n/**\n * Decorates the specified iterator such that it cannot be modified.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param iterator  the iterator to decorate\n * @return a new unmodifiable ordered map iterator\n * @throws NullPointerException if the iterator is null\n */\npublic static <K, V> OrderedMapIterator<K, V> unmodifiableOrderedMapIterator(final OrderedMapIterator<K, ? extends V> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"OrderedMapIterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final OrderedMapIterator<K, V> tmpIterator = (OrderedMapIterator<K, V>) iterator;\n        return tmpIterator;\n    }\n    return new UnmodifiableOrderedMapIterator<K, V>(iterator);\n}"
            ],
            [
                "unmodifiableIterator",
                "org.apache.commons.collections4.iterators",
                "UnmodifiableIterator",
                "//-----------------------------------------------------------------------\n/**\n * Decorates the specified iterator such that it cannot be modified.\n * <p>\n * If the iterator is already unmodifiable it is returned directly.\n *\n * @param <E>  the element type\n * @param iterator  the iterator to decorate\n * @return a new unmodifiable iterator\n * @throws NullPointerException if the iterator is null\n */\npublic static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final Iterator<E> tmpIterator = (Iterator<E>) iterator;\n        return tmpIterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}"
            ],
            [
                "peekingIterator",
                "org.apache.commons.collections4.iterators",
                "PeekingIterator",
                "//-----------------------------------------------------------------------\n/**\n * Decorates the specified iterator to support one-element lookahead.\n * <p>\n * If the iterator is already a {@link PeekingIterator} it is returned directly.\n *\n * @param <E>  the element type\n * @param iterator  the iterator to decorate\n * @return a new peeking iterator\n * @throws NullPointerException if the iterator is null\n */\npublic static <E> PeekingIterator<E> peekingIterator(final Iterator<? extends E> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof PeekingIterator<?>) {\n        // safe cast\n        @SuppressWarnings(\"unchecked\")\n        final PeekingIterator<E> it = (PeekingIterator<E>) iterator;\n        return it;\n    }\n    return new PeekingIterator<E>(iterator);\n}"
            ],
            [
                "emptyMapIterator",
                "org.apache.commons.collections4.iterators",
                "EmptyMapIterator",
                "/**\n * Get a typed instance of the iterator.\n * @param <K> the key type\n * @param <V> the value type\n * @return {@link MapIterator}<K, V>\n */\n@SuppressWarnings(\"unchecked\")\npublic static <K, V> MapIterator<K, V> emptyMapIterator() {\n    return (MapIterator<K, V>) INSTANCE;\n}"
            ],
            [
                "emptyOrderedIterator",
                "org.apache.commons.collections4.iterators",
                "EmptyOrderedIterator",
                "/**\n * Typed instance of the iterator.\n * @param <E> the element type\n * @return OrderedIterator<E>\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> OrderedIterator<E> emptyOrderedIterator() {\n    return (OrderedIterator<E>) INSTANCE;\n}"
            ],
            [
                "umodifiableListIterator",
                "org.apache.commons.collections4.iterators",
                "UnmodifiableListIterator",
                "//-----------------------------------------------------------------------\n/**\n * Decorates the specified iterator such that it cannot be modified.\n *\n * @param <E>  the element type\n * @param iterator  the iterator to decorate\n * @return a new unmodifiable list iterator\n * @throws NullPointerException if the iterator is null\n */\npublic static <E> ListIterator<E> umodifiableListIterator(final ListIterator<? extends E> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"ListIterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final ListIterator<E> tmpIterator = (ListIterator<E>) iterator;\n        return tmpIterator;\n    }\n    return new UnmodifiableListIterator<E>(iterator);\n}"
            ],
            [
                "emptyOrderedMapIterator",
                "org.apache.commons.collections4.iterators",
                "EmptyOrderedMapIterator",
                "/**\n * Get a typed instance of the iterator.\n * @param <K> the key type\n * @param <V> the value type\n * @return {@link OrderedMapIterator}<K, V>\n */\n@SuppressWarnings(\"unchecked\")\npublic static <K, V> OrderedMapIterator<K, V> emptyOrderedMapIterator() {\n    return (OrderedMapIterator<K, V>) INSTANCE;\n}"
            ],
            [
                "unmodifiableMapIterator",
                "org.apache.commons.collections4.iterators",
                "UnmodifiableMapIterator",
                "//-----------------------------------------------------------------------\n/**\n * Decorates the specified iterator such that it cannot be modified.\n *\n * @param <K>  the key type\n * @param <V>  the value type\n * @param iterator  the iterator to decorate\n * @return a new unmodifiable map iterator\n * @throws NullPointerException if the iterator is null\n */\npublic static <K, V> MapIterator<K, V> unmodifiableMapIterator(final MapIterator<? extends K, ? extends V> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"MapIterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        // safe to upcast\n        @SuppressWarnings(\"unchecked\")\n        final MapIterator<K, V> tmpIterator = (MapIterator<K, V>) iterator;\n        return tmpIterator;\n    }\n    return new UnmodifiableMapIterator<K, V>(iterator);\n}"
            ],
            [
                "resettableEmptyIterator",
                "org.apache.commons.collections4.iterators",
                "EmptyIterator",
                "/**\n * Get a typed resettable empty iterator instance.\n * @param <E> the element type\n * @return ResettableIterator<E>\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> ResettableIterator<E> resettableEmptyIterator() {\n    return (ResettableIterator<E>) RESETTABLE_INSTANCE;\n}"
            ],
            [
                "emptyIterator",
                "org.apache.commons.collections4.iterators",
                "EmptyIterator",
                "/**\n * Get a typed empty iterator instance.\n * @param <E> the element type\n * @return Iterator<E>\n */\n@SuppressWarnings(\"unchecked\")\npublic static <E> Iterator<E> emptyIterator() {\n    return (Iterator<E>) INSTANCE;\n}"
            ],
            [
                "pushbackIterator",
                "org.apache.commons.collections4.iterators",
                "PushbackIterator",
                "//-----------------------------------------------------------------------\n/**\n * Decorates the specified iterator to support one-element lookahead.\n * <p>\n * If the iterator is already a {@link PushbackIterator} it is returned directly.\n *\n * @param <E>  the element type\n * @param iterator  the iterator to decorate\n * @return a new peeking iterator\n * @throws NullPointerException if the iterator is null\n */\npublic static <E> PushbackIterator<E> pushbackIterator(final Iterator<? extends E> iterator) {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof PushbackIterator<?>) {\n        // safe cast\n        @SuppressWarnings(\"unchecked\")\n        final PushbackIterator<E> it = (PushbackIterator<E>) iterator;\n        return it;\n    }\n    return new PushbackIterator<E>(iterator);\n}"
            ],
            [
                "readableMap",
                "org.apache.commons.collections4",
                "SplitMapUtils",
                "//-----------------------------------------------------------------------\n/**\n * Get the specified {@link Get} as an instance of {@link IterableMap}.\n * If <code>get</code> implements {@link IterableMap} directly, no conversion will take place.\n * If <code>get</code> implements {@link Map} but not {@link IterableMap} it will be decorated.\n * Otherwise an {@link Unmodifiable} {@link IterableMap} will be returned.\n * @param <K> the key type\n * @param <V> the value type\n * @param get to wrap, must not be null\n * @return {@link IterableMap}\n * @throws NullPointerException if the argument is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <K, V> IterableMap<K, V> readableMap(final Get<K, V> get) {\n    if (get == null) {\n        throw new NullPointerException(\"Get must not be null\");\n    }\n    if (get instanceof Map) {\n        return get instanceof IterableMap ? ((IterableMap<K, V>) get) : MapUtils.iterableMap((Map<K, V>) get);\n    }\n    return new WrappedGet<K, V>(get);\n}"
            ],
            [
                "writableMap",
                "org.apache.commons.collections4",
                "SplitMapUtils",
                "/**\n * Get the specified {@link Put} as an instanceof {@link Map}.\n * If <code>put</code> implements {@link Map} directly, no conversion will take place.\n * Otherwise a <em>write-only</em> {@link Map} will be returned.  On such a {@link Map}\n * it is recommended that the result of #put(K, V) be discarded as it likely will not\n * match <code>V</code> at runtime.\n *\n * @param <K> the key type\n * @param <V> the element type\n * @param put to wrap, must not be null\n * @return {@link Map}\n * @throws NullPointerException if the argument is null\n */\n@SuppressWarnings(\"unchecked\")\npublic static <K, V> Map<K, V> writableMap(final Put<K, V> put) {\n    if (put == null) {\n        throw new NullPointerException(\"Put must not be null\");\n    }\n    if (put instanceof Map) {\n        return (Map<K, V>) put;\n    }\n    return new WrappedPut<K, V>(put);\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "EMPTY_ITERATOR",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "// validation is done in this class in certain cases because the\n// public classes allow invalid states\n/**\n * An iterator over no elements.\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final ResettableIterator EMPTY_ITERATOR = EmptyIterator.RESETTABLE_INSTANCE;"
            ],
            [
                "EMPTY_LIST_ITERATOR",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * A list iterator over no elements.\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final ResettableListIterator EMPTY_LIST_ITERATOR = EmptyListIterator.RESETTABLE_INSTANCE;"
            ],
            [
                "EMPTY_ORDERED_ITERATOR",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * An ordered iterator over no elements.\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final OrderedIterator EMPTY_ORDERED_ITERATOR = EmptyOrderedIterator.INSTANCE;"
            ],
            [
                "EMPTY_MAP_ITERATOR",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * A map iterator over no elements.\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final MapIterator EMPTY_MAP_ITERATOR = EmptyMapIterator.INSTANCE;"
            ],
            [
                "EMPTY_ORDERED_MAP_ITERATOR",
                "org.apache.commons.collections4",
                "IteratorUtils",
                "/**\n * An ordered map iterator over no elements.\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final OrderedMapIterator EMPTY_ORDERED_MAP_ITERATOR = EmptyOrderedMapIterator.INSTANCE;"
            ],
            [
                "NATURAL_COMPARATOR",
                "org.apache.commons.collections4",
                "ComparatorUtils",
                "/**\n * Comparator for natural sort order.\n *\n * @see ComparableComparator#comparableComparator()\n */\n// explicit type needed for Java 1.5 compilation\n@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\npublic static final Comparator NATURAL_COMPARATOR = ComparableComparator.<Comparable>comparableComparator();"
            ],
            [
                "EMPTY_MULTI_VALUED_MAP",
                "org.apache.commons.collections4",
                "MultiMapUtils",
                "/**\n * An empty {@link UnmodifiableMultiValuedMap}.\n */\n@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\npublic static final MultiValuedMap EMPTY_MULTI_VALUED_MAP = UnmodifiableMultiValuedMap.unmodifiableMultiValuedMap(new ArrayListValuedHashMap(0, 0));"
            ],
            [
                "EMPTY_SORTED_MAP",
                "org.apache.commons.collections4",
                "MapUtils",
                "/**\n * An empty unmodifiable sorted map.\n * This is not provided in the JDK.\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final SortedMap EMPTY_SORTED_MAP = UnmodifiableSortedMap.unmodifiableSortedMap(new TreeMap<Object, Object>());"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "DefaultEquator",
                "/**\n * Static instance\n */\n// the static instance works for all types\n@SuppressWarnings(\"rawtypes\")\npublic static final DefaultEquator INSTANCE = new DefaultEquator<Object>();"
            ],
            [
                "HASHCODE_NULL",
                "org.apache.commons.collections4.functors",
                "DefaultEquator",
                "/**\n * Hashcode used for <code>null</code> objects.\n */\npublic static final int HASHCODE_NULL = -1;"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "ExceptionClosure",
                "/**\n * Singleton predicate instance\n */\n// the static instance works for all types\n@SuppressWarnings(\"rawtypes\")\npublic static final Closure INSTANCE = new ExceptionClosure<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "NOPClosure",
                "/**\n * Singleton predicate instance\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final Closure INSTANCE = new NOPClosure<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "NullPredicate",
                "/**\n * Singleton predicate instance\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final Predicate INSTANCE = new NullPredicate<Object>();"
            ],
            [
                "NULL_INSTANCE",
                "org.apache.commons.collections4.functors",
                "ConstantTransformer",
                "/**\n * Returns null each time\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final Transformer NULL_INSTANCE = new ConstantTransformer<Object, Object>(null);"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "ExceptionTransformer",
                "/**\n * Singleton predicate instance\n */\n// the static instance works for all types\n@SuppressWarnings(\"rawtypes\")\npublic static final Transformer INSTANCE = new ExceptionTransformer<Object, Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "NOPTransformer",
                "/**\n * Singleton predicate instance\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final Transformer INSTANCE = new NOPTransformer<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "ExceptionFactory",
                "/**\n * Singleton predicate instance\n */\n// the static instance works for all types\n@SuppressWarnings(\"rawtypes\")\npublic static final Factory INSTANCE = new ExceptionFactory<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "ExceptionPredicate",
                "/**\n * Singleton predicate instance\n */\n// the static instance works for all types\n@SuppressWarnings(\"rawtypes\")\npublic static final Predicate INSTANCE = new ExceptionPredicate<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "FalsePredicate",
                "/**\n * Singleton predicate instance\n */\n// the static instance works for all types\n@SuppressWarnings(\"rawtypes\")\npublic static final Predicate INSTANCE = new FalsePredicate<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "CloneTransformer",
                "/**\n * Singleton predicate instance\n */\n// the singleton instance works for all types\n@SuppressWarnings(\"rawtypes\")\npublic static final Transformer INSTANCE = new CloneTransformer<Object>();"
            ],
            [
                "NULL_INSTANCE",
                "org.apache.commons.collections4.functors",
                "ConstantFactory",
                "/**\n * Returns null each time\n */\n// The null factory works for all object types\n@SuppressWarnings(\"rawtypes\")\npublic static final Factory NULL_INSTANCE = new ConstantFactory<Object>(null);"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "TruePredicate",
                "/**\n * Singleton predicate instance\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final Predicate INSTANCE = new TruePredicate<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.functors",
                "NotNullPredicate",
                "/**\n * Singleton predicate instance\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final Predicate INSTANCE = new NotNullPredicate<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.comparators",
                "ComparableComparator",
                "/**\n * The singleton instance.\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final ComparableComparator INSTANCE = new ComparableComparator();"
            ],
            [
                "EMPTY_COLLECTION",
                "org.apache.commons.collections4",
                "CollectionUtils",
                "/**\n * An empty unmodifiable collection.\n * The JDK provides empty Set and List implementations which could be used for\n * this purpose. However they could be cast to Set or List which might be\n * undesirable. This implementation only implements Collection.\n */\n// we deliberately use the raw type here\n@SuppressWarnings(\"rawtypes\")\npublic static final Collection EMPTY_COLLECTION = UnmodifiableCollection.unmodifiableCollection(new ArrayList<Object>());"
            ],
            [
                "EMPTY_ITERABLE",
                "org.apache.commons.collections4",
                "IterableUtils",
                "/**\n * An empty iterable.\n */\n@SuppressWarnings(\"rawtypes\")\nstatic final FluentIterable EMPTY_ITERABLE = new FluentIterable<Object>() {\n\n    @Override\n    public Iterator<Object> iterator() {\n        return IteratorUtils.emptyIterator();\n    }\n};"
            ],
            [
                "NULL_BIT_KEY",
                "org.apache.commons.collections4.trie",
                "KeyAnalyzer",
                "/**\n * Returned by {@link #bitIndex(Object, int, int, Object, int, int)}\n * if key's bits are all 0.\n */\npublic static final int NULL_BIT_KEY = -1;"
            ],
            [
                "EQUAL_BIT_KEY",
                "org.apache.commons.collections4.trie",
                "KeyAnalyzer",
                "/**\n * Returned by {@link #bitIndex(Object, int, int, Object, int, int)} if key and found key are equal.\n * This is a very very specific case and shouldn't happen on a regular basis.\n */\npublic static final int EQUAL_BIT_KEY = -2;"
            ],
            [
                "OUT_OF_BOUNDS_BIT_KEY",
                "org.apache.commons.collections4.trie",
                "KeyAnalyzer",
                "public static final int OUT_OF_BOUNDS_BIT_KEY = -3;"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.trie.analyzer",
                "StringKeyAnalyzer",
                "/**\n * A singleton instance of {@link StringKeyAnalyzer}.\n */\npublic static final StringKeyAnalyzer INSTANCE = new StringKeyAnalyzer();"
            ],
            [
                "LENGTH",
                "org.apache.commons.collections4.trie.analyzer",
                "StringKeyAnalyzer",
                "/**\n * The number of bits per {@link Character}.\n */\npublic static final int LENGTH = Character.SIZE;"
            ],
            [
                "NO_NEXT_ENTRY",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "protected static final String NO_NEXT_ENTRY = \"No next() entry in the iteration\";"
            ],
            [
                "NO_PREVIOUS_ENTRY",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "protected static final String NO_PREVIOUS_ENTRY = \"No previous() entry in the iteration\";"
            ],
            [
                "REMOVE_INVALID",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "protected static final String REMOVE_INVALID = \"remove() can only be called once after next()\";"
            ],
            [
                "GETKEY_INVALID",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "protected static final String GETKEY_INVALID = \"getKey() can only be called after next() and before remove()\";"
            ],
            [
                "GETVALUE_INVALID",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "protected static final String GETVALUE_INVALID = \"getValue() can only be called after next() and before remove()\";"
            ],
            [
                "SETVALUE_INVALID",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "protected static final String SETVALUE_INVALID = \"setValue() can only be called after next() and before remove()\";"
            ],
            [
                "DEFAULT_CAPACITY",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "/**\n * The default capacity to use\n */\nprotected static final int DEFAULT_CAPACITY = 16;"
            ],
            [
                "DEFAULT_THRESHOLD",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "/**\n * The default threshold to use\n */\nprotected static final int DEFAULT_THRESHOLD = 12;"
            ],
            [
                "DEFAULT_LOAD_FACTOR",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "/**\n * The default load factor to use\n */\nprotected static final float DEFAULT_LOAD_FACTOR = 0.75f;"
            ],
            [
                "MAXIMUM_CAPACITY",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "/**\n * The maximum capacity allowed\n */\nprotected static final int MAXIMUM_CAPACITY = 1 << 30;"
            ],
            [
                "NULL",
                "org.apache.commons.collections4.map",
                "AbstractHashedMap",
                "/**\n * An object for masking null\n */\nprotected static final Object NULL = new Object();"
            ],
            [
                "DEFAULT_MAX_SIZE",
                "org.apache.commons.collections4.map",
                "LRUMap",
                "/**\n * Default maximum size\n */\nprotected static final int DEFAULT_MAX_SIZE = 100;"
            ],
            [
                "EMPTY_MULTISET",
                "org.apache.commons.collections4",
                "MultiSetUtils",
                "/**\n * An empty unmodifiable multiset.\n */\n// OK, empty multiset is compatible with any type\n@SuppressWarnings(\"rawtypes\")\npublic static final MultiSet EMPTY_MULTISET = UnmodifiableMultiSet.unmodifiableMultiSet(new HashMultiSet<Object>());"
            ],
            [
                "EMPTY_SORTED_SET",
                "org.apache.commons.collections4",
                "SetUtils",
                "/**\n * An empty unmodifiable sorted set.\n * This is not provided in the JDK.\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final SortedSet EMPTY_SORTED_SET = UnmodifiableSortedSet.unmodifiableSortedSet(new TreeSet<Object>());"
            ],
            [
                "EMPTY_QUEUE",
                "org.apache.commons.collections4",
                "QueueUtils",
                "/**\n * An empty unmodifiable queue.\n */\n// OK, empty queue is compatible with any type\n@SuppressWarnings(\"rawtypes\")\npublic static final Queue EMPTY_QUEUE = UnmodifiableQueue.unmodifiableQueue(new LinkedList<Object>());"
            ],
            [
                "EMPTY_BAG",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * An empty unmodifiable bag.\n */\n// OK, empty bag is compatible with any type\n@SuppressWarnings(\"rawtypes\")\npublic static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());"
            ],
            [
                "EMPTY_SORTED_BAG",
                "org.apache.commons.collections4",
                "BagUtils",
                "/**\n * An empty unmodifiable sorted bag.\n */\n// OK, empty bag is compatible with any type\n@SuppressWarnings(\"rawtypes\")\npublic static final Bag EMPTY_SORTED_BAG = UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());"
            ],
            [
                "RESETTABLE_INSTANCE",
                "org.apache.commons.collections4.iterators",
                "EmptyListIterator",
                "/**\n * Singleton instance of the iterator.\n * @since 3.1\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final ResettableListIterator RESETTABLE_INSTANCE = new EmptyListIterator<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.iterators",
                "EmptyListIterator",
                "/**\n * Singleton instance of the iterator.\n * @since 2.1.1 and 3.1\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final ListIterator INSTANCE = RESETTABLE_INSTANCE;"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.iterators",
                "EmptyMapIterator",
                "/**\n * Singleton instance of the iterator.\n * @since 3.1\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final MapIterator INSTANCE = new EmptyMapIterator<Object, Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.iterators",
                "EmptyOrderedIterator",
                "/**\n * Singleton instance of the iterator.\n * @since 3.1\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final OrderedIterator INSTANCE = new EmptyOrderedIterator<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.iterators",
                "EmptyOrderedMapIterator",
                "/**\n * Singleton instance of the iterator.\n * @since 3.1\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final OrderedMapIterator INSTANCE = new EmptyOrderedMapIterator<Object, Object>();"
            ],
            [
                "RESETTABLE_INSTANCE",
                "org.apache.commons.collections4.iterators",
                "EmptyIterator",
                "/**\n * Singleton instance of the iterator.\n * @since 3.1\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final ResettableIterator RESETTABLE_INSTANCE = new EmptyIterator<Object>();"
            ],
            [
                "INSTANCE",
                "org.apache.commons.collections4.iterators",
                "EmptyIterator",
                "/**\n * Singleton instance of the iterator.\n * @since 2.1.1 and 3.1\n */\n@SuppressWarnings(\"rawtypes\")\npublic static final Iterator INSTANCE = RESETTABLE_INSTANCE;"
            ]
        ],
        "tokensMethodJavadocValues": [
            [
                "4.0",
                "double"
            ]
        ],
        "tokensMethodArguments": [
            [
                "list",
                "java.util.List",
                "List<T>"
            ],
            [
                "defaultList",
                "java.util.List",
                "List<T>"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "addAll",
                "java.util",
                "List",
                "public abstract boolean addAll(int arg0, Collection<? extends E> arg1)"
            ],
            [
                "iterator",
                "java.util",
                "List",
                "public abstract Iterator<E> iterator()"
            ],
            [
                "retainAll",
                "java.util",
                "List",
                "public abstract boolean retainAll(Collection<? extends Object> arg0)"
            ],
            [
                "spliterator",
                "java.util",
                "List",
                "public default Spliterator<E> spliterator()"
            ],
            [
                "contains",
                "java.util",
                "List",
                "public abstract boolean contains(Object arg0)"
            ],
            [
                "listIterator",
                "java.util",
                "List",
                "public abstract ListIterator<E> listIterator(int arg0)"
            ],
            [
                "get",
                "java.util",
                "List",
                "public abstract E get(int arg0)"
            ],
            [
                "subList",
                "java.util",
                "List",
                "public abstract List<E> subList(int arg0, int arg1)"
            ],
            [
                "indexOf",
                "java.util",
                "List",
                "public abstract int indexOf(Object arg0)"
            ],
            [
                "size",
                "java.util",
                "List",
                "public abstract int size()"
            ],
            [
                "isEmpty",
                "java.util",
                "List",
                "public abstract boolean isEmpty()"
            ],
            [
                "remove",
                "java.util",
                "List",
                "public abstract E remove(int arg0)"
            ],
            [
                "equals",
                "java.util",
                "List",
                "public abstract boolean equals(Object arg0)"
            ],
            [
                "lastIndexOf",
                "java.util",
                "List",
                "public abstract int lastIndexOf(Object arg0)"
            ],
            [
                "removeAll",
                "java.util",
                "List",
                "public abstract boolean removeAll(Collection<? extends Object> arg0)"
            ],
            [
                "listIterator",
                "java.util",
                "List",
                "public abstract ListIterator<E> listIterator()"
            ],
            [
                "toArray",
                "java.util",
                "List",
                "public abstract Object[] toArray()"
            ],
            [
                "set",
                "java.util",
                "List",
                "public abstract E set(int arg0, E arg1)"
            ],
            [
                "add",
                "java.util",
                "List",
                "public abstract boolean add(E arg0)"
            ],
            [
                "containsAll",
                "java.util",
                "List",
                "public abstract boolean containsAll(Collection<? extends Object> arg0)"
            ],
            [
                "addAll",
                "java.util",
                "List",
                "public abstract boolean addAll(Collection<? extends E> arg0)"
            ],
            [
                "toArray",
                "java.util",
                "List",
                "public abstract <T> T[] toArray(T[] arg0)"
            ],
            [
                "remove",
                "java.util",
                "List",
                "public abstract boolean remove(Object arg0)"
            ],
            [
                "hashCode",
                "java.util",
                "List",
                "public abstract int hashCode()"
            ],
            [
                "stream",
                "java.util",
                "Collection",
                "public default Stream<E> stream()"
            ],
            [
                "removeAll",
                "java.util",
                "Collection",
                "public abstract boolean removeAll(Collection<? extends Object> arg0)"
            ],
            [
                "removeIf",
                "java.util",
                "Collection",
                "public default boolean removeIf(Predicate<? super E> arg0)"
            ],
            [
                "parallelStream",
                "java.util",
                "Collection",
                "public default Stream<E> parallelStream()"
            ],
            [
                "hashCode",
                "java.util",
                "Collection",
                "public abstract int hashCode()"
            ],
            [
                "spliterator",
                "java.util",
                "Collection",
                "public default Spliterator<E> spliterator()"
            ],
            [
                "iterator",
                "java.util",
                "Collection",
                "public abstract Iterator<E> iterator()"
            ],
            [
                "remove",
                "java.util",
                "Collection",
                "public abstract boolean remove(Object arg0)"
            ],
            [
                "toArray",
                "java.util",
                "Collection",
                "public abstract Object[] toArray()"
            ],
            [
                "size",
                "java.util",
                "Collection",
                "public abstract int size()"
            ],
            [
                "add",
                "java.util",
                "Collection",
                "public abstract boolean add(E arg0)"
            ],
            [
                "toArray",
                "java.util",
                "Collection",
                "public abstract <T> T[] toArray(T[] arg0)"
            ],
            [
                "toArray",
                "java.util",
                "Collection",
                "public default <T> T[] toArray(IntFunction<T[]> arg0)"
            ],
            [
                "addAll",
                "java.util",
                "Collection",
                "public abstract boolean addAll(Collection<? extends E> arg0)"
            ],
            [
                "containsAll",
                "java.util",
                "Collection",
                "public abstract boolean containsAll(Collection<? extends Object> arg0)"
            ],
            [
                "contains",
                "java.util",
                "Collection",
                "public abstract boolean contains(Object arg0)"
            ],
            [
                "isEmpty",
                "java.util",
                "Collection",
                "public abstract boolean isEmpty()"
            ],
            [
                "equals",
                "java.util",
                "Collection",
                "public abstract boolean equals(Object arg0)"
            ],
            [
                "retainAll",
                "java.util",
                "Collection",
                "public abstract boolean retainAll(Collection<? extends Object> arg0)"
            ],
            [
                "spliterator",
                "java.lang",
                "Iterable",
                "public default Spliterator<T> spliterator()"
            ],
            [
                "iterator",
                "java.lang",
                "Iterable",
                "public abstract Iterator<T> iterator()"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    }
]