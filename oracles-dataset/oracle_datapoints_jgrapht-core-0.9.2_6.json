[ {
  "id" : 26323,
  "oracle" : ";",
  "oracleType" : "PRE",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.alg.isomorphism",
  "className" : "VF2State",
  "javadocTag" : "@param str",
  "methodJavadoc" : "    /**\n     * creates the debug output only if DEBUG is true.\n     *\n     * @param method\n     * @param str\n     */",
  "methodSourceCode" : "protected void showLog(String method, String str){\n    if (!DEBUG) {\n        return;\n    }\n    char[] indent = new char[2 * coreLen];\n    Arrays.fill(indent, ' ');\n    System.out.println((new String(indent)) + method + \"> \" + str);\n}",
  "classJavadoc" : "/**\n * controls the matching between two graphs according to the VF2 algorithm.\n *\n * @param <V> the type of the vertices\n * @param <E> the type of the edges\n *\n * @author Fabian Sp채h\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------------\n * VF2State.java\n * -------------------------\n * (C) Copyright 2015, by Fabian Sp채h and Contributors.\n *\n * Original Author:  Fabian Sp채h\n * Contributor(s):   Rita Dobler\n *\n * $Id$\n *\n * Changes\n * -------\n * 20-Jun-2015 : Initial revision (FS);\n *\n */\npackage org.jgrapht.alg.isomorphism;\n\nimport java.util.*;\n\n\n/**\n * controls the matching between two graphs according to the VF2 algorithm.\n *\n * @param <V> the type of the vertices\n * @param <E> the type of the edges\n *\n * @author Fabian Sp채h\n */\nabstract class VF2State<V, E>\n{\n    public static final int NULL_NODE = -1;\n\n    protected static final boolean DEBUG = false;\n\n    protected int [] core1, core2, in1, in2, out1, out2;\n\n    protected int coreLen, n1, n2, t1BothLen, t2BothLen, t1InLen, t2InLen,\n        t1OutLen, t2OutLen, addedVertex1, addVertex1, addVertex2;\n\n    protected GraphOrdering<V, E> g1, g2;\n\n    protected Comparator<V> vertexComparator;\n    protected Comparator<E> edgeComparator;\n\n    /**\n     * @param g1 GraphOrdering on first graph\n     * @param g2 GraphOrdering on second graph (possible subgraph)\n     * @param vertexComparator comparator for semantic equality of vertices\n     * @param edgeComparator comparator for semantic equality of edges\n     */\n    public VF2State(\n        GraphOrdering<V, E> g1,\n        GraphOrdering<V, E> g2,\n        Comparator<V> vertexComparator,\n        Comparator<E> edgeComparator)\n    {\n        this.g1 = g1;\n        this.g2 = g2;\n        this.vertexComparator = vertexComparator;\n        this.edgeComparator = edgeComparator;\n\n        n1 = g1.getVertexCount();\n        n2 = g2.getVertexCount();\n\n        core1 = new int[n1];\n        in1 = new int[n1];\n        out1 = new int[n1];\n        core2 = new int[n2];\n        in2 = new int[n2];\n        out2 = new int[n2];\n        Arrays.fill(core1, NULL_NODE);\n        Arrays.fill(core2, NULL_NODE);\n\n        coreLen = 0;\n        addedVertex1 = addVertex1 = addVertex2 = NULL_NODE;\n\n        t1BothLen = t2BothLen = t1InLen = t2InLen = t1OutLen = t2OutLen = 0;\n    }\n\n    /**\n     * copy constructor\n     *\n     * @param s\n     */\n    public VF2State(VF2State<V, E> s)\n    {\n        g1 = s.g1;\n        g2 = s.g2;\n\n        core1 = s.core1;\n        core2 = s.core2;\n        in1 = s.in1;\n        in2 = s.in2;\n        out1 = s.out1;\n        out2 = s.out2;\n\n        coreLen = s.coreLen;\n\n        n1 = s.n1;\n        n2 = s.n2;\n\n        t1BothLen = s.t1BothLen;\n        t2BothLen = s.t2BothLen;\n        t1InLen = s.t1InLen;\n        t2InLen = s.t2InLen;\n        t1OutLen = s.t1OutLen;\n        t2OutLen = s.t2OutLen;\n\n        vertexComparator = s.vertexComparator;\n        edgeComparator = s.edgeComparator;\n\n        addVertex1 = s.addVertex1;\n        addVertex2 = s.addVertex2;\n        addedVertex1 = s.addedVertex1;\n    }\n\n    /**\n     * calculates a pair of nodes which may be added to the current matching,\n     * according to the VF2 algorithm.\n     *\n     * @return false, if there are no more pairs left\n     */\n    public boolean nextPair()\n    {\n        if (addVertex2 == NULL_NODE) {\n            addVertex2 = 0;\n        }\n\n        if (addVertex1 == NULL_NODE) {\n            addVertex1 = 0;\n        } else {\n            addVertex1++;\n        }\n\n        // check incoming and outgoing edges\n        if ((t1BothLen > coreLen) && (t2BothLen > coreLen)) {\n            // find minimum for addVertex2 in core2 and t2in/t2out\n            while (\n                (addVertex2 < n2)\n                && ((core2[addVertex2] != NULL_NODE)\n                    || (out2[addVertex2] == 0)\n                    || (in2[addVertex2] == 0)))\n            {\n                addVertex2++;\n                addVertex1 = 0;\n            }\n\n            // find first/next vertex for addVertex1 in core1 and t1in/t1out\n            while (\n                (addVertex1 < n1)\n                && ((core1[addVertex1] != NULL_NODE)\n                    || (out1[addVertex1] == 0)\n                    || (in1[addVertex1] == 0)))\n            {\n                addVertex1++;\n            }\n        }\n\n        // check outgoing edges\n        else if ((t1OutLen > coreLen) && (t2OutLen > coreLen)) {\n            while (\n                (addVertex2 < n2)\n                && ((core2[addVertex2] != NULL_NODE)\n                    || (out2[addVertex2] == 0)))\n            {\n                addVertex2++;\n                addVertex1 = 0;\n            }\n\n            while (\n                (addVertex1 < n1)\n                && ((core1[addVertex1] != NULL_NODE)\n                    || (out1[addVertex1] == 0)))\n            {\n                addVertex1++;\n            }\n        }\n\n        // check incoming edges\n        else if ((t1InLen > coreLen) && (t2InLen > coreLen)) {\n            while (\n                (addVertex2 < n2)\n                && ((core2[addVertex2] != NULL_NODE)\n                    || (in2[addVertex2] == 0)))\n            {\n                addVertex2++;\n                addVertex1 = 0;\n            }\n\n            while (\n                (addVertex1 < n1)\n                && ((core1[addVertex1] != NULL_NODE)\n                    || (in1[addVertex1] == 0)))\n            {\n                addVertex1++;\n            }\n        }\n\n        // check new edges\n        else {\n            while ((addVertex2 < n2) && (core2[addVertex2] != NULL_NODE)) {\n                addVertex2++;\n                addVertex1 = 0;\n            }\n\n            while ((addVertex1 < n1) && (core1[addVertex1] != NULL_NODE)) {\n                addVertex1++;\n            }\n        }\n\n        if ((addVertex1 < n1) && (addVertex2 < n2)) {\n            showLog(\n                \"nextPair\",\n                \"next candidate pair: (\"\n                + g1.getVertex(addVertex1) + \", \"\n                + g2.getVertex(addVertex2) + \")\");\n            return true;\n        }\n\n        // there are no more pairs..\n        showLog(\"nextPair\", \"no more candidate pairs\");\n\n        addVertex1 = addVertex2 = NULL_NODE;\n        return false;\n    }\n\n    /**\n     * adds the pair to the current matching.\n     */\n    public void addPair()\n    {\n        showLog(\n            \"addPair\",\n            \"(\" + g1.getVertex(addVertex1) + \", \"\n            + g2.getVertex(addVertex2) + \") added\");\n\n        coreLen++;\n        addedVertex1 = addVertex1;\n\n        if (in1[addVertex1] == 0) {\n            in1[addVertex1] = coreLen;\n            t1InLen++;\n            if (out1[addVertex1] > 0) {\n                t1BothLen++;\n            }\n        }\n\n        if (out1[addVertex1] == 0) {\n            out1[addVertex1] = coreLen;\n            t1OutLen++;\n            if (in1[addVertex1] > 0) {\n                t1BothLen++;\n            }\n        }\n\n        if (in2[addVertex2] == 0) {\n            in2[addVertex2] = coreLen;\n            t2InLen++;\n            if (out2[addVertex2] > 0) {\n                t2BothLen++;\n            }\n        }\n\n        if (out2[addVertex2] == 0) {\n            out2[addVertex2] = coreLen;\n            t2OutLen++;\n            if (in2[addVertex2] > 0) {\n                t2BothLen++;\n            }\n        }\n\n        core1[addVertex1] = addVertex2;\n        core2[addVertex2] = addVertex1;\n\n        for (int other : g1.getInEdges(addVertex1)) {\n            if (in1[other] == 0) {\n                in1[other] = coreLen;\n                t1InLen++;\n                if (out1[other] > 0) {\n                    t1BothLen++;\n                }\n            }\n        }\n\n        for (int other : g1.getOutEdges(addVertex1)) {\n            if (out1[other] == 0) {\n                out1[other] = coreLen;\n                t1OutLen++;\n                if (in1[other] > 0) {\n                    t1BothLen++;\n                }\n            }\n        }\n\n        for (int other : g2.getInEdges(addVertex2)) {\n            if (in2[other] == 0) {\n                in2[other] = coreLen;\n                t2InLen++;\n                if (out2[other] > 0) {\n                    t2BothLen++;\n                }\n            }\n        }\n\n        for (int other : g2.getOutEdges(addVertex2)) {\n            if (out2[other] == 0) {\n                out2[other] = coreLen;\n                t2OutLen++;\n                if (in2[other] > 0) {\n                    t2BothLen++;\n                }\n            }\n        }\n    }\n\n    /**\n     * @return is the matching already complete?\n     */\n    public boolean isGoal()\n    {\n        return coreLen == n2;\n    }\n\n    /**\n     * @return true, if the already matched vertices of graph1 plus the first\n     * vertex of nextPair are isomorphic to the already matched vertices of\n     * graph2 and the second one vertex of nextPair.\n     */\n    public abstract boolean isFeasiblePair();\n\n    /**\n     * removes the last added pair from the matching\n     */\n    public void backtrack()\n    {\n        int addedVertex2 = core1[addedVertex1];\n\n        showLog(\n            \"backtrack\",\n            \"remove (\" + g1.getVertex(addedVertex1) + \", \"\n            + g2.getVertex(addedVertex2) + \") from the matching\");\n\n        if (in1[addedVertex1] == coreLen) {\n            in1[addedVertex1] = 0;\n        }\n\n        for (int other : g1.getInEdges(addedVertex1)) {\n            if (in1[other] == coreLen) {\n                in1[other] = 0;\n            }\n        }\n\n        if (out1[addedVertex1] == coreLen) {\n            out1[addedVertex1] = 0;\n        }\n\n        for (int other : g1.getOutEdges(addedVertex1)) {\n            if (out1[other] == coreLen) {\n                out1[other] = 0;\n            }\n        }\n\n        if (in2[addedVertex2] == coreLen) {\n            in2[addedVertex2] = 0;\n        }\n\n        for (int other : g2.getInEdges(addedVertex2)) {\n            if (in2[other] == coreLen) {\n                in2[other] = 0;\n            }\n        }\n\n        if (out2[addedVertex2] == coreLen) {\n            out2[addedVertex2] = 0;\n        }\n\n        for (int other : g2.getOutEdges(addedVertex2)) {\n            if (out2[other] == coreLen) {\n                out2[other] = 0;\n            }\n        }\n\n        core1[addedVertex1] = core2[addedVertex2] = NULL_NODE;\n        coreLen--;\n        addedVertex1 = NULL_NODE;\n    }\n\n    /**\n     * checks the vertices v1 and v2 for semantic equivalence\n     *\n     * @param v1\n     * @param v2\n     *\n     * @return v1 and v2 are equivalent\n     */\n    protected boolean areCompatibleVertexes(int v1, int v2)\n    {\n        return (vertexComparator == null)\n            || (vertexComparator.compare(g1.getVertex(v1), g2.getVertex(v2))\n                == 0);\n    }\n\n    /**\n     * checks the edges from v1 to v2 and from u1 to u2 for semantic equivalence\n     *\n     * @param v1\n     * @param v2\n     * @param u1\n     * @param u2\n     *\n     * @return edges are equivalent\n     */\n    protected boolean areCompatibleEdges(int v1, int v2, int u1, int u2)\n    {\n        return (edgeComparator == null)\n            || (edgeComparator.compare(g1.getEdge(v1, v2), g2.getEdge(u1, u2))\n                == 0);\n    }\n\n    public IsomorphicGraphMapping<V, E> getCurrentMapping()\n    {\n        return new IsomorphicGraphMapping<V, E>(g1, g2, core1, core2);\n    }\n\n    public void resetAddVertexes()\n    {\n        addVertex1 = addVertex2 = NULL_NODE;\n    }\n\n    /**\n     * creates the debug output only if DEBUG is true.\n     *\n     * @param method\n     * @param str\n     */\n    protected void showLog(String method, String str)\n    {\n        if (!DEBUG) {\n            return;\n        }\n\n        char [] indent = new char[2 * coreLen];\n        Arrays.fill(indent, ' ');\n        System.out.println((new String(indent)) + method + \"> \" + str);\n    }\n}\n\n// End VF2State.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "method", "java.lang", "String" ], [ "str", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "isGoal", "org.jgrapht.alg.isomorphism", "VF2State", "public boolean isGoal()" ], [ "areCompatibleEdges", "org.jgrapht.alg.isomorphism", "VF2State", "protected boolean areCompatibleEdges(int v1, int v2, int u1, int u2)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "nextPair", "org.jgrapht.alg.isomorphism", "VF2State", "public boolean nextPair()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "areCompatibleVertexes", "org.jgrapht.alg.isomorphism", "VF2State", "protected boolean areCompatibleVertexes(int v1, int v2)" ], [ "isFeasiblePair", "org.jgrapht.alg.isomorphism", "VF2State", "public abstract boolean isFeasiblePair()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getCurrentMapping", "org.jgrapht.alg.isomorphism", "VF2State", "public IsomorphicGraphMapping<V, E> getCurrentMapping()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "length", "java.lang", "String", "public int length()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "core1", "org.jgrapht.alg.isomorphism", "VF2State", "protected int[] core1;" ], [ "core2", "org.jgrapht.alg.isomorphism", "VF2State", "protected int[] core2;" ], [ "in1", "org.jgrapht.alg.isomorphism", "VF2State", "protected int[] in1;" ], [ "in2", "org.jgrapht.alg.isomorphism", "VF2State", "protected int[] in2;" ], [ "out1", "org.jgrapht.alg.isomorphism", "VF2State", "protected int[] out1;" ], [ "out2", "org.jgrapht.alg.isomorphism", "VF2State", "protected int[] out2;" ], [ "coreLen", "org.jgrapht.alg.isomorphism", "VF2State", "protected int coreLen;" ], [ "n1", "org.jgrapht.alg.isomorphism", "VF2State", "protected int n1;" ], [ "n2", "org.jgrapht.alg.isomorphism", "VF2State", "protected int n2;" ], [ "t1BothLen", "org.jgrapht.alg.isomorphism", "VF2State", "protected int t1BothLen;" ], [ "t2BothLen", "org.jgrapht.alg.isomorphism", "VF2State", "protected int t2BothLen;" ], [ "t1InLen", "org.jgrapht.alg.isomorphism", "VF2State", "protected int t1InLen;" ], [ "t2InLen", "org.jgrapht.alg.isomorphism", "VF2State", "protected int t2InLen;" ], [ "t1OutLen", "org.jgrapht.alg.isomorphism", "VF2State", "protected int t1OutLen;" ], [ "t2OutLen", "org.jgrapht.alg.isomorphism", "VF2State", "protected int t2OutLen;" ], [ "addedVertex1", "org.jgrapht.alg.isomorphism", "VF2State", "protected int addedVertex1;" ], [ "addVertex1", "org.jgrapht.alg.isomorphism", "VF2State", "protected int addVertex1;" ], [ "addVertex2", "org.jgrapht.alg.isomorphism", "VF2State", "protected int addVertex2;" ], [ "g1", "org.jgrapht.alg.isomorphism", "VF2State", "protected GraphOrdering<V,E> g1;" ], [ "g2", "org.jgrapht.alg.isomorphism", "VF2State", "protected GraphOrdering<V,E> g2;" ], [ "vertexComparator", "org.jgrapht.alg.isomorphism", "VF2State", "protected Comparator<V> vertexComparator;" ], [ "edgeComparator", "org.jgrapht.alg.isomorphism", "VF2State", "protected Comparator<E> edgeComparator;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 26334,
  "oracle" : ";",
  "oracleType" : "PRE",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.alg.isomorphism",
  "className" : "VF2AbstractIsomorphismInspector",
  "javadocTag" : "@param cacheEdges if true, edges get cached for faster access",
  "methodJavadoc" : "    /**\n     * This implementation of the VF2 algorithm does not support graphs with\n     * multiple edges.\n     *\n     * @param graph1 the first graph\n     * @param graph2 the second graph\n     * @param vertexComparator comparator for semantic equivalence of vertices\n     * @param edgeComparator comparator for semantic equivalence of edges\n     * @param cacheEdges if true, edges get cached for faster access\n     */",
  "methodSourceCode" : "public VF2AbstractIsomorphismInspector(Graph<V, E> graph1, Graph<V, E> graph2, Comparator<V> vertexComparator, Comparator<E> edgeComparator, boolean cacheEdges){\n    if ((graph1 instanceof Multigraph) || (graph2 instanceof Multigraph) || (graph1 instanceof Pseudograph) || (graph2 instanceof Pseudograph) || (graph1 instanceof DirectedMultigraph) || (graph2 instanceof DirectedMultigraph) || (graph1 instanceof DirectedPseudograph) || (graph2 instanceof DirectedPseudograph)) {\n        throw new UnsupportedOperationException(\"graphs with multiple \" + \"edges are not supported\");\n    }\n    if (((graph1 instanceof DirectedGraph) && (graph2 instanceof UndirectedGraph)) || ((graph1 instanceof UndirectedGraph) && (graph2 instanceof DirectedGraph))) {\n        throw new IllegalArgumentException(\"can not match directed with \" + \"undirected graphs\");\n    }\n    this.graph1 = graph1;\n    this.graph2 = graph2;\n    this.vertexComparator = vertexComparator;\n    this.edgeComparator = edgeComparator;\n    this.ordering1 = new GraphOrdering<V, E>(graph1, true, cacheEdges);\n    this.ordering2 = new GraphOrdering<V, E>(graph2, true, cacheEdges);\n}",
  "classJavadoc" : "/**\n     * This implementation of the VF2 algorithm does not support graphs with\n     * multiple edges.\n     *\n     * @param graph1 the first graph\n     * @param graph2 the second graph\n     * @param vertexComparator comparator for semantic equivalence of vertices\n     * @param edgeComparator comparator for semantic equivalence of edges\n     * @param cacheEdges if true, edges get cached for faster access\n     */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------------\n * VF2AbstractIsomorphismInspector.java\n * -------------------------\n * (C) Copyright 2015, by Fabian Sp채h and Contributors.\n *\n * Original Author:  Fabian Sp채h\n * Contributor(s):   Rita Dobler\n *\n * $Id$\n *\n * Changes\n * -------\n * 20-Jun-2015 : Initial revision (FS);\n *\n */\npackage org.jgrapht.alg.isomorphism;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\nimport org.jgrapht.graph.*;\n\n\npublic abstract class VF2AbstractIsomorphismInspector<V, E>\n    implements IsomorphismInspector<V, E>\n{\n    protected Graph<V, E> graph1, graph2;\n\n    protected Comparator<V> vertexComparator;\n    protected Comparator<E> edgeComparator;\n\n    protected GraphOrdering<V, E> ordering1, ordering2;\n\n    /**\n     * This implementation of the VF2 algorithm does not support graphs with\n     * multiple edges.\n     *\n     * @param graph1 the first graph\n     * @param graph2 the second graph\n     * @param vertexComparator comparator for semantic equivalence of vertices\n     * @param edgeComparator comparator for semantic equivalence of edges\n     * @param cacheEdges if true, edges get cached for faster access\n     */\n    public VF2AbstractIsomorphismInspector(\n        Graph<V, E> graph1,\n        Graph<V, E> graph2,\n        Comparator<V> vertexComparator,\n        Comparator<E> edgeComparator,\n        boolean cacheEdges)\n    {\n        if ((graph1 instanceof Multigraph)\n            || (graph2 instanceof Multigraph)\n            || (graph1 instanceof Pseudograph)\n            || (graph2 instanceof Pseudograph)\n            || (graph1 instanceof DirectedMultigraph)\n            || (graph2 instanceof DirectedMultigraph)\n            || (graph1 instanceof DirectedPseudograph)\n            || (graph2 instanceof DirectedPseudograph))\n        {\n            throw new UnsupportedOperationException(\n                \"graphs with multiple \"\n                + \"edges are not supported\");\n        }\n\n        if (((graph1 instanceof DirectedGraph)\n                && (graph2 instanceof UndirectedGraph))\n            || ((graph1 instanceof UndirectedGraph)\n                && (graph2 instanceof DirectedGraph)))\n        {\n            throw new IllegalArgumentException(\n                \"can not match directed with \"\n                + \"undirected graphs\");\n        }\n\n        this.graph1 = graph1;\n        this.graph2 = graph2;\n        this.vertexComparator = vertexComparator;\n        this.edgeComparator = edgeComparator;\n        this.ordering1 = new GraphOrdering<V, E>(graph1, true,\n            cacheEdges);\n        this.ordering2 = new GraphOrdering<V, E>(graph2, true,\n            cacheEdges);\n    }\n\n    public VF2AbstractIsomorphismInspector(\n        Graph<V, E> graph1,\n        Graph<V, E> graph2,\n        Comparator<V> vertexComparator,\n        Comparator<E> edgeComparator)\n    {\n        this(graph1,\n            graph2,\n            vertexComparator,\n            edgeComparator,\n            true);\n    }\n\n    public VF2AbstractIsomorphismInspector(\n        Graph<V, E> graph1,\n        Graph<V, E> graph2,\n        boolean cacheEdges)\n    {\n        this(graph1,\n            graph2,\n            null,\n            null,\n            cacheEdges);\n    }\n\n    public VF2AbstractIsomorphismInspector(\n        Graph<V, E> graph1,\n        Graph<V, E> graph2)\n    {\n        this(graph1,\n            graph2,\n            true);\n    }\n\n    @Override public abstract Iterator<GraphMapping<V, E>> getMappings();\n\n    @Override public boolean isomorphismExists()\n    {\n        Iterator<GraphMapping<V, E>> iter = getMappings();\n        return iter.hasNext();\n    }\n}\n\n// End VF2AbstractIsomorphismInspector.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ [ "2", "int" ], [ "1", "int" ], [ "2", "int" ] ],
  "tokensMethodArguments" : [ [ "graph1", "org.jgrapht.Graph", "Graph<V, E>" ], [ "graph2", "org.jgrapht.Graph", "Graph<V, E>" ], [ "vertexComparator", "java.util.Comparator", "Comparator<V>" ], [ "edgeComparator", "java.util.Comparator", "Comparator<E>" ], [ "cacheEdges", "", "boolean" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getMappings", "org.jgrapht.alg.isomorphism", "VF2AbstractIsomorphismInspector", "public abstract Iterator<GraphMapping<V, E>> getMappings()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "isomorphismExists", "org.jgrapht.alg.isomorphism", "VF2AbstractIsomorphismInspector", "public boolean isomorphismExists()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "removeVertex", "org.jgrapht", "Graph", "public abstract boolean removeVertex(V arg0)" ], [ "getEdgeTarget", "org.jgrapht", "Graph", "public abstract V getEdgeTarget(E arg0)" ], [ "edgesOf", "org.jgrapht", "Graph", "public abstract Set<E> edgesOf(V arg0)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract boolean removeAllEdges(Collection<? extends E> arg0)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> removeAllEdges(V arg0, V arg1)" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract boolean removeEdge(E arg0)" ], [ "getEdgeSource", "org.jgrapht", "Graph", "public abstract V getEdgeSource(E arg0)" ], [ "getEdge", "org.jgrapht", "Graph", "public abstract E getEdge(V arg0, V arg1)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(V arg0, V arg1)" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract E addEdge(V arg0, V arg1)" ], [ "vertexSet", "org.jgrapht", "Graph", "public abstract Set<V> vertexSet()" ], [ "getEdgeWeight", "org.jgrapht", "Graph", "public abstract double getEdgeWeight(E arg0)" ], [ "getAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> getAllEdges(V arg0, V arg1)" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract boolean addEdge(V arg0, V arg1, E arg2)" ], [ "containsVertex", "org.jgrapht", "Graph", "public abstract boolean containsVertex(V arg0)" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract E removeEdge(V arg0, V arg1)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(E arg0)" ], [ "edgeSet", "org.jgrapht", "Graph", "public abstract Set<E> edgeSet()" ], [ "removeAllVertices", "org.jgrapht", "Graph", "public abstract boolean removeAllVertices(Collection<? extends V> arg0)" ], [ "addVertex", "org.jgrapht", "Graph", "public abstract boolean addVertex(V arg0)" ], [ "getEdgeFactory", "org.jgrapht", "Graph", "public abstract EdgeFactory<V, E> getEdgeFactory()" ], [ "compare", "java.util", "Comparator", "public abstract int compare(T arg0, T arg1)" ], [ "equals", "java.util", "Comparator", "public abstract boolean equals(Object arg0)" ], [ "thenComparing", "java.util", "Comparator", "public default <U> Comparator<T> thenComparing(Function<? super T, ? extends U> arg0)" ], [ "thenComparingInt", "java.util", "Comparator", "public default Comparator<T> thenComparingInt(ToIntFunction<? super T> arg0)" ], [ "reversed", "java.util", "Comparator", "public default Comparator<T> reversed()" ], [ "thenComparing", "java.util", "Comparator", "public default <U> Comparator<T> thenComparing(Function<? super T, ? extends U> arg0, Comparator<? super U> arg1)" ], [ "thenComparingDouble", "java.util", "Comparator", "public default Comparator<T> thenComparingDouble(ToDoubleFunction<? super T> arg0)" ], [ "thenComparingLong", "java.util", "Comparator", "public default Comparator<T> thenComparingLong(ToLongFunction<? super T> arg0)" ], [ "thenComparing", "java.util", "Comparator", "public default Comparator<T> thenComparing(Comparator<? super T> arg0)" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "graph1", "org.jgrapht.alg.isomorphism", "VF2AbstractIsomorphismInspector", "protected Graph<V,E> graph1;" ], [ "graph2", "org.jgrapht.alg.isomorphism", "VF2AbstractIsomorphismInspector", "protected Graph<V,E> graph2;" ], [ "vertexComparator", "org.jgrapht.alg.isomorphism", "VF2AbstractIsomorphismInspector", "protected Comparator<V> vertexComparator;" ], [ "edgeComparator", "org.jgrapht.alg.isomorphism", "VF2AbstractIsomorphismInspector", "protected Comparator<E> edgeComparator;" ], [ "ordering1", "org.jgrapht.alg.isomorphism", "VF2AbstractIsomorphismInspector", "protected GraphOrdering<V,E> ordering1;" ], [ "ordering2", "org.jgrapht.alg.isomorphism", "VF2AbstractIsomorphismInspector", "protected GraphOrdering<V,E> ordering2;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 26387,
  "oracle" : "directedGraph == null;",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.alg",
  "className" : "KosarajuStrongConnectivityInspector",
  "javadocTag" : "@throws IllegalArgumentException",
  "methodJavadoc" : "    /**\n     * The constructor of the StrongConnectivityAlgorithm class.\n     *\n     * @param directedGraph the graph to inspect\n     *\n     * @throws IllegalArgumentException\n     */",
  "methodSourceCode" : "public KosarajuStrongConnectivityInspector(DirectedGraph<V, E> directedGraph){\n    if (directedGraph == null) {\n        throw new IllegalArgumentException(\"null not allowed for graph!\");\n    }\n    graph = directedGraph;\n    vertexToVertexData = null;\n    orderedVertices = null;\n    stronglyConnectedSets = null;\n    stronglyConnectedSubgraphs = null;\n}",
  "classJavadoc" : "/**\n * <p>Complements the {@link org.jgrapht.alg.ConnectivityInspector} class with\n * the capability to compute the strongly connected components of a directed\n * graph. The algorithm is implemented after \"Cormen et al: Introduction to\n * agorithms\", Chapter 22.5. It has a running time of O(V + E).</p>\n *\n * <p>Unlike {@link org.jgrapht.alg.ConnectivityInspector}, this class does not\n * implement incremental inspection. The full algorithm is executed at the first\n * call of {@link KosarajuStrongConnectivityInspector#stronglyConnectedSets()}\n * or {@link KosarajuStrongConnectivityInspector#isStronglyConnected()}.</p>\n *\n * @author Christian Soltenborn\n * @author Christian Hammer\n * @since Feb 2, 2005\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* --------------------------\n * StrongConnectivityAlgorithm.java\n * --------------------------\n * (C) Copyright 2005-2008, by Christian Soltenborn and Contributors.\n *\n * Original Author:  Christian Soltenborn\n *\n * $Id$\n *\n * Changes\n * -------\n * 2-Feb-2005 : Initial revision (CS);\n * 5-Feb-2007 : fixed NullPointerException (CS);\n * 1-Apr-2008 : Reduced memory consumption (CS);\n *\n */\npackage org.jgrapht.alg;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\nimport org.jgrapht.alg.interfaces.*;\nimport org.jgrapht.graph.*;\n\n\n/**\n * <p>Complements the {@link org.jgrapht.alg.ConnectivityInspector} class with\n * the capability to compute the strongly connected components of a directed\n * graph. The algorithm is implemented after \"Cormen et al: Introduction to\n * agorithms\", Chapter 22.5. It has a running time of O(V + E).</p>\n *\n * <p>Unlike {@link org.jgrapht.alg.ConnectivityInspector}, this class does not\n * implement incremental inspection. The full algorithm is executed at the first\n * call of {@link KosarajuStrongConnectivityInspector#stronglyConnectedSets()}\n * or {@link KosarajuStrongConnectivityInspector#isStronglyConnected()}.</p>\n *\n * @author Christian Soltenborn\n * @author Christian Hammer\n * @since Feb 2, 2005\n */\npublic class KosarajuStrongConnectivityInspector<V, E>\n    implements StrongConnectivityAlgorithm<V, E>\n{\n    // the graph to compute the strongly connected sets for\n    private final DirectedGraph<V, E> graph;\n\n    // stores the vertices, ordered by their finishing time in first dfs\n    private LinkedList<VertexData<V>> orderedVertices;\n\n    // the result of the computation, cached for future calls\n    private List<Set<V>> stronglyConnectedSets;\n\n    // the result of the computation, cached for future calls\n    private List<DirectedSubgraph<V, E>> stronglyConnectedSubgraphs;\n\n    // maps vertices to their VertexData object\n    private Map<V, VertexData<V>> vertexToVertexData;\n\n    /**\n     * The constructor of the StrongConnectivityAlgorithm class.\n     *\n     * @param directedGraph the graph to inspect\n     *\n     * @throws IllegalArgumentException\n     */\n    public KosarajuStrongConnectivityInspector(\n        DirectedGraph<V, E> directedGraph)\n    {\n        if (directedGraph == null) {\n            throw new IllegalArgumentException(\"null not allowed for graph!\");\n        }\n\n        graph = directedGraph;\n        vertexToVertexData = null;\n        orderedVertices = null;\n        stronglyConnectedSets = null;\n        stronglyConnectedSubgraphs = null;\n    }\n\n    /**\n     * Returns the graph inspected by the StrongConnectivityAlgorithm.\n     *\n     * @return the graph inspected by this StrongConnectivityAlgorithm\n     */\n    public DirectedGraph<V, E> getGraph()\n    {\n        return graph;\n    }\n\n    /**\n     * Returns true if the graph of this <code>\n     * StronglyConnectivityInspector</code> instance is strongly connected.\n     *\n     * @return true if the graph is strongly connected, false otherwise\n     */\n    public boolean isStronglyConnected()\n    {\n        return stronglyConnectedSets().size() == 1;\n    }\n\n    /**\n     * Computes a {@link List} of {@link Set}s, where each set contains vertices\n     * which together form a strongly connected component within the given\n     * graph.\n     *\n     * @return <code>List</code> of <code>Set</code> s containing the strongly\n     * connected components\n     */\n    public List<Set<V>> stronglyConnectedSets()\n    {\n        if (stronglyConnectedSets == null) {\n            orderedVertices = new LinkedList<VertexData<V>>();\n            stronglyConnectedSets = new Vector<Set<V>>();\n\n            // create VertexData objects for all vertices, store them\n            createVertexData();\n\n            // perform the first round of DFS, result is an ordering\n            // of the vertices by decreasing finishing time\n            for (VertexData<V> data : vertexToVertexData.values()) {\n                if (!data.isDiscovered()) {\n                    dfsVisit(graph, data, null);\n                }\n            }\n\n            // 'create' inverse graph (i.e. every edge is reversed)\n            DirectedGraph<V, E> inverseGraph =\n                new EdgeReversedGraph<V, E>(graph);\n\n            // get ready for next dfs round\n            resetVertexData();\n\n            // second dfs round: vertices are considered in decreasing\n            // finishing time order; every tree found is a strongly\n            // connected set\n            for (VertexData<V> data : orderedVertices) {\n                if (!data.isDiscovered()) {\n                    // new strongly connected set\n                    Set<V> set = new HashSet<V>();\n                    stronglyConnectedSets.add(set);\n                    dfsVisit(inverseGraph, data, set);\n                }\n            }\n\n            // clean up for garbage collection\n            orderedVertices = null;\n            vertexToVertexData = null;\n        }\n\n        return stronglyConnectedSets;\n    }\n\n    /**\n     * <p>Computes a list of {@link DirectedSubgraph}s of the given graph. Each\n     * subgraph will represent a strongly connected component and will contain\n     * all vertices of that component. The subgraph will have an edge (u,v) iff\n     * u and v are contained in the strongly connected component.</p>\n     *\n     * <p>NOTE: Calling this method will first execute {@link\n     * KosarajuStrongConnectivityInspector#stronglyConnectedSets()}. If you\n     * don't need subgraphs, use that method.</p>\n     *\n     * @return a list of subgraphs representing the strongly connected\n     * components\n     */\n    public List<DirectedSubgraph<V, E>> stronglyConnectedSubgraphs()\n    {\n        if (stronglyConnectedSubgraphs == null) {\n            List<Set<V>> sets = stronglyConnectedSets();\n            stronglyConnectedSubgraphs =\n                new Vector<DirectedSubgraph<V, E>>(sets.size());\n\n            for (Set<V> set : sets) {\n                stronglyConnectedSubgraphs.add(\n                    new DirectedSubgraph<V, E>(\n                        graph,\n                        set,\n                        null));\n            }\n        }\n\n        return stronglyConnectedSubgraphs;\n    }\n\n    /*\n     * Creates a VertexData object for every vertex in the graph and stores\n     * them\n     * in a HashMap.\n     */\n    private void createVertexData()\n    {\n        vertexToVertexData =\n            new HashMap<V, VertexData<V>>(graph.vertexSet().size());\n\n        for (V vertex : graph.vertexSet()) {\n            vertexToVertexData.put(\n                vertex,\n                new VertexData2<V>(vertex, false, false));\n        }\n    }\n\n    /*\n     * The subroutine of DFS. NOTE: the set is used to distinguish between 1st\n     * and 2nd round of DFS. set == null: finished vertices are stored (1st\n     * round). set != null: all vertices found will be saved in the set (2nd\n     * round)\n     */\n    private void dfsVisit(\n        DirectedGraph<V, E> visitedGraph,\n        VertexData<V> vertexData,\n        Set<V> vertices)\n    {\n        Deque<VertexData<V>> stack = new ArrayDeque<VertexData<V>>();\n        stack.add(vertexData);\n\n        while (!stack.isEmpty()) {\n            VertexData<V> data = stack.removeLast();\n\n            if (!data.isDiscovered()) {\n                data.setDiscovered(true);\n\n                if (vertices != null) {\n                    vertices.add(data.getVertex());\n                }\n\n                stack.add(new VertexData1<V>(data, true, true));\n\n                // follow all edges\n                for (E edge : visitedGraph.outgoingEdgesOf(data.getVertex())) {\n                    VertexData<V> targetData =\n                        vertexToVertexData.get(\n                            visitedGraph.getEdgeTarget(edge));\n\n                    if (!targetData.isDiscovered()) {\n                        // the \"recursion\"\n                        stack.add(targetData);\n                    }\n                }\n            } else if (data.isFinished()) {\n                if (vertices == null) {\n                    orderedVertices.addFirst(data.getFinishedData());\n                }\n            }\n        }\n    }\n\n    /*\n     * Resets all VertexData objects.\n     */\n    private void resetVertexData()\n    {\n        for (VertexData<V> data : vertexToVertexData.values()) {\n            data.setDiscovered(false);\n            data.setFinished(false);\n        }\n    }\n\n    /*\n     * Lightweight class storing some data for every vertex.\n     */\n    private static abstract class VertexData<V>\n    {\n        private byte bitfield;\n\n        private VertexData(\n            boolean discovered,\n            boolean finished)\n        {\n            this.bitfield = 0;\n            setDiscovered(discovered);\n            setFinished(finished);\n        }\n\n        private boolean isDiscovered()\n        {\n            return (bitfield & 1) == 1;\n        }\n\n        private boolean isFinished()\n        {\n            return (bitfield & 2) == 2;\n        }\n\n        private void setDiscovered(boolean discovered)\n        {\n            if (discovered) {\n                bitfield |= 1;\n            } else {\n                bitfield &= ~1;\n            }\n        }\n\n        private void setFinished(boolean finished)\n        {\n            if (finished) {\n                bitfield |= 2;\n            } else {\n                bitfield &= ~2;\n            }\n        }\n\n        abstract VertexData<V> getFinishedData();\n\n        abstract V getVertex();\n    }\n\n    private static final class VertexData1<V>\n        extends VertexData<V>\n    {\n        private final VertexData<V> finishedData;\n\n        private VertexData1(\n            VertexData<V> finishedData,\n            boolean discovered,\n            boolean finished)\n        {\n            super(discovered, finished);\n            this.finishedData = finishedData;\n        }\n\n        @Override VertexData<V> getFinishedData()\n        {\n            return finishedData;\n        }\n\n        @Override V getVertex()\n        {\n            return null;\n        }\n    }\n\n    private static final class VertexData2<V>\n        extends VertexData<V>\n    {\n        private final V vertex;\n\n        private VertexData2(\n            V vertex,\n            boolean discovered,\n            boolean finished)\n        {\n            super(discovered, finished);\n            this.vertex = vertex;\n        }\n\n        @Override VertexData<V> getFinishedData()\n        {\n            return null;\n        }\n\n        @Override V getVertex()\n        {\n            return vertex;\n        }\n    }\n}\n\n// End StrongConnectivityAlgorithm.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "directedGraph", "org.jgrapht.DirectedGraph", "DirectedGraph<V, E>" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getGraph", "org.jgrapht.alg", "KosarajuStrongConnectivityInspector", "public DirectedGraph<V, E> getGraph()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "stronglyConnectedSubgraphs", "org.jgrapht.alg", "KosarajuStrongConnectivityInspector", "public List<DirectedSubgraph<V, E>> stronglyConnectedSubgraphs()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "stronglyConnectedSets", "org.jgrapht.alg", "KosarajuStrongConnectivityInspector", "public List<Set<V>> stronglyConnectedSets()" ], [ "isStronglyConnected", "org.jgrapht.alg", "KosarajuStrongConnectivityInspector", "public boolean isStronglyConnected()" ], [ "outDegreeOf", "org.jgrapht", "DirectedGraph", "public abstract int outDegreeOf(V arg0)" ], [ "incomingEdgesOf", "org.jgrapht", "DirectedGraph", "public abstract Set<E> incomingEdgesOf(V arg0)" ], [ "inDegreeOf", "org.jgrapht", "DirectedGraph", "public abstract int inDegreeOf(V arg0)" ], [ "outgoingEdgesOf", "org.jgrapht", "DirectedGraph", "public abstract Set<E> outgoingEdgesOf(V arg0)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(V arg0, V arg1)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(E arg0)" ], [ "edgesOf", "org.jgrapht", "Graph", "public abstract Set<E> edgesOf(V arg0)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract boolean removeAllEdges(Collection<? extends E> arg0)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> removeAllEdges(V arg0, V arg1)" ], [ "getEdge", "org.jgrapht", "Graph", "public abstract E getEdge(V arg0, V arg1)" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract boolean addEdge(V arg0, V arg1, E arg2)" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract boolean removeEdge(E arg0)" ], [ "removeVertex", "org.jgrapht", "Graph", "public abstract boolean removeVertex(V arg0)" ], [ "vertexSet", "org.jgrapht", "Graph", "public abstract Set<V> vertexSet()" ], [ "getAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> getAllEdges(V arg0, V arg1)" ], [ "removeAllVertices", "org.jgrapht", "Graph", "public abstract boolean removeAllVertices(Collection<? extends V> arg0)" ], [ "getEdgeWeight", "org.jgrapht", "Graph", "public abstract double getEdgeWeight(E arg0)" ], [ "getEdgeFactory", "org.jgrapht", "Graph", "public abstract EdgeFactory<V, E> getEdgeFactory()" ], [ "getEdgeTarget", "org.jgrapht", "Graph", "public abstract V getEdgeTarget(E arg0)" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract E removeEdge(V arg0, V arg1)" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract E addEdge(V arg0, V arg1)" ], [ "edgeSet", "org.jgrapht", "Graph", "public abstract Set<E> edgeSet()" ], [ "getEdgeSource", "org.jgrapht", "Graph", "public abstract V getEdgeSource(E arg0)" ], [ "addVertex", "org.jgrapht", "Graph", "public abstract boolean addVertex(V arg0)" ], [ "containsVertex", "org.jgrapht", "Graph", "public abstract boolean containsVertex(V arg0)" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 26392,
  "oracle" : ";",
  "oracleType" : "PRE",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.alg",
  "className" : "BellmanFordShortestPath",
  "javadocTag" : "@param graph the graph to be searched",
  "methodJavadoc" : "    /**\n     * Convenience method to find the shortest path via a single static method\n     * call. If you need a more advanced search (e.g. limited by hops, or\n     * computation of the path length), use the constructor instead.\n     *\n     * @param graph the graph to be searched\n     * @param startVertex the vertex at which the path should start\n     * @param endVertex the vertex at which the path should end\n     *\n     * @return List of Edges, or null if no path exists\n     */",
  "methodSourceCode" : "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex){\n    BellmanFordShortestPath<V, E> alg = new BellmanFordShortestPath<V, E>(graph, startVertex);\n    return alg.getPathEdgeList(endVertex);\n}",
  "classJavadoc" : "/**\n * <a href=\"http://www.nist.gov/dads/HTML/bellmanford.html\">Bellman-Ford\n * algorithm</a>: weights could be negative, paths could be constrained by a\n * maximum number of edges.\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------------\n * BellmanFordShortestPath.java\n * -------------------------\n * (C) Copyright 2006-2008, by France Telecom and Contributors.\n *\n * Original Author:  Guillaume Boulmier and Contributors.\n * Contributor(s):   John V. Sichi\n *\n * $Id$\n *\n * Changes\n * -------\n * 05-Jan-2006 : Initial revision (GB);\n * 14-Jan-2006 : Added support for generics (JVS);\n *\n */\npackage org.jgrapht.alg;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\n\n\n/**\n * <a href=\"http://www.nist.gov/dads/HTML/bellmanford.html\">Bellman-Ford\n * algorithm</a>: weights could be negative, paths could be constrained by a\n * maximum number of edges.\n */\npublic class BellmanFordShortestPath<V, E>\n{\n    private static final double DEFAULT_EPSILON = 0.000000001;\n\n    /**\n     * Graph on which shortest paths are searched.\n     */\n    protected Graph<V, E> graph;\n\n    /**\n     * Start vertex.\n     */\n    protected V startVertex;\n\n    private BellmanFordIterator<V, E> iter;\n\n    /**\n     * Maximum number of edges of the calculated paths.\n     */\n    private int nMaxHops;\n\n    private int passNumber;\n\n    private double epsilon;\n\n    /**\n     * Creates an object to calculate shortest paths between the start vertex\n     * and others vertices using the Bellman-Ford algorithm.\n     *\n     * @param graph\n     * @param startVertex\n     */\n    public BellmanFordShortestPath(Graph<V, E> graph, V startVertex)\n    {\n        this(graph, startVertex, graph.vertexSet().size() - 1);\n    }\n\n    /**\n     * Creates an object to calculate shortest paths between the start vertex\n     * and others vertices using the Bellman-Ford algorithm.\n     *\n     * @param graph\n     * @param startVertex\n     * @param nMaxHops maximum number of edges of the calculated paths.\n     */\n    public BellmanFordShortestPath(\n        Graph<V, E> graph,\n        V startVertex,\n        int nMaxHops)\n    {\n        this(graph, startVertex, nMaxHops, DEFAULT_EPSILON);\n    }\n\n    /**\n     * Creates an object to calculate shortest paths between the start vertex\n     * and others vertices using the Bellman-Ford algorithm.\n     *\n     * @param graph\n     * @param startVertex\n     * @param nMaxHops maximum number of edges of the calculated paths.\n     * @param epsilon tolerance factor.\n     */\n    public BellmanFordShortestPath(\n        Graph<V, E> graph,\n        V startVertex,\n        int nMaxHops,\n        double epsilon)\n    {\n        this.startVertex = startVertex;\n        this.nMaxHops = nMaxHops;\n        this.graph = graph;\n        this.passNumber = 1;\n        this.epsilon = epsilon;\n    }\n\n    /**\n     * @param endVertex end vertex.\n     *\n     * @return the cost of the shortest path between the start vertex and the\n     * end vertex.\n     */\n    public double getCost(V endVertex)\n    {\n        assertGetPath(endVertex);\n\n        lazyCalculate();\n\n        BellmanFordPathElement<V, E> pathElement =\n            this.iter.getPathElement(endVertex);\n\n        if (pathElement == null) {\n            return Double.POSITIVE_INFINITY;\n        }\n\n        return pathElement.getCost();\n    }\n\n    /**\n     * @param endVertex end vertex.\n     *\n     * @return list of <code>Edge</code>, or null if no path exists between the\n     * start vertex and the end vertex.\n     */\n    public List<E> getPathEdgeList(V endVertex)\n    {\n        assertGetPath(endVertex);\n\n        lazyCalculate();\n\n        BellmanFordPathElement<V, E> pathElement =\n            this.iter.getPathElement(endVertex);\n\n        if (pathElement == null) {\n            return null;\n        }\n\n        return pathElement.createEdgeListPath();\n    }\n\n    private void assertGetPath(V endVertex)\n    {\n        if (endVertex.equals(this.startVertex)) {\n            throw new IllegalArgumentException(\n                \"The end vertex is the same as the start vertex!\");\n        }\n\n        if (!this.graph.containsVertex(endVertex)) {\n            throw new IllegalArgumentException(\n                \"Graph must contain the end vertex!\");\n        }\n    }\n\n    private void lazyCalculate()\n    {\n        if (this.iter == null) {\n            this.iter =\n                new BellmanFordIterator<V, E>(\n                    this.graph,\n                    this.startVertex,\n                    epsilon);\n        }\n\n        // at the i-th pass the shortest paths with less (or equal) than i edges\n        // are calculated.\n        for (\n            ;\n            (this.passNumber <= this.nMaxHops) && this.iter.hasNext();\n            this.passNumber++)\n        {\n            this.iter.next();\n        }\n    }\n\n    /**\n     * Convenience method to find the shortest path via a single static method\n     * call. If you need a more advanced search (e.g. limited by hops, or\n     * computation of the path length), use the constructor instead.\n     *\n     * @param graph the graph to be searched\n     * @param startVertex the vertex at which the path should start\n     * @param endVertex the vertex at which the path should end\n     *\n     * @return List of Edges, or null if no path exists\n     */\n    public static <V, E> List<E> findPathBetween(\n        Graph<V, E> graph,\n        V startVertex,\n        V endVertex)\n    {\n        BellmanFordShortestPath<V, E> alg =\n            new BellmanFordShortestPath<V, E>(\n                graph,\n                startVertex);\n\n        return alg.getPathEdgeList(endVertex);\n    }\n}\n\n// End BellmanFordShortestPath.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "graph", "org.jgrapht.Graph", "Graph<V, E>" ], [ "startVertex", "", "V" ], [ "endVertex", "", "V" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getCost", "org.jgrapht.alg", "BellmanFordShortestPath", "public double getCost(V endVertex)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getPathEdgeList", "org.jgrapht.alg", "BellmanFordShortestPath", "public List<E> getPathEdgeList(V endVertex)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract E addEdge(V arg0, V arg1)" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract boolean addEdge(V arg0, V arg1, E arg2)" ], [ "containsVertex", "org.jgrapht", "Graph", "public abstract boolean containsVertex(V arg0)" ], [ "getAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> getAllEdges(V arg0, V arg1)" ], [ "removeVertex", "org.jgrapht", "Graph", "public abstract boolean removeVertex(V arg0)" ], [ "getEdgeSource", "org.jgrapht", "Graph", "public abstract V getEdgeSource(E arg0)" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract E removeEdge(V arg0, V arg1)" ], [ "getEdgeFactory", "org.jgrapht", "Graph", "public abstract EdgeFactory<V, E> getEdgeFactory()" ], [ "getEdgeTarget", "org.jgrapht", "Graph", "public abstract V getEdgeTarget(E arg0)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> removeAllEdges(V arg0, V arg1)" ], [ "addVertex", "org.jgrapht", "Graph", "public abstract boolean addVertex(V arg0)" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract boolean removeEdge(E arg0)" ], [ "getEdgeWeight", "org.jgrapht", "Graph", "public abstract double getEdgeWeight(E arg0)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(V arg0, V arg1)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(E arg0)" ], [ "edgeSet", "org.jgrapht", "Graph", "public abstract Set<E> edgeSet()" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract boolean removeAllEdges(Collection<? extends E> arg0)" ], [ "getEdge", "org.jgrapht", "Graph", "public abstract E getEdge(V arg0, V arg1)" ], [ "edgesOf", "org.jgrapht", "Graph", "public abstract Set<E> edgesOf(V arg0)" ], [ "removeAllVertices", "org.jgrapht", "Graph", "public abstract boolean removeAllVertices(Collection<? extends V> arg0)" ], [ "vertexSet", "org.jgrapht", "Graph", "public abstract Set<V> vertexSet()" ], [ "listIterator", "java.util", "List", "public abstract ListIterator<E> listIterator()" ], [ "get", "java.util", "List", "public abstract E get(int arg0)" ], [ "equals", "java.util", "List", "public abstract boolean equals(Object arg0)" ], [ "removeAll", "java.util", "List", "public abstract boolean removeAll(Collection<? extends Object> arg0)" ], [ "listIterator", "java.util", "List", "public abstract ListIterator<E> listIterator(int arg0)" ], [ "add", "java.util", "List", "public abstract boolean add(E arg0)" ], [ "containsAll", "java.util", "List", "public abstract boolean containsAll(Collection<? extends Object> arg0)" ], [ "lastIndexOf", "java.util", "List", "public abstract int lastIndexOf(Object arg0)" ], [ "toArray", "java.util", "List", "public abstract Object[] toArray()" ], [ "addAll", "java.util", "List", "public abstract boolean addAll(int arg0, Collection<? extends E> arg1)" ], [ "addAll", "java.util", "List", "public abstract boolean addAll(Collection<? extends E> arg0)" ], [ "hashCode", "java.util", "List", "public abstract int hashCode()" ], [ "contains", "java.util", "List", "public abstract boolean contains(Object arg0)" ], [ "remove", "java.util", "List", "public abstract boolean remove(Object arg0)" ], [ "spliterator", "java.util", "List", "public default Spliterator<E> spliterator()" ], [ "toArray", "java.util", "List", "public abstract <T> T[] toArray(T[] arg0)" ], [ "indexOf", "java.util", "List", "public abstract int indexOf(Object arg0)" ], [ "iterator", "java.util", "List", "public abstract Iterator<E> iterator()" ], [ "isEmpty", "java.util", "List", "public abstract boolean isEmpty()" ], [ "remove", "java.util", "List", "public abstract E remove(int arg0)" ], [ "retainAll", "java.util", "List", "public abstract boolean retainAll(Collection<? extends Object> arg0)" ], [ "subList", "java.util", "List", "public abstract List<E> subList(int arg0, int arg1)" ], [ "set", "java.util", "List", "public abstract E set(int arg0, E arg1)" ], [ "size", "java.util", "List", "public abstract int size()" ], [ "isEmpty", "java.util", "Collection", "public abstract boolean isEmpty()" ], [ "retainAll", "java.util", "Collection", "public abstract boolean retainAll(Collection<? extends Object> arg0)" ], [ "containsAll", "java.util", "Collection", "public abstract boolean containsAll(Collection<? extends Object> arg0)" ], [ "addAll", "java.util", "Collection", "public abstract boolean addAll(Collection<? extends E> arg0)" ], [ "stream", "java.util", "Collection", "public default Stream<E> stream()" ], [ "toArray", "java.util", "Collection", "public abstract Object[] toArray()" ], [ "parallelStream", "java.util", "Collection", "public default Stream<E> parallelStream()" ], [ "size", "java.util", "Collection", "public abstract int size()" ], [ "removeIf", "java.util", "Collection", "public default boolean removeIf(Predicate<? super E> arg0)" ], [ "add", "java.util", "Collection", "public abstract boolean add(E arg0)" ], [ "hashCode", "java.util", "Collection", "public abstract int hashCode()" ], [ "toArray", "java.util", "Collection", "public abstract <T> T[] toArray(T[] arg0)" ], [ "removeAll", "java.util", "Collection", "public abstract boolean removeAll(Collection<? extends Object> arg0)" ], [ "contains", "java.util", "Collection", "public abstract boolean contains(Object arg0)" ], [ "remove", "java.util", "Collection", "public abstract boolean remove(Object arg0)" ], [ "toArray", "java.util", "Collection", "public default <T> T[] toArray(IntFunction<T[]> arg0)" ], [ "spliterator", "java.util", "Collection", "public default Spliterator<E> spliterator()" ], [ "equals", "java.util", "Collection", "public abstract boolean equals(Object arg0)" ], [ "iterator", "java.util", "Collection", "public abstract Iterator<E> iterator()" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "graph", "org.jgrapht.alg", "BellmanFordShortestPath", "protected Graph<V,E> graph;" ], [ "startVertex", "org.jgrapht.alg", "BellmanFordShortestPath", "protected V startVertex;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 26416,
  "oracle" : "graph.containsVertex(startVertex);",
  "oracleType" : "PRE",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.alg",
  "className" : "DijkstraShortestPath",
  "javadocTag" : "@param startVertex the vertex at which the path should start",
  "methodJavadoc" : "    /**\n     * Creates and executes a new DijkstraShortestPath algorithm instance. An\n     * instance is only good for a single search; after construction, it can be\n     * accessed to retrieve information about the path found.\n     *\n     * @param graph the graph to be searched\n     * @param startVertex the vertex at which the path should start\n     * @param endVertex the vertex at which the path should end\n     * @param radius limit on weighted path length, or Double.POSITIVE_INFINITY\n     * for unbounded search\n     */",
  "methodSourceCode" : "public DijkstraShortestPath(Graph<V, E> graph, V startVertex, V endVertex, double radius){\n    if (!graph.containsVertex(endVertex)) {\n        throw new IllegalArgumentException(\"graph must contain the end vertex\");\n    }\n    ClosestFirstIterator<V, E> iter = new ClosestFirstIterator<V, E>(graph, startVertex, radius);\n    while (iter.hasNext()) {\n        V vertex = iter.next();\n        if (vertex.equals(endVertex)) {\n            createEdgeList(graph, iter, startVertex, endVertex);\n            return;\n        }\n    }\n    path = null;\n}",
  "classJavadoc" : "/**\n * An implementation of <a\n * href=\"http://mathworld.wolfram.com/DijkstrasAlgorithm.html\">Dijkstra's\n * shortest path algorithm</a> using <code>ClosestFirstIterator</code>.\n *\n * @author John V. Sichi\n * @since Sep 2, 2003\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------------\n * DijkstraShortestPath.java\n * -------------------------\n * (C) Copyright 2003-2008, by John V. Sichi and Contributors.\n *\n * Original Author:  John V. Sichi\n * Contributor(s):   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 02-Sep-2003 : Initial revision (JVS);\n * 29-May-2005 : Make non-static and add radius support (JVS);\n * 07-Jun-2005 : Made generic (CH);\n *\n */\npackage org.jgrapht.alg;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\nimport org.jgrapht.graph.*;\nimport org.jgrapht.traverse.*;\n\n\n/**\n * An implementation of <a\n * href=\"http://mathworld.wolfram.com/DijkstrasAlgorithm.html\">Dijkstra's\n * shortest path algorithm</a> using <code>ClosestFirstIterator</code>.\n *\n * @author John V. Sichi\n * @since Sep 2, 2003\n */\npublic final class DijkstraShortestPath<V, E>\n{\n    private GraphPath<V, E> path;\n\n    /**\n     * Creates and executes a new DijkstraShortestPath algorithm instance. An\n     * instance is only good for a single search; after construction, it can be\n     * accessed to retrieve information about the path found.\n     *\n     * @param graph the graph to be searched\n     * @param startVertex the vertex at which the path should start\n     * @param endVertex the vertex at which the path should end\n     */\n    public DijkstraShortestPath(Graph<V, E> graph,\n        V startVertex,\n        V endVertex)\n    {\n        this(graph, startVertex, endVertex, Double.POSITIVE_INFINITY);\n    }\n\n    /**\n     * Creates and executes a new DijkstraShortestPath algorithm instance. An\n     * instance is only good for a single search; after construction, it can be\n     * accessed to retrieve information about the path found.\n     *\n     * @param graph the graph to be searched\n     * @param startVertex the vertex at which the path should start\n     * @param endVertex the vertex at which the path should end\n     * @param radius limit on weighted path length, or Double.POSITIVE_INFINITY\n     * for unbounded search\n     */\n    public DijkstraShortestPath(\n        Graph<V, E> graph,\n        V startVertex,\n        V endVertex,\n        double radius)\n    {\n        if (!graph.containsVertex(endVertex)) {\n            throw new IllegalArgumentException(\n                \"graph must contain the end vertex\");\n        }\n\n        ClosestFirstIterator<V, E> iter =\n            new ClosestFirstIterator<V, E>(graph, startVertex, radius);\n\n        while (iter.hasNext()) {\n            V vertex = iter.next();\n\n            if (vertex.equals(endVertex)) {\n                createEdgeList(graph, iter, startVertex, endVertex);\n                return;\n            }\n        }\n\n        path = null;\n    }\n\n    /**\n     * Return the edges making up the path found.\n     *\n     * @return List of Edges, or null if no path exists\n     */\n    public List<E> getPathEdgeList()\n    {\n        if (path == null) {\n            return null;\n        } else {\n            return path.getEdgeList();\n        }\n    }\n\n    /**\n     * Return the path found.\n     *\n     * @return path representation, or null if no path exists\n     */\n    public GraphPath<V, E> getPath()\n    {\n        return path;\n    }\n\n    /**\n     * Return the weighted length of the path found.\n     *\n     * @return path length, or Double.POSITIVE_INFINITY if no path exists\n     */\n    public double getPathLength()\n    {\n        if (path == null) {\n            return Double.POSITIVE_INFINITY;\n        } else {\n            return path.getWeight();\n        }\n    }\n\n    /**\n     * Convenience method to find the shortest path via a single static method\n     * call. If you need a more advanced search (e.g. limited by radius, or\n     * computation of the path length), use the constructor instead.\n     *\n     * @param graph the graph to be searched\n     * @param startVertex the vertex at which the path should start\n     * @param endVertex the vertex at which the path should end\n     *\n     * @return List of Edges, or null if no path exists\n     */\n    public static <V, E> List<E> findPathBetween(\n        Graph<V, E> graph,\n        V startVertex,\n        V endVertex)\n    {\n        DijkstraShortestPath<V, E> alg =\n            new DijkstraShortestPath<V, E>(\n                graph,\n                startVertex,\n                endVertex);\n\n        return alg.getPathEdgeList();\n    }\n\n    private void createEdgeList(\n        Graph<V, E> graph,\n        ClosestFirstIterator<V, E> iter,\n        V startVertex,\n        V endVertex)\n    {\n        List<E> edgeList = new ArrayList<E>();\n\n        V v = endVertex;\n\n        while (true) {\n            E edge = iter.getSpanningTreeEdge(v);\n\n            if (edge == null) {\n                break;\n            }\n\n            edgeList.add(edge);\n            v = Graphs.getOppositeVertex(graph, edge, v);\n        }\n\n        Collections.reverse(edgeList);\n        double pathLength = iter.getShortestPathLength(endVertex);\n        path =\n            new GraphPathImpl<V, E>(\n                graph,\n                startVertex,\n                endVertex,\n                edgeList,\n                pathLength);\n    }\n}\n\n// End DijkstraShortestPath.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "graph", "org.jgrapht.Graph", "Graph<V, E>" ], [ "startVertex", "", "V" ], [ "endVertex", "", "V" ], [ "radius", "", "double" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getPathEdgeList", "org.jgrapht.alg", "DijkstraShortestPath", "public List<E> getPathEdgeList()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "getPath", "org.jgrapht.alg", "DijkstraShortestPath", "public GraphPath<V, E> getPath()" ], [ "getPathLength", "org.jgrapht.alg", "DijkstraShortestPath", "public double getPathLength()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract boolean removeAllEdges(Collection<? extends E> arg0)" ], [ "addVertex", "org.jgrapht", "Graph", "public abstract boolean addVertex(V arg0)" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract boolean addEdge(V arg0, V arg1, E arg2)" ], [ "getEdge", "org.jgrapht", "Graph", "public abstract E getEdge(V arg0, V arg1)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(V arg0, V arg1)" ], [ "containsVertex", "org.jgrapht", "Graph", "public abstract boolean containsVertex(V arg0)" ], [ "getEdgeTarget", "org.jgrapht", "Graph", "public abstract V getEdgeTarget(E arg0)" ], [ "edgeSet", "org.jgrapht", "Graph", "public abstract Set<E> edgeSet()" ], [ "edgesOf", "org.jgrapht", "Graph", "public abstract Set<E> edgesOf(V arg0)" ], [ "getEdgeWeight", "org.jgrapht", "Graph", "public abstract double getEdgeWeight(E arg0)" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract E addEdge(V arg0, V arg1)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(E arg0)" ], [ "removeAllVertices", "org.jgrapht", "Graph", "public abstract boolean removeAllVertices(Collection<? extends V> arg0)" ], [ "removeVertex", "org.jgrapht", "Graph", "public abstract boolean removeVertex(V arg0)" ], [ "vertexSet", "org.jgrapht", "Graph", "public abstract Set<V> vertexSet()" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> removeAllEdges(V arg0, V arg1)" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract boolean removeEdge(E arg0)" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract E removeEdge(V arg0, V arg1)" ], [ "getEdgeSource", "org.jgrapht", "Graph", "public abstract V getEdgeSource(E arg0)" ], [ "getEdgeFactory", "org.jgrapht", "Graph", "public abstract EdgeFactory<V, E> getEdgeFactory()" ], [ "getAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> getAllEdges(V arg0, V arg1)" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
} ]