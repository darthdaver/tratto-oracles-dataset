[
    {
        "id": 26323,
        "oracle": ";",
        "oracleType": "PRE",
        "projectName": "jgrapht-core-0.9.2",
        "packageName": "org.jgrapht.alg.isomorphism",
        "className": "VF2State",
        "javadocTag": "@param str",
        "methodJavadoc": "    /**\n     * creates the debug output only if DEBUG is true.\n     *\n     * @param method\n     * @param str\n     */",
        "methodSourceCode": "protected void showLog(String method, String str){\n    if (!DEBUG) {\n        return;\n    }\n    char[] indent = new char[2 * coreLen];\n    Arrays.fill(indent, ' ');\n    System.out.println((new String(indent)) + method + \"> \" + str);\n}",
        "classJavadoc": "/**\n * controls the matching between two graphs according to the VF2 algorithm.\n *\n * @param <V> the type of the vertices\n * @param <E> the type of the edges\n *\n * @author Fabian Sp\u00e4h\n */",
        "classSourceCode": "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------------\n * VF2State.java\n * -------------------------\n * (C) Copyright 2015, by Fabian Sp\u00e4h and Contributors.\n *\n * Original Author:  Fabian Sp\u00e4h\n * Contributor(s):   Rita Dobler\n *\n * $Id$\n *\n * Changes\n * -------\n * 20-Jun-2015 : Initial revision (FS);\n *\n */\npackage org.jgrapht.alg.isomorphism;\n\nimport java.util.*;\n\n\n/**\n * controls the matching between two graphs according to the VF2 algorithm.\n *\n * @param <V> the type of the vertices\n * @param <E> the type of the edges\n *\n * @author Fabian Sp\u00e4h\n */\nabstract class VF2State<V, E>\n{\n    public static final int NULL_NODE = -1;\n\n    protected static final boolean DEBUG = false;\n\n    protected int [] core1, core2, in1, in2, out1, out2;\n\n    protected int coreLen, n1, n2, t1BothLen, t2BothLen, t1InLen, t2InLen,\n        t1OutLen, t2OutLen, addedVertex1, addVertex1, addVertex2;\n\n    protected GraphOrdering<V, E> g1, g2;\n\n    protected Comparator<V> vertexComparator;\n    protected Comparator<E> edgeComparator;\n\n    /**\n     * @param g1 GraphOrdering on first graph\n     * @param g2 GraphOrdering on second graph (possible subgraph)\n     * @param vertexComparator comparator for semantic equality of vertices\n     * @param edgeComparator comparator for semantic equality of edges\n     */\n    public VF2State(\n        GraphOrdering<V, E> g1,\n        GraphOrdering<V, E> g2,\n        Comparator<V> vertexComparator,\n        Comparator<E> edgeComparator)\n    {\n        this.g1 = g1;\n        this.g2 = g2;\n        this.vertexComparator = vertexComparator;\n        this.edgeComparator = edgeComparator;\n\n        n1 = g1.getVertexCount();\n        n2 = g2.getVertexCount();\n\n        core1 = new int[n1];\n        in1 = new int[n1];\n        out1 = new int[n1];\n        core2 = new int[n2];\n        in2 = new int[n2];\n        out2 = new int[n2];\n        Arrays.fill(core1, NULL_NODE);\n        Arrays.fill(core2, NULL_NODE);\n\n        coreLen = 0;\n        addedVertex1 = addVertex1 = addVertex2 = NULL_NODE;\n\n        t1BothLen = t2BothLen = t1InLen = t2InLen = t1OutLen = t2OutLen = 0;\n    }\n\n    /**\n     * copy constructor\n     *\n     * @param s\n     */\n    public VF2State(VF2State<V, E> s)\n    {\n        g1 = s.g1;\n        g2 = s.g2;\n\n        core1 = s.core1;\n        core2 = s.core2;\n        in1 = s.in1;\n        in2 = s.in2;\n        out1 = s.out1;\n        out2 = s.out2;\n\n        coreLen = s.coreLen;\n\n        n1 = s.n1;\n        n2 = s.n2;\n\n        t1BothLen = s.t1BothLen;\n        t2BothLen = s.t2BothLen;\n        t1InLen = s.t1InLen;\n        t2InLen = s.t2InLen;\n        t1OutLen = s.t1OutLen;\n        t2OutLen = s.t2OutLen;\n\n        vertexComparator = s.vertexComparator;\n        edgeComparator = s.edgeComparator;\n\n        addVertex1 = s.addVertex1;\n        addVertex2 = s.addVertex2;\n        addedVertex1 = s.addedVertex1;\n    }\n\n    /**\n     * calculates a pair of nodes which may be added to the current matching,\n     * according to the VF2 algorithm.\n     *\n     * @return false, if there are no more pairs left\n     */\n    public boolean nextPair()\n    {\n        if (addVertex2 == NULL_NODE) {\n            addVertex2 = 0;\n        }\n\n        if (addVertex1 == NULL_NODE) {\n            addVertex1 = 0;\n        } else {\n            addVertex1++;\n        }\n\n        // check incoming and outgoing edges\n        if ((t1BothLen > coreLen) && (t2BothLen > coreLen)) {\n            // find minimum for addVertex2 in core2 and t2in/t2out\n            while (\n                (addVertex2 < n2)\n                && ((core2[addVertex2] != NULL_NODE)\n                    || (out2[addVertex2] == 0)\n                    || (in2[addVertex2] == 0)))\n            {\n                addVertex2++;\n                addVertex1 = 0;\n            }\n\n            // find first/next vertex for addVertex1 in core1 and t1in/t1out\n            while (\n                (addVertex1 < n1)\n                && ((core1[addVertex1] != NULL_NODE)\n                    || (out1[addVertex1] == 0)\n                    || (in1[addVertex1] == 0)))\n            {\n                addVertex1++;\n            }\n        }\n\n        // check outgoing edges\n        else if ((t1OutLen > coreLen) && (t2OutLen > coreLen)) {\n            while (\n                (addVertex2 < n2)\n                && ((core2[addVertex2] != NULL_NODE)\n                    || (out2[addVertex2] == 0)))\n            {\n                addVertex2++;\n                addVertex1 = 0;\n            }\n\n            while (\n                (addVertex1 < n1)\n                && ((core1[addVertex1] != NULL_NODE)\n                    || (out1[addVertex1] == 0)))\n            {\n                addVertex1++;\n            }\n        }\n\n        // check incoming edges\n        else if ((t1InLen > coreLen) && (t2InLen > coreLen)) {\n            while (\n                (addVertex2 < n2)\n                && ((core2[addVertex2] != NULL_NODE)\n                    || (in2[addVertex2] == 0)))\n            {\n                addVertex2++;\n                addVertex1 = 0;\n            }\n\n            while (\n                (addVertex1 < n1)\n                && ((core1[addVertex1] != NULL_NODE)\n                    || (in1[addVertex1] == 0)))\n            {\n                addVertex1++;\n            }\n        }\n\n        // check new edges\n        else {\n            while ((addVertex2 < n2) && (core2[addVertex2] != NULL_NODE)) {\n                addVertex2++;\n                addVertex1 = 0;\n            }\n\n            while ((addVertex1 < n1) && (core1[addVertex1] != NULL_NODE)) {\n                addVertex1++;\n            }\n        }\n\n        if ((addVertex1 < n1) && (addVertex2 < n2)) {\n            showLog(\n                \"nextPair\",\n                \"next candidate pair: (\"\n                + g1.getVertex(addVertex1) + \", \"\n                + g2.getVertex(addVertex2) + \")\");\n            return true;\n        }\n\n        // there are no more pairs..\n        showLog(\"nextPair\", \"no more candidate pairs\");\n\n        addVertex1 = addVertex2 = NULL_NODE;\n        return false;\n    }\n\n    /**\n     * adds the pair to the current matching.\n     */\n    public void addPair()\n    {\n        showLog(\n            \"addPair\",\n            \"(\" + g1.getVertex(addVertex1) + \", \"\n            + g2.getVertex(addVertex2) + \") added\");\n\n        coreLen++;\n        addedVertex1 = addVertex1;\n\n        if (in1[addVertex1] == 0) {\n            in1[addVertex1] = coreLen;\n            t1InLen++;\n            if (out1[addVertex1] > 0) {\n                t1BothLen++;\n            }\n        }\n\n        if (out1[addVertex1] == 0) {\n            out1[addVertex1] = coreLen;\n            t1OutLen++;\n            if (in1[addVertex1] > 0) {\n                t1BothLen++;\n            }\n        }\n\n        if (in2[addVertex2] == 0) {\n            in2[addVertex2] = coreLen;\n            t2InLen++;\n            if (out2[addVertex2] > 0) {\n                t2BothLen++;\n            }\n        }\n\n        if (out2[addVertex2] == 0) {\n            out2[addVertex2] = coreLen;\n            t2OutLen++;\n            if (in2[addVertex2] > 0) {\n                t2BothLen++;\n            }\n        }\n\n        core1[addVertex1] = addVertex2;\n        core2[addVertex2] = addVertex1;\n\n        for (int other : g1.getInEdges(addVertex1)) {\n            if (in1[other] == 0) {\n                in1[other] = coreLen;\n                t1InLen++;\n                if (out1[other] > 0) {\n                    t1BothLen++;\n                }\n            }\n        }\n\n        for (int other : g1.getOutEdges(addVertex1)) {\n            if (out1[other] == 0) {\n                out1[other] = coreLen;\n                t1OutLen++;\n                if (in1[other] > 0) {\n                    t1BothLen++;\n                }\n            }\n        }\n\n        for (int other : g2.getInEdges(addVertex2)) {\n            if (in2[other] == 0) {\n                in2[other] = coreLen;\n                t2InLen++;\n                if (out2[other] > 0) {\n                    t2BothLen++;\n                }\n            }\n        }\n\n        for (int other : g2.getOutEdges(addVertex2)) {\n            if (out2[other] == 0) {\n                out2[other] = coreLen;\n                t2OutLen++;\n                if (in2[other] > 0) {\n                    t2BothLen++;\n                }\n            }\n        }\n    }\n\n    /**\n     * @return is the matching already complete?\n     */\n    public boolean isGoal()\n    {\n        return coreLen == n2;\n    }\n\n    /**\n     * @return true, if the already matched vertices of graph1 plus the first\n     * vertex of nextPair are isomorphic to the already matched vertices of\n     * graph2 and the second one vertex of nextPair.\n     */\n    public abstract boolean isFeasiblePair();\n\n    /**\n     * removes the last added pair from the matching\n     */\n    public void backtrack()\n    {\n        int addedVertex2 = core1[addedVertex1];\n\n        showLog(\n            \"backtrack\",\n            \"remove (\" + g1.getVertex(addedVertex1) + \", \"\n            + g2.getVertex(addedVertex2) + \") from the matching\");\n\n        if (in1[addedVertex1] == coreLen) {\n            in1[addedVertex1] = 0;\n        }\n\n        for (int other : g1.getInEdges(addedVertex1)) {\n            if (in1[other] == coreLen) {\n                in1[other] = 0;\n            }\n        }\n\n        if (out1[addedVertex1] == coreLen) {\n            out1[addedVertex1] = 0;\n        }\n\n        for (int other : g1.getOutEdges(addedVertex1)) {\n            if (out1[other] == coreLen) {\n                out1[other] = 0;\n            }\n        }\n\n        if (in2[addedVertex2] == coreLen) {\n            in2[addedVertex2] = 0;\n        }\n\n        for (int other : g2.getInEdges(addedVertex2)) {\n            if (in2[other] == coreLen) {\n                in2[other] = 0;\n            }\n        }\n\n        if (out2[addedVertex2] == coreLen) {\n            out2[addedVertex2] = 0;\n        }\n\n        for (int other : g2.getOutEdges(addedVertex2)) {\n            if (out2[other] == coreLen) {\n                out2[other] = 0;\n            }\n        }\n\n        core1[addedVertex1] = core2[addedVertex2] = NULL_NODE;\n        coreLen--;\n        addedVertex1 = NULL_NODE;\n    }\n\n    /**\n     * checks the vertices v1 and v2 for semantic equivalence\n     *\n     * @param v1\n     * @param v2\n     *\n     * @return v1 and v2 are equivalent\n     */\n    protected boolean areCompatibleVertexes(int v1, int v2)\n    {\n        return (vertexComparator == null)\n            || (vertexComparator.compare(g1.getVertex(v1), g2.getVertex(v2))\n                == 0);\n    }\n\n    /**\n     * checks the edges from v1 to v2 and from u1 to u2 for semantic equivalence\n     *\n     * @param v1\n     * @param v2\n     * @param u1\n     * @param u2\n     *\n     * @return edges are equivalent\n     */\n    protected boolean areCompatibleEdges(int v1, int v2, int u1, int u2)\n    {\n        return (edgeComparator == null)\n            || (edgeComparator.compare(g1.getEdge(v1, v2), g2.getEdge(u1, u2))\n                == 0);\n    }\n\n    public IsomorphicGraphMapping<V, E> getCurrentMapping()\n    {\n        return new IsomorphicGraphMapping<V, E>(g1, g2, core1, core2);\n    }\n\n    public void resetAddVertexes()\n    {\n        addVertex1 = addVertex2 = NULL_NODE;\n    }\n\n    /**\n     * creates the debug output only if DEBUG is true.\n     *\n     * @param method\n     * @param str\n     */\n    protected void showLog(String method, String str)\n    {\n        if (!DEBUG) {\n            return;\n        }\n\n        char [] indent = new char[2 * coreLen];\n        Arrays.fill(indent, ' ');\n        System.out.println((new String(indent)) + method + \"> \" + str);\n    }\n}\n\n// End VF2State.java\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "PartiteRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "RandomGraphHelper",
                "org.jgrapht.experimental"
            ],
            [
                "GraphReader",
                "org.jgrapht.experimental"
            ],
            [
                "DirectedAcyclicGraph",
                "org.jgrapht.experimental.dag"
            ],
            [
                "GraphSquare",
                "org.jgrapht.experimental"
            ],
            [
                "UniformRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "GraphTests",
                "org.jgrapht.experimental"
            ],
            [
                "ApproximationAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "BrownBacktrackColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "GreedyColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "IntArrayGraphAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ExactAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ListenableGraph",
                "org.jgrapht"
            ],
            [
                "ModifiableInteger",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeapNode",
                "org.jgrapht.util"
            ],
            [
                "WeightCombiner",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeap",
                "org.jgrapht.util"
            ],
            [
                "TypeUtil",
                "org.jgrapht.util"
            ],
            [
                "ArrayUnenforcedSet",
                "org.jgrapht.util"
            ],
            [
                "VertexPair",
                "org.jgrapht.util"
            ],
            [
                "MathUtil",
                "org.jgrapht.util"
            ],
            [
                "PrefetchIterator",
                "org.jgrapht.util"
            ],
            [
                "VertexFactory",
                "org.jgrapht"
            ],
            [
                "Graph",
                "org.jgrapht"
            ],
            [
                "GraphPath",
                "org.jgrapht"
            ],
            [
                "UndirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraph",
                "org.jgrapht.graph"
            ],
            [
                "MixedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DefaultGraphMapping",
                "org.jgrapht.graph"
            ],
            [
                "WeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskEdgeSet",
                "org.jgrapht.graph"
            ],
            [
                "Pseudograph",
                "org.jgrapht.graph"
            ],
            [
                "MaskFunctor",
                "org.jgrapht.graph"
            ],
            [
                "GraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractBaseGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "Multigraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultWeightedEdge",
                "org.jgrapht.graph"
            ],
            [
                "ListenableDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeSetFactory",
                "org.jgrapht.graph"
            ],
            [
                "GraphDelegator",
                "org.jgrapht.graph"
            ],
            [
                "DefaultListenableGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedVertexFactory",
                "org.jgrapht.graph"
            ],
            [
                "DefaultEdge",
                "org.jgrapht.graph"
            ],
            [
                "MaskVertexSet",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "IntrusiveEdge",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphPathImpl",
                "org.jgrapht.graph"
            ],
            [
                "Subgraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractGraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedEdgeFactory",
                "org.jgrapht.graph"
            ],
            [
                "SimpleWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "WeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeReversedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "AbstractGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "ListenableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraphPath",
                "org.jgrapht.graph"
            ],
            [
                "ParanoidGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphHelper",
                "org.jgrapht"
            ],
            [
                "Graphs",
                "org.jgrapht"
            ],
            [
                "DirectedGraph",
                "org.jgrapht"
            ],
            [
                "WeightedGraph",
                "org.jgrapht"
            ],
            [
                "HyperCubeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RingGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WheelGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GridGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "ScaleFreeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedBipartiteGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "LinearGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RandomGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGeneratorAdapter",
                "org.jgrapht.generate"
            ],
            [
                "EmptyGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteBipartiteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "StarGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "UndirectedGraph",
                "org.jgrapht"
            ],
            [
                "TopologicalOrderIterator",
                "org.jgrapht.traverse"
            ],
            [
                "CrossComponentIterator",
                "org.jgrapht.traverse"
            ],
            [
                "AbstractGraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "ClosestFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "BreadthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "DepthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "GraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "EdgeFactory",
                "org.jgrapht"
            ],
            [
                "GraphMapping",
                "org.jgrapht"
            ],
            [
                "VertexSetListener",
                "org.jgrapht.event"
            ],
            [
                "EdgeTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "TraversalListener",
                "org.jgrapht.event"
            ],
            [
                "GraphEdgeChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "VertexTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphListener",
                "org.jgrapht.event"
            ],
            [
                "TraversalListenerAdapter",
                "org.jgrapht.event"
            ],
            [
                "ConnectedComponentTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphVertexChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "TarjanLowestCommonAncestor",
                "org.jgrapht.alg"
            ],
            [
                "PrimMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "BlockCutpointGraph",
                "org.jgrapht.alg"
            ],
            [
                "AllDirectedPaths",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPathsIterator",
                "org.jgrapht.alg"
            ],
            [
                "KruskalMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "StrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "VF2State",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2AbstractIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "GraphOrdering",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphicGraphMapping",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2MappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "BronKerboschCliqueFinder",
                "org.jgrapht.alg"
            ],
            [
                "ChromaticNumber",
                "org.jgrapht.alg"
            ],
            [
                "KosarajuStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "DijkstraShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElement",
                "org.jgrapht.alg"
            ],
            [
                "AStarShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordPathElement",
                "org.jgrapht.alg"
            ],
            [
                "FloydWarshallShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "UnionFind",
                "org.jgrapht.alg.util"
            ],
            [
                "AlwaysEqualComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Extension",
                "org.jgrapht.alg.util"
            ],
            [
                "VertexDegreeComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Pair",
                "org.jgrapht.alg.util"
            ],
            [
                "GabowStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "HawickJamesSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "DirectedSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "JohnsonSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TiernanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "UndirectedCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "PatonCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TarjanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "SzwarcfiterLauerSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "BiconnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "ConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "MinSourceSinkCut",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsBlossomShrinking",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveClosure",
                "org.jgrapht.alg"
            ],
            [
                "HopcroftKarpBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "StoerWagnerMinimumCut",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "KuhnMunkresMinimalWeightBipartitePerfectMatching",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveReduction",
                "org.jgrapht.alg"
            ],
            [
                "EulerianCircuit",
                "org.jgrapht.alg"
            ],
            [
                "DirectedNeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "NaiveLcaFinder",
                "org.jgrapht.alg"
            ],
            [
                "MaximumWeightBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "HamiltonianCycle",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "NeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "VertexCovers",
                "org.jgrapht.alg"
            ],
            [
                "CycleDetector",
                "org.jgrapht.alg"
            ],
            [
                "AStarAdmissibleHeuristic",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MinimumSpanningTree",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "WeightedMatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "StrongConnectivityAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MaximumFlowAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "CliqueMinimalSeparatorDecomposition",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordIterator",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElement",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "PushRelabelMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "MaximumFlowAlgorithmBase",
                "org.jgrapht.alg.flow"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "addVertices",
                "org.jgrapht.experimental",
                "RandomGraphHelper",
                "/**\n * .\n *\n * @param target\n * @param vertexFactory\n * @param numVertices\n *\n * @return vertices\n */\n@SuppressWarnings(\"unchecked\")\npublic static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices) {\n    Object[] vertices = new Object[numVertices];\n    for (int i = 0; i < numVertices; ++i) {\n        vertices[i] = vertexFactory.createVertex();\n        target.addVertex(vertices[i]);\n    }\n    return vertices;\n}"
            ],
            [
                "isEmpty",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isEmpty(Graph<V, E> g) {\n    return g.edgeSet().isEmpty();\n}"
            ],
            [
                "isComplete",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isComplete(Graph<V, E> g) {\n    int n = g.vertexSet().size();\n    return g.edgeSet().size() == (n * (n - 1) / 2);\n}"
            ],
            [
                "isConnected",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isConnected(Graph<V, E> g) {\n    int numVertices = g.vertexSet().size();\n    int numEdges = g.edgeSet().size();\n    if (numEdges < (numVertices - 1)) {\n        return false;\n    }\n    if ((numVertices < 2) || (numEdges > ((numVertices - 1) * (numVertices - 2) / 2))) {\n        return true;\n    }\n    Set<V> known = new HashSet<V>();\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = g.vertexSet().iterator().next();\n    // start with node 1\n    queue.add(v);\n    known.add(v);\n    while (!queue.isEmpty()) {\n        v = queue.removeFirst();\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            v = it.next();\n            if (!known.contains(v)) {\n                known.add(v);\n                queue.add(v);\n            }\n        }\n    }\n    return known.size() == numVertices;\n}"
            ],
            [
                "isTree",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isTree(Graph<V, E> g) {\n    return isConnected(g) && (g.edgeSet().size() == (g.vertexSet().size() - 1));\n}"
            ],
            [
                "isBipartite",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isBipartite(Graph<V, E> g) {\n    if ((4 * g.edgeSet().size()) > (g.vertexSet().size() * g.vertexSet().size())) {\n        return false;\n    }\n    if (isEmpty(g)) {\n        return true;\n    }\n    Set<V> unknown = new HashSet<V>(g.vertexSet());\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = unknown.iterator().next();\n    Set<V> odd = new HashSet<V>();\n    queue.add(v);\n    while (!unknown.isEmpty()) {\n        if (queue.isEmpty()) {\n            queue.add(unknown.iterator().next());\n        }\n        v = queue.removeFirst();\n        unknown.remove(v);\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            V n = it.next();\n            if (unknown.contains(n)) {\n                queue.add(n);\n                if (!odd.contains(v)) {\n                    odd.add(n);\n                }\n            } else if (!(odd.contains(v) ^ odd.contains(n))) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
            ],
            [
                "union",
                "org.jgrapht.util",
                "FibonacciHeap",
                "// size\n/**\n * Joins two Fibonacci heaps into a new one. No heap consolidation is\n * performed at this time. The two root lists are simply joined together.\n *\n * <p>Running time: O(1) actual</p>\n *\n * @param h1 first heap\n * @param h2 second heap\n *\n * @return new heap containing h1 and h2\n */\npublic static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2) {\n    FibonacciHeap<T> h = new FibonacciHeap<T>();\n    if ((h1 != null) && (h2 != null)) {\n        h.minNode = h1.minNode;\n        if (h.minNode != null) {\n            if (h2.minNode != null) {\n                h.minNode.right.left = h2.minNode.left;\n                h2.minNode.left.right = h.minNode.right;\n                h.minNode.right = h2.minNode;\n                h2.minNode.left = h.minNode;\n                if (h2.minNode.key < h1.minNode.key) {\n                    h.minNode = h2.minNode;\n                }\n            }\n        } else {\n            h.minNode = h2.minNode;\n        }\n        h.nNodes = h1.nNodes + h2.nNodes;\n    }\n    return h;\n}"
            ],
            [
                "uncheckedCast",
                "org.jgrapht.util",
                "TypeUtil",
                "/**\n * Casts an object to a type.\n *\n * @param o object to be cast\n * @param typeDecl conveys the target type information; the actual value is\n * unused and can be null since this is all just stupid compiler tricks\n *\n * @return the result of the cast\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl) {\n    return (T) o;\n}"
            ],
            [
                "factorial",
                "org.jgrapht.util",
                "MathUtil",
                "public static long factorial(int N) {\n    long multi = 1;\n    for (int i = 1; i <= N; i++) {\n        multi = multi * i;\n    }\n    return multi;\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graphs",
                "/**\n * Creates a new edge and adds it to the specified graph similarly to the\n * {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n *\n * @see Graph#addEdge(Object, Object)\n */\npublic static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    EdgeFactory<V, E> ef = g.getEdgeFactory();\n    E e = ef.createEdge(sourceVertex, targetVertex);\n    // we first create the edge and set the weight to make sure that\n    // listeners will see the correct weight upon addEdge.\n    assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n    ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n    return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new edge and adds it to the specified\n * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return g.addEdge(sourceVertex, targetVertex);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified edge to the graph, including its vertices if not\n * already included.\n *\n * @param targetGraph the graph for which the specified edge to be added.\n * @param sourceGraph the graph in which the specified edge is already\n * present\n * @param edge edge to add\n *\n * @return <tt>true</tt> if the target graph did not already contain the\n * specified edge.\n */\npublic static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge) {\n    V sourceVertex = sourceGraph.getEdgeSource(edge);\n    V targetVertex = sourceGraph.getEdgeTarget(edge);\n    targetGraph.addVertex(sourceVertex);\n    targetGraph.addVertex(targetVertex);\n    return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new weighted edge and adds it to the\n * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n * method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return addEdge(g, sourceVertex, targetVertex, weight);\n}"
            ],
            [
                "addGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all the vertices and all the edges of the specified source graph to\n * the specified destination graph. First all vertices of the source graph\n * are added to the destination graph. Then every edge of the source graph\n * is added to the destination graph. This method returns <code>true</code>\n * if the destination graph has been modified as a result of this operation,\n * otherwise it returns <code>false</code>.\n *\n * <p>The behavior of this operation is undefined if any of the specified\n * graphs is modified while operation is in progress.</p>\n *\n * @param destination the graph to which vertices and edges are added.\n * @param source the graph used as source for vertices and edges to add.\n *\n * @return <code>true</code> if and only if the destination graph has been\n * changed as a result of this operation.\n */\npublic static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source) {\n    boolean modified = addAllVertices(destination, source.vertexSet());\n    modified |= addAllEdges(destination, source, source.edgeSet());\n    return modified;\n}"
            ],
            [
                "addAllEdges",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds a subset of the edges of the specified source graph to the specified\n * destination graph. The behavior of this operation is undefined if either\n * of the graphs is modified while the operation is in progress. {@link\n * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n * be added automatically to the target graph.\n *\n * @param destination the graph to which edges are to be added\n * @param source the graph used as a source for edges to add\n * @param edges the edges to be added\n *\n * @return <tt>true</tt> if this graph changed as a result of the call\n */\npublic static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges) {\n    boolean modified = false;\n    for (E e : edges) {\n        V s = source.getEdgeSource(e);\n        V t = source.getEdgeTarget(e);\n        destination.addVertex(s);\n        destination.addVertex(t);\n        modified |= destination.addEdge(s, t, e);\n    }\n    return modified;\n}"
            ],
            [
                "addAllVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all of the specified vertices to the destination graph. The behavior\n * of this operation is undefined if the specified vertex collection is\n * modified while the operation is in progress. This method will invoke the\n * {@link Graph#addVertex(Object)} method.\n *\n * @param destination the graph to which edges are to be added\n * @param vertices the vertices to be added to the graph.\n *\n * @return <tt>true</tt> if graph changed as a result of the call\n *\n * @throws NullPointerException if the specified vertices contains one or\n * more null vertices, or if the specified vertex collection is <tt>\n * null</tt>.\n *\n * @see Graph#addVertex(Object)\n */\npublic static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices) {\n    boolean modified = false;\n    for (V v : vertices) {\n        modified |= destination.addVertex(v);\n    }\n    return modified;\n}"
            ],
            [
                "neighborListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the neighbors of a specified vertex.\n * If the graph is a multigraph vertices may appear more than once in the\n * returned list.\n *\n * @param g the graph to look for neighbors in.\n * @param vertex the vertex to get the neighbors of.\n *\n * @return a list of the vertices that are the neighbors of the specified\n * vertex.\n */\npublic static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex) {\n    List<V> neighbors = new ArrayList<V>();\n    for (E e : g.edgesOf(vertex)) {\n        neighbors.add(getOppositeVertex(g, e, vertex));\n    }\n    return neighbors;\n}"
            ],
            [
                "predecessorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct predecessors of a\n * specified vertex. If the graph is a multigraph, vertices may appear more\n * than once in the returned list.\n *\n * @param g the graph to look for predecessors in.\n * @param vertex the vertex to get the predecessors of.\n *\n * @return a list of the vertices that are the direct predecessors of the\n * specified vertex.\n */\npublic static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> predecessors = new ArrayList<V>();\n    Set<? extends E> edges = g.incomingEdgesOf(vertex);\n    for (E e : edges) {\n        predecessors.add(getOppositeVertex(g, e, vertex));\n    }\n    return predecessors;\n}"
            ],
            [
                "successorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct successors of a specified\n * vertex. If the graph is a multigraph vertices may appear more than once\n * in the returned list.\n *\n * @param g the graph to look for successors in.\n * @param vertex the vertex to get the successors of.\n *\n * @return a list of the vertices that are the direct successors of the\n * specified vertex.\n */\npublic static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> successors = new ArrayList<V>();\n    Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n    for (E e : edges) {\n        successors.add(getOppositeVertex(g, e, vertex));\n    }\n    return successors;\n}"
            ],
            [
                "undirectedGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns an undirected view of the specified graph. If the specified graph\n * is directed, returns an undirected view of it. If the specified graph is\n * already undirected, just returns it.\n *\n * @param g the graph for which an undirected view is to be returned.\n *\n * @return an undirected view of the specified graph, if it is directed, or\n * or the specified graph itself if it is already undirected.\n *\n * @throws IllegalArgumentException if the graph is neither DirectedGraph\n * nor UndirectedGraph.\n *\n * @see AsUndirectedGraph\n */\npublic static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n    } else if (g instanceof UndirectedGraph<?, ?>) {\n        return (UndirectedGraph<V, E>) g;\n    } else {\n        throw new IllegalArgumentException(\"Graph must be either DirectedGraph or UndirectedGraph\");\n    }\n}"
            ],
            [
                "testIncidence",
                "org.jgrapht",
                "Graphs",
                "/**\n * Tests whether an edge is incident to a vertex.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return true iff e is incident on v\n */\npublic static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v) {\n    return (g.getEdgeSource(e).equals(v)) || (g.getEdgeTarget(e).equals(v));\n}"
            ],
            [
                "getOppositeVertex",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the vertex opposite another vertex across an edge.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return vertex opposite to v across e\n */\npublic static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v) {\n    V source = g.getEdgeSource(e);\n    V target = g.getEdgeTarget(e);\n    if (v.equals(source)) {\n        return target;\n    } else if (v.equals(target)) {\n        return source;\n    } else {\n        throw new IllegalArgumentException(\"no such vertex: \" + v.toString());\n    }\n}"
            ],
            [
                "getPathVertexList",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the list of vertices visited by a path.\n *\n * @param path path of interest\n *\n * @return corresponding vertex list\n */\npublic static <V, E> List<V> getPathVertexList(GraphPath<V, E> path) {\n    Graph<V, E> g = path.getGraph();\n    List<V> list = new ArrayList<V>();\n    V v = path.getStartVertex();\n    list.add(v);\n    for (E e : path.getEdgeList()) {\n        v = getOppositeVertex(g, e, v);\n        list.add(v);\n    }\n    return list;\n}"
            ],
            [
                "range",
                "org.jgrapht.generate",
                "SimpleWeightedGraphMatrixGenerator",
                "///////////////////////////////////////////////////////////////////////////////////////////////\npublic static int[] range(final int from, final int to) {\n    int[] range = new int[to - from];\n    for (int i = from; i < to; ++i) {\n        range[i - from] = i;\n    }\n    return range;\n}"
            ],
            [
                "createGraphSpecifics",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "// -------------------------------------------------------------------------\n/**\n * @param <V>\n * @param <E>\n * @param g\n *\n * @return TODO Document me\n */\nstatic <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new DirectedSpecifics<V, E>((DirectedGraph<V, E>) g);\n    } else {\n        return new UndirectedSpecifics<V, E>(g);\n    }\n}"
            ],
            [
                "findGreedyChromaticNumber",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds the number of colors required for a greedy coloring of the graph.\n *\n * @param g an undirected graph to find the chromatic number of\n *\n * @return integer the approximate chromatic number from the greedy\n * algorithm\n */\npublic static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g) {\n    Map<Integer, Set<V>> coloredGroups = findGreedyColoredGroups(g);\n    return coloredGroups.keySet().size();\n}"
            ],
            [
                "findGreedyColoredGroups",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds a greedy coloring of the graph.\n *\n * @param g an undirected graph for which to find the coloring\n */\npublic static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g) {\n    // A copy of the graph is made, so that elements of the graph may be\n    // removed to carry out the algorithm\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // The Vertices will be sorted in decreasing order by degree, so that\n    // higher degree vertices have priority to be colored first\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    List<V> sortedVertices = new LinkedList<V>(sg.vertexSet());\n    Collections.sort(sortedVertices, comp);\n    Collections.reverse(sortedVertices);\n    int color;\n    // create a map which will hold color as key and Set<V> as value\n    Map<Integer, Set<V>> coloredGroups = new HashMap<Integer, Set<V>>();\n    // We'll attempt to color each vertex with a single color each\n    // iteration, and these vertices will be removed from the graph at the\n    // end of each iteration\n    for (color = 0; sg.vertexSet().size() > 0; color++) {\n        // This set will contain vertices that are colored with the\n        // current color of this iteration\n        Set<V> currentColor = new HashSet<V>();\n        for (Iterator<V> iter = sortedVertices.iterator(); iter.hasNext(); ) {\n            V v = iter.next();\n            // Add new vertices to be colored as long as they are not\n            // adjacent with any other vertex that has already been colored\n            // with the current color\n            boolean flag = true;\n            for (Iterator<V> innerIter = currentColor.iterator(); innerIter.hasNext(); ) {\n                V temp = innerIter.next();\n                if (sg.containsEdge(temp, v)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                currentColor.add(v);\n                iter.remove();\n            }\n        }\n        // Add all these vertices as a group for this color\n        coloredGroups.put(color, currentColor);\n        // Remove vertices from the graph and then repeat the process for\n        // the next iteration\n        sg.removeAllVertices(currentColor);\n    }\n    return coloredGroups;\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "BellmanFordShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by hops, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    BellmanFordShortestPath<V, E> alg = new BellmanFordShortestPath<V, E>(graph, startVertex);\n    return alg.getPathEdgeList(endVertex);\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "DijkstraShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by radius, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    DijkstraShortestPath<V, E> alg = new DijkstraShortestPath<V, E>(graph, startVertex, endVertex);\n    return alg.getPathEdgeList();\n}"
            ],
            [
                "of",
                "org.jgrapht.alg.util",
                "Pair",
                "/**\n * Creates new pair of elements pulling of the necessity to provide\n * corresponding types of the elements supplied\n *\n * @param a first element\n * @param b second element\n *\n * @return new pair\n */\npublic static <A, B> Pair<A, B> of(A a, B b) {\n    return new Pair<A, B>(a, b);\n}"
            ],
            [
                "isEulerian",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will check whether the graph passed in is Eulerian or not.\n *\n * @param g The graph to be checked\n *\n * @return true for Eulerian and false for non-Eulerian\n */\npublic static <V, E> boolean isEulerian(UndirectedGraph<V, E> g) {\n    // If the graph is not connected, then no Eulerian circuit exists\n    if (!(new ConnectivityInspector<V, E>(g)).isGraphConnected()) {\n        return false;\n    }\n    // A graph is Eulerian if and only if all vertices have even degree\n    // So, this code will check for that\n    Iterator<V> iter = g.vertexSet().iterator();\n    while (iter.hasNext()) {\n        V v = iter.next();\n        if ((g.degreeOf(v) % 2) == 1) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "getEulerianCircuitVertices",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will return a list of vertices which represents the Eulerian\n * circuit of the graph.\n *\n * @param g The graph to find an Eulerian circuit\n *\n * @return null if no Eulerian circuit exists, or a list of vertices\n * representing the Eulerian circuit if one does exist\n */\npublic static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g) {\n    // If the graph is not Eulerian then just return a null since no\n    // Eulerian circuit exists\n    if (!isEulerian(g)) {\n        return null;\n    }\n    // The circuit will be represented by a linked list\n    List<V> path = new LinkedList<V>();\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    path.add(sg.vertexSet().iterator().next());\n    // Algorithm for finding an Eulerian circuit Basically this will find an\n    // arbitrary circuit, then it will find another arbitrary circuit until\n    // every edge has been traversed\n    while (sg.edgeSet().size() > 0) {\n        V v = null;\n        // Find a vertex which has an edge that hasn't been traversed yet,\n        // and keep its index position in the circuit list\n        int index = 0;\n        for (Iterator<V> iter = path.iterator(); iter.hasNext(); index++) {\n            v = iter.next();\n            if (sg.degreeOf(v) > 0) {\n                break;\n            }\n        }\n        // Finds an arbitrary circuit of the current vertex and\n        // appends this into the circuit list\n        while (sg.degreeOf(v) > 0) {\n            for (Iterator<V> iter = sg.vertexSet().iterator(); iter.hasNext(); ) {\n                V temp = iter.next();\n                if (sg.containsEdge(v, temp)) {\n                    path.add(index, temp);\n                    sg.removeEdge(v, temp);\n                    v = temp;\n                    break;\n                }\n            }\n        }\n    }\n    return path;\n}"
            ],
            [
                "getApproximateOptimalForCompleteGraph",
                "org.jgrapht.alg",
                "HamiltonianCycle",
                "/**\n * This method will return an approximate minimal traveling salesman tour\n * (hamiltonian cycle). This algorithm requires that the graph be complete\n * and the triangle inequality exists (if x,y,z are vertices then\n * d(x,y)+d(y,z) &lt; d(x,z) for all x,y,z) then this algorithm will\n * guarantee a hamiltonian cycle such that the total weight of the cycle is\n * less than or equal to double the total weight of the optimal hamiltonian\n * cycle. The optimal solution is NP-complete, so this is a decent\n * approximation that runs in polynomial time.\n *\n * @param <V>\n * @param <E>\n * @param g is the graph to find the optimal tour for.\n *\n * @return The optimal tour as a list of vertices.\n */\npublic static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g) {\n    List<V> vertices = new LinkedList<V>(g.vertexSet());\n    // If the graph is not complete then return null since this algorithm\n    // requires the graph be complete\n    if ((vertices.size() * (vertices.size() - 1) / 2) != g.edgeSet().size()) {\n        return null;\n    }\n    List<V> tour = new LinkedList<V>();\n    // Each iteration a new vertex will be added to the tour until all\n    // vertices have been added\n    while (tour.size() != g.vertexSet().size()) {\n        boolean firstEdge = true;\n        double minEdgeValue = 0;\n        int minVertexFound = 0;\n        int vertexConnectedTo = 0;\n        // A check will be made for the shortest edge to a vertex not within\n        // the tour and that new vertex will be added to the vertex\n        for (int i = 0; i < tour.size(); i++) {\n            V v = tour.get(i);\n            for (int j = 0; j < vertices.size(); j++) {\n                double weight = g.getEdgeWeight(g.getEdge(v, vertices.get(j)));\n                if (firstEdge || (weight < minEdgeValue)) {\n                    firstEdge = false;\n                    minEdgeValue = weight;\n                    minVertexFound = j;\n                    vertexConnectedTo = i;\n                }\n            }\n        }\n        tour.add(vertexConnectedTo, vertices.get(minVertexFound));\n        vertices.remove(minVertexFound);\n    }\n    return tour;\n}"
            ],
            [
                "find2ApproximationCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a 2-approximation for a minimal vertex cover of the specified\n * graph. The algorithm promises a cover that is at most double the size of\n * a minimal cover. The algorithm takes O(|E|) time.\n *\n * <p>For more details see Jenny Walter, CMPU-240: Lecture notes for\n * Language Theory and Computation, Fall 2002, Vassar College, <a\n * href=\"http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf\">\n * http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf</a>.\n * </p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G'=(V',E') <-- G(V,E)\n    Subgraph<V, E, Graph<V, E>> sg = new Subgraph<V, E, Graph<V, E>>(g, null, null);\n    // while E' is non-empty\n    while (sg.edgeSet().size() > 0) {\n        // let (u,v) be an arbitrary edge of E'\n        E e = sg.edgeSet().iterator().next();\n        // C <-- C U {u,v}\n        V u = g.getEdgeSource(e);\n        V v = g.getEdgeTarget(e);\n        cover.add(u);\n        cover.add(v);\n        // remove from E' every edge incident on either u or v\n        sg.removeVertex(u);\n        sg.removeVertex(v);\n    }\n    // return C\n    return cover;\n}"
            ],
            [
                "findGreedyCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a greedy approximation for a minimal vertex cover of a specified\n * graph. At each iteration, the algorithm picks the vertex with the highest\n * degree and adds it to the cover, until all edges are covered.\n *\n * <p>The algorithm works on undirected graphs, but can also work on\n * directed graphs when their edge-directions are ignored. To ignore edge\n * directions you can use {@link org.jgrapht.Graphs#undirectedGraph(Graph)}\n * or {@link org.jgrapht.graph.AsUndirectedGraph}.</p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G' <-- G\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // compare vertices in descending order of degree\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    // while G' != {}\n    while (sg.edgeSet().size() > 0) {\n        // v <-- vertex with maximum degree in G'\n        V v = Collections.max(sg.vertexSet(), comp);\n        // C <-- C U {v}\n        cover.add(v);\n        // remove from G' every edge incident on v, and v itself\n        sg.removeVertex(v);\n    }\n    return cover;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "BEST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int BEST_ORDER = 0;"
            ],
            [
                "NATURAL_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int NATURAL_ORDER = 1;"
            ],
            [
                "SMALLEST_DEGREE_LAST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;"
            ],
            [
                "LARGEST_SATURATION_FIRST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;"
            ],
            [
                "DEFAULT_EDGE_WEIGHT",
                "org.jgrapht",
                "WeightedGraph",
                "/**\n * The default weight for an edge.\n */\npublic static double DEFAULT_EDGE_WEIGHT = 1.0;"
            ],
            [
                "HUB_VERTEX",
                "org.jgrapht.generate",
                "WheelGraphGenerator",
                "/**\n * Role for the hub vertex.\n */\npublic static final String HUB_VERTEX = \"Hub Vertex\";"
            ],
            [
                "CORNER_VERTEX",
                "org.jgrapht.generate",
                "GridGraphGenerator",
                "/**\n * Role for the vertices at the corners.\n */\npublic static final String CORNER_VERTEX = \"Corner Vertex\";"
            ],
            [
                "START_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the first vertex generated.\n */\npublic static final String START_VERTEX = \"Start Vertex\";"
            ],
            [
                "END_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the last vertex generated.\n */\npublic static final String END_VERTEX = \"End Vertex\";"
            ],
            [
                "CENTER_VERTEX",
                "org.jgrapht.generate",
                "StarGraphGenerator",
                "public static final String CENTER_VERTEX = \"Center Vertex\";"
            ],
            [
                "SENTINEL",
                "org.jgrapht.traverse",
                "DepthFirstIterator",
                "/**\n * Sentinel object. Unfortunately, we can't use null, because ArrayDeque\n * won't accept those. And we don't want to rely on the caller to provide a\n * sentinel object for us. So we have to play typecasting games.\n */\npublic static final Object SENTINEL = new Object();"
            ],
            [
                "BEFORE_EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge added event. This event is fired before an edge is added to a\n * graph.\n */\npublic static final int BEFORE_EDGE_ADDED = 21;"
            ],
            [
                "BEFORE_EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge removed event. This event is fired before an edge is removed\n * from a graph.\n */\npublic static final int BEFORE_EDGE_REMOVED = 22;"
            ],
            [
                "EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge added event. This event is fired after an edge is added to a graph.\n */\npublic static final int EDGE_ADDED = 23;"
            ],
            [
                "EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge removed event. This event is fired after an edge is removed from a\n * graph.\n */\npublic static final int EDGE_REMOVED = 24;"
            ],
            [
                "CONNECTED_COMPONENT_STARTED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal started event.\n */\npublic static final int CONNECTED_COMPONENT_STARTED = 31;"
            ],
            [
                "CONNECTED_COMPONENT_FINISHED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal finished event.\n */\npublic static final int CONNECTED_COMPONENT_FINISHED = 32;"
            ],
            [
                "BEFORE_VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex added event. This event is fired before a vertex is added\n * to a graph.\n */\npublic static final int BEFORE_VERTEX_ADDED = 11;"
            ],
            [
                "BEFORE_VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex removed event. This event is fired before a vertex is\n * removed from a graph.\n */\npublic static final int BEFORE_VERTEX_REMOVED = 12;"
            ],
            [
                "VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex added event. This event is fired after a vertex is added to a\n * graph.\n */\npublic static final int VERTEX_ADDED = 13;"
            ],
            [
                "VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex removed event. This event is fired after a vertex is removed from\n * a graph.\n */\npublic static final int VERTEX_REMOVED = 14;"
            ],
            [
                "NULL_NODE",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "public static final int NULL_NODE = -1;"
            ],
            [
                "DEBUG",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected static final boolean DEBUG = false;"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg",
                "EdmondsKarpMaximumFlow",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 0.000000001;"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveClosure",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveClosure INSTANCE = new TransitiveClosure();"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveReduction",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveReduction INSTANCE = new TransitiveReduction();"
            ],
            [
                "NEGATIVE_UNDIRECTED_EDGE",
                "org.jgrapht.alg",
                "BellmanFordIterator",
                "/**\n * Error message.\n */\nprotected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg.flow",
                "MaximumFlowAlgorithmBase",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 1e-9;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [
            [
                "method",
                "java.lang",
                "String"
            ],
            [
                "str",
                "java.lang",
                "String"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "getCurrentMapping",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "public IsomorphicGraphMapping<V, E> getCurrentMapping() {\n    return new IsomorphicGraphMapping<V, E>(g1, g2, core1, core2);\n}"
            ],
            [
                "isFeasiblePair",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "/**\n * @return true, if the already matched vertices of graph1 plus the first\n * vertex of nextPair are isomorphic to the already matched vertices of\n * graph2 and the second one vertex of nextPair.\n */\npublic abstract boolean isFeasiblePair();"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "areCompatibleVertexes",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "/**\n * checks the vertices v1 and v2 for semantic equivalence\n *\n * @param v1\n * @param v2\n *\n * @return v1 and v2 are equivalent\n */\nprotected boolean areCompatibleVertexes(int v1, int v2) {\n    return (vertexComparator == null) || (vertexComparator.compare(g1.getVertex(v1), g2.getVertex(v2)) == 0);\n}"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "nextPair",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "/**\n * calculates a pair of nodes which may be added to the current matching,\n * according to the VF2 algorithm.\n *\n * @return false, if there are no more pairs left\n */\npublic boolean nextPair() {\n    if (addVertex2 == NULL_NODE) {\n        addVertex2 = 0;\n    }\n    if (addVertex1 == NULL_NODE) {\n        addVertex1 = 0;\n    } else {\n        addVertex1++;\n    }\n    // check incoming and outgoing edges\n    if ((t1BothLen > coreLen) && (t2BothLen > coreLen)) {\n        // find minimum for addVertex2 in core2 and t2in/t2out\n        while ((addVertex2 < n2) && ((core2[addVertex2] != NULL_NODE) || (out2[addVertex2] == 0) || (in2[addVertex2] == 0))) {\n            addVertex2++;\n            addVertex1 = 0;\n        }\n        // find first/next vertex for addVertex1 in core1 and t1in/t1out\n        while ((addVertex1 < n1) && ((core1[addVertex1] != NULL_NODE) || (out1[addVertex1] == 0) || (in1[addVertex1] == 0))) {\n            addVertex1++;\n        }\n    } else // check outgoing edges\n    if ((t1OutLen > coreLen) && (t2OutLen > coreLen)) {\n        while ((addVertex2 < n2) && ((core2[addVertex2] != NULL_NODE) || (out2[addVertex2] == 0))) {\n            addVertex2++;\n            addVertex1 = 0;\n        }\n        while ((addVertex1 < n1) && ((core1[addVertex1] != NULL_NODE) || (out1[addVertex1] == 0))) {\n            addVertex1++;\n        }\n    } else // check incoming edges\n    if ((t1InLen > coreLen) && (t2InLen > coreLen)) {\n        while ((addVertex2 < n2) && ((core2[addVertex2] != NULL_NODE) || (in2[addVertex2] == 0))) {\n            addVertex2++;\n            addVertex1 = 0;\n        }\n        while ((addVertex1 < n1) && ((core1[addVertex1] != NULL_NODE) || (in1[addVertex1] == 0))) {\n            addVertex1++;\n        }\n    } else // check new edges\n    {\n        while ((addVertex2 < n2) && (core2[addVertex2] != NULL_NODE)) {\n            addVertex2++;\n            addVertex1 = 0;\n        }\n        while ((addVertex1 < n1) && (core1[addVertex1] != NULL_NODE)) {\n            addVertex1++;\n        }\n    }\n    if ((addVertex1 < n1) && (addVertex2 < n2)) {\n        showLog(\"nextPair\", \"next candidate pair: (\" + g1.getVertex(addVertex1) + \", \" + g2.getVertex(addVertex2) + \")\");\n        return true;\n    }\n    // there are no more pairs..\n    showLog(\"nextPair\", \"no more candidate pairs\");\n    addVertex1 = addVertex2 = NULL_NODE;\n    return false;\n}"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "areCompatibleEdges",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "/**\n * checks the edges from v1 to v2 and from u1 to u2 for semantic equivalence\n *\n * @param v1\n * @param v2\n * @param u1\n * @param u2\n *\n * @return edges are equivalent\n */\nprotected boolean areCompatibleEdges(int v1, int v2, int u1, int u2) {\n    return (edgeComparator == null) || (edgeComparator.compare(g1.getEdge(v1, v2), g2.getEdge(u1, u2)) == 0);\n}"
            ],
            [
                "isGoal",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "/**\n * @return is the matching already complete?\n */\npublic boolean isGoal() {\n    return coreLen == n2;\n}"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "indexOf",
                "java.lang",
                "String",
                "public int indexOf(int arg0)"
            ],
            [
                "contentEquals",
                "java.lang",
                "String",
                "public boolean contentEquals(CharSequence arg0)"
            ],
            [
                "replace",
                "java.lang",
                "String",
                "public String replace(CharSequence arg0, CharSequence arg1)"
            ],
            [
                "split",
                "java.lang",
                "String",
                "public String[] split(String arg0)"
            ],
            [
                "strip",
                "java.lang",
                "String",
                "public String strip()"
            ],
            [
                "formatted",
                "java.lang",
                "String",
                "public String formatted(Object[] arg0)"
            ],
            [
                "getBytes",
                "java.lang",
                "String",
                "public byte[] getBytes(Charset arg0)"
            ],
            [
                "isLatin1",
                "java.lang",
                "String",
                "boolean isLatin1()"
            ],
            [
                "charAt",
                "java.lang",
                "String",
                "public char charAt(int arg0)"
            ],
            [
                "split",
                "java.lang",
                "String",
                "public String[] split(String arg0, int arg1)"
            ],
            [
                "toUpperCase",
                "java.lang",
                "String",
                "public String toUpperCase()"
            ],
            [
                "replaceFirst",
                "java.lang",
                "String",
                "public String replaceFirst(String arg0, String arg1)"
            ],
            [
                "codePointAt",
                "java.lang",
                "String",
                "public int codePointAt(int arg0)"
            ],
            [
                "indent",
                "java.lang",
                "String",
                "public String indent(int arg0)"
            ],
            [
                "offsetByCodePoints",
                "java.lang",
                "String",
                "public int offsetByCodePoints(int arg0, int arg1)"
            ],
            [
                "translateEscapes",
                "java.lang",
                "String",
                "public String translateEscapes()"
            ],
            [
                "endsWith",
                "java.lang",
                "String",
                "public boolean endsWith(String arg0)"
            ],
            [
                "stripLeading",
                "java.lang",
                "String",
                "public String stripLeading()"
            ],
            [
                "indexOf",
                "java.lang",
                "String",
                "public int indexOf(String arg0, int arg1)"
            ],
            [
                "codePoints",
                "java.lang",
                "String",
                "public IntStream codePoints()"
            ],
            [
                "lastIndexOf",
                "java.lang",
                "String",
                "public int lastIndexOf(String arg0, int arg1)"
            ],
            [
                "indexOf",
                "java.lang",
                "String",
                "public int indexOf(String arg0)"
            ],
            [
                "matches",
                "java.lang",
                "String",
                "public boolean matches(String arg0)"
            ],
            [
                "regionMatches",
                "java.lang",
                "String",
                "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)"
            ],
            [
                "hashCode",
                "java.lang",
                "String",
                "public int hashCode()"
            ],
            [
                "toString",
                "java.lang",
                "String",
                "public String toString()"
            ],
            [
                "lastIndexOf",
                "java.lang",
                "String",
                "public int lastIndexOf(String arg0)"
            ],
            [
                "repeat",
                "java.lang",
                "String",
                "public String repeat(int arg0)"
            ],
            [
                "toCharArray",
                "java.lang",
                "String",
                "public char[] toCharArray()"
            ],
            [
                "stripIndent",
                "java.lang",
                "String",
                "public String stripIndent()"
            ],
            [
                "compareToIgnoreCase",
                "java.lang",
                "String",
                "public int compareToIgnoreCase(String arg0)"
            ],
            [
                "transform",
                "java.lang",
                "String",
                "public <R> R transform(Function<? super String, ? extends R> arg0)"
            ],
            [
                "subSequence",
                "java.lang",
                "String",
                "public CharSequence subSequence(int arg0, int arg1)"
            ],
            [
                "toUpperCase",
                "java.lang",
                "String",
                "public String toUpperCase(Locale arg0)"
            ],
            [
                "indexOf",
                "java.lang",
                "String",
                "public int indexOf(int arg0, int arg1)"
            ],
            [
                "toLowerCase",
                "java.lang",
                "String",
                "public String toLowerCase(Locale arg0)"
            ],
            [
                "intern",
                "java.lang",
                "String",
                "public native String intern()"
            ],
            [
                "isEmpty",
                "java.lang",
                "String",
                "public boolean isEmpty()"
            ],
            [
                "substring",
                "java.lang",
                "String",
                "public String substring(int arg0)"
            ],
            [
                "codePointBefore",
                "java.lang",
                "String",
                "public int codePointBefore(int arg0)"
            ],
            [
                "trim",
                "java.lang",
                "String",
                "public String trim()"
            ],
            [
                "startsWith",
                "java.lang",
                "String",
                "public boolean startsWith(String arg0, int arg1)"
            ],
            [
                "lastIndexOf",
                "java.lang",
                "String",
                "public int lastIndexOf(int arg0, int arg1)"
            ],
            [
                "regionMatches",
                "java.lang",
                "String",
                "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)"
            ],
            [
                "stripTrailing",
                "java.lang",
                "String",
                "public String stripTrailing()"
            ],
            [
                "getBytes",
                "java.lang",
                "String",
                "public byte[] getBytes()"
            ],
            [
                "getBytes",
                "java.lang",
                "String",
                "public byte[] getBytes(String arg0) throws UnsupportedEncodingException"
            ],
            [
                "compareTo",
                "java.lang",
                "String",
                "public int compareTo(String arg0)"
            ],
            [
                "describeConstable",
                "java.lang",
                "String",
                "public Optional<String> describeConstable()"
            ],
            [
                "isBlank",
                "java.lang",
                "String",
                "public boolean isBlank()"
            ],
            [
                "substring",
                "java.lang",
                "String",
                "public String substring(int arg0, int arg1)"
            ],
            [
                "length",
                "java.lang",
                "String",
                "public int length()"
            ],
            [
                "contentEquals",
                "java.lang",
                "String",
                "public boolean contentEquals(StringBuffer arg0)"
            ],
            [
                "replace",
                "java.lang",
                "String",
                "public String replace(char arg0, char arg1)"
            ],
            [
                "lines",
                "java.lang",
                "String",
                "public Stream<String> lines()"
            ],
            [
                "startsWith",
                "java.lang",
                "String",
                "public boolean startsWith(String arg0)"
            ],
            [
                "equalsIgnoreCase",
                "java.lang",
                "String",
                "public boolean equalsIgnoreCase(String arg0)"
            ],
            [
                "value",
                "java.lang",
                "String",
                "byte[] value()"
            ],
            [
                "contains",
                "java.lang",
                "String",
                "public boolean contains(CharSequence arg0)"
            ],
            [
                "coder",
                "java.lang",
                "String",
                "byte coder()"
            ],
            [
                "replaceAll",
                "java.lang",
                "String",
                "public String replaceAll(String arg0, String arg1)"
            ],
            [
                "lastIndexOf",
                "java.lang",
                "String",
                "public int lastIndexOf(int arg0)"
            ],
            [
                "chars",
                "java.lang",
                "String",
                "public IntStream chars()"
            ],
            [
                "equals",
                "java.lang",
                "String",
                "public boolean equals(Object arg0)"
            ],
            [
                "toLowerCase",
                "java.lang",
                "String",
                "public String toLowerCase()"
            ],
            [
                "codePointCount",
                "java.lang",
                "String",
                "public int codePointCount(int arg0, int arg1)"
            ],
            [
                "concat",
                "java.lang",
                "String",
                "public String concat(String arg0)"
            ],
            [
                "resolveConstantDesc",
                "java.lang",
                "String",
                "public String resolveConstantDesc(MethodHandles.Lookup arg0)"
            ],
            [
                "compareTo",
                "java.lang",
                "Comparable",
                "public abstract int compareTo(T arg0)"
            ],
            [
                "charAt",
                "java.lang",
                "CharSequence",
                "public abstract char charAt(int arg0)"
            ],
            [
                "length",
                "java.lang",
                "CharSequence",
                "public abstract int length()"
            ],
            [
                "subSequence",
                "java.lang",
                "CharSequence",
                "public abstract CharSequence subSequence(int arg0, int arg1)"
            ],
            [
                "toString",
                "java.lang",
                "CharSequence",
                "public abstract String toString()"
            ],
            [
                "chars",
                "java.lang",
                "CharSequence",
                "public default IntStream chars()"
            ],
            [
                "codePoints",
                "java.lang",
                "CharSequence",
                "public default IntStream codePoints()"
            ],
            [
                "isEmpty",
                "java.lang",
                "CharSequence",
                "public default boolean isEmpty()"
            ],
            [
                "describeConstable",
                "java.lang.constant",
                "Constable",
                "public abstract Optional<? extends ConstantDesc> describeConstable()"
            ],
            [
                "resolveConstantDesc",
                "java.lang.constant",
                "ConstantDesc",
                "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [
            [
                "core1",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected int[] core1, core2, in1, in2, out1, out2;"
            ],
            [
                "core2",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected int[] core1, core2, in1, in2, out1, out2;"
            ],
            [
                "in1",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected int[] core1, core2, in1, in2, out1, out2;"
            ],
            [
                "in2",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected int[] core1, core2, in1, in2, out1, out2;"
            ],
            [
                "out1",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected int[] core1, core2, in1, in2, out1, out2;"
            ],
            [
                "out2",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected int[] core1, core2, in1, in2, out1, out2;"
            ],
            [
                "coreLen",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected int coreLen, n1, n2, t1BothLen, t2BothLen, t1InLen, t2InLen, t1OutLen, t2OutLen, addedVertex1, addVertex1, addVertex2;"
            ],
            [
                "n1",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected int coreLen, n1, n2, t1BothLen, t2BothLen, t1InLen, t2InLen, t1OutLen, t2OutLen, addedVertex1, addVertex1, addVertex2;"
            ],
            [
                "n2",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected int coreLen, n1, n2, t1BothLen, t2BothLen, t1InLen, t2InLen, t1OutLen, t2OutLen, addedVertex1, addVertex1, addVertex2;"
            ],
            [
                "t1BothLen",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected int coreLen, n1, n2, t1BothLen, t2BothLen, t1InLen, t2InLen, t1OutLen, t2OutLen, addedVertex1, addVertex1, addVertex2;"
            ],
            [
                "t2BothLen",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected int coreLen, n1, n2, t1BothLen, t2BothLen, t1InLen, t2InLen, t1OutLen, t2OutLen, addedVertex1, addVertex1, addVertex2;"
            ],
            [
                "t1InLen",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected int coreLen, n1, n2, t1BothLen, t2BothLen, t1InLen, t2InLen, t1OutLen, t2OutLen, addedVertex1, addVertex1, addVertex2;"
            ],
            [
                "t2InLen",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected int coreLen, n1, n2, t1BothLen, t2BothLen, t1InLen, t2InLen, t1OutLen, t2OutLen, addedVertex1, addVertex1, addVertex2;"
            ],
            [
                "t1OutLen",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected int coreLen, n1, n2, t1BothLen, t2BothLen, t1InLen, t2InLen, t1OutLen, t2OutLen, addedVertex1, addVertex1, addVertex2;"
            ],
            [
                "t2OutLen",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected int coreLen, n1, n2, t1BothLen, t2BothLen, t1InLen, t2InLen, t1OutLen, t2OutLen, addedVertex1, addVertex1, addVertex2;"
            ],
            [
                "addedVertex1",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected int coreLen, n1, n2, t1BothLen, t2BothLen, t1InLen, t2InLen, t1OutLen, t2OutLen, addedVertex1, addVertex1, addVertex2;"
            ],
            [
                "addVertex1",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected int coreLen, n1, n2, t1BothLen, t2BothLen, t1InLen, t2InLen, t1OutLen, t2OutLen, addedVertex1, addVertex1, addVertex2;"
            ],
            [
                "addVertex2",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected int coreLen, n1, n2, t1BothLen, t2BothLen, t1InLen, t2InLen, t1OutLen, t2OutLen, addedVertex1, addVertex1, addVertex2;"
            ],
            [
                "g1",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected GraphOrdering<V, E> g1, g2;"
            ],
            [
                "g2",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected GraphOrdering<V, E> g1, g2;"
            ],
            [
                "vertexComparator",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected Comparator<V> vertexComparator;"
            ],
            [
                "edgeComparator",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected Comparator<E> edgeComparator;"
            ]
        ],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 26334,
        "oracle": ";",
        "oracleType": "PRE",
        "projectName": "jgrapht-core-0.9.2",
        "packageName": "org.jgrapht.alg.isomorphism",
        "className": "VF2AbstractIsomorphismInspector",
        "javadocTag": "@param cacheEdges if true, edges get cached for faster access",
        "methodJavadoc": "    /**\n     * This implementation of the VF2 algorithm does not support graphs with\n     * multiple edges.\n     *\n     * @param graph1 the first graph\n     * @param graph2 the second graph\n     * @param vertexComparator comparator for semantic equivalence of vertices\n     * @param edgeComparator comparator for semantic equivalence of edges\n     * @param cacheEdges if true, edges get cached for faster access\n     */",
        "methodSourceCode": "public VF2AbstractIsomorphismInspector(Graph<V, E> graph1, Graph<V, E> graph2, Comparator<V> vertexComparator, Comparator<E> edgeComparator, boolean cacheEdges){\n    if ((graph1 instanceof Multigraph) || (graph2 instanceof Multigraph) || (graph1 instanceof Pseudograph) || (graph2 instanceof Pseudograph) || (graph1 instanceof DirectedMultigraph) || (graph2 instanceof DirectedMultigraph) || (graph1 instanceof DirectedPseudograph) || (graph2 instanceof DirectedPseudograph)) {\n        throw new UnsupportedOperationException(\"graphs with multiple \" + \"edges are not supported\");\n    }\n    if (((graph1 instanceof DirectedGraph) && (graph2 instanceof UndirectedGraph)) || ((graph1 instanceof UndirectedGraph) && (graph2 instanceof DirectedGraph))) {\n        throw new IllegalArgumentException(\"can not match directed with \" + \"undirected graphs\");\n    }\n    this.graph1 = graph1;\n    this.graph2 = graph2;\n    this.vertexComparator = vertexComparator;\n    this.edgeComparator = edgeComparator;\n    this.ordering1 = new GraphOrdering<V, E>(graph1, true, cacheEdges);\n    this.ordering2 = new GraphOrdering<V, E>(graph2, true, cacheEdges);\n}",
        "classJavadoc": "/**\n     * This implementation of the VF2 algorithm does not support graphs with\n     * multiple edges.\n     *\n     * @param graph1 the first graph\n     * @param graph2 the second graph\n     * @param vertexComparator comparator for semantic equivalence of vertices\n     * @param edgeComparator comparator for semantic equivalence of edges\n     * @param cacheEdges if true, edges get cached for faster access\n     */",
        "classSourceCode": "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------------\n * VF2AbstractIsomorphismInspector.java\n * -------------------------\n * (C) Copyright 2015, by Fabian Sp\u00e4h and Contributors.\n *\n * Original Author:  Fabian Sp\u00e4h\n * Contributor(s):   Rita Dobler\n *\n * $Id$\n *\n * Changes\n * -------\n * 20-Jun-2015 : Initial revision (FS);\n *\n */\npackage org.jgrapht.alg.isomorphism;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\nimport org.jgrapht.graph.*;\n\n\npublic abstract class VF2AbstractIsomorphismInspector<V, E>\n    implements IsomorphismInspector<V, E>\n{\n    protected Graph<V, E> graph1, graph2;\n\n    protected Comparator<V> vertexComparator;\n    protected Comparator<E> edgeComparator;\n\n    protected GraphOrdering<V, E> ordering1, ordering2;\n\n    /**\n     * This implementation of the VF2 algorithm does not support graphs with\n     * multiple edges.\n     *\n     * @param graph1 the first graph\n     * @param graph2 the second graph\n     * @param vertexComparator comparator for semantic equivalence of vertices\n     * @param edgeComparator comparator for semantic equivalence of edges\n     * @param cacheEdges if true, edges get cached for faster access\n     */\n    public VF2AbstractIsomorphismInspector(\n        Graph<V, E> graph1,\n        Graph<V, E> graph2,\n        Comparator<V> vertexComparator,\n        Comparator<E> edgeComparator,\n        boolean cacheEdges)\n    {\n        if ((graph1 instanceof Multigraph)\n            || (graph2 instanceof Multigraph)\n            || (graph1 instanceof Pseudograph)\n            || (graph2 instanceof Pseudograph)\n            || (graph1 instanceof DirectedMultigraph)\n            || (graph2 instanceof DirectedMultigraph)\n            || (graph1 instanceof DirectedPseudograph)\n            || (graph2 instanceof DirectedPseudograph))\n        {\n            throw new UnsupportedOperationException(\n                \"graphs with multiple \"\n                + \"edges are not supported\");\n        }\n\n        if (((graph1 instanceof DirectedGraph)\n                && (graph2 instanceof UndirectedGraph))\n            || ((graph1 instanceof UndirectedGraph)\n                && (graph2 instanceof DirectedGraph)))\n        {\n            throw new IllegalArgumentException(\n                \"can not match directed with \"\n                + \"undirected graphs\");\n        }\n\n        this.graph1 = graph1;\n        this.graph2 = graph2;\n        this.vertexComparator = vertexComparator;\n        this.edgeComparator = edgeComparator;\n        this.ordering1 = new GraphOrdering<V, E>(graph1, true,\n            cacheEdges);\n        this.ordering2 = new GraphOrdering<V, E>(graph2, true,\n            cacheEdges);\n    }\n\n    public VF2AbstractIsomorphismInspector(\n        Graph<V, E> graph1,\n        Graph<V, E> graph2,\n        Comparator<V> vertexComparator,\n        Comparator<E> edgeComparator)\n    {\n        this(graph1,\n            graph2,\n            vertexComparator,\n            edgeComparator,\n            true);\n    }\n\n    public VF2AbstractIsomorphismInspector(\n        Graph<V, E> graph1,\n        Graph<V, E> graph2,\n        boolean cacheEdges)\n    {\n        this(graph1,\n            graph2,\n            null,\n            null,\n            cacheEdges);\n    }\n\n    public VF2AbstractIsomorphismInspector(\n        Graph<V, E> graph1,\n        Graph<V, E> graph2)\n    {\n        this(graph1,\n            graph2,\n            true);\n    }\n\n    @Override public abstract Iterator<GraphMapping<V, E>> getMappings();\n\n    @Override public boolean isomorphismExists()\n    {\n        Iterator<GraphMapping<V, E>> iter = getMappings();\n        return iter.hasNext();\n    }\n}\n\n// End VF2AbstractIsomorphismInspector.java\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "PartiteRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "RandomGraphHelper",
                "org.jgrapht.experimental"
            ],
            [
                "GraphReader",
                "org.jgrapht.experimental"
            ],
            [
                "DirectedAcyclicGraph",
                "org.jgrapht.experimental.dag"
            ],
            [
                "GraphSquare",
                "org.jgrapht.experimental"
            ],
            [
                "UniformRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "GraphTests",
                "org.jgrapht.experimental"
            ],
            [
                "ApproximationAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "BrownBacktrackColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "GreedyColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "IntArrayGraphAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ExactAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ListenableGraph",
                "org.jgrapht"
            ],
            [
                "ModifiableInteger",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeapNode",
                "org.jgrapht.util"
            ],
            [
                "WeightCombiner",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeap",
                "org.jgrapht.util"
            ],
            [
                "TypeUtil",
                "org.jgrapht.util"
            ],
            [
                "ArrayUnenforcedSet",
                "org.jgrapht.util"
            ],
            [
                "VertexPair",
                "org.jgrapht.util"
            ],
            [
                "MathUtil",
                "org.jgrapht.util"
            ],
            [
                "PrefetchIterator",
                "org.jgrapht.util"
            ],
            [
                "VertexFactory",
                "org.jgrapht"
            ],
            [
                "Graph",
                "org.jgrapht"
            ],
            [
                "GraphPath",
                "org.jgrapht"
            ],
            [
                "UndirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraph",
                "org.jgrapht.graph"
            ],
            [
                "MixedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DefaultGraphMapping",
                "org.jgrapht.graph"
            ],
            [
                "WeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskEdgeSet",
                "org.jgrapht.graph"
            ],
            [
                "Pseudograph",
                "org.jgrapht.graph"
            ],
            [
                "MaskFunctor",
                "org.jgrapht.graph"
            ],
            [
                "GraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractBaseGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "Multigraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultWeightedEdge",
                "org.jgrapht.graph"
            ],
            [
                "ListenableDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeSetFactory",
                "org.jgrapht.graph"
            ],
            [
                "GraphDelegator",
                "org.jgrapht.graph"
            ],
            [
                "DefaultListenableGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedVertexFactory",
                "org.jgrapht.graph"
            ],
            [
                "DefaultEdge",
                "org.jgrapht.graph"
            ],
            [
                "MaskVertexSet",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "IntrusiveEdge",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphPathImpl",
                "org.jgrapht.graph"
            ],
            [
                "Subgraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractGraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedEdgeFactory",
                "org.jgrapht.graph"
            ],
            [
                "SimpleWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "WeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeReversedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "AbstractGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "ListenableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraphPath",
                "org.jgrapht.graph"
            ],
            [
                "ParanoidGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphHelper",
                "org.jgrapht"
            ],
            [
                "Graphs",
                "org.jgrapht"
            ],
            [
                "DirectedGraph",
                "org.jgrapht"
            ],
            [
                "WeightedGraph",
                "org.jgrapht"
            ],
            [
                "HyperCubeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RingGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WheelGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GridGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "ScaleFreeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedBipartiteGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "LinearGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RandomGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGeneratorAdapter",
                "org.jgrapht.generate"
            ],
            [
                "EmptyGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteBipartiteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "StarGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "UndirectedGraph",
                "org.jgrapht"
            ],
            [
                "TopologicalOrderIterator",
                "org.jgrapht.traverse"
            ],
            [
                "CrossComponentIterator",
                "org.jgrapht.traverse"
            ],
            [
                "AbstractGraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "ClosestFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "BreadthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "DepthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "GraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "EdgeFactory",
                "org.jgrapht"
            ],
            [
                "GraphMapping",
                "org.jgrapht"
            ],
            [
                "VertexSetListener",
                "org.jgrapht.event"
            ],
            [
                "EdgeTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "TraversalListener",
                "org.jgrapht.event"
            ],
            [
                "GraphEdgeChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "VertexTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphListener",
                "org.jgrapht.event"
            ],
            [
                "TraversalListenerAdapter",
                "org.jgrapht.event"
            ],
            [
                "ConnectedComponentTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphVertexChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "TarjanLowestCommonAncestor",
                "org.jgrapht.alg"
            ],
            [
                "PrimMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "BlockCutpointGraph",
                "org.jgrapht.alg"
            ],
            [
                "AllDirectedPaths",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPathsIterator",
                "org.jgrapht.alg"
            ],
            [
                "KruskalMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "StrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "VF2State",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2AbstractIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "GraphOrdering",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphicGraphMapping",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2MappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "BronKerboschCliqueFinder",
                "org.jgrapht.alg"
            ],
            [
                "ChromaticNumber",
                "org.jgrapht.alg"
            ],
            [
                "KosarajuStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "DijkstraShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElement",
                "org.jgrapht.alg"
            ],
            [
                "AStarShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordPathElement",
                "org.jgrapht.alg"
            ],
            [
                "FloydWarshallShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "UnionFind",
                "org.jgrapht.alg.util"
            ],
            [
                "AlwaysEqualComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Extension",
                "org.jgrapht.alg.util"
            ],
            [
                "VertexDegreeComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Pair",
                "org.jgrapht.alg.util"
            ],
            [
                "GabowStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "HawickJamesSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "DirectedSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "JohnsonSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TiernanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "UndirectedCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "PatonCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TarjanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "SzwarcfiterLauerSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "BiconnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "ConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "MinSourceSinkCut",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsBlossomShrinking",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveClosure",
                "org.jgrapht.alg"
            ],
            [
                "HopcroftKarpBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "StoerWagnerMinimumCut",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "KuhnMunkresMinimalWeightBipartitePerfectMatching",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveReduction",
                "org.jgrapht.alg"
            ],
            [
                "EulerianCircuit",
                "org.jgrapht.alg"
            ],
            [
                "DirectedNeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "NaiveLcaFinder",
                "org.jgrapht.alg"
            ],
            [
                "MaximumWeightBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "HamiltonianCycle",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "NeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "VertexCovers",
                "org.jgrapht.alg"
            ],
            [
                "CycleDetector",
                "org.jgrapht.alg"
            ],
            [
                "AStarAdmissibleHeuristic",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MinimumSpanningTree",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "WeightedMatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "StrongConnectivityAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MaximumFlowAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "CliqueMinimalSeparatorDecomposition",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordIterator",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElement",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "PushRelabelMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "MaximumFlowAlgorithmBase",
                "org.jgrapht.alg.flow"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "addVertices",
                "org.jgrapht.experimental",
                "RandomGraphHelper",
                "/**\n * .\n *\n * @param target\n * @param vertexFactory\n * @param numVertices\n *\n * @return vertices\n */\n@SuppressWarnings(\"unchecked\")\npublic static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices) {\n    Object[] vertices = new Object[numVertices];\n    for (int i = 0; i < numVertices; ++i) {\n        vertices[i] = vertexFactory.createVertex();\n        target.addVertex(vertices[i]);\n    }\n    return vertices;\n}"
            ],
            [
                "isEmpty",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isEmpty(Graph<V, E> g) {\n    return g.edgeSet().isEmpty();\n}"
            ],
            [
                "isComplete",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isComplete(Graph<V, E> g) {\n    int n = g.vertexSet().size();\n    return g.edgeSet().size() == (n * (n - 1) / 2);\n}"
            ],
            [
                "isConnected",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isConnected(Graph<V, E> g) {\n    int numVertices = g.vertexSet().size();\n    int numEdges = g.edgeSet().size();\n    if (numEdges < (numVertices - 1)) {\n        return false;\n    }\n    if ((numVertices < 2) || (numEdges > ((numVertices - 1) * (numVertices - 2) / 2))) {\n        return true;\n    }\n    Set<V> known = new HashSet<V>();\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = g.vertexSet().iterator().next();\n    // start with node 1\n    queue.add(v);\n    known.add(v);\n    while (!queue.isEmpty()) {\n        v = queue.removeFirst();\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            v = it.next();\n            if (!known.contains(v)) {\n                known.add(v);\n                queue.add(v);\n            }\n        }\n    }\n    return known.size() == numVertices;\n}"
            ],
            [
                "isTree",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isTree(Graph<V, E> g) {\n    return isConnected(g) && (g.edgeSet().size() == (g.vertexSet().size() - 1));\n}"
            ],
            [
                "isBipartite",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isBipartite(Graph<V, E> g) {\n    if ((4 * g.edgeSet().size()) > (g.vertexSet().size() * g.vertexSet().size())) {\n        return false;\n    }\n    if (isEmpty(g)) {\n        return true;\n    }\n    Set<V> unknown = new HashSet<V>(g.vertexSet());\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = unknown.iterator().next();\n    Set<V> odd = new HashSet<V>();\n    queue.add(v);\n    while (!unknown.isEmpty()) {\n        if (queue.isEmpty()) {\n            queue.add(unknown.iterator().next());\n        }\n        v = queue.removeFirst();\n        unknown.remove(v);\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            V n = it.next();\n            if (unknown.contains(n)) {\n                queue.add(n);\n                if (!odd.contains(v)) {\n                    odd.add(n);\n                }\n            } else if (!(odd.contains(v) ^ odd.contains(n))) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
            ],
            [
                "union",
                "org.jgrapht.util",
                "FibonacciHeap",
                "// size\n/**\n * Joins two Fibonacci heaps into a new one. No heap consolidation is\n * performed at this time. The two root lists are simply joined together.\n *\n * <p>Running time: O(1) actual</p>\n *\n * @param h1 first heap\n * @param h2 second heap\n *\n * @return new heap containing h1 and h2\n */\npublic static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2) {\n    FibonacciHeap<T> h = new FibonacciHeap<T>();\n    if ((h1 != null) && (h2 != null)) {\n        h.minNode = h1.minNode;\n        if (h.minNode != null) {\n            if (h2.minNode != null) {\n                h.minNode.right.left = h2.minNode.left;\n                h2.minNode.left.right = h.minNode.right;\n                h.minNode.right = h2.minNode;\n                h2.minNode.left = h.minNode;\n                if (h2.minNode.key < h1.minNode.key) {\n                    h.minNode = h2.minNode;\n                }\n            }\n        } else {\n            h.minNode = h2.minNode;\n        }\n        h.nNodes = h1.nNodes + h2.nNodes;\n    }\n    return h;\n}"
            ],
            [
                "uncheckedCast",
                "org.jgrapht.util",
                "TypeUtil",
                "/**\n * Casts an object to a type.\n *\n * @param o object to be cast\n * @param typeDecl conveys the target type information; the actual value is\n * unused and can be null since this is all just stupid compiler tricks\n *\n * @return the result of the cast\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl) {\n    return (T) o;\n}"
            ],
            [
                "factorial",
                "org.jgrapht.util",
                "MathUtil",
                "public static long factorial(int N) {\n    long multi = 1;\n    for (int i = 1; i <= N; i++) {\n        multi = multi * i;\n    }\n    return multi;\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graphs",
                "/**\n * Creates a new edge and adds it to the specified graph similarly to the\n * {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n *\n * @see Graph#addEdge(Object, Object)\n */\npublic static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    EdgeFactory<V, E> ef = g.getEdgeFactory();\n    E e = ef.createEdge(sourceVertex, targetVertex);\n    // we first create the edge and set the weight to make sure that\n    // listeners will see the correct weight upon addEdge.\n    assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n    ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n    return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new edge and adds it to the specified\n * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return g.addEdge(sourceVertex, targetVertex);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified edge to the graph, including its vertices if not\n * already included.\n *\n * @param targetGraph the graph for which the specified edge to be added.\n * @param sourceGraph the graph in which the specified edge is already\n * present\n * @param edge edge to add\n *\n * @return <tt>true</tt> if the target graph did not already contain the\n * specified edge.\n */\npublic static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge) {\n    V sourceVertex = sourceGraph.getEdgeSource(edge);\n    V targetVertex = sourceGraph.getEdgeTarget(edge);\n    targetGraph.addVertex(sourceVertex);\n    targetGraph.addVertex(targetVertex);\n    return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new weighted edge and adds it to the\n * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n * method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return addEdge(g, sourceVertex, targetVertex, weight);\n}"
            ],
            [
                "addGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all the vertices and all the edges of the specified source graph to\n * the specified destination graph. First all vertices of the source graph\n * are added to the destination graph. Then every edge of the source graph\n * is added to the destination graph. This method returns <code>true</code>\n * if the destination graph has been modified as a result of this operation,\n * otherwise it returns <code>false</code>.\n *\n * <p>The behavior of this operation is undefined if any of the specified\n * graphs is modified while operation is in progress.</p>\n *\n * @param destination the graph to which vertices and edges are added.\n * @param source the graph used as source for vertices and edges to add.\n *\n * @return <code>true</code> if and only if the destination graph has been\n * changed as a result of this operation.\n */\npublic static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source) {\n    boolean modified = addAllVertices(destination, source.vertexSet());\n    modified |= addAllEdges(destination, source, source.edgeSet());\n    return modified;\n}"
            ],
            [
                "addAllEdges",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds a subset of the edges of the specified source graph to the specified\n * destination graph. The behavior of this operation is undefined if either\n * of the graphs is modified while the operation is in progress. {@link\n * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n * be added automatically to the target graph.\n *\n * @param destination the graph to which edges are to be added\n * @param source the graph used as a source for edges to add\n * @param edges the edges to be added\n *\n * @return <tt>true</tt> if this graph changed as a result of the call\n */\npublic static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges) {\n    boolean modified = false;\n    for (E e : edges) {\n        V s = source.getEdgeSource(e);\n        V t = source.getEdgeTarget(e);\n        destination.addVertex(s);\n        destination.addVertex(t);\n        modified |= destination.addEdge(s, t, e);\n    }\n    return modified;\n}"
            ],
            [
                "addAllVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all of the specified vertices to the destination graph. The behavior\n * of this operation is undefined if the specified vertex collection is\n * modified while the operation is in progress. This method will invoke the\n * {@link Graph#addVertex(Object)} method.\n *\n * @param destination the graph to which edges are to be added\n * @param vertices the vertices to be added to the graph.\n *\n * @return <tt>true</tt> if graph changed as a result of the call\n *\n * @throws NullPointerException if the specified vertices contains one or\n * more null vertices, or if the specified vertex collection is <tt>\n * null</tt>.\n *\n * @see Graph#addVertex(Object)\n */\npublic static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices) {\n    boolean modified = false;\n    for (V v : vertices) {\n        modified |= destination.addVertex(v);\n    }\n    return modified;\n}"
            ],
            [
                "neighborListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the neighbors of a specified vertex.\n * If the graph is a multigraph vertices may appear more than once in the\n * returned list.\n *\n * @param g the graph to look for neighbors in.\n * @param vertex the vertex to get the neighbors of.\n *\n * @return a list of the vertices that are the neighbors of the specified\n * vertex.\n */\npublic static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex) {\n    List<V> neighbors = new ArrayList<V>();\n    for (E e : g.edgesOf(vertex)) {\n        neighbors.add(getOppositeVertex(g, e, vertex));\n    }\n    return neighbors;\n}"
            ],
            [
                "predecessorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct predecessors of a\n * specified vertex. If the graph is a multigraph, vertices may appear more\n * than once in the returned list.\n *\n * @param g the graph to look for predecessors in.\n * @param vertex the vertex to get the predecessors of.\n *\n * @return a list of the vertices that are the direct predecessors of the\n * specified vertex.\n */\npublic static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> predecessors = new ArrayList<V>();\n    Set<? extends E> edges = g.incomingEdgesOf(vertex);\n    for (E e : edges) {\n        predecessors.add(getOppositeVertex(g, e, vertex));\n    }\n    return predecessors;\n}"
            ],
            [
                "successorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct successors of a specified\n * vertex. If the graph is a multigraph vertices may appear more than once\n * in the returned list.\n *\n * @param g the graph to look for successors in.\n * @param vertex the vertex to get the successors of.\n *\n * @return a list of the vertices that are the direct successors of the\n * specified vertex.\n */\npublic static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> successors = new ArrayList<V>();\n    Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n    for (E e : edges) {\n        successors.add(getOppositeVertex(g, e, vertex));\n    }\n    return successors;\n}"
            ],
            [
                "undirectedGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns an undirected view of the specified graph. If the specified graph\n * is directed, returns an undirected view of it. If the specified graph is\n * already undirected, just returns it.\n *\n * @param g the graph for which an undirected view is to be returned.\n *\n * @return an undirected view of the specified graph, if it is directed, or\n * or the specified graph itself if it is already undirected.\n *\n * @throws IllegalArgumentException if the graph is neither DirectedGraph\n * nor UndirectedGraph.\n *\n * @see AsUndirectedGraph\n */\npublic static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n    } else if (g instanceof UndirectedGraph<?, ?>) {\n        return (UndirectedGraph<V, E>) g;\n    } else {\n        throw new IllegalArgumentException(\"Graph must be either DirectedGraph or UndirectedGraph\");\n    }\n}"
            ],
            [
                "testIncidence",
                "org.jgrapht",
                "Graphs",
                "/**\n * Tests whether an edge is incident to a vertex.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return true iff e is incident on v\n */\npublic static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v) {\n    return (g.getEdgeSource(e).equals(v)) || (g.getEdgeTarget(e).equals(v));\n}"
            ],
            [
                "getOppositeVertex",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the vertex opposite another vertex across an edge.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return vertex opposite to v across e\n */\npublic static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v) {\n    V source = g.getEdgeSource(e);\n    V target = g.getEdgeTarget(e);\n    if (v.equals(source)) {\n        return target;\n    } else if (v.equals(target)) {\n        return source;\n    } else {\n        throw new IllegalArgumentException(\"no such vertex: \" + v.toString());\n    }\n}"
            ],
            [
                "getPathVertexList",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the list of vertices visited by a path.\n *\n * @param path path of interest\n *\n * @return corresponding vertex list\n */\npublic static <V, E> List<V> getPathVertexList(GraphPath<V, E> path) {\n    Graph<V, E> g = path.getGraph();\n    List<V> list = new ArrayList<V>();\n    V v = path.getStartVertex();\n    list.add(v);\n    for (E e : path.getEdgeList()) {\n        v = getOppositeVertex(g, e, v);\n        list.add(v);\n    }\n    return list;\n}"
            ],
            [
                "range",
                "org.jgrapht.generate",
                "SimpleWeightedGraphMatrixGenerator",
                "///////////////////////////////////////////////////////////////////////////////////////////////\npublic static int[] range(final int from, final int to) {\n    int[] range = new int[to - from];\n    for (int i = from; i < to; ++i) {\n        range[i - from] = i;\n    }\n    return range;\n}"
            ],
            [
                "createGraphSpecifics",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "// -------------------------------------------------------------------------\n/**\n * @param <V>\n * @param <E>\n * @param g\n *\n * @return TODO Document me\n */\nstatic <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new DirectedSpecifics<V, E>((DirectedGraph<V, E>) g);\n    } else {\n        return new UndirectedSpecifics<V, E>(g);\n    }\n}"
            ],
            [
                "findGreedyChromaticNumber",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds the number of colors required for a greedy coloring of the graph.\n *\n * @param g an undirected graph to find the chromatic number of\n *\n * @return integer the approximate chromatic number from the greedy\n * algorithm\n */\npublic static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g) {\n    Map<Integer, Set<V>> coloredGroups = findGreedyColoredGroups(g);\n    return coloredGroups.keySet().size();\n}"
            ],
            [
                "findGreedyColoredGroups",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds a greedy coloring of the graph.\n *\n * @param g an undirected graph for which to find the coloring\n */\npublic static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g) {\n    // A copy of the graph is made, so that elements of the graph may be\n    // removed to carry out the algorithm\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // The Vertices will be sorted in decreasing order by degree, so that\n    // higher degree vertices have priority to be colored first\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    List<V> sortedVertices = new LinkedList<V>(sg.vertexSet());\n    Collections.sort(sortedVertices, comp);\n    Collections.reverse(sortedVertices);\n    int color;\n    // create a map which will hold color as key and Set<V> as value\n    Map<Integer, Set<V>> coloredGroups = new HashMap<Integer, Set<V>>();\n    // We'll attempt to color each vertex with a single color each\n    // iteration, and these vertices will be removed from the graph at the\n    // end of each iteration\n    for (color = 0; sg.vertexSet().size() > 0; color++) {\n        // This set will contain vertices that are colored with the\n        // current color of this iteration\n        Set<V> currentColor = new HashSet<V>();\n        for (Iterator<V> iter = sortedVertices.iterator(); iter.hasNext(); ) {\n            V v = iter.next();\n            // Add new vertices to be colored as long as they are not\n            // adjacent with any other vertex that has already been colored\n            // with the current color\n            boolean flag = true;\n            for (Iterator<V> innerIter = currentColor.iterator(); innerIter.hasNext(); ) {\n                V temp = innerIter.next();\n                if (sg.containsEdge(temp, v)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                currentColor.add(v);\n                iter.remove();\n            }\n        }\n        // Add all these vertices as a group for this color\n        coloredGroups.put(color, currentColor);\n        // Remove vertices from the graph and then repeat the process for\n        // the next iteration\n        sg.removeAllVertices(currentColor);\n    }\n    return coloredGroups;\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "BellmanFordShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by hops, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    BellmanFordShortestPath<V, E> alg = new BellmanFordShortestPath<V, E>(graph, startVertex);\n    return alg.getPathEdgeList(endVertex);\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "DijkstraShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by radius, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    DijkstraShortestPath<V, E> alg = new DijkstraShortestPath<V, E>(graph, startVertex, endVertex);\n    return alg.getPathEdgeList();\n}"
            ],
            [
                "of",
                "org.jgrapht.alg.util",
                "Pair",
                "/**\n * Creates new pair of elements pulling of the necessity to provide\n * corresponding types of the elements supplied\n *\n * @param a first element\n * @param b second element\n *\n * @return new pair\n */\npublic static <A, B> Pair<A, B> of(A a, B b) {\n    return new Pair<A, B>(a, b);\n}"
            ],
            [
                "isEulerian",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will check whether the graph passed in is Eulerian or not.\n *\n * @param g The graph to be checked\n *\n * @return true for Eulerian and false for non-Eulerian\n */\npublic static <V, E> boolean isEulerian(UndirectedGraph<V, E> g) {\n    // If the graph is not connected, then no Eulerian circuit exists\n    if (!(new ConnectivityInspector<V, E>(g)).isGraphConnected()) {\n        return false;\n    }\n    // A graph is Eulerian if and only if all vertices have even degree\n    // So, this code will check for that\n    Iterator<V> iter = g.vertexSet().iterator();\n    while (iter.hasNext()) {\n        V v = iter.next();\n        if ((g.degreeOf(v) % 2) == 1) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "getEulerianCircuitVertices",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will return a list of vertices which represents the Eulerian\n * circuit of the graph.\n *\n * @param g The graph to find an Eulerian circuit\n *\n * @return null if no Eulerian circuit exists, or a list of vertices\n * representing the Eulerian circuit if one does exist\n */\npublic static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g) {\n    // If the graph is not Eulerian then just return a null since no\n    // Eulerian circuit exists\n    if (!isEulerian(g)) {\n        return null;\n    }\n    // The circuit will be represented by a linked list\n    List<V> path = new LinkedList<V>();\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    path.add(sg.vertexSet().iterator().next());\n    // Algorithm for finding an Eulerian circuit Basically this will find an\n    // arbitrary circuit, then it will find another arbitrary circuit until\n    // every edge has been traversed\n    while (sg.edgeSet().size() > 0) {\n        V v = null;\n        // Find a vertex which has an edge that hasn't been traversed yet,\n        // and keep its index position in the circuit list\n        int index = 0;\n        for (Iterator<V> iter = path.iterator(); iter.hasNext(); index++) {\n            v = iter.next();\n            if (sg.degreeOf(v) > 0) {\n                break;\n            }\n        }\n        // Finds an arbitrary circuit of the current vertex and\n        // appends this into the circuit list\n        while (sg.degreeOf(v) > 0) {\n            for (Iterator<V> iter = sg.vertexSet().iterator(); iter.hasNext(); ) {\n                V temp = iter.next();\n                if (sg.containsEdge(v, temp)) {\n                    path.add(index, temp);\n                    sg.removeEdge(v, temp);\n                    v = temp;\n                    break;\n                }\n            }\n        }\n    }\n    return path;\n}"
            ],
            [
                "getApproximateOptimalForCompleteGraph",
                "org.jgrapht.alg",
                "HamiltonianCycle",
                "/**\n * This method will return an approximate minimal traveling salesman tour\n * (hamiltonian cycle). This algorithm requires that the graph be complete\n * and the triangle inequality exists (if x,y,z are vertices then\n * d(x,y)+d(y,z) &lt; d(x,z) for all x,y,z) then this algorithm will\n * guarantee a hamiltonian cycle such that the total weight of the cycle is\n * less than or equal to double the total weight of the optimal hamiltonian\n * cycle. The optimal solution is NP-complete, so this is a decent\n * approximation that runs in polynomial time.\n *\n * @param <V>\n * @param <E>\n * @param g is the graph to find the optimal tour for.\n *\n * @return The optimal tour as a list of vertices.\n */\npublic static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g) {\n    List<V> vertices = new LinkedList<V>(g.vertexSet());\n    // If the graph is not complete then return null since this algorithm\n    // requires the graph be complete\n    if ((vertices.size() * (vertices.size() - 1) / 2) != g.edgeSet().size()) {\n        return null;\n    }\n    List<V> tour = new LinkedList<V>();\n    // Each iteration a new vertex will be added to the tour until all\n    // vertices have been added\n    while (tour.size() != g.vertexSet().size()) {\n        boolean firstEdge = true;\n        double minEdgeValue = 0;\n        int minVertexFound = 0;\n        int vertexConnectedTo = 0;\n        // A check will be made for the shortest edge to a vertex not within\n        // the tour and that new vertex will be added to the vertex\n        for (int i = 0; i < tour.size(); i++) {\n            V v = tour.get(i);\n            for (int j = 0; j < vertices.size(); j++) {\n                double weight = g.getEdgeWeight(g.getEdge(v, vertices.get(j)));\n                if (firstEdge || (weight < minEdgeValue)) {\n                    firstEdge = false;\n                    minEdgeValue = weight;\n                    minVertexFound = j;\n                    vertexConnectedTo = i;\n                }\n            }\n        }\n        tour.add(vertexConnectedTo, vertices.get(minVertexFound));\n        vertices.remove(minVertexFound);\n    }\n    return tour;\n}"
            ],
            [
                "find2ApproximationCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a 2-approximation for a minimal vertex cover of the specified\n * graph. The algorithm promises a cover that is at most double the size of\n * a minimal cover. The algorithm takes O(|E|) time.\n *\n * <p>For more details see Jenny Walter, CMPU-240: Lecture notes for\n * Language Theory and Computation, Fall 2002, Vassar College, <a\n * href=\"http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf\">\n * http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf</a>.\n * </p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G'=(V',E') <-- G(V,E)\n    Subgraph<V, E, Graph<V, E>> sg = new Subgraph<V, E, Graph<V, E>>(g, null, null);\n    // while E' is non-empty\n    while (sg.edgeSet().size() > 0) {\n        // let (u,v) be an arbitrary edge of E'\n        E e = sg.edgeSet().iterator().next();\n        // C <-- C U {u,v}\n        V u = g.getEdgeSource(e);\n        V v = g.getEdgeTarget(e);\n        cover.add(u);\n        cover.add(v);\n        // remove from E' every edge incident on either u or v\n        sg.removeVertex(u);\n        sg.removeVertex(v);\n    }\n    // return C\n    return cover;\n}"
            ],
            [
                "findGreedyCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a greedy approximation for a minimal vertex cover of a specified\n * graph. At each iteration, the algorithm picks the vertex with the highest\n * degree and adds it to the cover, until all edges are covered.\n *\n * <p>The algorithm works on undirected graphs, but can also work on\n * directed graphs when their edge-directions are ignored. To ignore edge\n * directions you can use {@link org.jgrapht.Graphs#undirectedGraph(Graph)}\n * or {@link org.jgrapht.graph.AsUndirectedGraph}.</p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G' <-- G\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // compare vertices in descending order of degree\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    // while G' != {}\n    while (sg.edgeSet().size() > 0) {\n        // v <-- vertex with maximum degree in G'\n        V v = Collections.max(sg.vertexSet(), comp);\n        // C <-- C U {v}\n        cover.add(v);\n        // remove from G' every edge incident on v, and v itself\n        sg.removeVertex(v);\n    }\n    return cover;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "BEST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int BEST_ORDER = 0;"
            ],
            [
                "NATURAL_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int NATURAL_ORDER = 1;"
            ],
            [
                "SMALLEST_DEGREE_LAST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;"
            ],
            [
                "LARGEST_SATURATION_FIRST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;"
            ],
            [
                "DEFAULT_EDGE_WEIGHT",
                "org.jgrapht",
                "WeightedGraph",
                "/**\n * The default weight for an edge.\n */\npublic static double DEFAULT_EDGE_WEIGHT = 1.0;"
            ],
            [
                "HUB_VERTEX",
                "org.jgrapht.generate",
                "WheelGraphGenerator",
                "/**\n * Role for the hub vertex.\n */\npublic static final String HUB_VERTEX = \"Hub Vertex\";"
            ],
            [
                "CORNER_VERTEX",
                "org.jgrapht.generate",
                "GridGraphGenerator",
                "/**\n * Role for the vertices at the corners.\n */\npublic static final String CORNER_VERTEX = \"Corner Vertex\";"
            ],
            [
                "START_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the first vertex generated.\n */\npublic static final String START_VERTEX = \"Start Vertex\";"
            ],
            [
                "END_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the last vertex generated.\n */\npublic static final String END_VERTEX = \"End Vertex\";"
            ],
            [
                "CENTER_VERTEX",
                "org.jgrapht.generate",
                "StarGraphGenerator",
                "public static final String CENTER_VERTEX = \"Center Vertex\";"
            ],
            [
                "SENTINEL",
                "org.jgrapht.traverse",
                "DepthFirstIterator",
                "/**\n * Sentinel object. Unfortunately, we can't use null, because ArrayDeque\n * won't accept those. And we don't want to rely on the caller to provide a\n * sentinel object for us. So we have to play typecasting games.\n */\npublic static final Object SENTINEL = new Object();"
            ],
            [
                "BEFORE_EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge added event. This event is fired before an edge is added to a\n * graph.\n */\npublic static final int BEFORE_EDGE_ADDED = 21;"
            ],
            [
                "BEFORE_EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge removed event. This event is fired before an edge is removed\n * from a graph.\n */\npublic static final int BEFORE_EDGE_REMOVED = 22;"
            ],
            [
                "EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge added event. This event is fired after an edge is added to a graph.\n */\npublic static final int EDGE_ADDED = 23;"
            ],
            [
                "EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge removed event. This event is fired after an edge is removed from a\n * graph.\n */\npublic static final int EDGE_REMOVED = 24;"
            ],
            [
                "CONNECTED_COMPONENT_STARTED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal started event.\n */\npublic static final int CONNECTED_COMPONENT_STARTED = 31;"
            ],
            [
                "CONNECTED_COMPONENT_FINISHED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal finished event.\n */\npublic static final int CONNECTED_COMPONENT_FINISHED = 32;"
            ],
            [
                "BEFORE_VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex added event. This event is fired before a vertex is added\n * to a graph.\n */\npublic static final int BEFORE_VERTEX_ADDED = 11;"
            ],
            [
                "BEFORE_VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex removed event. This event is fired before a vertex is\n * removed from a graph.\n */\npublic static final int BEFORE_VERTEX_REMOVED = 12;"
            ],
            [
                "VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex added event. This event is fired after a vertex is added to a\n * graph.\n */\npublic static final int VERTEX_ADDED = 13;"
            ],
            [
                "VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex removed event. This event is fired after a vertex is removed from\n * a graph.\n */\npublic static final int VERTEX_REMOVED = 14;"
            ],
            [
                "NULL_NODE",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "public static final int NULL_NODE = -1;"
            ],
            [
                "DEBUG",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected static final boolean DEBUG = false;"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg",
                "EdmondsKarpMaximumFlow",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 0.000000001;"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveClosure",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveClosure INSTANCE = new TransitiveClosure();"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveReduction",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveReduction INSTANCE = new TransitiveReduction();"
            ],
            [
                "NEGATIVE_UNDIRECTED_EDGE",
                "org.jgrapht.alg",
                "BellmanFordIterator",
                "/**\n * Error message.\n */\nprotected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg.flow",
                "MaximumFlowAlgorithmBase",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 1e-9;"
            ]
        ],
        "tokensMethodJavadocValues": [
            [
                "2",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "2",
                "int"
            ]
        ],
        "tokensMethodArguments": [
            [
                "graph1",
                "org.jgrapht.Graph",
                "Graph<V, E>"
            ],
            [
                "graph2",
                "org.jgrapht.Graph",
                "Graph<V, E>"
            ],
            [
                "vertexComparator",
                "java.util.Comparator",
                "Comparator<V>"
            ],
            [
                "edgeComparator",
                "java.util.Comparator",
                "Comparator<E>"
            ],
            [
                "cacheEdges",
                "",
                "boolean"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "getMappings",
                "org.jgrapht.alg.isomorphism",
                "VF2AbstractIsomorphismInspector",
                "@Override\npublic abstract Iterator<GraphMapping<V, E>> getMappings();"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "isomorphismExists",
                "org.jgrapht.alg.isomorphism",
                "VF2AbstractIsomorphismInspector",
                "@Override\npublic boolean isomorphismExists() {\n    Iterator<GraphMapping<V, E>> iter = getMappings();\n    return iter.hasNext();\n}"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "edgesOf",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> edgesOf(V arg0)"
            ],
            [
                "containsEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean containsEdge(E arg0)"
            ],
            [
                "removeAllVertices",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeAllVertices(Collection<? extends V> arg0)"
            ],
            [
                "getAllEdges",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> getAllEdges(V arg0, V arg1)"
            ],
            [
                "getEdge",
                "org.jgrapht",
                "Graph",
                "public abstract E getEdge(V arg0, V arg1)"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graph",
                "public abstract E addEdge(V arg0, V arg1)"
            ],
            [
                "vertexSet",
                "org.jgrapht",
                "Graph",
                "public abstract Set<V> vertexSet()"
            ],
            [
                "addVertex",
                "org.jgrapht",
                "Graph",
                "public abstract boolean addVertex(V arg0)"
            ],
            [
                "removeAllEdges",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> removeAllEdges(V arg0, V arg1)"
            ],
            [
                "getEdgeSource",
                "org.jgrapht",
                "Graph",
                "public abstract V getEdgeSource(E arg0)"
            ],
            [
                "removeEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeEdge(E arg0)"
            ],
            [
                "containsVertex",
                "org.jgrapht",
                "Graph",
                "public abstract boolean containsVertex(V arg0)"
            ],
            [
                "getEdgeWeight",
                "org.jgrapht",
                "Graph",
                "public abstract double getEdgeWeight(E arg0)"
            ],
            [
                "removeEdge",
                "org.jgrapht",
                "Graph",
                "public abstract E removeEdge(V arg0, V arg1)"
            ],
            [
                "removeVertex",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeVertex(V arg0)"
            ],
            [
                "getEdgeTarget",
                "org.jgrapht",
                "Graph",
                "public abstract V getEdgeTarget(E arg0)"
            ],
            [
                "getEdgeFactory",
                "org.jgrapht",
                "Graph",
                "public abstract EdgeFactory<V, E> getEdgeFactory()"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean addEdge(V arg0, V arg1, E arg2)"
            ],
            [
                "removeAllEdges",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeAllEdges(Collection<? extends E> arg0)"
            ],
            [
                "containsEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean containsEdge(V arg0, V arg1)"
            ],
            [
                "edgeSet",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> edgeSet()"
            ],
            [
                "thenComparingInt",
                "java.util",
                "Comparator",
                "public default Comparator<T> thenComparingInt(ToIntFunction<? super T> arg0)"
            ],
            [
                "thenComparing",
                "java.util",
                "Comparator",
                "public default Comparator<T> thenComparing(Comparator<? super T> arg0)"
            ],
            [
                "equals",
                "java.util",
                "Comparator",
                "public abstract boolean equals(Object arg0)"
            ],
            [
                "compare",
                "java.util",
                "Comparator",
                "public abstract int compare(T arg0, T arg1)"
            ],
            [
                "thenComparingDouble",
                "java.util",
                "Comparator",
                "public default Comparator<T> thenComparingDouble(ToDoubleFunction<? super T> arg0)"
            ],
            [
                "reversed",
                "java.util",
                "Comparator",
                "public default Comparator<T> reversed()"
            ],
            [
                "thenComparing",
                "java.util",
                "Comparator",
                "public default <U> Comparator<T> thenComparing(Function<? super T, ? extends U> arg0, Comparator<? super U> arg1)"
            ],
            [
                "thenComparingLong",
                "java.util",
                "Comparator",
                "public default Comparator<T> thenComparingLong(ToLongFunction<? super T> arg0)"
            ],
            [
                "thenComparing",
                "java.util",
                "Comparator",
                "public default <U> Comparator<T> thenComparing(Function<? super T, ? extends U> arg0)"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [
            [
                "graph1",
                "org.jgrapht.alg.isomorphism",
                "VF2AbstractIsomorphismInspector",
                "protected Graph<V, E> graph1, graph2;"
            ],
            [
                "graph2",
                "org.jgrapht.alg.isomorphism",
                "VF2AbstractIsomorphismInspector",
                "protected Graph<V, E> graph1, graph2;"
            ],
            [
                "vertexComparator",
                "org.jgrapht.alg.isomorphism",
                "VF2AbstractIsomorphismInspector",
                "protected Comparator<V> vertexComparator;"
            ],
            [
                "edgeComparator",
                "org.jgrapht.alg.isomorphism",
                "VF2AbstractIsomorphismInspector",
                "protected Comparator<E> edgeComparator;"
            ],
            [
                "ordering1",
                "org.jgrapht.alg.isomorphism",
                "VF2AbstractIsomorphismInspector",
                "protected GraphOrdering<V, E> ordering1, ordering2;"
            ],
            [
                "ordering2",
                "org.jgrapht.alg.isomorphism",
                "VF2AbstractIsomorphismInspector",
                "protected GraphOrdering<V, E> ordering1, ordering2;"
            ]
        ],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 26387,
        "oracle": "directedGraph == null;",
        "oracleType": "EXCEPT_POST",
        "projectName": "jgrapht-core-0.9.2",
        "packageName": "org.jgrapht.alg",
        "className": "KosarajuStrongConnectivityInspector",
        "javadocTag": "@throws IllegalArgumentException",
        "methodJavadoc": "    /**\n     * The constructor of the StrongConnectivityAlgorithm class.\n     *\n     * @param directedGraph the graph to inspect\n     *\n     * @throws IllegalArgumentException\n     */",
        "methodSourceCode": "public KosarajuStrongConnectivityInspector(DirectedGraph<V, E> directedGraph){\n    if (directedGraph == null) {\n        throw new IllegalArgumentException(\"null not allowed for graph!\");\n    }\n    graph = directedGraph;\n    vertexToVertexData = null;\n    orderedVertices = null;\n    stronglyConnectedSets = null;\n    stronglyConnectedSubgraphs = null;\n}",
        "classJavadoc": "/**\n * <p>Complements the {@link org.jgrapht.alg.ConnectivityInspector} class with\n * the capability to compute the strongly connected components of a directed\n * graph. The algorithm is implemented after \"Cormen et al: Introduction to\n * agorithms\", Chapter 22.5. It has a running time of O(V + E).</p>\n *\n * <p>Unlike {@link org.jgrapht.alg.ConnectivityInspector}, this class does not\n * implement incremental inspection. The full algorithm is executed at the first\n * call of {@link KosarajuStrongConnectivityInspector#stronglyConnectedSets()}\n * or {@link KosarajuStrongConnectivityInspector#isStronglyConnected()}.</p>\n *\n * @author Christian Soltenborn\n * @author Christian Hammer\n * @since Feb 2, 2005\n */",
        "classSourceCode": "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* --------------------------\n * StrongConnectivityAlgorithm.java\n * --------------------------\n * (C) Copyright 2005-2008, by Christian Soltenborn and Contributors.\n *\n * Original Author:  Christian Soltenborn\n *\n * $Id$\n *\n * Changes\n * -------\n * 2-Feb-2005 : Initial revision (CS);\n * 5-Feb-2007 : fixed NullPointerException (CS);\n * 1-Apr-2008 : Reduced memory consumption (CS);\n *\n */\npackage org.jgrapht.alg;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\nimport org.jgrapht.alg.interfaces.*;\nimport org.jgrapht.graph.*;\n\n\n/**\n * <p>Complements the {@link org.jgrapht.alg.ConnectivityInspector} class with\n * the capability to compute the strongly connected components of a directed\n * graph. The algorithm is implemented after \"Cormen et al: Introduction to\n * agorithms\", Chapter 22.5. It has a running time of O(V + E).</p>\n *\n * <p>Unlike {@link org.jgrapht.alg.ConnectivityInspector}, this class does not\n * implement incremental inspection. The full algorithm is executed at the first\n * call of {@link KosarajuStrongConnectivityInspector#stronglyConnectedSets()}\n * or {@link KosarajuStrongConnectivityInspector#isStronglyConnected()}.</p>\n *\n * @author Christian Soltenborn\n * @author Christian Hammer\n * @since Feb 2, 2005\n */\npublic class KosarajuStrongConnectivityInspector<V, E>\n    implements StrongConnectivityAlgorithm<V, E>\n{\n    // the graph to compute the strongly connected sets for\n    private final DirectedGraph<V, E> graph;\n\n    // stores the vertices, ordered by their finishing time in first dfs\n    private LinkedList<VertexData<V>> orderedVertices;\n\n    // the result of the computation, cached for future calls\n    private List<Set<V>> stronglyConnectedSets;\n\n    // the result of the computation, cached for future calls\n    private List<DirectedSubgraph<V, E>> stronglyConnectedSubgraphs;\n\n    // maps vertices to their VertexData object\n    private Map<V, VertexData<V>> vertexToVertexData;\n\n    /**\n     * The constructor of the StrongConnectivityAlgorithm class.\n     *\n     * @param directedGraph the graph to inspect\n     *\n     * @throws IllegalArgumentException\n     */\n    public KosarajuStrongConnectivityInspector(\n        DirectedGraph<V, E> directedGraph)\n    {\n        if (directedGraph == null) {\n            throw new IllegalArgumentException(\"null not allowed for graph!\");\n        }\n\n        graph = directedGraph;\n        vertexToVertexData = null;\n        orderedVertices = null;\n        stronglyConnectedSets = null;\n        stronglyConnectedSubgraphs = null;\n    }\n\n    /**\n     * Returns the graph inspected by the StrongConnectivityAlgorithm.\n     *\n     * @return the graph inspected by this StrongConnectivityAlgorithm\n     */\n    public DirectedGraph<V, E> getGraph()\n    {\n        return graph;\n    }\n\n    /**\n     * Returns true if the graph of this <code>\n     * StronglyConnectivityInspector</code> instance is strongly connected.\n     *\n     * @return true if the graph is strongly connected, false otherwise\n     */\n    public boolean isStronglyConnected()\n    {\n        return stronglyConnectedSets().size() == 1;\n    }\n\n    /**\n     * Computes a {@link List} of {@link Set}s, where each set contains vertices\n     * which together form a strongly connected component within the given\n     * graph.\n     *\n     * @return <code>List</code> of <code>Set</code> s containing the strongly\n     * connected components\n     */\n    public List<Set<V>> stronglyConnectedSets()\n    {\n        if (stronglyConnectedSets == null) {\n            orderedVertices = new LinkedList<VertexData<V>>();\n            stronglyConnectedSets = new Vector<Set<V>>();\n\n            // create VertexData objects for all vertices, store them\n            createVertexData();\n\n            // perform the first round of DFS, result is an ordering\n            // of the vertices by decreasing finishing time\n            for (VertexData<V> data : vertexToVertexData.values()) {\n                if (!data.isDiscovered()) {\n                    dfsVisit(graph, data, null);\n                }\n            }\n\n            // 'create' inverse graph (i.e. every edge is reversed)\n            DirectedGraph<V, E> inverseGraph =\n                new EdgeReversedGraph<V, E>(graph);\n\n            // get ready for next dfs round\n            resetVertexData();\n\n            // second dfs round: vertices are considered in decreasing\n            // finishing time order; every tree found is a strongly\n            // connected set\n            for (VertexData<V> data : orderedVertices) {\n                if (!data.isDiscovered()) {\n                    // new strongly connected set\n                    Set<V> set = new HashSet<V>();\n                    stronglyConnectedSets.add(set);\n                    dfsVisit(inverseGraph, data, set);\n                }\n            }\n\n            // clean up for garbage collection\n            orderedVertices = null;\n            vertexToVertexData = null;\n        }\n\n        return stronglyConnectedSets;\n    }\n\n    /**\n     * <p>Computes a list of {@link DirectedSubgraph}s of the given graph. Each\n     * subgraph will represent a strongly connected component and will contain\n     * all vertices of that component. The subgraph will have an edge (u,v) iff\n     * u and v are contained in the strongly connected component.</p>\n     *\n     * <p>NOTE: Calling this method will first execute {@link\n     * KosarajuStrongConnectivityInspector#stronglyConnectedSets()}. If you\n     * don't need subgraphs, use that method.</p>\n     *\n     * @return a list of subgraphs representing the strongly connected\n     * components\n     */\n    public List<DirectedSubgraph<V, E>> stronglyConnectedSubgraphs()\n    {\n        if (stronglyConnectedSubgraphs == null) {\n            List<Set<V>> sets = stronglyConnectedSets();\n            stronglyConnectedSubgraphs =\n                new Vector<DirectedSubgraph<V, E>>(sets.size());\n\n            for (Set<V> set : sets) {\n                stronglyConnectedSubgraphs.add(\n                    new DirectedSubgraph<V, E>(\n                        graph,\n                        set,\n                        null));\n            }\n        }\n\n        return stronglyConnectedSubgraphs;\n    }\n\n    /*\n     * Creates a VertexData object for every vertex in the graph and stores\n     * them\n     * in a HashMap.\n     */\n    private void createVertexData()\n    {\n        vertexToVertexData =\n            new HashMap<V, VertexData<V>>(graph.vertexSet().size());\n\n        for (V vertex : graph.vertexSet()) {\n            vertexToVertexData.put(\n                vertex,\n                new VertexData2<V>(vertex, false, false));\n        }\n    }\n\n    /*\n     * The subroutine of DFS. NOTE: the set is used to distinguish between 1st\n     * and 2nd round of DFS. set == null: finished vertices are stored (1st\n     * round). set != null: all vertices found will be saved in the set (2nd\n     * round)\n     */\n    private void dfsVisit(\n        DirectedGraph<V, E> visitedGraph,\n        VertexData<V> vertexData,\n        Set<V> vertices)\n    {\n        Deque<VertexData<V>> stack = new ArrayDeque<VertexData<V>>();\n        stack.add(vertexData);\n\n        while (!stack.isEmpty()) {\n            VertexData<V> data = stack.removeLast();\n\n            if (!data.isDiscovered()) {\n                data.setDiscovered(true);\n\n                if (vertices != null) {\n                    vertices.add(data.getVertex());\n                }\n\n                stack.add(new VertexData1<V>(data, true, true));\n\n                // follow all edges\n                for (E edge : visitedGraph.outgoingEdgesOf(data.getVertex())) {\n                    VertexData<V> targetData =\n                        vertexToVertexData.get(\n                            visitedGraph.getEdgeTarget(edge));\n\n                    if (!targetData.isDiscovered()) {\n                        // the \"recursion\"\n                        stack.add(targetData);\n                    }\n                }\n            } else if (data.isFinished()) {\n                if (vertices == null) {\n                    orderedVertices.addFirst(data.getFinishedData());\n                }\n            }\n        }\n    }\n\n    /*\n     * Resets all VertexData objects.\n     */\n    private void resetVertexData()\n    {\n        for (VertexData<V> data : vertexToVertexData.values()) {\n            data.setDiscovered(false);\n            data.setFinished(false);\n        }\n    }\n\n    /*\n     * Lightweight class storing some data for every vertex.\n     */\n    private static abstract class VertexData<V>\n    {\n        private byte bitfield;\n\n        private VertexData(\n            boolean discovered,\n            boolean finished)\n        {\n            this.bitfield = 0;\n            setDiscovered(discovered);\n            setFinished(finished);\n        }\n\n        private boolean isDiscovered()\n        {\n            return (bitfield & 1) == 1;\n        }\n\n        private boolean isFinished()\n        {\n            return (bitfield & 2) == 2;\n        }\n\n        private void setDiscovered(boolean discovered)\n        {\n            if (discovered) {\n                bitfield |= 1;\n            } else {\n                bitfield &= ~1;\n            }\n        }\n\n        private void setFinished(boolean finished)\n        {\n            if (finished) {\n                bitfield |= 2;\n            } else {\n                bitfield &= ~2;\n            }\n        }\n\n        abstract VertexData<V> getFinishedData();\n\n        abstract V getVertex();\n    }\n\n    private static final class VertexData1<V>\n        extends VertexData<V>\n    {\n        private final VertexData<V> finishedData;\n\n        private VertexData1(\n            VertexData<V> finishedData,\n            boolean discovered,\n            boolean finished)\n        {\n            super(discovered, finished);\n            this.finishedData = finishedData;\n        }\n\n        @Override VertexData<V> getFinishedData()\n        {\n            return finishedData;\n        }\n\n        @Override V getVertex()\n        {\n            return null;\n        }\n    }\n\n    private static final class VertexData2<V>\n        extends VertexData<V>\n    {\n        private final V vertex;\n\n        private VertexData2(\n            V vertex,\n            boolean discovered,\n            boolean finished)\n        {\n            super(discovered, finished);\n            this.vertex = vertex;\n        }\n\n        @Override VertexData<V> getFinishedData()\n        {\n            return null;\n        }\n\n        @Override V getVertex()\n        {\n            return vertex;\n        }\n    }\n}\n\n// End StrongConnectivityAlgorithm.java\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "PartiteRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "RandomGraphHelper",
                "org.jgrapht.experimental"
            ],
            [
                "GraphReader",
                "org.jgrapht.experimental"
            ],
            [
                "DirectedAcyclicGraph",
                "org.jgrapht.experimental.dag"
            ],
            [
                "GraphSquare",
                "org.jgrapht.experimental"
            ],
            [
                "UniformRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "GraphTests",
                "org.jgrapht.experimental"
            ],
            [
                "ApproximationAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "BrownBacktrackColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "GreedyColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "IntArrayGraphAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ExactAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ListenableGraph",
                "org.jgrapht"
            ],
            [
                "ModifiableInteger",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeapNode",
                "org.jgrapht.util"
            ],
            [
                "WeightCombiner",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeap",
                "org.jgrapht.util"
            ],
            [
                "TypeUtil",
                "org.jgrapht.util"
            ],
            [
                "ArrayUnenforcedSet",
                "org.jgrapht.util"
            ],
            [
                "VertexPair",
                "org.jgrapht.util"
            ],
            [
                "MathUtil",
                "org.jgrapht.util"
            ],
            [
                "PrefetchIterator",
                "org.jgrapht.util"
            ],
            [
                "VertexFactory",
                "org.jgrapht"
            ],
            [
                "Graph",
                "org.jgrapht"
            ],
            [
                "GraphPath",
                "org.jgrapht"
            ],
            [
                "UndirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraph",
                "org.jgrapht.graph"
            ],
            [
                "MixedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DefaultGraphMapping",
                "org.jgrapht.graph"
            ],
            [
                "WeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskEdgeSet",
                "org.jgrapht.graph"
            ],
            [
                "Pseudograph",
                "org.jgrapht.graph"
            ],
            [
                "MaskFunctor",
                "org.jgrapht.graph"
            ],
            [
                "GraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractBaseGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "Multigraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultWeightedEdge",
                "org.jgrapht.graph"
            ],
            [
                "ListenableDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeSetFactory",
                "org.jgrapht.graph"
            ],
            [
                "GraphDelegator",
                "org.jgrapht.graph"
            ],
            [
                "DefaultListenableGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedVertexFactory",
                "org.jgrapht.graph"
            ],
            [
                "DefaultEdge",
                "org.jgrapht.graph"
            ],
            [
                "MaskVertexSet",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "IntrusiveEdge",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphPathImpl",
                "org.jgrapht.graph"
            ],
            [
                "Subgraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractGraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedEdgeFactory",
                "org.jgrapht.graph"
            ],
            [
                "SimpleWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "WeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeReversedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "AbstractGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "ListenableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraphPath",
                "org.jgrapht.graph"
            ],
            [
                "ParanoidGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphHelper",
                "org.jgrapht"
            ],
            [
                "Graphs",
                "org.jgrapht"
            ],
            [
                "DirectedGraph",
                "org.jgrapht"
            ],
            [
                "WeightedGraph",
                "org.jgrapht"
            ],
            [
                "HyperCubeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RingGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WheelGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GridGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "ScaleFreeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedBipartiteGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "LinearGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RandomGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGeneratorAdapter",
                "org.jgrapht.generate"
            ],
            [
                "EmptyGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteBipartiteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "StarGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "UndirectedGraph",
                "org.jgrapht"
            ],
            [
                "TopologicalOrderIterator",
                "org.jgrapht.traverse"
            ],
            [
                "CrossComponentIterator",
                "org.jgrapht.traverse"
            ],
            [
                "AbstractGraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "ClosestFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "BreadthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "DepthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "GraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "EdgeFactory",
                "org.jgrapht"
            ],
            [
                "GraphMapping",
                "org.jgrapht"
            ],
            [
                "VertexSetListener",
                "org.jgrapht.event"
            ],
            [
                "EdgeTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "TraversalListener",
                "org.jgrapht.event"
            ],
            [
                "GraphEdgeChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "VertexTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphListener",
                "org.jgrapht.event"
            ],
            [
                "TraversalListenerAdapter",
                "org.jgrapht.event"
            ],
            [
                "ConnectedComponentTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphVertexChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "TarjanLowestCommonAncestor",
                "org.jgrapht.alg"
            ],
            [
                "PrimMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "BlockCutpointGraph",
                "org.jgrapht.alg"
            ],
            [
                "AllDirectedPaths",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPathsIterator",
                "org.jgrapht.alg"
            ],
            [
                "KruskalMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "StrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "VF2State",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2AbstractIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "GraphOrdering",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphicGraphMapping",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2MappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "BronKerboschCliqueFinder",
                "org.jgrapht.alg"
            ],
            [
                "ChromaticNumber",
                "org.jgrapht.alg"
            ],
            [
                "KosarajuStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "DijkstraShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElement",
                "org.jgrapht.alg"
            ],
            [
                "AStarShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordPathElement",
                "org.jgrapht.alg"
            ],
            [
                "FloydWarshallShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "UnionFind",
                "org.jgrapht.alg.util"
            ],
            [
                "AlwaysEqualComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Extension",
                "org.jgrapht.alg.util"
            ],
            [
                "VertexDegreeComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Pair",
                "org.jgrapht.alg.util"
            ],
            [
                "GabowStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "HawickJamesSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "DirectedSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "JohnsonSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TiernanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "UndirectedCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "PatonCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TarjanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "SzwarcfiterLauerSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "BiconnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "ConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "MinSourceSinkCut",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsBlossomShrinking",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveClosure",
                "org.jgrapht.alg"
            ],
            [
                "HopcroftKarpBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "StoerWagnerMinimumCut",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "KuhnMunkresMinimalWeightBipartitePerfectMatching",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveReduction",
                "org.jgrapht.alg"
            ],
            [
                "EulerianCircuit",
                "org.jgrapht.alg"
            ],
            [
                "DirectedNeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "NaiveLcaFinder",
                "org.jgrapht.alg"
            ],
            [
                "MaximumWeightBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "HamiltonianCycle",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "NeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "VertexCovers",
                "org.jgrapht.alg"
            ],
            [
                "CycleDetector",
                "org.jgrapht.alg"
            ],
            [
                "AStarAdmissibleHeuristic",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MinimumSpanningTree",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "WeightedMatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "StrongConnectivityAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MaximumFlowAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "CliqueMinimalSeparatorDecomposition",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordIterator",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElement",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "PushRelabelMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "MaximumFlowAlgorithmBase",
                "org.jgrapht.alg.flow"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "addVertices",
                "org.jgrapht.experimental",
                "RandomGraphHelper",
                "/**\n * .\n *\n * @param target\n * @param vertexFactory\n * @param numVertices\n *\n * @return vertices\n */\n@SuppressWarnings(\"unchecked\")\npublic static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices) {\n    Object[] vertices = new Object[numVertices];\n    for (int i = 0; i < numVertices; ++i) {\n        vertices[i] = vertexFactory.createVertex();\n        target.addVertex(vertices[i]);\n    }\n    return vertices;\n}"
            ],
            [
                "isEmpty",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isEmpty(Graph<V, E> g) {\n    return g.edgeSet().isEmpty();\n}"
            ],
            [
                "isComplete",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isComplete(Graph<V, E> g) {\n    int n = g.vertexSet().size();\n    return g.edgeSet().size() == (n * (n - 1) / 2);\n}"
            ],
            [
                "isConnected",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isConnected(Graph<V, E> g) {\n    int numVertices = g.vertexSet().size();\n    int numEdges = g.edgeSet().size();\n    if (numEdges < (numVertices - 1)) {\n        return false;\n    }\n    if ((numVertices < 2) || (numEdges > ((numVertices - 1) * (numVertices - 2) / 2))) {\n        return true;\n    }\n    Set<V> known = new HashSet<V>();\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = g.vertexSet().iterator().next();\n    // start with node 1\n    queue.add(v);\n    known.add(v);\n    while (!queue.isEmpty()) {\n        v = queue.removeFirst();\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            v = it.next();\n            if (!known.contains(v)) {\n                known.add(v);\n                queue.add(v);\n            }\n        }\n    }\n    return known.size() == numVertices;\n}"
            ],
            [
                "isTree",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isTree(Graph<V, E> g) {\n    return isConnected(g) && (g.edgeSet().size() == (g.vertexSet().size() - 1));\n}"
            ],
            [
                "isBipartite",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isBipartite(Graph<V, E> g) {\n    if ((4 * g.edgeSet().size()) > (g.vertexSet().size() * g.vertexSet().size())) {\n        return false;\n    }\n    if (isEmpty(g)) {\n        return true;\n    }\n    Set<V> unknown = new HashSet<V>(g.vertexSet());\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = unknown.iterator().next();\n    Set<V> odd = new HashSet<V>();\n    queue.add(v);\n    while (!unknown.isEmpty()) {\n        if (queue.isEmpty()) {\n            queue.add(unknown.iterator().next());\n        }\n        v = queue.removeFirst();\n        unknown.remove(v);\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            V n = it.next();\n            if (unknown.contains(n)) {\n                queue.add(n);\n                if (!odd.contains(v)) {\n                    odd.add(n);\n                }\n            } else if (!(odd.contains(v) ^ odd.contains(n))) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
            ],
            [
                "union",
                "org.jgrapht.util",
                "FibonacciHeap",
                "// size\n/**\n * Joins two Fibonacci heaps into a new one. No heap consolidation is\n * performed at this time. The two root lists are simply joined together.\n *\n * <p>Running time: O(1) actual</p>\n *\n * @param h1 first heap\n * @param h2 second heap\n *\n * @return new heap containing h1 and h2\n */\npublic static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2) {\n    FibonacciHeap<T> h = new FibonacciHeap<T>();\n    if ((h1 != null) && (h2 != null)) {\n        h.minNode = h1.minNode;\n        if (h.minNode != null) {\n            if (h2.minNode != null) {\n                h.minNode.right.left = h2.minNode.left;\n                h2.minNode.left.right = h.minNode.right;\n                h.minNode.right = h2.minNode;\n                h2.minNode.left = h.minNode;\n                if (h2.minNode.key < h1.minNode.key) {\n                    h.minNode = h2.minNode;\n                }\n            }\n        } else {\n            h.minNode = h2.minNode;\n        }\n        h.nNodes = h1.nNodes + h2.nNodes;\n    }\n    return h;\n}"
            ],
            [
                "uncheckedCast",
                "org.jgrapht.util",
                "TypeUtil",
                "/**\n * Casts an object to a type.\n *\n * @param o object to be cast\n * @param typeDecl conveys the target type information; the actual value is\n * unused and can be null since this is all just stupid compiler tricks\n *\n * @return the result of the cast\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl) {\n    return (T) o;\n}"
            ],
            [
                "factorial",
                "org.jgrapht.util",
                "MathUtil",
                "public static long factorial(int N) {\n    long multi = 1;\n    for (int i = 1; i <= N; i++) {\n        multi = multi * i;\n    }\n    return multi;\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graphs",
                "/**\n * Creates a new edge and adds it to the specified graph similarly to the\n * {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n *\n * @see Graph#addEdge(Object, Object)\n */\npublic static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    EdgeFactory<V, E> ef = g.getEdgeFactory();\n    E e = ef.createEdge(sourceVertex, targetVertex);\n    // we first create the edge and set the weight to make sure that\n    // listeners will see the correct weight upon addEdge.\n    assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n    ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n    return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new edge and adds it to the specified\n * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return g.addEdge(sourceVertex, targetVertex);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified edge to the graph, including its vertices if not\n * already included.\n *\n * @param targetGraph the graph for which the specified edge to be added.\n * @param sourceGraph the graph in which the specified edge is already\n * present\n * @param edge edge to add\n *\n * @return <tt>true</tt> if the target graph did not already contain the\n * specified edge.\n */\npublic static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge) {\n    V sourceVertex = sourceGraph.getEdgeSource(edge);\n    V targetVertex = sourceGraph.getEdgeTarget(edge);\n    targetGraph.addVertex(sourceVertex);\n    targetGraph.addVertex(targetVertex);\n    return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new weighted edge and adds it to the\n * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n * method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return addEdge(g, sourceVertex, targetVertex, weight);\n}"
            ],
            [
                "addGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all the vertices and all the edges of the specified source graph to\n * the specified destination graph. First all vertices of the source graph\n * are added to the destination graph. Then every edge of the source graph\n * is added to the destination graph. This method returns <code>true</code>\n * if the destination graph has been modified as a result of this operation,\n * otherwise it returns <code>false</code>.\n *\n * <p>The behavior of this operation is undefined if any of the specified\n * graphs is modified while operation is in progress.</p>\n *\n * @param destination the graph to which vertices and edges are added.\n * @param source the graph used as source for vertices and edges to add.\n *\n * @return <code>true</code> if and only if the destination graph has been\n * changed as a result of this operation.\n */\npublic static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source) {\n    boolean modified = addAllVertices(destination, source.vertexSet());\n    modified |= addAllEdges(destination, source, source.edgeSet());\n    return modified;\n}"
            ],
            [
                "addAllEdges",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds a subset of the edges of the specified source graph to the specified\n * destination graph. The behavior of this operation is undefined if either\n * of the graphs is modified while the operation is in progress. {@link\n * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n * be added automatically to the target graph.\n *\n * @param destination the graph to which edges are to be added\n * @param source the graph used as a source for edges to add\n * @param edges the edges to be added\n *\n * @return <tt>true</tt> if this graph changed as a result of the call\n */\npublic static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges) {\n    boolean modified = false;\n    for (E e : edges) {\n        V s = source.getEdgeSource(e);\n        V t = source.getEdgeTarget(e);\n        destination.addVertex(s);\n        destination.addVertex(t);\n        modified |= destination.addEdge(s, t, e);\n    }\n    return modified;\n}"
            ],
            [
                "addAllVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all of the specified vertices to the destination graph. The behavior\n * of this operation is undefined if the specified vertex collection is\n * modified while the operation is in progress. This method will invoke the\n * {@link Graph#addVertex(Object)} method.\n *\n * @param destination the graph to which edges are to be added\n * @param vertices the vertices to be added to the graph.\n *\n * @return <tt>true</tt> if graph changed as a result of the call\n *\n * @throws NullPointerException if the specified vertices contains one or\n * more null vertices, or if the specified vertex collection is <tt>\n * null</tt>.\n *\n * @see Graph#addVertex(Object)\n */\npublic static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices) {\n    boolean modified = false;\n    for (V v : vertices) {\n        modified |= destination.addVertex(v);\n    }\n    return modified;\n}"
            ],
            [
                "neighborListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the neighbors of a specified vertex.\n * If the graph is a multigraph vertices may appear more than once in the\n * returned list.\n *\n * @param g the graph to look for neighbors in.\n * @param vertex the vertex to get the neighbors of.\n *\n * @return a list of the vertices that are the neighbors of the specified\n * vertex.\n */\npublic static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex) {\n    List<V> neighbors = new ArrayList<V>();\n    for (E e : g.edgesOf(vertex)) {\n        neighbors.add(getOppositeVertex(g, e, vertex));\n    }\n    return neighbors;\n}"
            ],
            [
                "predecessorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct predecessors of a\n * specified vertex. If the graph is a multigraph, vertices may appear more\n * than once in the returned list.\n *\n * @param g the graph to look for predecessors in.\n * @param vertex the vertex to get the predecessors of.\n *\n * @return a list of the vertices that are the direct predecessors of the\n * specified vertex.\n */\npublic static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> predecessors = new ArrayList<V>();\n    Set<? extends E> edges = g.incomingEdgesOf(vertex);\n    for (E e : edges) {\n        predecessors.add(getOppositeVertex(g, e, vertex));\n    }\n    return predecessors;\n}"
            ],
            [
                "successorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct successors of a specified\n * vertex. If the graph is a multigraph vertices may appear more than once\n * in the returned list.\n *\n * @param g the graph to look for successors in.\n * @param vertex the vertex to get the successors of.\n *\n * @return a list of the vertices that are the direct successors of the\n * specified vertex.\n */\npublic static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> successors = new ArrayList<V>();\n    Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n    for (E e : edges) {\n        successors.add(getOppositeVertex(g, e, vertex));\n    }\n    return successors;\n}"
            ],
            [
                "undirectedGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns an undirected view of the specified graph. If the specified graph\n * is directed, returns an undirected view of it. If the specified graph is\n * already undirected, just returns it.\n *\n * @param g the graph for which an undirected view is to be returned.\n *\n * @return an undirected view of the specified graph, if it is directed, or\n * or the specified graph itself if it is already undirected.\n *\n * @throws IllegalArgumentException if the graph is neither DirectedGraph\n * nor UndirectedGraph.\n *\n * @see AsUndirectedGraph\n */\npublic static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n    } else if (g instanceof UndirectedGraph<?, ?>) {\n        return (UndirectedGraph<V, E>) g;\n    } else {\n        throw new IllegalArgumentException(\"Graph must be either DirectedGraph or UndirectedGraph\");\n    }\n}"
            ],
            [
                "testIncidence",
                "org.jgrapht",
                "Graphs",
                "/**\n * Tests whether an edge is incident to a vertex.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return true iff e is incident on v\n */\npublic static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v) {\n    return (g.getEdgeSource(e).equals(v)) || (g.getEdgeTarget(e).equals(v));\n}"
            ],
            [
                "getOppositeVertex",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the vertex opposite another vertex across an edge.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return vertex opposite to v across e\n */\npublic static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v) {\n    V source = g.getEdgeSource(e);\n    V target = g.getEdgeTarget(e);\n    if (v.equals(source)) {\n        return target;\n    } else if (v.equals(target)) {\n        return source;\n    } else {\n        throw new IllegalArgumentException(\"no such vertex: \" + v.toString());\n    }\n}"
            ],
            [
                "getPathVertexList",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the list of vertices visited by a path.\n *\n * @param path path of interest\n *\n * @return corresponding vertex list\n */\npublic static <V, E> List<V> getPathVertexList(GraphPath<V, E> path) {\n    Graph<V, E> g = path.getGraph();\n    List<V> list = new ArrayList<V>();\n    V v = path.getStartVertex();\n    list.add(v);\n    for (E e : path.getEdgeList()) {\n        v = getOppositeVertex(g, e, v);\n        list.add(v);\n    }\n    return list;\n}"
            ],
            [
                "range",
                "org.jgrapht.generate",
                "SimpleWeightedGraphMatrixGenerator",
                "///////////////////////////////////////////////////////////////////////////////////////////////\npublic static int[] range(final int from, final int to) {\n    int[] range = new int[to - from];\n    for (int i = from; i < to; ++i) {\n        range[i - from] = i;\n    }\n    return range;\n}"
            ],
            [
                "createGraphSpecifics",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "// -------------------------------------------------------------------------\n/**\n * @param <V>\n * @param <E>\n * @param g\n *\n * @return TODO Document me\n */\nstatic <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new DirectedSpecifics<V, E>((DirectedGraph<V, E>) g);\n    } else {\n        return new UndirectedSpecifics<V, E>(g);\n    }\n}"
            ],
            [
                "findGreedyChromaticNumber",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds the number of colors required for a greedy coloring of the graph.\n *\n * @param g an undirected graph to find the chromatic number of\n *\n * @return integer the approximate chromatic number from the greedy\n * algorithm\n */\npublic static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g) {\n    Map<Integer, Set<V>> coloredGroups = findGreedyColoredGroups(g);\n    return coloredGroups.keySet().size();\n}"
            ],
            [
                "findGreedyColoredGroups",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds a greedy coloring of the graph.\n *\n * @param g an undirected graph for which to find the coloring\n */\npublic static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g) {\n    // A copy of the graph is made, so that elements of the graph may be\n    // removed to carry out the algorithm\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // The Vertices will be sorted in decreasing order by degree, so that\n    // higher degree vertices have priority to be colored first\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    List<V> sortedVertices = new LinkedList<V>(sg.vertexSet());\n    Collections.sort(sortedVertices, comp);\n    Collections.reverse(sortedVertices);\n    int color;\n    // create a map which will hold color as key and Set<V> as value\n    Map<Integer, Set<V>> coloredGroups = new HashMap<Integer, Set<V>>();\n    // We'll attempt to color each vertex with a single color each\n    // iteration, and these vertices will be removed from the graph at the\n    // end of each iteration\n    for (color = 0; sg.vertexSet().size() > 0; color++) {\n        // This set will contain vertices that are colored with the\n        // current color of this iteration\n        Set<V> currentColor = new HashSet<V>();\n        for (Iterator<V> iter = sortedVertices.iterator(); iter.hasNext(); ) {\n            V v = iter.next();\n            // Add new vertices to be colored as long as they are not\n            // adjacent with any other vertex that has already been colored\n            // with the current color\n            boolean flag = true;\n            for (Iterator<V> innerIter = currentColor.iterator(); innerIter.hasNext(); ) {\n                V temp = innerIter.next();\n                if (sg.containsEdge(temp, v)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                currentColor.add(v);\n                iter.remove();\n            }\n        }\n        // Add all these vertices as a group for this color\n        coloredGroups.put(color, currentColor);\n        // Remove vertices from the graph and then repeat the process for\n        // the next iteration\n        sg.removeAllVertices(currentColor);\n    }\n    return coloredGroups;\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "BellmanFordShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by hops, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    BellmanFordShortestPath<V, E> alg = new BellmanFordShortestPath<V, E>(graph, startVertex);\n    return alg.getPathEdgeList(endVertex);\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "DijkstraShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by radius, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    DijkstraShortestPath<V, E> alg = new DijkstraShortestPath<V, E>(graph, startVertex, endVertex);\n    return alg.getPathEdgeList();\n}"
            ],
            [
                "of",
                "org.jgrapht.alg.util",
                "Pair",
                "/**\n * Creates new pair of elements pulling of the necessity to provide\n * corresponding types of the elements supplied\n *\n * @param a first element\n * @param b second element\n *\n * @return new pair\n */\npublic static <A, B> Pair<A, B> of(A a, B b) {\n    return new Pair<A, B>(a, b);\n}"
            ],
            [
                "isEulerian",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will check whether the graph passed in is Eulerian or not.\n *\n * @param g The graph to be checked\n *\n * @return true for Eulerian and false for non-Eulerian\n */\npublic static <V, E> boolean isEulerian(UndirectedGraph<V, E> g) {\n    // If the graph is not connected, then no Eulerian circuit exists\n    if (!(new ConnectivityInspector<V, E>(g)).isGraphConnected()) {\n        return false;\n    }\n    // A graph is Eulerian if and only if all vertices have even degree\n    // So, this code will check for that\n    Iterator<V> iter = g.vertexSet().iterator();\n    while (iter.hasNext()) {\n        V v = iter.next();\n        if ((g.degreeOf(v) % 2) == 1) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "getEulerianCircuitVertices",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will return a list of vertices which represents the Eulerian\n * circuit of the graph.\n *\n * @param g The graph to find an Eulerian circuit\n *\n * @return null if no Eulerian circuit exists, or a list of vertices\n * representing the Eulerian circuit if one does exist\n */\npublic static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g) {\n    // If the graph is not Eulerian then just return a null since no\n    // Eulerian circuit exists\n    if (!isEulerian(g)) {\n        return null;\n    }\n    // The circuit will be represented by a linked list\n    List<V> path = new LinkedList<V>();\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    path.add(sg.vertexSet().iterator().next());\n    // Algorithm for finding an Eulerian circuit Basically this will find an\n    // arbitrary circuit, then it will find another arbitrary circuit until\n    // every edge has been traversed\n    while (sg.edgeSet().size() > 0) {\n        V v = null;\n        // Find a vertex which has an edge that hasn't been traversed yet,\n        // and keep its index position in the circuit list\n        int index = 0;\n        for (Iterator<V> iter = path.iterator(); iter.hasNext(); index++) {\n            v = iter.next();\n            if (sg.degreeOf(v) > 0) {\n                break;\n            }\n        }\n        // Finds an arbitrary circuit of the current vertex and\n        // appends this into the circuit list\n        while (sg.degreeOf(v) > 0) {\n            for (Iterator<V> iter = sg.vertexSet().iterator(); iter.hasNext(); ) {\n                V temp = iter.next();\n                if (sg.containsEdge(v, temp)) {\n                    path.add(index, temp);\n                    sg.removeEdge(v, temp);\n                    v = temp;\n                    break;\n                }\n            }\n        }\n    }\n    return path;\n}"
            ],
            [
                "getApproximateOptimalForCompleteGraph",
                "org.jgrapht.alg",
                "HamiltonianCycle",
                "/**\n * This method will return an approximate minimal traveling salesman tour\n * (hamiltonian cycle). This algorithm requires that the graph be complete\n * and the triangle inequality exists (if x,y,z are vertices then\n * d(x,y)+d(y,z) &lt; d(x,z) for all x,y,z) then this algorithm will\n * guarantee a hamiltonian cycle such that the total weight of the cycle is\n * less than or equal to double the total weight of the optimal hamiltonian\n * cycle. The optimal solution is NP-complete, so this is a decent\n * approximation that runs in polynomial time.\n *\n * @param <V>\n * @param <E>\n * @param g is the graph to find the optimal tour for.\n *\n * @return The optimal tour as a list of vertices.\n */\npublic static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g) {\n    List<V> vertices = new LinkedList<V>(g.vertexSet());\n    // If the graph is not complete then return null since this algorithm\n    // requires the graph be complete\n    if ((vertices.size() * (vertices.size() - 1) / 2) != g.edgeSet().size()) {\n        return null;\n    }\n    List<V> tour = new LinkedList<V>();\n    // Each iteration a new vertex will be added to the tour until all\n    // vertices have been added\n    while (tour.size() != g.vertexSet().size()) {\n        boolean firstEdge = true;\n        double minEdgeValue = 0;\n        int minVertexFound = 0;\n        int vertexConnectedTo = 0;\n        // A check will be made for the shortest edge to a vertex not within\n        // the tour and that new vertex will be added to the vertex\n        for (int i = 0; i < tour.size(); i++) {\n            V v = tour.get(i);\n            for (int j = 0; j < vertices.size(); j++) {\n                double weight = g.getEdgeWeight(g.getEdge(v, vertices.get(j)));\n                if (firstEdge || (weight < minEdgeValue)) {\n                    firstEdge = false;\n                    minEdgeValue = weight;\n                    minVertexFound = j;\n                    vertexConnectedTo = i;\n                }\n            }\n        }\n        tour.add(vertexConnectedTo, vertices.get(minVertexFound));\n        vertices.remove(minVertexFound);\n    }\n    return tour;\n}"
            ],
            [
                "find2ApproximationCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a 2-approximation for a minimal vertex cover of the specified\n * graph. The algorithm promises a cover that is at most double the size of\n * a minimal cover. The algorithm takes O(|E|) time.\n *\n * <p>For more details see Jenny Walter, CMPU-240: Lecture notes for\n * Language Theory and Computation, Fall 2002, Vassar College, <a\n * href=\"http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf\">\n * http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf</a>.\n * </p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G'=(V',E') <-- G(V,E)\n    Subgraph<V, E, Graph<V, E>> sg = new Subgraph<V, E, Graph<V, E>>(g, null, null);\n    // while E' is non-empty\n    while (sg.edgeSet().size() > 0) {\n        // let (u,v) be an arbitrary edge of E'\n        E e = sg.edgeSet().iterator().next();\n        // C <-- C U {u,v}\n        V u = g.getEdgeSource(e);\n        V v = g.getEdgeTarget(e);\n        cover.add(u);\n        cover.add(v);\n        // remove from E' every edge incident on either u or v\n        sg.removeVertex(u);\n        sg.removeVertex(v);\n    }\n    // return C\n    return cover;\n}"
            ],
            [
                "findGreedyCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a greedy approximation for a minimal vertex cover of a specified\n * graph. At each iteration, the algorithm picks the vertex with the highest\n * degree and adds it to the cover, until all edges are covered.\n *\n * <p>The algorithm works on undirected graphs, but can also work on\n * directed graphs when their edge-directions are ignored. To ignore edge\n * directions you can use {@link org.jgrapht.Graphs#undirectedGraph(Graph)}\n * or {@link org.jgrapht.graph.AsUndirectedGraph}.</p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G' <-- G\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // compare vertices in descending order of degree\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    // while G' != {}\n    while (sg.edgeSet().size() > 0) {\n        // v <-- vertex with maximum degree in G'\n        V v = Collections.max(sg.vertexSet(), comp);\n        // C <-- C U {v}\n        cover.add(v);\n        // remove from G' every edge incident on v, and v itself\n        sg.removeVertex(v);\n    }\n    return cover;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "BEST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int BEST_ORDER = 0;"
            ],
            [
                "NATURAL_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int NATURAL_ORDER = 1;"
            ],
            [
                "SMALLEST_DEGREE_LAST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;"
            ],
            [
                "LARGEST_SATURATION_FIRST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;"
            ],
            [
                "DEFAULT_EDGE_WEIGHT",
                "org.jgrapht",
                "WeightedGraph",
                "/**\n * The default weight for an edge.\n */\npublic static double DEFAULT_EDGE_WEIGHT = 1.0;"
            ],
            [
                "HUB_VERTEX",
                "org.jgrapht.generate",
                "WheelGraphGenerator",
                "/**\n * Role for the hub vertex.\n */\npublic static final String HUB_VERTEX = \"Hub Vertex\";"
            ],
            [
                "CORNER_VERTEX",
                "org.jgrapht.generate",
                "GridGraphGenerator",
                "/**\n * Role for the vertices at the corners.\n */\npublic static final String CORNER_VERTEX = \"Corner Vertex\";"
            ],
            [
                "START_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the first vertex generated.\n */\npublic static final String START_VERTEX = \"Start Vertex\";"
            ],
            [
                "END_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the last vertex generated.\n */\npublic static final String END_VERTEX = \"End Vertex\";"
            ],
            [
                "CENTER_VERTEX",
                "org.jgrapht.generate",
                "StarGraphGenerator",
                "public static final String CENTER_VERTEX = \"Center Vertex\";"
            ],
            [
                "SENTINEL",
                "org.jgrapht.traverse",
                "DepthFirstIterator",
                "/**\n * Sentinel object. Unfortunately, we can't use null, because ArrayDeque\n * won't accept those. And we don't want to rely on the caller to provide a\n * sentinel object for us. So we have to play typecasting games.\n */\npublic static final Object SENTINEL = new Object();"
            ],
            [
                "BEFORE_EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge added event. This event is fired before an edge is added to a\n * graph.\n */\npublic static final int BEFORE_EDGE_ADDED = 21;"
            ],
            [
                "BEFORE_EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge removed event. This event is fired before an edge is removed\n * from a graph.\n */\npublic static final int BEFORE_EDGE_REMOVED = 22;"
            ],
            [
                "EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge added event. This event is fired after an edge is added to a graph.\n */\npublic static final int EDGE_ADDED = 23;"
            ],
            [
                "EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge removed event. This event is fired after an edge is removed from a\n * graph.\n */\npublic static final int EDGE_REMOVED = 24;"
            ],
            [
                "CONNECTED_COMPONENT_STARTED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal started event.\n */\npublic static final int CONNECTED_COMPONENT_STARTED = 31;"
            ],
            [
                "CONNECTED_COMPONENT_FINISHED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal finished event.\n */\npublic static final int CONNECTED_COMPONENT_FINISHED = 32;"
            ],
            [
                "BEFORE_VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex added event. This event is fired before a vertex is added\n * to a graph.\n */\npublic static final int BEFORE_VERTEX_ADDED = 11;"
            ],
            [
                "BEFORE_VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex removed event. This event is fired before a vertex is\n * removed from a graph.\n */\npublic static final int BEFORE_VERTEX_REMOVED = 12;"
            ],
            [
                "VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex added event. This event is fired after a vertex is added to a\n * graph.\n */\npublic static final int VERTEX_ADDED = 13;"
            ],
            [
                "VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex removed event. This event is fired after a vertex is removed from\n * a graph.\n */\npublic static final int VERTEX_REMOVED = 14;"
            ],
            [
                "NULL_NODE",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "public static final int NULL_NODE = -1;"
            ],
            [
                "DEBUG",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected static final boolean DEBUG = false;"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg",
                "EdmondsKarpMaximumFlow",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 0.000000001;"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveClosure",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveClosure INSTANCE = new TransitiveClosure();"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveReduction",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveReduction INSTANCE = new TransitiveReduction();"
            ],
            [
                "NEGATIVE_UNDIRECTED_EDGE",
                "org.jgrapht.alg",
                "BellmanFordIterator",
                "/**\n * Error message.\n */\nprotected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg.flow",
                "MaximumFlowAlgorithmBase",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 1e-9;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [
            [
                "directedGraph",
                "org.jgrapht.DirectedGraph",
                "DirectedGraph<V, E>"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "getGraph",
                "org.jgrapht.alg",
                "KosarajuStrongConnectivityInspector",
                "/**\n * Returns the graph inspected by the StrongConnectivityAlgorithm.\n *\n * @return the graph inspected by this StrongConnectivityAlgorithm\n */\npublic DirectedGraph<V, E> getGraph() {\n    return graph;\n}"
            ],
            [
                "stronglyConnectedSubgraphs",
                "org.jgrapht.alg",
                "KosarajuStrongConnectivityInspector",
                "/**\n * <p>Computes a list of {@link DirectedSubgraph}s of the given graph. Each\n * subgraph will represent a strongly connected component and will contain\n * all vertices of that component. The subgraph will have an edge (u,v) iff\n * u and v are contained in the strongly connected component.</p>\n *\n * <p>NOTE: Calling this method will first execute {@link\n * KosarajuStrongConnectivityInspector#stronglyConnectedSets()}. If you\n * don't need subgraphs, use that method.</p>\n *\n * @return a list of subgraphs representing the strongly connected\n * components\n */\npublic List<DirectedSubgraph<V, E>> stronglyConnectedSubgraphs() {\n    if (stronglyConnectedSubgraphs == null) {\n        List<Set<V>> sets = stronglyConnectedSets();\n        stronglyConnectedSubgraphs = new Vector<DirectedSubgraph<V, E>>(sets.size());\n        for (Set<V> set : sets) {\n            stronglyConnectedSubgraphs.add(new DirectedSubgraph<V, E>(graph, set, null));\n        }\n    }\n    return stronglyConnectedSubgraphs;\n}"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "stronglyConnectedSets",
                "org.jgrapht.alg",
                "KosarajuStrongConnectivityInspector",
                "/**\n * Computes a {@link List} of {@link Set}s, where each set contains vertices\n * which together form a strongly connected component within the given\n * graph.\n *\n * @return <code>List</code> of <code>Set</code> s containing the strongly\n * connected components\n */\npublic List<Set<V>> stronglyConnectedSets() {\n    if (stronglyConnectedSets == null) {\n        orderedVertices = new LinkedList<VertexData<V>>();\n        stronglyConnectedSets = new Vector<Set<V>>();\n        // create VertexData objects for all vertices, store them\n        createVertexData();\n        // perform the first round of DFS, result is an ordering\n        // of the vertices by decreasing finishing time\n        for (VertexData<V> data : vertexToVertexData.values()) {\n            if (!data.isDiscovered()) {\n                dfsVisit(graph, data, null);\n            }\n        }\n        // 'create' inverse graph (i.e. every edge is reversed)\n        DirectedGraph<V, E> inverseGraph = new EdgeReversedGraph<V, E>(graph);\n        // get ready for next dfs round\n        resetVertexData();\n        // second dfs round: vertices are considered in decreasing\n        // finishing time order; every tree found is a strongly\n        // connected set\n        for (VertexData<V> data : orderedVertices) {\n            if (!data.isDiscovered()) {\n                // new strongly connected set\n                Set<V> set = new HashSet<V>();\n                stronglyConnectedSets.add(set);\n                dfsVisit(inverseGraph, data, set);\n            }\n        }\n        // clean up for garbage collection\n        orderedVertices = null;\n        vertexToVertexData = null;\n    }\n    return stronglyConnectedSets;\n}"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "isStronglyConnected",
                "org.jgrapht.alg",
                "KosarajuStrongConnectivityInspector",
                "/**\n * Returns true if the graph of this <code>\n * StronglyConnectivityInspector</code> instance is strongly connected.\n *\n * @return true if the graph is strongly connected, false otherwise\n */\npublic boolean isStronglyConnected() {\n    return stronglyConnectedSets().size() == 1;\n}"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "outDegreeOf",
                "org.jgrapht",
                "DirectedGraph",
                "public abstract int outDegreeOf(V arg0)"
            ],
            [
                "inDegreeOf",
                "org.jgrapht",
                "DirectedGraph",
                "public abstract int inDegreeOf(V arg0)"
            ],
            [
                "outgoingEdgesOf",
                "org.jgrapht",
                "DirectedGraph",
                "public abstract Set<E> outgoingEdgesOf(V arg0)"
            ],
            [
                "incomingEdgesOf",
                "org.jgrapht",
                "DirectedGraph",
                "public abstract Set<E> incomingEdgesOf(V arg0)"
            ],
            [
                "removeEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeEdge(E arg0)"
            ],
            [
                "containsEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean containsEdge(E arg0)"
            ],
            [
                "addVertex",
                "org.jgrapht",
                "Graph",
                "public abstract boolean addVertex(V arg0)"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graph",
                "public abstract E addEdge(V arg0, V arg1)"
            ],
            [
                "removeVertex",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeVertex(V arg0)"
            ],
            [
                "edgesOf",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> edgesOf(V arg0)"
            ],
            [
                "containsVertex",
                "org.jgrapht",
                "Graph",
                "public abstract boolean containsVertex(V arg0)"
            ],
            [
                "getEdgeSource",
                "org.jgrapht",
                "Graph",
                "public abstract V getEdgeSource(E arg0)"
            ],
            [
                "containsEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean containsEdge(V arg0, V arg1)"
            ],
            [
                "edgeSet",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> edgeSet()"
            ],
            [
                "getEdge",
                "org.jgrapht",
                "Graph",
                "public abstract E getEdge(V arg0, V arg1)"
            ],
            [
                "removeAllEdges",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeAllEdges(Collection<? extends E> arg0)"
            ],
            [
                "getAllEdges",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> getAllEdges(V arg0, V arg1)"
            ],
            [
                "getEdgeWeight",
                "org.jgrapht",
                "Graph",
                "public abstract double getEdgeWeight(E arg0)"
            ],
            [
                "getEdgeFactory",
                "org.jgrapht",
                "Graph",
                "public abstract EdgeFactory<V, E> getEdgeFactory()"
            ],
            [
                "removeAllVertices",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeAllVertices(Collection<? extends V> arg0)"
            ],
            [
                "getEdgeTarget",
                "org.jgrapht",
                "Graph",
                "public abstract V getEdgeTarget(E arg0)"
            ],
            [
                "removeEdge",
                "org.jgrapht",
                "Graph",
                "public abstract E removeEdge(V arg0, V arg1)"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean addEdge(V arg0, V arg1, E arg2)"
            ],
            [
                "removeAllEdges",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> removeAllEdges(V arg0, V arg1)"
            ],
            [
                "vertexSet",
                "org.jgrapht",
                "Graph",
                "public abstract Set<V> vertexSet()"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 26392,
        "oracle": ";",
        "oracleType": "PRE",
        "projectName": "jgrapht-core-0.9.2",
        "packageName": "org.jgrapht.alg",
        "className": "BellmanFordShortestPath",
        "javadocTag": "@param graph the graph to be searched",
        "methodJavadoc": "    /**\n     * Convenience method to find the shortest path via a single static method\n     * call. If you need a more advanced search (e.g. limited by hops, or\n     * computation of the path length), use the constructor instead.\n     *\n     * @param graph the graph to be searched\n     * @param startVertex the vertex at which the path should start\n     * @param endVertex the vertex at which the path should end\n     *\n     * @return List of Edges, or null if no path exists\n     */",
        "methodSourceCode": "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex){\n    BellmanFordShortestPath<V, E> alg = new BellmanFordShortestPath<V, E>(graph, startVertex);\n    return alg.getPathEdgeList(endVertex);\n}",
        "classJavadoc": "/**\n * <a href=\"http://www.nist.gov/dads/HTML/bellmanford.html\">Bellman-Ford\n * algorithm</a>: weights could be negative, paths could be constrained by a\n * maximum number of edges.\n */",
        "classSourceCode": "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------------\n * BellmanFordShortestPath.java\n * -------------------------\n * (C) Copyright 2006-2008, by France Telecom and Contributors.\n *\n * Original Author:  Guillaume Boulmier and Contributors.\n * Contributor(s):   John V. Sichi\n *\n * $Id$\n *\n * Changes\n * -------\n * 05-Jan-2006 : Initial revision (GB);\n * 14-Jan-2006 : Added support for generics (JVS);\n *\n */\npackage org.jgrapht.alg;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\n\n\n/**\n * <a href=\"http://www.nist.gov/dads/HTML/bellmanford.html\">Bellman-Ford\n * algorithm</a>: weights could be negative, paths could be constrained by a\n * maximum number of edges.\n */\npublic class BellmanFordShortestPath<V, E>\n{\n    private static final double DEFAULT_EPSILON = 0.000000001;\n\n    /**\n     * Graph on which shortest paths are searched.\n     */\n    protected Graph<V, E> graph;\n\n    /**\n     * Start vertex.\n     */\n    protected V startVertex;\n\n    private BellmanFordIterator<V, E> iter;\n\n    /**\n     * Maximum number of edges of the calculated paths.\n     */\n    private int nMaxHops;\n\n    private int passNumber;\n\n    private double epsilon;\n\n    /**\n     * Creates an object to calculate shortest paths between the start vertex\n     * and others vertices using the Bellman-Ford algorithm.\n     *\n     * @param graph\n     * @param startVertex\n     */\n    public BellmanFordShortestPath(Graph<V, E> graph, V startVertex)\n    {\n        this(graph, startVertex, graph.vertexSet().size() - 1);\n    }\n\n    /**\n     * Creates an object to calculate shortest paths between the start vertex\n     * and others vertices using the Bellman-Ford algorithm.\n     *\n     * @param graph\n     * @param startVertex\n     * @param nMaxHops maximum number of edges of the calculated paths.\n     */\n    public BellmanFordShortestPath(\n        Graph<V, E> graph,\n        V startVertex,\n        int nMaxHops)\n    {\n        this(graph, startVertex, nMaxHops, DEFAULT_EPSILON);\n    }\n\n    /**\n     * Creates an object to calculate shortest paths between the start vertex\n     * and others vertices using the Bellman-Ford algorithm.\n     *\n     * @param graph\n     * @param startVertex\n     * @param nMaxHops maximum number of edges of the calculated paths.\n     * @param epsilon tolerance factor.\n     */\n    public BellmanFordShortestPath(\n        Graph<V, E> graph,\n        V startVertex,\n        int nMaxHops,\n        double epsilon)\n    {\n        this.startVertex = startVertex;\n        this.nMaxHops = nMaxHops;\n        this.graph = graph;\n        this.passNumber = 1;\n        this.epsilon = epsilon;\n    }\n\n    /**\n     * @param endVertex end vertex.\n     *\n     * @return the cost of the shortest path between the start vertex and the\n     * end vertex.\n     */\n    public double getCost(V endVertex)\n    {\n        assertGetPath(endVertex);\n\n        lazyCalculate();\n\n        BellmanFordPathElement<V, E> pathElement =\n            this.iter.getPathElement(endVertex);\n\n        if (pathElement == null) {\n            return Double.POSITIVE_INFINITY;\n        }\n\n        return pathElement.getCost();\n    }\n\n    /**\n     * @param endVertex end vertex.\n     *\n     * @return list of <code>Edge</code>, or null if no path exists between the\n     * start vertex and the end vertex.\n     */\n    public List<E> getPathEdgeList(V endVertex)\n    {\n        assertGetPath(endVertex);\n\n        lazyCalculate();\n\n        BellmanFordPathElement<V, E> pathElement =\n            this.iter.getPathElement(endVertex);\n\n        if (pathElement == null) {\n            return null;\n        }\n\n        return pathElement.createEdgeListPath();\n    }\n\n    private void assertGetPath(V endVertex)\n    {\n        if (endVertex.equals(this.startVertex)) {\n            throw new IllegalArgumentException(\n                \"The end vertex is the same as the start vertex!\");\n        }\n\n        if (!this.graph.containsVertex(endVertex)) {\n            throw new IllegalArgumentException(\n                \"Graph must contain the end vertex!\");\n        }\n    }\n\n    private void lazyCalculate()\n    {\n        if (this.iter == null) {\n            this.iter =\n                new BellmanFordIterator<V, E>(\n                    this.graph,\n                    this.startVertex,\n                    epsilon);\n        }\n\n        // at the i-th pass the shortest paths with less (or equal) than i edges\n        // are calculated.\n        for (\n            ;\n            (this.passNumber <= this.nMaxHops) && this.iter.hasNext();\n            this.passNumber++)\n        {\n            this.iter.next();\n        }\n    }\n\n    /**\n     * Convenience method to find the shortest path via a single static method\n     * call. If you need a more advanced search (e.g. limited by hops, or\n     * computation of the path length), use the constructor instead.\n     *\n     * @param graph the graph to be searched\n     * @param startVertex the vertex at which the path should start\n     * @param endVertex the vertex at which the path should end\n     *\n     * @return List of Edges, or null if no path exists\n     */\n    public static <V, E> List<E> findPathBetween(\n        Graph<V, E> graph,\n        V startVertex,\n        V endVertex)\n    {\n        BellmanFordShortestPath<V, E> alg =\n            new BellmanFordShortestPath<V, E>(\n                graph,\n                startVertex);\n\n        return alg.getPathEdgeList(endVertex);\n    }\n}\n\n// End BellmanFordShortestPath.java\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "PartiteRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "RandomGraphHelper",
                "org.jgrapht.experimental"
            ],
            [
                "GraphReader",
                "org.jgrapht.experimental"
            ],
            [
                "DirectedAcyclicGraph",
                "org.jgrapht.experimental.dag"
            ],
            [
                "GraphSquare",
                "org.jgrapht.experimental"
            ],
            [
                "UniformRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "GraphTests",
                "org.jgrapht.experimental"
            ],
            [
                "ApproximationAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "BrownBacktrackColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "GreedyColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "IntArrayGraphAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ExactAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ListenableGraph",
                "org.jgrapht"
            ],
            [
                "ModifiableInteger",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeapNode",
                "org.jgrapht.util"
            ],
            [
                "WeightCombiner",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeap",
                "org.jgrapht.util"
            ],
            [
                "TypeUtil",
                "org.jgrapht.util"
            ],
            [
                "ArrayUnenforcedSet",
                "org.jgrapht.util"
            ],
            [
                "VertexPair",
                "org.jgrapht.util"
            ],
            [
                "MathUtil",
                "org.jgrapht.util"
            ],
            [
                "PrefetchIterator",
                "org.jgrapht.util"
            ],
            [
                "VertexFactory",
                "org.jgrapht"
            ],
            [
                "Graph",
                "org.jgrapht"
            ],
            [
                "GraphPath",
                "org.jgrapht"
            ],
            [
                "UndirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraph",
                "org.jgrapht.graph"
            ],
            [
                "MixedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DefaultGraphMapping",
                "org.jgrapht.graph"
            ],
            [
                "WeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskEdgeSet",
                "org.jgrapht.graph"
            ],
            [
                "Pseudograph",
                "org.jgrapht.graph"
            ],
            [
                "MaskFunctor",
                "org.jgrapht.graph"
            ],
            [
                "GraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractBaseGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "Multigraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultWeightedEdge",
                "org.jgrapht.graph"
            ],
            [
                "ListenableDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeSetFactory",
                "org.jgrapht.graph"
            ],
            [
                "GraphDelegator",
                "org.jgrapht.graph"
            ],
            [
                "DefaultListenableGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedVertexFactory",
                "org.jgrapht.graph"
            ],
            [
                "DefaultEdge",
                "org.jgrapht.graph"
            ],
            [
                "MaskVertexSet",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "IntrusiveEdge",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphPathImpl",
                "org.jgrapht.graph"
            ],
            [
                "Subgraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractGraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedEdgeFactory",
                "org.jgrapht.graph"
            ],
            [
                "SimpleWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "WeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeReversedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "AbstractGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "ListenableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraphPath",
                "org.jgrapht.graph"
            ],
            [
                "ParanoidGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphHelper",
                "org.jgrapht"
            ],
            [
                "Graphs",
                "org.jgrapht"
            ],
            [
                "DirectedGraph",
                "org.jgrapht"
            ],
            [
                "WeightedGraph",
                "org.jgrapht"
            ],
            [
                "HyperCubeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RingGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WheelGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GridGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "ScaleFreeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedBipartiteGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "LinearGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RandomGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGeneratorAdapter",
                "org.jgrapht.generate"
            ],
            [
                "EmptyGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteBipartiteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "StarGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "UndirectedGraph",
                "org.jgrapht"
            ],
            [
                "TopologicalOrderIterator",
                "org.jgrapht.traverse"
            ],
            [
                "CrossComponentIterator",
                "org.jgrapht.traverse"
            ],
            [
                "AbstractGraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "ClosestFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "BreadthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "DepthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "GraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "EdgeFactory",
                "org.jgrapht"
            ],
            [
                "GraphMapping",
                "org.jgrapht"
            ],
            [
                "VertexSetListener",
                "org.jgrapht.event"
            ],
            [
                "EdgeTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "TraversalListener",
                "org.jgrapht.event"
            ],
            [
                "GraphEdgeChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "VertexTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphListener",
                "org.jgrapht.event"
            ],
            [
                "TraversalListenerAdapter",
                "org.jgrapht.event"
            ],
            [
                "ConnectedComponentTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphVertexChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "TarjanLowestCommonAncestor",
                "org.jgrapht.alg"
            ],
            [
                "PrimMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "BlockCutpointGraph",
                "org.jgrapht.alg"
            ],
            [
                "AllDirectedPaths",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPathsIterator",
                "org.jgrapht.alg"
            ],
            [
                "KruskalMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "StrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "VF2State",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2AbstractIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "GraphOrdering",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphicGraphMapping",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2MappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "BronKerboschCliqueFinder",
                "org.jgrapht.alg"
            ],
            [
                "ChromaticNumber",
                "org.jgrapht.alg"
            ],
            [
                "KosarajuStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "DijkstraShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElement",
                "org.jgrapht.alg"
            ],
            [
                "AStarShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordPathElement",
                "org.jgrapht.alg"
            ],
            [
                "FloydWarshallShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "UnionFind",
                "org.jgrapht.alg.util"
            ],
            [
                "AlwaysEqualComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Extension",
                "org.jgrapht.alg.util"
            ],
            [
                "VertexDegreeComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Pair",
                "org.jgrapht.alg.util"
            ],
            [
                "GabowStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "HawickJamesSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "DirectedSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "JohnsonSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TiernanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "UndirectedCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "PatonCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TarjanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "SzwarcfiterLauerSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "BiconnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "ConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "MinSourceSinkCut",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsBlossomShrinking",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveClosure",
                "org.jgrapht.alg"
            ],
            [
                "HopcroftKarpBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "StoerWagnerMinimumCut",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "KuhnMunkresMinimalWeightBipartitePerfectMatching",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveReduction",
                "org.jgrapht.alg"
            ],
            [
                "EulerianCircuit",
                "org.jgrapht.alg"
            ],
            [
                "DirectedNeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "NaiveLcaFinder",
                "org.jgrapht.alg"
            ],
            [
                "MaximumWeightBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "HamiltonianCycle",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "NeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "VertexCovers",
                "org.jgrapht.alg"
            ],
            [
                "CycleDetector",
                "org.jgrapht.alg"
            ],
            [
                "AStarAdmissibleHeuristic",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MinimumSpanningTree",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "WeightedMatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "StrongConnectivityAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MaximumFlowAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "CliqueMinimalSeparatorDecomposition",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordIterator",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElement",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "PushRelabelMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "MaximumFlowAlgorithmBase",
                "org.jgrapht.alg.flow"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "addVertices",
                "org.jgrapht.experimental",
                "RandomGraphHelper",
                "/**\n * .\n *\n * @param target\n * @param vertexFactory\n * @param numVertices\n *\n * @return vertices\n */\n@SuppressWarnings(\"unchecked\")\npublic static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices) {\n    Object[] vertices = new Object[numVertices];\n    for (int i = 0; i < numVertices; ++i) {\n        vertices[i] = vertexFactory.createVertex();\n        target.addVertex(vertices[i]);\n    }\n    return vertices;\n}"
            ],
            [
                "isEmpty",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isEmpty(Graph<V, E> g) {\n    return g.edgeSet().isEmpty();\n}"
            ],
            [
                "isComplete",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isComplete(Graph<V, E> g) {\n    int n = g.vertexSet().size();\n    return g.edgeSet().size() == (n * (n - 1) / 2);\n}"
            ],
            [
                "isConnected",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isConnected(Graph<V, E> g) {\n    int numVertices = g.vertexSet().size();\n    int numEdges = g.edgeSet().size();\n    if (numEdges < (numVertices - 1)) {\n        return false;\n    }\n    if ((numVertices < 2) || (numEdges > ((numVertices - 1) * (numVertices - 2) / 2))) {\n        return true;\n    }\n    Set<V> known = new HashSet<V>();\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = g.vertexSet().iterator().next();\n    // start with node 1\n    queue.add(v);\n    known.add(v);\n    while (!queue.isEmpty()) {\n        v = queue.removeFirst();\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            v = it.next();\n            if (!known.contains(v)) {\n                known.add(v);\n                queue.add(v);\n            }\n        }\n    }\n    return known.size() == numVertices;\n}"
            ],
            [
                "isTree",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isTree(Graph<V, E> g) {\n    return isConnected(g) && (g.edgeSet().size() == (g.vertexSet().size() - 1));\n}"
            ],
            [
                "isBipartite",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isBipartite(Graph<V, E> g) {\n    if ((4 * g.edgeSet().size()) > (g.vertexSet().size() * g.vertexSet().size())) {\n        return false;\n    }\n    if (isEmpty(g)) {\n        return true;\n    }\n    Set<V> unknown = new HashSet<V>(g.vertexSet());\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = unknown.iterator().next();\n    Set<V> odd = new HashSet<V>();\n    queue.add(v);\n    while (!unknown.isEmpty()) {\n        if (queue.isEmpty()) {\n            queue.add(unknown.iterator().next());\n        }\n        v = queue.removeFirst();\n        unknown.remove(v);\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            V n = it.next();\n            if (unknown.contains(n)) {\n                queue.add(n);\n                if (!odd.contains(v)) {\n                    odd.add(n);\n                }\n            } else if (!(odd.contains(v) ^ odd.contains(n))) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
            ],
            [
                "union",
                "org.jgrapht.util",
                "FibonacciHeap",
                "// size\n/**\n * Joins two Fibonacci heaps into a new one. No heap consolidation is\n * performed at this time. The two root lists are simply joined together.\n *\n * <p>Running time: O(1) actual</p>\n *\n * @param h1 first heap\n * @param h2 second heap\n *\n * @return new heap containing h1 and h2\n */\npublic static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2) {\n    FibonacciHeap<T> h = new FibonacciHeap<T>();\n    if ((h1 != null) && (h2 != null)) {\n        h.minNode = h1.minNode;\n        if (h.minNode != null) {\n            if (h2.minNode != null) {\n                h.minNode.right.left = h2.minNode.left;\n                h2.minNode.left.right = h.minNode.right;\n                h.minNode.right = h2.minNode;\n                h2.minNode.left = h.minNode;\n                if (h2.minNode.key < h1.minNode.key) {\n                    h.minNode = h2.minNode;\n                }\n            }\n        } else {\n            h.minNode = h2.minNode;\n        }\n        h.nNodes = h1.nNodes + h2.nNodes;\n    }\n    return h;\n}"
            ],
            [
                "uncheckedCast",
                "org.jgrapht.util",
                "TypeUtil",
                "/**\n * Casts an object to a type.\n *\n * @param o object to be cast\n * @param typeDecl conveys the target type information; the actual value is\n * unused and can be null since this is all just stupid compiler tricks\n *\n * @return the result of the cast\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl) {\n    return (T) o;\n}"
            ],
            [
                "factorial",
                "org.jgrapht.util",
                "MathUtil",
                "public static long factorial(int N) {\n    long multi = 1;\n    for (int i = 1; i <= N; i++) {\n        multi = multi * i;\n    }\n    return multi;\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graphs",
                "/**\n * Creates a new edge and adds it to the specified graph similarly to the\n * {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n *\n * @see Graph#addEdge(Object, Object)\n */\npublic static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    EdgeFactory<V, E> ef = g.getEdgeFactory();\n    E e = ef.createEdge(sourceVertex, targetVertex);\n    // we first create the edge and set the weight to make sure that\n    // listeners will see the correct weight upon addEdge.\n    assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n    ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n    return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new edge and adds it to the specified\n * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return g.addEdge(sourceVertex, targetVertex);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified edge to the graph, including its vertices if not\n * already included.\n *\n * @param targetGraph the graph for which the specified edge to be added.\n * @param sourceGraph the graph in which the specified edge is already\n * present\n * @param edge edge to add\n *\n * @return <tt>true</tt> if the target graph did not already contain the\n * specified edge.\n */\npublic static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge) {\n    V sourceVertex = sourceGraph.getEdgeSource(edge);\n    V targetVertex = sourceGraph.getEdgeTarget(edge);\n    targetGraph.addVertex(sourceVertex);\n    targetGraph.addVertex(targetVertex);\n    return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new weighted edge and adds it to the\n * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n * method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return addEdge(g, sourceVertex, targetVertex, weight);\n}"
            ],
            [
                "addGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all the vertices and all the edges of the specified source graph to\n * the specified destination graph. First all vertices of the source graph\n * are added to the destination graph. Then every edge of the source graph\n * is added to the destination graph. This method returns <code>true</code>\n * if the destination graph has been modified as a result of this operation,\n * otherwise it returns <code>false</code>.\n *\n * <p>The behavior of this operation is undefined if any of the specified\n * graphs is modified while operation is in progress.</p>\n *\n * @param destination the graph to which vertices and edges are added.\n * @param source the graph used as source for vertices and edges to add.\n *\n * @return <code>true</code> if and only if the destination graph has been\n * changed as a result of this operation.\n */\npublic static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source) {\n    boolean modified = addAllVertices(destination, source.vertexSet());\n    modified |= addAllEdges(destination, source, source.edgeSet());\n    return modified;\n}"
            ],
            [
                "addAllEdges",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds a subset of the edges of the specified source graph to the specified\n * destination graph. The behavior of this operation is undefined if either\n * of the graphs is modified while the operation is in progress. {@link\n * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n * be added automatically to the target graph.\n *\n * @param destination the graph to which edges are to be added\n * @param source the graph used as a source for edges to add\n * @param edges the edges to be added\n *\n * @return <tt>true</tt> if this graph changed as a result of the call\n */\npublic static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges) {\n    boolean modified = false;\n    for (E e : edges) {\n        V s = source.getEdgeSource(e);\n        V t = source.getEdgeTarget(e);\n        destination.addVertex(s);\n        destination.addVertex(t);\n        modified |= destination.addEdge(s, t, e);\n    }\n    return modified;\n}"
            ],
            [
                "addAllVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all of the specified vertices to the destination graph. The behavior\n * of this operation is undefined if the specified vertex collection is\n * modified while the operation is in progress. This method will invoke the\n * {@link Graph#addVertex(Object)} method.\n *\n * @param destination the graph to which edges are to be added\n * @param vertices the vertices to be added to the graph.\n *\n * @return <tt>true</tt> if graph changed as a result of the call\n *\n * @throws NullPointerException if the specified vertices contains one or\n * more null vertices, or if the specified vertex collection is <tt>\n * null</tt>.\n *\n * @see Graph#addVertex(Object)\n */\npublic static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices) {\n    boolean modified = false;\n    for (V v : vertices) {\n        modified |= destination.addVertex(v);\n    }\n    return modified;\n}"
            ],
            [
                "neighborListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the neighbors of a specified vertex.\n * If the graph is a multigraph vertices may appear more than once in the\n * returned list.\n *\n * @param g the graph to look for neighbors in.\n * @param vertex the vertex to get the neighbors of.\n *\n * @return a list of the vertices that are the neighbors of the specified\n * vertex.\n */\npublic static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex) {\n    List<V> neighbors = new ArrayList<V>();\n    for (E e : g.edgesOf(vertex)) {\n        neighbors.add(getOppositeVertex(g, e, vertex));\n    }\n    return neighbors;\n}"
            ],
            [
                "predecessorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct predecessors of a\n * specified vertex. If the graph is a multigraph, vertices may appear more\n * than once in the returned list.\n *\n * @param g the graph to look for predecessors in.\n * @param vertex the vertex to get the predecessors of.\n *\n * @return a list of the vertices that are the direct predecessors of the\n * specified vertex.\n */\npublic static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> predecessors = new ArrayList<V>();\n    Set<? extends E> edges = g.incomingEdgesOf(vertex);\n    for (E e : edges) {\n        predecessors.add(getOppositeVertex(g, e, vertex));\n    }\n    return predecessors;\n}"
            ],
            [
                "successorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct successors of a specified\n * vertex. If the graph is a multigraph vertices may appear more than once\n * in the returned list.\n *\n * @param g the graph to look for successors in.\n * @param vertex the vertex to get the successors of.\n *\n * @return a list of the vertices that are the direct successors of the\n * specified vertex.\n */\npublic static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> successors = new ArrayList<V>();\n    Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n    for (E e : edges) {\n        successors.add(getOppositeVertex(g, e, vertex));\n    }\n    return successors;\n}"
            ],
            [
                "undirectedGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns an undirected view of the specified graph. If the specified graph\n * is directed, returns an undirected view of it. If the specified graph is\n * already undirected, just returns it.\n *\n * @param g the graph for which an undirected view is to be returned.\n *\n * @return an undirected view of the specified graph, if it is directed, or\n * or the specified graph itself if it is already undirected.\n *\n * @throws IllegalArgumentException if the graph is neither DirectedGraph\n * nor UndirectedGraph.\n *\n * @see AsUndirectedGraph\n */\npublic static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n    } else if (g instanceof UndirectedGraph<?, ?>) {\n        return (UndirectedGraph<V, E>) g;\n    } else {\n        throw new IllegalArgumentException(\"Graph must be either DirectedGraph or UndirectedGraph\");\n    }\n}"
            ],
            [
                "testIncidence",
                "org.jgrapht",
                "Graphs",
                "/**\n * Tests whether an edge is incident to a vertex.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return true iff e is incident on v\n */\npublic static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v) {\n    return (g.getEdgeSource(e).equals(v)) || (g.getEdgeTarget(e).equals(v));\n}"
            ],
            [
                "getOppositeVertex",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the vertex opposite another vertex across an edge.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return vertex opposite to v across e\n */\npublic static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v) {\n    V source = g.getEdgeSource(e);\n    V target = g.getEdgeTarget(e);\n    if (v.equals(source)) {\n        return target;\n    } else if (v.equals(target)) {\n        return source;\n    } else {\n        throw new IllegalArgumentException(\"no such vertex: \" + v.toString());\n    }\n}"
            ],
            [
                "getPathVertexList",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the list of vertices visited by a path.\n *\n * @param path path of interest\n *\n * @return corresponding vertex list\n */\npublic static <V, E> List<V> getPathVertexList(GraphPath<V, E> path) {\n    Graph<V, E> g = path.getGraph();\n    List<V> list = new ArrayList<V>();\n    V v = path.getStartVertex();\n    list.add(v);\n    for (E e : path.getEdgeList()) {\n        v = getOppositeVertex(g, e, v);\n        list.add(v);\n    }\n    return list;\n}"
            ],
            [
                "range",
                "org.jgrapht.generate",
                "SimpleWeightedGraphMatrixGenerator",
                "///////////////////////////////////////////////////////////////////////////////////////////////\npublic static int[] range(final int from, final int to) {\n    int[] range = new int[to - from];\n    for (int i = from; i < to; ++i) {\n        range[i - from] = i;\n    }\n    return range;\n}"
            ],
            [
                "createGraphSpecifics",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "// -------------------------------------------------------------------------\n/**\n * @param <V>\n * @param <E>\n * @param g\n *\n * @return TODO Document me\n */\nstatic <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new DirectedSpecifics<V, E>((DirectedGraph<V, E>) g);\n    } else {\n        return new UndirectedSpecifics<V, E>(g);\n    }\n}"
            ],
            [
                "findGreedyChromaticNumber",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds the number of colors required for a greedy coloring of the graph.\n *\n * @param g an undirected graph to find the chromatic number of\n *\n * @return integer the approximate chromatic number from the greedy\n * algorithm\n */\npublic static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g) {\n    Map<Integer, Set<V>> coloredGroups = findGreedyColoredGroups(g);\n    return coloredGroups.keySet().size();\n}"
            ],
            [
                "findGreedyColoredGroups",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds a greedy coloring of the graph.\n *\n * @param g an undirected graph for which to find the coloring\n */\npublic static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g) {\n    // A copy of the graph is made, so that elements of the graph may be\n    // removed to carry out the algorithm\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // The Vertices will be sorted in decreasing order by degree, so that\n    // higher degree vertices have priority to be colored first\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    List<V> sortedVertices = new LinkedList<V>(sg.vertexSet());\n    Collections.sort(sortedVertices, comp);\n    Collections.reverse(sortedVertices);\n    int color;\n    // create a map which will hold color as key and Set<V> as value\n    Map<Integer, Set<V>> coloredGroups = new HashMap<Integer, Set<V>>();\n    // We'll attempt to color each vertex with a single color each\n    // iteration, and these vertices will be removed from the graph at the\n    // end of each iteration\n    for (color = 0; sg.vertexSet().size() > 0; color++) {\n        // This set will contain vertices that are colored with the\n        // current color of this iteration\n        Set<V> currentColor = new HashSet<V>();\n        for (Iterator<V> iter = sortedVertices.iterator(); iter.hasNext(); ) {\n            V v = iter.next();\n            // Add new vertices to be colored as long as they are not\n            // adjacent with any other vertex that has already been colored\n            // with the current color\n            boolean flag = true;\n            for (Iterator<V> innerIter = currentColor.iterator(); innerIter.hasNext(); ) {\n                V temp = innerIter.next();\n                if (sg.containsEdge(temp, v)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                currentColor.add(v);\n                iter.remove();\n            }\n        }\n        // Add all these vertices as a group for this color\n        coloredGroups.put(color, currentColor);\n        // Remove vertices from the graph and then repeat the process for\n        // the next iteration\n        sg.removeAllVertices(currentColor);\n    }\n    return coloredGroups;\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "BellmanFordShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by hops, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    BellmanFordShortestPath<V, E> alg = new BellmanFordShortestPath<V, E>(graph, startVertex);\n    return alg.getPathEdgeList(endVertex);\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "DijkstraShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by radius, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    DijkstraShortestPath<V, E> alg = new DijkstraShortestPath<V, E>(graph, startVertex, endVertex);\n    return alg.getPathEdgeList();\n}"
            ],
            [
                "of",
                "org.jgrapht.alg.util",
                "Pair",
                "/**\n * Creates new pair of elements pulling of the necessity to provide\n * corresponding types of the elements supplied\n *\n * @param a first element\n * @param b second element\n *\n * @return new pair\n */\npublic static <A, B> Pair<A, B> of(A a, B b) {\n    return new Pair<A, B>(a, b);\n}"
            ],
            [
                "isEulerian",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will check whether the graph passed in is Eulerian or not.\n *\n * @param g The graph to be checked\n *\n * @return true for Eulerian and false for non-Eulerian\n */\npublic static <V, E> boolean isEulerian(UndirectedGraph<V, E> g) {\n    // If the graph is not connected, then no Eulerian circuit exists\n    if (!(new ConnectivityInspector<V, E>(g)).isGraphConnected()) {\n        return false;\n    }\n    // A graph is Eulerian if and only if all vertices have even degree\n    // So, this code will check for that\n    Iterator<V> iter = g.vertexSet().iterator();\n    while (iter.hasNext()) {\n        V v = iter.next();\n        if ((g.degreeOf(v) % 2) == 1) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "getEulerianCircuitVertices",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will return a list of vertices which represents the Eulerian\n * circuit of the graph.\n *\n * @param g The graph to find an Eulerian circuit\n *\n * @return null if no Eulerian circuit exists, or a list of vertices\n * representing the Eulerian circuit if one does exist\n */\npublic static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g) {\n    // If the graph is not Eulerian then just return a null since no\n    // Eulerian circuit exists\n    if (!isEulerian(g)) {\n        return null;\n    }\n    // The circuit will be represented by a linked list\n    List<V> path = new LinkedList<V>();\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    path.add(sg.vertexSet().iterator().next());\n    // Algorithm for finding an Eulerian circuit Basically this will find an\n    // arbitrary circuit, then it will find another arbitrary circuit until\n    // every edge has been traversed\n    while (sg.edgeSet().size() > 0) {\n        V v = null;\n        // Find a vertex which has an edge that hasn't been traversed yet,\n        // and keep its index position in the circuit list\n        int index = 0;\n        for (Iterator<V> iter = path.iterator(); iter.hasNext(); index++) {\n            v = iter.next();\n            if (sg.degreeOf(v) > 0) {\n                break;\n            }\n        }\n        // Finds an arbitrary circuit of the current vertex and\n        // appends this into the circuit list\n        while (sg.degreeOf(v) > 0) {\n            for (Iterator<V> iter = sg.vertexSet().iterator(); iter.hasNext(); ) {\n                V temp = iter.next();\n                if (sg.containsEdge(v, temp)) {\n                    path.add(index, temp);\n                    sg.removeEdge(v, temp);\n                    v = temp;\n                    break;\n                }\n            }\n        }\n    }\n    return path;\n}"
            ],
            [
                "getApproximateOptimalForCompleteGraph",
                "org.jgrapht.alg",
                "HamiltonianCycle",
                "/**\n * This method will return an approximate minimal traveling salesman tour\n * (hamiltonian cycle). This algorithm requires that the graph be complete\n * and the triangle inequality exists (if x,y,z are vertices then\n * d(x,y)+d(y,z) &lt; d(x,z) for all x,y,z) then this algorithm will\n * guarantee a hamiltonian cycle such that the total weight of the cycle is\n * less than or equal to double the total weight of the optimal hamiltonian\n * cycle. The optimal solution is NP-complete, so this is a decent\n * approximation that runs in polynomial time.\n *\n * @param <V>\n * @param <E>\n * @param g is the graph to find the optimal tour for.\n *\n * @return The optimal tour as a list of vertices.\n */\npublic static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g) {\n    List<V> vertices = new LinkedList<V>(g.vertexSet());\n    // If the graph is not complete then return null since this algorithm\n    // requires the graph be complete\n    if ((vertices.size() * (vertices.size() - 1) / 2) != g.edgeSet().size()) {\n        return null;\n    }\n    List<V> tour = new LinkedList<V>();\n    // Each iteration a new vertex will be added to the tour until all\n    // vertices have been added\n    while (tour.size() != g.vertexSet().size()) {\n        boolean firstEdge = true;\n        double minEdgeValue = 0;\n        int minVertexFound = 0;\n        int vertexConnectedTo = 0;\n        // A check will be made for the shortest edge to a vertex not within\n        // the tour and that new vertex will be added to the vertex\n        for (int i = 0; i < tour.size(); i++) {\n            V v = tour.get(i);\n            for (int j = 0; j < vertices.size(); j++) {\n                double weight = g.getEdgeWeight(g.getEdge(v, vertices.get(j)));\n                if (firstEdge || (weight < minEdgeValue)) {\n                    firstEdge = false;\n                    minEdgeValue = weight;\n                    minVertexFound = j;\n                    vertexConnectedTo = i;\n                }\n            }\n        }\n        tour.add(vertexConnectedTo, vertices.get(minVertexFound));\n        vertices.remove(minVertexFound);\n    }\n    return tour;\n}"
            ],
            [
                "find2ApproximationCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a 2-approximation for a minimal vertex cover of the specified\n * graph. The algorithm promises a cover that is at most double the size of\n * a minimal cover. The algorithm takes O(|E|) time.\n *\n * <p>For more details see Jenny Walter, CMPU-240: Lecture notes for\n * Language Theory and Computation, Fall 2002, Vassar College, <a\n * href=\"http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf\">\n * http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf</a>.\n * </p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G'=(V',E') <-- G(V,E)\n    Subgraph<V, E, Graph<V, E>> sg = new Subgraph<V, E, Graph<V, E>>(g, null, null);\n    // while E' is non-empty\n    while (sg.edgeSet().size() > 0) {\n        // let (u,v) be an arbitrary edge of E'\n        E e = sg.edgeSet().iterator().next();\n        // C <-- C U {u,v}\n        V u = g.getEdgeSource(e);\n        V v = g.getEdgeTarget(e);\n        cover.add(u);\n        cover.add(v);\n        // remove from E' every edge incident on either u or v\n        sg.removeVertex(u);\n        sg.removeVertex(v);\n    }\n    // return C\n    return cover;\n}"
            ],
            [
                "findGreedyCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a greedy approximation for a minimal vertex cover of a specified\n * graph. At each iteration, the algorithm picks the vertex with the highest\n * degree and adds it to the cover, until all edges are covered.\n *\n * <p>The algorithm works on undirected graphs, but can also work on\n * directed graphs when their edge-directions are ignored. To ignore edge\n * directions you can use {@link org.jgrapht.Graphs#undirectedGraph(Graph)}\n * or {@link org.jgrapht.graph.AsUndirectedGraph}.</p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G' <-- G\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // compare vertices in descending order of degree\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    // while G' != {}\n    while (sg.edgeSet().size() > 0) {\n        // v <-- vertex with maximum degree in G'\n        V v = Collections.max(sg.vertexSet(), comp);\n        // C <-- C U {v}\n        cover.add(v);\n        // remove from G' every edge incident on v, and v itself\n        sg.removeVertex(v);\n    }\n    return cover;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "BEST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int BEST_ORDER = 0;"
            ],
            [
                "NATURAL_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int NATURAL_ORDER = 1;"
            ],
            [
                "SMALLEST_DEGREE_LAST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;"
            ],
            [
                "LARGEST_SATURATION_FIRST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;"
            ],
            [
                "DEFAULT_EDGE_WEIGHT",
                "org.jgrapht",
                "WeightedGraph",
                "/**\n * The default weight for an edge.\n */\npublic static double DEFAULT_EDGE_WEIGHT = 1.0;"
            ],
            [
                "HUB_VERTEX",
                "org.jgrapht.generate",
                "WheelGraphGenerator",
                "/**\n * Role for the hub vertex.\n */\npublic static final String HUB_VERTEX = \"Hub Vertex\";"
            ],
            [
                "CORNER_VERTEX",
                "org.jgrapht.generate",
                "GridGraphGenerator",
                "/**\n * Role for the vertices at the corners.\n */\npublic static final String CORNER_VERTEX = \"Corner Vertex\";"
            ],
            [
                "START_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the first vertex generated.\n */\npublic static final String START_VERTEX = \"Start Vertex\";"
            ],
            [
                "END_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the last vertex generated.\n */\npublic static final String END_VERTEX = \"End Vertex\";"
            ],
            [
                "CENTER_VERTEX",
                "org.jgrapht.generate",
                "StarGraphGenerator",
                "public static final String CENTER_VERTEX = \"Center Vertex\";"
            ],
            [
                "SENTINEL",
                "org.jgrapht.traverse",
                "DepthFirstIterator",
                "/**\n * Sentinel object. Unfortunately, we can't use null, because ArrayDeque\n * won't accept those. And we don't want to rely on the caller to provide a\n * sentinel object for us. So we have to play typecasting games.\n */\npublic static final Object SENTINEL = new Object();"
            ],
            [
                "BEFORE_EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge added event. This event is fired before an edge is added to a\n * graph.\n */\npublic static final int BEFORE_EDGE_ADDED = 21;"
            ],
            [
                "BEFORE_EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge removed event. This event is fired before an edge is removed\n * from a graph.\n */\npublic static final int BEFORE_EDGE_REMOVED = 22;"
            ],
            [
                "EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge added event. This event is fired after an edge is added to a graph.\n */\npublic static final int EDGE_ADDED = 23;"
            ],
            [
                "EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge removed event. This event is fired after an edge is removed from a\n * graph.\n */\npublic static final int EDGE_REMOVED = 24;"
            ],
            [
                "CONNECTED_COMPONENT_STARTED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal started event.\n */\npublic static final int CONNECTED_COMPONENT_STARTED = 31;"
            ],
            [
                "CONNECTED_COMPONENT_FINISHED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal finished event.\n */\npublic static final int CONNECTED_COMPONENT_FINISHED = 32;"
            ],
            [
                "BEFORE_VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex added event. This event is fired before a vertex is added\n * to a graph.\n */\npublic static final int BEFORE_VERTEX_ADDED = 11;"
            ],
            [
                "BEFORE_VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex removed event. This event is fired before a vertex is\n * removed from a graph.\n */\npublic static final int BEFORE_VERTEX_REMOVED = 12;"
            ],
            [
                "VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex added event. This event is fired after a vertex is added to a\n * graph.\n */\npublic static final int VERTEX_ADDED = 13;"
            ],
            [
                "VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex removed event. This event is fired after a vertex is removed from\n * a graph.\n */\npublic static final int VERTEX_REMOVED = 14;"
            ],
            [
                "NULL_NODE",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "public static final int NULL_NODE = -1;"
            ],
            [
                "DEBUG",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected static final boolean DEBUG = false;"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg",
                "EdmondsKarpMaximumFlow",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 0.000000001;"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveClosure",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveClosure INSTANCE = new TransitiveClosure();"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveReduction",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveReduction INSTANCE = new TransitiveReduction();"
            ],
            [
                "NEGATIVE_UNDIRECTED_EDGE",
                "org.jgrapht.alg",
                "BellmanFordIterator",
                "/**\n * Error message.\n */\nprotected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg.flow",
                "MaximumFlowAlgorithmBase",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 1e-9;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [
            [
                "graph",
                "org.jgrapht.Graph",
                "Graph<V, E>"
            ],
            [
                "startVertex",
                "",
                "V"
            ],
            [
                "endVertex",
                "",
                "V"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "getPathEdgeList",
                "org.jgrapht.alg",
                "BellmanFordShortestPath",
                "/**\n * @param endVertex end vertex.\n *\n * @return list of <code>Edge</code>, or null if no path exists between the\n * start vertex and the end vertex.\n */\npublic List<E> getPathEdgeList(V endVertex) {\n    assertGetPath(endVertex);\n    lazyCalculate();\n    BellmanFordPathElement<V, E> pathElement = this.iter.getPathElement(endVertex);\n    if (pathElement == null) {\n        return null;\n    }\n    return pathElement.createEdgeListPath();\n}"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "getCost",
                "org.jgrapht.alg",
                "BellmanFordShortestPath",
                "/**\n * @param endVertex end vertex.\n *\n * @return the cost of the shortest path between the start vertex and the\n * end vertex.\n */\npublic double getCost(V endVertex) {\n    assertGetPath(endVertex);\n    lazyCalculate();\n    BellmanFordPathElement<V, E> pathElement = this.iter.getPathElement(endVertex);\n    if (pathElement == null) {\n        return Double.POSITIVE_INFINITY;\n    }\n    return pathElement.getCost();\n}"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "getEdgeFactory",
                "org.jgrapht",
                "Graph",
                "public abstract EdgeFactory<V, E> getEdgeFactory()"
            ],
            [
                "removeAllVertices",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeAllVertices(Collection<? extends V> arg0)"
            ],
            [
                "vertexSet",
                "org.jgrapht",
                "Graph",
                "public abstract Set<V> vertexSet()"
            ],
            [
                "getEdgeTarget",
                "org.jgrapht",
                "Graph",
                "public abstract V getEdgeTarget(E arg0)"
            ],
            [
                "containsEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean containsEdge(E arg0)"
            ],
            [
                "containsVertex",
                "org.jgrapht",
                "Graph",
                "public abstract boolean containsVertex(V arg0)"
            ],
            [
                "removeEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeEdge(E arg0)"
            ],
            [
                "getAllEdges",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> getAllEdges(V arg0, V arg1)"
            ],
            [
                "getEdgeSource",
                "org.jgrapht",
                "Graph",
                "public abstract V getEdgeSource(E arg0)"
            ],
            [
                "getEdgeWeight",
                "org.jgrapht",
                "Graph",
                "public abstract double getEdgeWeight(E arg0)"
            ],
            [
                "removeEdge",
                "org.jgrapht",
                "Graph",
                "public abstract E removeEdge(V arg0, V arg1)"
            ],
            [
                "getEdge",
                "org.jgrapht",
                "Graph",
                "public abstract E getEdge(V arg0, V arg1)"
            ],
            [
                "edgeSet",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> edgeSet()"
            ],
            [
                "containsEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean containsEdge(V arg0, V arg1)"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean addEdge(V arg0, V arg1, E arg2)"
            ],
            [
                "addVertex",
                "org.jgrapht",
                "Graph",
                "public abstract boolean addVertex(V arg0)"
            ],
            [
                "removeAllEdges",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> removeAllEdges(V arg0, V arg1)"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graph",
                "public abstract E addEdge(V arg0, V arg1)"
            ],
            [
                "edgesOf",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> edgesOf(V arg0)"
            ],
            [
                "removeAllEdges",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeAllEdges(Collection<? extends E> arg0)"
            ],
            [
                "removeVertex",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeVertex(V arg0)"
            ],
            [
                "equals",
                "java.util",
                "List",
                "public abstract boolean equals(Object arg0)"
            ],
            [
                "addAll",
                "java.util",
                "List",
                "public abstract boolean addAll(Collection<? extends E> arg0)"
            ],
            [
                "subList",
                "java.util",
                "List",
                "public abstract List<E> subList(int arg0, int arg1)"
            ],
            [
                "listIterator",
                "java.util",
                "List",
                "public abstract ListIterator<E> listIterator()"
            ],
            [
                "add",
                "java.util",
                "List",
                "public abstract boolean add(E arg0)"
            ],
            [
                "lastIndexOf",
                "java.util",
                "List",
                "public abstract int lastIndexOf(Object arg0)"
            ],
            [
                "remove",
                "java.util",
                "List",
                "public abstract E remove(int arg0)"
            ],
            [
                "indexOf",
                "java.util",
                "List",
                "public abstract int indexOf(Object arg0)"
            ],
            [
                "retainAll",
                "java.util",
                "List",
                "public abstract boolean retainAll(Collection<? extends Object> arg0)"
            ],
            [
                "toArray",
                "java.util",
                "List",
                "public abstract Object[] toArray()"
            ],
            [
                "isEmpty",
                "java.util",
                "List",
                "public abstract boolean isEmpty()"
            ],
            [
                "spliterator",
                "java.util",
                "List",
                "public default Spliterator<E> spliterator()"
            ],
            [
                "remove",
                "java.util",
                "List",
                "public abstract boolean remove(Object arg0)"
            ],
            [
                "removeAll",
                "java.util",
                "List",
                "public abstract boolean removeAll(Collection<? extends Object> arg0)"
            ],
            [
                "listIterator",
                "java.util",
                "List",
                "public abstract ListIterator<E> listIterator(int arg0)"
            ],
            [
                "size",
                "java.util",
                "List",
                "public abstract int size()"
            ],
            [
                "containsAll",
                "java.util",
                "List",
                "public abstract boolean containsAll(Collection<? extends Object> arg0)"
            ],
            [
                "get",
                "java.util",
                "List",
                "public abstract E get(int arg0)"
            ],
            [
                "addAll",
                "java.util",
                "List",
                "public abstract boolean addAll(int arg0, Collection<? extends E> arg1)"
            ],
            [
                "toArray",
                "java.util",
                "List",
                "public abstract <T> T[] toArray(T[] arg0)"
            ],
            [
                "hashCode",
                "java.util",
                "List",
                "public abstract int hashCode()"
            ],
            [
                "iterator",
                "java.util",
                "List",
                "public abstract Iterator<E> iterator()"
            ],
            [
                "contains",
                "java.util",
                "List",
                "public abstract boolean contains(Object arg0)"
            ],
            [
                "set",
                "java.util",
                "List",
                "public abstract E set(int arg0, E arg1)"
            ],
            [
                "removeAll",
                "java.util",
                "Collection",
                "public abstract boolean removeAll(Collection<? extends Object> arg0)"
            ],
            [
                "toArray",
                "java.util",
                "Collection",
                "public default <T> T[] toArray(IntFunction<T[]> arg0)"
            ],
            [
                "containsAll",
                "java.util",
                "Collection",
                "public abstract boolean containsAll(Collection<? extends Object> arg0)"
            ],
            [
                "contains",
                "java.util",
                "Collection",
                "public abstract boolean contains(Object arg0)"
            ],
            [
                "spliterator",
                "java.util",
                "Collection",
                "public default Spliterator<E> spliterator()"
            ],
            [
                "iterator",
                "java.util",
                "Collection",
                "public abstract Iterator<E> iterator()"
            ],
            [
                "size",
                "java.util",
                "Collection",
                "public abstract int size()"
            ],
            [
                "toArray",
                "java.util",
                "Collection",
                "public abstract <T> T[] toArray(T[] arg0)"
            ],
            [
                "addAll",
                "java.util",
                "Collection",
                "public abstract boolean addAll(Collection<? extends E> arg0)"
            ],
            [
                "remove",
                "java.util",
                "Collection",
                "public abstract boolean remove(Object arg0)"
            ],
            [
                "removeIf",
                "java.util",
                "Collection",
                "public default boolean removeIf(Predicate<? super E> arg0)"
            ],
            [
                "stream",
                "java.util",
                "Collection",
                "public default Stream<E> stream()"
            ],
            [
                "equals",
                "java.util",
                "Collection",
                "public abstract boolean equals(Object arg0)"
            ],
            [
                "hashCode",
                "java.util",
                "Collection",
                "public abstract int hashCode()"
            ],
            [
                "isEmpty",
                "java.util",
                "Collection",
                "public abstract boolean isEmpty()"
            ],
            [
                "parallelStream",
                "java.util",
                "Collection",
                "public default Stream<E> parallelStream()"
            ],
            [
                "toArray",
                "java.util",
                "Collection",
                "public abstract Object[] toArray()"
            ],
            [
                "retainAll",
                "java.util",
                "Collection",
                "public abstract boolean retainAll(Collection<? extends Object> arg0)"
            ],
            [
                "add",
                "java.util",
                "Collection",
                "public abstract boolean add(E arg0)"
            ],
            [
                "iterator",
                "java.lang",
                "Iterable",
                "public abstract Iterator<T> iterator()"
            ],
            [
                "spliterator",
                "java.lang",
                "Iterable",
                "public default Spliterator<T> spliterator()"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [
            [
                "graph",
                "org.jgrapht.alg",
                "BellmanFordShortestPath",
                "/**\n * Graph on which shortest paths are searched.\n */\nprotected Graph<V, E> graph;"
            ],
            [
                "startVertex",
                "org.jgrapht.alg",
                "BellmanFordShortestPath",
                "/**\n * Start vertex.\n */\nprotected V startVertex;"
            ]
        ],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 26416,
        "oracle": "graph.containsVertex(startVertex);",
        "oracleType": "PRE",
        "projectName": "jgrapht-core-0.9.2",
        "packageName": "org.jgrapht.alg",
        "className": "DijkstraShortestPath",
        "javadocTag": "@param startVertex the vertex at which the path should start",
        "methodJavadoc": "    /**\n     * Creates and executes a new DijkstraShortestPath algorithm instance. An\n     * instance is only good for a single search; after construction, it can be\n     * accessed to retrieve information about the path found.\n     *\n     * @param graph the graph to be searched\n     * @param startVertex the vertex at which the path should start\n     * @param endVertex the vertex at which the path should end\n     * @param radius limit on weighted path length, or Double.POSITIVE_INFINITY\n     * for unbounded search\n     */",
        "methodSourceCode": "public DijkstraShortestPath(Graph<V, E> graph, V startVertex, V endVertex, double radius){\n    if (!graph.containsVertex(endVertex)) {\n        throw new IllegalArgumentException(\"graph must contain the end vertex\");\n    }\n    ClosestFirstIterator<V, E> iter = new ClosestFirstIterator<V, E>(graph, startVertex, radius);\n    while (iter.hasNext()) {\n        V vertex = iter.next();\n        if (vertex.equals(endVertex)) {\n            createEdgeList(graph, iter, startVertex, endVertex);\n            return;\n        }\n    }\n    path = null;\n}",
        "classJavadoc": "/**\n * An implementation of <a\n * href=\"http://mathworld.wolfram.com/DijkstrasAlgorithm.html\">Dijkstra's\n * shortest path algorithm</a> using <code>ClosestFirstIterator</code>.\n *\n * @author John V. Sichi\n * @since Sep 2, 2003\n */",
        "classSourceCode": "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------------\n * DijkstraShortestPath.java\n * -------------------------\n * (C) Copyright 2003-2008, by John V. Sichi and Contributors.\n *\n * Original Author:  John V. Sichi\n * Contributor(s):   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 02-Sep-2003 : Initial revision (JVS);\n * 29-May-2005 : Make non-static and add radius support (JVS);\n * 07-Jun-2005 : Made generic (CH);\n *\n */\npackage org.jgrapht.alg;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\nimport org.jgrapht.graph.*;\nimport org.jgrapht.traverse.*;\n\n\n/**\n * An implementation of <a\n * href=\"http://mathworld.wolfram.com/DijkstrasAlgorithm.html\">Dijkstra's\n * shortest path algorithm</a> using <code>ClosestFirstIterator</code>.\n *\n * @author John V. Sichi\n * @since Sep 2, 2003\n */\npublic final class DijkstraShortestPath<V, E>\n{\n    private GraphPath<V, E> path;\n\n    /**\n     * Creates and executes a new DijkstraShortestPath algorithm instance. An\n     * instance is only good for a single search; after construction, it can be\n     * accessed to retrieve information about the path found.\n     *\n     * @param graph the graph to be searched\n     * @param startVertex the vertex at which the path should start\n     * @param endVertex the vertex at which the path should end\n     */\n    public DijkstraShortestPath(Graph<V, E> graph,\n        V startVertex,\n        V endVertex)\n    {\n        this(graph, startVertex, endVertex, Double.POSITIVE_INFINITY);\n    }\n\n    /**\n     * Creates and executes a new DijkstraShortestPath algorithm instance. An\n     * instance is only good for a single search; after construction, it can be\n     * accessed to retrieve information about the path found.\n     *\n     * @param graph the graph to be searched\n     * @param startVertex the vertex at which the path should start\n     * @param endVertex the vertex at which the path should end\n     * @param radius limit on weighted path length, or Double.POSITIVE_INFINITY\n     * for unbounded search\n     */\n    public DijkstraShortestPath(\n        Graph<V, E> graph,\n        V startVertex,\n        V endVertex,\n        double radius)\n    {\n        if (!graph.containsVertex(endVertex)) {\n            throw new IllegalArgumentException(\n                \"graph must contain the end vertex\");\n        }\n\n        ClosestFirstIterator<V, E> iter =\n            new ClosestFirstIterator<V, E>(graph, startVertex, radius);\n\n        while (iter.hasNext()) {\n            V vertex = iter.next();\n\n            if (vertex.equals(endVertex)) {\n                createEdgeList(graph, iter, startVertex, endVertex);\n                return;\n            }\n        }\n\n        path = null;\n    }\n\n    /**\n     * Return the edges making up the path found.\n     *\n     * @return List of Edges, or null if no path exists\n     */\n    public List<E> getPathEdgeList()\n    {\n        if (path == null) {\n            return null;\n        } else {\n            return path.getEdgeList();\n        }\n    }\n\n    /**\n     * Return the path found.\n     *\n     * @return path representation, or null if no path exists\n     */\n    public GraphPath<V, E> getPath()\n    {\n        return path;\n    }\n\n    /**\n     * Return the weighted length of the path found.\n     *\n     * @return path length, or Double.POSITIVE_INFINITY if no path exists\n     */\n    public double getPathLength()\n    {\n        if (path == null) {\n            return Double.POSITIVE_INFINITY;\n        } else {\n            return path.getWeight();\n        }\n    }\n\n    /**\n     * Convenience method to find the shortest path via a single static method\n     * call. If you need a more advanced search (e.g. limited by radius, or\n     * computation of the path length), use the constructor instead.\n     *\n     * @param graph the graph to be searched\n     * @param startVertex the vertex at which the path should start\n     * @param endVertex the vertex at which the path should end\n     *\n     * @return List of Edges, or null if no path exists\n     */\n    public static <V, E> List<E> findPathBetween(\n        Graph<V, E> graph,\n        V startVertex,\n        V endVertex)\n    {\n        DijkstraShortestPath<V, E> alg =\n            new DijkstraShortestPath<V, E>(\n                graph,\n                startVertex,\n                endVertex);\n\n        return alg.getPathEdgeList();\n    }\n\n    private void createEdgeList(\n        Graph<V, E> graph,\n        ClosestFirstIterator<V, E> iter,\n        V startVertex,\n        V endVertex)\n    {\n        List<E> edgeList = new ArrayList<E>();\n\n        V v = endVertex;\n\n        while (true) {\n            E edge = iter.getSpanningTreeEdge(v);\n\n            if (edge == null) {\n                break;\n            }\n\n            edgeList.add(edge);\n            v = Graphs.getOppositeVertex(graph, edge, v);\n        }\n\n        Collections.reverse(edgeList);\n        double pathLength = iter.getShortestPathLength(endVertex);\n        path =\n            new GraphPathImpl<V, E>(\n                graph,\n                startVertex,\n                endVertex,\n                edgeList,\n                pathLength);\n    }\n}\n\n// End DijkstraShortestPath.java\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "PartiteRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "RandomGraphHelper",
                "org.jgrapht.experimental"
            ],
            [
                "GraphReader",
                "org.jgrapht.experimental"
            ],
            [
                "DirectedAcyclicGraph",
                "org.jgrapht.experimental.dag"
            ],
            [
                "GraphSquare",
                "org.jgrapht.experimental"
            ],
            [
                "UniformRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "GraphTests",
                "org.jgrapht.experimental"
            ],
            [
                "ApproximationAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "BrownBacktrackColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "GreedyColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "IntArrayGraphAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ExactAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ListenableGraph",
                "org.jgrapht"
            ],
            [
                "ModifiableInteger",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeapNode",
                "org.jgrapht.util"
            ],
            [
                "WeightCombiner",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeap",
                "org.jgrapht.util"
            ],
            [
                "TypeUtil",
                "org.jgrapht.util"
            ],
            [
                "ArrayUnenforcedSet",
                "org.jgrapht.util"
            ],
            [
                "VertexPair",
                "org.jgrapht.util"
            ],
            [
                "MathUtil",
                "org.jgrapht.util"
            ],
            [
                "PrefetchIterator",
                "org.jgrapht.util"
            ],
            [
                "VertexFactory",
                "org.jgrapht"
            ],
            [
                "Graph",
                "org.jgrapht"
            ],
            [
                "GraphPath",
                "org.jgrapht"
            ],
            [
                "UndirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraph",
                "org.jgrapht.graph"
            ],
            [
                "MixedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DefaultGraphMapping",
                "org.jgrapht.graph"
            ],
            [
                "WeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskEdgeSet",
                "org.jgrapht.graph"
            ],
            [
                "Pseudograph",
                "org.jgrapht.graph"
            ],
            [
                "MaskFunctor",
                "org.jgrapht.graph"
            ],
            [
                "GraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractBaseGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "Multigraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultWeightedEdge",
                "org.jgrapht.graph"
            ],
            [
                "ListenableDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeSetFactory",
                "org.jgrapht.graph"
            ],
            [
                "GraphDelegator",
                "org.jgrapht.graph"
            ],
            [
                "DefaultListenableGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedVertexFactory",
                "org.jgrapht.graph"
            ],
            [
                "DefaultEdge",
                "org.jgrapht.graph"
            ],
            [
                "MaskVertexSet",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "IntrusiveEdge",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphPathImpl",
                "org.jgrapht.graph"
            ],
            [
                "Subgraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractGraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedEdgeFactory",
                "org.jgrapht.graph"
            ],
            [
                "SimpleWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "WeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeReversedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "AbstractGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "ListenableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraphPath",
                "org.jgrapht.graph"
            ],
            [
                "ParanoidGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphHelper",
                "org.jgrapht"
            ],
            [
                "Graphs",
                "org.jgrapht"
            ],
            [
                "DirectedGraph",
                "org.jgrapht"
            ],
            [
                "WeightedGraph",
                "org.jgrapht"
            ],
            [
                "HyperCubeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RingGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WheelGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GridGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "ScaleFreeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedBipartiteGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "LinearGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RandomGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGeneratorAdapter",
                "org.jgrapht.generate"
            ],
            [
                "EmptyGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteBipartiteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "StarGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "UndirectedGraph",
                "org.jgrapht"
            ],
            [
                "TopologicalOrderIterator",
                "org.jgrapht.traverse"
            ],
            [
                "CrossComponentIterator",
                "org.jgrapht.traverse"
            ],
            [
                "AbstractGraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "ClosestFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "BreadthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "DepthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "GraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "EdgeFactory",
                "org.jgrapht"
            ],
            [
                "GraphMapping",
                "org.jgrapht"
            ],
            [
                "VertexSetListener",
                "org.jgrapht.event"
            ],
            [
                "EdgeTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "TraversalListener",
                "org.jgrapht.event"
            ],
            [
                "GraphEdgeChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "VertexTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphListener",
                "org.jgrapht.event"
            ],
            [
                "TraversalListenerAdapter",
                "org.jgrapht.event"
            ],
            [
                "ConnectedComponentTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphVertexChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "TarjanLowestCommonAncestor",
                "org.jgrapht.alg"
            ],
            [
                "PrimMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "BlockCutpointGraph",
                "org.jgrapht.alg"
            ],
            [
                "AllDirectedPaths",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPathsIterator",
                "org.jgrapht.alg"
            ],
            [
                "KruskalMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "StrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "VF2State",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2AbstractIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "GraphOrdering",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphicGraphMapping",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2MappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "BronKerboschCliqueFinder",
                "org.jgrapht.alg"
            ],
            [
                "ChromaticNumber",
                "org.jgrapht.alg"
            ],
            [
                "KosarajuStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "DijkstraShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElement",
                "org.jgrapht.alg"
            ],
            [
                "AStarShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordPathElement",
                "org.jgrapht.alg"
            ],
            [
                "FloydWarshallShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "UnionFind",
                "org.jgrapht.alg.util"
            ],
            [
                "AlwaysEqualComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Extension",
                "org.jgrapht.alg.util"
            ],
            [
                "VertexDegreeComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Pair",
                "org.jgrapht.alg.util"
            ],
            [
                "GabowStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "HawickJamesSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "DirectedSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "JohnsonSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TiernanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "UndirectedCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "PatonCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TarjanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "SzwarcfiterLauerSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "BiconnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "ConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "MinSourceSinkCut",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsBlossomShrinking",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveClosure",
                "org.jgrapht.alg"
            ],
            [
                "HopcroftKarpBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "StoerWagnerMinimumCut",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "KuhnMunkresMinimalWeightBipartitePerfectMatching",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveReduction",
                "org.jgrapht.alg"
            ],
            [
                "EulerianCircuit",
                "org.jgrapht.alg"
            ],
            [
                "DirectedNeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "NaiveLcaFinder",
                "org.jgrapht.alg"
            ],
            [
                "MaximumWeightBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "HamiltonianCycle",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "NeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "VertexCovers",
                "org.jgrapht.alg"
            ],
            [
                "CycleDetector",
                "org.jgrapht.alg"
            ],
            [
                "AStarAdmissibleHeuristic",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MinimumSpanningTree",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "WeightedMatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "StrongConnectivityAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MaximumFlowAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "CliqueMinimalSeparatorDecomposition",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordIterator",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElement",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "PushRelabelMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "MaximumFlowAlgorithmBase",
                "org.jgrapht.alg.flow"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "addVertices",
                "org.jgrapht.experimental",
                "RandomGraphHelper",
                "/**\n * .\n *\n * @param target\n * @param vertexFactory\n * @param numVertices\n *\n * @return vertices\n */\n@SuppressWarnings(\"unchecked\")\npublic static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices) {\n    Object[] vertices = new Object[numVertices];\n    for (int i = 0; i < numVertices; ++i) {\n        vertices[i] = vertexFactory.createVertex();\n        target.addVertex(vertices[i]);\n    }\n    return vertices;\n}"
            ],
            [
                "isEmpty",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isEmpty(Graph<V, E> g) {\n    return g.edgeSet().isEmpty();\n}"
            ],
            [
                "isComplete",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isComplete(Graph<V, E> g) {\n    int n = g.vertexSet().size();\n    return g.edgeSet().size() == (n * (n - 1) / 2);\n}"
            ],
            [
                "isConnected",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isConnected(Graph<V, E> g) {\n    int numVertices = g.vertexSet().size();\n    int numEdges = g.edgeSet().size();\n    if (numEdges < (numVertices - 1)) {\n        return false;\n    }\n    if ((numVertices < 2) || (numEdges > ((numVertices - 1) * (numVertices - 2) / 2))) {\n        return true;\n    }\n    Set<V> known = new HashSet<V>();\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = g.vertexSet().iterator().next();\n    // start with node 1\n    queue.add(v);\n    known.add(v);\n    while (!queue.isEmpty()) {\n        v = queue.removeFirst();\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            v = it.next();\n            if (!known.contains(v)) {\n                known.add(v);\n                queue.add(v);\n            }\n        }\n    }\n    return known.size() == numVertices;\n}"
            ],
            [
                "isTree",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isTree(Graph<V, E> g) {\n    return isConnected(g) && (g.edgeSet().size() == (g.vertexSet().size() - 1));\n}"
            ],
            [
                "isBipartite",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isBipartite(Graph<V, E> g) {\n    if ((4 * g.edgeSet().size()) > (g.vertexSet().size() * g.vertexSet().size())) {\n        return false;\n    }\n    if (isEmpty(g)) {\n        return true;\n    }\n    Set<V> unknown = new HashSet<V>(g.vertexSet());\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = unknown.iterator().next();\n    Set<V> odd = new HashSet<V>();\n    queue.add(v);\n    while (!unknown.isEmpty()) {\n        if (queue.isEmpty()) {\n            queue.add(unknown.iterator().next());\n        }\n        v = queue.removeFirst();\n        unknown.remove(v);\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            V n = it.next();\n            if (unknown.contains(n)) {\n                queue.add(n);\n                if (!odd.contains(v)) {\n                    odd.add(n);\n                }\n            } else if (!(odd.contains(v) ^ odd.contains(n))) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
            ],
            [
                "union",
                "org.jgrapht.util",
                "FibonacciHeap",
                "// size\n/**\n * Joins two Fibonacci heaps into a new one. No heap consolidation is\n * performed at this time. The two root lists are simply joined together.\n *\n * <p>Running time: O(1) actual</p>\n *\n * @param h1 first heap\n * @param h2 second heap\n *\n * @return new heap containing h1 and h2\n */\npublic static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2) {\n    FibonacciHeap<T> h = new FibonacciHeap<T>();\n    if ((h1 != null) && (h2 != null)) {\n        h.minNode = h1.minNode;\n        if (h.minNode != null) {\n            if (h2.minNode != null) {\n                h.minNode.right.left = h2.minNode.left;\n                h2.minNode.left.right = h.minNode.right;\n                h.minNode.right = h2.minNode;\n                h2.minNode.left = h.minNode;\n                if (h2.minNode.key < h1.minNode.key) {\n                    h.minNode = h2.minNode;\n                }\n            }\n        } else {\n            h.minNode = h2.minNode;\n        }\n        h.nNodes = h1.nNodes + h2.nNodes;\n    }\n    return h;\n}"
            ],
            [
                "uncheckedCast",
                "org.jgrapht.util",
                "TypeUtil",
                "/**\n * Casts an object to a type.\n *\n * @param o object to be cast\n * @param typeDecl conveys the target type information; the actual value is\n * unused and can be null since this is all just stupid compiler tricks\n *\n * @return the result of the cast\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl) {\n    return (T) o;\n}"
            ],
            [
                "factorial",
                "org.jgrapht.util",
                "MathUtil",
                "public static long factorial(int N) {\n    long multi = 1;\n    for (int i = 1; i <= N; i++) {\n        multi = multi * i;\n    }\n    return multi;\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graphs",
                "/**\n * Creates a new edge and adds it to the specified graph similarly to the\n * {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n *\n * @see Graph#addEdge(Object, Object)\n */\npublic static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    EdgeFactory<V, E> ef = g.getEdgeFactory();\n    E e = ef.createEdge(sourceVertex, targetVertex);\n    // we first create the edge and set the weight to make sure that\n    // listeners will see the correct weight upon addEdge.\n    assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n    ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n    return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new edge and adds it to the specified\n * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return g.addEdge(sourceVertex, targetVertex);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified edge to the graph, including its vertices if not\n * already included.\n *\n * @param targetGraph the graph for which the specified edge to be added.\n * @param sourceGraph the graph in which the specified edge is already\n * present\n * @param edge edge to add\n *\n * @return <tt>true</tt> if the target graph did not already contain the\n * specified edge.\n */\npublic static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge) {\n    V sourceVertex = sourceGraph.getEdgeSource(edge);\n    V targetVertex = sourceGraph.getEdgeTarget(edge);\n    targetGraph.addVertex(sourceVertex);\n    targetGraph.addVertex(targetVertex);\n    return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new weighted edge and adds it to the\n * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n * method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return addEdge(g, sourceVertex, targetVertex, weight);\n}"
            ],
            [
                "addGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all the vertices and all the edges of the specified source graph to\n * the specified destination graph. First all vertices of the source graph\n * are added to the destination graph. Then every edge of the source graph\n * is added to the destination graph. This method returns <code>true</code>\n * if the destination graph has been modified as a result of this operation,\n * otherwise it returns <code>false</code>.\n *\n * <p>The behavior of this operation is undefined if any of the specified\n * graphs is modified while operation is in progress.</p>\n *\n * @param destination the graph to which vertices and edges are added.\n * @param source the graph used as source for vertices and edges to add.\n *\n * @return <code>true</code> if and only if the destination graph has been\n * changed as a result of this operation.\n */\npublic static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source) {\n    boolean modified = addAllVertices(destination, source.vertexSet());\n    modified |= addAllEdges(destination, source, source.edgeSet());\n    return modified;\n}"
            ],
            [
                "addAllEdges",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds a subset of the edges of the specified source graph to the specified\n * destination graph. The behavior of this operation is undefined if either\n * of the graphs is modified while the operation is in progress. {@link\n * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n * be added automatically to the target graph.\n *\n * @param destination the graph to which edges are to be added\n * @param source the graph used as a source for edges to add\n * @param edges the edges to be added\n *\n * @return <tt>true</tt> if this graph changed as a result of the call\n */\npublic static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges) {\n    boolean modified = false;\n    for (E e : edges) {\n        V s = source.getEdgeSource(e);\n        V t = source.getEdgeTarget(e);\n        destination.addVertex(s);\n        destination.addVertex(t);\n        modified |= destination.addEdge(s, t, e);\n    }\n    return modified;\n}"
            ],
            [
                "addAllVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all of the specified vertices to the destination graph. The behavior\n * of this operation is undefined if the specified vertex collection is\n * modified while the operation is in progress. This method will invoke the\n * {@link Graph#addVertex(Object)} method.\n *\n * @param destination the graph to which edges are to be added\n * @param vertices the vertices to be added to the graph.\n *\n * @return <tt>true</tt> if graph changed as a result of the call\n *\n * @throws NullPointerException if the specified vertices contains one or\n * more null vertices, or if the specified vertex collection is <tt>\n * null</tt>.\n *\n * @see Graph#addVertex(Object)\n */\npublic static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices) {\n    boolean modified = false;\n    for (V v : vertices) {\n        modified |= destination.addVertex(v);\n    }\n    return modified;\n}"
            ],
            [
                "neighborListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the neighbors of a specified vertex.\n * If the graph is a multigraph vertices may appear more than once in the\n * returned list.\n *\n * @param g the graph to look for neighbors in.\n * @param vertex the vertex to get the neighbors of.\n *\n * @return a list of the vertices that are the neighbors of the specified\n * vertex.\n */\npublic static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex) {\n    List<V> neighbors = new ArrayList<V>();\n    for (E e : g.edgesOf(vertex)) {\n        neighbors.add(getOppositeVertex(g, e, vertex));\n    }\n    return neighbors;\n}"
            ],
            [
                "predecessorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct predecessors of a\n * specified vertex. If the graph is a multigraph, vertices may appear more\n * than once in the returned list.\n *\n * @param g the graph to look for predecessors in.\n * @param vertex the vertex to get the predecessors of.\n *\n * @return a list of the vertices that are the direct predecessors of the\n * specified vertex.\n */\npublic static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> predecessors = new ArrayList<V>();\n    Set<? extends E> edges = g.incomingEdgesOf(vertex);\n    for (E e : edges) {\n        predecessors.add(getOppositeVertex(g, e, vertex));\n    }\n    return predecessors;\n}"
            ],
            [
                "successorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct successors of a specified\n * vertex. If the graph is a multigraph vertices may appear more than once\n * in the returned list.\n *\n * @param g the graph to look for successors in.\n * @param vertex the vertex to get the successors of.\n *\n * @return a list of the vertices that are the direct successors of the\n * specified vertex.\n */\npublic static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> successors = new ArrayList<V>();\n    Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n    for (E e : edges) {\n        successors.add(getOppositeVertex(g, e, vertex));\n    }\n    return successors;\n}"
            ],
            [
                "undirectedGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns an undirected view of the specified graph. If the specified graph\n * is directed, returns an undirected view of it. If the specified graph is\n * already undirected, just returns it.\n *\n * @param g the graph for which an undirected view is to be returned.\n *\n * @return an undirected view of the specified graph, if it is directed, or\n * or the specified graph itself if it is already undirected.\n *\n * @throws IllegalArgumentException if the graph is neither DirectedGraph\n * nor UndirectedGraph.\n *\n * @see AsUndirectedGraph\n */\npublic static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n    } else if (g instanceof UndirectedGraph<?, ?>) {\n        return (UndirectedGraph<V, E>) g;\n    } else {\n        throw new IllegalArgumentException(\"Graph must be either DirectedGraph or UndirectedGraph\");\n    }\n}"
            ],
            [
                "testIncidence",
                "org.jgrapht",
                "Graphs",
                "/**\n * Tests whether an edge is incident to a vertex.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return true iff e is incident on v\n */\npublic static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v) {\n    return (g.getEdgeSource(e).equals(v)) || (g.getEdgeTarget(e).equals(v));\n}"
            ],
            [
                "getOppositeVertex",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the vertex opposite another vertex across an edge.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return vertex opposite to v across e\n */\npublic static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v) {\n    V source = g.getEdgeSource(e);\n    V target = g.getEdgeTarget(e);\n    if (v.equals(source)) {\n        return target;\n    } else if (v.equals(target)) {\n        return source;\n    } else {\n        throw new IllegalArgumentException(\"no such vertex: \" + v.toString());\n    }\n}"
            ],
            [
                "getPathVertexList",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the list of vertices visited by a path.\n *\n * @param path path of interest\n *\n * @return corresponding vertex list\n */\npublic static <V, E> List<V> getPathVertexList(GraphPath<V, E> path) {\n    Graph<V, E> g = path.getGraph();\n    List<V> list = new ArrayList<V>();\n    V v = path.getStartVertex();\n    list.add(v);\n    for (E e : path.getEdgeList()) {\n        v = getOppositeVertex(g, e, v);\n        list.add(v);\n    }\n    return list;\n}"
            ],
            [
                "range",
                "org.jgrapht.generate",
                "SimpleWeightedGraphMatrixGenerator",
                "///////////////////////////////////////////////////////////////////////////////////////////////\npublic static int[] range(final int from, final int to) {\n    int[] range = new int[to - from];\n    for (int i = from; i < to; ++i) {\n        range[i - from] = i;\n    }\n    return range;\n}"
            ],
            [
                "createGraphSpecifics",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "// -------------------------------------------------------------------------\n/**\n * @param <V>\n * @param <E>\n * @param g\n *\n * @return TODO Document me\n */\nstatic <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new DirectedSpecifics<V, E>((DirectedGraph<V, E>) g);\n    } else {\n        return new UndirectedSpecifics<V, E>(g);\n    }\n}"
            ],
            [
                "findGreedyChromaticNumber",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds the number of colors required for a greedy coloring of the graph.\n *\n * @param g an undirected graph to find the chromatic number of\n *\n * @return integer the approximate chromatic number from the greedy\n * algorithm\n */\npublic static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g) {\n    Map<Integer, Set<V>> coloredGroups = findGreedyColoredGroups(g);\n    return coloredGroups.keySet().size();\n}"
            ],
            [
                "findGreedyColoredGroups",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds a greedy coloring of the graph.\n *\n * @param g an undirected graph for which to find the coloring\n */\npublic static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g) {\n    // A copy of the graph is made, so that elements of the graph may be\n    // removed to carry out the algorithm\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // The Vertices will be sorted in decreasing order by degree, so that\n    // higher degree vertices have priority to be colored first\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    List<V> sortedVertices = new LinkedList<V>(sg.vertexSet());\n    Collections.sort(sortedVertices, comp);\n    Collections.reverse(sortedVertices);\n    int color;\n    // create a map which will hold color as key and Set<V> as value\n    Map<Integer, Set<V>> coloredGroups = new HashMap<Integer, Set<V>>();\n    // We'll attempt to color each vertex with a single color each\n    // iteration, and these vertices will be removed from the graph at the\n    // end of each iteration\n    for (color = 0; sg.vertexSet().size() > 0; color++) {\n        // This set will contain vertices that are colored with the\n        // current color of this iteration\n        Set<V> currentColor = new HashSet<V>();\n        for (Iterator<V> iter = sortedVertices.iterator(); iter.hasNext(); ) {\n            V v = iter.next();\n            // Add new vertices to be colored as long as they are not\n            // adjacent with any other vertex that has already been colored\n            // with the current color\n            boolean flag = true;\n            for (Iterator<V> innerIter = currentColor.iterator(); innerIter.hasNext(); ) {\n                V temp = innerIter.next();\n                if (sg.containsEdge(temp, v)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                currentColor.add(v);\n                iter.remove();\n            }\n        }\n        // Add all these vertices as a group for this color\n        coloredGroups.put(color, currentColor);\n        // Remove vertices from the graph and then repeat the process for\n        // the next iteration\n        sg.removeAllVertices(currentColor);\n    }\n    return coloredGroups;\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "BellmanFordShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by hops, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    BellmanFordShortestPath<V, E> alg = new BellmanFordShortestPath<V, E>(graph, startVertex);\n    return alg.getPathEdgeList(endVertex);\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "DijkstraShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by radius, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    DijkstraShortestPath<V, E> alg = new DijkstraShortestPath<V, E>(graph, startVertex, endVertex);\n    return alg.getPathEdgeList();\n}"
            ],
            [
                "of",
                "org.jgrapht.alg.util",
                "Pair",
                "/**\n * Creates new pair of elements pulling of the necessity to provide\n * corresponding types of the elements supplied\n *\n * @param a first element\n * @param b second element\n *\n * @return new pair\n */\npublic static <A, B> Pair<A, B> of(A a, B b) {\n    return new Pair<A, B>(a, b);\n}"
            ],
            [
                "isEulerian",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will check whether the graph passed in is Eulerian or not.\n *\n * @param g The graph to be checked\n *\n * @return true for Eulerian and false for non-Eulerian\n */\npublic static <V, E> boolean isEulerian(UndirectedGraph<V, E> g) {\n    // If the graph is not connected, then no Eulerian circuit exists\n    if (!(new ConnectivityInspector<V, E>(g)).isGraphConnected()) {\n        return false;\n    }\n    // A graph is Eulerian if and only if all vertices have even degree\n    // So, this code will check for that\n    Iterator<V> iter = g.vertexSet().iterator();\n    while (iter.hasNext()) {\n        V v = iter.next();\n        if ((g.degreeOf(v) % 2) == 1) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "getEulerianCircuitVertices",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will return a list of vertices which represents the Eulerian\n * circuit of the graph.\n *\n * @param g The graph to find an Eulerian circuit\n *\n * @return null if no Eulerian circuit exists, or a list of vertices\n * representing the Eulerian circuit if one does exist\n */\npublic static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g) {\n    // If the graph is not Eulerian then just return a null since no\n    // Eulerian circuit exists\n    if (!isEulerian(g)) {\n        return null;\n    }\n    // The circuit will be represented by a linked list\n    List<V> path = new LinkedList<V>();\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    path.add(sg.vertexSet().iterator().next());\n    // Algorithm for finding an Eulerian circuit Basically this will find an\n    // arbitrary circuit, then it will find another arbitrary circuit until\n    // every edge has been traversed\n    while (sg.edgeSet().size() > 0) {\n        V v = null;\n        // Find a vertex which has an edge that hasn't been traversed yet,\n        // and keep its index position in the circuit list\n        int index = 0;\n        for (Iterator<V> iter = path.iterator(); iter.hasNext(); index++) {\n            v = iter.next();\n            if (sg.degreeOf(v) > 0) {\n                break;\n            }\n        }\n        // Finds an arbitrary circuit of the current vertex and\n        // appends this into the circuit list\n        while (sg.degreeOf(v) > 0) {\n            for (Iterator<V> iter = sg.vertexSet().iterator(); iter.hasNext(); ) {\n                V temp = iter.next();\n                if (sg.containsEdge(v, temp)) {\n                    path.add(index, temp);\n                    sg.removeEdge(v, temp);\n                    v = temp;\n                    break;\n                }\n            }\n        }\n    }\n    return path;\n}"
            ],
            [
                "getApproximateOptimalForCompleteGraph",
                "org.jgrapht.alg",
                "HamiltonianCycle",
                "/**\n * This method will return an approximate minimal traveling salesman tour\n * (hamiltonian cycle). This algorithm requires that the graph be complete\n * and the triangle inequality exists (if x,y,z are vertices then\n * d(x,y)+d(y,z) &lt; d(x,z) for all x,y,z) then this algorithm will\n * guarantee a hamiltonian cycle such that the total weight of the cycle is\n * less than or equal to double the total weight of the optimal hamiltonian\n * cycle. The optimal solution is NP-complete, so this is a decent\n * approximation that runs in polynomial time.\n *\n * @param <V>\n * @param <E>\n * @param g is the graph to find the optimal tour for.\n *\n * @return The optimal tour as a list of vertices.\n */\npublic static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g) {\n    List<V> vertices = new LinkedList<V>(g.vertexSet());\n    // If the graph is not complete then return null since this algorithm\n    // requires the graph be complete\n    if ((vertices.size() * (vertices.size() - 1) / 2) != g.edgeSet().size()) {\n        return null;\n    }\n    List<V> tour = new LinkedList<V>();\n    // Each iteration a new vertex will be added to the tour until all\n    // vertices have been added\n    while (tour.size() != g.vertexSet().size()) {\n        boolean firstEdge = true;\n        double minEdgeValue = 0;\n        int minVertexFound = 0;\n        int vertexConnectedTo = 0;\n        // A check will be made for the shortest edge to a vertex not within\n        // the tour and that new vertex will be added to the vertex\n        for (int i = 0; i < tour.size(); i++) {\n            V v = tour.get(i);\n            for (int j = 0; j < vertices.size(); j++) {\n                double weight = g.getEdgeWeight(g.getEdge(v, vertices.get(j)));\n                if (firstEdge || (weight < minEdgeValue)) {\n                    firstEdge = false;\n                    minEdgeValue = weight;\n                    minVertexFound = j;\n                    vertexConnectedTo = i;\n                }\n            }\n        }\n        tour.add(vertexConnectedTo, vertices.get(minVertexFound));\n        vertices.remove(minVertexFound);\n    }\n    return tour;\n}"
            ],
            [
                "find2ApproximationCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a 2-approximation for a minimal vertex cover of the specified\n * graph. The algorithm promises a cover that is at most double the size of\n * a minimal cover. The algorithm takes O(|E|) time.\n *\n * <p>For more details see Jenny Walter, CMPU-240: Lecture notes for\n * Language Theory and Computation, Fall 2002, Vassar College, <a\n * href=\"http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf\">\n * http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf</a>.\n * </p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G'=(V',E') <-- G(V,E)\n    Subgraph<V, E, Graph<V, E>> sg = new Subgraph<V, E, Graph<V, E>>(g, null, null);\n    // while E' is non-empty\n    while (sg.edgeSet().size() > 0) {\n        // let (u,v) be an arbitrary edge of E'\n        E e = sg.edgeSet().iterator().next();\n        // C <-- C U {u,v}\n        V u = g.getEdgeSource(e);\n        V v = g.getEdgeTarget(e);\n        cover.add(u);\n        cover.add(v);\n        // remove from E' every edge incident on either u or v\n        sg.removeVertex(u);\n        sg.removeVertex(v);\n    }\n    // return C\n    return cover;\n}"
            ],
            [
                "findGreedyCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a greedy approximation for a minimal vertex cover of a specified\n * graph. At each iteration, the algorithm picks the vertex with the highest\n * degree and adds it to the cover, until all edges are covered.\n *\n * <p>The algorithm works on undirected graphs, but can also work on\n * directed graphs when their edge-directions are ignored. To ignore edge\n * directions you can use {@link org.jgrapht.Graphs#undirectedGraph(Graph)}\n * or {@link org.jgrapht.graph.AsUndirectedGraph}.</p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G' <-- G\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // compare vertices in descending order of degree\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    // while G' != {}\n    while (sg.edgeSet().size() > 0) {\n        // v <-- vertex with maximum degree in G'\n        V v = Collections.max(sg.vertexSet(), comp);\n        // C <-- C U {v}\n        cover.add(v);\n        // remove from G' every edge incident on v, and v itself\n        sg.removeVertex(v);\n    }\n    return cover;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "BEST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int BEST_ORDER = 0;"
            ],
            [
                "NATURAL_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int NATURAL_ORDER = 1;"
            ],
            [
                "SMALLEST_DEGREE_LAST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;"
            ],
            [
                "LARGEST_SATURATION_FIRST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;"
            ],
            [
                "DEFAULT_EDGE_WEIGHT",
                "org.jgrapht",
                "WeightedGraph",
                "/**\n * The default weight for an edge.\n */\npublic static double DEFAULT_EDGE_WEIGHT = 1.0;"
            ],
            [
                "HUB_VERTEX",
                "org.jgrapht.generate",
                "WheelGraphGenerator",
                "/**\n * Role for the hub vertex.\n */\npublic static final String HUB_VERTEX = \"Hub Vertex\";"
            ],
            [
                "CORNER_VERTEX",
                "org.jgrapht.generate",
                "GridGraphGenerator",
                "/**\n * Role for the vertices at the corners.\n */\npublic static final String CORNER_VERTEX = \"Corner Vertex\";"
            ],
            [
                "START_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the first vertex generated.\n */\npublic static final String START_VERTEX = \"Start Vertex\";"
            ],
            [
                "END_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the last vertex generated.\n */\npublic static final String END_VERTEX = \"End Vertex\";"
            ],
            [
                "CENTER_VERTEX",
                "org.jgrapht.generate",
                "StarGraphGenerator",
                "public static final String CENTER_VERTEX = \"Center Vertex\";"
            ],
            [
                "SENTINEL",
                "org.jgrapht.traverse",
                "DepthFirstIterator",
                "/**\n * Sentinel object. Unfortunately, we can't use null, because ArrayDeque\n * won't accept those. And we don't want to rely on the caller to provide a\n * sentinel object for us. So we have to play typecasting games.\n */\npublic static final Object SENTINEL = new Object();"
            ],
            [
                "BEFORE_EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge added event. This event is fired before an edge is added to a\n * graph.\n */\npublic static final int BEFORE_EDGE_ADDED = 21;"
            ],
            [
                "BEFORE_EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge removed event. This event is fired before an edge is removed\n * from a graph.\n */\npublic static final int BEFORE_EDGE_REMOVED = 22;"
            ],
            [
                "EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge added event. This event is fired after an edge is added to a graph.\n */\npublic static final int EDGE_ADDED = 23;"
            ],
            [
                "EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge removed event. This event is fired after an edge is removed from a\n * graph.\n */\npublic static final int EDGE_REMOVED = 24;"
            ],
            [
                "CONNECTED_COMPONENT_STARTED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal started event.\n */\npublic static final int CONNECTED_COMPONENT_STARTED = 31;"
            ],
            [
                "CONNECTED_COMPONENT_FINISHED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal finished event.\n */\npublic static final int CONNECTED_COMPONENT_FINISHED = 32;"
            ],
            [
                "BEFORE_VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex added event. This event is fired before a vertex is added\n * to a graph.\n */\npublic static final int BEFORE_VERTEX_ADDED = 11;"
            ],
            [
                "BEFORE_VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex removed event. This event is fired before a vertex is\n * removed from a graph.\n */\npublic static final int BEFORE_VERTEX_REMOVED = 12;"
            ],
            [
                "VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex added event. This event is fired after a vertex is added to a\n * graph.\n */\npublic static final int VERTEX_ADDED = 13;"
            ],
            [
                "VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex removed event. This event is fired after a vertex is removed from\n * a graph.\n */\npublic static final int VERTEX_REMOVED = 14;"
            ],
            [
                "NULL_NODE",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "public static final int NULL_NODE = -1;"
            ],
            [
                "DEBUG",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected static final boolean DEBUG = false;"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg",
                "EdmondsKarpMaximumFlow",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 0.000000001;"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveClosure",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveClosure INSTANCE = new TransitiveClosure();"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveReduction",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveReduction INSTANCE = new TransitiveReduction();"
            ],
            [
                "NEGATIVE_UNDIRECTED_EDGE",
                "org.jgrapht.alg",
                "BellmanFordIterator",
                "/**\n * Error message.\n */\nprotected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg.flow",
                "MaximumFlowAlgorithmBase",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 1e-9;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [
            [
                "graph",
                "org.jgrapht.Graph",
                "Graph<V, E>"
            ],
            [
                "startVertex",
                "",
                "V"
            ],
            [
                "endVertex",
                "",
                "V"
            ],
            [
                "radius",
                "",
                "double"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "getPathEdgeList",
                "org.jgrapht.alg",
                "DijkstraShortestPath",
                "/**\n * Return the edges making up the path found.\n *\n * @return List of Edges, or null if no path exists\n */\npublic List<E> getPathEdgeList() {\n    if (path == null) {\n        return null;\n    } else {\n        return path.getEdgeList();\n    }\n}"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "getPath",
                "org.jgrapht.alg",
                "DijkstraShortestPath",
                "/**\n * Return the path found.\n *\n * @return path representation, or null if no path exists\n */\npublic GraphPath<V, E> getPath() {\n    return path;\n}"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "getPathLength",
                "org.jgrapht.alg",
                "DijkstraShortestPath",
                "/**\n * Return the weighted length of the path found.\n *\n * @return path length, or Double.POSITIVE_INFINITY if no path exists\n */\npublic double getPathLength() {\n    if (path == null) {\n        return Double.POSITIVE_INFINITY;\n    } else {\n        return path.getWeight();\n    }\n}"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "getEdgeTarget",
                "org.jgrapht",
                "Graph",
                "public abstract V getEdgeTarget(E arg0)"
            ],
            [
                "edgeSet",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> edgeSet()"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graph",
                "public abstract E addEdge(V arg0, V arg1)"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean addEdge(V arg0, V arg1, E arg2)"
            ],
            [
                "containsEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean containsEdge(E arg0)"
            ],
            [
                "getEdgeFactory",
                "org.jgrapht",
                "Graph",
                "public abstract EdgeFactory<V, E> getEdgeFactory()"
            ],
            [
                "removeAllVertices",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeAllVertices(Collection<? extends V> arg0)"
            ],
            [
                "getEdge",
                "org.jgrapht",
                "Graph",
                "public abstract E getEdge(V arg0, V arg1)"
            ],
            [
                "containsEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean containsEdge(V arg0, V arg1)"
            ],
            [
                "removeAllEdges",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeAllEdges(Collection<? extends E> arg0)"
            ],
            [
                "vertexSet",
                "org.jgrapht",
                "Graph",
                "public abstract Set<V> vertexSet()"
            ],
            [
                "removeEdge",
                "org.jgrapht",
                "Graph",
                "public abstract E removeEdge(V arg0, V arg1)"
            ],
            [
                "getEdgeSource",
                "org.jgrapht",
                "Graph",
                "public abstract V getEdgeSource(E arg0)"
            ],
            [
                "removeVertex",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeVertex(V arg0)"
            ],
            [
                "addVertex",
                "org.jgrapht",
                "Graph",
                "public abstract boolean addVertex(V arg0)"
            ],
            [
                "edgesOf",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> edgesOf(V arg0)"
            ],
            [
                "containsVertex",
                "org.jgrapht",
                "Graph",
                "public abstract boolean containsVertex(V arg0)"
            ],
            [
                "removeAllEdges",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> removeAllEdges(V arg0, V arg1)"
            ],
            [
                "getAllEdges",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> getAllEdges(V arg0, V arg1)"
            ],
            [
                "getEdgeWeight",
                "org.jgrapht",
                "Graph",
                "public abstract double getEdgeWeight(E arg0)"
            ],
            [
                "removeEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeEdge(E arg0)"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    }
]