[ {
  "id" : 4183,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.graph",
  "className" : "Graph",
  "javadocTag" : "@throws IdAlreadyInUseException If an edge with the same id already exists and strict\n            checking is enabled.",
  "methodJavadoc" : "    /**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param toIndex\n\t *            The first node index\n\t * @param fromIndex\n\t *            The second node index\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */",
  "methodSourceCode" : "<T extends Edge> T addEdge(String id, int fromIndex, int toIndex, boolean directed) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException;",
  "classJavadoc" : "/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.graph;\n\nimport java.io.IOException;\n\nimport org.graphstream.stream.AttributeSink;\nimport org.graphstream.stream.ElementSink;\nimport org.graphstream.stream.GraphParseException;\nimport org.graphstream.stream.Pipe;\nimport org.graphstream.stream.file.FileSink;\nimport org.graphstream.stream.file.FileSource;\nimport org.graphstream.ui.view.Viewer;\n\n\n/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */\npublic interface Graph extends Element, Pipe, Iterable<Node>, Structure {\n\t// Access\n\n\t/**\n\t * Get a node by its identifier. This method is implicitly generic and\n\t * returns something which extends Node. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param id\n\t *            Identifier of the node to find.\n\t * @return The searched node or null if not found.\n\t */\n\t<T extends Node> T getNode(String id);\n\n\t/**\n\t * Get an edge by its identifier. This method is implicitly generic and\n\t * returns something which extends Edge. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param id\n\t *            Identifier of the edge to find.\n\t * @return The searched edge or null if not found.\n\t */\n\t<T extends Edge> T getEdge(String id);\n\n\t/**\n\t * The factory used to create node instances. The factory can be changed to\n\t * refine the node class generated for this graph.\n\t * \n\t * @see #setNodeFactory(NodeFactory)\n\t * @see #edgeFactory()\n\t */\n\tNodeFactory<? extends Node> nodeFactory();\n\n\t/**\n\t * The factory used to create edge instances. The factory can be changed to\n\t * refine the edge class generated for this graph.\n\t * \n\t * @see #setEdgeFactory(EdgeFactory)\n\t * @see #nodeFactory()\n\t */\n\tEdgeFactory<? extends Edge> edgeFactory();\n\n\t/**\n\t * Is strict checking enabled? If strict checking is enabled the graph\n\t * checks for name space conflicts (e.g. insertion of two nodes with the\n\t * same name), removal of non-existing elements, use of non existing\n\t * elements (create an edge between two non existing nodes). Graph\n\t * implementations are free to respect strict checking or not.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isStrict();\n\n\t/**\n\t * Is the automatic creation of missing elements enabled?. If strict\n\t * checking is disabled and auto-creation is enabled, when an edge is\n\t * created and one or two of its nodes are not already present in the graph,\n\t * the nodes are automatically created.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isAutoCreationEnabled();\n\n\t/**\n\t * If true, when accessing an attribute that does not exist (or is not of\n\t * the expected type), a {@link NullAttributeException} is thrown. Else null\n\t * is returned.\n\t * \n\t * @return True if exceptions must be thrown when accessing a null\n\t *         attribute.\n\t */\n\tboolean nullAttributesAreErrors();\n\n\t/**\n\t * The current step.\n\t * \n\t * @return The step.\n\t */\n\tdouble getStep();\n\n\t// Command\n\n\t/**\n\t * Should a {@link NullAttributeException} be thrown when one tries to\n\t * access a non existing attribute, or an attribute whose type is not the\n\t * expected one?.\n\t * \n\t * @param on\n\t *            if true, exceptions will be thrown when accessing a non\n\t *            existing attribute.\n\t */\n\tvoid setNullAttributesAreErrors(boolean on);\n\n\t/**\n\t * Set the node factory used to create nodes.\n\t * \n\t * @param nf\n\t *            the new NodeFactory\n\t */\n\tvoid setNodeFactory(NodeFactory<? extends Node> nf);\n\n\t/**\n\t * Set the edge factory used to create edges.\n\t * \n\t * @param ef\n\t *            the new EdgeFactory\n\t */\n\tvoid setEdgeFactory(EdgeFactory<? extends Edge> ef);\n\n\t/**\n\t * Enable or disable strict checking.\n\t * \n\t * @see #isStrict()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setStrict(boolean on);\n\n\t/**\n\t * Enable or disable the automatic creation of missing elements.\n\t * \n\t * @see #isAutoCreationEnabled()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setAutoCreate(boolean on);\n\n\t// Graph construction\n\n\t/**\n\t * Empty the graph completely by removing any references to nodes or edges.\n\t * Every attribute is also removed. However, listeners are kept.\n\t * \n\t * @see #clearSinks()\n\t */\n\tvoid clear();\n\n\t/**\n\t * Add a node in the graph.\n\t * <p>\n\t * This acts as a factory, creating the node instance automatically (and\n\t * eventually using the node factory provided). An event is generated toward\n\t * the listeners. If strict checking is enabled, and a node already exists\n\t * with this identifier, an\n\t * {@link org.graphstream.graph.IdAlreadyInUseException} is raised. Else the\n\t * error is silently ignored and the already existing node is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.addNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            Arbitrary and unique string identifying the node.\n\t * @return The created node (or the already existing node).\n\t * @throws IdAlreadyInUseException\n\t *             If strict checking is enabled the identifier is already used.\n\t */\n\t<T extends Node> T addNode(String id) throws IdAlreadyInUseException;\n\n\t/**\n\t * Remove a node using its identifier.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            The unique identifier of the node to remove.\n\t * @return The removed node. If strict checking is disabled, it can return\n\t *         null if the node to remove does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no node matches the given identifier and strict checking\n\t *             is enabled.\n\t */\n\t<T extends Node> T removeNode(String id) throws ElementNotFoundException;\n\n\t/**\n\t * Adds an undirected edge between nodes.\n\t * \n\t * <p>\n\t * The behavior of this method depends on many conditions. It can be\n\t * summarized as follows.\n\t * </p>\n\t * \n\t * <p>\n\t * First of all, the method checks if the graph already contains an edge\n\t * with the same id. If this is the case and strict checking is enabled,\n\t * {@code IdAlreadyInUseException} is thrown. If the strict checking is\n\t * disabled the method returns a reference to the existing edge if it has\n\t * endpoints {@code node1} and {@code node2} (in the same order if the edge\n\t * is directed) or {@code null} otherwise.\n\t * </p>\n\t * \n\t * <p>\n\t * In the case when the graph does not contain an edge with the same id, the\n\t * method checks if {@code node1} and {@code node2} exist. If one or both of\n\t * them do not exist, and strict checking is enabled, {@code\n\t * ElementNotFoundException} is thrown. Otherwise if auto-creation is\n\t * disabled, the method returns {@code null}. If auto-creation is enabled,\n\t * the method creates the missing endpoints.\n\t * \n\t * <p>\n\t * When the edge id is not already in use and the both endpoints exist (or\n\t * created), the edge can still be rejected. It may happen for example when\n\t * it connects two already connected nodes in a single graph. If the edge is\n\t * rejected, the method throws {@code EdgeRejectedException} if strict\n\t * checking is enabled or returns {@code null} otherwise. Finally, if the\n\t * edge is accepted, it is created using the corresponding edge factory and\n\t * a reference to it is returned.\n\t * \n\t * <p>\n\t * An edge creation event is sent toward the listeners. If new nodes are\n\t * created, the corresponding events are also sent to the listeners.\n\t * </p>\n\t * \n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.addEdge(&quot;...&quot;, &quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * \n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t */\n\t<T extends Edge> T addEdge(String id, String node1, String node2)\n\t\t\tthrows IdAlreadyInUseException, ElementNotFoundException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)}, but this edge can be\n\t * directed between the two given nodes. If directed, the edge goes in the\n\t * 'from' -&gt; 'to' direction. An event is sent toward the listeners.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, String from, String to,\n\t\t\tboolean directed) throws IdAlreadyInUseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Remove an edge given the identifiers of its two endpoints.\n\t * <p>\n\t * If the edge is directed it is removed only if its source and destination\n\t * nodes are identified by 'from' and 'to' respectively. If the graph is a\n\t * multi-graph and there are several edges between the two nodes, one of the\n\t * edges at random is removed. An event is sent toward the listeners. If\n\t * strict checking is enabled and at least one of the two given nodes does\n\t * not exist or if they are not connected, a not found exception is raised.\n\t * Else the error is silently ignored, and null is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param from\n\t *            The origin node identifier to select the edge.\n\t * @param to\n\t *            The destination node identifier to select the edge.\n\t * @return The removed edge, or null if strict checking is disabled and at\n\t *         least one of the two given nodes does not exist or there is no\n\t *         edge between them\n\t * @throws ElementNotFoundException\n\t *             If the 'from' or 'to' node is not registered in the graph or\n\t *             not connected and strict checking is enabled.\n\t */\n\t<T extends Edge> T removeEdge(String from, String to)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge knowing its identifier. An event is sent toward the\n\t * listeners. If strict checking is enabled and the edge does not exist,\n\t * {@code ElementNotFoundException} is raised. Otherwise the error is\n\t * silently ignored and null is returned.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Identifier of the edge to remove.\n\t * @return The removed edge, or null if strict checking is disabled and the\n\t *         edge does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no edge matches the identifier and strict checking is\n\t *             enabled.\n\t */\n\t<T extends Edge> T removeEdge(String id) throws ElementNotFoundException;\n\n\t/**\n\t * <p>\n\t * Since dynamic graphs are based on discrete event modifications, the\n\t * notion of step is defined to simulate elapsed time between events. So a\n\t * step is a event that occurs in the graph, it does not modify it but it\n\t * gives a kind of timestamp that allows the tracking of the progress of the\n\t * graph over the time.\n\t * </p>\n\t * <p>\n\t * This kind of event is useful for dynamic algorithms that listen to the\n\t * dynamic graph and need to measure the time in the graph's evolution.\n\t * </p>\n\t * \n\t * @param time\n\t *            A numerical value that may give a timestamp to track the\n\t *            evolution of the graph over the time.\n\t */\n\tvoid stepBegins(double time);\n\n\t// Source\n\t// XXX do we put the iterable attributeSinks and elementSinks in Source ?\n\n\t/**\n\t * Returns an \"iterable\" of {@link AttributeSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the set of {@link AttributeSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<AttributeSink> attributeSinks();\n\n\t/**\n\t * Returns an \"iterable\" of {@link ElementSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the list of {@link ElementSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<ElementSink> elementSinks();\n\n\t// Utility shortcuts (should be mixins or traits, what are you doing Mr Java\n\t// ?)\n\t// XXX use a Readable/Writable/Displayable interface for this ?\n\n\t/**\n\t * Utility method to read a graph. This method tries to identify the graph\n\t * format by itself and instantiates the corresponding reader automatically.\n\t * If this process fails, a NotFoundException is raised.\n\t * \n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognized.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input output error occurs during the graph reading.\n\t */\n\tvoid read(String filename) throws IOException, GraphParseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Utility method to read a graph using the given reader.\n\t * \n\t * @param input\n\t *            An appropriate reader for the filename.\n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognised.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph reading.\n\t */\n\tvoid read(FileSource input, String filename) throws IOException,\n\t\t\tGraphParseException;\n\n\t/**\n\t * Utility method to write a graph in DGS format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(String filename) throws IOException;\n\n\t/**\n\t * Utility method to write a graph in the chosen format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @param output\n\t *            The output format to use.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(FileSink output, String filename) throws IOException;\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but may be limited. This method\n\t * automatically launch a graph layout algorithm in its own thread to\n\t * compute best node positions.\n\t * \n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display(boolean )\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display();\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but is very limited.\n\t * \n\t * @param autoLayout\n\t *            If true a layout algorithm is launched in its own thread to\n\t *            compute best node positions.\n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display()\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display(boolean autoLayout);\n\n\t// New methods\n\n\t/**\n\t * Get a node by its index. This method is implicitly generic and returns\n\t * something which extends Node. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param index\n\t *            Index of the node to find.\n\t * @return The node with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             If the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T getNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Get an edge by its index. This method is implicitly generic and returns\n\t * something which extends Edge. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param index\n\t *            The index of the edge to find.\n\t * @return The edge with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is less than 0 or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param index1\n\t *            The first node index\n\t * @param index2\n\t *            The second node index\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int index1, int index2)\n\t\t\tthrows IndexOutOfBoundsException, IdAlreadyInUseException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param toIndex\n\t *            The first node index\n\t * @param fromIndex\n\t *            The second node index\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int fromIndex, int toIndex,\n\t\t\tboolean directed) throws IndexOutOfBoundsException,\n\t\t\tIdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the node references are\n\t * given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node\n\t * @param node2\n\t *            The second node\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node node1, Node node2)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the node\n\t * references are given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param from\n\t *            The first node\n\t * @param to\n\t *            The second node\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Removes an edge with a given index. An event is sent toward the\n\t * listeners.\n\t * \n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.removeEdge(i);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the edge to be removed.\n\t * @return The removed edge\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getEdgeCount() - 1}\n\t */\n\t<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but the nodes are identified by their\n\t * indices.\n\t * \n\t * @param fromIndex\n\t *            the index of the source node\n\t * @param toIndex\n\t *            the index of the target node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws IndexOutOfBoundsException\n\t *             If one of the node indices is negative or greater than\n\t *             {@code getNodeCount() - 1}.\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(int fromIndex, int toIndex)\n\t\t\tthrows IndexOutOfBoundsException, ElementNotFoundException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but node references are given instead\n\t * of node identifiers.\n\t * \n\t * @param node1\n\t *            the first node\n\t * @param node2\n\t *            the second node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(Node node1, Node node2)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge. An event is sent toward the listeners.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * \n\t * \n\t * @param edge\n\t *            The edge to be removed\n\t * @return The removed edge\n\t */\n\t<T extends Edge> T removeEdge(Edge edge);\n\n\t/**\n\t * Removes a node with a given index.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the node to be removed\n\t * @return The removed node\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes a node.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param node\n\t *            The node to be removed\n\t * @return The removed node\n\t */\n\t<T extends Node> T removeNode(Node node);\n}",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ [ "1", "int" ] ],
  "tokensMethodArguments" : [ [ "id", "java.lang", "String" ], [ "fromIndex", "", "int" ], [ "toIndex", "", "int" ], [ "directed", "", "boolean" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "attributeSinks", "org.graphstream.graph", "Graph", "Iterable<AttributeSink> attributeSinks()" ], [ "getStep", "org.graphstream.graph", "Graph", "double getStep()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException" ], [ "hasVector", "org.graphstream.graph", "Element", "public abstract boolean hasVector(String arg0)" ], [ "getEdgeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getEdgeIterator()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int fromIndex, int toIndex, boolean directed) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0, Class<T> arg1)" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(String id) throws ElementNotFoundException" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display(boolean autoLayout)" ], [ "elementSinks", "org.graphstream.graph", "Graph", "Iterable<ElementSink> elementSinks()" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(String id)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String id) throws ElementNotFoundException" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Node node1, Node node2) throws ElementNotFoundException" ], [ "hasArray", "org.graphstream.graph", "Element", "public abstract boolean hasArray(String arg0)" ], [ "getNumber", "org.graphstream.graph", "Element", "public abstract double getNumber(String arg0)" ], [ "getAttributeKeyIterator", "org.graphstream.graph", "Element", "public abstract Iterator<String> getAttributeKeyIterator()" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(String id)" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display()" ], [ "getLabel", "org.graphstream.graph", "Element", "public abstract CharSequence getLabel(String arg0)" ], [ "getAttributeKeySet", "org.graphstream.graph", "Element", "public abstract Collection<String> getAttributeKeySet()" ], [ "getVector", "org.graphstream.graph", "Element", "public abstract ArrayList<? extends Number> getVector(String arg0)" ], [ "hasNumber", "org.graphstream.graph", "Element", "public abstract boolean hasNumber(String arg0)" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(String[] arg0)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(Class<T> arg0, String[] arg1)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException" ], [ "getNodeCount", "org.graphstream.graph", "Structure", "public abstract int getNodeCount()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String from, String to, boolean directed) throws IdAlreadyInUseException, ElementNotFoundException" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getArray", "org.graphstream.graph", "Element", "public abstract Object[] getArray(String arg0)" ], [ "isStrict", "org.graphstream.graph", "Graph", "boolean isStrict()" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0, Class<?> arg1)" ], [ "getAttributeCount", "org.graphstream.graph", "Element", "public abstract int getAttributeCount()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "nullAttributesAreErrors", "org.graphstream.graph", "Graph", "boolean nullAttributesAreErrors()" ], [ "getId", "org.graphstream.graph", "Element", "public abstract String getId()" ], [ "getEachEdge", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachEdge()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int fromIndex, int toIndex) throws IndexOutOfBoundsException, ElementNotFoundException" ], [ "getEdgeCount", "org.graphstream.graph", "Structure", "public abstract int getEdgeCount()" ], [ "getEachNode", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachNode()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Edge edge)" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException" ], [ "getIndex", "org.graphstream.graph", "Element", "public abstract int getIndex()" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(int index) throws IndexOutOfBoundsException" ], [ "getHash", "org.graphstream.graph", "Element", "public abstract HashMap<?, ?> getHash(String arg0)" ], [ "getNodeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getNodeSet()" ], [ "hasLabel", "org.graphstream.graph", "Element", "public abstract boolean hasLabel(String arg0)" ], [ "hasHash", "org.graphstream.graph", "Element", "public abstract boolean hasHash(String arg0)" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0)" ], [ "getEachAttributeKey", "org.graphstream.graph", "Element", "public abstract Iterable<String> getEachAttributeKey()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node node1, Node node2) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "nodeFactory", "org.graphstream.graph", "Graph", "NodeFactory<? extends Node> nodeFactory()" ], [ "edgeFactory", "org.graphstream.graph", "Graph", "EdgeFactory<? extends Edge> edgeFactory()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(Node node)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String node1, String node2) throws IdAlreadyInUseException, ElementNotFoundException, EdgeRejectedException" ], [ "getEdgeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getEdgeSet()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int index1, int index2) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "isAutoCreationEnabled", "org.graphstream.graph", "Graph", "boolean isAutoCreationEnabled()" ], [ "getNodeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getNodeIterator()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String from, String to) throws ElementNotFoundException" ], [ "addNode", "org.graphstream.graph", "Graph", "<T extends Node> T addNode(String id) throws IdAlreadyInUseException" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "length", "java.lang", "String", "public int length()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 4187,
  "oracle" : ";",
  "oracleType" : "PRE",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.graph",
  "className" : "Graph",
  "javadocTag" : "@param node2 The second node",
  "methodJavadoc" : "    /**\n\t * Like {@link #addEdge(String, String, String)} but the node references are\n\t * given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node\n\t * @param node2\n\t *            The second node\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */",
  "methodSourceCode" : "<T extends Edge> T addEdge(String id, Node node1, Node node2) throws IdAlreadyInUseException, EdgeRejectedException;",
  "classJavadoc" : "/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.graph;\n\nimport java.io.IOException;\n\nimport org.graphstream.stream.AttributeSink;\nimport org.graphstream.stream.ElementSink;\nimport org.graphstream.stream.GraphParseException;\nimport org.graphstream.stream.Pipe;\nimport org.graphstream.stream.file.FileSink;\nimport org.graphstream.stream.file.FileSource;\nimport org.graphstream.ui.view.Viewer;\n\n\n/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */\npublic interface Graph extends Element, Pipe, Iterable<Node>, Structure {\n\t// Access\n\n\t/**\n\t * Get a node by its identifier. This method is implicitly generic and\n\t * returns something which extends Node. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param id\n\t *            Identifier of the node to find.\n\t * @return The searched node or null if not found.\n\t */\n\t<T extends Node> T getNode(String id);\n\n\t/**\n\t * Get an edge by its identifier. This method is implicitly generic and\n\t * returns something which extends Edge. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param id\n\t *            Identifier of the edge to find.\n\t * @return The searched edge or null if not found.\n\t */\n\t<T extends Edge> T getEdge(String id);\n\n\t/**\n\t * The factory used to create node instances. The factory can be changed to\n\t * refine the node class generated for this graph.\n\t * \n\t * @see #setNodeFactory(NodeFactory)\n\t * @see #edgeFactory()\n\t */\n\tNodeFactory<? extends Node> nodeFactory();\n\n\t/**\n\t * The factory used to create edge instances. The factory can be changed to\n\t * refine the edge class generated for this graph.\n\t * \n\t * @see #setEdgeFactory(EdgeFactory)\n\t * @see #nodeFactory()\n\t */\n\tEdgeFactory<? extends Edge> edgeFactory();\n\n\t/**\n\t * Is strict checking enabled? If strict checking is enabled the graph\n\t * checks for name space conflicts (e.g. insertion of two nodes with the\n\t * same name), removal of non-existing elements, use of non existing\n\t * elements (create an edge between two non existing nodes). Graph\n\t * implementations are free to respect strict checking or not.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isStrict();\n\n\t/**\n\t * Is the automatic creation of missing elements enabled?. If strict\n\t * checking is disabled and auto-creation is enabled, when an edge is\n\t * created and one or two of its nodes are not already present in the graph,\n\t * the nodes are automatically created.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isAutoCreationEnabled();\n\n\t/**\n\t * If true, when accessing an attribute that does not exist (or is not of\n\t * the expected type), a {@link NullAttributeException} is thrown. Else null\n\t * is returned.\n\t * \n\t * @return True if exceptions must be thrown when accessing a null\n\t *         attribute.\n\t */\n\tboolean nullAttributesAreErrors();\n\n\t/**\n\t * The current step.\n\t * \n\t * @return The step.\n\t */\n\tdouble getStep();\n\n\t// Command\n\n\t/**\n\t * Should a {@link NullAttributeException} be thrown when one tries to\n\t * access a non existing attribute, or an attribute whose type is not the\n\t * expected one?.\n\t * \n\t * @param on\n\t *            if true, exceptions will be thrown when accessing a non\n\t *            existing attribute.\n\t */\n\tvoid setNullAttributesAreErrors(boolean on);\n\n\t/**\n\t * Set the node factory used to create nodes.\n\t * \n\t * @param nf\n\t *            the new NodeFactory\n\t */\n\tvoid setNodeFactory(NodeFactory<? extends Node> nf);\n\n\t/**\n\t * Set the edge factory used to create edges.\n\t * \n\t * @param ef\n\t *            the new EdgeFactory\n\t */\n\tvoid setEdgeFactory(EdgeFactory<? extends Edge> ef);\n\n\t/**\n\t * Enable or disable strict checking.\n\t * \n\t * @see #isStrict()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setStrict(boolean on);\n\n\t/**\n\t * Enable or disable the automatic creation of missing elements.\n\t * \n\t * @see #isAutoCreationEnabled()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setAutoCreate(boolean on);\n\n\t// Graph construction\n\n\t/**\n\t * Empty the graph completely by removing any references to nodes or edges.\n\t * Every attribute is also removed. However, listeners are kept.\n\t * \n\t * @see #clearSinks()\n\t */\n\tvoid clear();\n\n\t/**\n\t * Add a node in the graph.\n\t * <p>\n\t * This acts as a factory, creating the node instance automatically (and\n\t * eventually using the node factory provided). An event is generated toward\n\t * the listeners. If strict checking is enabled, and a node already exists\n\t * with this identifier, an\n\t * {@link org.graphstream.graph.IdAlreadyInUseException} is raised. Else the\n\t * error is silently ignored and the already existing node is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.addNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            Arbitrary and unique string identifying the node.\n\t * @return The created node (or the already existing node).\n\t * @throws IdAlreadyInUseException\n\t *             If strict checking is enabled the identifier is already used.\n\t */\n\t<T extends Node> T addNode(String id) throws IdAlreadyInUseException;\n\n\t/**\n\t * Remove a node using its identifier.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            The unique identifier of the node to remove.\n\t * @return The removed node. If strict checking is disabled, it can return\n\t *         null if the node to remove does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no node matches the given identifier and strict checking\n\t *             is enabled.\n\t */\n\t<T extends Node> T removeNode(String id) throws ElementNotFoundException;\n\n\t/**\n\t * Adds an undirected edge between nodes.\n\t * \n\t * <p>\n\t * The behavior of this method depends on many conditions. It can be\n\t * summarized as follows.\n\t * </p>\n\t * \n\t * <p>\n\t * First of all, the method checks if the graph already contains an edge\n\t * with the same id. If this is the case and strict checking is enabled,\n\t * {@code IdAlreadyInUseException} is thrown. If the strict checking is\n\t * disabled the method returns a reference to the existing edge if it has\n\t * endpoints {@code node1} and {@code node2} (in the same order if the edge\n\t * is directed) or {@code null} otherwise.\n\t * </p>\n\t * \n\t * <p>\n\t * In the case when the graph does not contain an edge with the same id, the\n\t * method checks if {@code node1} and {@code node2} exist. If one or both of\n\t * them do not exist, and strict checking is enabled, {@code\n\t * ElementNotFoundException} is thrown. Otherwise if auto-creation is\n\t * disabled, the method returns {@code null}. If auto-creation is enabled,\n\t * the method creates the missing endpoints.\n\t * \n\t * <p>\n\t * When the edge id is not already in use and the both endpoints exist (or\n\t * created), the edge can still be rejected. It may happen for example when\n\t * it connects two already connected nodes in a single graph. If the edge is\n\t * rejected, the method throws {@code EdgeRejectedException} if strict\n\t * checking is enabled or returns {@code null} otherwise. Finally, if the\n\t * edge is accepted, it is created using the corresponding edge factory and\n\t * a reference to it is returned.\n\t * \n\t * <p>\n\t * An edge creation event is sent toward the listeners. If new nodes are\n\t * created, the corresponding events are also sent to the listeners.\n\t * </p>\n\t * \n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.addEdge(&quot;...&quot;, &quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * \n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t */\n\t<T extends Edge> T addEdge(String id, String node1, String node2)\n\t\t\tthrows IdAlreadyInUseException, ElementNotFoundException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)}, but this edge can be\n\t * directed between the two given nodes. If directed, the edge goes in the\n\t * 'from' -&gt; 'to' direction. An event is sent toward the listeners.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, String from, String to,\n\t\t\tboolean directed) throws IdAlreadyInUseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Remove an edge given the identifiers of its two endpoints.\n\t * <p>\n\t * If the edge is directed it is removed only if its source and destination\n\t * nodes are identified by 'from' and 'to' respectively. If the graph is a\n\t * multi-graph and there are several edges between the two nodes, one of the\n\t * edges at random is removed. An event is sent toward the listeners. If\n\t * strict checking is enabled and at least one of the two given nodes does\n\t * not exist or if they are not connected, a not found exception is raised.\n\t * Else the error is silently ignored, and null is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param from\n\t *            The origin node identifier to select the edge.\n\t * @param to\n\t *            The destination node identifier to select the edge.\n\t * @return The removed edge, or null if strict checking is disabled and at\n\t *         least one of the two given nodes does not exist or there is no\n\t *         edge between them\n\t * @throws ElementNotFoundException\n\t *             If the 'from' or 'to' node is not registered in the graph or\n\t *             not connected and strict checking is enabled.\n\t */\n\t<T extends Edge> T removeEdge(String from, String to)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge knowing its identifier. An event is sent toward the\n\t * listeners. If strict checking is enabled and the edge does not exist,\n\t * {@code ElementNotFoundException} is raised. Otherwise the error is\n\t * silently ignored and null is returned.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Identifier of the edge to remove.\n\t * @return The removed edge, or null if strict checking is disabled and the\n\t *         edge does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no edge matches the identifier and strict checking is\n\t *             enabled.\n\t */\n\t<T extends Edge> T removeEdge(String id) throws ElementNotFoundException;\n\n\t/**\n\t * <p>\n\t * Since dynamic graphs are based on discrete event modifications, the\n\t * notion of step is defined to simulate elapsed time between events. So a\n\t * step is a event that occurs in the graph, it does not modify it but it\n\t * gives a kind of timestamp that allows the tracking of the progress of the\n\t * graph over the time.\n\t * </p>\n\t * <p>\n\t * This kind of event is useful for dynamic algorithms that listen to the\n\t * dynamic graph and need to measure the time in the graph's evolution.\n\t * </p>\n\t * \n\t * @param time\n\t *            A numerical value that may give a timestamp to track the\n\t *            evolution of the graph over the time.\n\t */\n\tvoid stepBegins(double time);\n\n\t// Source\n\t// XXX do we put the iterable attributeSinks and elementSinks in Source ?\n\n\t/**\n\t * Returns an \"iterable\" of {@link AttributeSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the set of {@link AttributeSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<AttributeSink> attributeSinks();\n\n\t/**\n\t * Returns an \"iterable\" of {@link ElementSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the list of {@link ElementSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<ElementSink> elementSinks();\n\n\t// Utility shortcuts (should be mixins or traits, what are you doing Mr Java\n\t// ?)\n\t// XXX use a Readable/Writable/Displayable interface for this ?\n\n\t/**\n\t * Utility method to read a graph. This method tries to identify the graph\n\t * format by itself and instantiates the corresponding reader automatically.\n\t * If this process fails, a NotFoundException is raised.\n\t * \n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognized.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input output error occurs during the graph reading.\n\t */\n\tvoid read(String filename) throws IOException, GraphParseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Utility method to read a graph using the given reader.\n\t * \n\t * @param input\n\t *            An appropriate reader for the filename.\n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognised.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph reading.\n\t */\n\tvoid read(FileSource input, String filename) throws IOException,\n\t\t\tGraphParseException;\n\n\t/**\n\t * Utility method to write a graph in DGS format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(String filename) throws IOException;\n\n\t/**\n\t * Utility method to write a graph in the chosen format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @param output\n\t *            The output format to use.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(FileSink output, String filename) throws IOException;\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but may be limited. This method\n\t * automatically launch a graph layout algorithm in its own thread to\n\t * compute best node positions.\n\t * \n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display(boolean )\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display();\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but is very limited.\n\t * \n\t * @param autoLayout\n\t *            If true a layout algorithm is launched in its own thread to\n\t *            compute best node positions.\n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display()\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display(boolean autoLayout);\n\n\t// New methods\n\n\t/**\n\t * Get a node by its index. This method is implicitly generic and returns\n\t * something which extends Node. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param index\n\t *            Index of the node to find.\n\t * @return The node with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             If the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T getNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Get an edge by its index. This method is implicitly generic and returns\n\t * something which extends Edge. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param index\n\t *            The index of the edge to find.\n\t * @return The edge with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is less than 0 or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param index1\n\t *            The first node index\n\t * @param index2\n\t *            The second node index\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int index1, int index2)\n\t\t\tthrows IndexOutOfBoundsException, IdAlreadyInUseException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param toIndex\n\t *            The first node index\n\t * @param fromIndex\n\t *            The second node index\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int fromIndex, int toIndex,\n\t\t\tboolean directed) throws IndexOutOfBoundsException,\n\t\t\tIdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the node references are\n\t * given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node\n\t * @param node2\n\t *            The second node\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node node1, Node node2)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the node\n\t * references are given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param from\n\t *            The first node\n\t * @param to\n\t *            The second node\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Removes an edge with a given index. An event is sent toward the\n\t * listeners.\n\t * \n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.removeEdge(i);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the edge to be removed.\n\t * @return The removed edge\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getEdgeCount() - 1}\n\t */\n\t<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but the nodes are identified by their\n\t * indices.\n\t * \n\t * @param fromIndex\n\t *            the index of the source node\n\t * @param toIndex\n\t *            the index of the target node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws IndexOutOfBoundsException\n\t *             If one of the node indices is negative or greater than\n\t *             {@code getNodeCount() - 1}.\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(int fromIndex, int toIndex)\n\t\t\tthrows IndexOutOfBoundsException, ElementNotFoundException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but node references are given instead\n\t * of node identifiers.\n\t * \n\t * @param node1\n\t *            the first node\n\t * @param node2\n\t *            the second node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(Node node1, Node node2)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge. An event is sent toward the listeners.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * \n\t * \n\t * @param edge\n\t *            The edge to be removed\n\t * @return The removed edge\n\t */\n\t<T extends Edge> T removeEdge(Edge edge);\n\n\t/**\n\t * Removes a node with a given index.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the node to be removed\n\t * @return The removed node\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes a node.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param node\n\t *            The node to be removed\n\t * @return The removed node\n\t */\n\t<T extends Node> T removeNode(Node node);\n}",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ [ "1", "int" ], [ "2", "int" ] ],
  "tokensMethodArguments" : [ [ "id", "java.lang", "String" ], [ "node1", "org.graphstream.graph", "Node" ], [ "node2", "org.graphstream.graph", "Node" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "nodeFactory", "org.graphstream.graph", "Graph", "NodeFactory<? extends Node> nodeFactory()" ], [ "getNodeCount", "org.graphstream.graph", "Structure", "public abstract int getNodeCount()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int index1, int index2) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0)" ], [ "hasHash", "org.graphstream.graph", "Element", "public abstract boolean hasHash(String arg0)" ], [ "getEdgeCount", "org.graphstream.graph", "Structure", "public abstract int getEdgeCount()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int fromIndex, int toIndex) throws IndexOutOfBoundsException, ElementNotFoundException" ], [ "hasVector", "org.graphstream.graph", "Element", "public abstract boolean hasVector(String arg0)" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0)" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0, Class<T> arg1)" ], [ "edgeFactory", "org.graphstream.graph", "Graph", "EdgeFactory<? extends Edge> edgeFactory()" ], [ "getStep", "org.graphstream.graph", "Graph", "double getStep()" ], [ "hasNumber", "org.graphstream.graph", "Element", "public abstract boolean hasNumber(String arg0)" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(String id)" ], [ "isStrict", "org.graphstream.graph", "Graph", "boolean isStrict()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String from, String to) throws ElementNotFoundException" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "getArray", "org.graphstream.graph", "Element", "public abstract Object[] getArray(String arg0)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String from, String to, boolean directed) throws IdAlreadyInUseException, ElementNotFoundException" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String node1, String node2) throws IdAlreadyInUseException, ElementNotFoundException, EdgeRejectedException" ], [ "hasArray", "org.graphstream.graph", "Element", "public abstract boolean hasArray(String arg0)" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getVector", "org.graphstream.graph", "Element", "public abstract ArrayList<? extends Number> getVector(String arg0)" ], [ "isAutoCreationEnabled", "org.graphstream.graph", "Graph", "boolean isAutoCreationEnabled()" ], [ "nullAttributesAreErrors", "org.graphstream.graph", "Graph", "boolean nullAttributesAreErrors()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display()" ], [ "getId", "org.graphstream.graph", "Element", "public abstract String getId()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Edge edge)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String id) throws ElementNotFoundException" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0, Class<?> arg1)" ], [ "addNode", "org.graphstream.graph", "Graph", "<T extends Node> T addNode(String id) throws IdAlreadyInUseException" ], [ "getNodeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getNodeIterator()" ], [ "getEachEdge", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachEdge()" ], [ "attributeSinks", "org.graphstream.graph", "Graph", "Iterable<AttributeSink> attributeSinks()" ], [ "getNodeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getNodeSet()" ], [ "getLabel", "org.graphstream.graph", "Element", "public abstract CharSequence getLabel(String arg0)" ], [ "elementSinks", "org.graphstream.graph", "Graph", "Iterable<ElementSink> elementSinks()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException" ], [ "getEachNode", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachNode()" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(String id)" ], [ "getEdgeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getEdgeSet()" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(Node node)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int fromIndex, int toIndex, boolean directed) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "getAttributeCount", "org.graphstream.graph", "Element", "public abstract int getAttributeCount()" ], [ "getIndex", "org.graphstream.graph", "Element", "public abstract int getIndex()" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(Class<T> arg0, String[] arg1)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getNumber", "org.graphstream.graph", "Element", "public abstract double getNumber(String arg0)" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display(boolean autoLayout)" ], [ "getEdgeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getEdgeIterator()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Node node1, Node node2) throws ElementNotFoundException" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(String id) throws ElementNotFoundException" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(int index) throws IndexOutOfBoundsException" ], [ "getAttributeKeyIterator", "org.graphstream.graph", "Element", "public abstract Iterator<String> getAttributeKeyIterator()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node node1, Node node2) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "getHash", "org.graphstream.graph", "Element", "public abstract HashMap<?, ?> getHash(String arg0)" ], [ "getEachAttributeKey", "org.graphstream.graph", "Element", "public abstract Iterable<String> getEachAttributeKey()" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(String[] arg0)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "hasLabel", "org.graphstream.graph", "Element", "public abstract boolean hasLabel(String arg0)" ], [ "getAttributeKeySet", "org.graphstream.graph", "Element", "public abstract Collection<String> getAttributeKeySet()" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "length", "java.lang", "String", "public int length()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ], [ "getBreadthFirstIterator", "org.graphstream.graph", "Node", "public abstract <T> Iterator<T> getBreadthFirstIterator(boolean arg0)" ], [ "hasEdgeBetween", "org.graphstream.graph", "Node", "public abstract boolean hasEdgeBetween(int arg0) throws IndexOutOfBoundsException" ], [ "getEdgeBetween", "org.graphstream.graph", "Node", "public abstract <T> T getEdgeBetween(int arg0) throws IndexOutOfBoundsException" ], [ "getDegree", "org.graphstream.graph", "Node", "public abstract int getDegree()" ], [ "getLeavingEdgeSet", "org.graphstream.graph", "Node", "public abstract <T> Collection<T> getLeavingEdgeSet()" ], [ "hasEdgeFrom", "org.graphstream.graph", "Node", "public abstract boolean hasEdgeFrom(int arg0) throws IndexOutOfBoundsException" ], [ "getLeavingEdge", "org.graphstream.graph", "Node", "public abstract <T> T getLeavingEdge(int arg0)" ], [ "getEdgeFrom", "org.graphstream.graph", "Node", "public abstract <T> T getEdgeFrom(int arg0) throws IndexOutOfBoundsException" ], [ "getGraph", "org.graphstream.graph", "Node", "public abstract Graph getGraph()" ], [ "getEdgeBetween", "org.graphstream.graph", "Node", "public abstract <T> T getEdgeBetween(String arg0)" ], [ "getEdgeBetween", "org.graphstream.graph", "Node", "public abstract <T> T getEdgeBetween(Node arg0)" ], [ "getNeighborNodeIterator", "org.graphstream.graph", "Node", "public abstract <T> Iterator<T> getNeighborNodeIterator()" ], [ "getEnteringEdgeSet", "org.graphstream.graph", "Node", "public abstract <T> Collection<T> getEnteringEdgeSet()" ], [ "hasEdgeToward", "org.graphstream.graph", "Node", "public abstract boolean hasEdgeToward(String arg0)" ], [ "getEdgeToward", "org.graphstream.graph", "Node", "public abstract <T> T getEdgeToward(int arg0) throws IndexOutOfBoundsException" ], [ "getEnteringEdge", "org.graphstream.graph", "Node", "public abstract <T> T getEnteringEdge(int arg0)" ], [ "getLeavingEdgeIterator", "org.graphstream.graph", "Node", "public abstract <T> Iterator<T> getLeavingEdgeIterator()" ], [ "hasEdgeBetween", "org.graphstream.graph", "Node", "public abstract boolean hasEdgeBetween(String arg0)" ], [ "getEdgeToward", "org.graphstream.graph", "Node", "public abstract <T> T getEdgeToward(Node arg0)" ], [ "getEnteringEdgeIterator", "org.graphstream.graph", "Node", "public abstract <T> Iterator<T> getEnteringEdgeIterator()" ], [ "getDepthFirstIterator", "org.graphstream.graph", "Node", "public abstract <T> Iterator<T> getDepthFirstIterator(boolean arg0)" ], [ "getEdgeToward", "org.graphstream.graph", "Node", "public abstract <T> T getEdgeToward(String arg0)" ], [ "hasEdgeBetween", "org.graphstream.graph", "Node", "public abstract boolean hasEdgeBetween(Node arg0)" ], [ "getEachEnteringEdge", "org.graphstream.graph", "Node", "public abstract <T> Iterable<T> getEachEnteringEdge()" ], [ "getEdge", "org.graphstream.graph", "Node", "public abstract <T> T getEdge(int arg0)" ], [ "getDepthFirstIterator", "org.graphstream.graph", "Node", "public abstract <T> Iterator<T> getDepthFirstIterator()" ], [ "getBreadthFirstIterator", "org.graphstream.graph", "Node", "public abstract <T> Iterator<T> getBreadthFirstIterator()" ], [ "toString", "org.graphstream.graph", "Node", "public abstract String toString()" ], [ "getEdgeFrom", "org.graphstream.graph", "Node", "public abstract <T> T getEdgeFrom(Node arg0)" ], [ "hasEdgeToward", "org.graphstream.graph", "Node", "public abstract boolean hasEdgeToward(int arg0) throws IndexOutOfBoundsException" ], [ "getEdgeIterator", "org.graphstream.graph", "Node", "public abstract <T> Iterator<T> getEdgeIterator()" ], [ "getEachLeavingEdge", "org.graphstream.graph", "Node", "public abstract <T> Iterable<T> getEachLeavingEdge()" ], [ "getOutDegree", "org.graphstream.graph", "Node", "public abstract int getOutDegree()" ], [ "hasEdgeFrom", "org.graphstream.graph", "Node", "public abstract boolean hasEdgeFrom(Node arg0)" ], [ "getEdgeFrom", "org.graphstream.graph", "Node", "public abstract <T> T getEdgeFrom(String arg0)" ], [ "hasEdgeToward", "org.graphstream.graph", "Node", "public abstract boolean hasEdgeToward(Node arg0)" ], [ "hasEdgeFrom", "org.graphstream.graph", "Node", "public abstract boolean hasEdgeFrom(String arg0)" ], [ "getEachEdge", "org.graphstream.graph", "Node", "public abstract <T> Iterable<T> getEachEdge()" ], [ "getInDegree", "org.graphstream.graph", "Node", "public abstract int getInDegree()" ], [ "getEdgeSet", "org.graphstream.graph", "Node", "public abstract <T> Collection<T> getEdgeSet()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 4189,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.graph",
  "className" : "Graph",
  "javadocTag" : "@throws IdAlreadyInUseException If an edge with the same id already exists and strict\n            checking is enabled.",
  "methodJavadoc" : "    /**\n\t * Like {@link #addEdge(String, String, String)} but the node references are\n\t * given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node\n\t * @param node2\n\t *            The second node\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */",
  "methodSourceCode" : "<T extends Edge> T addEdge(String id, Node node1, Node node2) throws IdAlreadyInUseException, EdgeRejectedException;",
  "classJavadoc" : "/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.graph;\n\nimport java.io.IOException;\n\nimport org.graphstream.stream.AttributeSink;\nimport org.graphstream.stream.ElementSink;\nimport org.graphstream.stream.GraphParseException;\nimport org.graphstream.stream.Pipe;\nimport org.graphstream.stream.file.FileSink;\nimport org.graphstream.stream.file.FileSource;\nimport org.graphstream.ui.view.Viewer;\n\n\n/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */\npublic interface Graph extends Element, Pipe, Iterable<Node>, Structure {\n\t// Access\n\n\t/**\n\t * Get a node by its identifier. This method is implicitly generic and\n\t * returns something which extends Node. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param id\n\t *            Identifier of the node to find.\n\t * @return The searched node or null if not found.\n\t */\n\t<T extends Node> T getNode(String id);\n\n\t/**\n\t * Get an edge by its identifier. This method is implicitly generic and\n\t * returns something which extends Edge. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param id\n\t *            Identifier of the edge to find.\n\t * @return The searched edge or null if not found.\n\t */\n\t<T extends Edge> T getEdge(String id);\n\n\t/**\n\t * The factory used to create node instances. The factory can be changed to\n\t * refine the node class generated for this graph.\n\t * \n\t * @see #setNodeFactory(NodeFactory)\n\t * @see #edgeFactory()\n\t */\n\tNodeFactory<? extends Node> nodeFactory();\n\n\t/**\n\t * The factory used to create edge instances. The factory can be changed to\n\t * refine the edge class generated for this graph.\n\t * \n\t * @see #setEdgeFactory(EdgeFactory)\n\t * @see #nodeFactory()\n\t */\n\tEdgeFactory<? extends Edge> edgeFactory();\n\n\t/**\n\t * Is strict checking enabled? If strict checking is enabled the graph\n\t * checks for name space conflicts (e.g. insertion of two nodes with the\n\t * same name), removal of non-existing elements, use of non existing\n\t * elements (create an edge between two non existing nodes). Graph\n\t * implementations are free to respect strict checking or not.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isStrict();\n\n\t/**\n\t * Is the automatic creation of missing elements enabled?. If strict\n\t * checking is disabled and auto-creation is enabled, when an edge is\n\t * created and one or two of its nodes are not already present in the graph,\n\t * the nodes are automatically created.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isAutoCreationEnabled();\n\n\t/**\n\t * If true, when accessing an attribute that does not exist (or is not of\n\t * the expected type), a {@link NullAttributeException} is thrown. Else null\n\t * is returned.\n\t * \n\t * @return True if exceptions must be thrown when accessing a null\n\t *         attribute.\n\t */\n\tboolean nullAttributesAreErrors();\n\n\t/**\n\t * The current step.\n\t * \n\t * @return The step.\n\t */\n\tdouble getStep();\n\n\t// Command\n\n\t/**\n\t * Should a {@link NullAttributeException} be thrown when one tries to\n\t * access a non existing attribute, or an attribute whose type is not the\n\t * expected one?.\n\t * \n\t * @param on\n\t *            if true, exceptions will be thrown when accessing a non\n\t *            existing attribute.\n\t */\n\tvoid setNullAttributesAreErrors(boolean on);\n\n\t/**\n\t * Set the node factory used to create nodes.\n\t * \n\t * @param nf\n\t *            the new NodeFactory\n\t */\n\tvoid setNodeFactory(NodeFactory<? extends Node> nf);\n\n\t/**\n\t * Set the edge factory used to create edges.\n\t * \n\t * @param ef\n\t *            the new EdgeFactory\n\t */\n\tvoid setEdgeFactory(EdgeFactory<? extends Edge> ef);\n\n\t/**\n\t * Enable or disable strict checking.\n\t * \n\t * @see #isStrict()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setStrict(boolean on);\n\n\t/**\n\t * Enable or disable the automatic creation of missing elements.\n\t * \n\t * @see #isAutoCreationEnabled()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setAutoCreate(boolean on);\n\n\t// Graph construction\n\n\t/**\n\t * Empty the graph completely by removing any references to nodes or edges.\n\t * Every attribute is also removed. However, listeners are kept.\n\t * \n\t * @see #clearSinks()\n\t */\n\tvoid clear();\n\n\t/**\n\t * Add a node in the graph.\n\t * <p>\n\t * This acts as a factory, creating the node instance automatically (and\n\t * eventually using the node factory provided). An event is generated toward\n\t * the listeners. If strict checking is enabled, and a node already exists\n\t * with this identifier, an\n\t * {@link org.graphstream.graph.IdAlreadyInUseException} is raised. Else the\n\t * error is silently ignored and the already existing node is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.addNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            Arbitrary and unique string identifying the node.\n\t * @return The created node (or the already existing node).\n\t * @throws IdAlreadyInUseException\n\t *             If strict checking is enabled the identifier is already used.\n\t */\n\t<T extends Node> T addNode(String id) throws IdAlreadyInUseException;\n\n\t/**\n\t * Remove a node using its identifier.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            The unique identifier of the node to remove.\n\t * @return The removed node. If strict checking is disabled, it can return\n\t *         null if the node to remove does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no node matches the given identifier and strict checking\n\t *             is enabled.\n\t */\n\t<T extends Node> T removeNode(String id) throws ElementNotFoundException;\n\n\t/**\n\t * Adds an undirected edge between nodes.\n\t * \n\t * <p>\n\t * The behavior of this method depends on many conditions. It can be\n\t * summarized as follows.\n\t * </p>\n\t * \n\t * <p>\n\t * First of all, the method checks if the graph already contains an edge\n\t * with the same id. If this is the case and strict checking is enabled,\n\t * {@code IdAlreadyInUseException} is thrown. If the strict checking is\n\t * disabled the method returns a reference to the existing edge if it has\n\t * endpoints {@code node1} and {@code node2} (in the same order if the edge\n\t * is directed) or {@code null} otherwise.\n\t * </p>\n\t * \n\t * <p>\n\t * In the case when the graph does not contain an edge with the same id, the\n\t * method checks if {@code node1} and {@code node2} exist. If one or both of\n\t * them do not exist, and strict checking is enabled, {@code\n\t * ElementNotFoundException} is thrown. Otherwise if auto-creation is\n\t * disabled, the method returns {@code null}. If auto-creation is enabled,\n\t * the method creates the missing endpoints.\n\t * \n\t * <p>\n\t * When the edge id is not already in use and the both endpoints exist (or\n\t * created), the edge can still be rejected. It may happen for example when\n\t * it connects two already connected nodes in a single graph. If the edge is\n\t * rejected, the method throws {@code EdgeRejectedException} if strict\n\t * checking is enabled or returns {@code null} otherwise. Finally, if the\n\t * edge is accepted, it is created using the corresponding edge factory and\n\t * a reference to it is returned.\n\t * \n\t * <p>\n\t * An edge creation event is sent toward the listeners. If new nodes are\n\t * created, the corresponding events are also sent to the listeners.\n\t * </p>\n\t * \n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.addEdge(&quot;...&quot;, &quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * \n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t */\n\t<T extends Edge> T addEdge(String id, String node1, String node2)\n\t\t\tthrows IdAlreadyInUseException, ElementNotFoundException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)}, but this edge can be\n\t * directed between the two given nodes. If directed, the edge goes in the\n\t * 'from' -&gt; 'to' direction. An event is sent toward the listeners.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, String from, String to,\n\t\t\tboolean directed) throws IdAlreadyInUseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Remove an edge given the identifiers of its two endpoints.\n\t * <p>\n\t * If the edge is directed it is removed only if its source and destination\n\t * nodes are identified by 'from' and 'to' respectively. If the graph is a\n\t * multi-graph and there are several edges between the two nodes, one of the\n\t * edges at random is removed. An event is sent toward the listeners. If\n\t * strict checking is enabled and at least one of the two given nodes does\n\t * not exist or if they are not connected, a not found exception is raised.\n\t * Else the error is silently ignored, and null is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param from\n\t *            The origin node identifier to select the edge.\n\t * @param to\n\t *            The destination node identifier to select the edge.\n\t * @return The removed edge, or null if strict checking is disabled and at\n\t *         least one of the two given nodes does not exist or there is no\n\t *         edge between them\n\t * @throws ElementNotFoundException\n\t *             If the 'from' or 'to' node is not registered in the graph or\n\t *             not connected and strict checking is enabled.\n\t */\n\t<T extends Edge> T removeEdge(String from, String to)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge knowing its identifier. An event is sent toward the\n\t * listeners. If strict checking is enabled and the edge does not exist,\n\t * {@code ElementNotFoundException} is raised. Otherwise the error is\n\t * silently ignored and null is returned.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Identifier of the edge to remove.\n\t * @return The removed edge, or null if strict checking is disabled and the\n\t *         edge does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no edge matches the identifier and strict checking is\n\t *             enabled.\n\t */\n\t<T extends Edge> T removeEdge(String id) throws ElementNotFoundException;\n\n\t/**\n\t * <p>\n\t * Since dynamic graphs are based on discrete event modifications, the\n\t * notion of step is defined to simulate elapsed time between events. So a\n\t * step is a event that occurs in the graph, it does not modify it but it\n\t * gives a kind of timestamp that allows the tracking of the progress of the\n\t * graph over the time.\n\t * </p>\n\t * <p>\n\t * This kind of event is useful for dynamic algorithms that listen to the\n\t * dynamic graph and need to measure the time in the graph's evolution.\n\t * </p>\n\t * \n\t * @param time\n\t *            A numerical value that may give a timestamp to track the\n\t *            evolution of the graph over the time.\n\t */\n\tvoid stepBegins(double time);\n\n\t// Source\n\t// XXX do we put the iterable attributeSinks and elementSinks in Source ?\n\n\t/**\n\t * Returns an \"iterable\" of {@link AttributeSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the set of {@link AttributeSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<AttributeSink> attributeSinks();\n\n\t/**\n\t * Returns an \"iterable\" of {@link ElementSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the list of {@link ElementSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<ElementSink> elementSinks();\n\n\t// Utility shortcuts (should be mixins or traits, what are you doing Mr Java\n\t// ?)\n\t// XXX use a Readable/Writable/Displayable interface for this ?\n\n\t/**\n\t * Utility method to read a graph. This method tries to identify the graph\n\t * format by itself and instantiates the corresponding reader automatically.\n\t * If this process fails, a NotFoundException is raised.\n\t * \n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognized.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input output error occurs during the graph reading.\n\t */\n\tvoid read(String filename) throws IOException, GraphParseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Utility method to read a graph using the given reader.\n\t * \n\t * @param input\n\t *            An appropriate reader for the filename.\n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognised.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph reading.\n\t */\n\tvoid read(FileSource input, String filename) throws IOException,\n\t\t\tGraphParseException;\n\n\t/**\n\t * Utility method to write a graph in DGS format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(String filename) throws IOException;\n\n\t/**\n\t * Utility method to write a graph in the chosen format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @param output\n\t *            The output format to use.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(FileSink output, String filename) throws IOException;\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but may be limited. This method\n\t * automatically launch a graph layout algorithm in its own thread to\n\t * compute best node positions.\n\t * \n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display(boolean )\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display();\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but is very limited.\n\t * \n\t * @param autoLayout\n\t *            If true a layout algorithm is launched in its own thread to\n\t *            compute best node positions.\n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display()\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display(boolean autoLayout);\n\n\t// New methods\n\n\t/**\n\t * Get a node by its index. This method is implicitly generic and returns\n\t * something which extends Node. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param index\n\t *            Index of the node to find.\n\t * @return The node with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             If the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T getNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Get an edge by its index. This method is implicitly generic and returns\n\t * something which extends Edge. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param index\n\t *            The index of the edge to find.\n\t * @return The edge with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is less than 0 or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param index1\n\t *            The first node index\n\t * @param index2\n\t *            The second node index\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int index1, int index2)\n\t\t\tthrows IndexOutOfBoundsException, IdAlreadyInUseException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param toIndex\n\t *            The first node index\n\t * @param fromIndex\n\t *            The second node index\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int fromIndex, int toIndex,\n\t\t\tboolean directed) throws IndexOutOfBoundsException,\n\t\t\tIdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the node references are\n\t * given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node\n\t * @param node2\n\t *            The second node\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node node1, Node node2)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the node\n\t * references are given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param from\n\t *            The first node\n\t * @param to\n\t *            The second node\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Removes an edge with a given index. An event is sent toward the\n\t * listeners.\n\t * \n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.removeEdge(i);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the edge to be removed.\n\t * @return The removed edge\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getEdgeCount() - 1}\n\t */\n\t<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but the nodes are identified by their\n\t * indices.\n\t * \n\t * @param fromIndex\n\t *            the index of the source node\n\t * @param toIndex\n\t *            the index of the target node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws IndexOutOfBoundsException\n\t *             If one of the node indices is negative or greater than\n\t *             {@code getNodeCount() - 1}.\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(int fromIndex, int toIndex)\n\t\t\tthrows IndexOutOfBoundsException, ElementNotFoundException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but node references are given instead\n\t * of node identifiers.\n\t * \n\t * @param node1\n\t *            the first node\n\t * @param node2\n\t *            the second node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(Node node1, Node node2)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge. An event is sent toward the listeners.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * \n\t * \n\t * @param edge\n\t *            The edge to be removed\n\t * @return The removed edge\n\t */\n\t<T extends Edge> T removeEdge(Edge edge);\n\n\t/**\n\t * Removes a node with a given index.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the node to be removed\n\t * @return The removed node\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes a node.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param node\n\t *            The node to be removed\n\t * @return The removed node\n\t */\n\t<T extends Node> T removeNode(Node node);\n}",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ [ "1", "int" ], [ "2", "int" ] ],
  "tokensMethodArguments" : [ [ "id", "java.lang", "String" ], [ "node1", "org.graphstream.graph", "Node" ], [ "node2", "org.graphstream.graph", "Node" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException" ], [ "getNodeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getNodeSet()" ], [ "getEdgeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getEdgeIterator()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "getEachAttributeKey", "org.graphstream.graph", "Element", "public abstract Iterable<String> getEachAttributeKey()" ], [ "getNumber", "org.graphstream.graph", "Element", "public abstract double getNumber(String arg0)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int index1, int index2) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "getNodeCount", "org.graphstream.graph", "Structure", "public abstract int getNodeCount()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int fromIndex, int toIndex) throws IndexOutOfBoundsException, ElementNotFoundException" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display()" ], [ "getEachNode", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachNode()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(Node node)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int fromIndex, int toIndex, boolean directed) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "attributeSinks", "org.graphstream.graph", "Graph", "Iterable<AttributeSink> attributeSinks()" ], [ "hasLabel", "org.graphstream.graph", "Element", "public abstract boolean hasLabel(String arg0)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String from, String to) throws ElementNotFoundException" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getHash", "org.graphstream.graph", "Element", "public abstract HashMap<?, ?> getHash(String arg0)" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "hasVector", "org.graphstream.graph", "Element", "public abstract boolean hasVector(String arg0)" ], [ "isAutoCreationEnabled", "org.graphstream.graph", "Graph", "boolean isAutoCreationEnabled()" ], [ "getEdgeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getEdgeSet()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String node1, String node2) throws IdAlreadyInUseException, ElementNotFoundException, EdgeRejectedException" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node node1, Node node2) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "nodeFactory", "org.graphstream.graph", "Graph", "NodeFactory<? extends Node> nodeFactory()" ], [ "getStep", "org.graphstream.graph", "Graph", "double getStep()" ], [ "getIndex", "org.graphstream.graph", "Element", "public abstract int getIndex()" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(String[] arg0)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException" ], [ "hasNumber", "org.graphstream.graph", "Element", "public abstract boolean hasNumber(String arg0)" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(String id)" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0, Class<T> arg1)" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(Class<T> arg0, String[] arg1)" ], [ "getId", "org.graphstream.graph", "Element", "public abstract String getId()" ], [ "nullAttributesAreErrors", "org.graphstream.graph", "Graph", "boolean nullAttributesAreErrors()" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(int index) throws IndexOutOfBoundsException" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Node node1, Node node2) throws ElementNotFoundException" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display(boolean autoLayout)" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "hasHash", "org.graphstream.graph", "Element", "public abstract boolean hasHash(String arg0)" ], [ "isStrict", "org.graphstream.graph", "Graph", "boolean isStrict()" ], [ "getEdgeCount", "org.graphstream.graph", "Structure", "public abstract int getEdgeCount()" ], [ "hasArray", "org.graphstream.graph", "Element", "public abstract boolean hasArray(String arg0)" ], [ "getNodeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getNodeIterator()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "addNode", "org.graphstream.graph", "Graph", "<T extends Node> T addNode(String id) throws IdAlreadyInUseException" ], [ "getVector", "org.graphstream.graph", "Element", "public abstract ArrayList<? extends Number> getVector(String arg0)" ], [ "getEachEdge", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachEdge()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String from, String to, boolean directed) throws IdAlreadyInUseException, ElementNotFoundException" ], [ "getAttributeKeySet", "org.graphstream.graph", "Element", "public abstract Collection<String> getAttributeKeySet()" ], [ "getArray", "org.graphstream.graph", "Element", "public abstract Object[] getArray(String arg0)" ], [ "getAttributeCount", "org.graphstream.graph", "Element", "public abstract int getAttributeCount()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String id) throws ElementNotFoundException" ], [ "elementSinks", "org.graphstream.graph", "Graph", "Iterable<ElementSink> elementSinks()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(String id) throws ElementNotFoundException" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0)" ], [ "edgeFactory", "org.graphstream.graph", "Graph", "EdgeFactory<? extends Edge> edgeFactory()" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0, Class<?> arg1)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Edge edge)" ], [ "getLabel", "org.graphstream.graph", "Element", "public abstract CharSequence getLabel(String arg0)" ], [ "getAttributeKeyIterator", "org.graphstream.graph", "Element", "public abstract Iterator<String> getAttributeKeyIterator()" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(String id)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "length", "java.lang", "String", "public int length()" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ], [ "getLeavingEdge", "org.graphstream.graph", "Node", "public abstract <T> T getLeavingEdge(int arg0)" ], [ "getEnteringEdge", "org.graphstream.graph", "Node", "public abstract <T> T getEnteringEdge(int arg0)" ], [ "getNeighborNodeIterator", "org.graphstream.graph", "Node", "public abstract <T> Iterator<T> getNeighborNodeIterator()" ], [ "getEnteringEdgeIterator", "org.graphstream.graph", "Node", "public abstract <T> Iterator<T> getEnteringEdgeIterator()" ], [ "toString", "org.graphstream.graph", "Node", "public abstract String toString()" ], [ "hasEdgeFrom", "org.graphstream.graph", "Node", "public abstract boolean hasEdgeFrom(String arg0)" ], [ "getEdgeSet", "org.graphstream.graph", "Node", "public abstract <T> Collection<T> getEdgeSet()" ], [ "getInDegree", "org.graphstream.graph", "Node", "public abstract int getInDegree()" ], [ "getEachLeavingEdge", "org.graphstream.graph", "Node", "public abstract <T> Iterable<T> getEachLeavingEdge()" ], [ "getEdgeToward", "org.graphstream.graph", "Node", "public abstract <T> T getEdgeToward(Node arg0)" ], [ "getEdgeBetween", "org.graphstream.graph", "Node", "public abstract <T> T getEdgeBetween(int arg0) throws IndexOutOfBoundsException" ], [ "getEdgeToward", "org.graphstream.graph", "Node", "public abstract <T> T getEdgeToward(int arg0) throws IndexOutOfBoundsException" ], [ "getEdgeFrom", "org.graphstream.graph", "Node", "public abstract <T> T getEdgeFrom(String arg0)" ], [ "getOutDegree", "org.graphstream.graph", "Node", "public abstract int getOutDegree()" ], [ "getEnteringEdgeSet", "org.graphstream.graph", "Node", "public abstract <T> Collection<T> getEnteringEdgeSet()" ], [ "getDepthFirstIterator", "org.graphstream.graph", "Node", "public abstract <T> Iterator<T> getDepthFirstIterator()" ], [ "getEdgeToward", "org.graphstream.graph", "Node", "public abstract <T> T getEdgeToward(String arg0)" ], [ "getEdgeFrom", "org.graphstream.graph", "Node", "public abstract <T> T getEdgeFrom(int arg0) throws IndexOutOfBoundsException" ], [ "hasEdgeBetween", "org.graphstream.graph", "Node", "public abstract boolean hasEdgeBetween(String arg0)" ], [ "hasEdgeToward", "org.graphstream.graph", "Node", "public abstract boolean hasEdgeToward(Node arg0)" ], [ "hasEdgeToward", "org.graphstream.graph", "Node", "public abstract boolean hasEdgeToward(String arg0)" ], [ "hasEdgeFrom", "org.graphstream.graph", "Node", "public abstract boolean hasEdgeFrom(Node arg0)" ], [ "getDegree", "org.graphstream.graph", "Node", "public abstract int getDegree()" ], [ "getLeavingEdgeSet", "org.graphstream.graph", "Node", "public abstract <T> Collection<T> getLeavingEdgeSet()" ], [ "getEdgeIterator", "org.graphstream.graph", "Node", "public abstract <T> Iterator<T> getEdgeIterator()" ], [ "getBreadthFirstIterator", "org.graphstream.graph", "Node", "public abstract <T> Iterator<T> getBreadthFirstIterator()" ], [ "getDepthFirstIterator", "org.graphstream.graph", "Node", "public abstract <T> Iterator<T> getDepthFirstIterator(boolean arg0)" ], [ "getEdge", "org.graphstream.graph", "Node", "public abstract <T> T getEdge(int arg0)" ], [ "hasEdgeFrom", "org.graphstream.graph", "Node", "public abstract boolean hasEdgeFrom(int arg0) throws IndexOutOfBoundsException" ], [ "hasEdgeBetween", "org.graphstream.graph", "Node", "public abstract boolean hasEdgeBetween(Node arg0)" ], [ "getEachEdge", "org.graphstream.graph", "Node", "public abstract <T> Iterable<T> getEachEdge()" ], [ "hasEdgeToward", "org.graphstream.graph", "Node", "public abstract boolean hasEdgeToward(int arg0) throws IndexOutOfBoundsException" ], [ "getEdgeBetween", "org.graphstream.graph", "Node", "public abstract <T> T getEdgeBetween(String arg0)" ], [ "getGraph", "org.graphstream.graph", "Node", "public abstract Graph getGraph()" ], [ "getEdgeBetween", "org.graphstream.graph", "Node", "public abstract <T> T getEdgeBetween(Node arg0)" ], [ "getBreadthFirstIterator", "org.graphstream.graph", "Node", "public abstract <T> Iterator<T> getBreadthFirstIterator(boolean arg0)" ], [ "getEdgeFrom", "org.graphstream.graph", "Node", "public abstract <T> T getEdgeFrom(Node arg0)" ], [ "getLeavingEdgeIterator", "org.graphstream.graph", "Node", "public abstract <T> Iterator<T> getLeavingEdgeIterator()" ], [ "getEachEnteringEdge", "org.graphstream.graph", "Node", "public abstract <T> Iterable<T> getEachEnteringEdge()" ], [ "hasEdgeBetween", "org.graphstream.graph", "Node", "public abstract boolean hasEdgeBetween(int arg0) throws IndexOutOfBoundsException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 4196,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.graph",
  "className" : "Graph",
  "javadocTag" : "@throws IdAlreadyInUseException If an edge with the same id already exists and strict\n            checking is enabled.",
  "methodJavadoc" : "    /**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the node\n\t * references are given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param from\n\t *            The first node\n\t * @param to\n\t *            The second node\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */",
  "methodSourceCode" : "<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed) throws IdAlreadyInUseException, EdgeRejectedException;",
  "classJavadoc" : "/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.graph;\n\nimport java.io.IOException;\n\nimport org.graphstream.stream.AttributeSink;\nimport org.graphstream.stream.ElementSink;\nimport org.graphstream.stream.GraphParseException;\nimport org.graphstream.stream.Pipe;\nimport org.graphstream.stream.file.FileSink;\nimport org.graphstream.stream.file.FileSource;\nimport org.graphstream.ui.view.Viewer;\n\n\n/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */\npublic interface Graph extends Element, Pipe, Iterable<Node>, Structure {\n\t// Access\n\n\t/**\n\t * Get a node by its identifier. This method is implicitly generic and\n\t * returns something which extends Node. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param id\n\t *            Identifier of the node to find.\n\t * @return The searched node or null if not found.\n\t */\n\t<T extends Node> T getNode(String id);\n\n\t/**\n\t * Get an edge by its identifier. This method is implicitly generic and\n\t * returns something which extends Edge. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param id\n\t *            Identifier of the edge to find.\n\t * @return The searched edge or null if not found.\n\t */\n\t<T extends Edge> T getEdge(String id);\n\n\t/**\n\t * The factory used to create node instances. The factory can be changed to\n\t * refine the node class generated for this graph.\n\t * \n\t * @see #setNodeFactory(NodeFactory)\n\t * @see #edgeFactory()\n\t */\n\tNodeFactory<? extends Node> nodeFactory();\n\n\t/**\n\t * The factory used to create edge instances. The factory can be changed to\n\t * refine the edge class generated for this graph.\n\t * \n\t * @see #setEdgeFactory(EdgeFactory)\n\t * @see #nodeFactory()\n\t */\n\tEdgeFactory<? extends Edge> edgeFactory();\n\n\t/**\n\t * Is strict checking enabled? If strict checking is enabled the graph\n\t * checks for name space conflicts (e.g. insertion of two nodes with the\n\t * same name), removal of non-existing elements, use of non existing\n\t * elements (create an edge between two non existing nodes). Graph\n\t * implementations are free to respect strict checking or not.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isStrict();\n\n\t/**\n\t * Is the automatic creation of missing elements enabled?. If strict\n\t * checking is disabled and auto-creation is enabled, when an edge is\n\t * created and one or two of its nodes are not already present in the graph,\n\t * the nodes are automatically created.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isAutoCreationEnabled();\n\n\t/**\n\t * If true, when accessing an attribute that does not exist (or is not of\n\t * the expected type), a {@link NullAttributeException} is thrown. Else null\n\t * is returned.\n\t * \n\t * @return True if exceptions must be thrown when accessing a null\n\t *         attribute.\n\t */\n\tboolean nullAttributesAreErrors();\n\n\t/**\n\t * The current step.\n\t * \n\t * @return The step.\n\t */\n\tdouble getStep();\n\n\t// Command\n\n\t/**\n\t * Should a {@link NullAttributeException} be thrown when one tries to\n\t * access a non existing attribute, or an attribute whose type is not the\n\t * expected one?.\n\t * \n\t * @param on\n\t *            if true, exceptions will be thrown when accessing a non\n\t *            existing attribute.\n\t */\n\tvoid setNullAttributesAreErrors(boolean on);\n\n\t/**\n\t * Set the node factory used to create nodes.\n\t * \n\t * @param nf\n\t *            the new NodeFactory\n\t */\n\tvoid setNodeFactory(NodeFactory<? extends Node> nf);\n\n\t/**\n\t * Set the edge factory used to create edges.\n\t * \n\t * @param ef\n\t *            the new EdgeFactory\n\t */\n\tvoid setEdgeFactory(EdgeFactory<? extends Edge> ef);\n\n\t/**\n\t * Enable or disable strict checking.\n\t * \n\t * @see #isStrict()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setStrict(boolean on);\n\n\t/**\n\t * Enable or disable the automatic creation of missing elements.\n\t * \n\t * @see #isAutoCreationEnabled()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setAutoCreate(boolean on);\n\n\t// Graph construction\n\n\t/**\n\t * Empty the graph completely by removing any references to nodes or edges.\n\t * Every attribute is also removed. However, listeners are kept.\n\t * \n\t * @see #clearSinks()\n\t */\n\tvoid clear();\n\n\t/**\n\t * Add a node in the graph.\n\t * <p>\n\t * This acts as a factory, creating the node instance automatically (and\n\t * eventually using the node factory provided). An event is generated toward\n\t * the listeners. If strict checking is enabled, and a node already exists\n\t * with this identifier, an\n\t * {@link org.graphstream.graph.IdAlreadyInUseException} is raised. Else the\n\t * error is silently ignored and the already existing node is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.addNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            Arbitrary and unique string identifying the node.\n\t * @return The created node (or the already existing node).\n\t * @throws IdAlreadyInUseException\n\t *             If strict checking is enabled the identifier is already used.\n\t */\n\t<T extends Node> T addNode(String id) throws IdAlreadyInUseException;\n\n\t/**\n\t * Remove a node using its identifier.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            The unique identifier of the node to remove.\n\t * @return The removed node. If strict checking is disabled, it can return\n\t *         null if the node to remove does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no node matches the given identifier and strict checking\n\t *             is enabled.\n\t */\n\t<T extends Node> T removeNode(String id) throws ElementNotFoundException;\n\n\t/**\n\t * Adds an undirected edge between nodes.\n\t * \n\t * <p>\n\t * The behavior of this method depends on many conditions. It can be\n\t * summarized as follows.\n\t * </p>\n\t * \n\t * <p>\n\t * First of all, the method checks if the graph already contains an edge\n\t * with the same id. If this is the case and strict checking is enabled,\n\t * {@code IdAlreadyInUseException} is thrown. If the strict checking is\n\t * disabled the method returns a reference to the existing edge if it has\n\t * endpoints {@code node1} and {@code node2} (in the same order if the edge\n\t * is directed) or {@code null} otherwise.\n\t * </p>\n\t * \n\t * <p>\n\t * In the case when the graph does not contain an edge with the same id, the\n\t * method checks if {@code node1} and {@code node2} exist. If one or both of\n\t * them do not exist, and strict checking is enabled, {@code\n\t * ElementNotFoundException} is thrown. Otherwise if auto-creation is\n\t * disabled, the method returns {@code null}. If auto-creation is enabled,\n\t * the method creates the missing endpoints.\n\t * \n\t * <p>\n\t * When the edge id is not already in use and the both endpoints exist (or\n\t * created), the edge can still be rejected. It may happen for example when\n\t * it connects two already connected nodes in a single graph. If the edge is\n\t * rejected, the method throws {@code EdgeRejectedException} if strict\n\t * checking is enabled or returns {@code null} otherwise. Finally, if the\n\t * edge is accepted, it is created using the corresponding edge factory and\n\t * a reference to it is returned.\n\t * \n\t * <p>\n\t * An edge creation event is sent toward the listeners. If new nodes are\n\t * created, the corresponding events are also sent to the listeners.\n\t * </p>\n\t * \n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.addEdge(&quot;...&quot;, &quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * \n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t */\n\t<T extends Edge> T addEdge(String id, String node1, String node2)\n\t\t\tthrows IdAlreadyInUseException, ElementNotFoundException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)}, but this edge can be\n\t * directed between the two given nodes. If directed, the edge goes in the\n\t * 'from' -&gt; 'to' direction. An event is sent toward the listeners.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, String from, String to,\n\t\t\tboolean directed) throws IdAlreadyInUseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Remove an edge given the identifiers of its two endpoints.\n\t * <p>\n\t * If the edge is directed it is removed only if its source and destination\n\t * nodes are identified by 'from' and 'to' respectively. If the graph is a\n\t * multi-graph and there are several edges between the two nodes, one of the\n\t * edges at random is removed. An event is sent toward the listeners. If\n\t * strict checking is enabled and at least one of the two given nodes does\n\t * not exist or if they are not connected, a not found exception is raised.\n\t * Else the error is silently ignored, and null is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param from\n\t *            The origin node identifier to select the edge.\n\t * @param to\n\t *            The destination node identifier to select the edge.\n\t * @return The removed edge, or null if strict checking is disabled and at\n\t *         least one of the two given nodes does not exist or there is no\n\t *         edge between them\n\t * @throws ElementNotFoundException\n\t *             If the 'from' or 'to' node is not registered in the graph or\n\t *             not connected and strict checking is enabled.\n\t */\n\t<T extends Edge> T removeEdge(String from, String to)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge knowing its identifier. An event is sent toward the\n\t * listeners. If strict checking is enabled and the edge does not exist,\n\t * {@code ElementNotFoundException} is raised. Otherwise the error is\n\t * silently ignored and null is returned.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Identifier of the edge to remove.\n\t * @return The removed edge, or null if strict checking is disabled and the\n\t *         edge does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no edge matches the identifier and strict checking is\n\t *             enabled.\n\t */\n\t<T extends Edge> T removeEdge(String id) throws ElementNotFoundException;\n\n\t/**\n\t * <p>\n\t * Since dynamic graphs are based on discrete event modifications, the\n\t * notion of step is defined to simulate elapsed time between events. So a\n\t * step is a event that occurs in the graph, it does not modify it but it\n\t * gives a kind of timestamp that allows the tracking of the progress of the\n\t * graph over the time.\n\t * </p>\n\t * <p>\n\t * This kind of event is useful for dynamic algorithms that listen to the\n\t * dynamic graph and need to measure the time in the graph's evolution.\n\t * </p>\n\t * \n\t * @param time\n\t *            A numerical value that may give a timestamp to track the\n\t *            evolution of the graph over the time.\n\t */\n\tvoid stepBegins(double time);\n\n\t// Source\n\t// XXX do we put the iterable attributeSinks and elementSinks in Source ?\n\n\t/**\n\t * Returns an \"iterable\" of {@link AttributeSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the set of {@link AttributeSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<AttributeSink> attributeSinks();\n\n\t/**\n\t * Returns an \"iterable\" of {@link ElementSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the list of {@link ElementSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<ElementSink> elementSinks();\n\n\t// Utility shortcuts (should be mixins or traits, what are you doing Mr Java\n\t// ?)\n\t// XXX use a Readable/Writable/Displayable interface for this ?\n\n\t/**\n\t * Utility method to read a graph. This method tries to identify the graph\n\t * format by itself and instantiates the corresponding reader automatically.\n\t * If this process fails, a NotFoundException is raised.\n\t * \n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognized.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input output error occurs during the graph reading.\n\t */\n\tvoid read(String filename) throws IOException, GraphParseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Utility method to read a graph using the given reader.\n\t * \n\t * @param input\n\t *            An appropriate reader for the filename.\n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognised.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph reading.\n\t */\n\tvoid read(FileSource input, String filename) throws IOException,\n\t\t\tGraphParseException;\n\n\t/**\n\t * Utility method to write a graph in DGS format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(String filename) throws IOException;\n\n\t/**\n\t * Utility method to write a graph in the chosen format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @param output\n\t *            The output format to use.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(FileSink output, String filename) throws IOException;\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but may be limited. This method\n\t * automatically launch a graph layout algorithm in its own thread to\n\t * compute best node positions.\n\t * \n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display(boolean )\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display();\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but is very limited.\n\t * \n\t * @param autoLayout\n\t *            If true a layout algorithm is launched in its own thread to\n\t *            compute best node positions.\n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display()\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display(boolean autoLayout);\n\n\t// New methods\n\n\t/**\n\t * Get a node by its index. This method is implicitly generic and returns\n\t * something which extends Node. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param index\n\t *            Index of the node to find.\n\t * @return The node with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             If the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T getNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Get an edge by its index. This method is implicitly generic and returns\n\t * something which extends Edge. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param index\n\t *            The index of the edge to find.\n\t * @return The edge with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is less than 0 or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param index1\n\t *            The first node index\n\t * @param index2\n\t *            The second node index\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int index1, int index2)\n\t\t\tthrows IndexOutOfBoundsException, IdAlreadyInUseException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param toIndex\n\t *            The first node index\n\t * @param fromIndex\n\t *            The second node index\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int fromIndex, int toIndex,\n\t\t\tboolean directed) throws IndexOutOfBoundsException,\n\t\t\tIdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the node references are\n\t * given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node\n\t * @param node2\n\t *            The second node\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node node1, Node node2)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the node\n\t * references are given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param from\n\t *            The first node\n\t * @param to\n\t *            The second node\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Removes an edge with a given index. An event is sent toward the\n\t * listeners.\n\t * \n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.removeEdge(i);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the edge to be removed.\n\t * @return The removed edge\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getEdgeCount() - 1}\n\t */\n\t<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but the nodes are identified by their\n\t * indices.\n\t * \n\t * @param fromIndex\n\t *            the index of the source node\n\t * @param toIndex\n\t *            the index of the target node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws IndexOutOfBoundsException\n\t *             If one of the node indices is negative or greater than\n\t *             {@code getNodeCount() - 1}.\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(int fromIndex, int toIndex)\n\t\t\tthrows IndexOutOfBoundsException, ElementNotFoundException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but node references are given instead\n\t * of node identifiers.\n\t * \n\t * @param node1\n\t *            the first node\n\t * @param node2\n\t *            the second node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(Node node1, Node node2)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge. An event is sent toward the listeners.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * \n\t * \n\t * @param edge\n\t *            The edge to be removed\n\t * @return The removed edge\n\t */\n\t<T extends Edge> T removeEdge(Edge edge);\n\n\t/**\n\t * Removes a node with a given index.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the node to be removed\n\t * @return The removed node\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes a node.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param node\n\t *            The node to be removed\n\t * @return The removed node\n\t */\n\t<T extends Node> T removeNode(Node node);\n}",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "id", "java.lang", "String" ], [ "from", "org.graphstream.graph", "Node" ], [ "to", "org.graphstream.graph", "Node" ], [ "directed", "", "boolean" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getAttributeKeyIterator", "org.graphstream.graph", "Element", "public abstract Iterator<String> getAttributeKeyIterator()" ], [ "hasNumber", "org.graphstream.graph", "Element", "public abstract boolean hasNumber(String arg0)" ], [ "getStep", "org.graphstream.graph", "Graph", "double getStep()" ], [ "getIndex", "org.graphstream.graph", "Element", "public abstract int getIndex()" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(Class<T> arg0, String[] arg1)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "getEdgeCount", "org.graphstream.graph", "Structure", "public abstract int getEdgeCount()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String node1, String node2) throws IdAlreadyInUseException, ElementNotFoundException, EdgeRejectedException" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(Node node)" ], [ "getHash", "org.graphstream.graph", "Element", "public abstract HashMap<?, ?> getHash(String arg0)" ], [ "getArray", "org.graphstream.graph", "Element", "public abstract Object[] getArray(String arg0)" ], [ "getEachEdge", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachEdge()" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0, Class<?> arg1)" ], [ "edgeFactory", "org.graphstream.graph", "Graph", "EdgeFactory<? extends Edge> edgeFactory()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node node1, Node node2) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int fromIndex, int toIndex) throws IndexOutOfBoundsException, ElementNotFoundException" ], [ "hasVector", "org.graphstream.graph", "Element", "public abstract boolean hasVector(String arg0)" ], [ "getId", "org.graphstream.graph", "Element", "public abstract String getId()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String id) throws ElementNotFoundException" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Edge edge)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String from, String to) throws ElementNotFoundException" ], [ "getVector", "org.graphstream.graph", "Element", "public abstract ArrayList<? extends Number> getVector(String arg0)" ], [ "hasHash", "org.graphstream.graph", "Element", "public abstract boolean hasHash(String arg0)" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0)" ], [ "nullAttributesAreErrors", "org.graphstream.graph", "Graph", "boolean nullAttributesAreErrors()" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int index1, int index2) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "elementSinks", "org.graphstream.graph", "Graph", "Iterable<ElementSink> elementSinks()" ], [ "hasArray", "org.graphstream.graph", "Element", "public abstract boolean hasArray(String arg0)" ], [ "addNode", "org.graphstream.graph", "Graph", "<T extends Node> T addNode(String id) throws IdAlreadyInUseException" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(String id)" ], [ "getEachAttributeKey", "org.graphstream.graph", "Element", "public abstract Iterable<String> getEachAttributeKey()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(String id)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException" ], [ "getNodeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getNodeSet()" ], [ "getAttributeCount", "org.graphstream.graph", "Element", "public abstract int getAttributeCount()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int fromIndex, int toIndex, boolean directed) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "isStrict", "org.graphstream.graph", "Graph", "boolean isStrict()" ], [ "hasLabel", "org.graphstream.graph", "Element", "public abstract boolean hasLabel(String arg0)" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display()" ], [ "getEachNode", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachNode()" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display(boolean autoLayout)" ], [ "getNodeCount", "org.graphstream.graph", "Structure", "public abstract int getNodeCount()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Node node1, Node node2) throws ElementNotFoundException" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String from, String to, boolean directed) throws IdAlreadyInUseException, ElementNotFoundException" ], [ "getNumber", "org.graphstream.graph", "Element", "public abstract double getNumber(String arg0)" ], [ "getNodeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getNodeIterator()" ], [ "getEdgeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getEdgeIterator()" ], [ "isAutoCreationEnabled", "org.graphstream.graph", "Graph", "boolean isAutoCreationEnabled()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(String id) throws ElementNotFoundException" ], [ "getAttributeKeySet", "org.graphstream.graph", "Element", "public abstract Collection<String> getAttributeKeySet()" ], [ "attributeSinks", "org.graphstream.graph", "Graph", "Iterable<AttributeSink> attributeSinks()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0, Class<T> arg1)" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(String[] arg0)" ], [ "nodeFactory", "org.graphstream.graph", "Graph", "NodeFactory<? extends Node> nodeFactory()" ], [ "getEdgeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getEdgeSet()" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(int index) throws IndexOutOfBoundsException" ], [ "getLabel", "org.graphstream.graph", "Element", "public abstract CharSequence getLabel(String arg0)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "length", "java.lang", "String", "public int length()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ], [ "hasEdgeToward", "org.graphstream.graph", "Node", "public abstract boolean hasEdgeToward(String arg0)" ], [ "getBreadthFirstIterator", "org.graphstream.graph", "Node", "public abstract <T> Iterator<T> getBreadthFirstIterator(boolean arg0)" ], [ "getEdgeBetween", "org.graphstream.graph", "Node", "public abstract <T> T getEdgeBetween(String arg0)" ], [ "hasEdgeFrom", "org.graphstream.graph", "Node", "public abstract boolean hasEdgeFrom(Node arg0)" ], [ "getEnteringEdgeSet", "org.graphstream.graph", "Node", "public abstract <T> Collection<T> getEnteringEdgeSet()" ], [ "getDepthFirstIterator", "org.graphstream.graph", "Node", "public abstract <T> Iterator<T> getDepthFirstIterator(boolean arg0)" ], [ "hasEdgeBetween", "org.graphstream.graph", "Node", "public abstract boolean hasEdgeBetween(Node arg0)" ], [ "getNeighborNodeIterator", "org.graphstream.graph", "Node", "public abstract <T> Iterator<T> getNeighborNodeIterator()" ], [ "hasEdgeBetween", "org.graphstream.graph", "Node", "public abstract boolean hasEdgeBetween(String arg0)" ], [ "getLeavingEdge", "org.graphstream.graph", "Node", "public abstract <T> T getLeavingEdge(int arg0)" ], [ "getEdgeFrom", "org.graphstream.graph", "Node", "public abstract <T> T getEdgeFrom(String arg0)" ], [ "getEdgeIterator", "org.graphstream.graph", "Node", "public abstract <T> Iterator<T> getEdgeIterator()" ], [ "hasEdgeBetween", "org.graphstream.graph", "Node", "public abstract boolean hasEdgeBetween(int arg0) throws IndexOutOfBoundsException" ], [ "getLeavingEdgeIterator", "org.graphstream.graph", "Node", "public abstract <T> Iterator<T> getLeavingEdgeIterator()" ], [ "getEnteringEdge", "org.graphstream.graph", "Node", "public abstract <T> T getEnteringEdge(int arg0)" ], [ "toString", "org.graphstream.graph", "Node", "public abstract String toString()" ], [ "hasEdgeToward", "org.graphstream.graph", "Node", "public abstract boolean hasEdgeToward(Node arg0)" ], [ "getEdgeBetween", "org.graphstream.graph", "Node", "public abstract <T> T getEdgeBetween(int arg0) throws IndexOutOfBoundsException" ], [ "getEachEdge", "org.graphstream.graph", "Node", "public abstract <T> Iterable<T> getEachEdge()" ], [ "hasEdgeFrom", "org.graphstream.graph", "Node", "public abstract boolean hasEdgeFrom(String arg0)" ], [ "getEdgeToward", "org.graphstream.graph", "Node", "public abstract <T> T getEdgeToward(Node arg0)" ], [ "getEdge", "org.graphstream.graph", "Node", "public abstract <T> T getEdge(int arg0)" ], [ "getDepthFirstIterator", "org.graphstream.graph", "Node", "public abstract <T> Iterator<T> getDepthFirstIterator()" ], [ "getLeavingEdgeSet", "org.graphstream.graph", "Node", "public abstract <T> Collection<T> getLeavingEdgeSet()" ], [ "getEdgeFrom", "org.graphstream.graph", "Node", "public abstract <T> T getEdgeFrom(Node arg0)" ], [ "getEnteringEdgeIterator", "org.graphstream.graph", "Node", "public abstract <T> Iterator<T> getEnteringEdgeIterator()" ], [ "hasEdgeToward", "org.graphstream.graph", "Node", "public abstract boolean hasEdgeToward(int arg0) throws IndexOutOfBoundsException" ], [ "getEdgeSet", "org.graphstream.graph", "Node", "public abstract <T> Collection<T> getEdgeSet()" ], [ "getGraph", "org.graphstream.graph", "Node", "public abstract Graph getGraph()" ], [ "getOutDegree", "org.graphstream.graph", "Node", "public abstract int getOutDegree()" ], [ "hasEdgeFrom", "org.graphstream.graph", "Node", "public abstract boolean hasEdgeFrom(int arg0) throws IndexOutOfBoundsException" ], [ "getDegree", "org.graphstream.graph", "Node", "public abstract int getDegree()" ], [ "getEdgeBetween", "org.graphstream.graph", "Node", "public abstract <T> T getEdgeBetween(Node arg0)" ], [ "getInDegree", "org.graphstream.graph", "Node", "public abstract int getInDegree()" ], [ "getEachLeavingEdge", "org.graphstream.graph", "Node", "public abstract <T> Iterable<T> getEachLeavingEdge()" ], [ "getEachEnteringEdge", "org.graphstream.graph", "Node", "public abstract <T> Iterable<T> getEachEnteringEdge()" ], [ "getEdgeToward", "org.graphstream.graph", "Node", "public abstract <T> T getEdgeToward(int arg0) throws IndexOutOfBoundsException" ], [ "getEdgeFrom", "org.graphstream.graph", "Node", "public abstract <T> T getEdgeFrom(int arg0) throws IndexOutOfBoundsException" ], [ "getEdgeToward", "org.graphstream.graph", "Node", "public abstract <T> T getEdgeToward(String arg0)" ], [ "getBreadthFirstIterator", "org.graphstream.graph", "Node", "public abstract <T> Iterator<T> getBreadthFirstIterator()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 4200,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.graph",
  "className" : "Graph",
  "javadocTag" : "@throws IndexOutOfBoundsException if the index is negative or greater than {@code\n            getEdgeCount() - 1}",
  "methodJavadoc" : "    /**\n\t * Removes an edge with a given index. An event is sent toward the\n\t * listeners.\n\t * \n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.removeEdge(i);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the edge to be removed.\n\t * @return The removed edge\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getEdgeCount() - 1}\n\t */",
  "methodSourceCode" : "<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException;",
  "classJavadoc" : "/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.graph;\n\nimport java.io.IOException;\n\nimport org.graphstream.stream.AttributeSink;\nimport org.graphstream.stream.ElementSink;\nimport org.graphstream.stream.GraphParseException;\nimport org.graphstream.stream.Pipe;\nimport org.graphstream.stream.file.FileSink;\nimport org.graphstream.stream.file.FileSource;\nimport org.graphstream.ui.view.Viewer;\n\n\n/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */\npublic interface Graph extends Element, Pipe, Iterable<Node>, Structure {\n\t// Access\n\n\t/**\n\t * Get a node by its identifier. This method is implicitly generic and\n\t * returns something which extends Node. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param id\n\t *            Identifier of the node to find.\n\t * @return The searched node or null if not found.\n\t */\n\t<T extends Node> T getNode(String id);\n\n\t/**\n\t * Get an edge by its identifier. This method is implicitly generic and\n\t * returns something which extends Edge. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param id\n\t *            Identifier of the edge to find.\n\t * @return The searched edge or null if not found.\n\t */\n\t<T extends Edge> T getEdge(String id);\n\n\t/**\n\t * The factory used to create node instances. The factory can be changed to\n\t * refine the node class generated for this graph.\n\t * \n\t * @see #setNodeFactory(NodeFactory)\n\t * @see #edgeFactory()\n\t */\n\tNodeFactory<? extends Node> nodeFactory();\n\n\t/**\n\t * The factory used to create edge instances. The factory can be changed to\n\t * refine the edge class generated for this graph.\n\t * \n\t * @see #setEdgeFactory(EdgeFactory)\n\t * @see #nodeFactory()\n\t */\n\tEdgeFactory<? extends Edge> edgeFactory();\n\n\t/**\n\t * Is strict checking enabled? If strict checking is enabled the graph\n\t * checks for name space conflicts (e.g. insertion of two nodes with the\n\t * same name), removal of non-existing elements, use of non existing\n\t * elements (create an edge between two non existing nodes). Graph\n\t * implementations are free to respect strict checking or not.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isStrict();\n\n\t/**\n\t * Is the automatic creation of missing elements enabled?. If strict\n\t * checking is disabled and auto-creation is enabled, when an edge is\n\t * created and one or two of its nodes are not already present in the graph,\n\t * the nodes are automatically created.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isAutoCreationEnabled();\n\n\t/**\n\t * If true, when accessing an attribute that does not exist (or is not of\n\t * the expected type), a {@link NullAttributeException} is thrown. Else null\n\t * is returned.\n\t * \n\t * @return True if exceptions must be thrown when accessing a null\n\t *         attribute.\n\t */\n\tboolean nullAttributesAreErrors();\n\n\t/**\n\t * The current step.\n\t * \n\t * @return The step.\n\t */\n\tdouble getStep();\n\n\t// Command\n\n\t/**\n\t * Should a {@link NullAttributeException} be thrown when one tries to\n\t * access a non existing attribute, or an attribute whose type is not the\n\t * expected one?.\n\t * \n\t * @param on\n\t *            if true, exceptions will be thrown when accessing a non\n\t *            existing attribute.\n\t */\n\tvoid setNullAttributesAreErrors(boolean on);\n\n\t/**\n\t * Set the node factory used to create nodes.\n\t * \n\t * @param nf\n\t *            the new NodeFactory\n\t */\n\tvoid setNodeFactory(NodeFactory<? extends Node> nf);\n\n\t/**\n\t * Set the edge factory used to create edges.\n\t * \n\t * @param ef\n\t *            the new EdgeFactory\n\t */\n\tvoid setEdgeFactory(EdgeFactory<? extends Edge> ef);\n\n\t/**\n\t * Enable or disable strict checking.\n\t * \n\t * @see #isStrict()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setStrict(boolean on);\n\n\t/**\n\t * Enable or disable the automatic creation of missing elements.\n\t * \n\t * @see #isAutoCreationEnabled()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setAutoCreate(boolean on);\n\n\t// Graph construction\n\n\t/**\n\t * Empty the graph completely by removing any references to nodes or edges.\n\t * Every attribute is also removed. However, listeners are kept.\n\t * \n\t * @see #clearSinks()\n\t */\n\tvoid clear();\n\n\t/**\n\t * Add a node in the graph.\n\t * <p>\n\t * This acts as a factory, creating the node instance automatically (and\n\t * eventually using the node factory provided). An event is generated toward\n\t * the listeners. If strict checking is enabled, and a node already exists\n\t * with this identifier, an\n\t * {@link org.graphstream.graph.IdAlreadyInUseException} is raised. Else the\n\t * error is silently ignored and the already existing node is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.addNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            Arbitrary and unique string identifying the node.\n\t * @return The created node (or the already existing node).\n\t * @throws IdAlreadyInUseException\n\t *             If strict checking is enabled the identifier is already used.\n\t */\n\t<T extends Node> T addNode(String id) throws IdAlreadyInUseException;\n\n\t/**\n\t * Remove a node using its identifier.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            The unique identifier of the node to remove.\n\t * @return The removed node. If strict checking is disabled, it can return\n\t *         null if the node to remove does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no node matches the given identifier and strict checking\n\t *             is enabled.\n\t */\n\t<T extends Node> T removeNode(String id) throws ElementNotFoundException;\n\n\t/**\n\t * Adds an undirected edge between nodes.\n\t * \n\t * <p>\n\t * The behavior of this method depends on many conditions. It can be\n\t * summarized as follows.\n\t * </p>\n\t * \n\t * <p>\n\t * First of all, the method checks if the graph already contains an edge\n\t * with the same id. If this is the case and strict checking is enabled,\n\t * {@code IdAlreadyInUseException} is thrown. If the strict checking is\n\t * disabled the method returns a reference to the existing edge if it has\n\t * endpoints {@code node1} and {@code node2} (in the same order if the edge\n\t * is directed) or {@code null} otherwise.\n\t * </p>\n\t * \n\t * <p>\n\t * In the case when the graph does not contain an edge with the same id, the\n\t * method checks if {@code node1} and {@code node2} exist. If one or both of\n\t * them do not exist, and strict checking is enabled, {@code\n\t * ElementNotFoundException} is thrown. Otherwise if auto-creation is\n\t * disabled, the method returns {@code null}. If auto-creation is enabled,\n\t * the method creates the missing endpoints.\n\t * \n\t * <p>\n\t * When the edge id is not already in use and the both endpoints exist (or\n\t * created), the edge can still be rejected. It may happen for example when\n\t * it connects two already connected nodes in a single graph. If the edge is\n\t * rejected, the method throws {@code EdgeRejectedException} if strict\n\t * checking is enabled or returns {@code null} otherwise. Finally, if the\n\t * edge is accepted, it is created using the corresponding edge factory and\n\t * a reference to it is returned.\n\t * \n\t * <p>\n\t * An edge creation event is sent toward the listeners. If new nodes are\n\t * created, the corresponding events are also sent to the listeners.\n\t * </p>\n\t * \n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.addEdge(&quot;...&quot;, &quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * \n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t */\n\t<T extends Edge> T addEdge(String id, String node1, String node2)\n\t\t\tthrows IdAlreadyInUseException, ElementNotFoundException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)}, but this edge can be\n\t * directed between the two given nodes. If directed, the edge goes in the\n\t * 'from' -&gt; 'to' direction. An event is sent toward the listeners.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, String from, String to,\n\t\t\tboolean directed) throws IdAlreadyInUseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Remove an edge given the identifiers of its two endpoints.\n\t * <p>\n\t * If the edge is directed it is removed only if its source and destination\n\t * nodes are identified by 'from' and 'to' respectively. If the graph is a\n\t * multi-graph and there are several edges between the two nodes, one of the\n\t * edges at random is removed. An event is sent toward the listeners. If\n\t * strict checking is enabled and at least one of the two given nodes does\n\t * not exist or if they are not connected, a not found exception is raised.\n\t * Else the error is silently ignored, and null is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param from\n\t *            The origin node identifier to select the edge.\n\t * @param to\n\t *            The destination node identifier to select the edge.\n\t * @return The removed edge, or null if strict checking is disabled and at\n\t *         least one of the two given nodes does not exist or there is no\n\t *         edge between them\n\t * @throws ElementNotFoundException\n\t *             If the 'from' or 'to' node is not registered in the graph or\n\t *             not connected and strict checking is enabled.\n\t */\n\t<T extends Edge> T removeEdge(String from, String to)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge knowing its identifier. An event is sent toward the\n\t * listeners. If strict checking is enabled and the edge does not exist,\n\t * {@code ElementNotFoundException} is raised. Otherwise the error is\n\t * silently ignored and null is returned.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Identifier of the edge to remove.\n\t * @return The removed edge, or null if strict checking is disabled and the\n\t *         edge does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no edge matches the identifier and strict checking is\n\t *             enabled.\n\t */\n\t<T extends Edge> T removeEdge(String id) throws ElementNotFoundException;\n\n\t/**\n\t * <p>\n\t * Since dynamic graphs are based on discrete event modifications, the\n\t * notion of step is defined to simulate elapsed time between events. So a\n\t * step is a event that occurs in the graph, it does not modify it but it\n\t * gives a kind of timestamp that allows the tracking of the progress of the\n\t * graph over the time.\n\t * </p>\n\t * <p>\n\t * This kind of event is useful for dynamic algorithms that listen to the\n\t * dynamic graph and need to measure the time in the graph's evolution.\n\t * </p>\n\t * \n\t * @param time\n\t *            A numerical value that may give a timestamp to track the\n\t *            evolution of the graph over the time.\n\t */\n\tvoid stepBegins(double time);\n\n\t// Source\n\t// XXX do we put the iterable attributeSinks and elementSinks in Source ?\n\n\t/**\n\t * Returns an \"iterable\" of {@link AttributeSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the set of {@link AttributeSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<AttributeSink> attributeSinks();\n\n\t/**\n\t * Returns an \"iterable\" of {@link ElementSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the list of {@link ElementSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<ElementSink> elementSinks();\n\n\t// Utility shortcuts (should be mixins or traits, what are you doing Mr Java\n\t// ?)\n\t// XXX use a Readable/Writable/Displayable interface for this ?\n\n\t/**\n\t * Utility method to read a graph. This method tries to identify the graph\n\t * format by itself and instantiates the corresponding reader automatically.\n\t * If this process fails, a NotFoundException is raised.\n\t * \n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognized.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input output error occurs during the graph reading.\n\t */\n\tvoid read(String filename) throws IOException, GraphParseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Utility method to read a graph using the given reader.\n\t * \n\t * @param input\n\t *            An appropriate reader for the filename.\n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognised.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph reading.\n\t */\n\tvoid read(FileSource input, String filename) throws IOException,\n\t\t\tGraphParseException;\n\n\t/**\n\t * Utility method to write a graph in DGS format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(String filename) throws IOException;\n\n\t/**\n\t * Utility method to write a graph in the chosen format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @param output\n\t *            The output format to use.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(FileSink output, String filename) throws IOException;\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but may be limited. This method\n\t * automatically launch a graph layout algorithm in its own thread to\n\t * compute best node positions.\n\t * \n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display(boolean )\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display();\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but is very limited.\n\t * \n\t * @param autoLayout\n\t *            If true a layout algorithm is launched in its own thread to\n\t *            compute best node positions.\n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display()\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display(boolean autoLayout);\n\n\t// New methods\n\n\t/**\n\t * Get a node by its index. This method is implicitly generic and returns\n\t * something which extends Node. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param index\n\t *            Index of the node to find.\n\t * @return The node with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             If the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T getNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Get an edge by its index. This method is implicitly generic and returns\n\t * something which extends Edge. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param index\n\t *            The index of the edge to find.\n\t * @return The edge with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is less than 0 or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param index1\n\t *            The first node index\n\t * @param index2\n\t *            The second node index\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int index1, int index2)\n\t\t\tthrows IndexOutOfBoundsException, IdAlreadyInUseException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param toIndex\n\t *            The first node index\n\t * @param fromIndex\n\t *            The second node index\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int fromIndex, int toIndex,\n\t\t\tboolean directed) throws IndexOutOfBoundsException,\n\t\t\tIdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the node references are\n\t * given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node\n\t * @param node2\n\t *            The second node\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node node1, Node node2)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the node\n\t * references are given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param from\n\t *            The first node\n\t * @param to\n\t *            The second node\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Removes an edge with a given index. An event is sent toward the\n\t * listeners.\n\t * \n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.removeEdge(i);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the edge to be removed.\n\t * @return The removed edge\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getEdgeCount() - 1}\n\t */\n\t<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but the nodes are identified by their\n\t * indices.\n\t * \n\t * @param fromIndex\n\t *            the index of the source node\n\t * @param toIndex\n\t *            the index of the target node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws IndexOutOfBoundsException\n\t *             If one of the node indices is negative or greater than\n\t *             {@code getNodeCount() - 1}.\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(int fromIndex, int toIndex)\n\t\t\tthrows IndexOutOfBoundsException, ElementNotFoundException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but node references are given instead\n\t * of node identifiers.\n\t * \n\t * @param node1\n\t *            the first node\n\t * @param node2\n\t *            the second node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(Node node1, Node node2)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge. An event is sent toward the listeners.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * \n\t * \n\t * @param edge\n\t *            The edge to be removed\n\t * @return The removed edge\n\t */\n\t<T extends Edge> T removeEdge(Edge edge);\n\n\t/**\n\t * Removes a node with a given index.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the node to be removed\n\t * @return The removed node\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes a node.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param node\n\t *            The node to be removed\n\t * @return The removed node\n\t */\n\t<T extends Node> T removeNode(Node node);\n}",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ [ "1", "int" ] ],
  "tokensMethodArguments" : [ [ "index", "", "int" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getEdgeCount", "org.graphstream.graph", "Structure", "public abstract int getEdgeCount()" ], [ "getNodeCount", "org.graphstream.graph", "Structure", "public abstract int getNodeCount()" ], [ "getIndex", "org.graphstream.graph", "Element", "public abstract int getIndex()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String from, String to) throws ElementNotFoundException" ], [ "getStep", "org.graphstream.graph", "Graph", "double getStep()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException" ], [ "isStrict", "org.graphstream.graph", "Graph", "boolean isStrict()" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display(boolean autoLayout)" ], [ "hasLabel", "org.graphstream.graph", "Element", "public abstract boolean hasLabel(String arg0)" ], [ "getEdgeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getEdgeSet()" ], [ "getEachNode", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachNode()" ], [ "hasHash", "org.graphstream.graph", "Element", "public abstract boolean hasHash(String arg0)" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(String id)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int index1, int index2) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Edge edge)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node node1, Node node2) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "getId", "org.graphstream.graph", "Element", "public abstract String getId()" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(Class<T> arg0, String[] arg1)" ], [ "getAttributeKeySet", "org.graphstream.graph", "Element", "public abstract Collection<String> getAttributeKeySet()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int fromIndex, int toIndex) throws IndexOutOfBoundsException, ElementNotFoundException" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int fromIndex, int toIndex, boolean directed) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "elementSinks", "org.graphstream.graph", "Graph", "Iterable<ElementSink> elementSinks()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(String id)" ], [ "getHash", "org.graphstream.graph", "Element", "public abstract HashMap<?, ?> getHash(String arg0)" ], [ "getNodeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getNodeSet()" ], [ "hasArray", "org.graphstream.graph", "Element", "public abstract boolean hasArray(String arg0)" ], [ "getLabel", "org.graphstream.graph", "Element", "public abstract CharSequence getLabel(String arg0)" ], [ "edgeFactory", "org.graphstream.graph", "Graph", "EdgeFactory<? extends Edge> edgeFactory()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Node node1, Node node2) throws ElementNotFoundException" ], [ "nullAttributesAreErrors", "org.graphstream.graph", "Graph", "boolean nullAttributesAreErrors()" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String id) throws ElementNotFoundException" ], [ "isAutoCreationEnabled", "org.graphstream.graph", "Graph", "boolean isAutoCreationEnabled()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getArray", "org.graphstream.graph", "Element", "public abstract Object[] getArray(String arg0)" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0, Class<?> arg1)" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "hasNumber", "org.graphstream.graph", "Element", "public abstract boolean hasNumber(String arg0)" ], [ "nodeFactory", "org.graphstream.graph", "Graph", "NodeFactory<? extends Node> nodeFactory()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(String id) throws ElementNotFoundException" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String from, String to, boolean directed) throws IdAlreadyInUseException, ElementNotFoundException" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(Node node)" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "getAttributeCount", "org.graphstream.graph", "Element", "public abstract int getAttributeCount()" ], [ "getNumber", "org.graphstream.graph", "Element", "public abstract double getNumber(String arg0)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "addNode", "org.graphstream.graph", "Graph", "<T extends Node> T addNode(String id) throws IdAlreadyInUseException" ], [ "getVector", "org.graphstream.graph", "Element", "public abstract ArrayList<? extends Number> getVector(String arg0)" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String node1, String node2) throws IdAlreadyInUseException, ElementNotFoundException, EdgeRejectedException" ], [ "getEachAttributeKey", "org.graphstream.graph", "Element", "public abstract Iterable<String> getEachAttributeKey()" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(int index) throws IndexOutOfBoundsException" ], [ "hasVector", "org.graphstream.graph", "Element", "public abstract boolean hasVector(String arg0)" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(String[] arg0)" ], [ "getEachEdge", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachEdge()" ], [ "getEdgeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getEdgeIterator()" ], [ "getNodeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getNodeIterator()" ], [ "getAttributeKeyIterator", "org.graphstream.graph", "Element", "public abstract Iterator<String> getAttributeKeyIterator()" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0, Class<T> arg1)" ], [ "attributeSinks", "org.graphstream.graph", "Graph", "Iterable<AttributeSink> attributeSinks()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 4204,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.graph",
  "className" : "Graph",
  "javadocTag" : "@throws IndexOutOfBoundsException If one of the node indices is negative or greater than\n            {@code getNodeCount() - 1}.",
  "methodJavadoc" : "    /**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but the nodes are identified by their\n\t * indices.\n\t * \n\t * @param fromIndex\n\t *            the index of the source node\n\t * @param toIndex\n\t *            the index of the target node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws IndexOutOfBoundsException\n\t *             If one of the node indices is negative or greater than\n\t *             {@code getNodeCount() - 1}.\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */",
  "methodSourceCode" : "<T extends Edge> T removeEdge(int fromIndex, int toIndex) throws IndexOutOfBoundsException, ElementNotFoundException;",
  "classJavadoc" : "/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.graph;\n\nimport java.io.IOException;\n\nimport org.graphstream.stream.AttributeSink;\nimport org.graphstream.stream.ElementSink;\nimport org.graphstream.stream.GraphParseException;\nimport org.graphstream.stream.Pipe;\nimport org.graphstream.stream.file.FileSink;\nimport org.graphstream.stream.file.FileSource;\nimport org.graphstream.ui.view.Viewer;\n\n\n/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */\npublic interface Graph extends Element, Pipe, Iterable<Node>, Structure {\n\t// Access\n\n\t/**\n\t * Get a node by its identifier. This method is implicitly generic and\n\t * returns something which extends Node. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param id\n\t *            Identifier of the node to find.\n\t * @return The searched node or null if not found.\n\t */\n\t<T extends Node> T getNode(String id);\n\n\t/**\n\t * Get an edge by its identifier. This method is implicitly generic and\n\t * returns something which extends Edge. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param id\n\t *            Identifier of the edge to find.\n\t * @return The searched edge or null if not found.\n\t */\n\t<T extends Edge> T getEdge(String id);\n\n\t/**\n\t * The factory used to create node instances. The factory can be changed to\n\t * refine the node class generated for this graph.\n\t * \n\t * @see #setNodeFactory(NodeFactory)\n\t * @see #edgeFactory()\n\t */\n\tNodeFactory<? extends Node> nodeFactory();\n\n\t/**\n\t * The factory used to create edge instances. The factory can be changed to\n\t * refine the edge class generated for this graph.\n\t * \n\t * @see #setEdgeFactory(EdgeFactory)\n\t * @see #nodeFactory()\n\t */\n\tEdgeFactory<? extends Edge> edgeFactory();\n\n\t/**\n\t * Is strict checking enabled? If strict checking is enabled the graph\n\t * checks for name space conflicts (e.g. insertion of two nodes with the\n\t * same name), removal of non-existing elements, use of non existing\n\t * elements (create an edge between two non existing nodes). Graph\n\t * implementations are free to respect strict checking or not.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isStrict();\n\n\t/**\n\t * Is the automatic creation of missing elements enabled?. If strict\n\t * checking is disabled and auto-creation is enabled, when an edge is\n\t * created and one or two of its nodes are not already present in the graph,\n\t * the nodes are automatically created.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isAutoCreationEnabled();\n\n\t/**\n\t * If true, when accessing an attribute that does not exist (or is not of\n\t * the expected type), a {@link NullAttributeException} is thrown. Else null\n\t * is returned.\n\t * \n\t * @return True if exceptions must be thrown when accessing a null\n\t *         attribute.\n\t */\n\tboolean nullAttributesAreErrors();\n\n\t/**\n\t * The current step.\n\t * \n\t * @return The step.\n\t */\n\tdouble getStep();\n\n\t// Command\n\n\t/**\n\t * Should a {@link NullAttributeException} be thrown when one tries to\n\t * access a non existing attribute, or an attribute whose type is not the\n\t * expected one?.\n\t * \n\t * @param on\n\t *            if true, exceptions will be thrown when accessing a non\n\t *            existing attribute.\n\t */\n\tvoid setNullAttributesAreErrors(boolean on);\n\n\t/**\n\t * Set the node factory used to create nodes.\n\t * \n\t * @param nf\n\t *            the new NodeFactory\n\t */\n\tvoid setNodeFactory(NodeFactory<? extends Node> nf);\n\n\t/**\n\t * Set the edge factory used to create edges.\n\t * \n\t * @param ef\n\t *            the new EdgeFactory\n\t */\n\tvoid setEdgeFactory(EdgeFactory<? extends Edge> ef);\n\n\t/**\n\t * Enable or disable strict checking.\n\t * \n\t * @see #isStrict()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setStrict(boolean on);\n\n\t/**\n\t * Enable or disable the automatic creation of missing elements.\n\t * \n\t * @see #isAutoCreationEnabled()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setAutoCreate(boolean on);\n\n\t// Graph construction\n\n\t/**\n\t * Empty the graph completely by removing any references to nodes or edges.\n\t * Every attribute is also removed. However, listeners are kept.\n\t * \n\t * @see #clearSinks()\n\t */\n\tvoid clear();\n\n\t/**\n\t * Add a node in the graph.\n\t * <p>\n\t * This acts as a factory, creating the node instance automatically (and\n\t * eventually using the node factory provided). An event is generated toward\n\t * the listeners. If strict checking is enabled, and a node already exists\n\t * with this identifier, an\n\t * {@link org.graphstream.graph.IdAlreadyInUseException} is raised. Else the\n\t * error is silently ignored and the already existing node is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.addNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            Arbitrary and unique string identifying the node.\n\t * @return The created node (or the already existing node).\n\t * @throws IdAlreadyInUseException\n\t *             If strict checking is enabled the identifier is already used.\n\t */\n\t<T extends Node> T addNode(String id) throws IdAlreadyInUseException;\n\n\t/**\n\t * Remove a node using its identifier.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            The unique identifier of the node to remove.\n\t * @return The removed node. If strict checking is disabled, it can return\n\t *         null if the node to remove does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no node matches the given identifier and strict checking\n\t *             is enabled.\n\t */\n\t<T extends Node> T removeNode(String id) throws ElementNotFoundException;\n\n\t/**\n\t * Adds an undirected edge between nodes.\n\t * \n\t * <p>\n\t * The behavior of this method depends on many conditions. It can be\n\t * summarized as follows.\n\t * </p>\n\t * \n\t * <p>\n\t * First of all, the method checks if the graph already contains an edge\n\t * with the same id. If this is the case and strict checking is enabled,\n\t * {@code IdAlreadyInUseException} is thrown. If the strict checking is\n\t * disabled the method returns a reference to the existing edge if it has\n\t * endpoints {@code node1} and {@code node2} (in the same order if the edge\n\t * is directed) or {@code null} otherwise.\n\t * </p>\n\t * \n\t * <p>\n\t * In the case when the graph does not contain an edge with the same id, the\n\t * method checks if {@code node1} and {@code node2} exist. If one or both of\n\t * them do not exist, and strict checking is enabled, {@code\n\t * ElementNotFoundException} is thrown. Otherwise if auto-creation is\n\t * disabled, the method returns {@code null}. If auto-creation is enabled,\n\t * the method creates the missing endpoints.\n\t * \n\t * <p>\n\t * When the edge id is not already in use and the both endpoints exist (or\n\t * created), the edge can still be rejected. It may happen for example when\n\t * it connects two already connected nodes in a single graph. If the edge is\n\t * rejected, the method throws {@code EdgeRejectedException} if strict\n\t * checking is enabled or returns {@code null} otherwise. Finally, if the\n\t * edge is accepted, it is created using the corresponding edge factory and\n\t * a reference to it is returned.\n\t * \n\t * <p>\n\t * An edge creation event is sent toward the listeners. If new nodes are\n\t * created, the corresponding events are also sent to the listeners.\n\t * </p>\n\t * \n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.addEdge(&quot;...&quot;, &quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * \n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t */\n\t<T extends Edge> T addEdge(String id, String node1, String node2)\n\t\t\tthrows IdAlreadyInUseException, ElementNotFoundException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)}, but this edge can be\n\t * directed between the two given nodes. If directed, the edge goes in the\n\t * 'from' -&gt; 'to' direction. An event is sent toward the listeners.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, String from, String to,\n\t\t\tboolean directed) throws IdAlreadyInUseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Remove an edge given the identifiers of its two endpoints.\n\t * <p>\n\t * If the edge is directed it is removed only if its source and destination\n\t * nodes are identified by 'from' and 'to' respectively. If the graph is a\n\t * multi-graph and there are several edges between the two nodes, one of the\n\t * edges at random is removed. An event is sent toward the listeners. If\n\t * strict checking is enabled and at least one of the two given nodes does\n\t * not exist or if they are not connected, a not found exception is raised.\n\t * Else the error is silently ignored, and null is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param from\n\t *            The origin node identifier to select the edge.\n\t * @param to\n\t *            The destination node identifier to select the edge.\n\t * @return The removed edge, or null if strict checking is disabled and at\n\t *         least one of the two given nodes does not exist or there is no\n\t *         edge between them\n\t * @throws ElementNotFoundException\n\t *             If the 'from' or 'to' node is not registered in the graph or\n\t *             not connected and strict checking is enabled.\n\t */\n\t<T extends Edge> T removeEdge(String from, String to)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge knowing its identifier. An event is sent toward the\n\t * listeners. If strict checking is enabled and the edge does not exist,\n\t * {@code ElementNotFoundException} is raised. Otherwise the error is\n\t * silently ignored and null is returned.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Identifier of the edge to remove.\n\t * @return The removed edge, or null if strict checking is disabled and the\n\t *         edge does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no edge matches the identifier and strict checking is\n\t *             enabled.\n\t */\n\t<T extends Edge> T removeEdge(String id) throws ElementNotFoundException;\n\n\t/**\n\t * <p>\n\t * Since dynamic graphs are based on discrete event modifications, the\n\t * notion of step is defined to simulate elapsed time between events. So a\n\t * step is a event that occurs in the graph, it does not modify it but it\n\t * gives a kind of timestamp that allows the tracking of the progress of the\n\t * graph over the time.\n\t * </p>\n\t * <p>\n\t * This kind of event is useful for dynamic algorithms that listen to the\n\t * dynamic graph and need to measure the time in the graph's evolution.\n\t * </p>\n\t * \n\t * @param time\n\t *            A numerical value that may give a timestamp to track the\n\t *            evolution of the graph over the time.\n\t */\n\tvoid stepBegins(double time);\n\n\t// Source\n\t// XXX do we put the iterable attributeSinks and elementSinks in Source ?\n\n\t/**\n\t * Returns an \"iterable\" of {@link AttributeSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the set of {@link AttributeSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<AttributeSink> attributeSinks();\n\n\t/**\n\t * Returns an \"iterable\" of {@link ElementSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the list of {@link ElementSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<ElementSink> elementSinks();\n\n\t// Utility shortcuts (should be mixins or traits, what are you doing Mr Java\n\t// ?)\n\t// XXX use a Readable/Writable/Displayable interface for this ?\n\n\t/**\n\t * Utility method to read a graph. This method tries to identify the graph\n\t * format by itself and instantiates the corresponding reader automatically.\n\t * If this process fails, a NotFoundException is raised.\n\t * \n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognized.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input output error occurs during the graph reading.\n\t */\n\tvoid read(String filename) throws IOException, GraphParseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Utility method to read a graph using the given reader.\n\t * \n\t * @param input\n\t *            An appropriate reader for the filename.\n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognised.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph reading.\n\t */\n\tvoid read(FileSource input, String filename) throws IOException,\n\t\t\tGraphParseException;\n\n\t/**\n\t * Utility method to write a graph in DGS format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(String filename) throws IOException;\n\n\t/**\n\t * Utility method to write a graph in the chosen format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @param output\n\t *            The output format to use.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(FileSink output, String filename) throws IOException;\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but may be limited. This method\n\t * automatically launch a graph layout algorithm in its own thread to\n\t * compute best node positions.\n\t * \n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display(boolean )\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display();\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but is very limited.\n\t * \n\t * @param autoLayout\n\t *            If true a layout algorithm is launched in its own thread to\n\t *            compute best node positions.\n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display()\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display(boolean autoLayout);\n\n\t// New methods\n\n\t/**\n\t * Get a node by its index. This method is implicitly generic and returns\n\t * something which extends Node. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param index\n\t *            Index of the node to find.\n\t * @return The node with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             If the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T getNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Get an edge by its index. This method is implicitly generic and returns\n\t * something which extends Edge. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param index\n\t *            The index of the edge to find.\n\t * @return The edge with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is less than 0 or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param index1\n\t *            The first node index\n\t * @param index2\n\t *            The second node index\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int index1, int index2)\n\t\t\tthrows IndexOutOfBoundsException, IdAlreadyInUseException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param toIndex\n\t *            The first node index\n\t * @param fromIndex\n\t *            The second node index\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int fromIndex, int toIndex,\n\t\t\tboolean directed) throws IndexOutOfBoundsException,\n\t\t\tIdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the node references are\n\t * given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node\n\t * @param node2\n\t *            The second node\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node node1, Node node2)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the node\n\t * references are given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param from\n\t *            The first node\n\t * @param to\n\t *            The second node\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Removes an edge with a given index. An event is sent toward the\n\t * listeners.\n\t * \n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.removeEdge(i);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the edge to be removed.\n\t * @return The removed edge\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getEdgeCount() - 1}\n\t */\n\t<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but the nodes are identified by their\n\t * indices.\n\t * \n\t * @param fromIndex\n\t *            the index of the source node\n\t * @param toIndex\n\t *            the index of the target node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws IndexOutOfBoundsException\n\t *             If one of the node indices is negative or greater than\n\t *             {@code getNodeCount() - 1}.\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(int fromIndex, int toIndex)\n\t\t\tthrows IndexOutOfBoundsException, ElementNotFoundException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but node references are given instead\n\t * of node identifiers.\n\t * \n\t * @param node1\n\t *            the first node\n\t * @param node2\n\t *            the second node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(Node node1, Node node2)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge. An event is sent toward the listeners.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * \n\t * \n\t * @param edge\n\t *            The edge to be removed\n\t * @return The removed edge\n\t */\n\t<T extends Edge> T removeEdge(Edge edge);\n\n\t/**\n\t * Removes a node with a given index.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the node to be removed\n\t * @return The removed node\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes a node.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param node\n\t *            The node to be removed\n\t * @return The removed node\n\t */\n\t<T extends Node> T removeNode(Node node);\n}",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ [ "1", "int" ] ],
  "tokensMethodArguments" : [ [ "fromIndex", "", "int" ], [ "toIndex", "", "int" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getId", "org.graphstream.graph", "Element", "public abstract String getId()" ], [ "getNodeCount", "org.graphstream.graph", "Structure", "public abstract int getNodeCount()" ], [ "getStep", "org.graphstream.graph", "Graph", "double getStep()" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0, Class<T> arg1)" ], [ "isStrict", "org.graphstream.graph", "Graph", "boolean isStrict()" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String node1, String node2) throws IdAlreadyInUseException, ElementNotFoundException, EdgeRejectedException" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int fromIndex, int toIndex, boolean directed) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "nullAttributesAreErrors", "org.graphstream.graph", "Graph", "boolean nullAttributesAreErrors()" ], [ "isAutoCreationEnabled", "org.graphstream.graph", "Graph", "boolean isAutoCreationEnabled()" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0, Class<?> arg1)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int fromIndex, int toIndex) throws IndexOutOfBoundsException, ElementNotFoundException" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display(boolean autoLayout)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String from, String to) throws ElementNotFoundException" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int index1, int index2) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getHash", "org.graphstream.graph", "Element", "public abstract HashMap<?, ?> getHash(String arg0)" ], [ "getEachEdge", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachEdge()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "attributeSinks", "org.graphstream.graph", "Graph", "Iterable<AttributeSink> attributeSinks()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Node node1, Node node2) throws ElementNotFoundException" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String id) throws ElementNotFoundException" ], [ "getIndex", "org.graphstream.graph", "Element", "public abstract int getIndex()" ], [ "getAttributeKeyIterator", "org.graphstream.graph", "Element", "public abstract Iterator<String> getAttributeKeyIterator()" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(String[] arg0)" ], [ "getEdgeCount", "org.graphstream.graph", "Structure", "public abstract int getEdgeCount()" ], [ "getEachNode", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachNode()" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0)" ], [ "hasHash", "org.graphstream.graph", "Element", "public abstract boolean hasHash(String arg0)" ], [ "getAttributeCount", "org.graphstream.graph", "Element", "public abstract int getAttributeCount()" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(int index) throws IndexOutOfBoundsException" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Edge edge)" ], [ "hasNumber", "org.graphstream.graph", "Element", "public abstract boolean hasNumber(String arg0)" ], [ "getEdgeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getEdgeSet()" ], [ "hasLabel", "org.graphstream.graph", "Element", "public abstract boolean hasLabel(String arg0)" ], [ "getArray", "org.graphstream.graph", "Element", "public abstract Object[] getArray(String arg0)" ], [ "getNumber", "org.graphstream.graph", "Element", "public abstract double getNumber(String arg0)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String from, String to, boolean directed) throws IdAlreadyInUseException, ElementNotFoundException" ], [ "getEachAttributeKey", "org.graphstream.graph", "Element", "public abstract Iterable<String> getEachAttributeKey()" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(String id)" ], [ "getNodeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getNodeSet()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node node1, Node node2) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "hasVector", "org.graphstream.graph", "Element", "public abstract boolean hasVector(String arg0)" ], [ "nodeFactory", "org.graphstream.graph", "Graph", "NodeFactory<? extends Node> nodeFactory()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "elementSinks", "org.graphstream.graph", "Graph", "Iterable<ElementSink> elementSinks()" ], [ "getAttributeKeySet", "org.graphstream.graph", "Element", "public abstract Collection<String> getAttributeKeySet()" ], [ "edgeFactory", "org.graphstream.graph", "Graph", "EdgeFactory<? extends Edge> edgeFactory()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(String id) throws ElementNotFoundException" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(Class<T> arg0, String[] arg1)" ], [ "getLabel", "org.graphstream.graph", "Element", "public abstract CharSequence getLabel(String arg0)" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0)" ], [ "addNode", "org.graphstream.graph", "Graph", "<T extends Node> T addNode(String id) throws IdAlreadyInUseException" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(String id)" ], [ "hasArray", "org.graphstream.graph", "Element", "public abstract boolean hasArray(String arg0)" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException" ], [ "getNodeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getNodeIterator()" ], [ "getEdgeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getEdgeIterator()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(Node node)" ], [ "getVector", "org.graphstream.graph", "Element", "public abstract ArrayList<? extends Number> getVector(String arg0)" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 4205,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.graph",
  "className" : "Graph",
  "javadocTag" : "@throws ElementNotFoundException if strict checking is enabled and there is no edge between\n            the two nodes.",
  "methodJavadoc" : "    /**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but the nodes are identified by their\n\t * indices.\n\t * \n\t * @param fromIndex\n\t *            the index of the source node\n\t * @param toIndex\n\t *            the index of the target node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws IndexOutOfBoundsException\n\t *             If one of the node indices is negative or greater than\n\t *             {@code getNodeCount() - 1}.\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */",
  "methodSourceCode" : "<T extends Edge> T removeEdge(int fromIndex, int toIndex) throws IndexOutOfBoundsException, ElementNotFoundException;",
  "classJavadoc" : "/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.graph;\n\nimport java.io.IOException;\n\nimport org.graphstream.stream.AttributeSink;\nimport org.graphstream.stream.ElementSink;\nimport org.graphstream.stream.GraphParseException;\nimport org.graphstream.stream.Pipe;\nimport org.graphstream.stream.file.FileSink;\nimport org.graphstream.stream.file.FileSource;\nimport org.graphstream.ui.view.Viewer;\n\n\n/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */\npublic interface Graph extends Element, Pipe, Iterable<Node>, Structure {\n\t// Access\n\n\t/**\n\t * Get a node by its identifier. This method is implicitly generic and\n\t * returns something which extends Node. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param id\n\t *            Identifier of the node to find.\n\t * @return The searched node or null if not found.\n\t */\n\t<T extends Node> T getNode(String id);\n\n\t/**\n\t * Get an edge by its identifier. This method is implicitly generic and\n\t * returns something which extends Edge. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param id\n\t *            Identifier of the edge to find.\n\t * @return The searched edge or null if not found.\n\t */\n\t<T extends Edge> T getEdge(String id);\n\n\t/**\n\t * The factory used to create node instances. The factory can be changed to\n\t * refine the node class generated for this graph.\n\t * \n\t * @see #setNodeFactory(NodeFactory)\n\t * @see #edgeFactory()\n\t */\n\tNodeFactory<? extends Node> nodeFactory();\n\n\t/**\n\t * The factory used to create edge instances. The factory can be changed to\n\t * refine the edge class generated for this graph.\n\t * \n\t * @see #setEdgeFactory(EdgeFactory)\n\t * @see #nodeFactory()\n\t */\n\tEdgeFactory<? extends Edge> edgeFactory();\n\n\t/**\n\t * Is strict checking enabled? If strict checking is enabled the graph\n\t * checks for name space conflicts (e.g. insertion of two nodes with the\n\t * same name), removal of non-existing elements, use of non existing\n\t * elements (create an edge between two non existing nodes). Graph\n\t * implementations are free to respect strict checking or not.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isStrict();\n\n\t/**\n\t * Is the automatic creation of missing elements enabled?. If strict\n\t * checking is disabled and auto-creation is enabled, when an edge is\n\t * created and one or two of its nodes are not already present in the graph,\n\t * the nodes are automatically created.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isAutoCreationEnabled();\n\n\t/**\n\t * If true, when accessing an attribute that does not exist (or is not of\n\t * the expected type), a {@link NullAttributeException} is thrown. Else null\n\t * is returned.\n\t * \n\t * @return True if exceptions must be thrown when accessing a null\n\t *         attribute.\n\t */\n\tboolean nullAttributesAreErrors();\n\n\t/**\n\t * The current step.\n\t * \n\t * @return The step.\n\t */\n\tdouble getStep();\n\n\t// Command\n\n\t/**\n\t * Should a {@link NullAttributeException} be thrown when one tries to\n\t * access a non existing attribute, or an attribute whose type is not the\n\t * expected one?.\n\t * \n\t * @param on\n\t *            if true, exceptions will be thrown when accessing a non\n\t *            existing attribute.\n\t */\n\tvoid setNullAttributesAreErrors(boolean on);\n\n\t/**\n\t * Set the node factory used to create nodes.\n\t * \n\t * @param nf\n\t *            the new NodeFactory\n\t */\n\tvoid setNodeFactory(NodeFactory<? extends Node> nf);\n\n\t/**\n\t * Set the edge factory used to create edges.\n\t * \n\t * @param ef\n\t *            the new EdgeFactory\n\t */\n\tvoid setEdgeFactory(EdgeFactory<? extends Edge> ef);\n\n\t/**\n\t * Enable or disable strict checking.\n\t * \n\t * @see #isStrict()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setStrict(boolean on);\n\n\t/**\n\t * Enable or disable the automatic creation of missing elements.\n\t * \n\t * @see #isAutoCreationEnabled()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setAutoCreate(boolean on);\n\n\t// Graph construction\n\n\t/**\n\t * Empty the graph completely by removing any references to nodes or edges.\n\t * Every attribute is also removed. However, listeners are kept.\n\t * \n\t * @see #clearSinks()\n\t */\n\tvoid clear();\n\n\t/**\n\t * Add a node in the graph.\n\t * <p>\n\t * This acts as a factory, creating the node instance automatically (and\n\t * eventually using the node factory provided). An event is generated toward\n\t * the listeners. If strict checking is enabled, and a node already exists\n\t * with this identifier, an\n\t * {@link org.graphstream.graph.IdAlreadyInUseException} is raised. Else the\n\t * error is silently ignored and the already existing node is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.addNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            Arbitrary and unique string identifying the node.\n\t * @return The created node (or the already existing node).\n\t * @throws IdAlreadyInUseException\n\t *             If strict checking is enabled the identifier is already used.\n\t */\n\t<T extends Node> T addNode(String id) throws IdAlreadyInUseException;\n\n\t/**\n\t * Remove a node using its identifier.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            The unique identifier of the node to remove.\n\t * @return The removed node. If strict checking is disabled, it can return\n\t *         null if the node to remove does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no node matches the given identifier and strict checking\n\t *             is enabled.\n\t */\n\t<T extends Node> T removeNode(String id) throws ElementNotFoundException;\n\n\t/**\n\t * Adds an undirected edge between nodes.\n\t * \n\t * <p>\n\t * The behavior of this method depends on many conditions. It can be\n\t * summarized as follows.\n\t * </p>\n\t * \n\t * <p>\n\t * First of all, the method checks if the graph already contains an edge\n\t * with the same id. If this is the case and strict checking is enabled,\n\t * {@code IdAlreadyInUseException} is thrown. If the strict checking is\n\t * disabled the method returns a reference to the existing edge if it has\n\t * endpoints {@code node1} and {@code node2} (in the same order if the edge\n\t * is directed) or {@code null} otherwise.\n\t * </p>\n\t * \n\t * <p>\n\t * In the case when the graph does not contain an edge with the same id, the\n\t * method checks if {@code node1} and {@code node2} exist. If one or both of\n\t * them do not exist, and strict checking is enabled, {@code\n\t * ElementNotFoundException} is thrown. Otherwise if auto-creation is\n\t * disabled, the method returns {@code null}. If auto-creation is enabled,\n\t * the method creates the missing endpoints.\n\t * \n\t * <p>\n\t * When the edge id is not already in use and the both endpoints exist (or\n\t * created), the edge can still be rejected. It may happen for example when\n\t * it connects two already connected nodes in a single graph. If the edge is\n\t * rejected, the method throws {@code EdgeRejectedException} if strict\n\t * checking is enabled or returns {@code null} otherwise. Finally, if the\n\t * edge is accepted, it is created using the corresponding edge factory and\n\t * a reference to it is returned.\n\t * \n\t * <p>\n\t * An edge creation event is sent toward the listeners. If new nodes are\n\t * created, the corresponding events are also sent to the listeners.\n\t * </p>\n\t * \n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.addEdge(&quot;...&quot;, &quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * \n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t */\n\t<T extends Edge> T addEdge(String id, String node1, String node2)\n\t\t\tthrows IdAlreadyInUseException, ElementNotFoundException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)}, but this edge can be\n\t * directed between the two given nodes. If directed, the edge goes in the\n\t * 'from' -&gt; 'to' direction. An event is sent toward the listeners.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, String from, String to,\n\t\t\tboolean directed) throws IdAlreadyInUseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Remove an edge given the identifiers of its two endpoints.\n\t * <p>\n\t * If the edge is directed it is removed only if its source and destination\n\t * nodes are identified by 'from' and 'to' respectively. If the graph is a\n\t * multi-graph and there are several edges between the two nodes, one of the\n\t * edges at random is removed. An event is sent toward the listeners. If\n\t * strict checking is enabled and at least one of the two given nodes does\n\t * not exist or if they are not connected, a not found exception is raised.\n\t * Else the error is silently ignored, and null is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param from\n\t *            The origin node identifier to select the edge.\n\t * @param to\n\t *            The destination node identifier to select the edge.\n\t * @return The removed edge, or null if strict checking is disabled and at\n\t *         least one of the two given nodes does not exist or there is no\n\t *         edge between them\n\t * @throws ElementNotFoundException\n\t *             If the 'from' or 'to' node is not registered in the graph or\n\t *             not connected and strict checking is enabled.\n\t */\n\t<T extends Edge> T removeEdge(String from, String to)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge knowing its identifier. An event is sent toward the\n\t * listeners. If strict checking is enabled and the edge does not exist,\n\t * {@code ElementNotFoundException} is raised. Otherwise the error is\n\t * silently ignored and null is returned.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Identifier of the edge to remove.\n\t * @return The removed edge, or null if strict checking is disabled and the\n\t *         edge does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no edge matches the identifier and strict checking is\n\t *             enabled.\n\t */\n\t<T extends Edge> T removeEdge(String id) throws ElementNotFoundException;\n\n\t/**\n\t * <p>\n\t * Since dynamic graphs are based on discrete event modifications, the\n\t * notion of step is defined to simulate elapsed time between events. So a\n\t * step is a event that occurs in the graph, it does not modify it but it\n\t * gives a kind of timestamp that allows the tracking of the progress of the\n\t * graph over the time.\n\t * </p>\n\t * <p>\n\t * This kind of event is useful for dynamic algorithms that listen to the\n\t * dynamic graph and need to measure the time in the graph's evolution.\n\t * </p>\n\t * \n\t * @param time\n\t *            A numerical value that may give a timestamp to track the\n\t *            evolution of the graph over the time.\n\t */\n\tvoid stepBegins(double time);\n\n\t// Source\n\t// XXX do we put the iterable attributeSinks and elementSinks in Source ?\n\n\t/**\n\t * Returns an \"iterable\" of {@link AttributeSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the set of {@link AttributeSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<AttributeSink> attributeSinks();\n\n\t/**\n\t * Returns an \"iterable\" of {@link ElementSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the list of {@link ElementSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<ElementSink> elementSinks();\n\n\t// Utility shortcuts (should be mixins or traits, what are you doing Mr Java\n\t// ?)\n\t// XXX use a Readable/Writable/Displayable interface for this ?\n\n\t/**\n\t * Utility method to read a graph. This method tries to identify the graph\n\t * format by itself and instantiates the corresponding reader automatically.\n\t * If this process fails, a NotFoundException is raised.\n\t * \n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognized.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input output error occurs during the graph reading.\n\t */\n\tvoid read(String filename) throws IOException, GraphParseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Utility method to read a graph using the given reader.\n\t * \n\t * @param input\n\t *            An appropriate reader for the filename.\n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognised.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph reading.\n\t */\n\tvoid read(FileSource input, String filename) throws IOException,\n\t\t\tGraphParseException;\n\n\t/**\n\t * Utility method to write a graph in DGS format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(String filename) throws IOException;\n\n\t/**\n\t * Utility method to write a graph in the chosen format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @param output\n\t *            The output format to use.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(FileSink output, String filename) throws IOException;\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but may be limited. This method\n\t * automatically launch a graph layout algorithm in its own thread to\n\t * compute best node positions.\n\t * \n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display(boolean )\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display();\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but is very limited.\n\t * \n\t * @param autoLayout\n\t *            If true a layout algorithm is launched in its own thread to\n\t *            compute best node positions.\n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display()\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display(boolean autoLayout);\n\n\t// New methods\n\n\t/**\n\t * Get a node by its index. This method is implicitly generic and returns\n\t * something which extends Node. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param index\n\t *            Index of the node to find.\n\t * @return The node with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             If the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T getNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Get an edge by its index. This method is implicitly generic and returns\n\t * something which extends Edge. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param index\n\t *            The index of the edge to find.\n\t * @return The edge with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is less than 0 or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param index1\n\t *            The first node index\n\t * @param index2\n\t *            The second node index\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int index1, int index2)\n\t\t\tthrows IndexOutOfBoundsException, IdAlreadyInUseException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param toIndex\n\t *            The first node index\n\t * @param fromIndex\n\t *            The second node index\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int fromIndex, int toIndex,\n\t\t\tboolean directed) throws IndexOutOfBoundsException,\n\t\t\tIdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the node references are\n\t * given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node\n\t * @param node2\n\t *            The second node\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node node1, Node node2)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the node\n\t * references are given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param from\n\t *            The first node\n\t * @param to\n\t *            The second node\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Removes an edge with a given index. An event is sent toward the\n\t * listeners.\n\t * \n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.removeEdge(i);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the edge to be removed.\n\t * @return The removed edge\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getEdgeCount() - 1}\n\t */\n\t<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but the nodes are identified by their\n\t * indices.\n\t * \n\t * @param fromIndex\n\t *            the index of the source node\n\t * @param toIndex\n\t *            the index of the target node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws IndexOutOfBoundsException\n\t *             If one of the node indices is negative or greater than\n\t *             {@code getNodeCount() - 1}.\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(int fromIndex, int toIndex)\n\t\t\tthrows IndexOutOfBoundsException, ElementNotFoundException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but node references are given instead\n\t * of node identifiers.\n\t * \n\t * @param node1\n\t *            the first node\n\t * @param node2\n\t *            the second node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(Node node1, Node node2)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge. An event is sent toward the listeners.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * \n\t * \n\t * @param edge\n\t *            The edge to be removed\n\t * @return The removed edge\n\t */\n\t<T extends Edge> T removeEdge(Edge edge);\n\n\t/**\n\t * Removes a node with a given index.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the node to be removed\n\t * @return The removed node\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes a node.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param node\n\t *            The node to be removed\n\t * @return The removed node\n\t */\n\t<T extends Node> T removeNode(Node node);\n}",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ [ "1", "int" ] ],
  "tokensMethodArguments" : [ [ "fromIndex", "", "int" ], [ "toIndex", "", "int" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(int index) throws IndexOutOfBoundsException" ], [ "getHash", "org.graphstream.graph", "Element", "public abstract HashMap<?, ?> getHash(String arg0)" ], [ "getLabel", "org.graphstream.graph", "Element", "public abstract CharSequence getLabel(String arg0)" ], [ "getEdgeCount", "org.graphstream.graph", "Structure", "public abstract int getEdgeCount()" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display(boolean autoLayout)" ], [ "getAttributeKeyIterator", "org.graphstream.graph", "Element", "public abstract Iterator<String> getAttributeKeyIterator()" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(String id)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException" ], [ "getVector", "org.graphstream.graph", "Element", "public abstract ArrayList<? extends Number> getVector(String arg0)" ], [ "getEdgeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getEdgeIterator()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(Node node)" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(String id) throws ElementNotFoundException" ], [ "hasVector", "org.graphstream.graph", "Element", "public abstract boolean hasVector(String arg0)" ], [ "getId", "org.graphstream.graph", "Element", "public abstract String getId()" ], [ "hasLabel", "org.graphstream.graph", "Element", "public abstract boolean hasLabel(String arg0)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int fromIndex, int toIndex, boolean directed) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int fromIndex, int toIndex) throws IndexOutOfBoundsException, ElementNotFoundException" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0, Class<?> arg1)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "getNodeCount", "org.graphstream.graph", "Structure", "public abstract int getNodeCount()" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(String[] arg0)" ], [ "getStep", "org.graphstream.graph", "Graph", "double getStep()" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0)" ], [ "hasArray", "org.graphstream.graph", "Element", "public abstract boolean hasArray(String arg0)" ], [ "getEdgeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getEdgeSet()" ], [ "nullAttributesAreErrors", "org.graphstream.graph", "Graph", "boolean nullAttributesAreErrors()" ], [ "getNumber", "org.graphstream.graph", "Element", "public abstract double getNumber(String arg0)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Edge edge)" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display()" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(String id)" ], [ "attributeSinks", "org.graphstream.graph", "Graph", "Iterable<AttributeSink> attributeSinks()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String from, String to, boolean directed) throws IdAlreadyInUseException, ElementNotFoundException" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node node1, Node node2) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "edgeFactory", "org.graphstream.graph", "Graph", "EdgeFactory<? extends Edge> edgeFactory()" ], [ "getNodeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getNodeIterator()" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0)" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0, Class<T> arg1)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int index1, int index2) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String id) throws ElementNotFoundException" ], [ "nodeFactory", "org.graphstream.graph", "Graph", "NodeFactory<? extends Node> nodeFactory()" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(Class<T> arg0, String[] arg1)" ], [ "getNodeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getNodeSet()" ], [ "elementSinks", "org.graphstream.graph", "Graph", "Iterable<ElementSink> elementSinks()" ], [ "getEachNode", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachNode()" ], [ "addNode", "org.graphstream.graph", "Graph", "<T extends Node> T addNode(String id) throws IdAlreadyInUseException" ], [ "getAttributeKeySet", "org.graphstream.graph", "Element", "public abstract Collection<String> getAttributeKeySet()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "getAttributeCount", "org.graphstream.graph", "Element", "public abstract int getAttributeCount()" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "hasHash", "org.graphstream.graph", "Element", "public abstract boolean hasHash(String arg0)" ], [ "hasNumber", "org.graphstream.graph", "Element", "public abstract boolean hasNumber(String arg0)" ], [ "getEachEdge", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachEdge()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Node node1, Node node2) throws ElementNotFoundException" ], [ "isAutoCreationEnabled", "org.graphstream.graph", "Graph", "boolean isAutoCreationEnabled()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException" ], [ "getEachAttributeKey", "org.graphstream.graph", "Element", "public abstract Iterable<String> getEachAttributeKey()" ], [ "isStrict", "org.graphstream.graph", "Graph", "boolean isStrict()" ], [ "getIndex", "org.graphstream.graph", "Element", "public abstract int getIndex()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String from, String to) throws ElementNotFoundException" ], [ "getArray", "org.graphstream.graph", "Element", "public abstract Object[] getArray(String arg0)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String node1, String node2) throws IdAlreadyInUseException, ElementNotFoundException, EdgeRejectedException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 4206,
  "oracle" : ";",
  "oracleType" : "PRE",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.graph",
  "className" : "Graph",
  "javadocTag" : "@param node1 the first node",
  "methodJavadoc" : "    /**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but node references are given instead\n\t * of node identifiers.\n\t * \n\t * @param node1\n\t *            the first node\n\t * @param node2\n\t *            the second node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */",
  "methodSourceCode" : "<T extends Edge> T removeEdge(Node node1, Node node2) throws ElementNotFoundException;",
  "classJavadoc" : "/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.graph;\n\nimport java.io.IOException;\n\nimport org.graphstream.stream.AttributeSink;\nimport org.graphstream.stream.ElementSink;\nimport org.graphstream.stream.GraphParseException;\nimport org.graphstream.stream.Pipe;\nimport org.graphstream.stream.file.FileSink;\nimport org.graphstream.stream.file.FileSource;\nimport org.graphstream.ui.view.Viewer;\n\n\n/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */\npublic interface Graph extends Element, Pipe, Iterable<Node>, Structure {\n\t// Access\n\n\t/**\n\t * Get a node by its identifier. This method is implicitly generic and\n\t * returns something which extends Node. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param id\n\t *            Identifier of the node to find.\n\t * @return The searched node or null if not found.\n\t */\n\t<T extends Node> T getNode(String id);\n\n\t/**\n\t * Get an edge by its identifier. This method is implicitly generic and\n\t * returns something which extends Edge. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param id\n\t *            Identifier of the edge to find.\n\t * @return The searched edge or null if not found.\n\t */\n\t<T extends Edge> T getEdge(String id);\n\n\t/**\n\t * The factory used to create node instances. The factory can be changed to\n\t * refine the node class generated for this graph.\n\t * \n\t * @see #setNodeFactory(NodeFactory)\n\t * @see #edgeFactory()\n\t */\n\tNodeFactory<? extends Node> nodeFactory();\n\n\t/**\n\t * The factory used to create edge instances. The factory can be changed to\n\t * refine the edge class generated for this graph.\n\t * \n\t * @see #setEdgeFactory(EdgeFactory)\n\t * @see #nodeFactory()\n\t */\n\tEdgeFactory<? extends Edge> edgeFactory();\n\n\t/**\n\t * Is strict checking enabled? If strict checking is enabled the graph\n\t * checks for name space conflicts (e.g. insertion of two nodes with the\n\t * same name), removal of non-existing elements, use of non existing\n\t * elements (create an edge between two non existing nodes). Graph\n\t * implementations are free to respect strict checking or not.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isStrict();\n\n\t/**\n\t * Is the automatic creation of missing elements enabled?. If strict\n\t * checking is disabled and auto-creation is enabled, when an edge is\n\t * created and one or two of its nodes are not already present in the graph,\n\t * the nodes are automatically created.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isAutoCreationEnabled();\n\n\t/**\n\t * If true, when accessing an attribute that does not exist (or is not of\n\t * the expected type), a {@link NullAttributeException} is thrown. Else null\n\t * is returned.\n\t * \n\t * @return True if exceptions must be thrown when accessing a null\n\t *         attribute.\n\t */\n\tboolean nullAttributesAreErrors();\n\n\t/**\n\t * The current step.\n\t * \n\t * @return The step.\n\t */\n\tdouble getStep();\n\n\t// Command\n\n\t/**\n\t * Should a {@link NullAttributeException} be thrown when one tries to\n\t * access a non existing attribute, or an attribute whose type is not the\n\t * expected one?.\n\t * \n\t * @param on\n\t *            if true, exceptions will be thrown when accessing a non\n\t *            existing attribute.\n\t */\n\tvoid setNullAttributesAreErrors(boolean on);\n\n\t/**\n\t * Set the node factory used to create nodes.\n\t * \n\t * @param nf\n\t *            the new NodeFactory\n\t */\n\tvoid setNodeFactory(NodeFactory<? extends Node> nf);\n\n\t/**\n\t * Set the edge factory used to create edges.\n\t * \n\t * @param ef\n\t *            the new EdgeFactory\n\t */\n\tvoid setEdgeFactory(EdgeFactory<? extends Edge> ef);\n\n\t/**\n\t * Enable or disable strict checking.\n\t * \n\t * @see #isStrict()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setStrict(boolean on);\n\n\t/**\n\t * Enable or disable the automatic creation of missing elements.\n\t * \n\t * @see #isAutoCreationEnabled()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setAutoCreate(boolean on);\n\n\t// Graph construction\n\n\t/**\n\t * Empty the graph completely by removing any references to nodes or edges.\n\t * Every attribute is also removed. However, listeners are kept.\n\t * \n\t * @see #clearSinks()\n\t */\n\tvoid clear();\n\n\t/**\n\t * Add a node in the graph.\n\t * <p>\n\t * This acts as a factory, creating the node instance automatically (and\n\t * eventually using the node factory provided). An event is generated toward\n\t * the listeners. If strict checking is enabled, and a node already exists\n\t * with this identifier, an\n\t * {@link org.graphstream.graph.IdAlreadyInUseException} is raised. Else the\n\t * error is silently ignored and the already existing node is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.addNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            Arbitrary and unique string identifying the node.\n\t * @return The created node (or the already existing node).\n\t * @throws IdAlreadyInUseException\n\t *             If strict checking is enabled the identifier is already used.\n\t */\n\t<T extends Node> T addNode(String id) throws IdAlreadyInUseException;\n\n\t/**\n\t * Remove a node using its identifier.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            The unique identifier of the node to remove.\n\t * @return The removed node. If strict checking is disabled, it can return\n\t *         null if the node to remove does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no node matches the given identifier and strict checking\n\t *             is enabled.\n\t */\n\t<T extends Node> T removeNode(String id) throws ElementNotFoundException;\n\n\t/**\n\t * Adds an undirected edge between nodes.\n\t * \n\t * <p>\n\t * The behavior of this method depends on many conditions. It can be\n\t * summarized as follows.\n\t * </p>\n\t * \n\t * <p>\n\t * First of all, the method checks if the graph already contains an edge\n\t * with the same id. If this is the case and strict checking is enabled,\n\t * {@code IdAlreadyInUseException} is thrown. If the strict checking is\n\t * disabled the method returns a reference to the existing edge if it has\n\t * endpoints {@code node1} and {@code node2} (in the same order if the edge\n\t * is directed) or {@code null} otherwise.\n\t * </p>\n\t * \n\t * <p>\n\t * In the case when the graph does not contain an edge with the same id, the\n\t * method checks if {@code node1} and {@code node2} exist. If one or both of\n\t * them do not exist, and strict checking is enabled, {@code\n\t * ElementNotFoundException} is thrown. Otherwise if auto-creation is\n\t * disabled, the method returns {@code null}. If auto-creation is enabled,\n\t * the method creates the missing endpoints.\n\t * \n\t * <p>\n\t * When the edge id is not already in use and the both endpoints exist (or\n\t * created), the edge can still be rejected. It may happen for example when\n\t * it connects two already connected nodes in a single graph. If the edge is\n\t * rejected, the method throws {@code EdgeRejectedException} if strict\n\t * checking is enabled or returns {@code null} otherwise. Finally, if the\n\t * edge is accepted, it is created using the corresponding edge factory and\n\t * a reference to it is returned.\n\t * \n\t * <p>\n\t * An edge creation event is sent toward the listeners. If new nodes are\n\t * created, the corresponding events are also sent to the listeners.\n\t * </p>\n\t * \n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.addEdge(&quot;...&quot;, &quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * \n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t */\n\t<T extends Edge> T addEdge(String id, String node1, String node2)\n\t\t\tthrows IdAlreadyInUseException, ElementNotFoundException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)}, but this edge can be\n\t * directed between the two given nodes. If directed, the edge goes in the\n\t * 'from' -&gt; 'to' direction. An event is sent toward the listeners.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, String from, String to,\n\t\t\tboolean directed) throws IdAlreadyInUseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Remove an edge given the identifiers of its two endpoints.\n\t * <p>\n\t * If the edge is directed it is removed only if its source and destination\n\t * nodes are identified by 'from' and 'to' respectively. If the graph is a\n\t * multi-graph and there are several edges between the two nodes, one of the\n\t * edges at random is removed. An event is sent toward the listeners. If\n\t * strict checking is enabled and at least one of the two given nodes does\n\t * not exist or if they are not connected, a not found exception is raised.\n\t * Else the error is silently ignored, and null is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param from\n\t *            The origin node identifier to select the edge.\n\t * @param to\n\t *            The destination node identifier to select the edge.\n\t * @return The removed edge, or null if strict checking is disabled and at\n\t *         least one of the two given nodes does not exist or there is no\n\t *         edge between them\n\t * @throws ElementNotFoundException\n\t *             If the 'from' or 'to' node is not registered in the graph or\n\t *             not connected and strict checking is enabled.\n\t */\n\t<T extends Edge> T removeEdge(String from, String to)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge knowing its identifier. An event is sent toward the\n\t * listeners. If strict checking is enabled and the edge does not exist,\n\t * {@code ElementNotFoundException} is raised. Otherwise the error is\n\t * silently ignored and null is returned.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Identifier of the edge to remove.\n\t * @return The removed edge, or null if strict checking is disabled and the\n\t *         edge does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no edge matches the identifier and strict checking is\n\t *             enabled.\n\t */\n\t<T extends Edge> T removeEdge(String id) throws ElementNotFoundException;\n\n\t/**\n\t * <p>\n\t * Since dynamic graphs are based on discrete event modifications, the\n\t * notion of step is defined to simulate elapsed time between events. So a\n\t * step is a event that occurs in the graph, it does not modify it but it\n\t * gives a kind of timestamp that allows the tracking of the progress of the\n\t * graph over the time.\n\t * </p>\n\t * <p>\n\t * This kind of event is useful for dynamic algorithms that listen to the\n\t * dynamic graph and need to measure the time in the graph's evolution.\n\t * </p>\n\t * \n\t * @param time\n\t *            A numerical value that may give a timestamp to track the\n\t *            evolution of the graph over the time.\n\t */\n\tvoid stepBegins(double time);\n\n\t// Source\n\t// XXX do we put the iterable attributeSinks and elementSinks in Source ?\n\n\t/**\n\t * Returns an \"iterable\" of {@link AttributeSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the set of {@link AttributeSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<AttributeSink> attributeSinks();\n\n\t/**\n\t * Returns an \"iterable\" of {@link ElementSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the list of {@link ElementSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<ElementSink> elementSinks();\n\n\t// Utility shortcuts (should be mixins or traits, what are you doing Mr Java\n\t// ?)\n\t// XXX use a Readable/Writable/Displayable interface for this ?\n\n\t/**\n\t * Utility method to read a graph. This method tries to identify the graph\n\t * format by itself and instantiates the corresponding reader automatically.\n\t * If this process fails, a NotFoundException is raised.\n\t * \n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognized.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input output error occurs during the graph reading.\n\t */\n\tvoid read(String filename) throws IOException, GraphParseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Utility method to read a graph using the given reader.\n\t * \n\t * @param input\n\t *            An appropriate reader for the filename.\n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognised.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph reading.\n\t */\n\tvoid read(FileSource input, String filename) throws IOException,\n\t\t\tGraphParseException;\n\n\t/**\n\t * Utility method to write a graph in DGS format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(String filename) throws IOException;\n\n\t/**\n\t * Utility method to write a graph in the chosen format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @param output\n\t *            The output format to use.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(FileSink output, String filename) throws IOException;\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but may be limited. This method\n\t * automatically launch a graph layout algorithm in its own thread to\n\t * compute best node positions.\n\t * \n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display(boolean )\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display();\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but is very limited.\n\t * \n\t * @param autoLayout\n\t *            If true a layout algorithm is launched in its own thread to\n\t *            compute best node positions.\n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display()\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display(boolean autoLayout);\n\n\t// New methods\n\n\t/**\n\t * Get a node by its index. This method is implicitly generic and returns\n\t * something which extends Node. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param index\n\t *            Index of the node to find.\n\t * @return The node with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             If the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T getNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Get an edge by its index. This method is implicitly generic and returns\n\t * something which extends Edge. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param index\n\t *            The index of the edge to find.\n\t * @return The edge with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is less than 0 or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param index1\n\t *            The first node index\n\t * @param index2\n\t *            The second node index\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int index1, int index2)\n\t\t\tthrows IndexOutOfBoundsException, IdAlreadyInUseException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param toIndex\n\t *            The first node index\n\t * @param fromIndex\n\t *            The second node index\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int fromIndex, int toIndex,\n\t\t\tboolean directed) throws IndexOutOfBoundsException,\n\t\t\tIdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the node references are\n\t * given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node\n\t * @param node2\n\t *            The second node\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node node1, Node node2)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the node\n\t * references are given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param from\n\t *            The first node\n\t * @param to\n\t *            The second node\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Removes an edge with a given index. An event is sent toward the\n\t * listeners.\n\t * \n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.removeEdge(i);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the edge to be removed.\n\t * @return The removed edge\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getEdgeCount() - 1}\n\t */\n\t<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but the nodes are identified by their\n\t * indices.\n\t * \n\t * @param fromIndex\n\t *            the index of the source node\n\t * @param toIndex\n\t *            the index of the target node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws IndexOutOfBoundsException\n\t *             If one of the node indices is negative or greater than\n\t *             {@code getNodeCount() - 1}.\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(int fromIndex, int toIndex)\n\t\t\tthrows IndexOutOfBoundsException, ElementNotFoundException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but node references are given instead\n\t * of node identifiers.\n\t * \n\t * @param node1\n\t *            the first node\n\t * @param node2\n\t *            the second node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(Node node1, Node node2)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge. An event is sent toward the listeners.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * \n\t * \n\t * @param edge\n\t *            The edge to be removed\n\t * @return The removed edge\n\t */\n\t<T extends Edge> T removeEdge(Edge edge);\n\n\t/**\n\t * Removes a node with a given index.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the node to be removed\n\t * @return The removed node\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes a node.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param node\n\t *            The node to be removed\n\t * @return The removed node\n\t */\n\t<T extends Node> T removeNode(Node node);\n}",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ [ "1", "int" ], [ "2", "int" ] ],
  "tokensMethodArguments" : [ [ "node1", "org.graphstream.graph", "Node" ], [ "node2", "org.graphstream.graph", "Node" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(String[] arg0)" ], [ "getEdgeCount", "org.graphstream.graph", "Structure", "public abstract int getEdgeCount()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0)" ], [ "getEdgeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getEdgeIterator()" ], [ "getAttributeCount", "org.graphstream.graph", "Element", "public abstract int getAttributeCount()" ], [ "getArray", "org.graphstream.graph", "Element", "public abstract Object[] getArray(String arg0)" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(Node node)" ], [ "edgeFactory", "org.graphstream.graph", "Graph", "EdgeFactory<? extends Edge> edgeFactory()" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display(boolean autoLayout)" ], [ "hasVector", "org.graphstream.graph", "Element", "public abstract boolean hasVector(String arg0)" ], [ "getEachAttributeKey", "org.graphstream.graph", "Element", "public abstract Iterable<String> getEachAttributeKey()" ], [ "getNodeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getNodeIterator()" ], [ "hasHash", "org.graphstream.graph", "Element", "public abstract boolean hasHash(String arg0)" ], [ "isStrict", "org.graphstream.graph", "Graph", "boolean isStrict()" ], [ "isAutoCreationEnabled", "org.graphstream.graph", "Graph", "boolean isAutoCreationEnabled()" ], [ "getNumber", "org.graphstream.graph", "Element", "public abstract double getNumber(String arg0)" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "getHash", "org.graphstream.graph", "Element", "public abstract HashMap<?, ?> getHash(String arg0)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int index1, int index2) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "getStep", "org.graphstream.graph", "Graph", "double getStep()" ], [ "hasArray", "org.graphstream.graph", "Element", "public abstract boolean hasArray(String arg0)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String node1, String node2) throws IdAlreadyInUseException, ElementNotFoundException, EdgeRejectedException" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String id) throws ElementNotFoundException" ], [ "getAttributeKeyIterator", "org.graphstream.graph", "Element", "public abstract Iterator<String> getAttributeKeyIterator()" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display()" ], [ "getEachEdge", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachEdge()" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0, Class<T> arg1)" ], [ "getAttributeKeySet", "org.graphstream.graph", "Element", "public abstract Collection<String> getAttributeKeySet()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getEdgeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getEdgeSet()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(String id) throws ElementNotFoundException" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(String id)" ], [ "getEachNode", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachNode()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Edge edge)" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0)" ], [ "getLabel", "org.graphstream.graph", "Element", "public abstract CharSequence getLabel(String arg0)" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(Class<T> arg0, String[] arg1)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node node1, Node node2) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int fromIndex, int toIndex, boolean directed) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "hasLabel", "org.graphstream.graph", "Element", "public abstract boolean hasLabel(String arg0)" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0, Class<?> arg1)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Node node1, Node node2) throws ElementNotFoundException" ], [ "addNode", "org.graphstream.graph", "Graph", "<T extends Node> T addNode(String id) throws IdAlreadyInUseException" ], [ "getIndex", "org.graphstream.graph", "Element", "public abstract int getIndex()" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(String id)" ], [ "nodeFactory", "org.graphstream.graph", "Graph", "NodeFactory<? extends Node> nodeFactory()" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(int index) throws IndexOutOfBoundsException" ], [ "getNodeCount", "org.graphstream.graph", "Structure", "public abstract int getNodeCount()" ], [ "getVector", "org.graphstream.graph", "Element", "public abstract ArrayList<? extends Number> getVector(String arg0)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "nullAttributesAreErrors", "org.graphstream.graph", "Graph", "boolean nullAttributesAreErrors()" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "elementSinks", "org.graphstream.graph", "Graph", "Iterable<ElementSink> elementSinks()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String from, String to) throws ElementNotFoundException" ], [ "getNodeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getNodeSet()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int fromIndex, int toIndex) throws IndexOutOfBoundsException, ElementNotFoundException" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String from, String to, boolean directed) throws IdAlreadyInUseException, ElementNotFoundException" ], [ "hasNumber", "org.graphstream.graph", "Element", "public abstract boolean hasNumber(String arg0)" ], [ "getId", "org.graphstream.graph", "Element", "public abstract String getId()" ], [ "attributeSinks", "org.graphstream.graph", "Graph", "Iterable<AttributeSink> attributeSinks()" ], [ "getEdgeBetween", "org.graphstream.graph", "Node", "public abstract <T> T getEdgeBetween(Node arg0)" ], [ "hasEdgeFrom", "org.graphstream.graph", "Node", "public abstract boolean hasEdgeFrom(String arg0)" ], [ "hasEdgeBetween", "org.graphstream.graph", "Node", "public abstract boolean hasEdgeBetween(String arg0)" ], [ "getBreadthFirstIterator", "org.graphstream.graph", "Node", "public abstract <T> Iterator<T> getBreadthFirstIterator(boolean arg0)" ], [ "getEdgeFrom", "org.graphstream.graph", "Node", "public abstract <T> T getEdgeFrom(String arg0)" ], [ "getEdgeIterator", "org.graphstream.graph", "Node", "public abstract <T> Iterator<T> getEdgeIterator()" ], [ "getEnteringEdgeSet", "org.graphstream.graph", "Node", "public abstract <T> Collection<T> getEnteringEdgeSet()" ], [ "hasEdgeFrom", "org.graphstream.graph", "Node", "public abstract boolean hasEdgeFrom(Node arg0)" ], [ "getEdgeBetween", "org.graphstream.graph", "Node", "public abstract <T> T getEdgeBetween(String arg0)" ], [ "getEachLeavingEdge", "org.graphstream.graph", "Node", "public abstract <T> Iterable<T> getEachLeavingEdge()" ], [ "hasEdgeFrom", "org.graphstream.graph", "Node", "public abstract boolean hasEdgeFrom(int arg0) throws IndexOutOfBoundsException" ], [ "hasEdgeBetween", "org.graphstream.graph", "Node", "public abstract boolean hasEdgeBetween(int arg0) throws IndexOutOfBoundsException" ], [ "getEnteringEdgeIterator", "org.graphstream.graph", "Node", "public abstract <T> Iterator<T> getEnteringEdgeIterator()" ], [ "getNeighborNodeIterator", "org.graphstream.graph", "Node", "public abstract <T> Iterator<T> getNeighborNodeIterator()" ], [ "getEdgeSet", "org.graphstream.graph", "Node", "public abstract <T> Collection<T> getEdgeSet()" ], [ "hasEdgeBetween", "org.graphstream.graph", "Node", "public abstract boolean hasEdgeBetween(Node arg0)" ], [ "getGraph", "org.graphstream.graph", "Node", "public abstract Graph getGraph()" ], [ "toString", "org.graphstream.graph", "Node", "public abstract String toString()" ], [ "getEdgeFrom", "org.graphstream.graph", "Node", "public abstract <T> T getEdgeFrom(int arg0) throws IndexOutOfBoundsException" ], [ "getBreadthFirstIterator", "org.graphstream.graph", "Node", "public abstract <T> Iterator<T> getBreadthFirstIterator()" ], [ "getEdgeToward", "org.graphstream.graph", "Node", "public abstract <T> T getEdgeToward(String arg0)" ], [ "getEdgeBetween", "org.graphstream.graph", "Node", "public abstract <T> T getEdgeBetween(int arg0) throws IndexOutOfBoundsException" ], [ "getInDegree", "org.graphstream.graph", "Node", "public abstract int getInDegree()" ], [ "getEdgeToward", "org.graphstream.graph", "Node", "public abstract <T> T getEdgeToward(int arg0) throws IndexOutOfBoundsException" ], [ "getOutDegree", "org.graphstream.graph", "Node", "public abstract int getOutDegree()" ], [ "getDepthFirstIterator", "org.graphstream.graph", "Node", "public abstract <T> Iterator<T> getDepthFirstIterator(boolean arg0)" ], [ "getLeavingEdge", "org.graphstream.graph", "Node", "public abstract <T> T getLeavingEdge(int arg0)" ], [ "getEnteringEdge", "org.graphstream.graph", "Node", "public abstract <T> T getEnteringEdge(int arg0)" ], [ "getEachEnteringEdge", "org.graphstream.graph", "Node", "public abstract <T> Iterable<T> getEachEnteringEdge()" ], [ "getLeavingEdgeIterator", "org.graphstream.graph", "Node", "public abstract <T> Iterator<T> getLeavingEdgeIterator()" ], [ "getEdgeFrom", "org.graphstream.graph", "Node", "public abstract <T> T getEdgeFrom(Node arg0)" ], [ "getEdgeToward", "org.graphstream.graph", "Node", "public abstract <T> T getEdgeToward(Node arg0)" ], [ "getEdge", "org.graphstream.graph", "Node", "public abstract <T> T getEdge(int arg0)" ], [ "getDepthFirstIterator", "org.graphstream.graph", "Node", "public abstract <T> Iterator<T> getDepthFirstIterator()" ], [ "getLeavingEdgeSet", "org.graphstream.graph", "Node", "public abstract <T> Collection<T> getLeavingEdgeSet()" ], [ "getEachEdge", "org.graphstream.graph", "Node", "public abstract <T> Iterable<T> getEachEdge()" ], [ "hasEdgeToward", "org.graphstream.graph", "Node", "public abstract boolean hasEdgeToward(int arg0) throws IndexOutOfBoundsException" ], [ "hasEdgeToward", "org.graphstream.graph", "Node", "public abstract boolean hasEdgeToward(String arg0)" ], [ "hasEdgeToward", "org.graphstream.graph", "Node", "public abstract boolean hasEdgeToward(Node arg0)" ], [ "getDegree", "org.graphstream.graph", "Node", "public abstract int getDegree()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 4209,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.graph",
  "className" : "Graph",
  "javadocTag" : "@throws ElementNotFoundException if strict checking is enabled and there is no edge between\n            the two nodes.",
  "methodJavadoc" : "    /**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but node references are given instead\n\t * of node identifiers.\n\t * \n\t * @param node1\n\t *            the first node\n\t * @param node2\n\t *            the second node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */",
  "methodSourceCode" : "<T extends Edge> T removeEdge(Node node1, Node node2) throws ElementNotFoundException;",
  "classJavadoc" : "/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.graph;\n\nimport java.io.IOException;\n\nimport org.graphstream.stream.AttributeSink;\nimport org.graphstream.stream.ElementSink;\nimport org.graphstream.stream.GraphParseException;\nimport org.graphstream.stream.Pipe;\nimport org.graphstream.stream.file.FileSink;\nimport org.graphstream.stream.file.FileSource;\nimport org.graphstream.ui.view.Viewer;\n\n\n/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */\npublic interface Graph extends Element, Pipe, Iterable<Node>, Structure {\n\t// Access\n\n\t/**\n\t * Get a node by its identifier. This method is implicitly generic and\n\t * returns something which extends Node. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param id\n\t *            Identifier of the node to find.\n\t * @return The searched node or null if not found.\n\t */\n\t<T extends Node> T getNode(String id);\n\n\t/**\n\t * Get an edge by its identifier. This method is implicitly generic and\n\t * returns something which extends Edge. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param id\n\t *            Identifier of the edge to find.\n\t * @return The searched edge or null if not found.\n\t */\n\t<T extends Edge> T getEdge(String id);\n\n\t/**\n\t * The factory used to create node instances. The factory can be changed to\n\t * refine the node class generated for this graph.\n\t * \n\t * @see #setNodeFactory(NodeFactory)\n\t * @see #edgeFactory()\n\t */\n\tNodeFactory<? extends Node> nodeFactory();\n\n\t/**\n\t * The factory used to create edge instances. The factory can be changed to\n\t * refine the edge class generated for this graph.\n\t * \n\t * @see #setEdgeFactory(EdgeFactory)\n\t * @see #nodeFactory()\n\t */\n\tEdgeFactory<? extends Edge> edgeFactory();\n\n\t/**\n\t * Is strict checking enabled? If strict checking is enabled the graph\n\t * checks for name space conflicts (e.g. insertion of two nodes with the\n\t * same name), removal of non-existing elements, use of non existing\n\t * elements (create an edge between two non existing nodes). Graph\n\t * implementations are free to respect strict checking or not.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isStrict();\n\n\t/**\n\t * Is the automatic creation of missing elements enabled?. If strict\n\t * checking is disabled and auto-creation is enabled, when an edge is\n\t * created and one or two of its nodes are not already present in the graph,\n\t * the nodes are automatically created.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isAutoCreationEnabled();\n\n\t/**\n\t * If true, when accessing an attribute that does not exist (or is not of\n\t * the expected type), a {@link NullAttributeException} is thrown. Else null\n\t * is returned.\n\t * \n\t * @return True if exceptions must be thrown when accessing a null\n\t *         attribute.\n\t */\n\tboolean nullAttributesAreErrors();\n\n\t/**\n\t * The current step.\n\t * \n\t * @return The step.\n\t */\n\tdouble getStep();\n\n\t// Command\n\n\t/**\n\t * Should a {@link NullAttributeException} be thrown when one tries to\n\t * access a non existing attribute, or an attribute whose type is not the\n\t * expected one?.\n\t * \n\t * @param on\n\t *            if true, exceptions will be thrown when accessing a non\n\t *            existing attribute.\n\t */\n\tvoid setNullAttributesAreErrors(boolean on);\n\n\t/**\n\t * Set the node factory used to create nodes.\n\t * \n\t * @param nf\n\t *            the new NodeFactory\n\t */\n\tvoid setNodeFactory(NodeFactory<? extends Node> nf);\n\n\t/**\n\t * Set the edge factory used to create edges.\n\t * \n\t * @param ef\n\t *            the new EdgeFactory\n\t */\n\tvoid setEdgeFactory(EdgeFactory<? extends Edge> ef);\n\n\t/**\n\t * Enable or disable strict checking.\n\t * \n\t * @see #isStrict()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setStrict(boolean on);\n\n\t/**\n\t * Enable or disable the automatic creation of missing elements.\n\t * \n\t * @see #isAutoCreationEnabled()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setAutoCreate(boolean on);\n\n\t// Graph construction\n\n\t/**\n\t * Empty the graph completely by removing any references to nodes or edges.\n\t * Every attribute is also removed. However, listeners are kept.\n\t * \n\t * @see #clearSinks()\n\t */\n\tvoid clear();\n\n\t/**\n\t * Add a node in the graph.\n\t * <p>\n\t * This acts as a factory, creating the node instance automatically (and\n\t * eventually using the node factory provided). An event is generated toward\n\t * the listeners. If strict checking is enabled, and a node already exists\n\t * with this identifier, an\n\t * {@link org.graphstream.graph.IdAlreadyInUseException} is raised. Else the\n\t * error is silently ignored and the already existing node is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.addNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            Arbitrary and unique string identifying the node.\n\t * @return The created node (or the already existing node).\n\t * @throws IdAlreadyInUseException\n\t *             If strict checking is enabled the identifier is already used.\n\t */\n\t<T extends Node> T addNode(String id) throws IdAlreadyInUseException;\n\n\t/**\n\t * Remove a node using its identifier.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            The unique identifier of the node to remove.\n\t * @return The removed node. If strict checking is disabled, it can return\n\t *         null if the node to remove does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no node matches the given identifier and strict checking\n\t *             is enabled.\n\t */\n\t<T extends Node> T removeNode(String id) throws ElementNotFoundException;\n\n\t/**\n\t * Adds an undirected edge between nodes.\n\t * \n\t * <p>\n\t * The behavior of this method depends on many conditions. It can be\n\t * summarized as follows.\n\t * </p>\n\t * \n\t * <p>\n\t * First of all, the method checks if the graph already contains an edge\n\t * with the same id. If this is the case and strict checking is enabled,\n\t * {@code IdAlreadyInUseException} is thrown. If the strict checking is\n\t * disabled the method returns a reference to the existing edge if it has\n\t * endpoints {@code node1} and {@code node2} (in the same order if the edge\n\t * is directed) or {@code null} otherwise.\n\t * </p>\n\t * \n\t * <p>\n\t * In the case when the graph does not contain an edge with the same id, the\n\t * method checks if {@code node1} and {@code node2} exist. If one or both of\n\t * them do not exist, and strict checking is enabled, {@code\n\t * ElementNotFoundException} is thrown. Otherwise if auto-creation is\n\t * disabled, the method returns {@code null}. If auto-creation is enabled,\n\t * the method creates the missing endpoints.\n\t * \n\t * <p>\n\t * When the edge id is not already in use and the both endpoints exist (or\n\t * created), the edge can still be rejected. It may happen for example when\n\t * it connects two already connected nodes in a single graph. If the edge is\n\t * rejected, the method throws {@code EdgeRejectedException} if strict\n\t * checking is enabled or returns {@code null} otherwise. Finally, if the\n\t * edge is accepted, it is created using the corresponding edge factory and\n\t * a reference to it is returned.\n\t * \n\t * <p>\n\t * An edge creation event is sent toward the listeners. If new nodes are\n\t * created, the corresponding events are also sent to the listeners.\n\t * </p>\n\t * \n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.addEdge(&quot;...&quot;, &quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * \n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t */\n\t<T extends Edge> T addEdge(String id, String node1, String node2)\n\t\t\tthrows IdAlreadyInUseException, ElementNotFoundException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)}, but this edge can be\n\t * directed between the two given nodes. If directed, the edge goes in the\n\t * 'from' -&gt; 'to' direction. An event is sent toward the listeners.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, String from, String to,\n\t\t\tboolean directed) throws IdAlreadyInUseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Remove an edge given the identifiers of its two endpoints.\n\t * <p>\n\t * If the edge is directed it is removed only if its source and destination\n\t * nodes are identified by 'from' and 'to' respectively. If the graph is a\n\t * multi-graph and there are several edges between the two nodes, one of the\n\t * edges at random is removed. An event is sent toward the listeners. If\n\t * strict checking is enabled and at least one of the two given nodes does\n\t * not exist or if they are not connected, a not found exception is raised.\n\t * Else the error is silently ignored, and null is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param from\n\t *            The origin node identifier to select the edge.\n\t * @param to\n\t *            The destination node identifier to select the edge.\n\t * @return The removed edge, or null if strict checking is disabled and at\n\t *         least one of the two given nodes does not exist or there is no\n\t *         edge between them\n\t * @throws ElementNotFoundException\n\t *             If the 'from' or 'to' node is not registered in the graph or\n\t *             not connected and strict checking is enabled.\n\t */\n\t<T extends Edge> T removeEdge(String from, String to)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge knowing its identifier. An event is sent toward the\n\t * listeners. If strict checking is enabled and the edge does not exist,\n\t * {@code ElementNotFoundException} is raised. Otherwise the error is\n\t * silently ignored and null is returned.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Identifier of the edge to remove.\n\t * @return The removed edge, or null if strict checking is disabled and the\n\t *         edge does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no edge matches the identifier and strict checking is\n\t *             enabled.\n\t */\n\t<T extends Edge> T removeEdge(String id) throws ElementNotFoundException;\n\n\t/**\n\t * <p>\n\t * Since dynamic graphs are based on discrete event modifications, the\n\t * notion of step is defined to simulate elapsed time between events. So a\n\t * step is a event that occurs in the graph, it does not modify it but it\n\t * gives a kind of timestamp that allows the tracking of the progress of the\n\t * graph over the time.\n\t * </p>\n\t * <p>\n\t * This kind of event is useful for dynamic algorithms that listen to the\n\t * dynamic graph and need to measure the time in the graph's evolution.\n\t * </p>\n\t * \n\t * @param time\n\t *            A numerical value that may give a timestamp to track the\n\t *            evolution of the graph over the time.\n\t */\n\tvoid stepBegins(double time);\n\n\t// Source\n\t// XXX do we put the iterable attributeSinks and elementSinks in Source ?\n\n\t/**\n\t * Returns an \"iterable\" of {@link AttributeSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the set of {@link AttributeSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<AttributeSink> attributeSinks();\n\n\t/**\n\t * Returns an \"iterable\" of {@link ElementSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the list of {@link ElementSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<ElementSink> elementSinks();\n\n\t// Utility shortcuts (should be mixins or traits, what are you doing Mr Java\n\t// ?)\n\t// XXX use a Readable/Writable/Displayable interface for this ?\n\n\t/**\n\t * Utility method to read a graph. This method tries to identify the graph\n\t * format by itself and instantiates the corresponding reader automatically.\n\t * If this process fails, a NotFoundException is raised.\n\t * \n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognized.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input output error occurs during the graph reading.\n\t */\n\tvoid read(String filename) throws IOException, GraphParseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Utility method to read a graph using the given reader.\n\t * \n\t * @param input\n\t *            An appropriate reader for the filename.\n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognised.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph reading.\n\t */\n\tvoid read(FileSource input, String filename) throws IOException,\n\t\t\tGraphParseException;\n\n\t/**\n\t * Utility method to write a graph in DGS format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(String filename) throws IOException;\n\n\t/**\n\t * Utility method to write a graph in the chosen format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @param output\n\t *            The output format to use.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(FileSink output, String filename) throws IOException;\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but may be limited. This method\n\t * automatically launch a graph layout algorithm in its own thread to\n\t * compute best node positions.\n\t * \n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display(boolean )\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display();\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but is very limited.\n\t * \n\t * @param autoLayout\n\t *            If true a layout algorithm is launched in its own thread to\n\t *            compute best node positions.\n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display()\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display(boolean autoLayout);\n\n\t// New methods\n\n\t/**\n\t * Get a node by its index. This method is implicitly generic and returns\n\t * something which extends Node. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param index\n\t *            Index of the node to find.\n\t * @return The node with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             If the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T getNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Get an edge by its index. This method is implicitly generic and returns\n\t * something which extends Edge. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param index\n\t *            The index of the edge to find.\n\t * @return The edge with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is less than 0 or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param index1\n\t *            The first node index\n\t * @param index2\n\t *            The second node index\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int index1, int index2)\n\t\t\tthrows IndexOutOfBoundsException, IdAlreadyInUseException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param toIndex\n\t *            The first node index\n\t * @param fromIndex\n\t *            The second node index\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int fromIndex, int toIndex,\n\t\t\tboolean directed) throws IndexOutOfBoundsException,\n\t\t\tIdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the node references are\n\t * given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node\n\t * @param node2\n\t *            The second node\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node node1, Node node2)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the node\n\t * references are given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param from\n\t *            The first node\n\t * @param to\n\t *            The second node\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Removes an edge with a given index. An event is sent toward the\n\t * listeners.\n\t * \n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.removeEdge(i);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the edge to be removed.\n\t * @return The removed edge\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getEdgeCount() - 1}\n\t */\n\t<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but the nodes are identified by their\n\t * indices.\n\t * \n\t * @param fromIndex\n\t *            the index of the source node\n\t * @param toIndex\n\t *            the index of the target node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws IndexOutOfBoundsException\n\t *             If one of the node indices is negative or greater than\n\t *             {@code getNodeCount() - 1}.\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(int fromIndex, int toIndex)\n\t\t\tthrows IndexOutOfBoundsException, ElementNotFoundException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but node references are given instead\n\t * of node identifiers.\n\t * \n\t * @param node1\n\t *            the first node\n\t * @param node2\n\t *            the second node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(Node node1, Node node2)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge. An event is sent toward the listeners.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * \n\t * \n\t * @param edge\n\t *            The edge to be removed\n\t * @return The removed edge\n\t */\n\t<T extends Edge> T removeEdge(Edge edge);\n\n\t/**\n\t * Removes a node with a given index.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the node to be removed\n\t * @return The removed node\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes a node.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param node\n\t *            The node to be removed\n\t * @return The removed node\n\t */\n\t<T extends Node> T removeNode(Node node);\n}",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ [ "1", "int" ], [ "2", "int" ] ],
  "tokensMethodArguments" : [ [ "node1", "org.graphstream.graph", "Node" ], [ "node2", "org.graphstream.graph", "Node" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(Class<T> arg0, String[] arg1)" ], [ "getAttributeKeySet", "org.graphstream.graph", "Element", "public abstract Collection<String> getAttributeKeySet()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int fromIndex, int toIndex) throws IndexOutOfBoundsException, ElementNotFoundException" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0)" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(String id)" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(String id) throws ElementNotFoundException" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Node node1, Node node2) throws ElementNotFoundException" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display()" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int fromIndex, int toIndex, boolean directed) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "getVector", "org.graphstream.graph", "Element", "public abstract ArrayList<? extends Number> getVector(String arg0)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "elementSinks", "org.graphstream.graph", "Graph", "Iterable<ElementSink> elementSinks()" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0, Class<T> arg1)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node node1, Node node2) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "hasHash", "org.graphstream.graph", "Element", "public abstract boolean hasHash(String arg0)" ], [ "isStrict", "org.graphstream.graph", "Graph", "boolean isStrict()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String node1, String node2) throws IdAlreadyInUseException, ElementNotFoundException, EdgeRejectedException" ], [ "getNodeCount", "org.graphstream.graph", "Structure", "public abstract int getNodeCount()" ], [ "nullAttributesAreErrors", "org.graphstream.graph", "Graph", "boolean nullAttributesAreErrors()" ], [ "hasVector", "org.graphstream.graph", "Element", "public abstract boolean hasVector(String arg0)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String from, String to, boolean directed) throws IdAlreadyInUseException, ElementNotFoundException" ], [ "getAttributeKeyIterator", "org.graphstream.graph", "Element", "public abstract Iterator<String> getAttributeKeyIterator()" ], [ "nodeFactory", "org.graphstream.graph", "Graph", "NodeFactory<? extends Node> nodeFactory()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String id) throws ElementNotFoundException" ], [ "hasLabel", "org.graphstream.graph", "Element", "public abstract boolean hasLabel(String arg0)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int index1, int index2) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "getNodeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getNodeSet()" ], [ "getArray", "org.graphstream.graph", "Element", "public abstract Object[] getArray(String arg0)" ], [ "hasArray", "org.graphstream.graph", "Element", "public abstract boolean hasArray(String arg0)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "getNodeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getNodeIterator()" ], [ "getEdgeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getEdgeIterator()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getEachEdge", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachEdge()" ], [ "getEachAttributeKey", "org.graphstream.graph", "Element", "public abstract Iterable<String> getEachAttributeKey()" ], [ "getIndex", "org.graphstream.graph", "Element", "public abstract int getIndex()" ], [ "getNumber", "org.graphstream.graph", "Element", "public abstract double getNumber(String arg0)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String from, String to) throws ElementNotFoundException" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(String[] arg0)" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException" ], [ "getEachNode", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachNode()" ], [ "attributeSinks", "org.graphstream.graph", "Graph", "Iterable<AttributeSink> attributeSinks()" ], [ "hasNumber", "org.graphstream.graph", "Element", "public abstract boolean hasNumber(String arg0)" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0, Class<?> arg1)" ], [ "isAutoCreationEnabled", "org.graphstream.graph", "Graph", "boolean isAutoCreationEnabled()" ], [ "getAttributeCount", "org.graphstream.graph", "Element", "public abstract int getAttributeCount()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(String id)" ], [ "edgeFactory", "org.graphstream.graph", "Graph", "EdgeFactory<? extends Edge> edgeFactory()" ], [ "getEdgeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getEdgeSet()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(Node node)" ], [ "getHash", "org.graphstream.graph", "Element", "public abstract HashMap<?, ?> getHash(String arg0)" ], [ "getId", "org.graphstream.graph", "Element", "public abstract String getId()" ], [ "getEdgeCount", "org.graphstream.graph", "Structure", "public abstract int getEdgeCount()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getLabel", "org.graphstream.graph", "Element", "public abstract CharSequence getLabel(String arg0)" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Edge edge)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(int index) throws IndexOutOfBoundsException" ], [ "addNode", "org.graphstream.graph", "Graph", "<T extends Node> T addNode(String id) throws IdAlreadyInUseException" ], [ "getStep", "org.graphstream.graph", "Graph", "double getStep()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display(boolean autoLayout)" ], [ "getEdgeSet", "org.graphstream.graph", "Node", "public abstract <T> Collection<T> getEdgeSet()" ], [ "getEdgeBetween", "org.graphstream.graph", "Node", "public abstract <T> T getEdgeBetween(String arg0)" ], [ "hasEdgeFrom", "org.graphstream.graph", "Node", "public abstract boolean hasEdgeFrom(int arg0) throws IndexOutOfBoundsException" ], [ "hasEdgeToward", "org.graphstream.graph", "Node", "public abstract boolean hasEdgeToward(String arg0)" ], [ "getEnteringEdge", "org.graphstream.graph", "Node", "public abstract <T> T getEnteringEdge(int arg0)" ], [ "getBreadthFirstIterator", "org.graphstream.graph", "Node", "public abstract <T> Iterator<T> getBreadthFirstIterator(boolean arg0)" ], [ "getEnteringEdgeIterator", "org.graphstream.graph", "Node", "public abstract <T> Iterator<T> getEnteringEdgeIterator()" ], [ "hasEdgeFrom", "org.graphstream.graph", "Node", "public abstract boolean hasEdgeFrom(String arg0)" ], [ "getEdge", "org.graphstream.graph", "Node", "public abstract <T> T getEdge(int arg0)" ], [ "getEdgeToward", "org.graphstream.graph", "Node", "public abstract <T> T getEdgeToward(Node arg0)" ], [ "getInDegree", "org.graphstream.graph", "Node", "public abstract int getInDegree()" ], [ "toString", "org.graphstream.graph", "Node", "public abstract String toString()" ], [ "hasEdgeToward", "org.graphstream.graph", "Node", "public abstract boolean hasEdgeToward(int arg0) throws IndexOutOfBoundsException" ], [ "getEachLeavingEdge", "org.graphstream.graph", "Node", "public abstract <T> Iterable<T> getEachLeavingEdge()" ], [ "getEdgeFrom", "org.graphstream.graph", "Node", "public abstract <T> T getEdgeFrom(int arg0) throws IndexOutOfBoundsException" ], [ "hasEdgeBetween", "org.graphstream.graph", "Node", "public abstract boolean hasEdgeBetween(int arg0) throws IndexOutOfBoundsException" ], [ "getEdgeFrom", "org.graphstream.graph", "Node", "public abstract <T> T getEdgeFrom(Node arg0)" ], [ "getEdgeBetween", "org.graphstream.graph", "Node", "public abstract <T> T getEdgeBetween(Node arg0)" ], [ "getDegree", "org.graphstream.graph", "Node", "public abstract int getDegree()" ], [ "getNeighborNodeIterator", "org.graphstream.graph", "Node", "public abstract <T> Iterator<T> getNeighborNodeIterator()" ], [ "getBreadthFirstIterator", "org.graphstream.graph", "Node", "public abstract <T> Iterator<T> getBreadthFirstIterator()" ], [ "getDepthFirstIterator", "org.graphstream.graph", "Node", "public abstract <T> Iterator<T> getDepthFirstIterator()" ], [ "getEachEdge", "org.graphstream.graph", "Node", "public abstract <T> Iterable<T> getEachEdge()" ], [ "getEdgeFrom", "org.graphstream.graph", "Node", "public abstract <T> T getEdgeFrom(String arg0)" ], [ "getEnteringEdgeSet", "org.graphstream.graph", "Node", "public abstract <T> Collection<T> getEnteringEdgeSet()" ], [ "getLeavingEdge", "org.graphstream.graph", "Node", "public abstract <T> T getLeavingEdge(int arg0)" ], [ "hasEdgeBetween", "org.graphstream.graph", "Node", "public abstract boolean hasEdgeBetween(Node arg0)" ], [ "getEachEnteringEdge", "org.graphstream.graph", "Node", "public abstract <T> Iterable<T> getEachEnteringEdge()" ], [ "getEdgeBetween", "org.graphstream.graph", "Node", "public abstract <T> T getEdgeBetween(int arg0) throws IndexOutOfBoundsException" ], [ "hasEdgeToward", "org.graphstream.graph", "Node", "public abstract boolean hasEdgeToward(Node arg0)" ], [ "getEdgeToward", "org.graphstream.graph", "Node", "public abstract <T> T getEdgeToward(int arg0) throws IndexOutOfBoundsException" ], [ "getLeavingEdgeSet", "org.graphstream.graph", "Node", "public abstract <T> Collection<T> getLeavingEdgeSet()" ], [ "getEdgeToward", "org.graphstream.graph", "Node", "public abstract <T> T getEdgeToward(String arg0)" ], [ "getDepthFirstIterator", "org.graphstream.graph", "Node", "public abstract <T> Iterator<T> getDepthFirstIterator(boolean arg0)" ], [ "getOutDegree", "org.graphstream.graph", "Node", "public abstract int getOutDegree()" ], [ "getLeavingEdgeIterator", "org.graphstream.graph", "Node", "public abstract <T> Iterator<T> getLeavingEdgeIterator()" ], [ "getEdgeIterator", "org.graphstream.graph", "Node", "public abstract <T> Iterator<T> getEdgeIterator()" ], [ "hasEdgeBetween", "org.graphstream.graph", "Node", "public abstract boolean hasEdgeBetween(String arg0)" ], [ "getGraph", "org.graphstream.graph", "Node", "public abstract Graph getGraph()" ], [ "hasEdgeFrom", "org.graphstream.graph", "Node", "public abstract boolean hasEdgeFrom(Node arg0)" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 4228,
  "oracle" : ";",
  "oracleType" : "PRE",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.graph",
  "className" : "EdgeFactory",
  "javadocTag" : "@param id The new edge identifier.",
  "methodJavadoc" : "    /**\n\t * Create a new instance of edge.\n\t * \n\t * @param id\n\t *            The new edge identifier.\n\t * @param src\n\t *            The source node.\n\t * @param dst\n\t *            The target node.\n\t * @param directed\n\t *            Is the edge directed (in the direction source toward target).\n\t * @return The newly created edge.\n\t */",
  "methodSourceCode" : "T newInstance(String id, Node src, Node dst, boolean directed);",
  "classJavadoc" : "/**\n * An interface aimed at dynamically creating edge objects.\n * \n * @since September 2007\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.graph;\n\n/**\n * An interface aimed at dynamically creating edge objects.\n * \n * @since September 2007\n */\npublic interface EdgeFactory<T extends Edge> {\n\t/**\n\t * Create a new instance of edge.\n\t * \n\t * @param id\n\t *            The new edge identifier.\n\t * @param src\n\t *            The source node.\n\t * @param dst\n\t *            The target node.\n\t * @param directed\n\t *            Is the edge directed (in the direction source toward target).\n\t * @return The newly created edge.\n\t */\n\tT newInstance(String id, Node src, Node dst, boolean directed);\n}",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "id", "java.lang", "String" ], [ "src", "org.graphstream.graph", "Node" ], [ "dst", "org.graphstream.graph", "Node" ], [ "directed", "", "boolean" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "newInstance", "org.graphstream.graph", "EdgeFactory", "T newInstance(String id, Node src, Node dst, boolean directed)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "length", "java.lang", "String", "public int length()" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ], [ "getLeavingEdgeSet", "org.graphstream.graph", "Node", "public abstract <T> Collection<T> getLeavingEdgeSet()" ], [ "getEdgeToward", "org.graphstream.graph", "Node", "public abstract <T> T getEdgeToward(Node arg0)" ], [ "hasEdgeToward", "org.graphstream.graph", "Node", "public abstract boolean hasEdgeToward(String arg0)" ], [ "getEdgeBetween", "org.graphstream.graph", "Node", "public abstract <T> T getEdgeBetween(int arg0) throws IndexOutOfBoundsException" ], [ "getOutDegree", "org.graphstream.graph", "Node", "public abstract int getOutDegree()" ], [ "getEdgeToward", "org.graphstream.graph", "Node", "public abstract <T> T getEdgeToward(String arg0)" ], [ "getGraph", "org.graphstream.graph", "Node", "public abstract Graph getGraph()" ], [ "getBreadthFirstIterator", "org.graphstream.graph", "Node", "public abstract <T> Iterator<T> getBreadthFirstIterator()" ], [ "getEdgeFrom", "org.graphstream.graph", "Node", "public abstract <T> T getEdgeFrom(int arg0) throws IndexOutOfBoundsException" ], [ "getNeighborNodeIterator", "org.graphstream.graph", "Node", "public abstract <T> Iterator<T> getNeighborNodeIterator()" ], [ "hasEdgeFrom", "org.graphstream.graph", "Node", "public abstract boolean hasEdgeFrom(Node arg0)" ], [ "getEdgeFrom", "org.graphstream.graph", "Node", "public abstract <T> T getEdgeFrom(Node arg0)" ], [ "getInDegree", "org.graphstream.graph", "Node", "public abstract int getInDegree()" ], [ "hasEdgeBetween", "org.graphstream.graph", "Node", "public abstract boolean hasEdgeBetween(int arg0) throws IndexOutOfBoundsException" ], [ "getEdge", "org.graphstream.graph", "Node", "public abstract <T> T getEdge(int arg0)" ], [ "getEdgeBetween", "org.graphstream.graph", "Node", "public abstract <T> T getEdgeBetween(String arg0)" ], [ "getEnteringEdgeIterator", "org.graphstream.graph", "Node", "public abstract <T> Iterator<T> getEnteringEdgeIterator()" ], [ "getEachEnteringEdge", "org.graphstream.graph", "Node", "public abstract <T> Iterable<T> getEachEnteringEdge()" ], [ "hasEdgeFrom", "org.graphstream.graph", "Node", "public abstract boolean hasEdgeFrom(String arg0)" ], [ "getEdgeIterator", "org.graphstream.graph", "Node", "public abstract <T> Iterator<T> getEdgeIterator()" ], [ "getDepthFirstIterator", "org.graphstream.graph", "Node", "public abstract <T> Iterator<T> getDepthFirstIterator()" ], [ "getEachLeavingEdge", "org.graphstream.graph", "Node", "public abstract <T> Iterable<T> getEachLeavingEdge()" ], [ "getEdgeBetween", "org.graphstream.graph", "Node", "public abstract <T> T getEdgeBetween(Node arg0)" ], [ "hasEdgeBetween", "org.graphstream.graph", "Node", "public abstract boolean hasEdgeBetween(String arg0)" ], [ "getLeavingEdge", "org.graphstream.graph", "Node", "public abstract <T> T getLeavingEdge(int arg0)" ], [ "getEnteringEdge", "org.graphstream.graph", "Node", "public abstract <T> T getEnteringEdge(int arg0)" ], [ "getLeavingEdgeIterator", "org.graphstream.graph", "Node", "public abstract <T> Iterator<T> getLeavingEdgeIterator()" ], [ "getDegree", "org.graphstream.graph", "Node", "public abstract int getDegree()" ], [ "hasEdgeToward", "org.graphstream.graph", "Node", "public abstract boolean hasEdgeToward(Node arg0)" ], [ "getEdgeFrom", "org.graphstream.graph", "Node", "public abstract <T> T getEdgeFrom(String arg0)" ], [ "hasEdgeBetween", "org.graphstream.graph", "Node", "public abstract boolean hasEdgeBetween(Node arg0)" ], [ "getEdgeSet", "org.graphstream.graph", "Node", "public abstract <T> Collection<T> getEdgeSet()" ], [ "getEdgeToward", "org.graphstream.graph", "Node", "public abstract <T> T getEdgeToward(int arg0) throws IndexOutOfBoundsException" ], [ "hasEdgeToward", "org.graphstream.graph", "Node", "public abstract boolean hasEdgeToward(int arg0) throws IndexOutOfBoundsException" ], [ "hasEdgeFrom", "org.graphstream.graph", "Node", "public abstract boolean hasEdgeFrom(int arg0) throws IndexOutOfBoundsException" ], [ "getEnteringEdgeSet", "org.graphstream.graph", "Node", "public abstract <T> Collection<T> getEnteringEdgeSet()" ], [ "getBreadthFirstIterator", "org.graphstream.graph", "Node", "public abstract <T> Iterator<T> getBreadthFirstIterator(boolean arg0)" ], [ "getEachEdge", "org.graphstream.graph", "Node", "public abstract <T> Iterable<T> getEachEdge()" ], [ "getDepthFirstIterator", "org.graphstream.graph", "Node", "public abstract <T> Iterator<T> getDepthFirstIterator(boolean arg0)" ], [ "toString", "org.graphstream.graph", "Node", "public abstract String toString()" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(String[] arg0)" ], [ "getArray", "org.graphstream.graph", "Element", "public abstract Object[] getArray(String arg0)" ], [ "getIndex", "org.graphstream.graph", "Element", "public abstract int getIndex()" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0)" ], [ "getId", "org.graphstream.graph", "Element", "public abstract String getId()" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0)" ], [ "hasArray", "org.graphstream.graph", "Element", "public abstract boolean hasArray(String arg0)" ], [ "hasHash", "org.graphstream.graph", "Element", "public abstract boolean hasHash(String arg0)" ], [ "getAttributeCount", "org.graphstream.graph", "Element", "public abstract int getAttributeCount()" ], [ "getEachAttributeKey", "org.graphstream.graph", "Element", "public abstract Iterable<String> getEachAttributeKey()" ], [ "getLabel", "org.graphstream.graph", "Element", "public abstract CharSequence getLabel(String arg0)" ], [ "hasVector", "org.graphstream.graph", "Element", "public abstract boolean hasVector(String arg0)" ], [ "getAttributeKeySet", "org.graphstream.graph", "Element", "public abstract Collection<String> getAttributeKeySet()" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0, Class<T> arg1)" ], [ "getVector", "org.graphstream.graph", "Element", "public abstract ArrayList<? extends Number> getVector(String arg0)" ], [ "getHash", "org.graphstream.graph", "Element", "public abstract HashMap<?, ?> getHash(String arg0)" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(Class<T> arg0, String[] arg1)" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0, Class<?> arg1)" ], [ "hasNumber", "org.graphstream.graph", "Element", "public abstract boolean hasNumber(String arg0)" ], [ "getAttributeKeyIterator", "org.graphstream.graph", "Element", "public abstract Iterator<String> getAttributeKeyIterator()" ], [ "hasLabel", "org.graphstream.graph", "Element", "public abstract boolean hasLabel(String arg0)" ], [ "getNumber", "org.graphstream.graph", "Element", "public abstract double getNumber(String arg0)" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 4246,
  "oracle" : ";",
  "oracleType" : "PRE",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.graph.implementations",
  "className" : "AdjacencyListGraph",
  "javadocTag" : "@param initialEdgeCapacity Initial capacity of the edge storage data structures. Use this\n           if you know the approximate maximum number of edges of the\n           graph. The graph can grow beyond this limit, but storage\n           reallocation is expensive operation.",
  "methodJavadoc" : "    /**\n\t * Creates an empty graph.\n\t * \n\t * @param id\n\t *            Unique identifier of the graph.\n\t * @param strictChecking\n\t *            If true any non-fatal error throws an exception.\n\t * @param autoCreate\n\t *            If true (and strict checking is false), nodes are\n\t *            automatically created when referenced when creating a edge,\n\t *            even if not yet inserted in the graph.\n\t * @param initialNodeCapacity\n\t *            Initial capacity of the node storage data structures. Use this\n\t *            if you know the approximate maximum number of nodes of the\n\t *            graph. The graph can grow beyond this limit, but storage\n\t *            reallocation is expensive operation.\n\t * @param initialEdgeCapacity\n\t *            Initial capacity of the edge storage data structures. Use this\n\t *            if you know the approximate maximum number of edges of the\n\t *            graph. The graph can grow beyond this limit, but storage\n\t *            reallocation is expensive operation.\n\t */",
  "methodSourceCode" : "public AdjacencyListGraph(String id, boolean strictChecking, boolean autoCreate, int initialNodeCapacity, int initialEdgeCapacity){\n    super(id, strictChecking, autoCreate);\n    setNodeFactory(new NodeFactory<AdjacencyListNode>() {\n\n        public AdjacencyListNode newInstance(String id, Graph graph) {\n            return new AdjacencyListNode((AbstractGraph) graph, id);\n        }\n    });\n    setEdgeFactory(new EdgeFactory<AbstractEdge>() {\n\n        public AbstractEdge newInstance(String id, Node src, Node dst, boolean directed) {\n            return new AbstractEdge(id, (AbstractNode) src, (AbstractNode) dst, directed);\n        }\n    });\n    if (initialNodeCapacity < DEFAULT_NODE_CAPACITY)\n        initialNodeCapacity = DEFAULT_NODE_CAPACITY;\n    if (initialEdgeCapacity < DEFAULT_EDGE_CAPACITY)\n        initialEdgeCapacity = DEFAULT_EDGE_CAPACITY;\n    nodeMap = new HashMap<String, AbstractNode>(4 * initialNodeCapacity / 3 + 1);\n    edgeMap = new HashMap<String, AbstractEdge>(4 * initialEdgeCapacity / 3 + 1);\n    nodeArray = new AbstractNode[initialNodeCapacity];\n    edgeArray = new AbstractEdge[initialEdgeCapacity];\n    nodeCount = edgeCount = 0;\n}",
  "classJavadoc" : "/**\n * <p>\n * A lightweight graph class intended to allow the construction of big graphs\n * (millions of elements).\n * </p>\n * \n * <p>\n * The main purpose here is to minimize memory consumption even if the\n * management of such a graph implies more CPU consuming. See the\n * <code>complexity</code> tags on each method so as to figure out the impact on\n * the CPU.\n * </p>\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.graph.implementations;\n\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\n\nimport org.graphstream.graph.Edge;\nimport org.graphstream.graph.EdgeFactory;\nimport org.graphstream.graph.Graph;\nimport org.graphstream.graph.Node;\nimport org.graphstream.graph.NodeFactory;\n\n/**\n * <p>\n * A lightweight graph class intended to allow the construction of big graphs\n * (millions of elements).\n * </p>\n * \n * <p>\n * The main purpose here is to minimize memory consumption even if the\n * management of such a graph implies more CPU consuming. See the\n * <code>complexity</code> tags on each method so as to figure out the impact on\n * the CPU.\n * </p>\n */\npublic class AdjacencyListGraph extends AbstractGraph {\n\n\tpublic static final double GROW_FACTOR = 1.1;\n\tpublic static final int DEFAULT_NODE_CAPACITY = 128;\n\tpublic static final int DEFAULT_EDGE_CAPACITY = 1024;\n\n\tprotected HashMap<String, AbstractNode> nodeMap;\n\tprotected HashMap<String, AbstractEdge> edgeMap;\n\n\tprotected AbstractNode[] nodeArray;\n\tprotected AbstractEdge[] edgeArray;\n\n\tprotected int nodeCount;\n\tprotected int edgeCount;\n\n\t// *** Constructors ***\n\n\t/**\n\t * Creates an empty graph.\n\t * \n\t * @param id\n\t *            Unique identifier of the graph.\n\t * @param strictChecking\n\t *            If true any non-fatal error throws an exception.\n\t * @param autoCreate\n\t *            If true (and strict checking is false), nodes are\n\t *            automatically created when referenced when creating a edge,\n\t *            even if not yet inserted in the graph.\n\t * @param initialNodeCapacity\n\t *            Initial capacity of the node storage data structures. Use this\n\t *            if you know the approximate maximum number of nodes of the\n\t *            graph. The graph can grow beyond this limit, but storage\n\t *            reallocation is expensive operation.\n\t * @param initialEdgeCapacity\n\t *            Initial capacity of the edge storage data structures. Use this\n\t *            if you know the approximate maximum number of edges of the\n\t *            graph. The graph can grow beyond this limit, but storage\n\t *            reallocation is expensive operation.\n\t */\n\tpublic AdjacencyListGraph(String id, boolean strictChecking, boolean autoCreate,\n\t\t\tint initialNodeCapacity, int initialEdgeCapacity) {\n\t\tsuper(id, strictChecking, autoCreate);\n\n\t\tsetNodeFactory(new NodeFactory<AdjacencyListNode>() {\n\t\t\tpublic AdjacencyListNode newInstance(String id, Graph graph) {\n\t\t\t\treturn new AdjacencyListNode((AbstractGraph) graph, id);\n\t\t\t}\n\t\t});\n\n\t\tsetEdgeFactory(new EdgeFactory<AbstractEdge>() {\n\t\t\tpublic AbstractEdge newInstance(String id, Node src, Node dst,\n\t\t\t\t\tboolean directed) {\n\t\t\t\treturn new AbstractEdge(id, (AbstractNode) src,\n\t\t\t\t\t\t(AbstractNode) dst, directed);\n\t\t\t}\n\t\t});\n\n\t\tif (initialNodeCapacity < DEFAULT_NODE_CAPACITY)\n\t\t\tinitialNodeCapacity = DEFAULT_NODE_CAPACITY;\n\t\tif (initialEdgeCapacity < DEFAULT_EDGE_CAPACITY)\n\t\t\tinitialEdgeCapacity = DEFAULT_EDGE_CAPACITY;\n\n\t\tnodeMap = new HashMap<String, AbstractNode>(\n\t\t\t\t4 * initialNodeCapacity / 3 + 1);\n\t\tedgeMap = new HashMap<String, AbstractEdge>(\n\t\t\t\t4 * initialEdgeCapacity / 3 + 1);\n\t\tnodeArray = new AbstractNode[initialNodeCapacity];\n\t\tedgeArray = new AbstractEdge[initialEdgeCapacity];\n\t\tnodeCount = edgeCount = 0;\n\t}\n\n\t/**\n\t * Creates an empty graph with default edge and node capacity.\n\t * \n\t * @param id\n\t *            Unique identifier of the graph.\n\t * @param strictChecking\n\t *            If true any non-fatal error throws an exception.\n\t * @param autoCreate\n\t *            If true (and strict checking is false), nodes are\n\t *            automatically created when referenced when creating a edge,\n\t *            even if not yet inserted in the graph.\n\t */\n\tpublic AdjacencyListGraph(String id, boolean strictChecking, boolean autoCreate) {\n\t\tthis(id, strictChecking, autoCreate, DEFAULT_NODE_CAPACITY,\n\t\t\t\tDEFAULT_EDGE_CAPACITY);\n\t}\n\n\t/**\n\t * Creates an empty graph with strict checking and without auto-creation.\n\t * \n\t * @param id\n\t *            Unique identifier of the graph.\n\t */\n\tpublic AdjacencyListGraph(String id) {\n\t\tthis(id, true, false);\n\t}\n\n\t// *** Callbacks ***\n\n\t@Override\n\tprotected void addEdgeCallback(AbstractEdge edge) {\n\t\tedgeMap.put(edge.getId(), edge);\n\t\tif (edgeCount == edgeArray.length) {\n\t\t\tAbstractEdge[] tmp = new AbstractEdge[(int) (edgeArray.length * GROW_FACTOR) + 1];\n\t\t\tSystem.arraycopy(edgeArray, 0, tmp, 0, edgeArray.length);\n\t\t\tArrays.fill(edgeArray, null);\n\t\t\tedgeArray = tmp;\n\t\t}\n\t\tedgeArray[edgeCount] = edge;\n\t\tedge.setIndex(edgeCount++);\n\t}\n\n\t@Override\n\tprotected void addNodeCallback(AbstractNode node) {\n\t\tnodeMap.put(node.getId(), node);\n\t\tif (nodeCount == nodeArray.length) {\n\t\t\tAbstractNode[] tmp = new AbstractNode[(int) (nodeArray.length * GROW_FACTOR) + 1];\n\t\t\tSystem.arraycopy(nodeArray, 0, tmp, 0, nodeArray.length);\n\t\t\tArrays.fill(nodeArray, null);\n\t\t\tnodeArray = tmp;\n\t\t}\n\t\tnodeArray[nodeCount] = node;\n\t\tnode.setIndex(nodeCount++);\n\t}\n\n\t@Override\n\tprotected void removeEdgeCallback(AbstractEdge edge) {\n\t\tedgeMap.remove(edge.getId());\n\t\tint i = edge.getIndex();\n\t\tedgeArray[i] = edgeArray[--edgeCount];\n\t\tedgeArray[i].setIndex(i);\n\t\tedgeArray[edgeCount] = null;\n\t}\n\n\t@Override\n\tprotected void removeNodeCallback(AbstractNode node) {\n\t\tnodeMap.remove(node.getId());\n\t\tint i = node.getIndex();\n\t\tnodeArray[i] = nodeArray[--nodeCount];\n\t\tnodeArray[i].setIndex(i);\n\t\tnodeArray[nodeCount] = null;\n\t}\n\n\t@Override\n\tprotected void clearCallback() {\n\t\tnodeMap.clear();\n\t\tedgeMap.clear();\n\t\tArrays.fill(nodeArray, 0, nodeCount, null);\n\t\tArrays.fill(edgeArray, 0, edgeCount, null);\n\t\tnodeCount = edgeCount = 0;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic <T extends Edge> T getEdge(String id) {\n\t\treturn (T) edgeMap.get(id);\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic <T extends Edge> T getEdge(int index) {\n\t\tif (index < 0 || index >= edgeCount)\n\t\t\tthrow new IndexOutOfBoundsException(\"Edge \" + index\n\t\t\t\t\t+ \" does not exist\");\n\t\treturn (T) edgeArray[index];\n\t}\n\n\t@Override\n\tpublic int getEdgeCount() {\n\t\treturn edgeCount;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic <T extends Node> T getNode(String id) {\n\t\treturn (T) nodeMap.get(id);\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic <T extends Node> T getNode(int index) {\n\t\tif (index < 0 || index > nodeCount)\n\t\t\tthrow new IndexOutOfBoundsException(\"Node \" + index\n\t\t\t\t\t+ \" does not exist\");\n\t\treturn (T) nodeArray[index];\n\t}\n\n\t@Override\n\tpublic int getNodeCount() {\n\t\treturn nodeCount;\n\t}\n\n\t// *** Iterators ***\n\n\tprotected class EdgeIterator<T extends Edge> implements Iterator<T> {\n\t\tint iNext = 0;\n\t\tint iPrev = -1;\n\n\t\tpublic boolean hasNext() {\n\t\t\treturn iNext < edgeCount;\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic T next() {\n\t\t\tif (iNext >= edgeCount)\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tiPrev = iNext++;\n\t\t\treturn (T) edgeArray[iPrev];\n\t\t}\n\n\t\tpublic void remove() {\n\t\t\tif (iPrev == -1)\n\t\t\t\tthrow new IllegalStateException();\n\t\t\tremoveEdge(edgeArray[iPrev], true, true, true);\n\t\t\tiNext = iPrev;\n\t\t\tiPrev = -1;\n\t\t}\n\t}\n\n\tprotected class NodeIterator<T extends Node> implements Iterator<T> {\n\t\tint iNext = 0;\n\t\tint iPrev = -1;\n\n\t\tpublic boolean hasNext() {\n\t\t\treturn iNext < nodeCount;\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic T next() {\n\t\t\tif (iNext >= nodeCount)\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tiPrev = iNext++;\n\t\t\treturn (T) nodeArray[iPrev];\n\t\t}\n\n\t\tpublic void remove() {\n\t\t\tif (iPrev == -1)\n\t\t\t\tthrow new IllegalStateException();\n\t\t\tremoveNode(nodeArray[iPrev], true);\n\t\t\tiNext = iPrev;\n\t\t\tiPrev = -1;\n\t\t}\n\t}\n\n\t@Override\n\tpublic <T extends Edge> Iterator<T> getEdgeIterator() {\n\t\treturn new EdgeIterator<T>();\n\t}\n\n\t@Override\n\tpublic <T extends Node> Iterator<T> getNodeIterator() {\n\t\treturn new NodeIterator<T>();\n\t}\n\n\t/*\n\t * For performance tuning\n\t * \n\t * @return the number of allocated but unused array elements public int\n\t * getUnusedArrayElements() { int count = 0; count += edgeArray.length -\n\t * edgeCount; count += nodeArray.length - nodeCount; for (ALNode n :\n\t * this.<ALNode> getEachNode()) count += n.edges.length - n.degree; return\n\t * count; }\n\t */\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "id", "java.lang", "String" ], [ "strictChecking", "", "boolean" ], [ "autoCreate", "", "boolean" ], [ "initialNodeCapacity", "", "int" ], [ "initialEdgeCapacity", "", "int" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "hasVector", "org.graphstream.graph.implementations", "AbstractElement", "public boolean hasVector(String arg0)" ], [ "addNode", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> T addNode(String arg0)" ], [ "getEdgeIterator", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public <T extends Edge> Iterator<T> getEdgeIterator()" ], [ "getEdge", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public <T extends Edge> T getEdge(int index)" ], [ "addEdge", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> T addEdge(String arg0, String arg1, String arg2, boolean arg3)" ], [ "nodeFactory", "org.graphstream.graph.implementations", "AbstractGraph", "public NodeFactory<? extends Node> nodeFactory()" ], [ "getVector", "org.graphstream.graph.implementations", "AbstractElement", "public ArrayList<? extends Number> getVector(String arg0)" ], [ "getIndex", "org.graphstream.graph.implementations", "AbstractElement", "public int getIndex()" ], [ "getLabel", "org.graphstream.graph", "Element", "public abstract CharSequence getLabel(String arg0)" ], [ "getEdgeCount", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public int getEdgeCount()" ], [ "toString", "org.graphstream.graph.implementations", "AbstractElement", "public String toString()" ], [ "getFirstAttributeOf", "org.graphstream.graph.implementations", "AbstractElement", "public transient <T> T getFirstAttributeOf(String[] arg0)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "addEdge", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> T addEdge(String arg0, String arg1, String arg2)" ], [ "getId", "org.graphstream.graph.implementations", "AbstractElement", "public String getId()" ], [ "hasArray", "org.graphstream.graph.implementations", "AbstractElement", "public boolean hasArray(String arg0)" ], [ "getAttributeKeySet", "org.graphstream.graph.implementations", "AbstractElement", "public Collection<String> getAttributeKeySet()" ], [ "getNode", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public <T extends Node> T getNode(String id)" ], [ "removeNode", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> T removeNode(int arg0)" ], [ "getNode", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public <T extends Node> T getNode(int index)" ], [ "hasAttribute", "org.graphstream.graph.implementations", "AbstractElement", "public boolean hasAttribute(String arg0)" ], [ "removeEdge", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> T removeEdge(Edge arg0)" ], [ "getEdge", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public <T extends Edge> T getEdge(String id)" ], [ "removeEdge", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> T removeEdge(int arg0, int arg1)" ], [ "getStep", "org.graphstream.graph.implementations", "AbstractGraph", "public double getStep()" ], [ "addEdge", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> T addEdge(String arg0, int arg1, int arg2)" ], [ "getNumber", "org.graphstream.graph.implementations", "AbstractElement", "public double getNumber(String arg0)" ], [ "display", "org.graphstream.graph.implementations", "AbstractGraph", "public Viewer display(boolean arg0)" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "addEdge", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> T addEdge(String arg0, Node arg1, Node arg2)" ], [ "iterator", "org.graphstream.graph.implementations", "AbstractGraph", "public Iterator<Node> iterator()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getLabel", "org.graphstream.graph.implementations", "AbstractElement", "public String getLabel(String arg0)" ], [ "getReplayController", "org.graphstream.graph.implementations", "AbstractGraph", "public Replayable.Controller getReplayController()" ], [ "removeEdge", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> T removeEdge(String arg0, String arg1)" ], [ "getEachEdge", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> Iterable<? extends T> getEachEdge()" ], [ "removeEdge", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> T removeEdge(Node arg0, Node arg1)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "nullAttributesAreErrors", "org.graphstream.graph.implementations", "AbstractGraph", "public boolean nullAttributesAreErrors()" ], [ "getAttributeKeyIterator", "org.graphstream.graph.implementations", "AbstractElement", "public Iterator<String> getAttributeKeyIterator()" ], [ "hasHash", "org.graphstream.graph.implementations", "AbstractElement", "public boolean hasHash(String arg0)" ], [ "getAttribute", "org.graphstream.graph.implementations", "AbstractElement", "public <T> T getAttribute(String arg0)" ], [ "addEdge", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> T addEdge(String arg0, Node arg1, Node arg2, boolean arg3)" ], [ "hasLabel", "org.graphstream.graph.implementations", "AbstractElement", "public boolean hasLabel(String arg0)" ], [ "removeEdge", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> T removeEdge(int arg0)" ], [ "addEdge", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> T addEdge(String arg0, int arg1, int arg2, boolean arg3)" ], [ "getNodeSet", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> Collection<T> getNodeSet()" ], [ "hasAttribute", "org.graphstream.graph.implementations", "AbstractElement", "public boolean hasAttribute(String arg0, Class<?> arg1)" ], [ "elementSinks", "org.graphstream.graph.implementations", "AbstractGraph", "public Iterable<ElementSink> elementSinks()" ], [ "getFirstAttributeOf", "org.graphstream.graph.implementations", "AbstractElement", "public transient <T> T getFirstAttributeOf(Class<T> arg0, String[] arg1)" ], [ "removeNode", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> T removeNode(String arg0)" ], [ "isAutoCreationEnabled", "org.graphstream.graph.implementations", "AbstractGraph", "public boolean isAutoCreationEnabled()" ], [ "getEachNode", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> Iterable<? extends T> getEachNode()" ], [ "isStrict", "org.graphstream.graph.implementations", "AbstractGraph", "public boolean isStrict()" ], [ "addEdge", "org.graphstream.graph.implementations", "AbstractGraph", "protected <T> T addEdge(String arg0, AbstractNode arg1, String arg2, AbstractNode arg3, String arg4, boolean arg5)" ], [ "edgeFactory", "org.graphstream.graph.implementations", "AbstractGraph", "public EdgeFactory<? extends Edge> edgeFactory()" ], [ "getAttribute", "org.graphstream.graph.implementations", "AbstractElement", "public <T> T getAttribute(String arg0, Class<T> arg1)" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "getAttributeCount", "org.graphstream.graph.implementations", "AbstractElement", "public int getAttributeCount()" ], [ "display", "org.graphstream.graph.implementations", "AbstractGraph", "public Viewer display()" ], [ "getHash", "org.graphstream.graph.implementations", "AbstractElement", "public HashMap<?, ?> getHash(String arg0)" ], [ "getEachAttributeKey", "org.graphstream.graph.implementations", "AbstractElement", "public Iterable<String> getEachAttributeKey()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "getArray", "org.graphstream.graph.implementations", "AbstractElement", "public Object[] getArray(String arg0)" ], [ "hasNumber", "org.graphstream.graph.implementations", "AbstractElement", "public boolean hasNumber(String arg0)" ], [ "getNodeIterator", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public <T extends Node> Iterator<T> getNodeIterator()" ], [ "removeEdge", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> T removeEdge(String arg0)" ], [ "removeNode", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> T removeNode(Node arg0)" ], [ "getNodeCount", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public int getNodeCount()" ], [ "attributeSinks", "org.graphstream.graph.implementations", "AbstractGraph", "public Iterable<AttributeSink> attributeSinks()" ], [ "getEdgeSet", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> Collection<T> getEdgeSet()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "length", "java.lang", "String", "public int length()" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "nodeMap", "org.graphstream.graph.implementations", "AdjacencyListGraph", "protected HashMap<String,AbstractNode> nodeMap;" ], [ "edgeMap", "org.graphstream.graph.implementations", "AdjacencyListGraph", "protected HashMap<String,AbstractEdge> edgeMap;" ], [ "nodeArray", "org.graphstream.graph.implementations", "AdjacencyListGraph", "protected AbstractNode[] nodeArray;" ], [ "edgeArray", "org.graphstream.graph.implementations", "AdjacencyListGraph", "protected AbstractEdge[] edgeArray;" ], [ "nodeCount", "org.graphstream.graph.implementations", "AdjacencyListGraph", "protected int nodeCount;" ], [ "edgeCount", "org.graphstream.graph.implementations", "AdjacencyListGraph", "protected int edgeCount;" ], [ "listeners", "org.graphstream.graph.implementations", "AbstractGraph", "GraphListeners listeners;" ], [ "id", "org.graphstream.graph.implementations", "AbstractElement", "protected String id;" ], [ "attributes", "org.graphstream.graph.implementations", "AbstractElement", "protected HashMap<String, Object> attributes;" ], [ "attributesBeingRemoved", "org.graphstream.graph.implementations", "AbstractElement", "protected ArrayList<String> attributesBeingRemoved;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 4262,
  "oracle" : ";",
  "oracleType" : "PRE",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.graph.implementations",
  "className" : "DefaultGraph",
  "javadocTag" : "@param initialNodeCapacity Initial capacity of the node storage data structures. Use this\n           if you know the approximate maximum number of nodes of the\n           graph. The graph can grow beyond this limit, but storage\n           reallocation is expensive operation.",
  "methodJavadoc" : "    /**\n\t * Creates an empty graph.\n\t * \n\t * @param id\n\t *            Unique identifier of the graph.\n\t * @param strictChecking\n\t *            If true any non-fatal error throws an exception.\n\t * @param autoCreate\n\t *            If true (and strict checking is false), nodes are\n\t *            automatically created when referenced when creating a edge,\n\t *            even if not yet inserted in the graph.\n\t * @param initialNodeCapacity\n\t *            Initial capacity of the node storage data structures. Use this\n\t *            if you know the approximate maximum number of nodes of the\n\t *            graph. The graph can grow beyond this limit, but storage\n\t *            reallocation is expensive operation.\n\t * @param initialEdgeCapacity\n\t *            Initial capacity of the edge storage data structures. Use this\n\t *            if you know the approximate maximum number of edges of the\n\t *            graph. The graph can grow beyond this limit, but storage\n\t *            reallocation is expensive operation.\n\t */",
  "methodSourceCode" : "public DefaultGraph(String id, boolean strictChecking, boolean autoCreate, int initialNodeCapacity, int initialEdgeCapacity){\n    super(id, strictChecking, autoCreate, initialNodeCapacity, initialEdgeCapacity);\n}",
  "classJavadoc" : "/**\n * Default implementation of graph. This is just a synonym of {@link SingleGraph}. It is here for clarity only.\n *\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.graph.implementations;\n\n/**\n * Default implementation of graph. This is just a synonym of {@link SingleGraph}. It is here for clarity only.\n *\n */\npublic class DefaultGraph extends SingleGraph {\n\n\t/**\n\t * Creates an empty graph.\n\t * \n\t * @param id\n\t *            Unique identifier of the graph.\n\t * @param strictChecking\n\t *            If true any non-fatal error throws an exception.\n\t * @param autoCreate\n\t *            If true (and strict checking is false), nodes are\n\t *            automatically created when referenced when creating a edge,\n\t *            even if not yet inserted in the graph.\n\t * @param initialNodeCapacity\n\t *            Initial capacity of the node storage data structures. Use this\n\t *            if you know the approximate maximum number of nodes of the\n\t *            graph. The graph can grow beyond this limit, but storage\n\t *            reallocation is expensive operation.\n\t * @param initialEdgeCapacity\n\t *            Initial capacity of the edge storage data structures. Use this\n\t *            if you know the approximate maximum number of edges of the\n\t *            graph. The graph can grow beyond this limit, but storage\n\t *            reallocation is expensive operation.\n\t */\n\tpublic DefaultGraph(String id, boolean strictChecking, boolean autoCreate,\n\t\t\tint initialNodeCapacity, int initialEdgeCapacity) {\n\t\tsuper(id, strictChecking, autoCreate, initialNodeCapacity,\n\t\t\t\tinitialEdgeCapacity);\n\t}\n\n\t/**\n\t * Creates an empty graph with default edge and node capacity.\n\t * \n\t * @param id\n\t *            Unique identifier of the graph.\n\t * @param strictChecking\n\t *            If true any non-fatal error throws an exception.\n\t * @param autoCreate\n\t *            If true (and strict checking is false), nodes are\n\t *            automatically created when referenced when creating a edge,\n\t *            even if not yet inserted in the graph.\n\t */\n\tpublic DefaultGraph(String id, boolean strictChecking, boolean autoCreate) {\n\t\tsuper(id, strictChecking, autoCreate);\n\t}\n\n\t/**\n\t * Creates an empty graph with strict checking and without auto-creation.\n\t * \n\t * @param id\n\t *            Unique identifier of the graph.\n\t */\n\tpublic DefaultGraph(String id) {\n\t\tsuper(id);\n\t}\n\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "id", "java.lang", "String" ], [ "strictChecking", "", "boolean" ], [ "autoCreate", "", "boolean" ], [ "initialNodeCapacity", "", "int" ], [ "initialEdgeCapacity", "", "int" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getLabel", "org.graphstream.graph", "Element", "public abstract CharSequence getLabel(String arg0)" ], [ "addEdge", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> T addEdge(String arg0, String arg1, String arg2)" ], [ "getIndex", "org.graphstream.graph.implementations", "AbstractElement", "public int getIndex()" ], [ "nodeFactory", "org.graphstream.graph.implementations", "AbstractGraph", "public NodeFactory<? extends Node> nodeFactory()" ], [ "attributeSinks", "org.graphstream.graph.implementations", "AbstractGraph", "public Iterable<AttributeSink> attributeSinks()" ], [ "getFirstAttributeOf", "org.graphstream.graph.implementations", "AbstractElement", "public transient <T> T getFirstAttributeOf(String[] arg0)" ], [ "addEdge", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> T addEdge(String arg0, int arg1, int arg2, boolean arg3)" ], [ "getEdgeIterator", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public <T> Iterator<T> getEdgeIterator()" ], [ "addNode", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> T addNode(String arg0)" ], [ "hasLabel", "org.graphstream.graph.implementations", "AbstractElement", "public boolean hasLabel(String arg0)" ], [ "removeEdge", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> T removeEdge(Edge arg0)" ], [ "hasArray", "org.graphstream.graph.implementations", "AbstractElement", "public boolean hasArray(String arg0)" ], [ "removeEdge", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> T removeEdge(Node arg0, Node arg1)" ], [ "getEdge", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public <T> T getEdge(int arg0)" ], [ "isAutoCreationEnabled", "org.graphstream.graph.implementations", "AbstractGraph", "public boolean isAutoCreationEnabled()" ], [ "removeEdge", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> T removeEdge(int arg0)" ], [ "addEdge", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> T addEdge(String arg0, Node arg1, Node arg2)" ], [ "getFirstAttributeOf", "org.graphstream.graph.implementations", "AbstractElement", "public transient <T> T getFirstAttributeOf(Class<T> arg0, String[] arg1)" ], [ "getAttributeKeySet", "org.graphstream.graph.implementations", "AbstractElement", "public Collection<String> getAttributeKeySet()" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "getNodeSet", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> Collection<T> getNodeSet()" ], [ "getEdgeSet", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> Collection<T> getEdgeSet()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "getLabel", "org.graphstream.graph.implementations", "AbstractElement", "public String getLabel(String arg0)" ], [ "getAttribute", "org.graphstream.graph.implementations", "AbstractElement", "public <T> T getAttribute(String arg0)" ], [ "getAttributeKeyIterator", "org.graphstream.graph.implementations", "AbstractElement", "public Iterator<String> getAttributeKeyIterator()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "getVector", "org.graphstream.graph.implementations", "AbstractElement", "public ArrayList<? extends Number> getVector(String arg0)" ], [ "getAttributeCount", "org.graphstream.graph.implementations", "AbstractElement", "public int getAttributeCount()" ], [ "getNode", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public <T> T getNode(int arg0)" ], [ "getEachEdge", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> Iterable<? extends T> getEachEdge()" ], [ "getAttribute", "org.graphstream.graph.implementations", "AbstractElement", "public <T> T getAttribute(String arg0, Class<T> arg1)" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "getNode", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public <T> T getNode(String arg0)" ], [ "hasNumber", "org.graphstream.graph.implementations", "AbstractElement", "public boolean hasNumber(String arg0)" ], [ "getNumber", "org.graphstream.graph.implementations", "AbstractElement", "public double getNumber(String arg0)" ], [ "display", "org.graphstream.graph.implementations", "AbstractGraph", "public Viewer display()" ], [ "getReplayController", "org.graphstream.graph.implementations", "AbstractGraph", "public Replayable.Controller getReplayController()" ], [ "getEachNode", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> Iterable<? extends T> getEachNode()" ], [ "getStep", "org.graphstream.graph.implementations", "AbstractGraph", "public double getStep()" ], [ "addEdge", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> T addEdge(String arg0, Node arg1, Node arg2, boolean arg3)" ], [ "elementSinks", "org.graphstream.graph.implementations", "AbstractGraph", "public Iterable<ElementSink> elementSinks()" ], [ "getId", "org.graphstream.graph.implementations", "AbstractElement", "public String getId()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getHash", "org.graphstream.graph.implementations", "AbstractElement", "public HashMap<?, ?> getHash(String arg0)" ], [ "hasHash", "org.graphstream.graph.implementations", "AbstractElement", "public boolean hasHash(String arg0)" ], [ "getEdgeCount", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public int getEdgeCount()" ], [ "getEdge", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public <T> T getEdge(String arg0)" ], [ "removeNode", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> T removeNode(int arg0)" ], [ "hasAttribute", "org.graphstream.graph.implementations", "AbstractElement", "public boolean hasAttribute(String arg0, Class<?> arg1)" ], [ "removeNode", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> T removeNode(String arg0)" ], [ "getNodeCount", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public int getNodeCount()" ], [ "display", "org.graphstream.graph.implementations", "AbstractGraph", "public Viewer display(boolean arg0)" ], [ "getArray", "org.graphstream.graph.implementations", "AbstractElement", "public Object[] getArray(String arg0)" ], [ "hasVector", "org.graphstream.graph.implementations", "AbstractElement", "public boolean hasVector(String arg0)" ], [ "hasAttribute", "org.graphstream.graph.implementations", "AbstractElement", "public boolean hasAttribute(String arg0)" ], [ "toString", "org.graphstream.graph.implementations", "AbstractElement", "public String toString()" ], [ "addEdge", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> T addEdge(String arg0, int arg1, int arg2)" ], [ "removeEdge", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> T removeEdge(String arg0)" ], [ "addEdge", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> T addEdge(String arg0, String arg1, String arg2, boolean arg3)" ], [ "iterator", "org.graphstream.graph.implementations", "AbstractGraph", "public Iterator<Node> iterator()" ], [ "isStrict", "org.graphstream.graph.implementations", "AbstractGraph", "public boolean isStrict()" ], [ "removeEdge", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> T removeEdge(String arg0, String arg1)" ], [ "removeNode", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> T removeNode(Node arg0)" ], [ "edgeFactory", "org.graphstream.graph.implementations", "AbstractGraph", "public EdgeFactory<? extends Edge> edgeFactory()" ], [ "removeEdge", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> T removeEdge(int arg0, int arg1)" ], [ "addEdge", "org.graphstream.graph.implementations", "AbstractGraph", "protected <T> T addEdge(String arg0, AbstractNode arg1, String arg2, AbstractNode arg3, String arg4, boolean arg5)" ], [ "getNodeIterator", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public <T> Iterator<T> getNodeIterator()" ], [ "nullAttributesAreErrors", "org.graphstream.graph.implementations", "AbstractGraph", "public boolean nullAttributesAreErrors()" ], [ "getEachAttributeKey", "org.graphstream.graph.implementations", "AbstractElement", "public Iterable<String> getEachAttributeKey()" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "length", "java.lang", "String", "public int length()" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "nodeMap", "org.graphstream.graph.implementations", "AdjacencyListGraph", "protected HashMap<String, AbstractNode> nodeMap;" ], [ "edgeMap", "org.graphstream.graph.implementations", "AdjacencyListGraph", "protected HashMap<String, AbstractEdge> edgeMap;" ], [ "nodeArray", "org.graphstream.graph.implementations", "AdjacencyListGraph", "protected AbstractNode[] nodeArray;" ], [ "edgeArray", "org.graphstream.graph.implementations", "AdjacencyListGraph", "protected AbstractEdge[] edgeArray;" ], [ "nodeCount", "org.graphstream.graph.implementations", "AdjacencyListGraph", "protected int nodeCount;" ], [ "edgeCount", "org.graphstream.graph.implementations", "AdjacencyListGraph", "protected int edgeCount;" ], [ "listeners", "org.graphstream.graph.implementations", "AbstractGraph", "GraphListeners listeners;" ], [ "id", "org.graphstream.graph.implementations", "AbstractElement", "protected String id;" ], [ "attributes", "org.graphstream.graph.implementations", "AbstractElement", "protected HashMap<String, Object> attributes;" ], [ "attributesBeingRemoved", "org.graphstream.graph.implementations", "AbstractElement", "protected ArrayList<String> attributesBeingRemoved;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 4266,
  "oracle" : ";",
  "oracleType" : "PRE",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.graph.implementations",
  "className" : "DefaultGraph",
  "javadocTag" : "@param id Unique identifier of the graph.",
  "methodJavadoc" : "    /**\n\t * Creates an empty graph with strict checking and without auto-creation.\n\t * \n\t * @param id\n\t *            Unique identifier of the graph.\n\t */",
  "methodSourceCode" : "public DefaultGraph(String id){\n    super(id);\n}",
  "classJavadoc" : "/**\n * Default implementation of graph. This is just a synonym of {@link SingleGraph}. It is here for clarity only.\n *\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.graph.implementations;\n\n/**\n * Default implementation of graph. This is just a synonym of {@link SingleGraph}. It is here for clarity only.\n *\n */\npublic class DefaultGraph extends SingleGraph {\n\n\t/**\n\t * Creates an empty graph.\n\t * \n\t * @param id\n\t *            Unique identifier of the graph.\n\t * @param strictChecking\n\t *            If true any non-fatal error throws an exception.\n\t * @param autoCreate\n\t *            If true (and strict checking is false), nodes are\n\t *            automatically created when referenced when creating a edge,\n\t *            even if not yet inserted in the graph.\n\t * @param initialNodeCapacity\n\t *            Initial capacity of the node storage data structures. Use this\n\t *            if you know the approximate maximum number of nodes of the\n\t *            graph. The graph can grow beyond this limit, but storage\n\t *            reallocation is expensive operation.\n\t * @param initialEdgeCapacity\n\t *            Initial capacity of the edge storage data structures. Use this\n\t *            if you know the approximate maximum number of edges of the\n\t *            graph. The graph can grow beyond this limit, but storage\n\t *            reallocation is expensive operation.\n\t */\n\tpublic DefaultGraph(String id, boolean strictChecking, boolean autoCreate,\n\t\t\tint initialNodeCapacity, int initialEdgeCapacity) {\n\t\tsuper(id, strictChecking, autoCreate, initialNodeCapacity,\n\t\t\t\tinitialEdgeCapacity);\n\t}\n\n\t/**\n\t * Creates an empty graph with default edge and node capacity.\n\t * \n\t * @param id\n\t *            Unique identifier of the graph.\n\t * @param strictChecking\n\t *            If true any non-fatal error throws an exception.\n\t * @param autoCreate\n\t *            If true (and strict checking is false), nodes are\n\t *            automatically created when referenced when creating a edge,\n\t *            even if not yet inserted in the graph.\n\t */\n\tpublic DefaultGraph(String id, boolean strictChecking, boolean autoCreate) {\n\t\tsuper(id, strictChecking, autoCreate);\n\t}\n\n\t/**\n\t * Creates an empty graph with strict checking and without auto-creation.\n\t * \n\t * @param id\n\t *            Unique identifier of the graph.\n\t */\n\tpublic DefaultGraph(String id) {\n\t\tsuper(id);\n\t}\n\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "id", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "getEdgeIterator", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public <T> Iterator<T> getEdgeIterator()" ], [ "getNode", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public <T> T getNode(String arg0)" ], [ "hasNumber", "org.graphstream.graph.implementations", "AbstractElement", "public boolean hasNumber(String arg0)" ], [ "removeEdge", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> T removeEdge(String arg0, String arg1)" ], [ "hasAttribute", "org.graphstream.graph.implementations", "AbstractElement", "public boolean hasAttribute(String arg0)" ], [ "getNodeCount", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public int getNodeCount()" ], [ "removeEdge", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> T removeEdge(Node arg0, Node arg1)" ], [ "getEachEdge", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> Iterable<? extends T> getEachEdge()" ], [ "hasArray", "org.graphstream.graph.implementations", "AbstractElement", "public boolean hasArray(String arg0)" ], [ "addEdge", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> T addEdge(String arg0, int arg1, int arg2, boolean arg3)" ], [ "display", "org.graphstream.graph.implementations", "AbstractGraph", "public Viewer display(boolean arg0)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "removeEdge", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> T removeEdge(int arg0)" ], [ "hasAttribute", "org.graphstream.graph.implementations", "AbstractElement", "public boolean hasAttribute(String arg0, Class<?> arg1)" ], [ "getEdge", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public <T> T getEdge(String arg0)" ], [ "nullAttributesAreErrors", "org.graphstream.graph.implementations", "AbstractGraph", "public boolean nullAttributesAreErrors()" ], [ "removeNode", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> T removeNode(Node arg0)" ], [ "getIndex", "org.graphstream.graph.implementations", "AbstractElement", "public int getIndex()" ], [ "getLabel", "org.graphstream.graph.implementations", "AbstractElement", "public String getLabel(String arg0)" ], [ "removeEdge", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> T removeEdge(Edge arg0)" ], [ "isAutoCreationEnabled", "org.graphstream.graph.implementations", "AbstractGraph", "public boolean isAutoCreationEnabled()" ], [ "getNodeSet", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> Collection<T> getNodeSet()" ], [ "addEdge", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> T addEdge(String arg0, String arg1, String arg2)" ], [ "hasHash", "org.graphstream.graph.implementations", "AbstractElement", "public boolean hasHash(String arg0)" ], [ "isStrict", "org.graphstream.graph.implementations", "AbstractGraph", "public boolean isStrict()" ], [ "edgeFactory", "org.graphstream.graph.implementations", "AbstractGraph", "public EdgeFactory<? extends Edge> edgeFactory()" ], [ "getFirstAttributeOf", "org.graphstream.graph.implementations", "AbstractElement", "public transient <T> T getFirstAttributeOf(String[] arg0)" ], [ "hasLabel", "org.graphstream.graph.implementations", "AbstractElement", "public boolean hasLabel(String arg0)" ], [ "getAttributeCount", "org.graphstream.graph.implementations", "AbstractElement", "public int getAttributeCount()" ], [ "getNode", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public <T> T getNode(int arg0)" ], [ "getLabel", "org.graphstream.graph", "Element", "public abstract CharSequence getLabel(String arg0)" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "getAttributeKeySet", "org.graphstream.graph.implementations", "AbstractElement", "public Collection<String> getAttributeKeySet()" ], [ "getId", "org.graphstream.graph.implementations", "AbstractElement", "public String getId()" ], [ "removeEdge", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> T removeEdge(String arg0)" ], [ "getEachNode", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> Iterable<? extends T> getEachNode()" ], [ "attributeSinks", "org.graphstream.graph.implementations", "AbstractGraph", "public Iterable<AttributeSink> attributeSinks()" ], [ "iterator", "org.graphstream.graph.implementations", "AbstractGraph", "public Iterator<Node> iterator()" ], [ "toString", "org.graphstream.graph.implementations", "AbstractElement", "public String toString()" ], [ "getAttribute", "org.graphstream.graph.implementations", "AbstractElement", "public <T> T getAttribute(String arg0, Class<T> arg1)" ], [ "getEdgeCount", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public int getEdgeCount()" ], [ "addEdge", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> T addEdge(String arg0, int arg1, int arg2)" ], [ "getNumber", "org.graphstream.graph.implementations", "AbstractElement", "public double getNumber(String arg0)" ], [ "getReplayController", "org.graphstream.graph.implementations", "AbstractGraph", "public Replayable.Controller getReplayController()" ], [ "addNode", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> T addNode(String arg0)" ], [ "addEdge", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> T addEdge(String arg0, String arg1, String arg2, boolean arg3)" ], [ "removeEdge", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> T removeEdge(int arg0, int arg1)" ], [ "getEachAttributeKey", "org.graphstream.graph.implementations", "AbstractElement", "public Iterable<String> getEachAttributeKey()" ], [ "getEdgeSet", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> Collection<T> getEdgeSet()" ], [ "getArray", "org.graphstream.graph.implementations", "AbstractElement", "public Object[] getArray(String arg0)" ], [ "hasVector", "org.graphstream.graph.implementations", "AbstractElement", "public boolean hasVector(String arg0)" ], [ "nodeFactory", "org.graphstream.graph.implementations", "AbstractGraph", "public NodeFactory<? extends Node> nodeFactory()" ], [ "getHash", "org.graphstream.graph.implementations", "AbstractElement", "public HashMap<?, ?> getHash(String arg0)" ], [ "addEdge", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> T addEdge(String arg0, Node arg1, Node arg2)" ], [ "removeNode", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> T removeNode(String arg0)" ], [ "getStep", "org.graphstream.graph.implementations", "AbstractGraph", "public double getStep()" ], [ "getVector", "org.graphstream.graph.implementations", "AbstractElement", "public ArrayList<? extends Number> getVector(String arg0)" ], [ "removeNode", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> T removeNode(int arg0)" ], [ "getNodeIterator", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public <T> Iterator<T> getNodeIterator()" ], [ "display", "org.graphstream.graph.implementations", "AbstractGraph", "public Viewer display()" ], [ "elementSinks", "org.graphstream.graph.implementations", "AbstractGraph", "public Iterable<ElementSink> elementSinks()" ], [ "addEdge", "org.graphstream.graph.implementations", "AbstractGraph", "public <T> T addEdge(String arg0, Node arg1, Node arg2, boolean arg3)" ], [ "getFirstAttributeOf", "org.graphstream.graph.implementations", "AbstractElement", "public transient <T> T getFirstAttributeOf(Class<T> arg0, String[] arg1)" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "addEdge", "org.graphstream.graph.implementations", "AbstractGraph", "protected <T> T addEdge(String arg0, AbstractNode arg1, String arg2, AbstractNode arg3, String arg4, boolean arg5)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "getEdge", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public <T> T getEdge(int arg0)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "getAttributeKeyIterator", "org.graphstream.graph.implementations", "AbstractElement", "public Iterator<String> getAttributeKeyIterator()" ], [ "getAttribute", "org.graphstream.graph.implementations", "AbstractElement", "public <T> T getAttribute(String arg0)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "length", "java.lang", "String", "public int length()" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "nodeMap", "org.graphstream.graph.implementations", "AdjacencyListGraph", "protected HashMap<String, AbstractNode> nodeMap;" ], [ "edgeMap", "org.graphstream.graph.implementations", "AdjacencyListGraph", "protected HashMap<String, AbstractEdge> edgeMap;" ], [ "nodeArray", "org.graphstream.graph.implementations", "AdjacencyListGraph", "protected AbstractNode[] nodeArray;" ], [ "edgeArray", "org.graphstream.graph.implementations", "AdjacencyListGraph", "protected AbstractEdge[] edgeArray;" ], [ "nodeCount", "org.graphstream.graph.implementations", "AdjacencyListGraph", "protected int nodeCount;" ], [ "edgeCount", "org.graphstream.graph.implementations", "AdjacencyListGraph", "protected int edgeCount;" ], [ "listeners", "org.graphstream.graph.implementations", "AbstractGraph", "GraphListeners listeners;" ], [ "id", "org.graphstream.graph.implementations", "AbstractElement", "protected String id;" ], [ "attributes", "org.graphstream.graph.implementations", "AbstractElement", "protected HashMap<String, Object> attributes;" ], [ "attributesBeingRemoved", "org.graphstream.graph.implementations", "AbstractElement", "protected ArrayList<String> attributesBeingRemoved;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 4281,
  "oracle" : ";",
  "oracleType" : "NORMAL_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.graph.implementations",
  "className" : "Graphs",
  "javadocTag" : "@return a copy of g",
  "methodJavadoc" : "    /**\n\t * Clone a given graph with same node/edge structure and same attributes.\n\t * \n\t * @param g\n\t *            the graph to clone\n\t * @return a copy of g\n\t */",
  "methodSourceCode" : "public static Graph clone(Graph g){\n    Graph copy;\n    try {\n        Class<? extends Graph> cls = g.getClass();\n        copy = cls.getConstructor(String.class).newInstance(g.getId());\n    } catch (Exception e) {\n        logger.warning(String.format(\"Cannot create a graph of %s.\", g.getClass().getName()));\n        copy = new AdjacencyListGraph(g.getId());\n    }\n    copyAttributes(g, copy);\n    for (int i = 0; i < g.getNodeCount(); i++) {\n        Node source = g.getNode(i);\n        Node target = copy.addNode(source.getId());\n        copyAttributes(source, target);\n    }\n    for (int i = 0; i < g.getEdgeCount(); i++) {\n        Edge source = g.getEdge(i);\n        Edge target = copy.addEdge(source.getId(), source.getSourceNode().getId(), source.getTargetNode().getId(), source.isDirected());\n        copyAttributes(source, target);\n    }\n    return copy;\n}",
  "classJavadoc" : "/**\n     * Synchronizes a graph. The returned graph can be accessed and modified by\n     * several threads. You lose genericity in methods returning edge or node\n     * because each element (graph, nodes and edges) is wrapped into a\n     * synchronized wrapper which breaks original elements class.\n     *\n     * @param g\n     *            the graph to synchronize\n     * @return a synchronized wrapper for g\n     */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.graph.implementations;\n\nimport org.graphstream.graph.Edge;\nimport org.graphstream.graph.EdgeFactory;\nimport org.graphstream.graph.EdgeRejectedException;\nimport org.graphstream.graph.Element;\nimport org.graphstream.graph.ElementNotFoundException;\nimport org.graphstream.graph.Graph;\nimport org.graphstream.graph.IdAlreadyInUseException;\nimport org.graphstream.graph.Node;\nimport org.graphstream.graph.NodeFactory;\nimport org.graphstream.stream.AttributeSink;\nimport org.graphstream.stream.ElementSink;\nimport org.graphstream.stream.GraphParseException;\nimport org.graphstream.stream.GraphReplay;\nimport org.graphstream.stream.Sink;\nimport org.graphstream.stream.file.FileSink;\nimport org.graphstream.stream.file.FileSource;\nimport org.graphstream.ui.view.Viewer;\n\nimport java.io.IOException;\nimport java.lang.reflect.Array;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.concurrent.locks.ReentrantLock;\nimport java.util.logging.Logger;\n\npublic class Graphs {\n\n    private static final Logger logger = Logger.getLogger(Graphs.class.getSimpleName());\n\n\tpublic static Graph unmutableGraph(Graph g) {\n\t\treturn null;\n\t}\n\n\t/**\n\t * Synchronizes a graph. The returned graph can be accessed and modified by\n\t * several threads. You lose genericity in methods returning edge or node\n\t * because each element (graph, nodes and edges) is wrapped into a\n\t * synchronized wrapper which breaks original elements class.\n\t * \n\t * @param g\n\t *            the graph to synchronize\n\t * @return a synchronized wrapper for g\n\t */\n\tpublic static Graph synchronizedGraph(Graph g) {\n\t\treturn new SynchronizedGraph(g);\n\t}\n\n\t/**\n\t * Merge several graphs in one. A new graph is created, that will contain\n\t * the result. The method will try to create a graph of the same class that\n\t * the first graph to merge (it needs to have a constructor with a String).\n\t * Else, a MultiGraph is used.\n\t * \n\t * @param graphs\n\t *            graphs to merge\n\t * @return merge result\n\t */\n\tpublic static Graph merge(Graph... graphs) {\n\t\tif (graphs == null)\n\t\t\treturn new DefaultGraph(\"void-merge\");\n\n\t\tString id = \"merge\";\n\n\t\tfor (Graph g : graphs)\n\t\t\tid += \"-\" + g.getId();\n\n\t\tGraph result;\n\n\t\ttry {\n\t\t\tClass<? extends Graph> cls = graphs[0].getClass();\n\t\t\tresult = cls.getConstructor(String.class).newInstance(id);\n\t\t} catch (Exception e) {\n            logger.warning(String.format(\"Cannot create a graph of %s.\", graphs[0].getClass().getName()));\n\t\t\tresult = new MultiGraph(id);\n\t\t}\n\n\t\tmergeIn(result, graphs);\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Merge several graphs in one. The first parameter is the graph in which\n\t * the other graphs will be merged.\n\t * \n\t * @param result\n\t *            destination graph.\n\t * @param graphs\n\t *            all graphs that will be merged in result.\n\t */\n\tpublic static void mergeIn(Graph result, Graph... graphs) {\n\t\tboolean strict = result.isStrict();\n\t\tGraphReplay replay = new GraphReplay(String.format(\"replay-%x\",\n\t\t\t\tSystem.nanoTime()));\n\n\t\treplay.addSink(result);\n\t\tresult.setStrict(false);\n\n\t\tif (graphs != null)\n\t\t\tfor (Graph g : graphs)\n\t\t\t\treplay.replay(g);\n\n\t\treplay.removeSink(result);\n\t\tresult.setStrict(strict);\n\t}\n\n\t/**\n\t * Clone a given graph with same node/edge structure and same attributes.\n\t * \n\t * @param g\n\t *            the graph to clone\n\t * @return a copy of g\n\t */\n\tpublic static Graph clone(Graph g) {\n\t\tGraph copy;\n\n\t\ttry {\n\t\t\tClass<? extends Graph> cls = g.getClass();\n\t\t\tcopy = cls.getConstructor(String.class).newInstance(g.getId());\n\t\t} catch (Exception e) {\n            logger.warning(String.format(\"Cannot create a graph of %s.\", g.getClass().getName()));\n\t\t\tcopy = new AdjacencyListGraph(g.getId());\n\t\t}\n\n\t\tcopyAttributes(g, copy);\n\n\t\tfor (int i = 0; i < g.getNodeCount(); i++) {\n\t\t\tNode source = g.getNode(i);\n\t\t\tNode target = copy.addNode(source.getId());\n\n\t\t\tcopyAttributes(source, target);\n\t\t}\n\n\t\tfor (int i = 0; i < g.getEdgeCount(); i++) {\n\t\t\tEdge source = g.getEdge(i);\n\t\t\tEdge target = copy.addEdge(source.getId(), source.getSourceNode()\n\t\t\t\t\t.getId(), source.getTargetNode().getId(), source\n\t\t\t\t\t.isDirected());\n\n\t\t\tcopyAttributes(source, target);\n\t\t}\n\n\t\treturn copy;\n\t}\n\n\t/**\n\t * \n\t * @param source\n\t * @param target\n\t */\n\tpublic static void copyAttributes(Element source, Element target) {\n\t\tfor (String key : source.getAttributeKeySet()) {\n\t\t\tObject value = source.getAttribute(key);\n\t\t\tvalue = checkedArrayOrCollectionCopy(value);\n\n\t\t\ttarget.setAttribute(key, value);\n\t\t}\n\t}\n\n\t@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n\tprivate static Object checkedArrayOrCollectionCopy(Object o) {\n\t\tif (o == null)\n\t\t\treturn null;\n\n\t\tif (o.getClass().isArray()) {\n\n\t\t\tObject c = Array.newInstance(o.getClass().getComponentType(),\n\t\t\t\t\tArray.getLength(o));\n\n\t\t\tfor (int i = 0; i < Array.getLength(o); i++) {\n\t\t\t\tObject t = checkedArrayOrCollectionCopy(Array.get(o, i));\n\t\t\t\tArray.set(c, i, t);\n\t\t\t}\n\n\t\t\treturn c;\n\t\t}\n\n\t\tif (Collection.class.isAssignableFrom(o.getClass())) {\n\t\t\tCollection<?> t;\n\n\t\t\ttry {\n\t\t\t\tt = (Collection<?>) o.getClass().newInstance();\n\t\t\t\tt.addAll((Collection) o);\n\n\t\t\t\treturn t;\n\t\t\t} catch (InstantiationException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\treturn o;\n\t}\n\n\tstatic class SynchronizedElement<U extends Element> implements Element {\n\n\t\tprivate final ReentrantLock attributeLock;\n\t\tprotected final U wrappedElement;\n\n\t\tSynchronizedElement(U e) {\n\t\t\tthis.wrappedElement = e;\n\t\t\tthis.attributeLock = new ReentrantLock();\n\t\t}\n\n\t\tpublic void addAttribute(String attribute, Object... values) {\n\t\t\tattributeLock.lock();\n\t\t\twrappedElement.addAttribute(attribute, values);\n\t\t\tattributeLock.unlock();\n\t\t}\n\n\t\tpublic void addAttributes(Map<String, Object> attributes) {\n\t\t\tattributeLock.lock();\n\t\t\twrappedElement.addAttributes(attributes);\n\t\t\tattributeLock.unlock();\n\t\t}\n\n\t\tpublic void changeAttribute(String attribute, Object... values) {\n\t\t\tattributeLock.lock();\n\t\t\twrappedElement.changeAttribute(attribute, values);\n\t\t\tattributeLock.unlock();\n\t\t}\n\n\t\tpublic void clearAttributes() {\n\t\t\tattributeLock.lock();\n\t\t\twrappedElement.clearAttributes();\n\t\t\tattributeLock.unlock();\n\t\t}\n\n\t\tpublic Object[] getArray(String key) {\n\t\t\tObject[] o;\n\n\t\t\tattributeLock.lock();\n\t\t\to = wrappedElement.getArray(key);\n\t\t\tattributeLock.unlock();\n\n\t\t\treturn o;\n\t\t}\n\n\t\tpublic <T> T getAttribute(String key) {\n\t\t\tT o;\n\n\t\t\tattributeLock.lock();\n\t\t\to = wrappedElement.getAttribute(key);\n\t\t\tattributeLock.unlock();\n\n\t\t\treturn o;\n\t\t}\n\n\t\tpublic <T> T getAttribute(String key, Class<T> clazz) {\n\t\t\tT o;\n\n\t\t\tattributeLock.lock();\n\t\t\to = wrappedElement.getAttribute(key, clazz);\n\t\t\tattributeLock.unlock();\n\n\t\t\treturn o;\n\t\t}\n\n\t\tpublic int getAttributeCount() {\n\t\t\tint c;\n\n\t\t\tattributeLock.lock();\n\t\t\tc = wrappedElement.getAttributeCount();\n\t\t\tattributeLock.unlock();\n\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic Iterator<String> getAttributeKeyIterator() {\n\t\t\treturn getAttributeKeySet().iterator();\n\t\t}\n\n\t\tpublic Collection<String> getAttributeKeySet() {\n\t\t\tArrayList<String> o;\n\t\t\tIterator<String> it;\n\n\t\t\tattributeLock.lock();\n\n\t\t\to = new ArrayList<String>(wrappedElement.getAttributeCount());\n\t\t\tit = wrappedElement.getAttributeKeyIterator();\n\n\t\t\twhile (it.hasNext())\n\t\t\t\to.add(it.next());\n\n\t\t\tattributeLock.unlock();\n\n\t\t\treturn o;\n\t\t}\n\t\t\n\t\tpublic Iterable<String> getEachAttributeKey() {\n\t\t\treturn getAttributeKeySet();\n\t\t}\n\n\t\tpublic <T> T getFirstAttributeOf(String... keys) {\n\t\t\tT o;\n\n\t\t\tattributeLock.lock();\n\t\t\to = wrappedElement.getFirstAttributeOf(keys);\n\t\t\tattributeLock.unlock();\n\n\t\t\treturn o;\n\t\t}\n\n\t\tpublic <T> T getFirstAttributeOf(Class<T> clazz, String... keys) {\n\t\t\tT o;\n\n\t\t\tattributeLock.lock();\n\t\t\to = wrappedElement.getFirstAttributeOf(clazz, keys);\n\t\t\tattributeLock.unlock();\n\n\t\t\treturn o;\n\t\t}\n\n\t\tpublic HashMap<?, ?> getHash(String key) {\n\t\t\tHashMap<?, ?> o;\n\n\t\t\tattributeLock.lock();\n\t\t\to = wrappedElement.getHash(key);\n\t\t\tattributeLock.unlock();\n\n\t\t\treturn o;\n\t\t}\n\n\t\tpublic String getId() {\n\t\t\treturn wrappedElement.getId();\n\t\t}\n\n\t\tpublic int getIndex() {\n\t\t\treturn wrappedElement.getIndex();\n\t\t}\n\n\t\tpublic CharSequence getLabel(String key) {\n\t\t\tCharSequence o;\n\n\t\t\tattributeLock.lock();\n\t\t\to = wrappedElement.getLabel(key);\n\t\t\tattributeLock.unlock();\n\n\t\t\treturn o;\n\t\t}\n\n\t\tpublic double getNumber(String key) {\n\t\t\tdouble o;\n\n\t\t\tattributeLock.lock();\n\t\t\to = wrappedElement.getNumber(key);\n\t\t\tattributeLock.unlock();\n\n\t\t\treturn o;\n\t\t}\n\n\t\tpublic ArrayList<? extends Number> getVector(String key) {\n\t\t\tArrayList<? extends Number> o;\n\n\t\t\tattributeLock.lock();\n\t\t\to = wrappedElement.getVector(key);\n\t\t\tattributeLock.unlock();\n\n\t\t\treturn o;\n\t\t}\n\n\t\tpublic boolean hasArray(String key) {\n\t\t\tboolean b;\n\n\t\t\tattributeLock.lock();\n\t\t\tb = wrappedElement.hasArray(key);\n\t\t\tattributeLock.unlock();\n\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic boolean hasAttribute(String key) {\n\t\t\tboolean b;\n\n\t\t\tattributeLock.lock();\n\t\t\tb = wrappedElement.hasAttribute(key);\n\t\t\tattributeLock.unlock();\n\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic boolean hasAttribute(String key, Class<?> clazz) {\n\t\t\tboolean b;\n\n\t\t\tattributeLock.lock();\n\t\t\tb = wrappedElement.hasAttribute(key, clazz);\n\t\t\tattributeLock.unlock();\n\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic boolean hasHash(String key) {\n\t\t\tboolean b;\n\n\t\t\tattributeLock.lock();\n\t\t\tb = wrappedElement.hasHash(key);\n\t\t\tattributeLock.unlock();\n\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic boolean hasLabel(String key) {\n\t\t\tboolean b;\n\n\t\t\tattributeLock.lock();\n\t\t\tb = wrappedElement.hasLabel(key);\n\t\t\tattributeLock.unlock();\n\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic boolean hasNumber(String key) {\n\t\t\tboolean b;\n\n\t\t\tattributeLock.lock();\n\t\t\tb = wrappedElement.hasNumber(key);\n\t\t\tattributeLock.unlock();\n\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic boolean hasVector(String key) {\n\t\t\tboolean b;\n\n\t\t\tattributeLock.lock();\n\t\t\tb = wrappedElement.hasVector(key);\n\t\t\tattributeLock.unlock();\n\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic void removeAttribute(String attribute) {\n\t\t\tattributeLock.lock();\n\t\t\twrappedElement.removeAttribute(attribute);\n\t\t\tattributeLock.unlock();\n\t\t}\n\n\t\tpublic void setAttribute(String attribute, Object... values) {\n\t\t\tattributeLock.lock();\n\t\t\twrappedElement.setAttribute(attribute, values);\n\t\t\tattributeLock.unlock();\n\t\t}\t\t\n\t}\n\n\tstatic class SynchronizedGraph extends SynchronizedElement<Graph> implements\n\t\t\tGraph {\n\n\t\tfinal ReentrantLock elementLock;\n\t\tfinal HashMap<String, Node> synchronizedNodes;\n\t\tfinal HashMap<String, Edge> synchronizedEdges;\n\n\t\tSynchronizedGraph(Graph g) {\n\t\t\tsuper(g);\n\n\t\t\telementLock = new ReentrantLock();\n\t\t\tsynchronizedNodes = new HashMap<String, Node>();\n\t\t\tsynchronizedEdges = new HashMap<String, Edge>();\n\n\t\t\tfor (Node n : g.getEachNode())\n\t\t\t\tsynchronizedNodes.put(n.getId(), new SynchronizedNode(this, n));\n\n\t\t\tfor (Edge e : g.getEachEdge())\n\t\t\t\tsynchronizedEdges.put(e.getId(), new SynchronizedEdge(this, e));\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic <T extends Edge> T addEdge(String id, String node1, String node2)\n\t\t\t\tthrows IdAlreadyInUseException, ElementNotFoundException,\n\t\t\t\tEdgeRejectedException {\n\t\t\tT e;\n\t\t\tEdge se;\n\n\t\t\telementLock.lock();\n\n\t\t\te = wrappedElement.addEdge(id, node1, node2);\n\t\t\tse = new SynchronizedEdge(this, e);\n\t\t\tsynchronizedEdges.put(id, se);\n\n\t\t\telementLock.unlock();\n\n\t\t\treturn (T) se;\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic <T extends Edge> T addEdge(String id, String from, String to,\n\t\t\t\tboolean directed) throws IdAlreadyInUseException,\n\t\t\t\tElementNotFoundException {\n\t\t\tT e;\n\t\t\tEdge se;\n\n\t\t\telementLock.lock();\n\n\t\t\te = wrappedElement.addEdge(id, from, to, directed);\n\t\t\tse = new SynchronizedEdge(this, e);\n\t\t\tsynchronizedEdges.put(id, se);\n\n\t\t\telementLock.unlock();\n\n\t\t\treturn (T) se;\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic <T extends Edge> T addEdge(String id, int index1, int index2) {\n\t\t\tT e;\n\t\t\tEdge se;\n\n\t\t\telementLock.lock();\n\n\t\t\te = wrappedElement.addEdge(id, index1, index2);\n\t\t\tse = new SynchronizedEdge(this, e);\n\t\t\tsynchronizedEdges.put(id, se);\n\n\t\t\telementLock.unlock();\n\n\t\t\treturn (T) se;\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic <T extends Edge> T addEdge(String id, int fromIndex,\n\t\t\t\tint toIndex, boolean directed) {\n\t\t\tT e;\n\t\t\tEdge se;\n\n\t\t\telementLock.lock();\n\n\t\t\te = wrappedElement.addEdge(id, fromIndex, toIndex, directed);\n\t\t\tse = new SynchronizedEdge(this, e);\n\t\t\tsynchronizedEdges.put(id, se);\n\n\t\t\telementLock.unlock();\n\n\t\t\treturn (T) se;\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic <T extends Edge> T addEdge(String id, Node node1, Node node2) {\n\t\t\tT e;\n\t\t\tEdge se;\n\t\t\tfinal Node unsyncNode1, unsyncNode2;\n\n\t\t\tunsyncNode1 = ((SynchronizedElement<Node>) node1).wrappedElement;\n\t\t\tunsyncNode2 = ((SynchronizedElement<Node>) node2).wrappedElement;\n\n\t\t\telementLock.lock();\n\n\t\t\te = wrappedElement.addEdge(id, unsyncNode1, unsyncNode2);\n\t\t\tse = new SynchronizedEdge(this, e);\n\t\t\tsynchronizedEdges.put(id, se);\n\n\t\t\telementLock.unlock();\n\n\t\t\treturn (T) se;\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic <T extends Edge> T addEdge(String id, Node from, Node to,\n\t\t\t\tboolean directed) {\n\t\t\tT e;\n\t\t\tEdge se;\n\t\t\tfinal Node unsyncFrom, unsyncTo;\n\n\t\t\tunsyncFrom = ((SynchronizedElement<Node>) from).wrappedElement;\n\t\t\tunsyncTo = ((SynchronizedElement<Node>) to).wrappedElement;\n\n\t\t\telementLock.lock();\n\n\t\t\te = wrappedElement.addEdge(id, unsyncFrom, unsyncTo, directed);\n\t\t\tse = new SynchronizedEdge(this, e);\n\t\t\tsynchronizedEdges.put(id, se);\n\n\t\t\telementLock.unlock();\n\n\t\t\treturn (T) se;\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic <T extends Node> T addNode(String id)\n\t\t\t\tthrows IdAlreadyInUseException {\n\t\t\tT n;\n\t\t\tNode sn;\n\n\t\t\telementLock.lock();\n\n\t\t\tn = wrappedElement.addNode(id);\n\t\t\tsn = new SynchronizedNode(this, n);\n\t\t\tsynchronizedNodes.put(id, sn);\n\n\t\t\telementLock.unlock();\n\n\t\t\treturn (T) sn;\n\t\t}\n\n\t\tpublic Iterable<AttributeSink> attributeSinks() {\n\t\t\tLinkedList<AttributeSink> sinks = new LinkedList<AttributeSink>();\n\n\t\t\telementLock.lock();\n\n\t\t\tfor (AttributeSink as : wrappedElement.attributeSinks())\n\t\t\t\tsinks.add(as);\n\n\t\t\telementLock.unlock();\n\n\t\t\treturn sinks;\n\t\t}\n\n\t\tpublic void clear() {\n\t\t\telementLock.lock();\n\t\t\twrappedElement.clear();\n\t\t\telementLock.unlock();\n\t\t}\n\n\t\tpublic Viewer display() {\n\t\t\treturn wrappedElement.display();\n\t\t}\n\n\t\tpublic Viewer display(boolean autoLayout) {\n\t\t\treturn wrappedElement.display(autoLayout);\n\t\t}\n\n\t\tpublic EdgeFactory<? extends Edge> edgeFactory() {\n\t\t\treturn wrappedElement.edgeFactory();\n\t\t}\n\n\t\tpublic Iterable<ElementSink> elementSinks() {\n\t\t\tLinkedList<ElementSink> sinks = new LinkedList<ElementSink>();\n\n\t\t\telementLock.lock();\n\n\t\t\tfor (ElementSink es : wrappedElement.elementSinks())\n\t\t\t\tsinks.add(es);\n\n\t\t\telementLock.unlock();\n\n\t\t\treturn sinks;\n\t\t}\n\n\t\tpublic Iterable<Edge> getEachEdge() {\n\t\t\tLinkedList<Edge> edges;\n\n\t\t\telementLock.lock();\n\t\t\tedges = new LinkedList<Edge>(synchronizedEdges.values());\n\t\t\telementLock.unlock();\n\n\t\t\treturn edges;\n\t\t}\n\n\t\tpublic Iterable<Node> getEachNode() {\n\t\t\tLinkedList<Node> nodes;\n\n\t\t\telementLock.lock();\n\t\t\tnodes = new LinkedList<Node>(synchronizedNodes.values());\n\t\t\telementLock.unlock();\n\n\t\t\treturn nodes;\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic <T extends Edge> T getEdge(String id) {\n\t\t\tT e;\n\n\t\t\telementLock.lock();\n\t\t\te = (T) synchronizedEdges.get(id);\n\t\t\telementLock.unlock();\n\n\t\t\treturn e;\n\t\t}\n\n\t\tpublic <T extends Edge> T getEdge(int index)\n\t\t\t\tthrows IndexOutOfBoundsException {\n\t\t\tEdge e;\n\n\t\t\telementLock.lock();\n\t\t\te = wrappedElement.getEdge(index);\n\t\t\telementLock.unlock();\n\n\t\t\treturn e == null ? null : this.<T> getEdge(e.getId());\n\t\t}\n\n\t\tpublic int getEdgeCount() {\n\t\t\tint c;\n\n\t\t\telementLock.lock();\n\t\t\tc = synchronizedEdges.size();\n\t\t\telementLock.unlock();\n\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic Iterator<Edge> getEdgeIterator() {\n\t\t\treturn getEdgeSet().iterator();\n\t\t}\n\n\t\tpublic Collection<Edge> getEdgeSet() {\n\t\t\tLinkedList<Edge> l;\n\n\t\t\telementLock.lock();\n\t\t\tl = new LinkedList<Edge>(synchronizedEdges.values());\n\t\t\telementLock.unlock();\n\n\t\t\treturn l;\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic <T extends Node> T getNode(String id) {\n\t\t\tT n;\n\n\t\t\telementLock.lock();\n\t\t\tn = (T) synchronizedNodes.get(id);\n\t\t\telementLock.unlock();\n\n\t\t\treturn n;\n\t\t}\n\n\t\tpublic <T extends Node> T getNode(int index)\n\t\t\t\tthrows IndexOutOfBoundsException {\n\t\t\tNode n;\n\n\t\t\telementLock.lock();\n\t\t\tn = wrappedElement.getNode(index);\n\t\t\telementLock.unlock();\n\n\t\t\treturn n == null ? null : this.<T> getNode(n.getId());\n\t\t}\n\n\t\tpublic int getNodeCount() {\n\t\t\tint c;\n\n\t\t\telementLock.lock();\n\t\t\tc = synchronizedNodes.size();\n\t\t\telementLock.unlock();\n\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic Iterator<Node> getNodeIterator() {\n\t\t\treturn getNodeSet().iterator();\n\t\t}\n\n\t\tpublic Collection<Node> getNodeSet() {\n\t\t\tLinkedList<Node> l;\n\n\t\t\telementLock.lock();\n\t\t\tl = new LinkedList<Node>(synchronizedNodes.values());\n\t\t\telementLock.unlock();\n\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic double getStep() {\n\t\t\tdouble s;\n\n\t\t\telementLock.lock();\n\t\t\ts = wrappedElement.getStep();\n\t\t\telementLock.unlock();\n\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic boolean isAutoCreationEnabled() {\n\t\t\treturn wrappedElement.isAutoCreationEnabled();\n\t\t}\n\n\t\tpublic boolean isStrict() {\n\t\t\treturn wrappedElement.isStrict();\n\t\t}\n\n\t\tpublic NodeFactory<? extends Node> nodeFactory() {\n\t\t\treturn wrappedElement.nodeFactory();\n\t\t}\n\n\t\tpublic boolean nullAttributesAreErrors() {\n\t\t\treturn wrappedElement.nullAttributesAreErrors();\n\t\t}\n\n\t\tpublic void read(String filename) throws IOException,\n\t\t\t\tGraphParseException, ElementNotFoundException {\n\t\t\telementLock.lock();\n\t\t\twrappedElement.read(filename);\n\t\t\telementLock.unlock();\n\t\t}\n\n\t\tpublic void read(FileSource input, String filename) throws IOException,\n\t\t\t\tGraphParseException {\n\t\t\telementLock.lock();\n\t\t\twrappedElement.read(input, filename);\n\t\t\telementLock.unlock();\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic <T extends Edge> T removeEdge(String from, String to)\n\t\t\t\tthrows ElementNotFoundException {\n\t\t\tT e;\n\t\t\tEdge se;\n\n\t\t\telementLock.lock();\n\t\t\te = wrappedElement.removeEdge(from, to);\n\t\t\tse = synchronizedEdges.remove(e.getId());\n\t\t\telementLock.unlock();\n\n\t\t\treturn (T) se;\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic <T extends Edge> T removeEdge(String id)\n\t\t\t\tthrows ElementNotFoundException {\n\t\t\tT e;\n\t\t\tEdge se;\n\n\t\t\telementLock.lock();\n\t\t\te = wrappedElement.removeEdge(id);\n\t\t\tse = synchronizedEdges.remove(e.getId());\n\t\t\telementLock.unlock();\n\n\t\t\treturn (T) se;\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic <T extends Edge> T removeEdge(int index) {\n\t\t\tT e;\n\t\t\tEdge se;\n\n\t\t\telementLock.lock();\n\t\t\te = wrappedElement.removeEdge(index);\n\t\t\tse = synchronizedEdges.remove(e.getId());\n\t\t\telementLock.unlock();\n\n\t\t\treturn (T) se;\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic <T extends Edge> T removeEdge(int fromIndex, int toIndex) {\n\t\t\tT e;\n\t\t\tEdge se;\n\n\t\t\telementLock.lock();\n\t\t\te = wrappedElement.removeEdge(fromIndex, toIndex);\n\t\t\tse = synchronizedEdges.remove(e.getId());\n\t\t\telementLock.unlock();\n\n\t\t\treturn (T) se;\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic <T extends Edge> T removeEdge(Node node1, Node node2) {\n\t\t\tT e;\n\t\t\tEdge se;\n\n\t\t\tif (node1 instanceof SynchronizedNode)\n\t\t\t\tnode1 = ((SynchronizedNode) node1).wrappedElement;\n\n\t\t\tif (node2 instanceof SynchronizedNode)\n\t\t\t\tnode2 = ((SynchronizedNode) node1).wrappedElement;\n\n\t\t\telementLock.lock();\n\t\t\te = wrappedElement.removeEdge(node1, node2);\n\t\t\tse = synchronizedEdges.remove(e.getId());\n\t\t\telementLock.unlock();\n\n\t\t\treturn (T) se;\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic <T extends Edge> T removeEdge(Edge edge) {\n\t\t\tT e;\n\t\t\tEdge se;\n\n\t\t\tif (edge instanceof SynchronizedEdge)\n\t\t\t\tedge = ((SynchronizedEdge) edge).wrappedElement;\n\n\t\t\telementLock.lock();\n\t\t\te = wrappedElement.removeEdge(edge);\n\t\t\tse = synchronizedEdges.remove(e.getId());\n\t\t\telementLock.unlock();\n\n\t\t\treturn (T) se;\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic <T extends Node> T removeNode(String id)\n\t\t\t\tthrows ElementNotFoundException {\n\t\t\tT n;\n\t\t\tNode sn;\n\n\t\t\telementLock.lock();\n\t\t\tn = wrappedElement.removeNode(id);\n\t\t\tsn = synchronizedNodes.remove(n.getId());\n\t\t\telementLock.unlock();\n\n\t\t\treturn (T) sn;\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic <T extends Node> T removeNode(int index) {\n\t\t\tT n;\n\t\t\tNode sn;\n\n\t\t\telementLock.lock();\n\t\t\tn = wrappedElement.removeNode(index);\n\t\t\tsn = synchronizedNodes.remove(n.getId());\n\t\t\telementLock.unlock();\n\n\t\t\treturn (T) sn;\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic <T extends Node> T removeNode(Node node) {\n\t\t\tT n;\n\t\t\tNode sn;\n\n\t\t\tif (node instanceof SynchronizedNode)\n\t\t\t\tnode = ((SynchronizedNode) node).wrappedElement;\n\n\t\t\telementLock.lock();\n\t\t\tn = wrappedElement.removeNode(node);\n\t\t\tsn = synchronizedNodes.remove(n.getId());\n\t\t\telementLock.unlock();\n\n\t\t\treturn (T) sn;\n\t\t}\n\n\t\tpublic void setAutoCreate(boolean on) {\n\t\t\telementLock.lock();\n\t\t\twrappedElement.setAutoCreate(on);\n\t\t\telementLock.unlock();\n\t\t}\n\n\t\tpublic void setEdgeFactory(EdgeFactory<? extends Edge> ef) {\n\t\t\telementLock.lock();\n\t\t\twrappedElement.setEdgeFactory(ef);\n\t\t\telementLock.unlock();\n\t\t}\n\n\t\tpublic void setNodeFactory(NodeFactory<? extends Node> nf) {\n\t\t\telementLock.lock();\n\t\t\twrappedElement.setNodeFactory(nf);\n\t\t\telementLock.unlock();\n\t\t}\n\n\t\tpublic void setNullAttributesAreErrors(boolean on) {\n\t\t\telementLock.lock();\n\t\t\twrappedElement.setNullAttributesAreErrors(on);\n\t\t\telementLock.unlock();\n\t\t}\n\n\t\tpublic void setStrict(boolean on) {\n\t\t\telementLock.lock();\n\t\t\twrappedElement.setStrict(on);\n\t\t\telementLock.unlock();\n\t\t}\n\n\t\tpublic void stepBegins(double time) {\n\t\t\telementLock.lock();\n\t\t\twrappedElement.stepBegins(time);\n\t\t\telementLock.unlock();\n\t\t}\n\n\t\tpublic void write(String filename) throws IOException {\n\t\t\telementLock.lock();\n\t\t\twrappedElement.write(filename);\n\t\t\telementLock.unlock();\n\t\t}\n\n\t\tpublic void write(FileSink output, String filename) throws IOException {\n\t\t\telementLock.lock();\n\t\t\twrappedElement.write(output, filename);\n\t\t\telementLock.unlock();\n\t\t}\n\n\t\tpublic void addAttributeSink(AttributeSink sink) {\n\t\t\telementLock.lock();\n\t\t\twrappedElement.addAttributeSink(sink);\n\t\t\telementLock.unlock();\n\t\t}\n\n\t\tpublic void addElementSink(ElementSink sink) {\n\t\t\telementLock.lock();\n\t\t\twrappedElement.addElementSink(sink);\n\t\t\telementLock.unlock();\n\t\t}\n\n\t\tpublic void addSink(Sink sink) {\n\t\t\telementLock.lock();\n\t\t\twrappedElement.addSink(sink);\n\t\t\telementLock.unlock();\n\t\t}\n\n\t\tpublic void clearAttributeSinks() {\n\t\t\telementLock.lock();\n\t\t\twrappedElement.clearAttributeSinks();\n\t\t\telementLock.unlock();\n\t\t}\n\n\t\tpublic void clearElementSinks() {\n\t\t\telementLock.lock();\n\t\t\twrappedElement.clearElementSinks();\n\t\t\telementLock.unlock();\n\t\t}\n\n\t\tpublic void clearSinks() {\n\t\t\telementLock.lock();\n\t\t\twrappedElement.clearSinks();\n\t\t\telementLock.unlock();\n\t\t}\n\n\t\tpublic void removeAttributeSink(AttributeSink sink) {\n\t\t\telementLock.lock();\n\t\t\twrappedElement.removeAttributeSink(sink);\n\t\t\telementLock.unlock();\n\t\t}\n\n\t\tpublic void removeElementSink(ElementSink sink) {\n\t\t\telementLock.lock();\n\t\t\twrappedElement.removeElementSink(sink);\n\t\t\telementLock.unlock();\n\t\t}\n\n\t\tpublic void removeSink(Sink sink) {\n\t\t\telementLock.lock();\n\t\t\twrappedElement.removeSink(sink);\n\t\t\telementLock.unlock();\n\t\t}\n\n\t\tpublic void edgeAttributeAdded(String sourceId, long timeId,\n\t\t\t\tString edgeId, String attribute, Object value) {\n\t\t\twrappedElement.edgeAttributeAdded(sourceId, timeId, edgeId,\n\t\t\t\t\tattribute, value);\n\t\t}\n\n\t\tpublic void edgeAttributeChanged(String sourceId, long timeId,\n\t\t\t\tString edgeId, String attribute, Object oldValue,\n\t\t\t\tObject newValue) {\n\t\t\twrappedElement.edgeAttributeChanged(sourceId, timeId, edgeId,\n\t\t\t\t\tattribute, oldValue, newValue);\n\t\t}\n\n\t\tpublic void edgeAttributeRemoved(String sourceId, long timeId,\n\t\t\t\tString edgeId, String attribute) {\n\t\t\twrappedElement.edgeAttributeRemoved(sourceId, timeId, edgeId,\n\t\t\t\t\tattribute);\n\t\t}\n\n\t\tpublic void graphAttributeAdded(String sourceId, long timeId,\n\t\t\t\tString attribute, Object value) {\n\t\t\twrappedElement.graphAttributeAdded(sourceId, timeId, attribute,\n\t\t\t\t\tvalue);\n\t\t}\n\n\t\tpublic void graphAttributeChanged(String sourceId, long timeId,\n\t\t\t\tString attribute, Object oldValue, Object newValue) {\n\t\t\twrappedElement.graphAttributeChanged(sourceId, timeId, attribute,\n\t\t\t\t\toldValue, newValue);\n\t\t}\n\n\t\tpublic void graphAttributeRemoved(String sourceId, long timeId,\n\t\t\t\tString attribute) {\n\t\t\twrappedElement.graphAttributeRemoved(sourceId, timeId, attribute);\n\t\t}\n\n\t\tpublic void nodeAttributeAdded(String sourceId, long timeId,\n\t\t\t\tString nodeId, String attribute, Object value) {\n\t\t\twrappedElement.nodeAttributeAdded(sourceId, timeId, nodeId,\n\t\t\t\t\tattribute, value);\n\t\t}\n\n\t\tpublic void nodeAttributeChanged(String sourceId, long timeId,\n\t\t\t\tString nodeId, String attribute, Object oldValue,\n\t\t\t\tObject newValue) {\n\t\t\twrappedElement.nodeAttributeChanged(sourceId, timeId, nodeId,\n\t\t\t\t\tattribute, oldValue, newValue);\n\t\t}\n\n\t\tpublic void nodeAttributeRemoved(String sourceId, long timeId,\n\t\t\t\tString nodeId, String attribute) {\n\t\t\twrappedElement.nodeAttributeRemoved(sourceId, timeId, nodeId,\n\t\t\t\t\tattribute);\n\t\t}\n\n\t\tpublic void edgeAdded(String sourceId, long timeId, String edgeId,\n\t\t\t\tString fromNodeId, String toNodeId, boolean directed) {\n\t\t\twrappedElement.edgeAdded(sourceId, timeId, edgeId, fromNodeId,\n\t\t\t\t\ttoNodeId, directed);\n\t\t}\n\n\t\tpublic void edgeRemoved(String sourceId, long timeId, String edgeId) {\n\t\t\twrappedElement.edgeRemoved(sourceId, timeId, edgeId);\n\t\t}\n\n\t\tpublic void graphCleared(String sourceId, long timeId) {\n\t\t\twrappedElement.graphCleared(sourceId, timeId);\n\t\t}\n\n\t\tpublic void nodeAdded(String sourceId, long timeId, String nodeId) {\n\t\t\twrappedElement.nodeAdded(sourceId, timeId, nodeId);\n\t\t}\n\n\t\tpublic void nodeRemoved(String sourceId, long timeId, String nodeId) {\n\t\t\twrappedElement.nodeRemoved(sourceId, timeId, nodeId);\n\t\t}\n\n\t\tpublic void stepBegins(String sourceId, long timeId, double step) {\n\t\t\twrappedElement.stepBegins(sourceId, timeId, step);\n\t\t}\n\n\t\tpublic Iterator<Node> iterator() {\n\t\t\treturn getEachNode().iterator();\n\t\t}\n\t}\n\n\tstatic class SynchronizedNode extends SynchronizedElement<Node> implements\n\t\t\tNode {\n\n\t\tprivate final SynchronizedGraph sg;\n\t\tprivate final ReentrantLock elementLock;\n\n\t\tSynchronizedNode(SynchronizedGraph sg, Node n) {\n\t\t\tsuper(n);\n\n\t\t\tthis.sg = sg;\n\t\t\tthis.elementLock = new ReentrantLock();\n\t\t}\n\n\t\tpublic Iterator<Node> getBreadthFirstIterator() {\n\t\t\treturn getBreadthFirstIterator(false);\n\t\t}\n\n\t\tpublic Iterator<Node> getBreadthFirstIterator(boolean directed) {\n\t\t\tLinkedList<Node> l = new LinkedList<Node>();\n\t\t\tIterator<Node> it;\n\n\t\t\telementLock.lock();\n\t\t\tsg.elementLock.lock();\n\n\t\t\tit = wrappedElement.getBreadthFirstIterator(directed);\n\n\t\t\twhile (it.hasNext())\n\t\t\t\tl.add(sg.getNode(it.next().getIndex()));\n\n\t\t\tsg.elementLock.unlock();\n\t\t\telementLock.unlock();\n\n\t\t\treturn l.iterator();\n\t\t}\n\n\t\tpublic int getDegree() {\n\t\t\tint d;\n\n\t\t\telementLock.lock();\n\t\t\td = wrappedElement.getDegree();\n\t\t\telementLock.unlock();\n\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic Iterator<Node> getDepthFirstIterator() {\n\t\t\treturn getDepthFirstIterator(false);\n\t\t}\n\n\t\tpublic Iterator<Node> getDepthFirstIterator(boolean directed) {\n\t\t\tLinkedList<Node> l = new LinkedList<Node>();\n\t\t\tIterator<Node> it;\n\n\t\t\telementLock.lock();\n\t\t\tsg.elementLock.lock();\n\n\t\t\tit = wrappedElement.getDepthFirstIterator();\n\n\t\t\twhile (it.hasNext())\n\t\t\t\tl.add(sg.getNode(it.next().getIndex()));\n\n\t\t\tsg.elementLock.unlock();\n\t\t\telementLock.unlock();\n\n\t\t\treturn l.iterator();\n\t\t}\n\n\t\tpublic Iterable<Edge> getEachEdge() {\n\t\t\treturn getEdgeSet();\n\t\t}\n\n\t\tpublic Iterable<Edge> getEachEnteringEdge() {\n\t\t\treturn getEnteringEdgeSet();\n\t\t}\n\n\t\tpublic Iterable<Edge> getEachLeavingEdge() {\n\t\t\treturn getLeavingEdgeSet();\n\t\t}\n\n\t\tpublic <T extends Edge> T getEdge(int i) {\n\t\t\tT e;\n\n\t\t\telementLock.lock();\n\t\t\te = sg.getEdge(wrappedElement.getEdge(i).getIndex());\n\t\t\telementLock.unlock();\n\n\t\t\treturn e;\n\t\t}\n\n\t\tpublic <T extends Edge> T getEnteringEdge(int i) {\n\t\t\tT e;\n\n\t\t\telementLock.lock();\n\t\t\te = sg.getEdge(wrappedElement.getEnteringEdge(i).getIndex());\n\t\t\telementLock.unlock();\n\n\t\t\treturn e;\n\t\t}\n\n\t\tpublic <T extends Edge> T getLeavingEdge(int i) {\n\t\t\tT e;\n\n\t\t\telementLock.lock();\n\t\t\te = sg.getEdge(wrappedElement.getLeavingEdge(i).getIndex());\n\t\t\telementLock.unlock();\n\n\t\t\treturn e;\n\t\t}\n\n\t\tpublic <T extends Edge> T getEdgeBetween(String id) {\n\t\t\tT e;\n\n\t\t\telementLock.lock();\n\t\t\te = sg.getEdge(wrappedElement.getEdgeBetween(id).getIndex());\n\t\t\telementLock.unlock();\n\n\t\t\treturn e;\n\t\t}\n\n\t\tpublic <T extends Edge> T getEdgeBetween(Node n) {\n\t\t\tT e;\n\n\t\t\telementLock.lock();\n\t\t\te = sg.getEdge(wrappedElement.getEdgeBetween(n).getIndex());\n\t\t\telementLock.unlock();\n\n\t\t\treturn e;\n\t\t}\n\n\t\tpublic <T extends Edge> T getEdgeBetween(int index) {\n\t\t\tT e;\n\n\t\t\telementLock.lock();\n\t\t\te = sg.getEdge(wrappedElement.getEdgeBetween(index).getIndex());\n\t\t\telementLock.unlock();\n\n\t\t\treturn e;\n\t\t}\n\n\t\tpublic <T extends Edge> T getEdgeFrom(String id) {\n\t\t\tT e;\n\n\t\t\telementLock.lock();\n\t\t\te = sg.getEdge(wrappedElement.getEdgeFrom(id).getIndex());\n\t\t\telementLock.unlock();\n\n\t\t\treturn e;\n\t\t}\n\n\t\tpublic <T extends Edge> T getEdgeFrom(Node n) {\n\t\t\tT e;\n\n\t\t\telementLock.lock();\n\t\t\te = sg.getEdge(wrappedElement.getEdgeFrom(n).getIndex());\n\t\t\telementLock.unlock();\n\n\t\t\treturn e;\n\t\t}\n\n\t\tpublic <T extends Edge> T getEdgeFrom(int index) {\n\t\t\tT e;\n\n\t\t\telementLock.lock();\n\t\t\te = sg.getEdge(wrappedElement.getEdgeFrom(index).getIndex());\n\t\t\telementLock.unlock();\n\n\t\t\treturn e;\n\t\t}\n\n\t\tpublic Iterator<Edge> getEdgeIterator() {\n\t\t\treturn getEdgeSet().iterator();\n\t\t}\n\n\t\tpublic Collection<Edge> getEdgeSet() {\n\t\t\tArrayList<Edge> l;\n\t\t\tIterator<Edge> it;\n\n\t\t\telementLock.lock();\n\n\t\t\tl = new ArrayList<Edge>(wrappedElement.getDegree());\n\t\t\tit = wrappedElement.getEachEdge().iterator();\n\n\t\t\twhile (it.hasNext())\n\t\t\t\tl.add(sg.getEdge(it.next().getIndex()));\n\n\t\t\telementLock.unlock();\n\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic <T extends Edge> T getEdgeToward(String id) {\n\t\t\tT e;\n\n\t\t\telementLock.lock();\n\t\t\te = sg.getEdge(wrappedElement.getEdgeToward(id).getIndex());\n\t\t\telementLock.unlock();\n\n\t\t\treturn e;\n\t\t}\n\n\t\tpublic <T extends Edge> T getEdgeToward(Node n) {\n\t\t\tT e;\n\n\t\t\telementLock.lock();\n\t\t\te = sg.getEdge(wrappedElement.getEdgeToward(n).getIndex());\n\t\t\telementLock.unlock();\n\n\t\t\treturn e;\n\t\t}\n\n\t\tpublic <T extends Edge> T getEdgeToward(int index) {\n\t\t\tT e;\n\n\t\t\telementLock.lock();\n\t\t\te = sg.getEdge(wrappedElement.getEdgeToward(index).getIndex());\n\t\t\telementLock.unlock();\n\n\t\t\treturn e;\n\t\t}\n\n\t\tpublic Iterator<Edge> getEnteringEdgeIterator() {\n\t\t\treturn getEnteringEdgeSet().iterator();\n\t\t}\n\n\t\tpublic Collection<Edge> getEnteringEdgeSet() {\n\t\t\tArrayList<Edge> l;\n\t\t\tIterator<Edge> it;\n\n\t\t\telementLock.lock();\n\t\t\tsg.elementLock.lock();\n\n\t\t\tl = new ArrayList<Edge>(wrappedElement.getInDegree());\n\t\t\tit = wrappedElement.getEachEnteringEdge().iterator();\n\n\t\t\twhile (it.hasNext())\n\t\t\t\tl.add(sg.getEdge(it.next().getIndex()));\n\n\t\t\tsg.elementLock.unlock();\n\t\t\telementLock.unlock();\n\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic Graph getGraph() {\n\t\t\treturn sg;\n\t\t}\n\n\t\tpublic int getInDegree() {\n\t\t\tint d;\n\n\t\t\telementLock.lock();\n\t\t\td = wrappedElement.getInDegree();\n\t\t\telementLock.unlock();\n\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic Iterator<Edge> getLeavingEdgeIterator() {\n\t\t\treturn getLeavingEdgeSet().iterator();\n\t\t}\n\n\t\tpublic Collection<Edge> getLeavingEdgeSet() {\n\t\t\tArrayList<Edge> l;\n\t\t\tIterator<Edge> it;\n\n\t\t\telementLock.lock();\n\t\t\tsg.elementLock.lock();\n\n\t\t\tl = new ArrayList<Edge>(wrappedElement.getOutDegree());\n\t\t\tit = wrappedElement.<Edge> getEachLeavingEdge().iterator();\n\n\t\t\twhile (it.hasNext())\n\t\t\t\tl.add(sg.getEdge(it.next().getIndex()));\n\n\t\t\tsg.elementLock.unlock();\n\t\t\telementLock.unlock();\n\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic Iterator<Node> getNeighborNodeIterator() {\n\t\t\tArrayList<Node> l;\n\t\t\tIterator<Node> it;\n\n\t\t\telementLock.lock();\n\t\t\tsg.elementLock.lock();\n\n\t\t\tl = new ArrayList<Node>(wrappedElement.getDegree());\n\t\t\tit = wrappedElement.getNeighborNodeIterator();\n\n\t\t\twhile (it.hasNext())\n\t\t\t\tl.add(sg.getNode(it.next().getIndex()));\n\n\t\t\tsg.elementLock.unlock();\n\t\t\telementLock.unlock();\n\n\t\t\treturn l.iterator();\n\t\t}\n\n\t\tpublic int getOutDegree() {\n\t\t\tint d;\n\n\t\t\telementLock.lock();\n\t\t\td = wrappedElement.getOutDegree();\n\t\t\telementLock.unlock();\n\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic boolean hasEdgeBetween(String id) {\n\t\t\tboolean b;\n\n\t\t\telementLock.lock();\n\t\t\tb = wrappedElement.hasEdgeBetween(id);\n\t\t\telementLock.unlock();\n\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic boolean hasEdgeBetween(Node node) {\n\t\t\tboolean b;\n\n\t\t\telementLock.lock();\n\t\t\tb = wrappedElement.hasEdgeBetween(node);\n\t\t\telementLock.unlock();\n\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic boolean hasEdgeBetween(int index) {\n\t\t\tboolean b;\n\n\t\t\telementLock.lock();\n\t\t\tb = wrappedElement.hasEdgeBetween(index);\n\t\t\telementLock.unlock();\n\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic boolean hasEdgeFrom(String id) {\n\t\t\tboolean b;\n\n\t\t\telementLock.lock();\n\t\t\tb = wrappedElement.hasEdgeFrom(id);\n\t\t\telementLock.unlock();\n\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic boolean hasEdgeFrom(Node node) {\n\t\t\tboolean b;\n\n\t\t\telementLock.lock();\n\t\t\tb = wrappedElement.hasEdgeFrom(node);\n\t\t\telementLock.unlock();\n\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic boolean hasEdgeFrom(int index) {\n\t\t\tboolean b;\n\n\t\t\telementLock.lock();\n\t\t\tb = wrappedElement.hasEdgeFrom(index);\n\t\t\telementLock.unlock();\n\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic boolean hasEdgeToward(String id) {\n\t\t\tboolean b;\n\n\t\t\telementLock.lock();\n\t\t\tb = wrappedElement.hasEdgeToward(id);\n\t\t\telementLock.unlock();\n\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic boolean hasEdgeToward(Node node) {\n\t\t\tboolean b;\n\n\t\t\telementLock.lock();\n\t\t\tb = wrappedElement.hasEdgeToward(node);\n\t\t\telementLock.unlock();\n\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic boolean hasEdgeToward(int index) {\n\t\t\tboolean b;\n\n\t\t\telementLock.lock();\n\t\t\tb = wrappedElement.hasEdgeToward(index);\n\t\t\telementLock.unlock();\n\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic Iterator<Edge> iterator() {\n\t\t\treturn getEdgeSet().iterator();\n\t\t}\n\t}\n\n\tstatic class SynchronizedEdge extends SynchronizedElement<Edge> implements\n\t\t\tEdge {\n\n\t\tfinal SynchronizedGraph sg;\n\n\t\tSynchronizedEdge(SynchronizedGraph sg, Edge e) {\n\t\t\tsuper(e);\n\t\t\tthis.sg = sg;\n\t\t}\n\n\t\tpublic <T extends Node> T getNode0() {\n\t\t\tT n;\n\n\t\t\tsg.elementLock.lock();\n\t\t\tn = sg.getNode(wrappedElement.getNode0().getIndex());\n\t\t\tsg.elementLock.unlock();\n\n\t\t\treturn n;\n\t\t}\n\n\t\tpublic <T extends Node> T getNode1() {\n\t\t\tT n;\n\n\t\t\tsg.elementLock.lock();\n\t\t\tn = sg.getNode(wrappedElement.getNode1().getIndex());\n\t\t\tsg.elementLock.unlock();\n\n\t\t\treturn n;\n\t\t}\n\n\t\tpublic <T extends Node> T getOpposite(Node node) {\n\t\t\tT n;\n\n\t\t\tif (node instanceof SynchronizedNode)\n\t\t\t\tnode = ((SynchronizedNode) node).wrappedElement;\n\n\t\t\tsg.elementLock.lock();\n\t\t\tn = sg.getNode(wrappedElement.getOpposite(node).getIndex());\n\t\t\tsg.elementLock.unlock();\n\n\t\t\treturn n;\n\t\t}\n\n\t\tpublic <T extends Node> T getSourceNode() {\n\t\t\tT n;\n\n\t\t\tsg.elementLock.lock();\n\t\t\tn = sg.getNode(wrappedElement.getSourceNode().getIndex());\n\t\t\tsg.elementLock.unlock();\n\n\t\t\treturn n;\n\t\t}\n\n\t\tpublic <T extends Node> T getTargetNode() {\n\t\t\tT n;\n\n\t\t\tsg.elementLock.lock();\n\t\t\tn = sg.getNode(wrappedElement.getTargetNode().getIndex());\n\t\t\tsg.elementLock.unlock();\n\n\t\t\treturn n;\n\t\t}\n\n\t\tpublic boolean isDirected() {\n\t\t\treturn wrappedElement.isDirected();\n\t\t}\n\n\t\tpublic boolean isLoop() {\n\t\t\treturn wrappedElement.isLoop();\n\t\t}\n\t}\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "g", "org.graphstream.graph", "Graph" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getNode", "org.graphstream.graph", "Graph", "public abstract <T> T getNode(String arg0)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "public abstract <T> T removeEdge(String arg0) throws ElementNotFoundException" ], [ "addEdge", "org.graphstream.graph", "Graph", "public abstract <T> T addEdge(String arg0, String arg1, String arg2) throws IdAlreadyInUseException, ElementNotFoundException, EdgeRejectedException" ], [ "getNode", "org.graphstream.graph", "Graph", "public abstract <T> T getNode(int arg0) throws IndexOutOfBoundsException" ], [ "getEdge", "org.graphstream.graph", "Graph", "public abstract <T> T getEdge(int arg0) throws IndexOutOfBoundsException" ], [ "removeEdge", "org.graphstream.graph", "Graph", "public abstract <T> T removeEdge(int arg0, int arg1) throws IndexOutOfBoundsException, ElementNotFoundException" ], [ "display", "org.graphstream.graph", "Graph", "public abstract Viewer display()" ], [ "addEdge", "org.graphstream.graph", "Graph", "public abstract <T> T addEdge(String arg0, Node arg1, Node arg2, boolean arg3) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "isAutoCreationEnabled", "org.graphstream.graph", "Graph", "public abstract boolean isAutoCreationEnabled()" ], [ "addEdge", "org.graphstream.graph", "Graph", "public abstract <T> T addEdge(String arg0, String arg1, String arg2, boolean arg3) throws IdAlreadyInUseException, ElementNotFoundException" ], [ "removeEdge", "org.graphstream.graph", "Graph", "public abstract <T> T removeEdge(Edge arg0)" ], [ "display", "org.graphstream.graph", "Graph", "public abstract Viewer display(boolean arg0)" ], [ "addEdge", "org.graphstream.graph", "Graph", "public abstract <T> T addEdge(String arg0, Node arg1, Node arg2) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "removeNode", "org.graphstream.graph", "Graph", "public abstract <T> T removeNode(Node arg0)" ], [ "edgeFactory", "org.graphstream.graph", "Graph", "public abstract EdgeFactory<? extends Edge> edgeFactory()" ], [ "addEdge", "org.graphstream.graph", "Graph", "public abstract <T> T addEdge(String arg0, int arg1, int arg2) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "addEdge", "org.graphstream.graph", "Graph", "public abstract <T> T addEdge(String arg0, int arg1, int arg2, boolean arg3) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "getEdge", "org.graphstream.graph", "Graph", "public abstract <T> T getEdge(String arg0)" ], [ "isStrict", "org.graphstream.graph", "Graph", "public abstract boolean isStrict()" ], [ "nodeFactory", "org.graphstream.graph", "Graph", "public abstract NodeFactory<? extends Node> nodeFactory()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "public abstract <T> T removeEdge(int arg0) throws IndexOutOfBoundsException" ], [ "addNode", "org.graphstream.graph", "Graph", "public abstract <T> T addNode(String arg0) throws IdAlreadyInUseException" ], [ "removeEdge", "org.graphstream.graph", "Graph", "public abstract <T> T removeEdge(Node arg0, Node arg1) throws ElementNotFoundException" ], [ "getStep", "org.graphstream.graph", "Graph", "public abstract double getStep()" ], [ "attributeSinks", "org.graphstream.graph", "Graph", "public abstract Iterable<AttributeSink> attributeSinks()" ], [ "removeNode", "org.graphstream.graph", "Graph", "public abstract <T> T removeNode(String arg0) throws ElementNotFoundException" ], [ "removeEdge", "org.graphstream.graph", "Graph", "public abstract <T> T removeEdge(String arg0, String arg1) throws ElementNotFoundException" ], [ "elementSinks", "org.graphstream.graph", "Graph", "public abstract Iterable<ElementSink> elementSinks()" ], [ "removeNode", "org.graphstream.graph", "Graph", "public abstract <T> T removeNode(int arg0) throws IndexOutOfBoundsException" ], [ "nullAttributesAreErrors", "org.graphstream.graph", "Graph", "public abstract boolean nullAttributesAreErrors()" ], [ "getAttributeCount", "org.graphstream.graph", "Element", "public abstract int getAttributeCount()" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0, Class<?> arg1)" ], [ "hasHash", "org.graphstream.graph", "Element", "public abstract boolean hasHash(String arg0)" ], [ "getLabel", "org.graphstream.graph", "Element", "public abstract CharSequence getLabel(String arg0)" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0)" ], [ "hasLabel", "org.graphstream.graph", "Element", "public abstract boolean hasLabel(String arg0)" ], [ "hasArray", "org.graphstream.graph", "Element", "public abstract boolean hasArray(String arg0)" ], [ "getEachAttributeKey", "org.graphstream.graph", "Element", "public abstract Iterable<String> getEachAttributeKey()" ], [ "getHash", "org.graphstream.graph", "Element", "public abstract HashMap<?, ?> getHash(String arg0)" ], [ "getNumber", "org.graphstream.graph", "Element", "public abstract double getNumber(String arg0)" ], [ "getId", "org.graphstream.graph", "Element", "public abstract String getId()" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0)" ], [ "getArray", "org.graphstream.graph", "Element", "public abstract Object[] getArray(String arg0)" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(String[] arg0)" ], [ "hasNumber", "org.graphstream.graph", "Element", "public abstract boolean hasNumber(String arg0)" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(Class<T> arg0, String[] arg1)" ], [ "getAttributeKeyIterator", "org.graphstream.graph", "Element", "public abstract Iterator<String> getAttributeKeyIterator()" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0, Class<T> arg1)" ], [ "hasVector", "org.graphstream.graph", "Element", "public abstract boolean hasVector(String arg0)" ], [ "getAttributeKeySet", "org.graphstream.graph", "Element", "public abstract Collection<String> getAttributeKeySet()" ], [ "getIndex", "org.graphstream.graph", "Element", "public abstract int getIndex()" ], [ "getVector", "org.graphstream.graph", "Element", "public abstract ArrayList<? extends Number> getVector(String arg0)" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "getEdgeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getEdgeSet()" ], [ "getNodeCount", "org.graphstream.graph", "Structure", "public abstract int getNodeCount()" ], [ "getEachEdge", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachEdge()" ], [ "getNodeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getNodeIterator()" ], [ "getEachNode", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachNode()" ], [ "getEdgeCount", "org.graphstream.graph", "Structure", "public abstract int getEdgeCount()" ], [ "getEdgeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getEdgeIterator()" ], [ "getNodeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getNodeSet()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
} ]