[ {
  "id" : 26222,
  "oracle" : ";",
  "oracleType" : "PRE",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht",
  "className" : "GraphMapping",
  "javadocTag" : "@param vertex vertex in one of the graphs",
  "methodJavadoc" : "    /**\n     * Gets the mapped value where the key is <code>vertex</code>\n     *\n     * @param vertex vertex in one of the graphs\n     * @param forward if true, uses mapping from graph1 to graph2; if false, use\n     * mapping from graph2 to graph1\n     *\n     * @return corresponding vertex in other graph, or null if none\n     */",
  "methodSourceCode" : "public V getVertexCorrespondence(V vertex, boolean forward);",
  "classJavadoc" : "/**\n * GraphMapping represents a bidirectional mapping between two graphs (called\n * graph1 and graph2), which allows the caller to obtain the matching vertex or\n * edge in either direction, from graph1 to graph2, or from graph2 to graph1. It\n * does not have to always be a complete bidirectional mapping (it could return\n * null for some lookups).\n *\n * @author Assaf Lehr\n * @since Jul 30, 2005\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -----------------\n * GraphMapping.java\n * -----------------\n * (C) Copyright 2005-2008, by Assaf Lehr and Contributors.\n *\n * Original Author:  Assaf Lehr\n * Contributor(s):   John V. Sichi\n *\n * Changes\n * -------\n */\npackage org.jgrapht;\n\n/**\n * GraphMapping represents a bidirectional mapping between two graphs (called\n * graph1 and graph2), which allows the caller to obtain the matching vertex or\n * edge in either direction, from graph1 to graph2, or from graph2 to graph1. It\n * does not have to always be a complete bidirectional mapping (it could return\n * null for some lookups).\n *\n * @author Assaf Lehr\n * @since Jul 30, 2005\n */\npublic interface GraphMapping<V, E>\n{\n    /**\n     * Gets the mapped value where the key is <code>vertex</code>\n     *\n     * @param vertex vertex in one of the graphs\n     * @param forward if true, uses mapping from graph1 to graph2; if false, use\n     * mapping from graph2 to graph1\n     *\n     * @return corresponding vertex in other graph, or null if none\n     */\n    public V getVertexCorrespondence(V vertex, boolean forward);\n\n    /**\n     * Gets the mapped value where the key is <code>edge</code>\n     *\n     * @param edge edge in one of the graphs\n     * @param forward if true, uses mapping from graph1 to graph2; if false, use\n     * mapping from graph2 to graph1\n     *\n     * @return corresponding edge in other graph, or null if none\n     */\n    public E getEdgeCorrespondence(E edge, boolean forward);\n}\n\n// End GraphMapping.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ [ "1", "int" ], [ "2", "int" ], [ "2", "int" ], [ "1", "int" ] ],
  "tokensMethodArguments" : [ [ "vertex", "", "V" ], [ "forward", "", "boolean" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getVertexCorrespondence", "org.jgrapht", "GraphMapping", "public V getVertexCorrespondence(V vertex, boolean forward)" ], [ "getEdgeCorrespondence", "org.jgrapht", "GraphMapping", "public E getEdgeCorrespondence(E edge, boolean forward)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 26259,
  "oracle" : ";",
  "oracleType" : "PRE",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.event",
  "className" : "GraphVertexChangeEvent",
  "javadocTag" : "@param type the type of the event.",
  "methodJavadoc" : "    /**\n     * Creates a new GraphVertexChangeEvent object.\n     *\n     * @param eventSource the source of the event.\n     * @param type the type of the event.\n     * @param vertex the vertex that the event is related to.\n     */",
  "methodSourceCode" : "public GraphVertexChangeEvent(Object eventSource, int type, V vertex){\n    super(eventSource, type);\n    this.vertex = vertex;\n}",
  "classJavadoc" : "/**\n * An event which indicates that a graph vertex has changed, or is about to\n * change. The event can be used either as an indication <i>after</i> the vertex\n * has been added or removed, or <i>before</i> it is added. The type of the\n * event can be tested using the {@link\n * org.jgrapht.event.GraphChangeEvent#getType()} method.\n *\n * @author Barak Naveh\n * @since Aug 10, 2003\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ---------------------------\n * GraphVertexChangeEvent.java\n * ---------------------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Aug-2003 : Initial revision (BN);\n * 11-Mar-2004 : Made generic (CH);\n *\n */\npackage org.jgrapht.event;\n\n/**\n * An event which indicates that a graph vertex has changed, or is about to\n * change. The event can be used either as an indication <i>after</i> the vertex\n * has been added or removed, or <i>before</i> it is added. The type of the\n * event can be tested using the {@link\n * org.jgrapht.event.GraphChangeEvent#getType()} method.\n *\n * @author Barak Naveh\n * @since Aug 10, 2003\n */\npublic class GraphVertexChangeEvent<V>\n    extends GraphChangeEvent\n{\n    private static final long serialVersionUID = 3690189962679104053L;\n\n    /**\n     * Before vertex added event. This event is fired before a vertex is added\n     * to a graph.\n     */\n    public static final int BEFORE_VERTEX_ADDED = 11;\n\n    /**\n     * Before vertex removed event. This event is fired before a vertex is\n     * removed from a graph.\n     */\n    public static final int BEFORE_VERTEX_REMOVED = 12;\n\n    /**\n     * Vertex added event. This event is fired after a vertex is added to a\n     * graph.\n     */\n    public static final int VERTEX_ADDED = 13;\n\n    /**\n     * Vertex removed event. This event is fired after a vertex is removed from\n     * a graph.\n     */\n    public static final int VERTEX_REMOVED = 14;\n\n    /**\n     * The vertex that this event is related to.\n     */\n    protected V vertex;\n\n    /**\n     * Creates a new GraphVertexChangeEvent object.\n     *\n     * @param eventSource the source of the event.\n     * @param type the type of the event.\n     * @param vertex the vertex that the event is related to.\n     */\n    public GraphVertexChangeEvent(Object eventSource, int type, V vertex)\n    {\n        super(eventSource, type);\n        this.vertex = vertex;\n    }\n\n    /**\n     * Returns the vertex that this event is related to.\n     *\n     * @return the vertex that this event is related to.\n     */\n    public V getVertex()\n    {\n        return vertex;\n    }\n}\n\n// End GraphVertexChangeEvent.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "eventSource", "java.lang", "Object" ], [ "type", "", "int" ], [ "vertex", "", "V" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getType", "org.jgrapht.event", "GraphChangeEvent", "public int getType()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toString", "java.util", "EventObject", "public String toString()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getVertex", "org.jgrapht.event", "GraphVertexChangeEvent", "public V getVertex()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "getSource", "java.util", "EventObject", "public Object getSource()" ], [ "toString", "java.lang", "Object", "public String toString()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "vertex", "org.jgrapht.event", "GraphVertexChangeEvent", "protected V vertex;" ], [ "type", "org.jgrapht.event", "GraphChangeEvent", "protected int type;" ], [ "source", "java.util", "EventObject", "protected Object source;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 26271,
  "oracle" : "((maxPathLength != null) && (maxPathLength < 0)) == false && ((simplePathsOnly == false) && (maxPathLength == null)) == false;",
  "oracleType" : "PRE",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.alg",
  "className" : "AllDirectedPaths",
  "javadocTag" : "@param maxPathLength maximum number of edges to allow in a path (if null,\nall paths are considered, which may be very slow due to potentially huge\noutput)",
  "methodJavadoc" : "    /**\n     * Calculate (and return) all paths from the source vertices to the target\n     * vertices.\n     *\n     * @param sourceVertices the source vertices\n     * @param targetVertices the target vertices\n     * @param simplePathsOnly if true, only search simple\n     * (non-self-intersecting) paths\n     * @param maxPathLength maximum number of edges to allow in a path (if null,\n     * all paths are considered, which may be very slow due to potentially huge\n     * output)\n     *\n     * @return list of all paths from the sources to the targets containing no\n     * more than maxPathLength edges\n     */",
  "methodSourceCode" : "public List<GraphPath<V, E>> getAllPaths(Set<V> sourceVertices, Set<V> targetVertices, boolean simplePathsOnly, Integer maxPathLength){\n    if ((maxPathLength != null) && (maxPathLength < 0)) {\n        throw new IllegalArgumentException(\"maxPathLength must be non-negative if defined\");\n    }\n    if (!simplePathsOnly && (maxPathLength == null)) {\n        throw new IllegalArgumentException(\"If search is not restricted to simple paths, a maximum path length must be set to avoid infinite cycles\");\n    }\n    if ((sourceVertices.isEmpty()) || (targetVertices.isEmpty())) {\n        return new ArrayList();\n    }\n    // Decorate the edges with the minimum path lengths through them\n    Map<E, Integer> edgeMinDistancesFromTargets = edgeMinDistancesBackwards(targetVertices, maxPathLength);\n    // Generate all the paths\n    List<GraphPath<V, E>> allPaths = generatePaths(sourceVertices, targetVertices, simplePathsOnly, maxPathLength, edgeMinDistancesFromTargets);\n    return allPaths;\n}",
  "classJavadoc" : "/**\n * A Dijkstra-like algorithm to find all paths between two sets of nodes in a\n * directed graph, with options to search only simple paths and to limit the\n * path length.\n *\n * @author Andrew Gainer-Dewar\n * @since Feb, 2016\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2012, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n\n/* -------------------------\n * AllDirectedPaths.java\n * -------------------------\n * (C) Copyright 2015-2015, Vera-Licona Research Group and Contributors.\n *\n * Original Author:  Andrew Gainer-Dewar, Ph.D. (Vera-Licona Research Group)\n * Contributor(s):\n *\n * Changes\n * -------\n * Feb-2016 : Initial version;\n *\n */\npackage org.jgrapht.alg;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\nimport org.jgrapht.graph.*;\n\n\n/**\n * A Dijkstra-like algorithm to find all paths between two sets of nodes in a\n * directed graph, with options to search only simple paths and to limit the\n * path length.\n *\n * @author Andrew Gainer-Dewar\n * @since Feb, 2016\n */\n\npublic class AllDirectedPaths<V, E>\n{\n    private final DirectedGraph<V, E> graph;\n\n    public AllDirectedPaths(DirectedGraph<V, E> graph)\n    {\n        if (graph == null) {\n            throw new IllegalArgumentException(\"Graph cannot be null!\");\n        }\n\n        this.graph = graph;\n    }\n\n    /**\n     * Calculate (and return) all paths from the source vertex to the target\n     * vertex.\n     *\n     * @param sourceVertex the source vertex\n     * @param targetVertex the target vertex\n     * @param simplePathsOnly if true, only search simple\n     * (non-self-intersecting) paths\n     * @param maxPathLength maximum number of edges to allow in a path (if null,\n     * all paths are considered, which may be very slow due to potentially huge\n     * output)\n     */\n    public List<GraphPath<V, E>> getAllPaths(\n        V sourceVertex,\n        V targetVertex,\n        boolean simplePathsOnly,\n        Integer maxPathLength)\n    {\n        return getAllPaths(\n            Collections.singleton(sourceVertex),\n            Collections.singleton(targetVertex),\n            simplePathsOnly,\n            maxPathLength);\n    }\n\n    /**\n     * Calculate (and return) all paths from the source vertices to the target\n     * vertices.\n     *\n     * @param sourceVertices the source vertices\n     * @param targetVertices the target vertices\n     * @param simplePathsOnly if true, only search simple\n     * (non-self-intersecting) paths\n     * @param maxPathLength maximum number of edges to allow in a path (if null,\n     * all paths are considered, which may be very slow due to potentially huge\n     * output)\n     *\n     * @return list of all paths from the sources to the targets containing no\n     * more than maxPathLength edges\n     */\n    public List<GraphPath<V, E>> getAllPaths(\n        Set<V> sourceVertices,\n        Set<V> targetVertices,\n        boolean simplePathsOnly,\n        Integer maxPathLength)\n    {\n        if ((maxPathLength != null) && (maxPathLength < 0)) {\n            throw new IllegalArgumentException(\n                \"maxPathLength must be non-negative if defined\");\n        }\n\n        if (!simplePathsOnly && (maxPathLength == null)) {\n            throw new IllegalArgumentException(\n                \"If search is not restricted to simple paths, a maximum path length must be set to avoid infinite cycles\");\n        }\n\n        if ((sourceVertices.isEmpty()) || (targetVertices.isEmpty())) {\n            return new ArrayList();\n        }\n\n        // Decorate the edges with the minimum path lengths through them\n        Map<E, Integer> edgeMinDistancesFromTargets =\n            edgeMinDistancesBackwards(targetVertices, maxPathLength);\n\n        // Generate all the paths\n        List<GraphPath<V, E>> allPaths =\n            generatePaths(\n                sourceVertices,\n                targetVertices,\n                simplePathsOnly,\n                maxPathLength,\n                edgeMinDistancesFromTargets);\n\n        return allPaths;\n    }\n\n    /**\n     * Compute the minimum number of edges in a path to the targets through each\n     * edge, so long as it is not greater than a bound.\n     *\n     * @param targetVertices the target vertices\n     * @param maxPathLength maximum number of edges to allow in a path (if null,\n     * all edges will be considered, which may be expensive)\n     *\n     * @return the minimum number of edges in a path from each edge to the\n     * targets, encoded in a Map\n     */\n    private Map<E, Integer> edgeMinDistancesBackwards(\n        Set<V> targetVertices,\n        Integer maxPathLength)\n    {\n        /*\n         * We walk backwards through the network from the target\n         * vertices, marking edges and vertices with their minimum\n         * distances as we go.\n         */\n        Map<E, Integer> edgeMinDistances = new HashMap();\n        Map<V, Integer> vertexMinDistances = new HashMap();\n        Queue<V> verticesToProcess = new LinkedList();\n\n        // Input sanity checking\n        if (maxPathLength != null) {\n            if (maxPathLength < 0) {\n                throw new IllegalArgumentException(\n                    \"maxPathLength must be non-negative if defined\");\n            }\n            if (maxPathLength == 0) {\n                return edgeMinDistances;\n            }\n        }\n\n        // Bootstrap the process with the target vertices\n        for (V target : targetVertices) {\n            vertexMinDistances.put(target, 0);\n            verticesToProcess.add(target);\n        }\n\n        // Work through the node queue. When it's empty, we're done!\n        for (V vertex; (vertex = verticesToProcess.poll()) != null;) {\n            assert vertexMinDistances.containsKey(vertex);\n\n            Integer childDistance = vertexMinDistances.get(vertex) + 1;\n\n            // Check whether the incoming edges of this node are correctly\n            // decorated\n            for (E edge : graph.incomingEdgesOf(vertex)) {\n                // Mark the edge if needed\n                if (!edgeMinDistances.containsKey(edge)\n                    || (edgeMinDistances.get(edge) > childDistance))\n                {\n                    edgeMinDistances.put(edge, childDistance);\n                }\n\n                // Mark the edge's source vertex if needed\n                V edgeSource = graph.getEdgeSource(edge);\n                if (!vertexMinDistances.containsKey(edgeSource)\n                    || (vertexMinDistances.get(edgeSource) > childDistance))\n                {\n                    vertexMinDistances.put(edgeSource, childDistance);\n\n                    if ((maxPathLength == null)\n                        || (childDistance < maxPathLength))\n                    {\n                        verticesToProcess.add(edgeSource);\n                    }\n                }\n            }\n        }\n\n        assert verticesToProcess.isEmpty();\n        return edgeMinDistances;\n    }\n\n    /**\n     * Generate all paths from the sources to the targets, using pre-computed\n     * minimum distances.\n     *\n     * @param sourceVertices the source vertices\n     * @param targetVertices the target vertices\n     * @param maxPathLength maximum number of edges to allow in a path\n     * @param simplePathsOnly if true, only search simple\n     * (non-self-intersecting) paths (if null, all edges will be considered,\n     * which may be expensive)\n     * @param edgeMinDistancesFromTargets the minimum number of edges in a path\n     * to a target through each edge, as computed by {@code\n     * edgeMinDistancesBackwards}.\n     *\n     * @return a List of all GraphPaths from the sources to the targets\n     * satisfying the given constraints\n     */\n    private List<GraphPath<V, E>> generatePaths(\n        Set<V> sourceVertices,\n        Set<V> targetVertices,\n        boolean simplePathsOnly,\n        Integer maxPathLength,\n        Map<E, Integer> edgeMinDistancesFromTargets)\n    {\n        /*\n         * We walk forwards through the network from the source\n         * vertices, exploring all outgoing edges whose minimum\n         * distances is small enough.\n         */\n        List<GraphPath<V, E>> completePaths = new ArrayList();\n        Deque<List<E>> incompletePaths = new LinkedList();\n\n        // Input sanity checking\n        if (maxPathLength != null) {\n            if (maxPathLength < 0) {\n                throw new IllegalArgumentException(\n                    \"maxPathLength must be non-negative if defined\");\n            }\n            if (maxPathLength == 0) {\n                return completePaths;\n            }\n        }\n\n        // Bootstrap the search with the source vertices\n        for (V source : sourceVertices) {\n            for (E edge : graph.outgoingEdgesOf(source)) {\n                assert graph.getEdgeSource(edge).equals(source);\n\n                if (edgeMinDistancesFromTargets.containsKey(edge)) {\n                    List<E> path = Arrays.asList(edge);\n                    incompletePaths.add(path);\n                }\n            }\n        }\n\n        // Walk through the queue of incomplete paths\n        for (\n            List<E> incompletePath;\n            (incompletePath = incompletePaths.poll()) != null;)\n        {\n            Integer lengthSoFar = incompletePath.size();\n            assert (maxPathLength == null) || (lengthSoFar < maxPathLength);\n\n            E leafEdge = incompletePath.get(lengthSoFar - 1);\n            V leafNode = graph.getEdgeTarget(leafEdge);\n\n            Set<V> pathVertices = new HashSet();\n            for (E pathEdge : incompletePath) {\n                pathVertices.add(graph.getEdgeSource(pathEdge));\n                pathVertices.add(graph.getEdgeTarget(pathEdge));\n            }\n\n            for (E outEdge : graph.outgoingEdgesOf(leafNode)) {\n                // Proceed if the outgoing edge is marked and the mark\n                // is sufficiently small\n                if (edgeMinDistancesFromTargets.containsKey(outEdge)\n                    && ((maxPathLength == null)\n                        || ((edgeMinDistancesFromTargets.get(outEdge)\n                                + lengthSoFar) <= maxPathLength)))\n                {\n                    List<E> newPath = new ArrayList(incompletePath);\n                    newPath.add(outEdge);\n\n                    // If requested, make sure this path isn't self-intersecting\n                    if (simplePathsOnly\n                        && pathVertices.contains(\n                            graph.getEdgeTarget(outEdge)))\n                    {\n                        continue;\n                    }\n\n                    // If this path reaches a target, add it to completePaths\n                    if (targetVertices.contains(graph.getEdgeTarget(outEdge))) {\n                        GraphPath<V, E> completePath = makePath(newPath);\n                        assert sourceVertices.contains(\n                            completePath.getStartVertex());\n                        assert targetVertices.contains(\n                            completePath.getEndVertex());\n                        assert (maxPathLength == null)\n                            || (completePath.getWeight() <= maxPathLength);\n                        completePaths.add(completePath);\n                    }\n\n                    // If this path is short enough, consider further\n                    // extensions of it\n                    if ((maxPathLength == null)\n                        || (newPath.size() < maxPathLength))\n                    {\n                        incompletePaths.addFirst(newPath); // We use\n                                                           // incompletePaths in\n                                                           // FIFO mode to avoid\n                                                           // memory blowup\n                    }\n                }\n            }\n        }\n\n        assert incompletePaths.isEmpty();\n        return completePaths;\n    }\n\n    /**\n     * Transform an ordered list of edges into a GraphPath\n     *\n     * @param edges the edges\n     *\n     * @return the corresponding GraphPath\n     */\n    private GraphPath<V, E> makePath(List<E> edges)\n    {\n        V source = graph.getEdgeSource(edges.get(0));\n        V target = graph.getEdgeTarget(edges.get(edges.size() - 1));\n        double weight = edges.size();\n        return new GraphPathImpl<V, E>(graph, source, target, edges, weight);\n    }\n}\n\n// End AllDirectedPaths.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "sourceVertices", "java.util.Set", "Set<V>" ], [ "targetVertices", "java.util.Set", "Set<V>" ], [ "simplePathsOnly", "", "boolean" ], [ "maxPathLength", "java.lang", "Integer" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getAllPaths", "org.jgrapht.alg", "AllDirectedPaths", "public List<GraphPath<V, E>> getAllPaths(Set<V> sourceVertices, Set<V> targetVertices, boolean simplePathsOnly, Integer maxPathLength)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getAllPaths", "org.jgrapht.alg", "AllDirectedPaths", "public List<GraphPath<V, E>> getAllPaths(V sourceVertex, V targetVertex, boolean simplePathsOnly, Integer maxPathLength)" ], [ "equals", "java.util", "Set", "public abstract boolean equals(Object arg0)" ], [ "size", "java.util", "Set", "public abstract int size()" ], [ "removeAll", "java.util", "Set", "public abstract boolean removeAll(Collection<? extends Object> arg0)" ], [ "remove", "java.util", "Set", "public abstract boolean remove(Object arg0)" ], [ "toArray", "java.util", "Set", "public abstract <T> T[] toArray(T[] arg0)" ], [ "toArray", "java.util", "Set", "public abstract Object[] toArray()" ], [ "iterator", "java.util", "Set", "public abstract Iterator<E> iterator()" ], [ "contains", "java.util", "Set", "public abstract boolean contains(Object arg0)" ], [ "retainAll", "java.util", "Set", "public abstract boolean retainAll(Collection<? extends Object> arg0)" ], [ "add", "java.util", "Set", "public abstract boolean add(E arg0)" ], [ "addAll", "java.util", "Set", "public abstract boolean addAll(Collection<? extends E> arg0)" ], [ "spliterator", "java.util", "Set", "public default Spliterator<E> spliterator()" ], [ "hashCode", "java.util", "Set", "public abstract int hashCode()" ], [ "isEmpty", "java.util", "Set", "public abstract boolean isEmpty()" ], [ "containsAll", "java.util", "Set", "public abstract boolean containsAll(Collection<? extends Object> arg0)" ], [ "toArray", "java.util", "Collection", "public abstract Object[] toArray()" ], [ "toArray", "java.util", "Collection", "public abstract <T> T[] toArray(T[] arg0)" ], [ "removeIf", "java.util", "Collection", "public default boolean removeIf(Predicate<? super E> arg0)" ], [ "iterator", "java.util", "Collection", "public abstract Iterator<E> iterator()" ], [ "add", "java.util", "Collection", "public abstract boolean add(E arg0)" ], [ "containsAll", "java.util", "Collection", "public abstract boolean containsAll(Collection<? extends Object> arg0)" ], [ "parallelStream", "java.util", "Collection", "public default Stream<E> parallelStream()" ], [ "equals", "java.util", "Collection", "public abstract boolean equals(Object arg0)" ], [ "size", "java.util", "Collection", "public abstract int size()" ], [ "contains", "java.util", "Collection", "public abstract boolean contains(Object arg0)" ], [ "retainAll", "java.util", "Collection", "public abstract boolean retainAll(Collection<? extends Object> arg0)" ], [ "toArray", "java.util", "Collection", "public default <T> T[] toArray(IntFunction<T[]> arg0)" ], [ "addAll", "java.util", "Collection", "public abstract boolean addAll(Collection<? extends E> arg0)" ], [ "removeAll", "java.util", "Collection", "public abstract boolean removeAll(Collection<? extends Object> arg0)" ], [ "stream", "java.util", "Collection", "public default Stream<E> stream()" ], [ "spliterator", "java.util", "Collection", "public default Spliterator<E> spliterator()" ], [ "hashCode", "java.util", "Collection", "public abstract int hashCode()" ], [ "remove", "java.util", "Collection", "public abstract boolean remove(Object arg0)" ], [ "isEmpty", "java.util", "Collection", "public abstract boolean isEmpty()" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "longValue", "java.lang", "Integer", "public long longValue()" ], [ "describeConstable", "java.lang", "Integer", "public Optional<Integer> describeConstable()" ], [ "doubleValue", "java.lang", "Integer", "public double doubleValue()" ], [ "compareTo", "java.lang", "Integer", "public int compareTo(Integer arg0)" ], [ "byteValue", "java.lang", "Integer", "public byte byteValue()" ], [ "shortValue", "java.lang", "Integer", "public short shortValue()" ], [ "toString", "java.lang", "Integer", "public String toString()" ], [ "floatValue", "java.lang", "Integer", "public float floatValue()" ], [ "intValue", "java.lang", "Integer", "public int intValue()" ], [ "resolveConstantDesc", "java.lang", "Integer", "public Integer resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "hashCode", "java.lang", "Integer", "public int hashCode()" ], [ "equals", "java.lang", "Integer", "public boolean equals(Object arg0)" ], [ "floatValue", "java.lang", "Number", "public abstract float floatValue()" ], [ "byteValue", "java.lang", "Number", "public byte byteValue()" ], [ "longValue", "java.lang", "Number", "public abstract long longValue()" ], [ "doubleValue", "java.lang", "Number", "public abstract double doubleValue()" ], [ "intValue", "java.lang", "Number", "public abstract int intValue()" ], [ "shortValue", "java.lang", "Number", "public short shortValue()" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ], [ "addAll", "java.util", "List", "public abstract boolean addAll(Collection<? extends E> arg0)" ], [ "indexOf", "java.util", "List", "public abstract int indexOf(Object arg0)" ], [ "toArray", "java.util", "List", "public abstract <T> T[] toArray(T[] arg0)" ], [ "retainAll", "java.util", "List", "public abstract boolean retainAll(Collection<? extends Object> arg0)" ], [ "listIterator", "java.util", "List", "public abstract ListIterator<E> listIterator()" ], [ "add", "java.util", "List", "public abstract boolean add(E arg0)" ], [ "iterator", "java.util", "List", "public abstract Iterator<E> iterator()" ], [ "listIterator", "java.util", "List", "public abstract ListIterator<E> listIterator(int arg0)" ], [ "lastIndexOf", "java.util", "List", "public abstract int lastIndexOf(Object arg0)" ], [ "equals", "java.util", "List", "public abstract boolean equals(Object arg0)" ], [ "toArray", "java.util", "List", "public abstract Object[] toArray()" ], [ "isEmpty", "java.util", "List", "public abstract boolean isEmpty()" ], [ "size", "java.util", "List", "public abstract int size()" ], [ "spliterator", "java.util", "List", "public default Spliterator<E> spliterator()" ], [ "subList", "java.util", "List", "public abstract List<E> subList(int arg0, int arg1)" ], [ "addAll", "java.util", "List", "public abstract boolean addAll(int arg0, Collection<? extends E> arg1)" ], [ "get", "java.util", "List", "public abstract E get(int arg0)" ], [ "contains", "java.util", "List", "public abstract boolean contains(Object arg0)" ], [ "remove", "java.util", "List", "public abstract E remove(int arg0)" ], [ "hashCode", "java.util", "List", "public abstract int hashCode()" ], [ "containsAll", "java.util", "List", "public abstract boolean containsAll(Collection<? extends Object> arg0)" ], [ "remove", "java.util", "List", "public abstract boolean remove(Object arg0)" ], [ "set", "java.util", "List", "public abstract E set(int arg0, E arg1)" ], [ "removeAll", "java.util", "List", "public abstract boolean removeAll(Collection<? extends Object> arg0)" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 26276,
  "oracle" : ";",
  "oracleType" : "PRE",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.alg",
  "className" : "AllDirectedPaths",
  "javadocTag" : "@param sourceVertices the source vertices",
  "methodJavadoc" : "    /**\n     * Generate all paths from the sources to the targets, using pre-computed\n     * minimum distances.\n     *\n     * @param sourceVertices the source vertices\n     * @param targetVertices the target vertices\n     * @param maxPathLength maximum number of edges to allow in a path\n     * @param simplePathsOnly if true, only search simple\n     * (non-self-intersecting) paths (if null, all edges will be considered,\n     * which may be expensive)\n     * @param edgeMinDistancesFromTargets the minimum number of edges in a path\n     * to a target through each edge, as computed by {@code\n     * edgeMinDistancesBackwards}.\n     *\n     * @return a List of all GraphPaths from the sources to the targets\n     * satisfying the given constraints\n     */",
  "methodSourceCode" : "private List<GraphPath<V, E>> generatePaths(Set<V> sourceVertices, Set<V> targetVertices, boolean simplePathsOnly, Integer maxPathLength, Map<E, Integer> edgeMinDistancesFromTargets){\n    /*\n         * We walk forwards through the network from the source\n         * vertices, exploring all outgoing edges whose minimum\n         * distances is small enough.\n         */\n    List<GraphPath<V, E>> completePaths = new ArrayList();\n    Deque<List<E>> incompletePaths = new LinkedList();\n    // Input sanity checking\n    if (maxPathLength != null) {\n        if (maxPathLength < 0) {\n            throw new IllegalArgumentException(\"maxPathLength must be non-negative if defined\");\n        }\n        if (maxPathLength == 0) {\n            return completePaths;\n        }\n    }\n    // Bootstrap the search with the source vertices\n    for (V source : sourceVertices) {\n        for (E edge : graph.outgoingEdgesOf(source)) {\n            assert graph.getEdgeSource(edge).equals(source);\n            if (edgeMinDistancesFromTargets.containsKey(edge)) {\n                List<E> path = Arrays.asList(edge);\n                incompletePaths.add(path);\n            }\n        }\n    }\n    // Walk through the queue of incomplete paths\n    for (List<E> incompletePath; (incompletePath = incompletePaths.poll()) != null; ) {\n        Integer lengthSoFar = incompletePath.size();\n        assert (maxPathLength == null) || (lengthSoFar < maxPathLength);\n        E leafEdge = incompletePath.get(lengthSoFar - 1);\n        V leafNode = graph.getEdgeTarget(leafEdge);\n        Set<V> pathVertices = new HashSet();\n        for (E pathEdge : incompletePath) {\n            pathVertices.add(graph.getEdgeSource(pathEdge));\n            pathVertices.add(graph.getEdgeTarget(pathEdge));\n        }\n        for (E outEdge : graph.outgoingEdgesOf(leafNode)) {\n            // Proceed if the outgoing edge is marked and the mark\n            // is sufficiently small\n            if (edgeMinDistancesFromTargets.containsKey(outEdge) && ((maxPathLength == null) || ((edgeMinDistancesFromTargets.get(outEdge) + lengthSoFar) <= maxPathLength))) {\n                List<E> newPath = new ArrayList(incompletePath);\n                newPath.add(outEdge);\n                // If requested, make sure this path isn't self-intersecting\n                if (simplePathsOnly && pathVertices.contains(graph.getEdgeTarget(outEdge))) {\n                    continue;\n                }\n                // If this path reaches a target, add it to completePaths\n                if (targetVertices.contains(graph.getEdgeTarget(outEdge))) {\n                    GraphPath<V, E> completePath = makePath(newPath);\n                    assert sourceVertices.contains(completePath.getStartVertex());\n                    assert targetVertices.contains(completePath.getEndVertex());\n                    assert (maxPathLength == null) || (completePath.getWeight() <= maxPathLength);\n                    completePaths.add(completePath);\n                }\n                // If this path is short enough, consider further\n                // extensions of it\n                if ((maxPathLength == null) || (newPath.size() < maxPathLength)) {\n                    // We use\n                    incompletePaths.addFirst(newPath);\n                    // incompletePaths in\n                    // FIFO mode to avoid\n                    // memory blowup\n                }\n            }\n        }\n    }\n    assert incompletePaths.isEmpty();\n    return completePaths;\n}",
  "classJavadoc" : "/**\n * A Dijkstra-like algorithm to find all paths between two sets of nodes in a\n * directed graph, with options to search only simple paths and to limit the\n * path length.\n *\n * @author Andrew Gainer-Dewar\n * @since Feb, 2016\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2012, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n\n/* -------------------------\n * AllDirectedPaths.java\n * -------------------------\n * (C) Copyright 2015-2015, Vera-Licona Research Group and Contributors.\n *\n * Original Author:  Andrew Gainer-Dewar, Ph.D. (Vera-Licona Research Group)\n * Contributor(s):\n *\n * Changes\n * -------\n * Feb-2016 : Initial version;\n *\n */\npackage org.jgrapht.alg;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\nimport org.jgrapht.graph.*;\n\n\n/**\n * A Dijkstra-like algorithm to find all paths between two sets of nodes in a\n * directed graph, with options to search only simple paths and to limit the\n * path length.\n *\n * @author Andrew Gainer-Dewar\n * @since Feb, 2016\n */\n\npublic class AllDirectedPaths<V, E>\n{\n    private final DirectedGraph<V, E> graph;\n\n    public AllDirectedPaths(DirectedGraph<V, E> graph)\n    {\n        if (graph == null) {\n            throw new IllegalArgumentException(\"Graph cannot be null!\");\n        }\n\n        this.graph = graph;\n    }\n\n    /**\n     * Calculate (and return) all paths from the source vertex to the target\n     * vertex.\n     *\n     * @param sourceVertex the source vertex\n     * @param targetVertex the target vertex\n     * @param simplePathsOnly if true, only search simple\n     * (non-self-intersecting) paths\n     * @param maxPathLength maximum number of edges to allow in a path (if null,\n     * all paths are considered, which may be very slow due to potentially huge\n     * output)\n     */\n    public List<GraphPath<V, E>> getAllPaths(\n        V sourceVertex,\n        V targetVertex,\n        boolean simplePathsOnly,\n        Integer maxPathLength)\n    {\n        return getAllPaths(\n            Collections.singleton(sourceVertex),\n            Collections.singleton(targetVertex),\n            simplePathsOnly,\n            maxPathLength);\n    }\n\n    /**\n     * Calculate (and return) all paths from the source vertices to the target\n     * vertices.\n     *\n     * @param sourceVertices the source vertices\n     * @param targetVertices the target vertices\n     * @param simplePathsOnly if true, only search simple\n     * (non-self-intersecting) paths\n     * @param maxPathLength maximum number of edges to allow in a path (if null,\n     * all paths are considered, which may be very slow due to potentially huge\n     * output)\n     *\n     * @return list of all paths from the sources to the targets containing no\n     * more than maxPathLength edges\n     */\n    public List<GraphPath<V, E>> getAllPaths(\n        Set<V> sourceVertices,\n        Set<V> targetVertices,\n        boolean simplePathsOnly,\n        Integer maxPathLength)\n    {\n        if ((maxPathLength != null) && (maxPathLength < 0)) {\n            throw new IllegalArgumentException(\n                \"maxPathLength must be non-negative if defined\");\n        }\n\n        if (!simplePathsOnly && (maxPathLength == null)) {\n            throw new IllegalArgumentException(\n                \"If search is not restricted to simple paths, a maximum path length must be set to avoid infinite cycles\");\n        }\n\n        if ((sourceVertices.isEmpty()) || (targetVertices.isEmpty())) {\n            return new ArrayList();\n        }\n\n        // Decorate the edges with the minimum path lengths through them\n        Map<E, Integer> edgeMinDistancesFromTargets =\n            edgeMinDistancesBackwards(targetVertices, maxPathLength);\n\n        // Generate all the paths\n        List<GraphPath<V, E>> allPaths =\n            generatePaths(\n                sourceVertices,\n                targetVertices,\n                simplePathsOnly,\n                maxPathLength,\n                edgeMinDistancesFromTargets);\n\n        return allPaths;\n    }\n\n    /**\n     * Compute the minimum number of edges in a path to the targets through each\n     * edge, so long as it is not greater than a bound.\n     *\n     * @param targetVertices the target vertices\n     * @param maxPathLength maximum number of edges to allow in a path (if null,\n     * all edges will be considered, which may be expensive)\n     *\n     * @return the minimum number of edges in a path from each edge to the\n     * targets, encoded in a Map\n     */\n    private Map<E, Integer> edgeMinDistancesBackwards(\n        Set<V> targetVertices,\n        Integer maxPathLength)\n    {\n        /*\n         * We walk backwards through the network from the target\n         * vertices, marking edges and vertices with their minimum\n         * distances as we go.\n         */\n        Map<E, Integer> edgeMinDistances = new HashMap();\n        Map<V, Integer> vertexMinDistances = new HashMap();\n        Queue<V> verticesToProcess = new LinkedList();\n\n        // Input sanity checking\n        if (maxPathLength != null) {\n            if (maxPathLength < 0) {\n                throw new IllegalArgumentException(\n                    \"maxPathLength must be non-negative if defined\");\n            }\n            if (maxPathLength == 0) {\n                return edgeMinDistances;\n            }\n        }\n\n        // Bootstrap the process with the target vertices\n        for (V target : targetVertices) {\n            vertexMinDistances.put(target, 0);\n            verticesToProcess.add(target);\n        }\n\n        // Work through the node queue. When it's empty, we're done!\n        for (V vertex; (vertex = verticesToProcess.poll()) != null;) {\n            assert vertexMinDistances.containsKey(vertex);\n\n            Integer childDistance = vertexMinDistances.get(vertex) + 1;\n\n            // Check whether the incoming edges of this node are correctly\n            // decorated\n            for (E edge : graph.incomingEdgesOf(vertex)) {\n                // Mark the edge if needed\n                if (!edgeMinDistances.containsKey(edge)\n                    || (edgeMinDistances.get(edge) > childDistance))\n                {\n                    edgeMinDistances.put(edge, childDistance);\n                }\n\n                // Mark the edge's source vertex if needed\n                V edgeSource = graph.getEdgeSource(edge);\n                if (!vertexMinDistances.containsKey(edgeSource)\n                    || (vertexMinDistances.get(edgeSource) > childDistance))\n                {\n                    vertexMinDistances.put(edgeSource, childDistance);\n\n                    if ((maxPathLength == null)\n                        || (childDistance < maxPathLength))\n                    {\n                        verticesToProcess.add(edgeSource);\n                    }\n                }\n            }\n        }\n\n        assert verticesToProcess.isEmpty();\n        return edgeMinDistances;\n    }\n\n    /**\n     * Generate all paths from the sources to the targets, using pre-computed\n     * minimum distances.\n     *\n     * @param sourceVertices the source vertices\n     * @param targetVertices the target vertices\n     * @param maxPathLength maximum number of edges to allow in a path\n     * @param simplePathsOnly if true, only search simple\n     * (non-self-intersecting) paths (if null, all edges will be considered,\n     * which may be expensive)\n     * @param edgeMinDistancesFromTargets the minimum number of edges in a path\n     * to a target through each edge, as computed by {@code\n     * edgeMinDistancesBackwards}.\n     *\n     * @return a List of all GraphPaths from the sources to the targets\n     * satisfying the given constraints\n     */\n    private List<GraphPath<V, E>> generatePaths(\n        Set<V> sourceVertices,\n        Set<V> targetVertices,\n        boolean simplePathsOnly,\n        Integer maxPathLength,\n        Map<E, Integer> edgeMinDistancesFromTargets)\n    {\n        /*\n         * We walk forwards through the network from the source\n         * vertices, exploring all outgoing edges whose minimum\n         * distances is small enough.\n         */\n        List<GraphPath<V, E>> completePaths = new ArrayList();\n        Deque<List<E>> incompletePaths = new LinkedList();\n\n        // Input sanity checking\n        if (maxPathLength != null) {\n            if (maxPathLength < 0) {\n                throw new IllegalArgumentException(\n                    \"maxPathLength must be non-negative if defined\");\n            }\n            if (maxPathLength == 0) {\n                return completePaths;\n            }\n        }\n\n        // Bootstrap the search with the source vertices\n        for (V source : sourceVertices) {\n            for (E edge : graph.outgoingEdgesOf(source)) {\n                assert graph.getEdgeSource(edge).equals(source);\n\n                if (edgeMinDistancesFromTargets.containsKey(edge)) {\n                    List<E> path = Arrays.asList(edge);\n                    incompletePaths.add(path);\n                }\n            }\n        }\n\n        // Walk through the queue of incomplete paths\n        for (\n            List<E> incompletePath;\n            (incompletePath = incompletePaths.poll()) != null;)\n        {\n            Integer lengthSoFar = incompletePath.size();\n            assert (maxPathLength == null) || (lengthSoFar < maxPathLength);\n\n            E leafEdge = incompletePath.get(lengthSoFar - 1);\n            V leafNode = graph.getEdgeTarget(leafEdge);\n\n            Set<V> pathVertices = new HashSet();\n            for (E pathEdge : incompletePath) {\n                pathVertices.add(graph.getEdgeSource(pathEdge));\n                pathVertices.add(graph.getEdgeTarget(pathEdge));\n            }\n\n            for (E outEdge : graph.outgoingEdgesOf(leafNode)) {\n                // Proceed if the outgoing edge is marked and the mark\n                // is sufficiently small\n                if (edgeMinDistancesFromTargets.containsKey(outEdge)\n                    && ((maxPathLength == null)\n                        || ((edgeMinDistancesFromTargets.get(outEdge)\n                                + lengthSoFar) <= maxPathLength)))\n                {\n                    List<E> newPath = new ArrayList(incompletePath);\n                    newPath.add(outEdge);\n\n                    // If requested, make sure this path isn't self-intersecting\n                    if (simplePathsOnly\n                        && pathVertices.contains(\n                            graph.getEdgeTarget(outEdge)))\n                    {\n                        continue;\n                    }\n\n                    // If this path reaches a target, add it to completePaths\n                    if (targetVertices.contains(graph.getEdgeTarget(outEdge))) {\n                        GraphPath<V, E> completePath = makePath(newPath);\n                        assert sourceVertices.contains(\n                            completePath.getStartVertex());\n                        assert targetVertices.contains(\n                            completePath.getEndVertex());\n                        assert (maxPathLength == null)\n                            || (completePath.getWeight() <= maxPathLength);\n                        completePaths.add(completePath);\n                    }\n\n                    // If this path is short enough, consider further\n                    // extensions of it\n                    if ((maxPathLength == null)\n                        || (newPath.size() < maxPathLength))\n                    {\n                        incompletePaths.addFirst(newPath); // We use\n                                                           // incompletePaths in\n                                                           // FIFO mode to avoid\n                                                           // memory blowup\n                    }\n                }\n            }\n        }\n\n        assert incompletePaths.isEmpty();\n        return completePaths;\n    }\n\n    /**\n     * Transform an ordered list of edges into a GraphPath\n     *\n     * @param edges the edges\n     *\n     * @return the corresponding GraphPath\n     */\n    private GraphPath<V, E> makePath(List<E> edges)\n    {\n        V source = graph.getEdgeSource(edges.get(0));\n        V target = graph.getEdgeTarget(edges.get(edges.size() - 1));\n        double weight = edges.size();\n        return new GraphPathImpl<V, E>(graph, source, target, edges, weight);\n    }\n}\n\n// End AllDirectedPaths.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "sourceVertices", "java.util.Set", "Set<V>" ], [ "targetVertices", "java.util.Set", "Set<V>" ], [ "simplePathsOnly", "", "boolean" ], [ "maxPathLength", "java.lang", "Integer" ], [ "edgeMinDistancesFromTargets", "java.util.Map", "Map<E, Integer>" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getAllPaths", "org.jgrapht.alg", "AllDirectedPaths", "public List<GraphPath<V, E>> getAllPaths(Set<V> sourceVertices, Set<V> targetVertices, boolean simplePathsOnly, Integer maxPathLength)" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getAllPaths", "org.jgrapht.alg", "AllDirectedPaths", "public List<GraphPath<V, E>> getAllPaths(V sourceVertex, V targetVertex, boolean simplePathsOnly, Integer maxPathLength)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "iterator", "java.util", "Set", "public abstract Iterator<E> iterator()" ], [ "contains", "java.util", "Set", "public abstract boolean contains(Object arg0)" ], [ "containsAll", "java.util", "Set", "public abstract boolean containsAll(Collection<? extends Object> arg0)" ], [ "addAll", "java.util", "Set", "public abstract boolean addAll(Collection<? extends E> arg0)" ], [ "size", "java.util", "Set", "public abstract int size()" ], [ "add", "java.util", "Set", "public abstract boolean add(E arg0)" ], [ "removeAll", "java.util", "Set", "public abstract boolean removeAll(Collection<? extends Object> arg0)" ], [ "hashCode", "java.util", "Set", "public abstract int hashCode()" ], [ "toArray", "java.util", "Set", "public abstract <T> T[] toArray(T[] arg0)" ], [ "retainAll", "java.util", "Set", "public abstract boolean retainAll(Collection<? extends Object> arg0)" ], [ "toArray", "java.util", "Set", "public abstract Object[] toArray()" ], [ "isEmpty", "java.util", "Set", "public abstract boolean isEmpty()" ], [ "equals", "java.util", "Set", "public abstract boolean equals(Object arg0)" ], [ "remove", "java.util", "Set", "public abstract boolean remove(Object arg0)" ], [ "spliterator", "java.util", "Set", "public default Spliterator<E> spliterator()" ], [ "toArray", "java.util", "Collection", "public abstract Object[] toArray()" ], [ "add", "java.util", "Collection", "public abstract boolean add(E arg0)" ], [ "parallelStream", "java.util", "Collection", "public default Stream<E> parallelStream()" ], [ "spliterator", "java.util", "Collection", "public default Spliterator<E> spliterator()" ], [ "iterator", "java.util", "Collection", "public abstract Iterator<E> iterator()" ], [ "addAll", "java.util", "Collection", "public abstract boolean addAll(Collection<? extends E> arg0)" ], [ "removeAll", "java.util", "Collection", "public abstract boolean removeAll(Collection<? extends Object> arg0)" ], [ "containsAll", "java.util", "Collection", "public abstract boolean containsAll(Collection<? extends Object> arg0)" ], [ "isEmpty", "java.util", "Collection", "public abstract boolean isEmpty()" ], [ "contains", "java.util", "Collection", "public abstract boolean contains(Object arg0)" ], [ "hashCode", "java.util", "Collection", "public abstract int hashCode()" ], [ "remove", "java.util", "Collection", "public abstract boolean remove(Object arg0)" ], [ "equals", "java.util", "Collection", "public abstract boolean equals(Object arg0)" ], [ "size", "java.util", "Collection", "public abstract int size()" ], [ "stream", "java.util", "Collection", "public default Stream<E> stream()" ], [ "retainAll", "java.util", "Collection", "public abstract boolean retainAll(Collection<? extends Object> arg0)" ], [ "toArray", "java.util", "Collection", "public abstract <T> T[] toArray(T[] arg0)" ], [ "toArray", "java.util", "Collection", "public default <T> T[] toArray(IntFunction<T[]> arg0)" ], [ "removeIf", "java.util", "Collection", "public default boolean removeIf(Predicate<? super E> arg0)" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "compareTo", "java.lang", "Integer", "public int compareTo(Integer arg0)" ], [ "byteValue", "java.lang", "Integer", "public byte byteValue()" ], [ "resolveConstantDesc", "java.lang", "Integer", "public Integer resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "intValue", "java.lang", "Integer", "public int intValue()" ], [ "equals", "java.lang", "Integer", "public boolean equals(Object arg0)" ], [ "shortValue", "java.lang", "Integer", "public short shortValue()" ], [ "toString", "java.lang", "Integer", "public String toString()" ], [ "doubleValue", "java.lang", "Integer", "public double doubleValue()" ], [ "longValue", "java.lang", "Integer", "public long longValue()" ], [ "hashCode", "java.lang", "Integer", "public int hashCode()" ], [ "floatValue", "java.lang", "Integer", "public float floatValue()" ], [ "describeConstable", "java.lang", "Integer", "public Optional<Integer> describeConstable()" ], [ "shortValue", "java.lang", "Number", "public short shortValue()" ], [ "floatValue", "java.lang", "Number", "public abstract float floatValue()" ], [ "intValue", "java.lang", "Number", "public abstract int intValue()" ], [ "doubleValue", "java.lang", "Number", "public abstract double doubleValue()" ], [ "byteValue", "java.lang", "Number", "public byte byteValue()" ], [ "longValue", "java.lang", "Number", "public abstract long longValue()" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ], [ "put", "java.util", "Map", "public abstract V put(K arg0, V arg1)" ], [ "isEmpty", "java.util", "Map", "public abstract boolean isEmpty()" ], [ "values", "java.util", "Map", "public abstract Collection<V> values()" ], [ "computeIfAbsent", "java.util", "Map", "public default V computeIfAbsent(K arg0, Function<? super K, ? extends V> arg1)" ], [ "remove", "java.util", "Map", "public abstract V remove(Object arg0)" ], [ "computeIfPresent", "java.util", "Map", "public default V computeIfPresent(K arg0, BiFunction<? super K, ? super V, ? extends V> arg1)" ], [ "containsKey", "java.util", "Map", "public abstract boolean containsKey(Object arg0)" ], [ "size", "java.util", "Map", "public abstract int size()" ], [ "getOrDefault", "java.util", "Map", "public default V getOrDefault(Object arg0, V arg1)" ], [ "putIfAbsent", "java.util", "Map", "public default V putIfAbsent(K arg0, V arg1)" ], [ "containsValue", "java.util", "Map", "public abstract boolean containsValue(Object arg0)" ], [ "equals", "java.util", "Map", "public abstract boolean equals(Object arg0)" ], [ "replace", "java.util", "Map", "public default V replace(K arg0, V arg1)" ], [ "compute", "java.util", "Map", "public default V compute(K arg0, BiFunction<? super K, ? super V, ? extends V> arg1)" ], [ "merge", "java.util", "Map", "public default V merge(K arg0, V arg1, BiFunction<? super V, ? super V, ? extends V> arg2)" ], [ "get", "java.util", "Map", "public abstract V get(Object arg0)" ], [ "keySet", "java.util", "Map", "public abstract Set<K> keySet()" ], [ "hashCode", "java.util", "Map", "public abstract int hashCode()" ], [ "replace", "java.util", "Map", "public default boolean replace(K arg0, V arg1, V arg2)" ], [ "entrySet", "java.util", "Map", "public abstract Set<Map.Entry<K, V>> entrySet()" ], [ "remove", "java.util", "Map", "public default boolean remove(Object arg0, Object arg1)" ], [ "isEmpty", "java.util", "List", "public abstract boolean isEmpty()" ], [ "set", "java.util", "List", "public abstract E set(int arg0, E arg1)" ], [ "contains", "java.util", "List", "public abstract boolean contains(Object arg0)" ], [ "listIterator", "java.util", "List", "public abstract ListIterator<E> listIterator(int arg0)" ], [ "add", "java.util", "List", "public abstract boolean add(E arg0)" ], [ "size", "java.util", "List", "public abstract int size()" ], [ "subList", "java.util", "List", "public abstract List<E> subList(int arg0, int arg1)" ], [ "get", "java.util", "List", "public abstract E get(int arg0)" ], [ "addAll", "java.util", "List", "public abstract boolean addAll(int arg0, Collection<? extends E> arg1)" ], [ "addAll", "java.util", "List", "public abstract boolean addAll(Collection<? extends E> arg0)" ], [ "indexOf", "java.util", "List", "public abstract int indexOf(Object arg0)" ], [ "retainAll", "java.util", "List", "public abstract boolean retainAll(Collection<? extends Object> arg0)" ], [ "lastIndexOf", "java.util", "List", "public abstract int lastIndexOf(Object arg0)" ], [ "remove", "java.util", "List", "public abstract E remove(int arg0)" ], [ "removeAll", "java.util", "List", "public abstract boolean removeAll(Collection<? extends Object> arg0)" ], [ "equals", "java.util", "List", "public abstract boolean equals(Object arg0)" ], [ "toArray", "java.util", "List", "public abstract Object[] toArray()" ], [ "toArray", "java.util", "List", "public abstract <T> T[] toArray(T[] arg0)" ], [ "spliterator", "java.util", "List", "public default Spliterator<E> spliterator()" ], [ "remove", "java.util", "List", "public abstract boolean remove(Object arg0)" ], [ "hashCode", "java.util", "List", "public abstract int hashCode()" ], [ "listIterator", "java.util", "List", "public abstract ListIterator<E> listIterator()" ], [ "iterator", "java.util", "List", "public abstract Iterator<E> iterator()" ], [ "containsAll", "java.util", "List", "public abstract boolean containsAll(Collection<? extends Object> arg0)" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 26292,
  "oracle" : ";",
  "oracleType" : "PRE",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.alg",
  "className" : "KShortestPathsIterator",
  "javadocTag" : "@param vertex vertex reached by a path.",
  "methodJavadoc" : "    /**\n     * Try to add the first paths to the specified vertex. These paths reached\n     * the specified vertex and ended with the specified edge. A new\n     * intermediary path is stored in the paths list of the specified vertex\n     * provided that the path can be extended to the end-vertex.\n     *\n     * @param vertex vertex reached by a path.\n     * @param edge edge reaching the vertex.\n     */",
  "methodSourceCode" : "private boolean tryToAddFirstPaths(V vertex, E edge){\n    // the vertex has not been reached yet\n    RankingPathElementList<V, E> data = createSeenData(vertex, edge);\n    if (!data.isEmpty()) {\n        this.seenDataContainer.put(vertex, data);\n        return true;\n    }\n    return false;\n}",
  "classJavadoc" : "/**\n * Helper class for {@link KShortestPaths}.\n *\n * @author Guillaume Boulmier\n * @since July 5, 2007\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2010, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------------\n * KShortestPathsIterator.java\n * -------------------------\n * (C) Copyright 2007-2010, by France Telecom\n *\n * Original Author:  Guillaume Boulmier and Contributors.\n * Contributor(s):   John V. Sichi\n *\n * $Id$\n *\n * Changes\n * -------\n * 05-Jun-2007 : Initial revision (GB);\n * 05-Jul-2007 : Added support for generics (JVS);\n * 06-Dec-2010 : Bugfixes (GB);\n *\n */\npackage org.jgrapht.alg;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\n\n\n/**\n * Helper class for {@link KShortestPaths}.\n *\n * @author Guillaume Boulmier\n * @since July 5, 2007\n */\nclass KShortestPathsIterator<V, E>\n    implements Iterator<Set<V>>\n{\n    /**\n     * End vertex.\n     */\n    private V endVertex;\n\n    /**\n     * Graph on which shortest paths are searched.\n     */\n    private Graph<V, E> graph;\n\n    /**\n     * Number of paths stored at each end vertex.\n     */\n    private int k;\n\n    /**\n     * Vertices whose ranking shortest paths have been modified during the\n     * previous pass.\n     */\n    private Set<V> prevImprovedVertices;\n\n    /**\n     * Stores the paths that improved the vertex in the previous pass.\n     */\n    private Map<V, RankingPathElementList<V, E>> prevSeenDataContainer;\n\n    /**\n     * Stores the vertices that have been seen during iteration and (optionally)\n     * some additional traversal info regarding each vertex. Key = vertex, value\n     * = <code>RankingPathElementList</code> list of calculated paths.\n     */\n    private Map<V, RankingPathElementList<V, E>> seenDataContainer;\n\n    /**\n     * Start vertex.\n     */\n    private V startVertex;\n\n    private boolean startVertexEncountered;\n\n    /**\n     * Stores the number of the path.\n     */\n    private int passNumber = 1;\n\n    /**\n     * @param graph graph on which shortest paths are searched.\n     * @param startVertex start vertex of the calculated paths.\n     * @param endVertex end vertex of the calculated paths.\n     * @param maxSize number of paths stored at end vertex of the graph.\n     */\n    public KShortestPathsIterator(\n        Graph<V, E> graph,\n        V startVertex,\n        V endVertex,\n        int maxSize)\n    {\n        assertKShortestPathsIterator(graph, startVertex);\n\n        this.graph = graph;\n        this.startVertex = startVertex;\n        this.endVertex = endVertex;\n\n        this.k = maxSize;\n\n        this.seenDataContainer = new HashMap<V, RankingPathElementList<V, E>>();\n        this.prevSeenDataContainer =\n            new HashMap<V, RankingPathElementList<V, E>>();\n\n        this.prevImprovedVertices = new HashSet<V>();\n    }\n\n    /**\n     * @return <code>true</code> if at least one path has been improved during\n     * the previous pass, <code>false</code> otherwise.\n     */\n    @Override public boolean hasNext()\n    {\n        if (!this.startVertexEncountered) {\n            encounterStartVertex();\n        }\n\n        return !(this.prevImprovedVertices.isEmpty());\n    }\n\n    /**\n     * Returns the list of vertices whose path has been improved during the\n     * current pass. Complexity =\n     *\n     * <ul>\n     * <li>O(<code>m*k*(m+n)</code>) where <code>k</code> is the maximum number\n     * of shortest paths to compute, <code>m</code> is the number of edges of\n     * the graph and <code>n</code> is the number of vertices of the graph</li>\n     * </ul>\n     *\n     * @see java.util.Iterator#next()\n     */\n    @Override public Set<V> next()\n    {\n        if (!this.startVertexEncountered) {\n            encounterStartVertex();\n        }\n\n        // at the i-th pass the shortest paths with i edges are calculated.\n        if (hasNext()) {\n            Set<V> improvedVertices = new HashSet<V>();\n\n            for (\n                Iterator<V> iter = this.prevImprovedVertices.iterator();\n                iter.hasNext();)\n            {\n                V vertex = iter.next();\n                if (!vertex.equals(this.endVertex)) {\n                    updateOutgoingVertices(vertex, improvedVertices);\n                }\n            }\n\n            savePassData(improvedVertices);\n            this.passNumber++;\n\n            return improvedVertices;\n        }\n        throw new NoSuchElementException();\n    }\n\n    /**\n     * Unsupported.\n     *\n     * @see java.util.Iterator#remove()\n     */\n    @Override public void remove()\n    {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * Returns the path elements of the ranking shortest paths with less than\n     * <code>nMaxHops</code> edges between the start vertex and the end vertex.\n     *\n     * @param endVertex end vertex.\n     *\n     * @return list of <code>RankingPathElement</code>, or <code>null</code> of\n     * no path exists between the start vertex and the end vertex.\n     */\n    RankingPathElementList<V, E> getPathElements(V endVertex)\n    {\n        return this.seenDataContainer.get(endVertex);\n    }\n\n    private void assertKShortestPathsIterator(Graph<V, E> graph, V startVertex)\n    {\n        if (graph == null) {\n            throw new NullPointerException(\"graph is null\");\n        }\n        if (startVertex == null) {\n            throw new NullPointerException(\"startVertex is null\");\n        }\n    }\n\n    /**\n     * The first time we see a vertex, make up a new entry for it.\n     *\n     * @param vertex a vertex which has just been encountered.\n     * @param edge the edge via which the vertex was encountered.\n     *\n     * @return the new entry.\n     */\n    private RankingPathElementList<V, E> createSeenData(V vertex, E edge)\n    {\n        V oppositeVertex = Graphs.getOppositeVertex(this.graph, edge, vertex);\n\n        RankingPathElementList<V, E> oppositeData =\n            this.prevSeenDataContainer.get(oppositeVertex);\n\n        // endVertex in argument to ensure that stored paths do not disconnect\n        // the end-vertex\n        RankingPathElementList<V, E> data =\n            new RankingPathElementList<V, E>(\n                this.graph,\n                this.k,\n                oppositeData,\n                edge,\n                this.endVertex);\n\n        return data;\n    }\n\n    /**\n     * Returns an iterator to loop over outgoing edges <code>Edge</code> of the\n     * vertex.\n     *\n     * @param vertex\n     *\n     * @return .\n     */\n    private Iterator<E> edgesOfIterator(V vertex)\n    {\n        if (this.graph instanceof DirectedGraph<?, ?>) {\n            return ((DirectedGraph<V, E>) this.graph).outgoingEdgesOf(vertex)\n                .iterator();\n        } else {\n            return this.graph.edgesOf(vertex).iterator();\n        }\n    }\n\n    /**\n     * Initializes the list of paths at the start vertex and adds an empty path.\n     */\n    private void encounterStartVertex()\n    {\n        RankingPathElementList<V, E> data =\n            new RankingPathElementList<V, E>(\n                this.graph,\n                this.k,\n                new RankingPathElement<V, E>(\n                    this.startVertex));\n\n        this.seenDataContainer.put(this.startVertex, data);\n        this.prevSeenDataContainer.put(this.startVertex, data);\n\n        // initially the only vertex whose value is considered to have changed\n        // is the start vertex\n        this.prevImprovedVertices.add(this.startVertex);\n\n        this.startVertexEncountered = true;\n    }\n\n    private void savePassData(Set<V> improvedVertices)\n    {\n        for (Iterator<V> iter = improvedVertices.iterator(); iter.hasNext();) {\n            V vertex = iter.next();\n\n            RankingPathElementList<V, E> pathElementList =\n                this.seenDataContainer.get(vertex);\n\n            RankingPathElementList<V, E> improvedPaths =\n                new RankingPathElementList<V, E>(\n                    this.graph,\n                    pathElementList.maxSize,\n                    vertex);\n\n            for (\n                Iterator<RankingPathElement<V, E>> pathIter =\n                    pathElementList.iterator();\n                pathIter.hasNext();)\n            {\n                RankingPathElement<V, E> path = pathIter.next();\n                if (path.getHopCount() == this.passNumber) {\n                    // the path has just been computed.\n                    improvedPaths.pathElements.add(path);\n                }\n            }\n\n            this.prevSeenDataContainer.put(vertex, improvedPaths);\n        }\n\n        this.prevImprovedVertices = improvedVertices;\n    }\n\n    /**\n     * Try to add the first paths to the specified vertex. These paths reached\n     * the specified vertex and ended with the specified edge. A new\n     * intermediary path is stored in the paths list of the specified vertex\n     * provided that the path can be extended to the end-vertex.\n     *\n     * @param vertex vertex reached by a path.\n     * @param edge edge reaching the vertex.\n     */\n    private boolean tryToAddFirstPaths(V vertex, E edge)\n    {\n        // the vertex has not been reached yet\n        RankingPathElementList<V, E> data = createSeenData(vertex, edge);\n\n        if (!data.isEmpty()) {\n            this.seenDataContainer.put(vertex, data);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Try to add new paths for the vertex. These new paths reached the\n     * specified vertex and ended with the specified edge. A new intermediary\n     * path is stored in the paths list of the specified vertex provided that\n     * the path can be extended to the end-vertex.\n     *\n     * @param vertex a vertex which has just been encountered.\n     * @param edge the edge via which the vertex was encountered.\n     */\n    private boolean tryToAddNewPaths(V vertex, E edge)\n    {\n        RankingPathElementList<V, E> data = this.seenDataContainer.get(vertex);\n\n        V oppositeVertex = Graphs.getOppositeVertex(this.graph, edge, vertex);\n        RankingPathElementList<V, E> oppositeData =\n            this.prevSeenDataContainer.get(oppositeVertex);\n\n        return data.addPathElements(oppositeData, edge);\n    }\n\n    /**\n     * <p>Updates outgoing vertices of the vertex. For each outgoing vertex, the\n     * new paths are obtained by concatenating the specified edge to the\n     * calculated paths of the specified vertex. If the weight of a new path is\n     * greater than the weight of any path stored so far at the outgoing vertex\n     * then the path is not added, otherwise it is added to the list of paths in\n     * increasing order of weight.</p>\n     *\n     * Complexity =\n     *\n     * <ul>\n     * <li>O(<code>d(v)*k*(m+n)</code>) where <code>d(v)</code> is the outgoing\n     * degree of the specified vertex, <code>k</code> is the maximum number of\n     * shortest paths to compute, <code>m</code> is the number of edges of the\n     * graph and <code>n</code> is the number of vertices of the graph</li>\n     * </ul>\n     *\n     * @param vertex\n     * @param improvedVertices\n     */\n    private void updateOutgoingVertices(V vertex, Set<V> improvedVertices)\n    {\n        // try to add new paths for the target vertices of the outgoing edges\n        // of the vertex in argument.\n        for (Iterator<E> iter = edgesOfIterator(vertex); iter.hasNext();) {\n            E edge = iter.next();\n            V vertexReachedByEdge =\n                Graphs.getOppositeVertex(this.graph, edge,\n                    vertex);\n\n            // check if the path does not loop over the start vertex.\n            if (!vertexReachedByEdge.equals(this.startVertex)) {\n                if (this.seenDataContainer.containsKey(vertexReachedByEdge)) {\n                    boolean relaxed =\n                        tryToAddNewPaths(vertexReachedByEdge,\n                            edge);\n                    if (relaxed) {\n                        improvedVertices.add(vertexReachedByEdge);\n                    }\n                } else {\n                    boolean relaxed =\n                        tryToAddFirstPaths(vertexReachedByEdge,\n                            edge);\n                    if (relaxed) {\n                        improvedVertices.add(vertexReachedByEdge);\n                    }\n                }\n            }\n        }\n    }\n}\n\n// End KShortestPathsIterator.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "vertex", "", "V" ], [ "edge", "", "E" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "next", "org.jgrapht.alg", "KShortestPathsIterator", "public Set<V> next()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "getPathElements", "org.jgrapht.alg", "KShortestPathsIterator", "RankingPathElementList<V, E> getPathElements(V endVertex)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "next", "java.util", "Iterator", "public abstract E next()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "hasNext", "org.jgrapht.alg", "KShortestPathsIterator", "public boolean hasNext()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 26310,
  "oracle" : "directedGraph == null;",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.alg",
  "className" : "StrongConnectivityInspector",
  "javadocTag" : "@throws IllegalArgumentException",
  "methodJavadoc" : "    /**\n     * The constructor of the StrongConnectivityAlgorithm class.\n     *\n     * @param directedGraph the graph to inspect\n     *\n     * @throws IllegalArgumentException\n     */",
  "methodSourceCode" : "public StrongConnectivityInspector(DirectedGraph<V, E> directedGraph){\n    if (directedGraph == null) {\n        throw new IllegalArgumentException(\"null not allowed for graph!\");\n    }\n    graph = directedGraph;\n    vertexToVertexData = null;\n    orderedVertices = null;\n    stronglyConnectedSets = null;\n    stronglyConnectedSubgraphs = null;\n}",
  "classJavadoc" : "/**\n * <p>Complements the {@link ConnectivityInspector} class with the capability to\n * compute the strongly connected components of a directed graph. The algorithm\n * is implemented after \"Cormen et al: Introduction to algorithms\", Chapter\n * 22.5. It has a running time of O(V + E).</p>\n *\n * <p>Unlike {@link ConnectivityInspector}, this class does not implement\n * incremental inspection. The full algorithm is executed at the first call of\n * {@link StrongConnectivityInspector#stronglyConnectedSets()} or {@link\n * StrongConnectivityInspector#isStronglyConnected()}.</p>\n *\n * @author Christian Soltenborn\n * @author Christian Hammer\n * @since Feb 2, 2005\n * @deprecated Use {@link KosarajuStrongConnectivityInspector} instead.\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* --------------------------\n * StrongConnectivityInspector.java\n * --------------------------\n * (C) Copyright 2005-2008, by Christian Soltenborn and Contributors.\n *\n * Original Author:  Christian Soltenborn\n *\n * $Id$\n *\n * Changes\n * -------\n * 2-Feb-2005 : Initial revision (CS);\n * 5-Feb-2007 : fixed NullPointerException (CS);\n * 1-Apr-2008 : Reduced memory consumption (CS);\n *\n */\npackage org.jgrapht.alg;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\nimport org.jgrapht.alg.interfaces.*;\nimport org.jgrapht.graph.*;\n\n\n/**\n * <p>Complements the {@link ConnectivityInspector} class with the capability to\n * compute the strongly connected components of a directed graph. The algorithm\n * is implemented after \"Cormen et al: Introduction to algorithms\", Chapter\n * 22.5. It has a running time of O(V + E).</p>\n *\n * <p>Unlike {@link ConnectivityInspector}, this class does not implement\n * incremental inspection. The full algorithm is executed at the first call of\n * {@link StrongConnectivityInspector#stronglyConnectedSets()} or {@link\n * StrongConnectivityInspector#isStronglyConnected()}.</p>\n *\n * @author Christian Soltenborn\n * @author Christian Hammer\n * @since Feb 2, 2005\n * @deprecated Use {@link KosarajuStrongConnectivityInspector} instead.\n */\n@Deprecated public class StrongConnectivityInspector<V, E>\n    implements StrongConnectivityAlgorithm<V, E>\n{\n    // the graph to compute the strongly connected sets for\n    private final DirectedGraph<V, E> graph;\n\n    // stores the vertices, ordered by their finishing time in first dfs\n    private LinkedList<VertexData<V>> orderedVertices;\n\n    // the result of the computation, cached for future calls\n    private List<Set<V>> stronglyConnectedSets;\n\n    // the result of the computation, cached for future calls\n    private List<DirectedSubgraph<V, E>> stronglyConnectedSubgraphs;\n\n    // maps vertices to their VertexData object\n    private Map<V, VertexData<V>> vertexToVertexData;\n\n    /**\n     * The constructor of the StrongConnectivityAlgorithm class.\n     *\n     * @param directedGraph the graph to inspect\n     *\n     * @throws IllegalArgumentException\n     */\n    public StrongConnectivityInspector(DirectedGraph<V, E> directedGraph)\n    {\n        if (directedGraph == null) {\n            throw new IllegalArgumentException(\"null not allowed for graph!\");\n        }\n\n        graph = directedGraph;\n        vertexToVertexData = null;\n        orderedVertices = null;\n        stronglyConnectedSets = null;\n        stronglyConnectedSubgraphs = null;\n    }\n\n    /**\n     * Returns the graph inspected by the StrongConnectivityAlgorithm.\n     *\n     * @return the graph inspected by this StrongConnectivityAlgorithm\n     */\n    public DirectedGraph<V, E> getGraph()\n    {\n        return graph;\n    }\n\n    /**\n     * Returns true if the graph of this <code>\n     * StronglyConnectivityInspector</code> instance is strongly connected.\n     *\n     * @return true if the graph is strongly connected, false otherwise\n     */\n    public boolean isStronglyConnected()\n    {\n        return stronglyConnectedSets().size() == 1;\n    }\n\n    /**\n     * Computes a {@link List} of {@link Set}s, where each set contains vertices\n     * which together form a strongly connected component within the given\n     * graph.\n     *\n     * @return <code>List</code> of <code>Set</code> s containing the strongly\n     * connected components\n     */\n    public List<Set<V>> stronglyConnectedSets()\n    {\n        if (stronglyConnectedSets == null) {\n            orderedVertices = new LinkedList<VertexData<V>>();\n            stronglyConnectedSets = new Vector<Set<V>>();\n\n            // create VertexData objects for all vertices, store them\n            createVertexData();\n\n            // perform the first round of DFS, result is an ordering\n            // of the vertices by decreasing finishing time\n            for (VertexData<V> data : vertexToVertexData.values()) {\n                if (!data.isDiscovered()) {\n                    dfsVisit(graph, data, null);\n                }\n            }\n\n            // 'create' inverse graph (i.e. every edge is reversed)\n            DirectedGraph<V, E> inverseGraph =\n                new EdgeReversedGraph<V, E>(graph);\n\n            // get ready for next dfs round\n            resetVertexData();\n\n            // second dfs round: vertices are considered in decreasing\n            // finishing time order; every tree found is a strongly\n            // connected set\n            for (VertexData<V> data : orderedVertices) {\n                if (!data.isDiscovered()) {\n                    // new strongly connected set\n                    Set<V> set = new HashSet<V>();\n                    stronglyConnectedSets.add(set);\n                    dfsVisit(inverseGraph, data, set);\n                }\n            }\n\n            // clean up for garbage collection\n            orderedVertices = null;\n            vertexToVertexData = null;\n        }\n\n        return stronglyConnectedSets;\n    }\n\n    /**\n     * <p>Computes a list of {@link DirectedSubgraph}s of the given graph. Each\n     * subgraph will represent a strongly connected component and will contain\n     * all vertices of that component. The subgraph will have an edge (u,v) iff\n     * u and v are contained in the strongly connected component.</p>\n     *\n     * <p>NOTE: Calling this method will first execute {@link\n     * StrongConnectivityInspector#stronglyConnectedSets()}. If you don't need\n     * subgraphs, use that method.</p>\n     *\n     * @return a list of subgraphs representing the strongly connected\n     * components\n     */\n    public List<DirectedSubgraph<V, E>> stronglyConnectedSubgraphs()\n    {\n        if (stronglyConnectedSubgraphs == null) {\n            List<Set<V>> sets = stronglyConnectedSets();\n            stronglyConnectedSubgraphs =\n                new Vector<DirectedSubgraph<V, E>>(sets.size());\n\n            for (Set<V> set : sets) {\n                stronglyConnectedSubgraphs.add(\n                    new DirectedSubgraph<V, E>(\n                        graph,\n                        set,\n                        null));\n            }\n        }\n\n        return stronglyConnectedSubgraphs;\n    }\n\n    /*\n     * Creates a VertexData object for every vertex in the graph and stores\n     * them\n     * in a HashMap.\n     */\n    private void createVertexData()\n    {\n        vertexToVertexData =\n            new HashMap<V, VertexData<V>>(graph.vertexSet().size());\n\n        for (V vertex : graph.vertexSet()) {\n            vertexToVertexData.put(\n                vertex,\n                new VertexData2<V>(vertex, false, false));\n        }\n    }\n\n    /*\n     * The subroutine of DFS. NOTE: the set is used to distinguish between 1st\n     * and 2nd round of DFS. set == null: finished vertices are stored (1st\n     * round). set != null: all vertices found will be saved in the set (2nd\n     * round)\n     */\n    private void dfsVisit(\n        DirectedGraph<V, E> visitedGraph,\n        VertexData<V> vertexData,\n        Set<V> vertices)\n    {\n        Deque<VertexData<V>> stack = new ArrayDeque<VertexData<V>>();\n        stack.add(vertexData);\n\n        while (!stack.isEmpty()) {\n            VertexData<V> data = stack.removeLast();\n\n            if (!data.isDiscovered()) {\n                data.setDiscovered(true);\n\n                if (vertices != null) {\n                    vertices.add(data.getVertex());\n                }\n\n                stack.add(new VertexData1<V>(data, true, true));\n\n                // follow all edges\n                for (E edge : visitedGraph.outgoingEdgesOf(data.getVertex())) {\n                    VertexData<V> targetData =\n                        vertexToVertexData.get(\n                            visitedGraph.getEdgeTarget(edge));\n\n                    if (!targetData.isDiscovered()) {\n                        // the \"recursion\"\n                        stack.add(targetData);\n                    }\n                }\n            } else if (data.isFinished()) {\n                if (vertices == null) {\n                    orderedVertices.addFirst(data.getFinishedData());\n                }\n            }\n        }\n    }\n\n    /*\n     * Resets all VertexData objects.\n     */\n    private void resetVertexData()\n    {\n        for (VertexData<V> data : vertexToVertexData.values()) {\n            data.setDiscovered(false);\n            data.setFinished(false);\n        }\n    }\n\n    /*\n     * Lightweight class storing some data for every vertex.\n     */\n    private static abstract class VertexData<V>\n    {\n        private byte bitfield;\n\n        private VertexData(\n            boolean discovered,\n            boolean finished)\n        {\n            this.bitfield = 0;\n            setDiscovered(discovered);\n            setFinished(finished);\n        }\n\n        private boolean isDiscovered()\n        {\n            return (bitfield & 1) == 1;\n        }\n\n        private boolean isFinished()\n        {\n            return (bitfield & 2) == 2;\n        }\n\n        private void setDiscovered(boolean discovered)\n        {\n            if (discovered) {\n                bitfield |= 1;\n            } else {\n                bitfield &= ~1;\n            }\n        }\n\n        private void setFinished(boolean finished)\n        {\n            if (finished) {\n                bitfield |= 2;\n            } else {\n                bitfield &= ~2;\n            }\n        }\n\n        abstract VertexData<V> getFinishedData();\n\n        abstract V getVertex();\n    }\n\n    private static final class VertexData1<V>\n        extends VertexData<V>\n    {\n        private final VertexData<V> finishedData;\n\n        private VertexData1(\n            VertexData<V> finishedData,\n            boolean discovered,\n            boolean finished)\n        {\n            super(discovered, finished);\n            this.finishedData = finishedData;\n        }\n\n        @Override VertexData<V> getFinishedData()\n        {\n            return finishedData;\n        }\n\n        @Override V getVertex()\n        {\n            return null;\n        }\n    }\n\n    private static final class VertexData2<V>\n        extends VertexData<V>\n    {\n        private final V vertex;\n\n        private VertexData2(\n            V vertex,\n            boolean discovered,\n            boolean finished)\n        {\n            super(discovered, finished);\n            this.vertex = vertex;\n        }\n\n        @Override VertexData<V> getFinishedData()\n        {\n            return null;\n        }\n\n        @Override V getVertex()\n        {\n            return vertex;\n        }\n    }\n}\n\n// End StrongConnectivityAlgorithm.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "directedGraph", "org.jgrapht.DirectedGraph", "DirectedGraph<V, E>" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "stronglyConnectedSets", "org.jgrapht.alg", "StrongConnectivityInspector", "public List<Set<V>> stronglyConnectedSets()" ], [ "isStronglyConnected", "org.jgrapht.alg", "StrongConnectivityInspector", "public boolean isStronglyConnected()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "stronglyConnectedSubgraphs", "org.jgrapht.alg", "StrongConnectivityInspector", "public List<DirectedSubgraph<V, E>> stronglyConnectedSubgraphs()" ], [ "getGraph", "org.jgrapht.alg", "StrongConnectivityInspector", "public DirectedGraph<V, E> getGraph()" ], [ "outDegreeOf", "org.jgrapht", "DirectedGraph", "public abstract int outDegreeOf(V arg0)" ], [ "incomingEdgesOf", "org.jgrapht", "DirectedGraph", "public abstract Set<E> incomingEdgesOf(V arg0)" ], [ "inDegreeOf", "org.jgrapht", "DirectedGraph", "public abstract int inDegreeOf(V arg0)" ], [ "outgoingEdgesOf", "org.jgrapht", "DirectedGraph", "public abstract Set<E> outgoingEdgesOf(V arg0)" ], [ "removeVertex", "org.jgrapht", "Graph", "public abstract boolean removeVertex(V arg0)" ], [ "edgesOf", "org.jgrapht", "Graph", "public abstract Set<E> edgesOf(V arg0)" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract boolean addEdge(V arg0, V arg1, E arg2)" ], [ "containsVertex", "org.jgrapht", "Graph", "public abstract boolean containsVertex(V arg0)" ], [ "vertexSet", "org.jgrapht", "Graph", "public abstract Set<V> vertexSet()" ], [ "removeAllVertices", "org.jgrapht", "Graph", "public abstract boolean removeAllVertices(Collection<? extends V> arg0)" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract boolean removeEdge(E arg0)" ], [ "addVertex", "org.jgrapht", "Graph", "public abstract boolean addVertex(V arg0)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract boolean removeAllEdges(Collection<? extends E> arg0)" ], [ "getEdgeTarget", "org.jgrapht", "Graph", "public abstract V getEdgeTarget(E arg0)" ], [ "getEdgeWeight", "org.jgrapht", "Graph", "public abstract double getEdgeWeight(E arg0)" ], [ "getAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> getAllEdges(V arg0, V arg1)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(V arg0, V arg1)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> removeAllEdges(V arg0, V arg1)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(E arg0)" ], [ "getEdgeSource", "org.jgrapht", "Graph", "public abstract V getEdgeSource(E arg0)" ], [ "getEdgeFactory", "org.jgrapht", "Graph", "public abstract EdgeFactory<V, E> getEdgeFactory()" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract E addEdge(V arg0, V arg1)" ], [ "getEdge", "org.jgrapht", "Graph", "public abstract E getEdge(V arg0, V arg1)" ], [ "edgeSet", "org.jgrapht", "Graph", "public abstract Set<E> edgeSet()" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract E removeEdge(V arg0, V arg1)" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
} ]