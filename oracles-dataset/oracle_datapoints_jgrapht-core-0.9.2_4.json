[
    {
        "id": 26126,
        "oracle": "size >= 0;",
        "oracleType": "PRE",
        "projectName": "jgrapht-core-0.9.2",
        "packageName": "org.jgrapht.generate",
        "className": "WheelGraphGenerator",
        "javadocTag": "@param size number of vertices to be generated.",
        "methodJavadoc": "    /**\n     * Construct a new WheelGraphGenerator.\n     *\n     * @param size number of vertices to be generated.\n     * @param inwardSpokes if <code>true</code> and graph is directed, spokes\n     * are oriented from rim to hub; else from hub to rim.\n     *\n     * @throws IllegalArgumentException\n     */",
        "methodSourceCode": "public WheelGraphGenerator(int size, boolean inwardSpokes){\n    if (size < 0) {\n        throw new IllegalArgumentException(\"must be non-negative\");\n    }\n    this.size = size;\n    this.inwardSpokes = inwardSpokes;\n}",
        "classJavadoc": "/**\n * Generates a <a href=\"http://mathworld.wolfram.com/WheelGraph.html\">wheel\n * graph</a> of any size. Reminding a bicycle wheel, a wheel graph has a hub\n * vertex in the center and a rim of vertices around it that are connected to\n * each other (as a ring). The rim vertices are also connected to the hub with\n * edges that are called \"spokes\".\n *\n * @author John V. Sichi\n * @since Sep 16, 2003\n */",
        "classSourceCode": "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------\n * WheelGraphGenerator.java\n * -------------------\n * (C) Copyright 2003-2008, by John V. Sichi and Contributors.\n *\n * Original Author:  John V. Sichi\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n * 16-Sep-2003 : Initial revision (JVS);\n *\n */\npackage org.jgrapht.generate;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\n\n\n/**\n * Generates a <a href=\"http://mathworld.wolfram.com/WheelGraph.html\">wheel\n * graph</a> of any size. Reminding a bicycle wheel, a wheel graph has a hub\n * vertex in the center and a rim of vertices around it that are connected to\n * each other (as a ring). The rim vertices are also connected to the hub with\n * edges that are called \"spokes\".\n *\n * @author John V. Sichi\n * @since Sep 16, 2003\n */\npublic class WheelGraphGenerator<V, E>\n    implements GraphGenerator<V, E, V>\n{\n    /**\n     * Role for the hub vertex.\n     */\n    public static final String HUB_VERTEX = \"Hub Vertex\";\n\n    private boolean inwardSpokes;\n    private int size;\n\n    /**\n     * Creates a new WheelGraphGenerator object. This constructor is more\n     * suitable for undirected graphs, where spokes' direction is meaningless.\n     * In the directed case, spokes will be oriented from rim to hub.\n     *\n     * @param size number of vertices to be generated.\n     */\n    public WheelGraphGenerator(int size)\n    {\n        this(size, true);\n    }\n\n    /**\n     * Construct a new WheelGraphGenerator.\n     *\n     * @param size number of vertices to be generated.\n     * @param inwardSpokes if <code>true</code> and graph is directed, spokes\n     * are oriented from rim to hub; else from hub to rim.\n     *\n     * @throws IllegalArgumentException\n     */\n    public WheelGraphGenerator(int size, boolean inwardSpokes)\n    {\n        if (size < 0) {\n            throw new IllegalArgumentException(\"must be non-negative\");\n        }\n\n        this.size = size;\n        this.inwardSpokes = inwardSpokes;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override public void generateGraph(\n        Graph<V, E> target,\n        final VertexFactory<V> vertexFactory,\n        Map<String, V> resultMap)\n    {\n        if (size < 1) {\n            return;\n        }\n\n        // A little trickery to intercept the rim generation.  This is\n        // necessary since target may be initially non-empty, meaning we can't\n        // rely on its vertex set after the rim is generated.\n        final Collection<V> rim = new ArrayList<V>();\n        VertexFactory<V> rimVertexFactory =\n            new VertexFactory<V>() {\n                @Override public V createVertex()\n                {\n                    V vertex = vertexFactory.createVertex();\n                    rim.add(vertex);\n\n                    return vertex;\n                }\n            };\n\n        RingGraphGenerator<V, E> ringGenerator =\n            new RingGraphGenerator<V, E>(size - 1);\n        ringGenerator.generateGraph(target, rimVertexFactory, resultMap);\n\n        V hubVertex = vertexFactory.createVertex();\n        target.addVertex(hubVertex);\n\n        if (resultMap != null) {\n            resultMap.put(HUB_VERTEX, hubVertex);\n        }\n\n        for (V rimVertex : rim) {\n            if (inwardSpokes) {\n                target.addEdge(rimVertex, hubVertex);\n            } else {\n                target.addEdge(hubVertex, rimVertex);\n            }\n        }\n    }\n}\n\n// End WheelGraphGenerator.java\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "PartiteRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "RandomGraphHelper",
                "org.jgrapht.experimental"
            ],
            [
                "GraphReader",
                "org.jgrapht.experimental"
            ],
            [
                "DirectedAcyclicGraph",
                "org.jgrapht.experimental.dag"
            ],
            [
                "GraphSquare",
                "org.jgrapht.experimental"
            ],
            [
                "UniformRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "GraphTests",
                "org.jgrapht.experimental"
            ],
            [
                "ApproximationAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "BrownBacktrackColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "GreedyColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "IntArrayGraphAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ExactAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ListenableGraph",
                "org.jgrapht"
            ],
            [
                "ModifiableInteger",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeapNode",
                "org.jgrapht.util"
            ],
            [
                "WeightCombiner",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeap",
                "org.jgrapht.util"
            ],
            [
                "TypeUtil",
                "org.jgrapht.util"
            ],
            [
                "ArrayUnenforcedSet",
                "org.jgrapht.util"
            ],
            [
                "VertexPair",
                "org.jgrapht.util"
            ],
            [
                "MathUtil",
                "org.jgrapht.util"
            ],
            [
                "PrefetchIterator",
                "org.jgrapht.util"
            ],
            [
                "VertexFactory",
                "org.jgrapht"
            ],
            [
                "Graph",
                "org.jgrapht"
            ],
            [
                "GraphPath",
                "org.jgrapht"
            ],
            [
                "UndirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraph",
                "org.jgrapht.graph"
            ],
            [
                "MixedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DefaultGraphMapping",
                "org.jgrapht.graph"
            ],
            [
                "WeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskEdgeSet",
                "org.jgrapht.graph"
            ],
            [
                "Pseudograph",
                "org.jgrapht.graph"
            ],
            [
                "MaskFunctor",
                "org.jgrapht.graph"
            ],
            [
                "GraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractBaseGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "Multigraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultWeightedEdge",
                "org.jgrapht.graph"
            ],
            [
                "ListenableDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeSetFactory",
                "org.jgrapht.graph"
            ],
            [
                "GraphDelegator",
                "org.jgrapht.graph"
            ],
            [
                "DefaultListenableGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedVertexFactory",
                "org.jgrapht.graph"
            ],
            [
                "DefaultEdge",
                "org.jgrapht.graph"
            ],
            [
                "MaskVertexSet",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "IntrusiveEdge",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphPathImpl",
                "org.jgrapht.graph"
            ],
            [
                "Subgraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractGraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedEdgeFactory",
                "org.jgrapht.graph"
            ],
            [
                "SimpleWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "WeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeReversedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "AbstractGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "ListenableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraphPath",
                "org.jgrapht.graph"
            ],
            [
                "ParanoidGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphHelper",
                "org.jgrapht"
            ],
            [
                "Graphs",
                "org.jgrapht"
            ],
            [
                "DirectedGraph",
                "org.jgrapht"
            ],
            [
                "WeightedGraph",
                "org.jgrapht"
            ],
            [
                "HyperCubeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RingGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WheelGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GridGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "ScaleFreeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedBipartiteGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "LinearGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RandomGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGeneratorAdapter",
                "org.jgrapht.generate"
            ],
            [
                "EmptyGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteBipartiteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "StarGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "UndirectedGraph",
                "org.jgrapht"
            ],
            [
                "TopologicalOrderIterator",
                "org.jgrapht.traverse"
            ],
            [
                "CrossComponentIterator",
                "org.jgrapht.traverse"
            ],
            [
                "AbstractGraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "ClosestFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "BreadthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "DepthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "GraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "EdgeFactory",
                "org.jgrapht"
            ],
            [
                "GraphMapping",
                "org.jgrapht"
            ],
            [
                "VertexSetListener",
                "org.jgrapht.event"
            ],
            [
                "EdgeTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "TraversalListener",
                "org.jgrapht.event"
            ],
            [
                "GraphEdgeChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "VertexTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphListener",
                "org.jgrapht.event"
            ],
            [
                "TraversalListenerAdapter",
                "org.jgrapht.event"
            ],
            [
                "ConnectedComponentTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphVertexChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "TarjanLowestCommonAncestor",
                "org.jgrapht.alg"
            ],
            [
                "PrimMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "BlockCutpointGraph",
                "org.jgrapht.alg"
            ],
            [
                "AllDirectedPaths",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPathsIterator",
                "org.jgrapht.alg"
            ],
            [
                "KruskalMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "StrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "VF2State",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2AbstractIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "GraphOrdering",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphicGraphMapping",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2MappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "BronKerboschCliqueFinder",
                "org.jgrapht.alg"
            ],
            [
                "ChromaticNumber",
                "org.jgrapht.alg"
            ],
            [
                "KosarajuStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "DijkstraShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElement",
                "org.jgrapht.alg"
            ],
            [
                "AStarShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordPathElement",
                "org.jgrapht.alg"
            ],
            [
                "FloydWarshallShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "UnionFind",
                "org.jgrapht.alg.util"
            ],
            [
                "AlwaysEqualComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Extension",
                "org.jgrapht.alg.util"
            ],
            [
                "VertexDegreeComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Pair",
                "org.jgrapht.alg.util"
            ],
            [
                "GabowStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "HawickJamesSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "DirectedSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "JohnsonSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TiernanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "UndirectedCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "PatonCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TarjanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "SzwarcfiterLauerSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "BiconnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "ConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "MinSourceSinkCut",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsBlossomShrinking",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveClosure",
                "org.jgrapht.alg"
            ],
            [
                "HopcroftKarpBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "StoerWagnerMinimumCut",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "KuhnMunkresMinimalWeightBipartitePerfectMatching",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveReduction",
                "org.jgrapht.alg"
            ],
            [
                "EulerianCircuit",
                "org.jgrapht.alg"
            ],
            [
                "DirectedNeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "NaiveLcaFinder",
                "org.jgrapht.alg"
            ],
            [
                "MaximumWeightBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "HamiltonianCycle",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "NeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "VertexCovers",
                "org.jgrapht.alg"
            ],
            [
                "CycleDetector",
                "org.jgrapht.alg"
            ],
            [
                "AStarAdmissibleHeuristic",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MinimumSpanningTree",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "WeightedMatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "StrongConnectivityAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MaximumFlowAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "CliqueMinimalSeparatorDecomposition",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordIterator",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElement",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "PushRelabelMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "MaximumFlowAlgorithmBase",
                "org.jgrapht.alg.flow"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "addVertices",
                "org.jgrapht.experimental",
                "RandomGraphHelper",
                "/**\n * .\n *\n * @param target\n * @param vertexFactory\n * @param numVertices\n *\n * @return vertices\n */\n@SuppressWarnings(\"unchecked\")\npublic static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices) {\n    Object[] vertices = new Object[numVertices];\n    for (int i = 0; i < numVertices; ++i) {\n        vertices[i] = vertexFactory.createVertex();\n        target.addVertex(vertices[i]);\n    }\n    return vertices;\n}"
            ],
            [
                "isEmpty",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isEmpty(Graph<V, E> g) {\n    return g.edgeSet().isEmpty();\n}"
            ],
            [
                "isComplete",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isComplete(Graph<V, E> g) {\n    int n = g.vertexSet().size();\n    return g.edgeSet().size() == (n * (n - 1) / 2);\n}"
            ],
            [
                "isConnected",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isConnected(Graph<V, E> g) {\n    int numVertices = g.vertexSet().size();\n    int numEdges = g.edgeSet().size();\n    if (numEdges < (numVertices - 1)) {\n        return false;\n    }\n    if ((numVertices < 2) || (numEdges > ((numVertices - 1) * (numVertices - 2) / 2))) {\n        return true;\n    }\n    Set<V> known = new HashSet<V>();\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = g.vertexSet().iterator().next();\n    // start with node 1\n    queue.add(v);\n    known.add(v);\n    while (!queue.isEmpty()) {\n        v = queue.removeFirst();\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            v = it.next();\n            if (!known.contains(v)) {\n                known.add(v);\n                queue.add(v);\n            }\n        }\n    }\n    return known.size() == numVertices;\n}"
            ],
            [
                "isTree",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isTree(Graph<V, E> g) {\n    return isConnected(g) && (g.edgeSet().size() == (g.vertexSet().size() - 1));\n}"
            ],
            [
                "isBipartite",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isBipartite(Graph<V, E> g) {\n    if ((4 * g.edgeSet().size()) > (g.vertexSet().size() * g.vertexSet().size())) {\n        return false;\n    }\n    if (isEmpty(g)) {\n        return true;\n    }\n    Set<V> unknown = new HashSet<V>(g.vertexSet());\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = unknown.iterator().next();\n    Set<V> odd = new HashSet<V>();\n    queue.add(v);\n    while (!unknown.isEmpty()) {\n        if (queue.isEmpty()) {\n            queue.add(unknown.iterator().next());\n        }\n        v = queue.removeFirst();\n        unknown.remove(v);\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            V n = it.next();\n            if (unknown.contains(n)) {\n                queue.add(n);\n                if (!odd.contains(v)) {\n                    odd.add(n);\n                }\n            } else if (!(odd.contains(v) ^ odd.contains(n))) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
            ],
            [
                "union",
                "org.jgrapht.util",
                "FibonacciHeap",
                "// size\n/**\n * Joins two Fibonacci heaps into a new one. No heap consolidation is\n * performed at this time. The two root lists are simply joined together.\n *\n * <p>Running time: O(1) actual</p>\n *\n * @param h1 first heap\n * @param h2 second heap\n *\n * @return new heap containing h1 and h2\n */\npublic static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2) {\n    FibonacciHeap<T> h = new FibonacciHeap<T>();\n    if ((h1 != null) && (h2 != null)) {\n        h.minNode = h1.minNode;\n        if (h.minNode != null) {\n            if (h2.minNode != null) {\n                h.minNode.right.left = h2.minNode.left;\n                h2.minNode.left.right = h.minNode.right;\n                h.minNode.right = h2.minNode;\n                h2.minNode.left = h.minNode;\n                if (h2.minNode.key < h1.minNode.key) {\n                    h.minNode = h2.minNode;\n                }\n            }\n        } else {\n            h.minNode = h2.minNode;\n        }\n        h.nNodes = h1.nNodes + h2.nNodes;\n    }\n    return h;\n}"
            ],
            [
                "uncheckedCast",
                "org.jgrapht.util",
                "TypeUtil",
                "/**\n * Casts an object to a type.\n *\n * @param o object to be cast\n * @param typeDecl conveys the target type information; the actual value is\n * unused and can be null since this is all just stupid compiler tricks\n *\n * @return the result of the cast\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl) {\n    return (T) o;\n}"
            ],
            [
                "factorial",
                "org.jgrapht.util",
                "MathUtil",
                "public static long factorial(int N) {\n    long multi = 1;\n    for (int i = 1; i <= N; i++) {\n        multi = multi * i;\n    }\n    return multi;\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graphs",
                "/**\n * Creates a new edge and adds it to the specified graph similarly to the\n * {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n *\n * @see Graph#addEdge(Object, Object)\n */\npublic static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    EdgeFactory<V, E> ef = g.getEdgeFactory();\n    E e = ef.createEdge(sourceVertex, targetVertex);\n    // we first create the edge and set the weight to make sure that\n    // listeners will see the correct weight upon addEdge.\n    assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n    ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n    return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new edge and adds it to the specified\n * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return g.addEdge(sourceVertex, targetVertex);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified edge to the graph, including its vertices if not\n * already included.\n *\n * @param targetGraph the graph for which the specified edge to be added.\n * @param sourceGraph the graph in which the specified edge is already\n * present\n * @param edge edge to add\n *\n * @return <tt>true</tt> if the target graph did not already contain the\n * specified edge.\n */\npublic static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge) {\n    V sourceVertex = sourceGraph.getEdgeSource(edge);\n    V targetVertex = sourceGraph.getEdgeTarget(edge);\n    targetGraph.addVertex(sourceVertex);\n    targetGraph.addVertex(targetVertex);\n    return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new weighted edge and adds it to the\n * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n * method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return addEdge(g, sourceVertex, targetVertex, weight);\n}"
            ],
            [
                "addGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all the vertices and all the edges of the specified source graph to\n * the specified destination graph. First all vertices of the source graph\n * are added to the destination graph. Then every edge of the source graph\n * is added to the destination graph. This method returns <code>true</code>\n * if the destination graph has been modified as a result of this operation,\n * otherwise it returns <code>false</code>.\n *\n * <p>The behavior of this operation is undefined if any of the specified\n * graphs is modified while operation is in progress.</p>\n *\n * @param destination the graph to which vertices and edges are added.\n * @param source the graph used as source for vertices and edges to add.\n *\n * @return <code>true</code> if and only if the destination graph has been\n * changed as a result of this operation.\n */\npublic static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source) {\n    boolean modified = addAllVertices(destination, source.vertexSet());\n    modified |= addAllEdges(destination, source, source.edgeSet());\n    return modified;\n}"
            ],
            [
                "addAllEdges",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds a subset of the edges of the specified source graph to the specified\n * destination graph. The behavior of this operation is undefined if either\n * of the graphs is modified while the operation is in progress. {@link\n * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n * be added automatically to the target graph.\n *\n * @param destination the graph to which edges are to be added\n * @param source the graph used as a source for edges to add\n * @param edges the edges to be added\n *\n * @return <tt>true</tt> if this graph changed as a result of the call\n */\npublic static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges) {\n    boolean modified = false;\n    for (E e : edges) {\n        V s = source.getEdgeSource(e);\n        V t = source.getEdgeTarget(e);\n        destination.addVertex(s);\n        destination.addVertex(t);\n        modified |= destination.addEdge(s, t, e);\n    }\n    return modified;\n}"
            ],
            [
                "addAllVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all of the specified vertices to the destination graph. The behavior\n * of this operation is undefined if the specified vertex collection is\n * modified while the operation is in progress. This method will invoke the\n * {@link Graph#addVertex(Object)} method.\n *\n * @param destination the graph to which edges are to be added\n * @param vertices the vertices to be added to the graph.\n *\n * @return <tt>true</tt> if graph changed as a result of the call\n *\n * @throws NullPointerException if the specified vertices contains one or\n * more null vertices, or if the specified vertex collection is <tt>\n * null</tt>.\n *\n * @see Graph#addVertex(Object)\n */\npublic static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices) {\n    boolean modified = false;\n    for (V v : vertices) {\n        modified |= destination.addVertex(v);\n    }\n    return modified;\n}"
            ],
            [
                "neighborListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the neighbors of a specified vertex.\n * If the graph is a multigraph vertices may appear more than once in the\n * returned list.\n *\n * @param g the graph to look for neighbors in.\n * @param vertex the vertex to get the neighbors of.\n *\n * @return a list of the vertices that are the neighbors of the specified\n * vertex.\n */\npublic static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex) {\n    List<V> neighbors = new ArrayList<V>();\n    for (E e : g.edgesOf(vertex)) {\n        neighbors.add(getOppositeVertex(g, e, vertex));\n    }\n    return neighbors;\n}"
            ],
            [
                "predecessorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct predecessors of a\n * specified vertex. If the graph is a multigraph, vertices may appear more\n * than once in the returned list.\n *\n * @param g the graph to look for predecessors in.\n * @param vertex the vertex to get the predecessors of.\n *\n * @return a list of the vertices that are the direct predecessors of the\n * specified vertex.\n */\npublic static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> predecessors = new ArrayList<V>();\n    Set<? extends E> edges = g.incomingEdgesOf(vertex);\n    for (E e : edges) {\n        predecessors.add(getOppositeVertex(g, e, vertex));\n    }\n    return predecessors;\n}"
            ],
            [
                "successorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct successors of a specified\n * vertex. If the graph is a multigraph vertices may appear more than once\n * in the returned list.\n *\n * @param g the graph to look for successors in.\n * @param vertex the vertex to get the successors of.\n *\n * @return a list of the vertices that are the direct successors of the\n * specified vertex.\n */\npublic static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> successors = new ArrayList<V>();\n    Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n    for (E e : edges) {\n        successors.add(getOppositeVertex(g, e, vertex));\n    }\n    return successors;\n}"
            ],
            [
                "undirectedGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns an undirected view of the specified graph. If the specified graph\n * is directed, returns an undirected view of it. If the specified graph is\n * already undirected, just returns it.\n *\n * @param g the graph for which an undirected view is to be returned.\n *\n * @return an undirected view of the specified graph, if it is directed, or\n * or the specified graph itself if it is already undirected.\n *\n * @throws IllegalArgumentException if the graph is neither DirectedGraph\n * nor UndirectedGraph.\n *\n * @see AsUndirectedGraph\n */\npublic static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n    } else if (g instanceof UndirectedGraph<?, ?>) {\n        return (UndirectedGraph<V, E>) g;\n    } else {\n        throw new IllegalArgumentException(\"Graph must be either DirectedGraph or UndirectedGraph\");\n    }\n}"
            ],
            [
                "testIncidence",
                "org.jgrapht",
                "Graphs",
                "/**\n * Tests whether an edge is incident to a vertex.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return true iff e is incident on v\n */\npublic static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v) {\n    return (g.getEdgeSource(e).equals(v)) || (g.getEdgeTarget(e).equals(v));\n}"
            ],
            [
                "getOppositeVertex",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the vertex opposite another vertex across an edge.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return vertex opposite to v across e\n */\npublic static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v) {\n    V source = g.getEdgeSource(e);\n    V target = g.getEdgeTarget(e);\n    if (v.equals(source)) {\n        return target;\n    } else if (v.equals(target)) {\n        return source;\n    } else {\n        throw new IllegalArgumentException(\"no such vertex: \" + v.toString());\n    }\n}"
            ],
            [
                "getPathVertexList",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the list of vertices visited by a path.\n *\n * @param path path of interest\n *\n * @return corresponding vertex list\n */\npublic static <V, E> List<V> getPathVertexList(GraphPath<V, E> path) {\n    Graph<V, E> g = path.getGraph();\n    List<V> list = new ArrayList<V>();\n    V v = path.getStartVertex();\n    list.add(v);\n    for (E e : path.getEdgeList()) {\n        v = getOppositeVertex(g, e, v);\n        list.add(v);\n    }\n    return list;\n}"
            ],
            [
                "range",
                "org.jgrapht.generate",
                "SimpleWeightedGraphMatrixGenerator",
                "///////////////////////////////////////////////////////////////////////////////////////////////\npublic static int[] range(final int from, final int to) {\n    int[] range = new int[to - from];\n    for (int i = from; i < to; ++i) {\n        range[i - from] = i;\n    }\n    return range;\n}"
            ],
            [
                "createGraphSpecifics",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "// -------------------------------------------------------------------------\n/**\n * @param <V>\n * @param <E>\n * @param g\n *\n * @return TODO Document me\n */\nstatic <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new DirectedSpecifics<V, E>((DirectedGraph<V, E>) g);\n    } else {\n        return new UndirectedSpecifics<V, E>(g);\n    }\n}"
            ],
            [
                "findGreedyChromaticNumber",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds the number of colors required for a greedy coloring of the graph.\n *\n * @param g an undirected graph to find the chromatic number of\n *\n * @return integer the approximate chromatic number from the greedy\n * algorithm\n */\npublic static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g) {\n    Map<Integer, Set<V>> coloredGroups = findGreedyColoredGroups(g);\n    return coloredGroups.keySet().size();\n}"
            ],
            [
                "findGreedyColoredGroups",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds a greedy coloring of the graph.\n *\n * @param g an undirected graph for which to find the coloring\n */\npublic static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g) {\n    // A copy of the graph is made, so that elements of the graph may be\n    // removed to carry out the algorithm\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // The Vertices will be sorted in decreasing order by degree, so that\n    // higher degree vertices have priority to be colored first\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    List<V> sortedVertices = new LinkedList<V>(sg.vertexSet());\n    Collections.sort(sortedVertices, comp);\n    Collections.reverse(sortedVertices);\n    int color;\n    // create a map which will hold color as key and Set<V> as value\n    Map<Integer, Set<V>> coloredGroups = new HashMap<Integer, Set<V>>();\n    // We'll attempt to color each vertex with a single color each\n    // iteration, and these vertices will be removed from the graph at the\n    // end of each iteration\n    for (color = 0; sg.vertexSet().size() > 0; color++) {\n        // This set will contain vertices that are colored with the\n        // current color of this iteration\n        Set<V> currentColor = new HashSet<V>();\n        for (Iterator<V> iter = sortedVertices.iterator(); iter.hasNext(); ) {\n            V v = iter.next();\n            // Add new vertices to be colored as long as they are not\n            // adjacent with any other vertex that has already been colored\n            // with the current color\n            boolean flag = true;\n            for (Iterator<V> innerIter = currentColor.iterator(); innerIter.hasNext(); ) {\n                V temp = innerIter.next();\n                if (sg.containsEdge(temp, v)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                currentColor.add(v);\n                iter.remove();\n            }\n        }\n        // Add all these vertices as a group for this color\n        coloredGroups.put(color, currentColor);\n        // Remove vertices from the graph and then repeat the process for\n        // the next iteration\n        sg.removeAllVertices(currentColor);\n    }\n    return coloredGroups;\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "BellmanFordShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by hops, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    BellmanFordShortestPath<V, E> alg = new BellmanFordShortestPath<V, E>(graph, startVertex);\n    return alg.getPathEdgeList(endVertex);\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "DijkstraShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by radius, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    DijkstraShortestPath<V, E> alg = new DijkstraShortestPath<V, E>(graph, startVertex, endVertex);\n    return alg.getPathEdgeList();\n}"
            ],
            [
                "of",
                "org.jgrapht.alg.util",
                "Pair",
                "/**\n * Creates new pair of elements pulling of the necessity to provide\n * corresponding types of the elements supplied\n *\n * @param a first element\n * @param b second element\n *\n * @return new pair\n */\npublic static <A, B> Pair<A, B> of(A a, B b) {\n    return new Pair<A, B>(a, b);\n}"
            ],
            [
                "isEulerian",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will check whether the graph passed in is Eulerian or not.\n *\n * @param g The graph to be checked\n *\n * @return true for Eulerian and false for non-Eulerian\n */\npublic static <V, E> boolean isEulerian(UndirectedGraph<V, E> g) {\n    // If the graph is not connected, then no Eulerian circuit exists\n    if (!(new ConnectivityInspector<V, E>(g)).isGraphConnected()) {\n        return false;\n    }\n    // A graph is Eulerian if and only if all vertices have even degree\n    // So, this code will check for that\n    Iterator<V> iter = g.vertexSet().iterator();\n    while (iter.hasNext()) {\n        V v = iter.next();\n        if ((g.degreeOf(v) % 2) == 1) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "getEulerianCircuitVertices",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will return a list of vertices which represents the Eulerian\n * circuit of the graph.\n *\n * @param g The graph to find an Eulerian circuit\n *\n * @return null if no Eulerian circuit exists, or a list of vertices\n * representing the Eulerian circuit if one does exist\n */\npublic static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g) {\n    // If the graph is not Eulerian then just return a null since no\n    // Eulerian circuit exists\n    if (!isEulerian(g)) {\n        return null;\n    }\n    // The circuit will be represented by a linked list\n    List<V> path = new LinkedList<V>();\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    path.add(sg.vertexSet().iterator().next());\n    // Algorithm for finding an Eulerian circuit Basically this will find an\n    // arbitrary circuit, then it will find another arbitrary circuit until\n    // every edge has been traversed\n    while (sg.edgeSet().size() > 0) {\n        V v = null;\n        // Find a vertex which has an edge that hasn't been traversed yet,\n        // and keep its index position in the circuit list\n        int index = 0;\n        for (Iterator<V> iter = path.iterator(); iter.hasNext(); index++) {\n            v = iter.next();\n            if (sg.degreeOf(v) > 0) {\n                break;\n            }\n        }\n        // Finds an arbitrary circuit of the current vertex and\n        // appends this into the circuit list\n        while (sg.degreeOf(v) > 0) {\n            for (Iterator<V> iter = sg.vertexSet().iterator(); iter.hasNext(); ) {\n                V temp = iter.next();\n                if (sg.containsEdge(v, temp)) {\n                    path.add(index, temp);\n                    sg.removeEdge(v, temp);\n                    v = temp;\n                    break;\n                }\n            }\n        }\n    }\n    return path;\n}"
            ],
            [
                "getApproximateOptimalForCompleteGraph",
                "org.jgrapht.alg",
                "HamiltonianCycle",
                "/**\n * This method will return an approximate minimal traveling salesman tour\n * (hamiltonian cycle). This algorithm requires that the graph be complete\n * and the triangle inequality exists (if x,y,z are vertices then\n * d(x,y)+d(y,z) &lt; d(x,z) for all x,y,z) then this algorithm will\n * guarantee a hamiltonian cycle such that the total weight of the cycle is\n * less than or equal to double the total weight of the optimal hamiltonian\n * cycle. The optimal solution is NP-complete, so this is a decent\n * approximation that runs in polynomial time.\n *\n * @param <V>\n * @param <E>\n * @param g is the graph to find the optimal tour for.\n *\n * @return The optimal tour as a list of vertices.\n */\npublic static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g) {\n    List<V> vertices = new LinkedList<V>(g.vertexSet());\n    // If the graph is not complete then return null since this algorithm\n    // requires the graph be complete\n    if ((vertices.size() * (vertices.size() - 1) / 2) != g.edgeSet().size()) {\n        return null;\n    }\n    List<V> tour = new LinkedList<V>();\n    // Each iteration a new vertex will be added to the tour until all\n    // vertices have been added\n    while (tour.size() != g.vertexSet().size()) {\n        boolean firstEdge = true;\n        double minEdgeValue = 0;\n        int minVertexFound = 0;\n        int vertexConnectedTo = 0;\n        // A check will be made for the shortest edge to a vertex not within\n        // the tour and that new vertex will be added to the vertex\n        for (int i = 0; i < tour.size(); i++) {\n            V v = tour.get(i);\n            for (int j = 0; j < vertices.size(); j++) {\n                double weight = g.getEdgeWeight(g.getEdge(v, vertices.get(j)));\n                if (firstEdge || (weight < minEdgeValue)) {\n                    firstEdge = false;\n                    minEdgeValue = weight;\n                    minVertexFound = j;\n                    vertexConnectedTo = i;\n                }\n            }\n        }\n        tour.add(vertexConnectedTo, vertices.get(minVertexFound));\n        vertices.remove(minVertexFound);\n    }\n    return tour;\n}"
            ],
            [
                "find2ApproximationCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a 2-approximation for a minimal vertex cover of the specified\n * graph. The algorithm promises a cover that is at most double the size of\n * a minimal cover. The algorithm takes O(|E|) time.\n *\n * <p>For more details see Jenny Walter, CMPU-240: Lecture notes for\n * Language Theory and Computation, Fall 2002, Vassar College, <a\n * href=\"http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf\">\n * http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf</a>.\n * </p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G'=(V',E') <-- G(V,E)\n    Subgraph<V, E, Graph<V, E>> sg = new Subgraph<V, E, Graph<V, E>>(g, null, null);\n    // while E' is non-empty\n    while (sg.edgeSet().size() > 0) {\n        // let (u,v) be an arbitrary edge of E'\n        E e = sg.edgeSet().iterator().next();\n        // C <-- C U {u,v}\n        V u = g.getEdgeSource(e);\n        V v = g.getEdgeTarget(e);\n        cover.add(u);\n        cover.add(v);\n        // remove from E' every edge incident on either u or v\n        sg.removeVertex(u);\n        sg.removeVertex(v);\n    }\n    // return C\n    return cover;\n}"
            ],
            [
                "findGreedyCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a greedy approximation for a minimal vertex cover of a specified\n * graph. At each iteration, the algorithm picks the vertex with the highest\n * degree and adds it to the cover, until all edges are covered.\n *\n * <p>The algorithm works on undirected graphs, but can also work on\n * directed graphs when their edge-directions are ignored. To ignore edge\n * directions you can use {@link org.jgrapht.Graphs#undirectedGraph(Graph)}\n * or {@link org.jgrapht.graph.AsUndirectedGraph}.</p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G' <-- G\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // compare vertices in descending order of degree\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    // while G' != {}\n    while (sg.edgeSet().size() > 0) {\n        // v <-- vertex with maximum degree in G'\n        V v = Collections.max(sg.vertexSet(), comp);\n        // C <-- C U {v}\n        cover.add(v);\n        // remove from G' every edge incident on v, and v itself\n        sg.removeVertex(v);\n    }\n    return cover;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "BEST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int BEST_ORDER = 0;"
            ],
            [
                "NATURAL_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int NATURAL_ORDER = 1;"
            ],
            [
                "SMALLEST_DEGREE_LAST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;"
            ],
            [
                "LARGEST_SATURATION_FIRST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;"
            ],
            [
                "DEFAULT_EDGE_WEIGHT",
                "org.jgrapht",
                "WeightedGraph",
                "/**\n * The default weight for an edge.\n */\npublic static double DEFAULT_EDGE_WEIGHT = 1.0;"
            ],
            [
                "HUB_VERTEX",
                "org.jgrapht.generate",
                "WheelGraphGenerator",
                "/**\n * Role for the hub vertex.\n */\npublic static final String HUB_VERTEX = \"Hub Vertex\";"
            ],
            [
                "CORNER_VERTEX",
                "org.jgrapht.generate",
                "GridGraphGenerator",
                "/**\n * Role for the vertices at the corners.\n */\npublic static final String CORNER_VERTEX = \"Corner Vertex\";"
            ],
            [
                "START_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the first vertex generated.\n */\npublic static final String START_VERTEX = \"Start Vertex\";"
            ],
            [
                "END_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the last vertex generated.\n */\npublic static final String END_VERTEX = \"End Vertex\";"
            ],
            [
                "CENTER_VERTEX",
                "org.jgrapht.generate",
                "StarGraphGenerator",
                "public static final String CENTER_VERTEX = \"Center Vertex\";"
            ],
            [
                "SENTINEL",
                "org.jgrapht.traverse",
                "DepthFirstIterator",
                "/**\n * Sentinel object. Unfortunately, we can't use null, because ArrayDeque\n * won't accept those. And we don't want to rely on the caller to provide a\n * sentinel object for us. So we have to play typecasting games.\n */\npublic static final Object SENTINEL = new Object();"
            ],
            [
                "BEFORE_EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge added event. This event is fired before an edge is added to a\n * graph.\n */\npublic static final int BEFORE_EDGE_ADDED = 21;"
            ],
            [
                "BEFORE_EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge removed event. This event is fired before an edge is removed\n * from a graph.\n */\npublic static final int BEFORE_EDGE_REMOVED = 22;"
            ],
            [
                "EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge added event. This event is fired after an edge is added to a graph.\n */\npublic static final int EDGE_ADDED = 23;"
            ],
            [
                "EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge removed event. This event is fired after an edge is removed from a\n * graph.\n */\npublic static final int EDGE_REMOVED = 24;"
            ],
            [
                "CONNECTED_COMPONENT_STARTED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal started event.\n */\npublic static final int CONNECTED_COMPONENT_STARTED = 31;"
            ],
            [
                "CONNECTED_COMPONENT_FINISHED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal finished event.\n */\npublic static final int CONNECTED_COMPONENT_FINISHED = 32;"
            ],
            [
                "BEFORE_VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex added event. This event is fired before a vertex is added\n * to a graph.\n */\npublic static final int BEFORE_VERTEX_ADDED = 11;"
            ],
            [
                "BEFORE_VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex removed event. This event is fired before a vertex is\n * removed from a graph.\n */\npublic static final int BEFORE_VERTEX_REMOVED = 12;"
            ],
            [
                "VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex added event. This event is fired after a vertex is added to a\n * graph.\n */\npublic static final int VERTEX_ADDED = 13;"
            ],
            [
                "VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex removed event. This event is fired after a vertex is removed from\n * a graph.\n */\npublic static final int VERTEX_REMOVED = 14;"
            ],
            [
                "NULL_NODE",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "public static final int NULL_NODE = -1;"
            ],
            [
                "DEBUG",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected static final boolean DEBUG = false;"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg",
                "EdmondsKarpMaximumFlow",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 0.000000001;"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveClosure",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveClosure INSTANCE = new TransitiveClosure();"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveReduction",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveReduction INSTANCE = new TransitiveReduction();"
            ],
            [
                "NEGATIVE_UNDIRECTED_EDGE",
                "org.jgrapht.alg",
                "BellmanFordIterator",
                "/**\n * Error message.\n */\nprotected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg.flow",
                "MaximumFlowAlgorithmBase",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 1e-9;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [
            [
                "size",
                "",
                "int"
            ],
            [
                "inwardSpokes",
                "",
                "boolean"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 26128,
        "oracle": "size < 0;",
        "oracleType": "EXCEPT_POST",
        "projectName": "jgrapht-core-0.9.2",
        "packageName": "org.jgrapht.generate",
        "className": "WheelGraphGenerator",
        "javadocTag": "@throws IllegalArgumentException",
        "methodJavadoc": "    /**\n     * Construct a new WheelGraphGenerator.\n     *\n     * @param size number of vertices to be generated.\n     * @param inwardSpokes if <code>true</code> and graph is directed, spokes\n     * are oriented from rim to hub; else from hub to rim.\n     *\n     * @throws IllegalArgumentException\n     */",
        "methodSourceCode": "public WheelGraphGenerator(int size, boolean inwardSpokes){\n    if (size < 0) {\n        throw new IllegalArgumentException(\"must be non-negative\");\n    }\n    this.size = size;\n    this.inwardSpokes = inwardSpokes;\n}",
        "classJavadoc": "/**\n * Generates a <a href=\"http://mathworld.wolfram.com/WheelGraph.html\">wheel\n * graph</a> of any size. Reminding a bicycle wheel, a wheel graph has a hub\n * vertex in the center and a rim of vertices around it that are connected to\n * each other (as a ring). The rim vertices are also connected to the hub with\n * edges that are called \"spokes\".\n *\n * @author John V. Sichi\n * @since Sep 16, 2003\n */",
        "classSourceCode": "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------\n * WheelGraphGenerator.java\n * -------------------\n * (C) Copyright 2003-2008, by John V. Sichi and Contributors.\n *\n * Original Author:  John V. Sichi\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n * 16-Sep-2003 : Initial revision (JVS);\n *\n */\npackage org.jgrapht.generate;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\n\n\n/**\n * Generates a <a href=\"http://mathworld.wolfram.com/WheelGraph.html\">wheel\n * graph</a> of any size. Reminding a bicycle wheel, a wheel graph has a hub\n * vertex in the center and a rim of vertices around it that are connected to\n * each other (as a ring). The rim vertices are also connected to the hub with\n * edges that are called \"spokes\".\n *\n * @author John V. Sichi\n * @since Sep 16, 2003\n */\npublic class WheelGraphGenerator<V, E>\n    implements GraphGenerator<V, E, V>\n{\n    /**\n     * Role for the hub vertex.\n     */\n    public static final String HUB_VERTEX = \"Hub Vertex\";\n\n    private boolean inwardSpokes;\n    private int size;\n\n    /**\n     * Creates a new WheelGraphGenerator object. This constructor is more\n     * suitable for undirected graphs, where spokes' direction is meaningless.\n     * In the directed case, spokes will be oriented from rim to hub.\n     *\n     * @param size number of vertices to be generated.\n     */\n    public WheelGraphGenerator(int size)\n    {\n        this(size, true);\n    }\n\n    /**\n     * Construct a new WheelGraphGenerator.\n     *\n     * @param size number of vertices to be generated.\n     * @param inwardSpokes if <code>true</code> and graph is directed, spokes\n     * are oriented from rim to hub; else from hub to rim.\n     *\n     * @throws IllegalArgumentException\n     */\n    public WheelGraphGenerator(int size, boolean inwardSpokes)\n    {\n        if (size < 0) {\n            throw new IllegalArgumentException(\"must be non-negative\");\n        }\n\n        this.size = size;\n        this.inwardSpokes = inwardSpokes;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override public void generateGraph(\n        Graph<V, E> target,\n        final VertexFactory<V> vertexFactory,\n        Map<String, V> resultMap)\n    {\n        if (size < 1) {\n            return;\n        }\n\n        // A little trickery to intercept the rim generation.  This is\n        // necessary since target may be initially non-empty, meaning we can't\n        // rely on its vertex set after the rim is generated.\n        final Collection<V> rim = new ArrayList<V>();\n        VertexFactory<V> rimVertexFactory =\n            new VertexFactory<V>() {\n                @Override public V createVertex()\n                {\n                    V vertex = vertexFactory.createVertex();\n                    rim.add(vertex);\n\n                    return vertex;\n                }\n            };\n\n        RingGraphGenerator<V, E> ringGenerator =\n            new RingGraphGenerator<V, E>(size - 1);\n        ringGenerator.generateGraph(target, rimVertexFactory, resultMap);\n\n        V hubVertex = vertexFactory.createVertex();\n        target.addVertex(hubVertex);\n\n        if (resultMap != null) {\n            resultMap.put(HUB_VERTEX, hubVertex);\n        }\n\n        for (V rimVertex : rim) {\n            if (inwardSpokes) {\n                target.addEdge(rimVertex, hubVertex);\n            } else {\n                target.addEdge(hubVertex, rimVertex);\n            }\n        }\n    }\n}\n\n// End WheelGraphGenerator.java\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "PartiteRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "RandomGraphHelper",
                "org.jgrapht.experimental"
            ],
            [
                "GraphReader",
                "org.jgrapht.experimental"
            ],
            [
                "DirectedAcyclicGraph",
                "org.jgrapht.experimental.dag"
            ],
            [
                "GraphSquare",
                "org.jgrapht.experimental"
            ],
            [
                "UniformRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "GraphTests",
                "org.jgrapht.experimental"
            ],
            [
                "ApproximationAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "BrownBacktrackColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "GreedyColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "IntArrayGraphAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ExactAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ListenableGraph",
                "org.jgrapht"
            ],
            [
                "ModifiableInteger",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeapNode",
                "org.jgrapht.util"
            ],
            [
                "WeightCombiner",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeap",
                "org.jgrapht.util"
            ],
            [
                "TypeUtil",
                "org.jgrapht.util"
            ],
            [
                "ArrayUnenforcedSet",
                "org.jgrapht.util"
            ],
            [
                "VertexPair",
                "org.jgrapht.util"
            ],
            [
                "MathUtil",
                "org.jgrapht.util"
            ],
            [
                "PrefetchIterator",
                "org.jgrapht.util"
            ],
            [
                "VertexFactory",
                "org.jgrapht"
            ],
            [
                "Graph",
                "org.jgrapht"
            ],
            [
                "GraphPath",
                "org.jgrapht"
            ],
            [
                "UndirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraph",
                "org.jgrapht.graph"
            ],
            [
                "MixedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DefaultGraphMapping",
                "org.jgrapht.graph"
            ],
            [
                "WeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskEdgeSet",
                "org.jgrapht.graph"
            ],
            [
                "Pseudograph",
                "org.jgrapht.graph"
            ],
            [
                "MaskFunctor",
                "org.jgrapht.graph"
            ],
            [
                "GraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractBaseGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "Multigraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultWeightedEdge",
                "org.jgrapht.graph"
            ],
            [
                "ListenableDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeSetFactory",
                "org.jgrapht.graph"
            ],
            [
                "GraphDelegator",
                "org.jgrapht.graph"
            ],
            [
                "DefaultListenableGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedVertexFactory",
                "org.jgrapht.graph"
            ],
            [
                "DefaultEdge",
                "org.jgrapht.graph"
            ],
            [
                "MaskVertexSet",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "IntrusiveEdge",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphPathImpl",
                "org.jgrapht.graph"
            ],
            [
                "Subgraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractGraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedEdgeFactory",
                "org.jgrapht.graph"
            ],
            [
                "SimpleWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "WeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeReversedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "AbstractGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "ListenableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraphPath",
                "org.jgrapht.graph"
            ],
            [
                "ParanoidGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphHelper",
                "org.jgrapht"
            ],
            [
                "Graphs",
                "org.jgrapht"
            ],
            [
                "DirectedGraph",
                "org.jgrapht"
            ],
            [
                "WeightedGraph",
                "org.jgrapht"
            ],
            [
                "HyperCubeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RingGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WheelGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GridGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "ScaleFreeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedBipartiteGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "LinearGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RandomGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGeneratorAdapter",
                "org.jgrapht.generate"
            ],
            [
                "EmptyGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteBipartiteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "StarGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "UndirectedGraph",
                "org.jgrapht"
            ],
            [
                "TopologicalOrderIterator",
                "org.jgrapht.traverse"
            ],
            [
                "CrossComponentIterator",
                "org.jgrapht.traverse"
            ],
            [
                "AbstractGraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "ClosestFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "BreadthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "DepthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "GraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "EdgeFactory",
                "org.jgrapht"
            ],
            [
                "GraphMapping",
                "org.jgrapht"
            ],
            [
                "VertexSetListener",
                "org.jgrapht.event"
            ],
            [
                "EdgeTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "TraversalListener",
                "org.jgrapht.event"
            ],
            [
                "GraphEdgeChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "VertexTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphListener",
                "org.jgrapht.event"
            ],
            [
                "TraversalListenerAdapter",
                "org.jgrapht.event"
            ],
            [
                "ConnectedComponentTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphVertexChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "TarjanLowestCommonAncestor",
                "org.jgrapht.alg"
            ],
            [
                "PrimMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "BlockCutpointGraph",
                "org.jgrapht.alg"
            ],
            [
                "AllDirectedPaths",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPathsIterator",
                "org.jgrapht.alg"
            ],
            [
                "KruskalMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "StrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "VF2State",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2AbstractIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "GraphOrdering",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphicGraphMapping",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2MappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "BronKerboschCliqueFinder",
                "org.jgrapht.alg"
            ],
            [
                "ChromaticNumber",
                "org.jgrapht.alg"
            ],
            [
                "KosarajuStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "DijkstraShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElement",
                "org.jgrapht.alg"
            ],
            [
                "AStarShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordPathElement",
                "org.jgrapht.alg"
            ],
            [
                "FloydWarshallShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "UnionFind",
                "org.jgrapht.alg.util"
            ],
            [
                "AlwaysEqualComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Extension",
                "org.jgrapht.alg.util"
            ],
            [
                "VertexDegreeComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Pair",
                "org.jgrapht.alg.util"
            ],
            [
                "GabowStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "HawickJamesSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "DirectedSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "JohnsonSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TiernanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "UndirectedCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "PatonCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TarjanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "SzwarcfiterLauerSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "BiconnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "ConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "MinSourceSinkCut",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsBlossomShrinking",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveClosure",
                "org.jgrapht.alg"
            ],
            [
                "HopcroftKarpBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "StoerWagnerMinimumCut",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "KuhnMunkresMinimalWeightBipartitePerfectMatching",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveReduction",
                "org.jgrapht.alg"
            ],
            [
                "EulerianCircuit",
                "org.jgrapht.alg"
            ],
            [
                "DirectedNeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "NaiveLcaFinder",
                "org.jgrapht.alg"
            ],
            [
                "MaximumWeightBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "HamiltonianCycle",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "NeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "VertexCovers",
                "org.jgrapht.alg"
            ],
            [
                "CycleDetector",
                "org.jgrapht.alg"
            ],
            [
                "AStarAdmissibleHeuristic",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MinimumSpanningTree",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "WeightedMatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "StrongConnectivityAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MaximumFlowAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "CliqueMinimalSeparatorDecomposition",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordIterator",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElement",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "PushRelabelMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "MaximumFlowAlgorithmBase",
                "org.jgrapht.alg.flow"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "addVertices",
                "org.jgrapht.experimental",
                "RandomGraphHelper",
                "/**\n * .\n *\n * @param target\n * @param vertexFactory\n * @param numVertices\n *\n * @return vertices\n */\n@SuppressWarnings(\"unchecked\")\npublic static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices) {\n    Object[] vertices = new Object[numVertices];\n    for (int i = 0; i < numVertices; ++i) {\n        vertices[i] = vertexFactory.createVertex();\n        target.addVertex(vertices[i]);\n    }\n    return vertices;\n}"
            ],
            [
                "isEmpty",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isEmpty(Graph<V, E> g) {\n    return g.edgeSet().isEmpty();\n}"
            ],
            [
                "isComplete",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isComplete(Graph<V, E> g) {\n    int n = g.vertexSet().size();\n    return g.edgeSet().size() == (n * (n - 1) / 2);\n}"
            ],
            [
                "isConnected",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isConnected(Graph<V, E> g) {\n    int numVertices = g.vertexSet().size();\n    int numEdges = g.edgeSet().size();\n    if (numEdges < (numVertices - 1)) {\n        return false;\n    }\n    if ((numVertices < 2) || (numEdges > ((numVertices - 1) * (numVertices - 2) / 2))) {\n        return true;\n    }\n    Set<V> known = new HashSet<V>();\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = g.vertexSet().iterator().next();\n    // start with node 1\n    queue.add(v);\n    known.add(v);\n    while (!queue.isEmpty()) {\n        v = queue.removeFirst();\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            v = it.next();\n            if (!known.contains(v)) {\n                known.add(v);\n                queue.add(v);\n            }\n        }\n    }\n    return known.size() == numVertices;\n}"
            ],
            [
                "isTree",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isTree(Graph<V, E> g) {\n    return isConnected(g) && (g.edgeSet().size() == (g.vertexSet().size() - 1));\n}"
            ],
            [
                "isBipartite",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isBipartite(Graph<V, E> g) {\n    if ((4 * g.edgeSet().size()) > (g.vertexSet().size() * g.vertexSet().size())) {\n        return false;\n    }\n    if (isEmpty(g)) {\n        return true;\n    }\n    Set<V> unknown = new HashSet<V>(g.vertexSet());\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = unknown.iterator().next();\n    Set<V> odd = new HashSet<V>();\n    queue.add(v);\n    while (!unknown.isEmpty()) {\n        if (queue.isEmpty()) {\n            queue.add(unknown.iterator().next());\n        }\n        v = queue.removeFirst();\n        unknown.remove(v);\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            V n = it.next();\n            if (unknown.contains(n)) {\n                queue.add(n);\n                if (!odd.contains(v)) {\n                    odd.add(n);\n                }\n            } else if (!(odd.contains(v) ^ odd.contains(n))) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
            ],
            [
                "union",
                "org.jgrapht.util",
                "FibonacciHeap",
                "// size\n/**\n * Joins two Fibonacci heaps into a new one. No heap consolidation is\n * performed at this time. The two root lists are simply joined together.\n *\n * <p>Running time: O(1) actual</p>\n *\n * @param h1 first heap\n * @param h2 second heap\n *\n * @return new heap containing h1 and h2\n */\npublic static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2) {\n    FibonacciHeap<T> h = new FibonacciHeap<T>();\n    if ((h1 != null) && (h2 != null)) {\n        h.minNode = h1.minNode;\n        if (h.minNode != null) {\n            if (h2.minNode != null) {\n                h.minNode.right.left = h2.minNode.left;\n                h2.minNode.left.right = h.minNode.right;\n                h.minNode.right = h2.minNode;\n                h2.minNode.left = h.minNode;\n                if (h2.minNode.key < h1.minNode.key) {\n                    h.minNode = h2.minNode;\n                }\n            }\n        } else {\n            h.minNode = h2.minNode;\n        }\n        h.nNodes = h1.nNodes + h2.nNodes;\n    }\n    return h;\n}"
            ],
            [
                "uncheckedCast",
                "org.jgrapht.util",
                "TypeUtil",
                "/**\n * Casts an object to a type.\n *\n * @param o object to be cast\n * @param typeDecl conveys the target type information; the actual value is\n * unused and can be null since this is all just stupid compiler tricks\n *\n * @return the result of the cast\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl) {\n    return (T) o;\n}"
            ],
            [
                "factorial",
                "org.jgrapht.util",
                "MathUtil",
                "public static long factorial(int N) {\n    long multi = 1;\n    for (int i = 1; i <= N; i++) {\n        multi = multi * i;\n    }\n    return multi;\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graphs",
                "/**\n * Creates a new edge and adds it to the specified graph similarly to the\n * {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n *\n * @see Graph#addEdge(Object, Object)\n */\npublic static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    EdgeFactory<V, E> ef = g.getEdgeFactory();\n    E e = ef.createEdge(sourceVertex, targetVertex);\n    // we first create the edge and set the weight to make sure that\n    // listeners will see the correct weight upon addEdge.\n    assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n    ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n    return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new edge and adds it to the specified\n * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return g.addEdge(sourceVertex, targetVertex);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified edge to the graph, including its vertices if not\n * already included.\n *\n * @param targetGraph the graph for which the specified edge to be added.\n * @param sourceGraph the graph in which the specified edge is already\n * present\n * @param edge edge to add\n *\n * @return <tt>true</tt> if the target graph did not already contain the\n * specified edge.\n */\npublic static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge) {\n    V sourceVertex = sourceGraph.getEdgeSource(edge);\n    V targetVertex = sourceGraph.getEdgeTarget(edge);\n    targetGraph.addVertex(sourceVertex);\n    targetGraph.addVertex(targetVertex);\n    return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new weighted edge and adds it to the\n * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n * method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return addEdge(g, sourceVertex, targetVertex, weight);\n}"
            ],
            [
                "addGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all the vertices and all the edges of the specified source graph to\n * the specified destination graph. First all vertices of the source graph\n * are added to the destination graph. Then every edge of the source graph\n * is added to the destination graph. This method returns <code>true</code>\n * if the destination graph has been modified as a result of this operation,\n * otherwise it returns <code>false</code>.\n *\n * <p>The behavior of this operation is undefined if any of the specified\n * graphs is modified while operation is in progress.</p>\n *\n * @param destination the graph to which vertices and edges are added.\n * @param source the graph used as source for vertices and edges to add.\n *\n * @return <code>true</code> if and only if the destination graph has been\n * changed as a result of this operation.\n */\npublic static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source) {\n    boolean modified = addAllVertices(destination, source.vertexSet());\n    modified |= addAllEdges(destination, source, source.edgeSet());\n    return modified;\n}"
            ],
            [
                "addAllEdges",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds a subset of the edges of the specified source graph to the specified\n * destination graph. The behavior of this operation is undefined if either\n * of the graphs is modified while the operation is in progress. {@link\n * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n * be added automatically to the target graph.\n *\n * @param destination the graph to which edges are to be added\n * @param source the graph used as a source for edges to add\n * @param edges the edges to be added\n *\n * @return <tt>true</tt> if this graph changed as a result of the call\n */\npublic static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges) {\n    boolean modified = false;\n    for (E e : edges) {\n        V s = source.getEdgeSource(e);\n        V t = source.getEdgeTarget(e);\n        destination.addVertex(s);\n        destination.addVertex(t);\n        modified |= destination.addEdge(s, t, e);\n    }\n    return modified;\n}"
            ],
            [
                "addAllVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all of the specified vertices to the destination graph. The behavior\n * of this operation is undefined if the specified vertex collection is\n * modified while the operation is in progress. This method will invoke the\n * {@link Graph#addVertex(Object)} method.\n *\n * @param destination the graph to which edges are to be added\n * @param vertices the vertices to be added to the graph.\n *\n * @return <tt>true</tt> if graph changed as a result of the call\n *\n * @throws NullPointerException if the specified vertices contains one or\n * more null vertices, or if the specified vertex collection is <tt>\n * null</tt>.\n *\n * @see Graph#addVertex(Object)\n */\npublic static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices) {\n    boolean modified = false;\n    for (V v : vertices) {\n        modified |= destination.addVertex(v);\n    }\n    return modified;\n}"
            ],
            [
                "neighborListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the neighbors of a specified vertex.\n * If the graph is a multigraph vertices may appear more than once in the\n * returned list.\n *\n * @param g the graph to look for neighbors in.\n * @param vertex the vertex to get the neighbors of.\n *\n * @return a list of the vertices that are the neighbors of the specified\n * vertex.\n */\npublic static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex) {\n    List<V> neighbors = new ArrayList<V>();\n    for (E e : g.edgesOf(vertex)) {\n        neighbors.add(getOppositeVertex(g, e, vertex));\n    }\n    return neighbors;\n}"
            ],
            [
                "predecessorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct predecessors of a\n * specified vertex. If the graph is a multigraph, vertices may appear more\n * than once in the returned list.\n *\n * @param g the graph to look for predecessors in.\n * @param vertex the vertex to get the predecessors of.\n *\n * @return a list of the vertices that are the direct predecessors of the\n * specified vertex.\n */\npublic static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> predecessors = new ArrayList<V>();\n    Set<? extends E> edges = g.incomingEdgesOf(vertex);\n    for (E e : edges) {\n        predecessors.add(getOppositeVertex(g, e, vertex));\n    }\n    return predecessors;\n}"
            ],
            [
                "successorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct successors of a specified\n * vertex. If the graph is a multigraph vertices may appear more than once\n * in the returned list.\n *\n * @param g the graph to look for successors in.\n * @param vertex the vertex to get the successors of.\n *\n * @return a list of the vertices that are the direct successors of the\n * specified vertex.\n */\npublic static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> successors = new ArrayList<V>();\n    Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n    for (E e : edges) {\n        successors.add(getOppositeVertex(g, e, vertex));\n    }\n    return successors;\n}"
            ],
            [
                "undirectedGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns an undirected view of the specified graph. If the specified graph\n * is directed, returns an undirected view of it. If the specified graph is\n * already undirected, just returns it.\n *\n * @param g the graph for which an undirected view is to be returned.\n *\n * @return an undirected view of the specified graph, if it is directed, or\n * or the specified graph itself if it is already undirected.\n *\n * @throws IllegalArgumentException if the graph is neither DirectedGraph\n * nor UndirectedGraph.\n *\n * @see AsUndirectedGraph\n */\npublic static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n    } else if (g instanceof UndirectedGraph<?, ?>) {\n        return (UndirectedGraph<V, E>) g;\n    } else {\n        throw new IllegalArgumentException(\"Graph must be either DirectedGraph or UndirectedGraph\");\n    }\n}"
            ],
            [
                "testIncidence",
                "org.jgrapht",
                "Graphs",
                "/**\n * Tests whether an edge is incident to a vertex.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return true iff e is incident on v\n */\npublic static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v) {\n    return (g.getEdgeSource(e).equals(v)) || (g.getEdgeTarget(e).equals(v));\n}"
            ],
            [
                "getOppositeVertex",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the vertex opposite another vertex across an edge.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return vertex opposite to v across e\n */\npublic static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v) {\n    V source = g.getEdgeSource(e);\n    V target = g.getEdgeTarget(e);\n    if (v.equals(source)) {\n        return target;\n    } else if (v.equals(target)) {\n        return source;\n    } else {\n        throw new IllegalArgumentException(\"no such vertex: \" + v.toString());\n    }\n}"
            ],
            [
                "getPathVertexList",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the list of vertices visited by a path.\n *\n * @param path path of interest\n *\n * @return corresponding vertex list\n */\npublic static <V, E> List<V> getPathVertexList(GraphPath<V, E> path) {\n    Graph<V, E> g = path.getGraph();\n    List<V> list = new ArrayList<V>();\n    V v = path.getStartVertex();\n    list.add(v);\n    for (E e : path.getEdgeList()) {\n        v = getOppositeVertex(g, e, v);\n        list.add(v);\n    }\n    return list;\n}"
            ],
            [
                "range",
                "org.jgrapht.generate",
                "SimpleWeightedGraphMatrixGenerator",
                "///////////////////////////////////////////////////////////////////////////////////////////////\npublic static int[] range(final int from, final int to) {\n    int[] range = new int[to - from];\n    for (int i = from; i < to; ++i) {\n        range[i - from] = i;\n    }\n    return range;\n}"
            ],
            [
                "createGraphSpecifics",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "// -------------------------------------------------------------------------\n/**\n * @param <V>\n * @param <E>\n * @param g\n *\n * @return TODO Document me\n */\nstatic <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new DirectedSpecifics<V, E>((DirectedGraph<V, E>) g);\n    } else {\n        return new UndirectedSpecifics<V, E>(g);\n    }\n}"
            ],
            [
                "findGreedyChromaticNumber",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds the number of colors required for a greedy coloring of the graph.\n *\n * @param g an undirected graph to find the chromatic number of\n *\n * @return integer the approximate chromatic number from the greedy\n * algorithm\n */\npublic static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g) {\n    Map<Integer, Set<V>> coloredGroups = findGreedyColoredGroups(g);\n    return coloredGroups.keySet().size();\n}"
            ],
            [
                "findGreedyColoredGroups",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds a greedy coloring of the graph.\n *\n * @param g an undirected graph for which to find the coloring\n */\npublic static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g) {\n    // A copy of the graph is made, so that elements of the graph may be\n    // removed to carry out the algorithm\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // The Vertices will be sorted in decreasing order by degree, so that\n    // higher degree vertices have priority to be colored first\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    List<V> sortedVertices = new LinkedList<V>(sg.vertexSet());\n    Collections.sort(sortedVertices, comp);\n    Collections.reverse(sortedVertices);\n    int color;\n    // create a map which will hold color as key and Set<V> as value\n    Map<Integer, Set<V>> coloredGroups = new HashMap<Integer, Set<V>>();\n    // We'll attempt to color each vertex with a single color each\n    // iteration, and these vertices will be removed from the graph at the\n    // end of each iteration\n    for (color = 0; sg.vertexSet().size() > 0; color++) {\n        // This set will contain vertices that are colored with the\n        // current color of this iteration\n        Set<V> currentColor = new HashSet<V>();\n        for (Iterator<V> iter = sortedVertices.iterator(); iter.hasNext(); ) {\n            V v = iter.next();\n            // Add new vertices to be colored as long as they are not\n            // adjacent with any other vertex that has already been colored\n            // with the current color\n            boolean flag = true;\n            for (Iterator<V> innerIter = currentColor.iterator(); innerIter.hasNext(); ) {\n                V temp = innerIter.next();\n                if (sg.containsEdge(temp, v)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                currentColor.add(v);\n                iter.remove();\n            }\n        }\n        // Add all these vertices as a group for this color\n        coloredGroups.put(color, currentColor);\n        // Remove vertices from the graph and then repeat the process for\n        // the next iteration\n        sg.removeAllVertices(currentColor);\n    }\n    return coloredGroups;\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "BellmanFordShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by hops, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    BellmanFordShortestPath<V, E> alg = new BellmanFordShortestPath<V, E>(graph, startVertex);\n    return alg.getPathEdgeList(endVertex);\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "DijkstraShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by radius, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    DijkstraShortestPath<V, E> alg = new DijkstraShortestPath<V, E>(graph, startVertex, endVertex);\n    return alg.getPathEdgeList();\n}"
            ],
            [
                "of",
                "org.jgrapht.alg.util",
                "Pair",
                "/**\n * Creates new pair of elements pulling of the necessity to provide\n * corresponding types of the elements supplied\n *\n * @param a first element\n * @param b second element\n *\n * @return new pair\n */\npublic static <A, B> Pair<A, B> of(A a, B b) {\n    return new Pair<A, B>(a, b);\n}"
            ],
            [
                "isEulerian",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will check whether the graph passed in is Eulerian or not.\n *\n * @param g The graph to be checked\n *\n * @return true for Eulerian and false for non-Eulerian\n */\npublic static <V, E> boolean isEulerian(UndirectedGraph<V, E> g) {\n    // If the graph is not connected, then no Eulerian circuit exists\n    if (!(new ConnectivityInspector<V, E>(g)).isGraphConnected()) {\n        return false;\n    }\n    // A graph is Eulerian if and only if all vertices have even degree\n    // So, this code will check for that\n    Iterator<V> iter = g.vertexSet().iterator();\n    while (iter.hasNext()) {\n        V v = iter.next();\n        if ((g.degreeOf(v) % 2) == 1) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "getEulerianCircuitVertices",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will return a list of vertices which represents the Eulerian\n * circuit of the graph.\n *\n * @param g The graph to find an Eulerian circuit\n *\n * @return null if no Eulerian circuit exists, or a list of vertices\n * representing the Eulerian circuit if one does exist\n */\npublic static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g) {\n    // If the graph is not Eulerian then just return a null since no\n    // Eulerian circuit exists\n    if (!isEulerian(g)) {\n        return null;\n    }\n    // The circuit will be represented by a linked list\n    List<V> path = new LinkedList<V>();\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    path.add(sg.vertexSet().iterator().next());\n    // Algorithm for finding an Eulerian circuit Basically this will find an\n    // arbitrary circuit, then it will find another arbitrary circuit until\n    // every edge has been traversed\n    while (sg.edgeSet().size() > 0) {\n        V v = null;\n        // Find a vertex which has an edge that hasn't been traversed yet,\n        // and keep its index position in the circuit list\n        int index = 0;\n        for (Iterator<V> iter = path.iterator(); iter.hasNext(); index++) {\n            v = iter.next();\n            if (sg.degreeOf(v) > 0) {\n                break;\n            }\n        }\n        // Finds an arbitrary circuit of the current vertex and\n        // appends this into the circuit list\n        while (sg.degreeOf(v) > 0) {\n            for (Iterator<V> iter = sg.vertexSet().iterator(); iter.hasNext(); ) {\n                V temp = iter.next();\n                if (sg.containsEdge(v, temp)) {\n                    path.add(index, temp);\n                    sg.removeEdge(v, temp);\n                    v = temp;\n                    break;\n                }\n            }\n        }\n    }\n    return path;\n}"
            ],
            [
                "getApproximateOptimalForCompleteGraph",
                "org.jgrapht.alg",
                "HamiltonianCycle",
                "/**\n * This method will return an approximate minimal traveling salesman tour\n * (hamiltonian cycle). This algorithm requires that the graph be complete\n * and the triangle inequality exists (if x,y,z are vertices then\n * d(x,y)+d(y,z) &lt; d(x,z) for all x,y,z) then this algorithm will\n * guarantee a hamiltonian cycle such that the total weight of the cycle is\n * less than or equal to double the total weight of the optimal hamiltonian\n * cycle. The optimal solution is NP-complete, so this is a decent\n * approximation that runs in polynomial time.\n *\n * @param <V>\n * @param <E>\n * @param g is the graph to find the optimal tour for.\n *\n * @return The optimal tour as a list of vertices.\n */\npublic static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g) {\n    List<V> vertices = new LinkedList<V>(g.vertexSet());\n    // If the graph is not complete then return null since this algorithm\n    // requires the graph be complete\n    if ((vertices.size() * (vertices.size() - 1) / 2) != g.edgeSet().size()) {\n        return null;\n    }\n    List<V> tour = new LinkedList<V>();\n    // Each iteration a new vertex will be added to the tour until all\n    // vertices have been added\n    while (tour.size() != g.vertexSet().size()) {\n        boolean firstEdge = true;\n        double minEdgeValue = 0;\n        int minVertexFound = 0;\n        int vertexConnectedTo = 0;\n        // A check will be made for the shortest edge to a vertex not within\n        // the tour and that new vertex will be added to the vertex\n        for (int i = 0; i < tour.size(); i++) {\n            V v = tour.get(i);\n            for (int j = 0; j < vertices.size(); j++) {\n                double weight = g.getEdgeWeight(g.getEdge(v, vertices.get(j)));\n                if (firstEdge || (weight < minEdgeValue)) {\n                    firstEdge = false;\n                    minEdgeValue = weight;\n                    minVertexFound = j;\n                    vertexConnectedTo = i;\n                }\n            }\n        }\n        tour.add(vertexConnectedTo, vertices.get(minVertexFound));\n        vertices.remove(minVertexFound);\n    }\n    return tour;\n}"
            ],
            [
                "find2ApproximationCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a 2-approximation for a minimal vertex cover of the specified\n * graph. The algorithm promises a cover that is at most double the size of\n * a minimal cover. The algorithm takes O(|E|) time.\n *\n * <p>For more details see Jenny Walter, CMPU-240: Lecture notes for\n * Language Theory and Computation, Fall 2002, Vassar College, <a\n * href=\"http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf\">\n * http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf</a>.\n * </p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G'=(V',E') <-- G(V,E)\n    Subgraph<V, E, Graph<V, E>> sg = new Subgraph<V, E, Graph<V, E>>(g, null, null);\n    // while E' is non-empty\n    while (sg.edgeSet().size() > 0) {\n        // let (u,v) be an arbitrary edge of E'\n        E e = sg.edgeSet().iterator().next();\n        // C <-- C U {u,v}\n        V u = g.getEdgeSource(e);\n        V v = g.getEdgeTarget(e);\n        cover.add(u);\n        cover.add(v);\n        // remove from E' every edge incident on either u or v\n        sg.removeVertex(u);\n        sg.removeVertex(v);\n    }\n    // return C\n    return cover;\n}"
            ],
            [
                "findGreedyCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a greedy approximation for a minimal vertex cover of a specified\n * graph. At each iteration, the algorithm picks the vertex with the highest\n * degree and adds it to the cover, until all edges are covered.\n *\n * <p>The algorithm works on undirected graphs, but can also work on\n * directed graphs when their edge-directions are ignored. To ignore edge\n * directions you can use {@link org.jgrapht.Graphs#undirectedGraph(Graph)}\n * or {@link org.jgrapht.graph.AsUndirectedGraph}.</p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G' <-- G\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // compare vertices in descending order of degree\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    // while G' != {}\n    while (sg.edgeSet().size() > 0) {\n        // v <-- vertex with maximum degree in G'\n        V v = Collections.max(sg.vertexSet(), comp);\n        // C <-- C U {v}\n        cover.add(v);\n        // remove from G' every edge incident on v, and v itself\n        sg.removeVertex(v);\n    }\n    return cover;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "BEST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int BEST_ORDER = 0;"
            ],
            [
                "NATURAL_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int NATURAL_ORDER = 1;"
            ],
            [
                "SMALLEST_DEGREE_LAST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;"
            ],
            [
                "LARGEST_SATURATION_FIRST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;"
            ],
            [
                "DEFAULT_EDGE_WEIGHT",
                "org.jgrapht",
                "WeightedGraph",
                "/**\n * The default weight for an edge.\n */\npublic static double DEFAULT_EDGE_WEIGHT = 1.0;"
            ],
            [
                "HUB_VERTEX",
                "org.jgrapht.generate",
                "WheelGraphGenerator",
                "/**\n * Role for the hub vertex.\n */\npublic static final String HUB_VERTEX = \"Hub Vertex\";"
            ],
            [
                "CORNER_VERTEX",
                "org.jgrapht.generate",
                "GridGraphGenerator",
                "/**\n * Role for the vertices at the corners.\n */\npublic static final String CORNER_VERTEX = \"Corner Vertex\";"
            ],
            [
                "START_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the first vertex generated.\n */\npublic static final String START_VERTEX = \"Start Vertex\";"
            ],
            [
                "END_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the last vertex generated.\n */\npublic static final String END_VERTEX = \"End Vertex\";"
            ],
            [
                "CENTER_VERTEX",
                "org.jgrapht.generate",
                "StarGraphGenerator",
                "public static final String CENTER_VERTEX = \"Center Vertex\";"
            ],
            [
                "SENTINEL",
                "org.jgrapht.traverse",
                "DepthFirstIterator",
                "/**\n * Sentinel object. Unfortunately, we can't use null, because ArrayDeque\n * won't accept those. And we don't want to rely on the caller to provide a\n * sentinel object for us. So we have to play typecasting games.\n */\npublic static final Object SENTINEL = new Object();"
            ],
            [
                "BEFORE_EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge added event. This event is fired before an edge is added to a\n * graph.\n */\npublic static final int BEFORE_EDGE_ADDED = 21;"
            ],
            [
                "BEFORE_EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge removed event. This event is fired before an edge is removed\n * from a graph.\n */\npublic static final int BEFORE_EDGE_REMOVED = 22;"
            ],
            [
                "EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge added event. This event is fired after an edge is added to a graph.\n */\npublic static final int EDGE_ADDED = 23;"
            ],
            [
                "EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge removed event. This event is fired after an edge is removed from a\n * graph.\n */\npublic static final int EDGE_REMOVED = 24;"
            ],
            [
                "CONNECTED_COMPONENT_STARTED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal started event.\n */\npublic static final int CONNECTED_COMPONENT_STARTED = 31;"
            ],
            [
                "CONNECTED_COMPONENT_FINISHED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal finished event.\n */\npublic static final int CONNECTED_COMPONENT_FINISHED = 32;"
            ],
            [
                "BEFORE_VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex added event. This event is fired before a vertex is added\n * to a graph.\n */\npublic static final int BEFORE_VERTEX_ADDED = 11;"
            ],
            [
                "BEFORE_VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex removed event. This event is fired before a vertex is\n * removed from a graph.\n */\npublic static final int BEFORE_VERTEX_REMOVED = 12;"
            ],
            [
                "VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex added event. This event is fired after a vertex is added to a\n * graph.\n */\npublic static final int VERTEX_ADDED = 13;"
            ],
            [
                "VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex removed event. This event is fired after a vertex is removed from\n * a graph.\n */\npublic static final int VERTEX_REMOVED = 14;"
            ],
            [
                "NULL_NODE",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "public static final int NULL_NODE = -1;"
            ],
            [
                "DEBUG",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected static final boolean DEBUG = false;"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg",
                "EdmondsKarpMaximumFlow",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 0.000000001;"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveClosure",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveClosure INSTANCE = new TransitiveClosure();"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveReduction",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveReduction INSTANCE = new TransitiveReduction();"
            ],
            [
                "NEGATIVE_UNDIRECTED_EDGE",
                "org.jgrapht.alg",
                "BellmanFordIterator",
                "/**\n * Error message.\n */\nprotected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg.flow",
                "MaximumFlowAlgorithmBase",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 1e-9;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [
            [
                "size",
                "",
                "int"
            ],
            [
                "inwardSpokes",
                "",
                "boolean"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 26139,
        "oracle": ";",
        "oracleType": "EXCEPT_POST",
        "projectName": "jgrapht-core-0.9.2",
        "packageName": "org.jgrapht.generate",
        "className": "RandomGraphGenerator",
        "javadocTag": "@throws IllegalArgumentException if the aNumOfEdges passed in the\nconstructor, cannot be created on a graph of the concrete type with\naNumOfVertexes.\norg.jgrapht.generate.RandomGraphGenerator.DefaultEdgeTopologyFactory#isNumberOfEdgesValid(org.jgrapht.Graph,\nint)",
        "methodJavadoc": "    /**\n     * (non-Javadoc)\n     *\n     * @throws IllegalArgumentException if the aNumOfEdges passed in the\n     * constructor, cannot be created on a graph of the concrete type with\n     * aNumOfVertexes.\n     * org.jgrapht.generate.RandomGraphGenerator.DefaultEdgeTopologyFactory#isNumberOfEdgesValid(org.jgrapht.Graph,\n     * int)\n     *\n     * @see GraphGenerator#generateGraph(Graph, VertexFactory, Map)\n     */",
        "methodSourceCode": "public void generateGraph(Graph<V, E> target, VertexFactory<V> vertexFactory, Map<String, V> resultMap){\n    resetRandomSeed();\n    // key = generation order (1st,2nd,3rd,...) value=vertex Object\n    // will be used later\n    Map<Integer, V> orderToVertexMap = new HashMap<Integer, V>(this.numOfVertexes);\n    for (int i = 0; i < this.numOfVertexes; i++) {\n        V currVertex = vertexFactory.createVertex();\n        target.addVertex(currVertex);\n        orderToVertexMap.put(Integer.valueOf(i), currVertex);\n    }\n    if (target.vertexSet().size() != numOfVertexes) {\n        throw new IllegalArgumentException(\"Vertex factory did not produce \" + numOfVertexes + \" distinct vertices.\");\n    }\n    // use specific type of edge factory, depending of the graph type\n    // and edge density\n    EdgeTopologyFactory<V, E> edgesFactory = edgeTopologyFactoryChooser(target, numOfEdges);\n    if (!edgesFactory.isNumberOfEdgesValid(target, numOfEdges)) {\n        throw new IllegalArgumentException(\"numOfEdges is not valid for the graph type \" + \"\\n-> Invalid number Of Edges=\" + numOfEdges + \" for:\" + \" graph type=\" + target.getClass() + \" ,number Of Vertexes=\" + this.numOfVertexes + \"\\n-> Advice: For the Max value , check the javadoc for\" + \" org.jgrapht.generate.RandomGraphGenerator.DefaultEdgeTopologyFactory\");\n    }\n    edgesFactory.createEdges(target, orderToVertexMap, this.numOfEdges, this.randomizer);\n}",
        "classJavadoc": "/**\n * This Generator creates a random-topology graph of a specified number of\n * vertexes and edges. An instance of this generator will always return the same\n * graph-topology in calls to generateGraph(). The vertexes can be different\n * (depends on the VertexFactory implementation)\n *\n * <p>However, two instances which use the same constructor parameters will\n * produce two different random graphs (note: as with any random generator,\n * there is always a small possibility that two instances will create the same\n * results).\n *\n * @author Assaf Lehr\n * @since Aug 6, 2005\n */",
        "classSourceCode": "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -----------------\n * RandomGraphGenerator.java\n * -----------------\n * (C) Copyright 2005-2008, by Assaf Lehr and Contributors.\n *\n * Original Author:  Assaf Lehr\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n */\npackage org.jgrapht.generate;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\nimport org.jgrapht.graph.*;\n\n\n/**\n * This Generator creates a random-topology graph of a specified number of\n * vertexes and edges. An instance of this generator will always return the same\n * graph-topology in calls to generateGraph(). The vertexes can be different\n * (depends on the VertexFactory implementation)\n *\n * <p>However, two instances which use the same constructor parameters will\n * produce two different random graphs (note: as with any random generator,\n * there is always a small possibility that two instances will create the same\n * results).\n *\n * @author Assaf Lehr\n * @since Aug 6, 2005\n */\npublic class RandomGraphGenerator<V, E>\n    implements GraphGenerator<V, E, V>\n{\n    private static long seedUniquifier = 8682522807148012L;\n\n    protected int numOfVertexes;\n    protected int numOfEdges;\n    protected Random randomizer;\n    private long randomizerSeed;\n\n    public RandomGraphGenerator(int aNumOfVertexes, int aNumOfEdges)\n    {\n        this(aNumOfVertexes, aNumOfEdges, chooseRandomSeedOnce());\n    }\n\n    public RandomGraphGenerator(int aNumOfVertexes, int aNumOfEdges, long seed)\n    {\n        if ((aNumOfVertexes < 0) || (aNumOfEdges < 0)) {\n            throw new IllegalArgumentException(\"must be non-negative\");\n        }\n        this.numOfVertexes = aNumOfVertexes;\n        this.numOfEdges = aNumOfEdges;\n\n        this.randomizerSeed = seed;\n        this.randomizer = new Random(this.randomizerSeed);\n    }\n\n    /**\n     * Should be called only once on creation. Chooses a seed which can be used\n     * later to reset the randomizer before each method call. This\n     * implementation copies the java.util.Random constructor because there is\n     * no getSeed() there, and seed is protected.\n     *\n     * @author Assaf\n     * @since Aug 6, 2005\n     */\n    private synchronized static long chooseRandomSeedOnce()\n    {\n        return (++seedUniquifier + System.nanoTime());\n    }\n\n    /**\n     * Resets seed to generate the same random stream.\n     */\n    private void resetRandomSeed()\n    {\n        this.randomizer.setSeed(this.randomizerSeed);\n    }\n\n    public long getRandomSeed()\n    {\n        return this.randomizerSeed;\n    }\n\n    /**\n     * (non-Javadoc)\n     *\n     * @throws IllegalArgumentException if the aNumOfEdges passed in the\n     * constructor, cannot be created on a graph of the concrete type with\n     * aNumOfVertexes.\n     * org.jgrapht.generate.RandomGraphGenerator.DefaultEdgeTopologyFactory#isNumberOfEdgesValid(org.jgrapht.Graph,\n     * int)\n     *\n     * @see GraphGenerator#generateGraph(Graph, VertexFactory, Map)\n     */\n    @Override public void generateGraph(\n        Graph<V, E> target,\n        VertexFactory<V> vertexFactory,\n        Map<String, V> resultMap)\n    {\n        resetRandomSeed();\n\n        // key = generation order (1st,2nd,3rd,...) value=vertex Object\n        // will be used later\n        Map<Integer, V> orderToVertexMap =\n            new HashMap<Integer, V>(this.numOfVertexes);\n\n        for (int i = 0; i < this.numOfVertexes; i++) {\n            V currVertex = vertexFactory.createVertex();\n            target.addVertex(currVertex);\n            orderToVertexMap.put(Integer.valueOf(i), currVertex);\n        }\n\n        if (target.vertexSet().size() != numOfVertexes) {\n            throw new IllegalArgumentException(\n                \"Vertex factory did not produce \" + numOfVertexes\n                + \" distinct vertices.\");\n        }\n\n        // use specific type of edge factory, depending of the graph type\n        // and edge density\n        EdgeTopologyFactory<V, E> edgesFactory =\n            edgeTopologyFactoryChooser(target, numOfEdges);\n        if (!edgesFactory.isNumberOfEdgesValid(target, numOfEdges)) {\n            throw new IllegalArgumentException(\n                \"numOfEdges is not valid for the graph type \"\n                + \"\\n-> Invalid number Of Edges=\" + numOfEdges + \" for:\"\n                + \" graph type=\" + target.getClass()\n                + \" ,number Of Vertexes=\" + this.numOfVertexes\n                + \"\\n-> Advice: For the Max value , check the javadoc for\"\n                + \" org.jgrapht.generate.RandomGraphGenerator.DefaultEdgeTopologyFactory\");\n        }\n\n        edgesFactory.createEdges(\n            target,\n            orderToVertexMap,\n            this.numOfEdges,\n            this.randomizer);\n    }\n\n    /**\n     * Returns a concrete EdgeTopologyFactory, depending on graph type and\n     * numOfEdges\n     *\n     * @param target\n     *\n     * @return\n     */\n    private EdgeTopologyFactory<V, E> edgeTopologyFactoryChooser(\n        Graph<V, E> target,\n        int numOfEdges)\n    {\n        return new DefaultEdgeTopologyFactory<V, E>();\n    }\n\n    /**\n     * This class is used to generate the edge topology for a graph.\n     *\n     * @author Assaf\n     * @since Aug 6, 2005\n     */\n    public interface EdgeTopologyFactory<VV, EE>\n    {\n        /**\n         * Two different calls to the createEdges() with the same parameters\n         * must result in the generation of the same. But if the randomizer is\n         * different, it should, usually, create different edge topology.\n         *\n         * @param targetGraph - guranteed to start with zero edges.\n         * @param orderToVertexMap - key=Integer of vertex order . between zero\n         * to numOfVertexes (exclusive). value = vertex from the graph. unique.\n         * @param numberOfEdges - to create in the graph\n         * @param randomizer\n         */\n        public void createEdges(\n            Graph<VV, EE> targetGraph,\n            Map<Integer, VV> orderToVertexMap,\n            int numberOfEdges,\n            Random randomizer);\n\n        /**\n         * Checks if the graph can contain the givven numberOfEdges according to\n         * the graph type restrictions. For example:\n         *\n         * <ol>\n         * <li>#V means number of vertexes in graph\n         * <li>a Simple Graph, can have max of #V*(#V-1)/2 edges. etc\n         * </ol>\n         *\n         * @param targetGraph guranteed to start with zero edges.\n         * @param numberOfEdges\n         */\n        public boolean isNumberOfEdgesValid(\n            Graph<VV, EE> targetGraph,\n            int numberOfEdges);\n    }\n\n    /**\n     * Default implementation of the EdgeTopologyFactory interface. randomly\n     * chooses an edge and tries to add it. If the add fails from any reason\n     * (like: self edge / multiple edges in unpermitted graph type) it will just\n     * choose another and try again. Performance:\n     *\n     * <ol>\n     * <li>when the number of possible edges becomes slim , this class will have\n     * a very poor performance , cause it will not use gready methods to choose\n     * them. for example : In simple graph , if #V = N (#x = number Of x) and we\n     * want full mesh #edges= N*(N-1)/2 , the first added edges will do so\n     * quickly (O(1) , the last will take O(N^2). So , do not use it in this\n     * kind of graphs.</li>\n     * <li>If the numberOfEdges is bigger than what the graph can add, there\n     * will be an infinite loop here. It is not tested.</li>\n     * </ol>\n     *\n     * @author Assaf\n     * @since Aug 6, 2005\n     */\n    public class DefaultEdgeTopologyFactory<VV, EE>\n        implements EdgeTopologyFactory<VV, EE>\n    {\n        @Override public void createEdges(\n            Graph<VV, EE> targetGraph,\n            Map<Integer, VV> orderToVertexMap,\n            int numberOfEdges,\n            Random randomizer)\n        {\n            int iterationsCounter = 0;\n            int edgesCounter = 0;\n            while (edgesCounter < numberOfEdges) {\n                // randomizer.nextInt(int n) return a number between zero\n                // (inclusive) and n(exclusive)\n                VV startVertex =\n                    orderToVertexMap.get(\n                        Integer.valueOf(randomizer.nextInt(numOfVertexes)));\n                VV endVertex =\n                    orderToVertexMap.get(\n                        Integer.valueOf(randomizer.nextInt(numOfVertexes)));\n                try {\n                    EE resultEdge = targetGraph.addEdge(startVertex, endVertex);\n                    if (resultEdge != null) {\n                        edgesCounter++;\n                    }\n                } catch (Exception e) {\n                    // do nothing.just ignore the edge\n                }\n\n                iterationsCounter++;\n            }\n        }\n\n        /**\n         * checks if the numOfEdges is smaller than the Max edges according to\n         * the following table:\n         *\n         * <p>\n         * <table border=1 cellpadding=5>\n         * <caption></caption>\n         * <tr align=\"center\">\n         * <th>Graph Type</th>\n         * <th><i>Directed / UnDirected</i></th>\n         * <th><i>multiple edges</i></th>\n         * <th><i>loops</i></th>\n         * <th><i>Max Edges</i></th>\n         * </tr>\n         * <tr align=\"center\">\n         * <td>SimpleGraph</td>\n         * <td>UnDirected</td>\n         * <td>-</td>\n         * <td>-</td>\n         * <td>N(N-1)/2</td>\n         * </tr>\n         * <tr align=\"center\">\n         * <td>Multigraph</td>\n         * <td>UnDirected</td>\n         * <td>+</td>\n         * <td>-</td>\n         * <td>Infinite</td>\n         * </tr>\n         * <tr align=\"center\">\n         * <td>Pseudograph</td>\n         * <td>UnDirected</td>\n         * <td>+</td>\n         * <td>+</td>\n         * <td>Infinite</td>\n         * </tr>\n         * <tr align=\"center\">\n         * <td>SimpleDirectedGraph</td>\n         * <td>Directed</td>\n         * <td>-</td>\n         * <td>-</td>\n         * <td>N (N-1)</td>\n         * </tr>\n         * <tr align=\"center\">\n         * <td>DefaultDirectedGraph</td>\n         * <td>Directed</td>\n         * <td>-</td>\n         * <td>+</td>\n         * <td>N*(N-1)+ N = N^2</td>\n         * </tr>\n         * <tr align=\"center\">\n         * <td>DirectedMultigraph</td>\n         * <td>Directed</td>\n         * <td>+</td>\n         * <td>+</td>\n         * <td>Infinite</td>\n         * </tr>\n         * </table>\n         *\n         * @see RandomGraphGenerator.EdgeTopologyFactory#isNumberOfEdgesValid(Graph,\n         * int)\n         */\n        @Override public boolean isNumberOfEdgesValid(\n            Graph<VV, EE> targetGraph,\n            int numberOfEdges)\n        {\n            boolean result;\n\n            boolean infinite = false;\n            int maxAllowedEdges = getMaxEdgesForVertexNum(targetGraph);\n            if (maxAllowedEdges == -1) {\n                infinite = true;\n            }\n\n            if (true == infinite) {\n                result = true;\n            } else if (numberOfEdges <= maxAllowedEdges) {\n                result = true;\n            } else {\n                result = false;\n            }\n            return result;\n        }\n\n        /**\n         * Return max edges for that graph. If it is infinite return -1 instead.\n         */\n        public int getMaxEdgesForVertexNum(Graph<VV, EE> targetGraph)\n        {\n            int maxAllowedEdges = 0;\n            if (targetGraph instanceof SimpleGraph<?, ?>) {\n                maxAllowedEdges = numOfVertexes * (numOfVertexes - 1) / 2;\n            } else if (targetGraph instanceof SimpleDirectedGraph<?, ?>) {\n                maxAllowedEdges = numOfVertexes * (numOfVertexes - 1);\n            } else if (targetGraph instanceof DefaultDirectedGraph<?, ?>) {\n                maxAllowedEdges = numOfVertexes * numOfVertexes;\n            } else {\n                // This may be overly liberal in the case of something\n                // like a simple graph which has been wrapped with\n                // a graph adapter or view.\n                maxAllowedEdges = -1; // infinite\n            }\n            return maxAllowedEdges;\n        }\n    }\n}\n\n// End RandomGraphGenerator.java\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "PartiteRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "RandomGraphHelper",
                "org.jgrapht.experimental"
            ],
            [
                "GraphReader",
                "org.jgrapht.experimental"
            ],
            [
                "DirectedAcyclicGraph",
                "org.jgrapht.experimental.dag"
            ],
            [
                "GraphSquare",
                "org.jgrapht.experimental"
            ],
            [
                "UniformRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "GraphTests",
                "org.jgrapht.experimental"
            ],
            [
                "ApproximationAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "BrownBacktrackColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "GreedyColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "IntArrayGraphAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ExactAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ListenableGraph",
                "org.jgrapht"
            ],
            [
                "ModifiableInteger",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeapNode",
                "org.jgrapht.util"
            ],
            [
                "WeightCombiner",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeap",
                "org.jgrapht.util"
            ],
            [
                "TypeUtil",
                "org.jgrapht.util"
            ],
            [
                "ArrayUnenforcedSet",
                "org.jgrapht.util"
            ],
            [
                "VertexPair",
                "org.jgrapht.util"
            ],
            [
                "MathUtil",
                "org.jgrapht.util"
            ],
            [
                "PrefetchIterator",
                "org.jgrapht.util"
            ],
            [
                "VertexFactory",
                "org.jgrapht"
            ],
            [
                "Graph",
                "org.jgrapht"
            ],
            [
                "GraphPath",
                "org.jgrapht"
            ],
            [
                "UndirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraph",
                "org.jgrapht.graph"
            ],
            [
                "MixedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DefaultGraphMapping",
                "org.jgrapht.graph"
            ],
            [
                "WeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskEdgeSet",
                "org.jgrapht.graph"
            ],
            [
                "Pseudograph",
                "org.jgrapht.graph"
            ],
            [
                "MaskFunctor",
                "org.jgrapht.graph"
            ],
            [
                "GraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractBaseGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "Multigraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultWeightedEdge",
                "org.jgrapht.graph"
            ],
            [
                "ListenableDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeSetFactory",
                "org.jgrapht.graph"
            ],
            [
                "GraphDelegator",
                "org.jgrapht.graph"
            ],
            [
                "DefaultListenableGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedVertexFactory",
                "org.jgrapht.graph"
            ],
            [
                "DefaultEdge",
                "org.jgrapht.graph"
            ],
            [
                "MaskVertexSet",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "IntrusiveEdge",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphPathImpl",
                "org.jgrapht.graph"
            ],
            [
                "Subgraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractGraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedEdgeFactory",
                "org.jgrapht.graph"
            ],
            [
                "SimpleWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "WeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeReversedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "AbstractGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "ListenableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraphPath",
                "org.jgrapht.graph"
            ],
            [
                "ParanoidGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphHelper",
                "org.jgrapht"
            ],
            [
                "Graphs",
                "org.jgrapht"
            ],
            [
                "DirectedGraph",
                "org.jgrapht"
            ],
            [
                "WeightedGraph",
                "org.jgrapht"
            ],
            [
                "HyperCubeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RingGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WheelGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GridGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "ScaleFreeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedBipartiteGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "LinearGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RandomGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGeneratorAdapter",
                "org.jgrapht.generate"
            ],
            [
                "EmptyGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteBipartiteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "StarGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "UndirectedGraph",
                "org.jgrapht"
            ],
            [
                "TopologicalOrderIterator",
                "org.jgrapht.traverse"
            ],
            [
                "CrossComponentIterator",
                "org.jgrapht.traverse"
            ],
            [
                "AbstractGraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "ClosestFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "BreadthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "DepthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "GraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "EdgeFactory",
                "org.jgrapht"
            ],
            [
                "GraphMapping",
                "org.jgrapht"
            ],
            [
                "VertexSetListener",
                "org.jgrapht.event"
            ],
            [
                "EdgeTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "TraversalListener",
                "org.jgrapht.event"
            ],
            [
                "GraphEdgeChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "VertexTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphListener",
                "org.jgrapht.event"
            ],
            [
                "TraversalListenerAdapter",
                "org.jgrapht.event"
            ],
            [
                "ConnectedComponentTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphVertexChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "TarjanLowestCommonAncestor",
                "org.jgrapht.alg"
            ],
            [
                "PrimMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "BlockCutpointGraph",
                "org.jgrapht.alg"
            ],
            [
                "AllDirectedPaths",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPathsIterator",
                "org.jgrapht.alg"
            ],
            [
                "KruskalMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "StrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "VF2State",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2AbstractIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "GraphOrdering",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphicGraphMapping",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2MappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "BronKerboschCliqueFinder",
                "org.jgrapht.alg"
            ],
            [
                "ChromaticNumber",
                "org.jgrapht.alg"
            ],
            [
                "KosarajuStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "DijkstraShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElement",
                "org.jgrapht.alg"
            ],
            [
                "AStarShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordPathElement",
                "org.jgrapht.alg"
            ],
            [
                "FloydWarshallShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "UnionFind",
                "org.jgrapht.alg.util"
            ],
            [
                "AlwaysEqualComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Extension",
                "org.jgrapht.alg.util"
            ],
            [
                "VertexDegreeComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Pair",
                "org.jgrapht.alg.util"
            ],
            [
                "GabowStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "HawickJamesSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "DirectedSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "JohnsonSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TiernanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "UndirectedCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "PatonCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TarjanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "SzwarcfiterLauerSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "BiconnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "ConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "MinSourceSinkCut",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsBlossomShrinking",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveClosure",
                "org.jgrapht.alg"
            ],
            [
                "HopcroftKarpBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "StoerWagnerMinimumCut",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "KuhnMunkresMinimalWeightBipartitePerfectMatching",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveReduction",
                "org.jgrapht.alg"
            ],
            [
                "EulerianCircuit",
                "org.jgrapht.alg"
            ],
            [
                "DirectedNeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "NaiveLcaFinder",
                "org.jgrapht.alg"
            ],
            [
                "MaximumWeightBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "HamiltonianCycle",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "NeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "VertexCovers",
                "org.jgrapht.alg"
            ],
            [
                "CycleDetector",
                "org.jgrapht.alg"
            ],
            [
                "AStarAdmissibleHeuristic",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MinimumSpanningTree",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "WeightedMatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "StrongConnectivityAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MaximumFlowAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "CliqueMinimalSeparatorDecomposition",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordIterator",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElement",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "PushRelabelMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "MaximumFlowAlgorithmBase",
                "org.jgrapht.alg.flow"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "addVertices",
                "org.jgrapht.experimental",
                "RandomGraphHelper",
                "/**\n * .\n *\n * @param target\n * @param vertexFactory\n * @param numVertices\n *\n * @return vertices\n */\n@SuppressWarnings(\"unchecked\")\npublic static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices) {\n    Object[] vertices = new Object[numVertices];\n    for (int i = 0; i < numVertices; ++i) {\n        vertices[i] = vertexFactory.createVertex();\n        target.addVertex(vertices[i]);\n    }\n    return vertices;\n}"
            ],
            [
                "isEmpty",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isEmpty(Graph<V, E> g) {\n    return g.edgeSet().isEmpty();\n}"
            ],
            [
                "isComplete",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isComplete(Graph<V, E> g) {\n    int n = g.vertexSet().size();\n    return g.edgeSet().size() == (n * (n - 1) / 2);\n}"
            ],
            [
                "isConnected",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isConnected(Graph<V, E> g) {\n    int numVertices = g.vertexSet().size();\n    int numEdges = g.edgeSet().size();\n    if (numEdges < (numVertices - 1)) {\n        return false;\n    }\n    if ((numVertices < 2) || (numEdges > ((numVertices - 1) * (numVertices - 2) / 2))) {\n        return true;\n    }\n    Set<V> known = new HashSet<V>();\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = g.vertexSet().iterator().next();\n    // start with node 1\n    queue.add(v);\n    known.add(v);\n    while (!queue.isEmpty()) {\n        v = queue.removeFirst();\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            v = it.next();\n            if (!known.contains(v)) {\n                known.add(v);\n                queue.add(v);\n            }\n        }\n    }\n    return known.size() == numVertices;\n}"
            ],
            [
                "isTree",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isTree(Graph<V, E> g) {\n    return isConnected(g) && (g.edgeSet().size() == (g.vertexSet().size() - 1));\n}"
            ],
            [
                "isBipartite",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isBipartite(Graph<V, E> g) {\n    if ((4 * g.edgeSet().size()) > (g.vertexSet().size() * g.vertexSet().size())) {\n        return false;\n    }\n    if (isEmpty(g)) {\n        return true;\n    }\n    Set<V> unknown = new HashSet<V>(g.vertexSet());\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = unknown.iterator().next();\n    Set<V> odd = new HashSet<V>();\n    queue.add(v);\n    while (!unknown.isEmpty()) {\n        if (queue.isEmpty()) {\n            queue.add(unknown.iterator().next());\n        }\n        v = queue.removeFirst();\n        unknown.remove(v);\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            V n = it.next();\n            if (unknown.contains(n)) {\n                queue.add(n);\n                if (!odd.contains(v)) {\n                    odd.add(n);\n                }\n            } else if (!(odd.contains(v) ^ odd.contains(n))) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
            ],
            [
                "union",
                "org.jgrapht.util",
                "FibonacciHeap",
                "// size\n/**\n * Joins two Fibonacci heaps into a new one. No heap consolidation is\n * performed at this time. The two root lists are simply joined together.\n *\n * <p>Running time: O(1) actual</p>\n *\n * @param h1 first heap\n * @param h2 second heap\n *\n * @return new heap containing h1 and h2\n */\npublic static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2) {\n    FibonacciHeap<T> h = new FibonacciHeap<T>();\n    if ((h1 != null) && (h2 != null)) {\n        h.minNode = h1.minNode;\n        if (h.minNode != null) {\n            if (h2.minNode != null) {\n                h.minNode.right.left = h2.minNode.left;\n                h2.minNode.left.right = h.minNode.right;\n                h.minNode.right = h2.minNode;\n                h2.minNode.left = h.minNode;\n                if (h2.minNode.key < h1.minNode.key) {\n                    h.minNode = h2.minNode;\n                }\n            }\n        } else {\n            h.minNode = h2.minNode;\n        }\n        h.nNodes = h1.nNodes + h2.nNodes;\n    }\n    return h;\n}"
            ],
            [
                "uncheckedCast",
                "org.jgrapht.util",
                "TypeUtil",
                "/**\n * Casts an object to a type.\n *\n * @param o object to be cast\n * @param typeDecl conveys the target type information; the actual value is\n * unused and can be null since this is all just stupid compiler tricks\n *\n * @return the result of the cast\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl) {\n    return (T) o;\n}"
            ],
            [
                "factorial",
                "org.jgrapht.util",
                "MathUtil",
                "public static long factorial(int N) {\n    long multi = 1;\n    for (int i = 1; i <= N; i++) {\n        multi = multi * i;\n    }\n    return multi;\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graphs",
                "/**\n * Creates a new edge and adds it to the specified graph similarly to the\n * {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n *\n * @see Graph#addEdge(Object, Object)\n */\npublic static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    EdgeFactory<V, E> ef = g.getEdgeFactory();\n    E e = ef.createEdge(sourceVertex, targetVertex);\n    // we first create the edge and set the weight to make sure that\n    // listeners will see the correct weight upon addEdge.\n    assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n    ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n    return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new edge and adds it to the specified\n * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return g.addEdge(sourceVertex, targetVertex);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified edge to the graph, including its vertices if not\n * already included.\n *\n * @param targetGraph the graph for which the specified edge to be added.\n * @param sourceGraph the graph in which the specified edge is already\n * present\n * @param edge edge to add\n *\n * @return <tt>true</tt> if the target graph did not already contain the\n * specified edge.\n */\npublic static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge) {\n    V sourceVertex = sourceGraph.getEdgeSource(edge);\n    V targetVertex = sourceGraph.getEdgeTarget(edge);\n    targetGraph.addVertex(sourceVertex);\n    targetGraph.addVertex(targetVertex);\n    return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new weighted edge and adds it to the\n * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n * method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return addEdge(g, sourceVertex, targetVertex, weight);\n}"
            ],
            [
                "addGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all the vertices and all the edges of the specified source graph to\n * the specified destination graph. First all vertices of the source graph\n * are added to the destination graph. Then every edge of the source graph\n * is added to the destination graph. This method returns <code>true</code>\n * if the destination graph has been modified as a result of this operation,\n * otherwise it returns <code>false</code>.\n *\n * <p>The behavior of this operation is undefined if any of the specified\n * graphs is modified while operation is in progress.</p>\n *\n * @param destination the graph to which vertices and edges are added.\n * @param source the graph used as source for vertices and edges to add.\n *\n * @return <code>true</code> if and only if the destination graph has been\n * changed as a result of this operation.\n */\npublic static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source) {\n    boolean modified = addAllVertices(destination, source.vertexSet());\n    modified |= addAllEdges(destination, source, source.edgeSet());\n    return modified;\n}"
            ],
            [
                "addAllEdges",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds a subset of the edges of the specified source graph to the specified\n * destination graph. The behavior of this operation is undefined if either\n * of the graphs is modified while the operation is in progress. {@link\n * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n * be added automatically to the target graph.\n *\n * @param destination the graph to which edges are to be added\n * @param source the graph used as a source for edges to add\n * @param edges the edges to be added\n *\n * @return <tt>true</tt> if this graph changed as a result of the call\n */\npublic static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges) {\n    boolean modified = false;\n    for (E e : edges) {\n        V s = source.getEdgeSource(e);\n        V t = source.getEdgeTarget(e);\n        destination.addVertex(s);\n        destination.addVertex(t);\n        modified |= destination.addEdge(s, t, e);\n    }\n    return modified;\n}"
            ],
            [
                "addAllVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all of the specified vertices to the destination graph. The behavior\n * of this operation is undefined if the specified vertex collection is\n * modified while the operation is in progress. This method will invoke the\n * {@link Graph#addVertex(Object)} method.\n *\n * @param destination the graph to which edges are to be added\n * @param vertices the vertices to be added to the graph.\n *\n * @return <tt>true</tt> if graph changed as a result of the call\n *\n * @throws NullPointerException if the specified vertices contains one or\n * more null vertices, or if the specified vertex collection is <tt>\n * null</tt>.\n *\n * @see Graph#addVertex(Object)\n */\npublic static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices) {\n    boolean modified = false;\n    for (V v : vertices) {\n        modified |= destination.addVertex(v);\n    }\n    return modified;\n}"
            ],
            [
                "neighborListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the neighbors of a specified vertex.\n * If the graph is a multigraph vertices may appear more than once in the\n * returned list.\n *\n * @param g the graph to look for neighbors in.\n * @param vertex the vertex to get the neighbors of.\n *\n * @return a list of the vertices that are the neighbors of the specified\n * vertex.\n */\npublic static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex) {\n    List<V> neighbors = new ArrayList<V>();\n    for (E e : g.edgesOf(vertex)) {\n        neighbors.add(getOppositeVertex(g, e, vertex));\n    }\n    return neighbors;\n}"
            ],
            [
                "predecessorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct predecessors of a\n * specified vertex. If the graph is a multigraph, vertices may appear more\n * than once in the returned list.\n *\n * @param g the graph to look for predecessors in.\n * @param vertex the vertex to get the predecessors of.\n *\n * @return a list of the vertices that are the direct predecessors of the\n * specified vertex.\n */\npublic static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> predecessors = new ArrayList<V>();\n    Set<? extends E> edges = g.incomingEdgesOf(vertex);\n    for (E e : edges) {\n        predecessors.add(getOppositeVertex(g, e, vertex));\n    }\n    return predecessors;\n}"
            ],
            [
                "successorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct successors of a specified\n * vertex. If the graph is a multigraph vertices may appear more than once\n * in the returned list.\n *\n * @param g the graph to look for successors in.\n * @param vertex the vertex to get the successors of.\n *\n * @return a list of the vertices that are the direct successors of the\n * specified vertex.\n */\npublic static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> successors = new ArrayList<V>();\n    Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n    for (E e : edges) {\n        successors.add(getOppositeVertex(g, e, vertex));\n    }\n    return successors;\n}"
            ],
            [
                "undirectedGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns an undirected view of the specified graph. If the specified graph\n * is directed, returns an undirected view of it. If the specified graph is\n * already undirected, just returns it.\n *\n * @param g the graph for which an undirected view is to be returned.\n *\n * @return an undirected view of the specified graph, if it is directed, or\n * or the specified graph itself if it is already undirected.\n *\n * @throws IllegalArgumentException if the graph is neither DirectedGraph\n * nor UndirectedGraph.\n *\n * @see AsUndirectedGraph\n */\npublic static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n    } else if (g instanceof UndirectedGraph<?, ?>) {\n        return (UndirectedGraph<V, E>) g;\n    } else {\n        throw new IllegalArgumentException(\"Graph must be either DirectedGraph or UndirectedGraph\");\n    }\n}"
            ],
            [
                "testIncidence",
                "org.jgrapht",
                "Graphs",
                "/**\n * Tests whether an edge is incident to a vertex.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return true iff e is incident on v\n */\npublic static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v) {\n    return (g.getEdgeSource(e).equals(v)) || (g.getEdgeTarget(e).equals(v));\n}"
            ],
            [
                "getOppositeVertex",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the vertex opposite another vertex across an edge.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return vertex opposite to v across e\n */\npublic static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v) {\n    V source = g.getEdgeSource(e);\n    V target = g.getEdgeTarget(e);\n    if (v.equals(source)) {\n        return target;\n    } else if (v.equals(target)) {\n        return source;\n    } else {\n        throw new IllegalArgumentException(\"no such vertex: \" + v.toString());\n    }\n}"
            ],
            [
                "getPathVertexList",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the list of vertices visited by a path.\n *\n * @param path path of interest\n *\n * @return corresponding vertex list\n */\npublic static <V, E> List<V> getPathVertexList(GraphPath<V, E> path) {\n    Graph<V, E> g = path.getGraph();\n    List<V> list = new ArrayList<V>();\n    V v = path.getStartVertex();\n    list.add(v);\n    for (E e : path.getEdgeList()) {\n        v = getOppositeVertex(g, e, v);\n        list.add(v);\n    }\n    return list;\n}"
            ],
            [
                "range",
                "org.jgrapht.generate",
                "SimpleWeightedGraphMatrixGenerator",
                "///////////////////////////////////////////////////////////////////////////////////////////////\npublic static int[] range(final int from, final int to) {\n    int[] range = new int[to - from];\n    for (int i = from; i < to; ++i) {\n        range[i - from] = i;\n    }\n    return range;\n}"
            ],
            [
                "createGraphSpecifics",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "// -------------------------------------------------------------------------\n/**\n * @param <V>\n * @param <E>\n * @param g\n *\n * @return TODO Document me\n */\nstatic <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new DirectedSpecifics<V, E>((DirectedGraph<V, E>) g);\n    } else {\n        return new UndirectedSpecifics<V, E>(g);\n    }\n}"
            ],
            [
                "findGreedyChromaticNumber",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds the number of colors required for a greedy coloring of the graph.\n *\n * @param g an undirected graph to find the chromatic number of\n *\n * @return integer the approximate chromatic number from the greedy\n * algorithm\n */\npublic static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g) {\n    Map<Integer, Set<V>> coloredGroups = findGreedyColoredGroups(g);\n    return coloredGroups.keySet().size();\n}"
            ],
            [
                "findGreedyColoredGroups",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds a greedy coloring of the graph.\n *\n * @param g an undirected graph for which to find the coloring\n */\npublic static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g) {\n    // A copy of the graph is made, so that elements of the graph may be\n    // removed to carry out the algorithm\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // The Vertices will be sorted in decreasing order by degree, so that\n    // higher degree vertices have priority to be colored first\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    List<V> sortedVertices = new LinkedList<V>(sg.vertexSet());\n    Collections.sort(sortedVertices, comp);\n    Collections.reverse(sortedVertices);\n    int color;\n    // create a map which will hold color as key and Set<V> as value\n    Map<Integer, Set<V>> coloredGroups = new HashMap<Integer, Set<V>>();\n    // We'll attempt to color each vertex with a single color each\n    // iteration, and these vertices will be removed from the graph at the\n    // end of each iteration\n    for (color = 0; sg.vertexSet().size() > 0; color++) {\n        // This set will contain vertices that are colored with the\n        // current color of this iteration\n        Set<V> currentColor = new HashSet<V>();\n        for (Iterator<V> iter = sortedVertices.iterator(); iter.hasNext(); ) {\n            V v = iter.next();\n            // Add new vertices to be colored as long as they are not\n            // adjacent with any other vertex that has already been colored\n            // with the current color\n            boolean flag = true;\n            for (Iterator<V> innerIter = currentColor.iterator(); innerIter.hasNext(); ) {\n                V temp = innerIter.next();\n                if (sg.containsEdge(temp, v)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                currentColor.add(v);\n                iter.remove();\n            }\n        }\n        // Add all these vertices as a group for this color\n        coloredGroups.put(color, currentColor);\n        // Remove vertices from the graph and then repeat the process for\n        // the next iteration\n        sg.removeAllVertices(currentColor);\n    }\n    return coloredGroups;\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "BellmanFordShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by hops, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    BellmanFordShortestPath<V, E> alg = new BellmanFordShortestPath<V, E>(graph, startVertex);\n    return alg.getPathEdgeList(endVertex);\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "DijkstraShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by radius, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    DijkstraShortestPath<V, E> alg = new DijkstraShortestPath<V, E>(graph, startVertex, endVertex);\n    return alg.getPathEdgeList();\n}"
            ],
            [
                "of",
                "org.jgrapht.alg.util",
                "Pair",
                "/**\n * Creates new pair of elements pulling of the necessity to provide\n * corresponding types of the elements supplied\n *\n * @param a first element\n * @param b second element\n *\n * @return new pair\n */\npublic static <A, B> Pair<A, B> of(A a, B b) {\n    return new Pair<A, B>(a, b);\n}"
            ],
            [
                "isEulerian",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will check whether the graph passed in is Eulerian or not.\n *\n * @param g The graph to be checked\n *\n * @return true for Eulerian and false for non-Eulerian\n */\npublic static <V, E> boolean isEulerian(UndirectedGraph<V, E> g) {\n    // If the graph is not connected, then no Eulerian circuit exists\n    if (!(new ConnectivityInspector<V, E>(g)).isGraphConnected()) {\n        return false;\n    }\n    // A graph is Eulerian if and only if all vertices have even degree\n    // So, this code will check for that\n    Iterator<V> iter = g.vertexSet().iterator();\n    while (iter.hasNext()) {\n        V v = iter.next();\n        if ((g.degreeOf(v) % 2) == 1) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "getEulerianCircuitVertices",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will return a list of vertices which represents the Eulerian\n * circuit of the graph.\n *\n * @param g The graph to find an Eulerian circuit\n *\n * @return null if no Eulerian circuit exists, or a list of vertices\n * representing the Eulerian circuit if one does exist\n */\npublic static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g) {\n    // If the graph is not Eulerian then just return a null since no\n    // Eulerian circuit exists\n    if (!isEulerian(g)) {\n        return null;\n    }\n    // The circuit will be represented by a linked list\n    List<V> path = new LinkedList<V>();\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    path.add(sg.vertexSet().iterator().next());\n    // Algorithm for finding an Eulerian circuit Basically this will find an\n    // arbitrary circuit, then it will find another arbitrary circuit until\n    // every edge has been traversed\n    while (sg.edgeSet().size() > 0) {\n        V v = null;\n        // Find a vertex which has an edge that hasn't been traversed yet,\n        // and keep its index position in the circuit list\n        int index = 0;\n        for (Iterator<V> iter = path.iterator(); iter.hasNext(); index++) {\n            v = iter.next();\n            if (sg.degreeOf(v) > 0) {\n                break;\n            }\n        }\n        // Finds an arbitrary circuit of the current vertex and\n        // appends this into the circuit list\n        while (sg.degreeOf(v) > 0) {\n            for (Iterator<V> iter = sg.vertexSet().iterator(); iter.hasNext(); ) {\n                V temp = iter.next();\n                if (sg.containsEdge(v, temp)) {\n                    path.add(index, temp);\n                    sg.removeEdge(v, temp);\n                    v = temp;\n                    break;\n                }\n            }\n        }\n    }\n    return path;\n}"
            ],
            [
                "getApproximateOptimalForCompleteGraph",
                "org.jgrapht.alg",
                "HamiltonianCycle",
                "/**\n * This method will return an approximate minimal traveling salesman tour\n * (hamiltonian cycle). This algorithm requires that the graph be complete\n * and the triangle inequality exists (if x,y,z are vertices then\n * d(x,y)+d(y,z) &lt; d(x,z) for all x,y,z) then this algorithm will\n * guarantee a hamiltonian cycle such that the total weight of the cycle is\n * less than or equal to double the total weight of the optimal hamiltonian\n * cycle. The optimal solution is NP-complete, so this is a decent\n * approximation that runs in polynomial time.\n *\n * @param <V>\n * @param <E>\n * @param g is the graph to find the optimal tour for.\n *\n * @return The optimal tour as a list of vertices.\n */\npublic static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g) {\n    List<V> vertices = new LinkedList<V>(g.vertexSet());\n    // If the graph is not complete then return null since this algorithm\n    // requires the graph be complete\n    if ((vertices.size() * (vertices.size() - 1) / 2) != g.edgeSet().size()) {\n        return null;\n    }\n    List<V> tour = new LinkedList<V>();\n    // Each iteration a new vertex will be added to the tour until all\n    // vertices have been added\n    while (tour.size() != g.vertexSet().size()) {\n        boolean firstEdge = true;\n        double minEdgeValue = 0;\n        int minVertexFound = 0;\n        int vertexConnectedTo = 0;\n        // A check will be made for the shortest edge to a vertex not within\n        // the tour and that new vertex will be added to the vertex\n        for (int i = 0; i < tour.size(); i++) {\n            V v = tour.get(i);\n            for (int j = 0; j < vertices.size(); j++) {\n                double weight = g.getEdgeWeight(g.getEdge(v, vertices.get(j)));\n                if (firstEdge || (weight < minEdgeValue)) {\n                    firstEdge = false;\n                    minEdgeValue = weight;\n                    minVertexFound = j;\n                    vertexConnectedTo = i;\n                }\n            }\n        }\n        tour.add(vertexConnectedTo, vertices.get(minVertexFound));\n        vertices.remove(minVertexFound);\n    }\n    return tour;\n}"
            ],
            [
                "find2ApproximationCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a 2-approximation for a minimal vertex cover of the specified\n * graph. The algorithm promises a cover that is at most double the size of\n * a minimal cover. The algorithm takes O(|E|) time.\n *\n * <p>For more details see Jenny Walter, CMPU-240: Lecture notes for\n * Language Theory and Computation, Fall 2002, Vassar College, <a\n * href=\"http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf\">\n * http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf</a>.\n * </p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G'=(V',E') <-- G(V,E)\n    Subgraph<V, E, Graph<V, E>> sg = new Subgraph<V, E, Graph<V, E>>(g, null, null);\n    // while E' is non-empty\n    while (sg.edgeSet().size() > 0) {\n        // let (u,v) be an arbitrary edge of E'\n        E e = sg.edgeSet().iterator().next();\n        // C <-- C U {u,v}\n        V u = g.getEdgeSource(e);\n        V v = g.getEdgeTarget(e);\n        cover.add(u);\n        cover.add(v);\n        // remove from E' every edge incident on either u or v\n        sg.removeVertex(u);\n        sg.removeVertex(v);\n    }\n    // return C\n    return cover;\n}"
            ],
            [
                "findGreedyCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a greedy approximation for a minimal vertex cover of a specified\n * graph. At each iteration, the algorithm picks the vertex with the highest\n * degree and adds it to the cover, until all edges are covered.\n *\n * <p>The algorithm works on undirected graphs, but can also work on\n * directed graphs when their edge-directions are ignored. To ignore edge\n * directions you can use {@link org.jgrapht.Graphs#undirectedGraph(Graph)}\n * or {@link org.jgrapht.graph.AsUndirectedGraph}.</p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G' <-- G\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // compare vertices in descending order of degree\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    // while G' != {}\n    while (sg.edgeSet().size() > 0) {\n        // v <-- vertex with maximum degree in G'\n        V v = Collections.max(sg.vertexSet(), comp);\n        // C <-- C U {v}\n        cover.add(v);\n        // remove from G' every edge incident on v, and v itself\n        sg.removeVertex(v);\n    }\n    return cover;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "BEST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int BEST_ORDER = 0;"
            ],
            [
                "NATURAL_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int NATURAL_ORDER = 1;"
            ],
            [
                "SMALLEST_DEGREE_LAST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;"
            ],
            [
                "LARGEST_SATURATION_FIRST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;"
            ],
            [
                "DEFAULT_EDGE_WEIGHT",
                "org.jgrapht",
                "WeightedGraph",
                "/**\n * The default weight for an edge.\n */\npublic static double DEFAULT_EDGE_WEIGHT = 1.0;"
            ],
            [
                "HUB_VERTEX",
                "org.jgrapht.generate",
                "WheelGraphGenerator",
                "/**\n * Role for the hub vertex.\n */\npublic static final String HUB_VERTEX = \"Hub Vertex\";"
            ],
            [
                "CORNER_VERTEX",
                "org.jgrapht.generate",
                "GridGraphGenerator",
                "/**\n * Role for the vertices at the corners.\n */\npublic static final String CORNER_VERTEX = \"Corner Vertex\";"
            ],
            [
                "START_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the first vertex generated.\n */\npublic static final String START_VERTEX = \"Start Vertex\";"
            ],
            [
                "END_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the last vertex generated.\n */\npublic static final String END_VERTEX = \"End Vertex\";"
            ],
            [
                "CENTER_VERTEX",
                "org.jgrapht.generate",
                "StarGraphGenerator",
                "public static final String CENTER_VERTEX = \"Center Vertex\";"
            ],
            [
                "SENTINEL",
                "org.jgrapht.traverse",
                "DepthFirstIterator",
                "/**\n * Sentinel object. Unfortunately, we can't use null, because ArrayDeque\n * won't accept those. And we don't want to rely on the caller to provide a\n * sentinel object for us. So we have to play typecasting games.\n */\npublic static final Object SENTINEL = new Object();"
            ],
            [
                "BEFORE_EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge added event. This event is fired before an edge is added to a\n * graph.\n */\npublic static final int BEFORE_EDGE_ADDED = 21;"
            ],
            [
                "BEFORE_EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge removed event. This event is fired before an edge is removed\n * from a graph.\n */\npublic static final int BEFORE_EDGE_REMOVED = 22;"
            ],
            [
                "EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge added event. This event is fired after an edge is added to a graph.\n */\npublic static final int EDGE_ADDED = 23;"
            ],
            [
                "EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge removed event. This event is fired after an edge is removed from a\n * graph.\n */\npublic static final int EDGE_REMOVED = 24;"
            ],
            [
                "CONNECTED_COMPONENT_STARTED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal started event.\n */\npublic static final int CONNECTED_COMPONENT_STARTED = 31;"
            ],
            [
                "CONNECTED_COMPONENT_FINISHED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal finished event.\n */\npublic static final int CONNECTED_COMPONENT_FINISHED = 32;"
            ],
            [
                "BEFORE_VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex added event. This event is fired before a vertex is added\n * to a graph.\n */\npublic static final int BEFORE_VERTEX_ADDED = 11;"
            ],
            [
                "BEFORE_VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex removed event. This event is fired before a vertex is\n * removed from a graph.\n */\npublic static final int BEFORE_VERTEX_REMOVED = 12;"
            ],
            [
                "VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex added event. This event is fired after a vertex is added to a\n * graph.\n */\npublic static final int VERTEX_ADDED = 13;"
            ],
            [
                "VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex removed event. This event is fired after a vertex is removed from\n * a graph.\n */\npublic static final int VERTEX_REMOVED = 14;"
            ],
            [
                "NULL_NODE",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "public static final int NULL_NODE = -1;"
            ],
            [
                "DEBUG",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected static final boolean DEBUG = false;"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg",
                "EdmondsKarpMaximumFlow",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 0.000000001;"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveClosure",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveClosure INSTANCE = new TransitiveClosure();"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveReduction",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveReduction INSTANCE = new TransitiveReduction();"
            ],
            [
                "NEGATIVE_UNDIRECTED_EDGE",
                "org.jgrapht.alg",
                "BellmanFordIterator",
                "/**\n * Error message.\n */\nprotected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg.flow",
                "MaximumFlowAlgorithmBase",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 1e-9;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [
            [
                "target",
                "org.jgrapht.Graph",
                "Graph<V, E>"
            ],
            [
                "vertexFactory",
                "org.jgrapht.VertexFactory",
                "VertexFactory<V>"
            ],
            [
                "resultMap",
                "java.util.Map",
                "Map<String, V>"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "getRandomSeed",
                "org.jgrapht.generate",
                "RandomGraphGenerator",
                "public long getRandomSeed() {\n    return this.randomizerSeed;\n}"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "removeAllEdges",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> removeAllEdges(V arg0, V arg1)"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean addEdge(V arg0, V arg1, E arg2)"
            ],
            [
                "getAllEdges",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> getAllEdges(V arg0, V arg1)"
            ],
            [
                "containsEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean containsEdge(E arg0)"
            ],
            [
                "getEdgeTarget",
                "org.jgrapht",
                "Graph",
                "public abstract V getEdgeTarget(E arg0)"
            ],
            [
                "containsEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean containsEdge(V arg0, V arg1)"
            ],
            [
                "removeEdge",
                "org.jgrapht",
                "Graph",
                "public abstract E removeEdge(V arg0, V arg1)"
            ],
            [
                "addVertex",
                "org.jgrapht",
                "Graph",
                "public abstract boolean addVertex(V arg0)"
            ],
            [
                "getEdgeFactory",
                "org.jgrapht",
                "Graph",
                "public abstract EdgeFactory<V, E> getEdgeFactory()"
            ],
            [
                "edgesOf",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> edgesOf(V arg0)"
            ],
            [
                "getEdgeWeight",
                "org.jgrapht",
                "Graph",
                "public abstract double getEdgeWeight(E arg0)"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graph",
                "public abstract E addEdge(V arg0, V arg1)"
            ],
            [
                "getEdgeSource",
                "org.jgrapht",
                "Graph",
                "public abstract V getEdgeSource(E arg0)"
            ],
            [
                "vertexSet",
                "org.jgrapht",
                "Graph",
                "public abstract Set<V> vertexSet()"
            ],
            [
                "edgeSet",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> edgeSet()"
            ],
            [
                "getEdge",
                "org.jgrapht",
                "Graph",
                "public abstract E getEdge(V arg0, V arg1)"
            ],
            [
                "containsVertex",
                "org.jgrapht",
                "Graph",
                "public abstract boolean containsVertex(V arg0)"
            ],
            [
                "removeVertex",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeVertex(V arg0)"
            ],
            [
                "removeAllVertices",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeAllVertices(Collection<? extends V> arg0)"
            ],
            [
                "removeAllEdges",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeAllEdges(Collection<? extends E> arg0)"
            ],
            [
                "removeEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeEdge(E arg0)"
            ],
            [
                "createVertex",
                "org.jgrapht",
                "VertexFactory",
                "public abstract V createVertex()"
            ],
            [
                "values",
                "java.util",
                "Map",
                "public abstract Collection<V> values()"
            ],
            [
                "merge",
                "java.util",
                "Map",
                "public default V merge(K arg0, V arg1, BiFunction<? super V, ? super V, ? extends V> arg2)"
            ],
            [
                "hashCode",
                "java.util",
                "Map",
                "public abstract int hashCode()"
            ],
            [
                "remove",
                "java.util",
                "Map",
                "public default boolean remove(Object arg0, Object arg1)"
            ],
            [
                "put",
                "java.util",
                "Map",
                "public abstract V put(K arg0, V arg1)"
            ],
            [
                "keySet",
                "java.util",
                "Map",
                "public abstract Set<K> keySet()"
            ],
            [
                "remove",
                "java.util",
                "Map",
                "public abstract V remove(Object arg0)"
            ],
            [
                "replace",
                "java.util",
                "Map",
                "public default V replace(K arg0, V arg1)"
            ],
            [
                "equals",
                "java.util",
                "Map",
                "public abstract boolean equals(Object arg0)"
            ],
            [
                "size",
                "java.util",
                "Map",
                "public abstract int size()"
            ],
            [
                "putIfAbsent",
                "java.util",
                "Map",
                "public default V putIfAbsent(K arg0, V arg1)"
            ],
            [
                "computeIfPresent",
                "java.util",
                "Map",
                "public default V computeIfPresent(K arg0, BiFunction<? super K, ? super V, ? extends V> arg1)"
            ],
            [
                "containsValue",
                "java.util",
                "Map",
                "public abstract boolean containsValue(Object arg0)"
            ],
            [
                "containsKey",
                "java.util",
                "Map",
                "public abstract boolean containsKey(Object arg0)"
            ],
            [
                "get",
                "java.util",
                "Map",
                "public abstract V get(Object arg0)"
            ],
            [
                "isEmpty",
                "java.util",
                "Map",
                "public abstract boolean isEmpty()"
            ],
            [
                "compute",
                "java.util",
                "Map",
                "public default V compute(K arg0, BiFunction<? super K, ? super V, ? extends V> arg1)"
            ],
            [
                "replace",
                "java.util",
                "Map",
                "public default boolean replace(K arg0, V arg1, V arg2)"
            ],
            [
                "computeIfAbsent",
                "java.util",
                "Map",
                "public default V computeIfAbsent(K arg0, Function<? super K, ? extends V> arg1)"
            ],
            [
                "getOrDefault",
                "java.util",
                "Map",
                "public default V getOrDefault(Object arg0, V arg1)"
            ],
            [
                "entrySet",
                "java.util",
                "Map",
                "public abstract Set<Map.Entry<K, V>> entrySet()"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [
            [
                "numOfVertexes",
                "org.jgrapht.generate",
                "RandomGraphGenerator",
                "protected int numOfVertexes;"
            ],
            [
                "numOfEdges",
                "org.jgrapht.generate",
                "RandomGraphGenerator",
                "protected int numOfEdges;"
            ],
            [
                "randomizer",
                "org.jgrapht.generate",
                "RandomGraphGenerator",
                "protected Random randomizer;"
            ]
        ],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 26143,
        "oracle": "partitionOne >= 0;",
        "oracleType": "PRE",
        "projectName": "jgrapht-core-0.9.2",
        "packageName": "org.jgrapht.generate",
        "className": "CompleteBipartiteGraphGenerator",
        "javadocTag": "@param partitionOne This is the number of vertices in the first partition",
        "methodJavadoc": "    /**\n     * Creates a new CompleteBipartiteGraphGenerator object.\n     *\n     * @param partitionOne This is the number of vertices in the first partition\n     * @param partitionTwo This is the number of vertices in the second parition\n     */",
        "methodSourceCode": "public CompleteBipartiteGraphGenerator(int partitionOne, int partitionTwo){\n    if ((partitionOne < 0) || (partitionTwo < 0)) {\n        throw new IllegalArgumentException(\"must be non-negative\");\n    }\n    this.sizeA = partitionOne;\n    this.sizeB = partitionTwo;\n}",
        "classJavadoc": "/**\n * Generates a <a\n * href=\"http://mathworld.wolfram.com/CompleteBipartiteGraph.html\">complete\n * bipartite graph</a> of any size. This is a graph with two partitions; two\n * vertices will contain an edge if and only if they belong to different\n * partitions.\n *\n * @author Andrew Newell\n * @since Dec 21, 2008\n */",
        "classSourceCode": "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------\n * CompleteBipartiteGraphGenerator.java\n * -------------------\n * (C) Copyright 2008-2008, by Andrew Newell and Contributors.\n *\n * Original Author:  Andrew Newell\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n * 24-Dec-2008 : Initial revision (AN);\n *\n */\npackage org.jgrapht.generate;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\n\n\n/**\n * Generates a <a\n * href=\"http://mathworld.wolfram.com/CompleteBipartiteGraph.html\">complete\n * bipartite graph</a> of any size. This is a graph with two partitions; two\n * vertices will contain an edge if and only if they belong to different\n * partitions.\n *\n * @author Andrew Newell\n * @since Dec 21, 2008\n */\npublic class CompleteBipartiteGraphGenerator<V, E>\n    implements GraphGenerator<V, E, V>\n{\n    private int sizeA, sizeB;\n\n    /**\n     * Creates a new CompleteBipartiteGraphGenerator object.\n     *\n     * @param partitionOne This is the number of vertices in the first partition\n     * @param partitionTwo This is the number of vertices in the second parition\n     */\n    public CompleteBipartiteGraphGenerator(int partitionOne, int partitionTwo)\n    {\n        if ((partitionOne < 0) || (partitionTwo < 0)) {\n            throw new IllegalArgumentException(\"must be non-negative\");\n        }\n        this.sizeA = partitionOne;\n        this.sizeB = partitionTwo;\n    }\n\n    /**\n     * Construct a complete bipartite graph\n     */\n    @Override public void generateGraph(\n        Graph<V, E> target,\n        final VertexFactory<V> vertexFactory,\n        Map<String, V> resultMap)\n    {\n        if ((sizeA < 1) && (sizeB < 1)) {\n            return;\n        }\n\n        //Create vertices in each of the partitions\n        Set<V> a = new HashSet<V>();\n        Set<V> b = new HashSet<V>();\n        for (int i = 0; i < sizeA; i++) {\n            V newVertex = vertexFactory.createVertex();\n            target.addVertex(newVertex);\n            a.add(newVertex);\n        }\n        for (int i = 0; i < sizeB; i++) {\n            V newVertex = vertexFactory.createVertex();\n            target.addVertex(newVertex);\n            b.add(newVertex);\n        }\n\n        //Add an edge for each pair of vertices in different partitions\n        for (Iterator<V> iterA = a.iterator(); iterA.hasNext();) {\n            V v = iterA.next();\n            for (Iterator<V> iterB = b.iterator(); iterB.hasNext();) {\n                target.addEdge(v, iterB.next());\n            }\n        }\n    }\n}\n\n// End CompleteBipartiteGraphGenerator.java\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "PartiteRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "RandomGraphHelper",
                "org.jgrapht.experimental"
            ],
            [
                "GraphReader",
                "org.jgrapht.experimental"
            ],
            [
                "DirectedAcyclicGraph",
                "org.jgrapht.experimental.dag"
            ],
            [
                "GraphSquare",
                "org.jgrapht.experimental"
            ],
            [
                "UniformRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "GraphTests",
                "org.jgrapht.experimental"
            ],
            [
                "ApproximationAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "BrownBacktrackColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "GreedyColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "IntArrayGraphAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ExactAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ListenableGraph",
                "org.jgrapht"
            ],
            [
                "ModifiableInteger",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeapNode",
                "org.jgrapht.util"
            ],
            [
                "WeightCombiner",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeap",
                "org.jgrapht.util"
            ],
            [
                "TypeUtil",
                "org.jgrapht.util"
            ],
            [
                "ArrayUnenforcedSet",
                "org.jgrapht.util"
            ],
            [
                "VertexPair",
                "org.jgrapht.util"
            ],
            [
                "MathUtil",
                "org.jgrapht.util"
            ],
            [
                "PrefetchIterator",
                "org.jgrapht.util"
            ],
            [
                "VertexFactory",
                "org.jgrapht"
            ],
            [
                "Graph",
                "org.jgrapht"
            ],
            [
                "GraphPath",
                "org.jgrapht"
            ],
            [
                "UndirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraph",
                "org.jgrapht.graph"
            ],
            [
                "MixedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DefaultGraphMapping",
                "org.jgrapht.graph"
            ],
            [
                "WeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskEdgeSet",
                "org.jgrapht.graph"
            ],
            [
                "Pseudograph",
                "org.jgrapht.graph"
            ],
            [
                "MaskFunctor",
                "org.jgrapht.graph"
            ],
            [
                "GraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractBaseGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "Multigraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultWeightedEdge",
                "org.jgrapht.graph"
            ],
            [
                "ListenableDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeSetFactory",
                "org.jgrapht.graph"
            ],
            [
                "GraphDelegator",
                "org.jgrapht.graph"
            ],
            [
                "DefaultListenableGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedVertexFactory",
                "org.jgrapht.graph"
            ],
            [
                "DefaultEdge",
                "org.jgrapht.graph"
            ],
            [
                "MaskVertexSet",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "IntrusiveEdge",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphPathImpl",
                "org.jgrapht.graph"
            ],
            [
                "Subgraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractGraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedEdgeFactory",
                "org.jgrapht.graph"
            ],
            [
                "SimpleWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "WeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeReversedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "AbstractGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "ListenableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraphPath",
                "org.jgrapht.graph"
            ],
            [
                "ParanoidGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphHelper",
                "org.jgrapht"
            ],
            [
                "Graphs",
                "org.jgrapht"
            ],
            [
                "DirectedGraph",
                "org.jgrapht"
            ],
            [
                "WeightedGraph",
                "org.jgrapht"
            ],
            [
                "HyperCubeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RingGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WheelGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GridGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "ScaleFreeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedBipartiteGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "LinearGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RandomGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGeneratorAdapter",
                "org.jgrapht.generate"
            ],
            [
                "EmptyGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteBipartiteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "StarGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "UndirectedGraph",
                "org.jgrapht"
            ],
            [
                "TopologicalOrderIterator",
                "org.jgrapht.traverse"
            ],
            [
                "CrossComponentIterator",
                "org.jgrapht.traverse"
            ],
            [
                "AbstractGraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "ClosestFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "BreadthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "DepthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "GraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "EdgeFactory",
                "org.jgrapht"
            ],
            [
                "GraphMapping",
                "org.jgrapht"
            ],
            [
                "VertexSetListener",
                "org.jgrapht.event"
            ],
            [
                "EdgeTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "TraversalListener",
                "org.jgrapht.event"
            ],
            [
                "GraphEdgeChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "VertexTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphListener",
                "org.jgrapht.event"
            ],
            [
                "TraversalListenerAdapter",
                "org.jgrapht.event"
            ],
            [
                "ConnectedComponentTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphVertexChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "TarjanLowestCommonAncestor",
                "org.jgrapht.alg"
            ],
            [
                "PrimMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "BlockCutpointGraph",
                "org.jgrapht.alg"
            ],
            [
                "AllDirectedPaths",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPathsIterator",
                "org.jgrapht.alg"
            ],
            [
                "KruskalMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "StrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "VF2State",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2AbstractIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "GraphOrdering",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphicGraphMapping",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2MappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "BronKerboschCliqueFinder",
                "org.jgrapht.alg"
            ],
            [
                "ChromaticNumber",
                "org.jgrapht.alg"
            ],
            [
                "KosarajuStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "DijkstraShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElement",
                "org.jgrapht.alg"
            ],
            [
                "AStarShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordPathElement",
                "org.jgrapht.alg"
            ],
            [
                "FloydWarshallShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "UnionFind",
                "org.jgrapht.alg.util"
            ],
            [
                "AlwaysEqualComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Extension",
                "org.jgrapht.alg.util"
            ],
            [
                "VertexDegreeComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Pair",
                "org.jgrapht.alg.util"
            ],
            [
                "GabowStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "HawickJamesSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "DirectedSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "JohnsonSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TiernanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "UndirectedCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "PatonCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TarjanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "SzwarcfiterLauerSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "BiconnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "ConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "MinSourceSinkCut",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsBlossomShrinking",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveClosure",
                "org.jgrapht.alg"
            ],
            [
                "HopcroftKarpBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "StoerWagnerMinimumCut",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "KuhnMunkresMinimalWeightBipartitePerfectMatching",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveReduction",
                "org.jgrapht.alg"
            ],
            [
                "EulerianCircuit",
                "org.jgrapht.alg"
            ],
            [
                "DirectedNeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "NaiveLcaFinder",
                "org.jgrapht.alg"
            ],
            [
                "MaximumWeightBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "HamiltonianCycle",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "NeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "VertexCovers",
                "org.jgrapht.alg"
            ],
            [
                "CycleDetector",
                "org.jgrapht.alg"
            ],
            [
                "AStarAdmissibleHeuristic",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MinimumSpanningTree",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "WeightedMatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "StrongConnectivityAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MaximumFlowAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "CliqueMinimalSeparatorDecomposition",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordIterator",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElement",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "PushRelabelMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "MaximumFlowAlgorithmBase",
                "org.jgrapht.alg.flow"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "addVertices",
                "org.jgrapht.experimental",
                "RandomGraphHelper",
                "/**\n * .\n *\n * @param target\n * @param vertexFactory\n * @param numVertices\n *\n * @return vertices\n */\n@SuppressWarnings(\"unchecked\")\npublic static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices) {\n    Object[] vertices = new Object[numVertices];\n    for (int i = 0; i < numVertices; ++i) {\n        vertices[i] = vertexFactory.createVertex();\n        target.addVertex(vertices[i]);\n    }\n    return vertices;\n}"
            ],
            [
                "isEmpty",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isEmpty(Graph<V, E> g) {\n    return g.edgeSet().isEmpty();\n}"
            ],
            [
                "isComplete",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isComplete(Graph<V, E> g) {\n    int n = g.vertexSet().size();\n    return g.edgeSet().size() == (n * (n - 1) / 2);\n}"
            ],
            [
                "isConnected",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isConnected(Graph<V, E> g) {\n    int numVertices = g.vertexSet().size();\n    int numEdges = g.edgeSet().size();\n    if (numEdges < (numVertices - 1)) {\n        return false;\n    }\n    if ((numVertices < 2) || (numEdges > ((numVertices - 1) * (numVertices - 2) / 2))) {\n        return true;\n    }\n    Set<V> known = new HashSet<V>();\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = g.vertexSet().iterator().next();\n    // start with node 1\n    queue.add(v);\n    known.add(v);\n    while (!queue.isEmpty()) {\n        v = queue.removeFirst();\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            v = it.next();\n            if (!known.contains(v)) {\n                known.add(v);\n                queue.add(v);\n            }\n        }\n    }\n    return known.size() == numVertices;\n}"
            ],
            [
                "isTree",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isTree(Graph<V, E> g) {\n    return isConnected(g) && (g.edgeSet().size() == (g.vertexSet().size() - 1));\n}"
            ],
            [
                "isBipartite",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isBipartite(Graph<V, E> g) {\n    if ((4 * g.edgeSet().size()) > (g.vertexSet().size() * g.vertexSet().size())) {\n        return false;\n    }\n    if (isEmpty(g)) {\n        return true;\n    }\n    Set<V> unknown = new HashSet<V>(g.vertexSet());\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = unknown.iterator().next();\n    Set<V> odd = new HashSet<V>();\n    queue.add(v);\n    while (!unknown.isEmpty()) {\n        if (queue.isEmpty()) {\n            queue.add(unknown.iterator().next());\n        }\n        v = queue.removeFirst();\n        unknown.remove(v);\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            V n = it.next();\n            if (unknown.contains(n)) {\n                queue.add(n);\n                if (!odd.contains(v)) {\n                    odd.add(n);\n                }\n            } else if (!(odd.contains(v) ^ odd.contains(n))) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
            ],
            [
                "union",
                "org.jgrapht.util",
                "FibonacciHeap",
                "// size\n/**\n * Joins two Fibonacci heaps into a new one. No heap consolidation is\n * performed at this time. The two root lists are simply joined together.\n *\n * <p>Running time: O(1) actual</p>\n *\n * @param h1 first heap\n * @param h2 second heap\n *\n * @return new heap containing h1 and h2\n */\npublic static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2) {\n    FibonacciHeap<T> h = new FibonacciHeap<T>();\n    if ((h1 != null) && (h2 != null)) {\n        h.minNode = h1.minNode;\n        if (h.minNode != null) {\n            if (h2.minNode != null) {\n                h.minNode.right.left = h2.minNode.left;\n                h2.minNode.left.right = h.minNode.right;\n                h.minNode.right = h2.minNode;\n                h2.minNode.left = h.minNode;\n                if (h2.minNode.key < h1.minNode.key) {\n                    h.minNode = h2.minNode;\n                }\n            }\n        } else {\n            h.minNode = h2.minNode;\n        }\n        h.nNodes = h1.nNodes + h2.nNodes;\n    }\n    return h;\n}"
            ],
            [
                "uncheckedCast",
                "org.jgrapht.util",
                "TypeUtil",
                "/**\n * Casts an object to a type.\n *\n * @param o object to be cast\n * @param typeDecl conveys the target type information; the actual value is\n * unused and can be null since this is all just stupid compiler tricks\n *\n * @return the result of the cast\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl) {\n    return (T) o;\n}"
            ],
            [
                "factorial",
                "org.jgrapht.util",
                "MathUtil",
                "public static long factorial(int N) {\n    long multi = 1;\n    for (int i = 1; i <= N; i++) {\n        multi = multi * i;\n    }\n    return multi;\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graphs",
                "/**\n * Creates a new edge and adds it to the specified graph similarly to the\n * {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n *\n * @see Graph#addEdge(Object, Object)\n */\npublic static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    EdgeFactory<V, E> ef = g.getEdgeFactory();\n    E e = ef.createEdge(sourceVertex, targetVertex);\n    // we first create the edge and set the weight to make sure that\n    // listeners will see the correct weight upon addEdge.\n    assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n    ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n    return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new edge and adds it to the specified\n * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return g.addEdge(sourceVertex, targetVertex);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified edge to the graph, including its vertices if not\n * already included.\n *\n * @param targetGraph the graph for which the specified edge to be added.\n * @param sourceGraph the graph in which the specified edge is already\n * present\n * @param edge edge to add\n *\n * @return <tt>true</tt> if the target graph did not already contain the\n * specified edge.\n */\npublic static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge) {\n    V sourceVertex = sourceGraph.getEdgeSource(edge);\n    V targetVertex = sourceGraph.getEdgeTarget(edge);\n    targetGraph.addVertex(sourceVertex);\n    targetGraph.addVertex(targetVertex);\n    return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new weighted edge and adds it to the\n * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n * method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return addEdge(g, sourceVertex, targetVertex, weight);\n}"
            ],
            [
                "addGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all the vertices and all the edges of the specified source graph to\n * the specified destination graph. First all vertices of the source graph\n * are added to the destination graph. Then every edge of the source graph\n * is added to the destination graph. This method returns <code>true</code>\n * if the destination graph has been modified as a result of this operation,\n * otherwise it returns <code>false</code>.\n *\n * <p>The behavior of this operation is undefined if any of the specified\n * graphs is modified while operation is in progress.</p>\n *\n * @param destination the graph to which vertices and edges are added.\n * @param source the graph used as source for vertices and edges to add.\n *\n * @return <code>true</code> if and only if the destination graph has been\n * changed as a result of this operation.\n */\npublic static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source) {\n    boolean modified = addAllVertices(destination, source.vertexSet());\n    modified |= addAllEdges(destination, source, source.edgeSet());\n    return modified;\n}"
            ],
            [
                "addAllEdges",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds a subset of the edges of the specified source graph to the specified\n * destination graph. The behavior of this operation is undefined if either\n * of the graphs is modified while the operation is in progress. {@link\n * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n * be added automatically to the target graph.\n *\n * @param destination the graph to which edges are to be added\n * @param source the graph used as a source for edges to add\n * @param edges the edges to be added\n *\n * @return <tt>true</tt> if this graph changed as a result of the call\n */\npublic static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges) {\n    boolean modified = false;\n    for (E e : edges) {\n        V s = source.getEdgeSource(e);\n        V t = source.getEdgeTarget(e);\n        destination.addVertex(s);\n        destination.addVertex(t);\n        modified |= destination.addEdge(s, t, e);\n    }\n    return modified;\n}"
            ],
            [
                "addAllVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all of the specified vertices to the destination graph. The behavior\n * of this operation is undefined if the specified vertex collection is\n * modified while the operation is in progress. This method will invoke the\n * {@link Graph#addVertex(Object)} method.\n *\n * @param destination the graph to which edges are to be added\n * @param vertices the vertices to be added to the graph.\n *\n * @return <tt>true</tt> if graph changed as a result of the call\n *\n * @throws NullPointerException if the specified vertices contains one or\n * more null vertices, or if the specified vertex collection is <tt>\n * null</tt>.\n *\n * @see Graph#addVertex(Object)\n */\npublic static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices) {\n    boolean modified = false;\n    for (V v : vertices) {\n        modified |= destination.addVertex(v);\n    }\n    return modified;\n}"
            ],
            [
                "neighborListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the neighbors of a specified vertex.\n * If the graph is a multigraph vertices may appear more than once in the\n * returned list.\n *\n * @param g the graph to look for neighbors in.\n * @param vertex the vertex to get the neighbors of.\n *\n * @return a list of the vertices that are the neighbors of the specified\n * vertex.\n */\npublic static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex) {\n    List<V> neighbors = new ArrayList<V>();\n    for (E e : g.edgesOf(vertex)) {\n        neighbors.add(getOppositeVertex(g, e, vertex));\n    }\n    return neighbors;\n}"
            ],
            [
                "predecessorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct predecessors of a\n * specified vertex. If the graph is a multigraph, vertices may appear more\n * than once in the returned list.\n *\n * @param g the graph to look for predecessors in.\n * @param vertex the vertex to get the predecessors of.\n *\n * @return a list of the vertices that are the direct predecessors of the\n * specified vertex.\n */\npublic static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> predecessors = new ArrayList<V>();\n    Set<? extends E> edges = g.incomingEdgesOf(vertex);\n    for (E e : edges) {\n        predecessors.add(getOppositeVertex(g, e, vertex));\n    }\n    return predecessors;\n}"
            ],
            [
                "successorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct successors of a specified\n * vertex. If the graph is a multigraph vertices may appear more than once\n * in the returned list.\n *\n * @param g the graph to look for successors in.\n * @param vertex the vertex to get the successors of.\n *\n * @return a list of the vertices that are the direct successors of the\n * specified vertex.\n */\npublic static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> successors = new ArrayList<V>();\n    Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n    for (E e : edges) {\n        successors.add(getOppositeVertex(g, e, vertex));\n    }\n    return successors;\n}"
            ],
            [
                "undirectedGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns an undirected view of the specified graph. If the specified graph\n * is directed, returns an undirected view of it. If the specified graph is\n * already undirected, just returns it.\n *\n * @param g the graph for which an undirected view is to be returned.\n *\n * @return an undirected view of the specified graph, if it is directed, or\n * or the specified graph itself if it is already undirected.\n *\n * @throws IllegalArgumentException if the graph is neither DirectedGraph\n * nor UndirectedGraph.\n *\n * @see AsUndirectedGraph\n */\npublic static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n    } else if (g instanceof UndirectedGraph<?, ?>) {\n        return (UndirectedGraph<V, E>) g;\n    } else {\n        throw new IllegalArgumentException(\"Graph must be either DirectedGraph or UndirectedGraph\");\n    }\n}"
            ],
            [
                "testIncidence",
                "org.jgrapht",
                "Graphs",
                "/**\n * Tests whether an edge is incident to a vertex.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return true iff e is incident on v\n */\npublic static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v) {\n    return (g.getEdgeSource(e).equals(v)) || (g.getEdgeTarget(e).equals(v));\n}"
            ],
            [
                "getOppositeVertex",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the vertex opposite another vertex across an edge.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return vertex opposite to v across e\n */\npublic static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v) {\n    V source = g.getEdgeSource(e);\n    V target = g.getEdgeTarget(e);\n    if (v.equals(source)) {\n        return target;\n    } else if (v.equals(target)) {\n        return source;\n    } else {\n        throw new IllegalArgumentException(\"no such vertex: \" + v.toString());\n    }\n}"
            ],
            [
                "getPathVertexList",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the list of vertices visited by a path.\n *\n * @param path path of interest\n *\n * @return corresponding vertex list\n */\npublic static <V, E> List<V> getPathVertexList(GraphPath<V, E> path) {\n    Graph<V, E> g = path.getGraph();\n    List<V> list = new ArrayList<V>();\n    V v = path.getStartVertex();\n    list.add(v);\n    for (E e : path.getEdgeList()) {\n        v = getOppositeVertex(g, e, v);\n        list.add(v);\n    }\n    return list;\n}"
            ],
            [
                "range",
                "org.jgrapht.generate",
                "SimpleWeightedGraphMatrixGenerator",
                "///////////////////////////////////////////////////////////////////////////////////////////////\npublic static int[] range(final int from, final int to) {\n    int[] range = new int[to - from];\n    for (int i = from; i < to; ++i) {\n        range[i - from] = i;\n    }\n    return range;\n}"
            ],
            [
                "createGraphSpecifics",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "// -------------------------------------------------------------------------\n/**\n * @param <V>\n * @param <E>\n * @param g\n *\n * @return TODO Document me\n */\nstatic <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new DirectedSpecifics<V, E>((DirectedGraph<V, E>) g);\n    } else {\n        return new UndirectedSpecifics<V, E>(g);\n    }\n}"
            ],
            [
                "findGreedyChromaticNumber",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds the number of colors required for a greedy coloring of the graph.\n *\n * @param g an undirected graph to find the chromatic number of\n *\n * @return integer the approximate chromatic number from the greedy\n * algorithm\n */\npublic static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g) {\n    Map<Integer, Set<V>> coloredGroups = findGreedyColoredGroups(g);\n    return coloredGroups.keySet().size();\n}"
            ],
            [
                "findGreedyColoredGroups",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds a greedy coloring of the graph.\n *\n * @param g an undirected graph for which to find the coloring\n */\npublic static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g) {\n    // A copy of the graph is made, so that elements of the graph may be\n    // removed to carry out the algorithm\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // The Vertices will be sorted in decreasing order by degree, so that\n    // higher degree vertices have priority to be colored first\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    List<V> sortedVertices = new LinkedList<V>(sg.vertexSet());\n    Collections.sort(sortedVertices, comp);\n    Collections.reverse(sortedVertices);\n    int color;\n    // create a map which will hold color as key and Set<V> as value\n    Map<Integer, Set<V>> coloredGroups = new HashMap<Integer, Set<V>>();\n    // We'll attempt to color each vertex with a single color each\n    // iteration, and these vertices will be removed from the graph at the\n    // end of each iteration\n    for (color = 0; sg.vertexSet().size() > 0; color++) {\n        // This set will contain vertices that are colored with the\n        // current color of this iteration\n        Set<V> currentColor = new HashSet<V>();\n        for (Iterator<V> iter = sortedVertices.iterator(); iter.hasNext(); ) {\n            V v = iter.next();\n            // Add new vertices to be colored as long as they are not\n            // adjacent with any other vertex that has already been colored\n            // with the current color\n            boolean flag = true;\n            for (Iterator<V> innerIter = currentColor.iterator(); innerIter.hasNext(); ) {\n                V temp = innerIter.next();\n                if (sg.containsEdge(temp, v)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                currentColor.add(v);\n                iter.remove();\n            }\n        }\n        // Add all these vertices as a group for this color\n        coloredGroups.put(color, currentColor);\n        // Remove vertices from the graph and then repeat the process for\n        // the next iteration\n        sg.removeAllVertices(currentColor);\n    }\n    return coloredGroups;\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "BellmanFordShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by hops, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    BellmanFordShortestPath<V, E> alg = new BellmanFordShortestPath<V, E>(graph, startVertex);\n    return alg.getPathEdgeList(endVertex);\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "DijkstraShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by radius, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    DijkstraShortestPath<V, E> alg = new DijkstraShortestPath<V, E>(graph, startVertex, endVertex);\n    return alg.getPathEdgeList();\n}"
            ],
            [
                "of",
                "org.jgrapht.alg.util",
                "Pair",
                "/**\n * Creates new pair of elements pulling of the necessity to provide\n * corresponding types of the elements supplied\n *\n * @param a first element\n * @param b second element\n *\n * @return new pair\n */\npublic static <A, B> Pair<A, B> of(A a, B b) {\n    return new Pair<A, B>(a, b);\n}"
            ],
            [
                "isEulerian",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will check whether the graph passed in is Eulerian or not.\n *\n * @param g The graph to be checked\n *\n * @return true for Eulerian and false for non-Eulerian\n */\npublic static <V, E> boolean isEulerian(UndirectedGraph<V, E> g) {\n    // If the graph is not connected, then no Eulerian circuit exists\n    if (!(new ConnectivityInspector<V, E>(g)).isGraphConnected()) {\n        return false;\n    }\n    // A graph is Eulerian if and only if all vertices have even degree\n    // So, this code will check for that\n    Iterator<V> iter = g.vertexSet().iterator();\n    while (iter.hasNext()) {\n        V v = iter.next();\n        if ((g.degreeOf(v) % 2) == 1) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "getEulerianCircuitVertices",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will return a list of vertices which represents the Eulerian\n * circuit of the graph.\n *\n * @param g The graph to find an Eulerian circuit\n *\n * @return null if no Eulerian circuit exists, or a list of vertices\n * representing the Eulerian circuit if one does exist\n */\npublic static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g) {\n    // If the graph is not Eulerian then just return a null since no\n    // Eulerian circuit exists\n    if (!isEulerian(g)) {\n        return null;\n    }\n    // The circuit will be represented by a linked list\n    List<V> path = new LinkedList<V>();\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    path.add(sg.vertexSet().iterator().next());\n    // Algorithm for finding an Eulerian circuit Basically this will find an\n    // arbitrary circuit, then it will find another arbitrary circuit until\n    // every edge has been traversed\n    while (sg.edgeSet().size() > 0) {\n        V v = null;\n        // Find a vertex which has an edge that hasn't been traversed yet,\n        // and keep its index position in the circuit list\n        int index = 0;\n        for (Iterator<V> iter = path.iterator(); iter.hasNext(); index++) {\n            v = iter.next();\n            if (sg.degreeOf(v) > 0) {\n                break;\n            }\n        }\n        // Finds an arbitrary circuit of the current vertex and\n        // appends this into the circuit list\n        while (sg.degreeOf(v) > 0) {\n            for (Iterator<V> iter = sg.vertexSet().iterator(); iter.hasNext(); ) {\n                V temp = iter.next();\n                if (sg.containsEdge(v, temp)) {\n                    path.add(index, temp);\n                    sg.removeEdge(v, temp);\n                    v = temp;\n                    break;\n                }\n            }\n        }\n    }\n    return path;\n}"
            ],
            [
                "getApproximateOptimalForCompleteGraph",
                "org.jgrapht.alg",
                "HamiltonianCycle",
                "/**\n * This method will return an approximate minimal traveling salesman tour\n * (hamiltonian cycle). This algorithm requires that the graph be complete\n * and the triangle inequality exists (if x,y,z are vertices then\n * d(x,y)+d(y,z) &lt; d(x,z) for all x,y,z) then this algorithm will\n * guarantee a hamiltonian cycle such that the total weight of the cycle is\n * less than or equal to double the total weight of the optimal hamiltonian\n * cycle. The optimal solution is NP-complete, so this is a decent\n * approximation that runs in polynomial time.\n *\n * @param <V>\n * @param <E>\n * @param g is the graph to find the optimal tour for.\n *\n * @return The optimal tour as a list of vertices.\n */\npublic static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g) {\n    List<V> vertices = new LinkedList<V>(g.vertexSet());\n    // If the graph is not complete then return null since this algorithm\n    // requires the graph be complete\n    if ((vertices.size() * (vertices.size() - 1) / 2) != g.edgeSet().size()) {\n        return null;\n    }\n    List<V> tour = new LinkedList<V>();\n    // Each iteration a new vertex will be added to the tour until all\n    // vertices have been added\n    while (tour.size() != g.vertexSet().size()) {\n        boolean firstEdge = true;\n        double minEdgeValue = 0;\n        int minVertexFound = 0;\n        int vertexConnectedTo = 0;\n        // A check will be made for the shortest edge to a vertex not within\n        // the tour and that new vertex will be added to the vertex\n        for (int i = 0; i < tour.size(); i++) {\n            V v = tour.get(i);\n            for (int j = 0; j < vertices.size(); j++) {\n                double weight = g.getEdgeWeight(g.getEdge(v, vertices.get(j)));\n                if (firstEdge || (weight < minEdgeValue)) {\n                    firstEdge = false;\n                    minEdgeValue = weight;\n                    minVertexFound = j;\n                    vertexConnectedTo = i;\n                }\n            }\n        }\n        tour.add(vertexConnectedTo, vertices.get(minVertexFound));\n        vertices.remove(minVertexFound);\n    }\n    return tour;\n}"
            ],
            [
                "find2ApproximationCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a 2-approximation for a minimal vertex cover of the specified\n * graph. The algorithm promises a cover that is at most double the size of\n * a minimal cover. The algorithm takes O(|E|) time.\n *\n * <p>For more details see Jenny Walter, CMPU-240: Lecture notes for\n * Language Theory and Computation, Fall 2002, Vassar College, <a\n * href=\"http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf\">\n * http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf</a>.\n * </p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G'=(V',E') <-- G(V,E)\n    Subgraph<V, E, Graph<V, E>> sg = new Subgraph<V, E, Graph<V, E>>(g, null, null);\n    // while E' is non-empty\n    while (sg.edgeSet().size() > 0) {\n        // let (u,v) be an arbitrary edge of E'\n        E e = sg.edgeSet().iterator().next();\n        // C <-- C U {u,v}\n        V u = g.getEdgeSource(e);\n        V v = g.getEdgeTarget(e);\n        cover.add(u);\n        cover.add(v);\n        // remove from E' every edge incident on either u or v\n        sg.removeVertex(u);\n        sg.removeVertex(v);\n    }\n    // return C\n    return cover;\n}"
            ],
            [
                "findGreedyCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a greedy approximation for a minimal vertex cover of a specified\n * graph. At each iteration, the algorithm picks the vertex with the highest\n * degree and adds it to the cover, until all edges are covered.\n *\n * <p>The algorithm works on undirected graphs, but can also work on\n * directed graphs when their edge-directions are ignored. To ignore edge\n * directions you can use {@link org.jgrapht.Graphs#undirectedGraph(Graph)}\n * or {@link org.jgrapht.graph.AsUndirectedGraph}.</p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G' <-- G\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // compare vertices in descending order of degree\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    // while G' != {}\n    while (sg.edgeSet().size() > 0) {\n        // v <-- vertex with maximum degree in G'\n        V v = Collections.max(sg.vertexSet(), comp);\n        // C <-- C U {v}\n        cover.add(v);\n        // remove from G' every edge incident on v, and v itself\n        sg.removeVertex(v);\n    }\n    return cover;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "BEST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int BEST_ORDER = 0;"
            ],
            [
                "NATURAL_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int NATURAL_ORDER = 1;"
            ],
            [
                "SMALLEST_DEGREE_LAST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;"
            ],
            [
                "LARGEST_SATURATION_FIRST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;"
            ],
            [
                "DEFAULT_EDGE_WEIGHT",
                "org.jgrapht",
                "WeightedGraph",
                "/**\n * The default weight for an edge.\n */\npublic static double DEFAULT_EDGE_WEIGHT = 1.0;"
            ],
            [
                "HUB_VERTEX",
                "org.jgrapht.generate",
                "WheelGraphGenerator",
                "/**\n * Role for the hub vertex.\n */\npublic static final String HUB_VERTEX = \"Hub Vertex\";"
            ],
            [
                "CORNER_VERTEX",
                "org.jgrapht.generate",
                "GridGraphGenerator",
                "/**\n * Role for the vertices at the corners.\n */\npublic static final String CORNER_VERTEX = \"Corner Vertex\";"
            ],
            [
                "START_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the first vertex generated.\n */\npublic static final String START_VERTEX = \"Start Vertex\";"
            ],
            [
                "END_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the last vertex generated.\n */\npublic static final String END_VERTEX = \"End Vertex\";"
            ],
            [
                "CENTER_VERTEX",
                "org.jgrapht.generate",
                "StarGraphGenerator",
                "public static final String CENTER_VERTEX = \"Center Vertex\";"
            ],
            [
                "SENTINEL",
                "org.jgrapht.traverse",
                "DepthFirstIterator",
                "/**\n * Sentinel object. Unfortunately, we can't use null, because ArrayDeque\n * won't accept those. And we don't want to rely on the caller to provide a\n * sentinel object for us. So we have to play typecasting games.\n */\npublic static final Object SENTINEL = new Object();"
            ],
            [
                "BEFORE_EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge added event. This event is fired before an edge is added to a\n * graph.\n */\npublic static final int BEFORE_EDGE_ADDED = 21;"
            ],
            [
                "BEFORE_EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge removed event. This event is fired before an edge is removed\n * from a graph.\n */\npublic static final int BEFORE_EDGE_REMOVED = 22;"
            ],
            [
                "EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge added event. This event is fired after an edge is added to a graph.\n */\npublic static final int EDGE_ADDED = 23;"
            ],
            [
                "EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge removed event. This event is fired after an edge is removed from a\n * graph.\n */\npublic static final int EDGE_REMOVED = 24;"
            ],
            [
                "CONNECTED_COMPONENT_STARTED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal started event.\n */\npublic static final int CONNECTED_COMPONENT_STARTED = 31;"
            ],
            [
                "CONNECTED_COMPONENT_FINISHED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal finished event.\n */\npublic static final int CONNECTED_COMPONENT_FINISHED = 32;"
            ],
            [
                "BEFORE_VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex added event. This event is fired before a vertex is added\n * to a graph.\n */\npublic static final int BEFORE_VERTEX_ADDED = 11;"
            ],
            [
                "BEFORE_VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex removed event. This event is fired before a vertex is\n * removed from a graph.\n */\npublic static final int BEFORE_VERTEX_REMOVED = 12;"
            ],
            [
                "VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex added event. This event is fired after a vertex is added to a\n * graph.\n */\npublic static final int VERTEX_ADDED = 13;"
            ],
            [
                "VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex removed event. This event is fired after a vertex is removed from\n * a graph.\n */\npublic static final int VERTEX_REMOVED = 14;"
            ],
            [
                "NULL_NODE",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "public static final int NULL_NODE = -1;"
            ],
            [
                "DEBUG",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected static final boolean DEBUG = false;"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg",
                "EdmondsKarpMaximumFlow",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 0.000000001;"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveClosure",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveClosure INSTANCE = new TransitiveClosure();"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveReduction",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveReduction INSTANCE = new TransitiveReduction();"
            ],
            [
                "NEGATIVE_UNDIRECTED_EDGE",
                "org.jgrapht.alg",
                "BellmanFordIterator",
                "/**\n * Error message.\n */\nprotected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg.flow",
                "MaximumFlowAlgorithmBase",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 1e-9;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [
            [
                "partitionOne",
                "",
                "int"
            ],
            [
                "partitionTwo",
                "",
                "int"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 26149,
        "oracle": ";",
        "oracleType": "PRE",
        "projectName": "jgrapht-core-0.9.2",
        "packageName": "org.jgrapht",
        "className": "UndirectedGraph",
        "javadocTag": "@param vertex vertex whose degree is to be calculated.",
        "methodJavadoc": "    /**\n     * Returns the degree of the specified vertex. A degree of a vertex in an\n     * undirected graph is the number of edges touching that vertex.\n     *\n     * @param vertex vertex whose degree is to be calculated.\n     *\n     * @return the degree of the specified vertex.\n     */",
        "methodSourceCode": "public int degreeOf(V vertex);",
        "classJavadoc": "/**\n * A graph whose all edges are undirected. This is the root interface of all\n * undirected graphs.\n *\n * <p>See <a href=\"http://mathworld.wolfram.com/Graph.html\">\n * http://mathworld.wolfram.com/Graph.html</a> for more on undirected and on\n * directed graphs.</p>\n *\n * @author Barak Naveh\n * @since Jul 14, 2003\n */",
        "classSourceCode": "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* --------------------\n * UndirectedGraph.java\n * --------------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 24-Jul-2003 : Initial revision (BN);\n * 11-Mar-2004 : Made generic (CH);\n *\n */\npackage org.jgrapht;\n\n/**\n * A graph whose all edges are undirected. This is the root interface of all\n * undirected graphs.\n *\n * <p>See <a href=\"http://mathworld.wolfram.com/Graph.html\">\n * http://mathworld.wolfram.com/Graph.html</a> for more on undirected and on\n * directed graphs.</p>\n *\n * @author Barak Naveh\n * @since Jul 14, 2003\n */\npublic interface UndirectedGraph<V, E>\n    extends Graph<V, E>\n{\n    /**\n     * Returns the degree of the specified vertex. A degree of a vertex in an\n     * undirected graph is the number of edges touching that vertex.\n     *\n     * @param vertex vertex whose degree is to be calculated.\n     *\n     * @return the degree of the specified vertex.\n     */\n    public int degreeOf(V vertex);\n}\n\n// End UndirectedGraph.java\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "PartiteRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "RandomGraphHelper",
                "org.jgrapht.experimental"
            ],
            [
                "GraphReader",
                "org.jgrapht.experimental"
            ],
            [
                "DirectedAcyclicGraph",
                "org.jgrapht.experimental.dag"
            ],
            [
                "GraphSquare",
                "org.jgrapht.experimental"
            ],
            [
                "UniformRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "GraphTests",
                "org.jgrapht.experimental"
            ],
            [
                "ApproximationAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "BrownBacktrackColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "GreedyColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "IntArrayGraphAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ExactAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ListenableGraph",
                "org.jgrapht"
            ],
            [
                "ModifiableInteger",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeapNode",
                "org.jgrapht.util"
            ],
            [
                "WeightCombiner",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeap",
                "org.jgrapht.util"
            ],
            [
                "TypeUtil",
                "org.jgrapht.util"
            ],
            [
                "ArrayUnenforcedSet",
                "org.jgrapht.util"
            ],
            [
                "VertexPair",
                "org.jgrapht.util"
            ],
            [
                "MathUtil",
                "org.jgrapht.util"
            ],
            [
                "PrefetchIterator",
                "org.jgrapht.util"
            ],
            [
                "VertexFactory",
                "org.jgrapht"
            ],
            [
                "Graph",
                "org.jgrapht"
            ],
            [
                "GraphPath",
                "org.jgrapht"
            ],
            [
                "UndirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraph",
                "org.jgrapht.graph"
            ],
            [
                "MixedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DefaultGraphMapping",
                "org.jgrapht.graph"
            ],
            [
                "WeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskEdgeSet",
                "org.jgrapht.graph"
            ],
            [
                "Pseudograph",
                "org.jgrapht.graph"
            ],
            [
                "MaskFunctor",
                "org.jgrapht.graph"
            ],
            [
                "GraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractBaseGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "Multigraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultWeightedEdge",
                "org.jgrapht.graph"
            ],
            [
                "ListenableDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeSetFactory",
                "org.jgrapht.graph"
            ],
            [
                "GraphDelegator",
                "org.jgrapht.graph"
            ],
            [
                "DefaultListenableGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedVertexFactory",
                "org.jgrapht.graph"
            ],
            [
                "DefaultEdge",
                "org.jgrapht.graph"
            ],
            [
                "MaskVertexSet",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "IntrusiveEdge",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphPathImpl",
                "org.jgrapht.graph"
            ],
            [
                "Subgraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractGraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedEdgeFactory",
                "org.jgrapht.graph"
            ],
            [
                "SimpleWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "WeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeReversedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "AbstractGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "ListenableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraphPath",
                "org.jgrapht.graph"
            ],
            [
                "ParanoidGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphHelper",
                "org.jgrapht"
            ],
            [
                "Graphs",
                "org.jgrapht"
            ],
            [
                "DirectedGraph",
                "org.jgrapht"
            ],
            [
                "WeightedGraph",
                "org.jgrapht"
            ],
            [
                "HyperCubeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RingGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WheelGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GridGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "ScaleFreeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedBipartiteGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "LinearGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RandomGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGeneratorAdapter",
                "org.jgrapht.generate"
            ],
            [
                "EmptyGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteBipartiteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "StarGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "UndirectedGraph",
                "org.jgrapht"
            ],
            [
                "TopologicalOrderIterator",
                "org.jgrapht.traverse"
            ],
            [
                "CrossComponentIterator",
                "org.jgrapht.traverse"
            ],
            [
                "AbstractGraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "ClosestFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "BreadthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "DepthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "GraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "EdgeFactory",
                "org.jgrapht"
            ],
            [
                "GraphMapping",
                "org.jgrapht"
            ],
            [
                "VertexSetListener",
                "org.jgrapht.event"
            ],
            [
                "EdgeTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "TraversalListener",
                "org.jgrapht.event"
            ],
            [
                "GraphEdgeChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "VertexTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphListener",
                "org.jgrapht.event"
            ],
            [
                "TraversalListenerAdapter",
                "org.jgrapht.event"
            ],
            [
                "ConnectedComponentTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphVertexChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "TarjanLowestCommonAncestor",
                "org.jgrapht.alg"
            ],
            [
                "PrimMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "BlockCutpointGraph",
                "org.jgrapht.alg"
            ],
            [
                "AllDirectedPaths",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPathsIterator",
                "org.jgrapht.alg"
            ],
            [
                "KruskalMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "StrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "VF2State",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2AbstractIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "GraphOrdering",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphicGraphMapping",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2MappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "BronKerboschCliqueFinder",
                "org.jgrapht.alg"
            ],
            [
                "ChromaticNumber",
                "org.jgrapht.alg"
            ],
            [
                "KosarajuStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "DijkstraShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElement",
                "org.jgrapht.alg"
            ],
            [
                "AStarShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordPathElement",
                "org.jgrapht.alg"
            ],
            [
                "FloydWarshallShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "UnionFind",
                "org.jgrapht.alg.util"
            ],
            [
                "AlwaysEqualComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Extension",
                "org.jgrapht.alg.util"
            ],
            [
                "VertexDegreeComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Pair",
                "org.jgrapht.alg.util"
            ],
            [
                "GabowStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "HawickJamesSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "DirectedSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "JohnsonSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TiernanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "UndirectedCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "PatonCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TarjanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "SzwarcfiterLauerSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "BiconnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "ConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "MinSourceSinkCut",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsBlossomShrinking",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveClosure",
                "org.jgrapht.alg"
            ],
            [
                "HopcroftKarpBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "StoerWagnerMinimumCut",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "KuhnMunkresMinimalWeightBipartitePerfectMatching",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveReduction",
                "org.jgrapht.alg"
            ],
            [
                "EulerianCircuit",
                "org.jgrapht.alg"
            ],
            [
                "DirectedNeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "NaiveLcaFinder",
                "org.jgrapht.alg"
            ],
            [
                "MaximumWeightBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "HamiltonianCycle",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "NeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "VertexCovers",
                "org.jgrapht.alg"
            ],
            [
                "CycleDetector",
                "org.jgrapht.alg"
            ],
            [
                "AStarAdmissibleHeuristic",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MinimumSpanningTree",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "WeightedMatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "StrongConnectivityAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MaximumFlowAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "CliqueMinimalSeparatorDecomposition",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordIterator",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElement",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "PushRelabelMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "MaximumFlowAlgorithmBase",
                "org.jgrapht.alg.flow"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "addVertices",
                "org.jgrapht.experimental",
                "RandomGraphHelper",
                "/**\n * .\n *\n * @param target\n * @param vertexFactory\n * @param numVertices\n *\n * @return vertices\n */\n@SuppressWarnings(\"unchecked\")\npublic static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices) {\n    Object[] vertices = new Object[numVertices];\n    for (int i = 0; i < numVertices; ++i) {\n        vertices[i] = vertexFactory.createVertex();\n        target.addVertex(vertices[i]);\n    }\n    return vertices;\n}"
            ],
            [
                "isEmpty",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isEmpty(Graph<V, E> g) {\n    return g.edgeSet().isEmpty();\n}"
            ],
            [
                "isComplete",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isComplete(Graph<V, E> g) {\n    int n = g.vertexSet().size();\n    return g.edgeSet().size() == (n * (n - 1) / 2);\n}"
            ],
            [
                "isConnected",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isConnected(Graph<V, E> g) {\n    int numVertices = g.vertexSet().size();\n    int numEdges = g.edgeSet().size();\n    if (numEdges < (numVertices - 1)) {\n        return false;\n    }\n    if ((numVertices < 2) || (numEdges > ((numVertices - 1) * (numVertices - 2) / 2))) {\n        return true;\n    }\n    Set<V> known = new HashSet<V>();\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = g.vertexSet().iterator().next();\n    // start with node 1\n    queue.add(v);\n    known.add(v);\n    while (!queue.isEmpty()) {\n        v = queue.removeFirst();\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            v = it.next();\n            if (!known.contains(v)) {\n                known.add(v);\n                queue.add(v);\n            }\n        }\n    }\n    return known.size() == numVertices;\n}"
            ],
            [
                "isTree",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isTree(Graph<V, E> g) {\n    return isConnected(g) && (g.edgeSet().size() == (g.vertexSet().size() - 1));\n}"
            ],
            [
                "isBipartite",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isBipartite(Graph<V, E> g) {\n    if ((4 * g.edgeSet().size()) > (g.vertexSet().size() * g.vertexSet().size())) {\n        return false;\n    }\n    if (isEmpty(g)) {\n        return true;\n    }\n    Set<V> unknown = new HashSet<V>(g.vertexSet());\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = unknown.iterator().next();\n    Set<V> odd = new HashSet<V>();\n    queue.add(v);\n    while (!unknown.isEmpty()) {\n        if (queue.isEmpty()) {\n            queue.add(unknown.iterator().next());\n        }\n        v = queue.removeFirst();\n        unknown.remove(v);\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            V n = it.next();\n            if (unknown.contains(n)) {\n                queue.add(n);\n                if (!odd.contains(v)) {\n                    odd.add(n);\n                }\n            } else if (!(odd.contains(v) ^ odd.contains(n))) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
            ],
            [
                "union",
                "org.jgrapht.util",
                "FibonacciHeap",
                "// size\n/**\n * Joins two Fibonacci heaps into a new one. No heap consolidation is\n * performed at this time. The two root lists are simply joined together.\n *\n * <p>Running time: O(1) actual</p>\n *\n * @param h1 first heap\n * @param h2 second heap\n *\n * @return new heap containing h1 and h2\n */\npublic static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2) {\n    FibonacciHeap<T> h = new FibonacciHeap<T>();\n    if ((h1 != null) && (h2 != null)) {\n        h.minNode = h1.minNode;\n        if (h.minNode != null) {\n            if (h2.minNode != null) {\n                h.minNode.right.left = h2.minNode.left;\n                h2.minNode.left.right = h.minNode.right;\n                h.minNode.right = h2.minNode;\n                h2.minNode.left = h.minNode;\n                if (h2.minNode.key < h1.minNode.key) {\n                    h.minNode = h2.minNode;\n                }\n            }\n        } else {\n            h.minNode = h2.minNode;\n        }\n        h.nNodes = h1.nNodes + h2.nNodes;\n    }\n    return h;\n}"
            ],
            [
                "uncheckedCast",
                "org.jgrapht.util",
                "TypeUtil",
                "/**\n * Casts an object to a type.\n *\n * @param o object to be cast\n * @param typeDecl conveys the target type information; the actual value is\n * unused and can be null since this is all just stupid compiler tricks\n *\n * @return the result of the cast\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl) {\n    return (T) o;\n}"
            ],
            [
                "factorial",
                "org.jgrapht.util",
                "MathUtil",
                "public static long factorial(int N) {\n    long multi = 1;\n    for (int i = 1; i <= N; i++) {\n        multi = multi * i;\n    }\n    return multi;\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graphs",
                "/**\n * Creates a new edge and adds it to the specified graph similarly to the\n * {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n *\n * @see Graph#addEdge(Object, Object)\n */\npublic static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    EdgeFactory<V, E> ef = g.getEdgeFactory();\n    E e = ef.createEdge(sourceVertex, targetVertex);\n    // we first create the edge and set the weight to make sure that\n    // listeners will see the correct weight upon addEdge.\n    assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n    ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n    return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new edge and adds it to the specified\n * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return g.addEdge(sourceVertex, targetVertex);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified edge to the graph, including its vertices if not\n * already included.\n *\n * @param targetGraph the graph for which the specified edge to be added.\n * @param sourceGraph the graph in which the specified edge is already\n * present\n * @param edge edge to add\n *\n * @return <tt>true</tt> if the target graph did not already contain the\n * specified edge.\n */\npublic static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge) {\n    V sourceVertex = sourceGraph.getEdgeSource(edge);\n    V targetVertex = sourceGraph.getEdgeTarget(edge);\n    targetGraph.addVertex(sourceVertex);\n    targetGraph.addVertex(targetVertex);\n    return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new weighted edge and adds it to the\n * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n * method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return addEdge(g, sourceVertex, targetVertex, weight);\n}"
            ],
            [
                "addGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all the vertices and all the edges of the specified source graph to\n * the specified destination graph. First all vertices of the source graph\n * are added to the destination graph. Then every edge of the source graph\n * is added to the destination graph. This method returns <code>true</code>\n * if the destination graph has been modified as a result of this operation,\n * otherwise it returns <code>false</code>.\n *\n * <p>The behavior of this operation is undefined if any of the specified\n * graphs is modified while operation is in progress.</p>\n *\n * @param destination the graph to which vertices and edges are added.\n * @param source the graph used as source for vertices and edges to add.\n *\n * @return <code>true</code> if and only if the destination graph has been\n * changed as a result of this operation.\n */\npublic static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source) {\n    boolean modified = addAllVertices(destination, source.vertexSet());\n    modified |= addAllEdges(destination, source, source.edgeSet());\n    return modified;\n}"
            ],
            [
                "addAllEdges",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds a subset of the edges of the specified source graph to the specified\n * destination graph. The behavior of this operation is undefined if either\n * of the graphs is modified while the operation is in progress. {@link\n * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n * be added automatically to the target graph.\n *\n * @param destination the graph to which edges are to be added\n * @param source the graph used as a source for edges to add\n * @param edges the edges to be added\n *\n * @return <tt>true</tt> if this graph changed as a result of the call\n */\npublic static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges) {\n    boolean modified = false;\n    for (E e : edges) {\n        V s = source.getEdgeSource(e);\n        V t = source.getEdgeTarget(e);\n        destination.addVertex(s);\n        destination.addVertex(t);\n        modified |= destination.addEdge(s, t, e);\n    }\n    return modified;\n}"
            ],
            [
                "addAllVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all of the specified vertices to the destination graph. The behavior\n * of this operation is undefined if the specified vertex collection is\n * modified while the operation is in progress. This method will invoke the\n * {@link Graph#addVertex(Object)} method.\n *\n * @param destination the graph to which edges are to be added\n * @param vertices the vertices to be added to the graph.\n *\n * @return <tt>true</tt> if graph changed as a result of the call\n *\n * @throws NullPointerException if the specified vertices contains one or\n * more null vertices, or if the specified vertex collection is <tt>\n * null</tt>.\n *\n * @see Graph#addVertex(Object)\n */\npublic static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices) {\n    boolean modified = false;\n    for (V v : vertices) {\n        modified |= destination.addVertex(v);\n    }\n    return modified;\n}"
            ],
            [
                "neighborListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the neighbors of a specified vertex.\n * If the graph is a multigraph vertices may appear more than once in the\n * returned list.\n *\n * @param g the graph to look for neighbors in.\n * @param vertex the vertex to get the neighbors of.\n *\n * @return a list of the vertices that are the neighbors of the specified\n * vertex.\n */\npublic static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex) {\n    List<V> neighbors = new ArrayList<V>();\n    for (E e : g.edgesOf(vertex)) {\n        neighbors.add(getOppositeVertex(g, e, vertex));\n    }\n    return neighbors;\n}"
            ],
            [
                "predecessorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct predecessors of a\n * specified vertex. If the graph is a multigraph, vertices may appear more\n * than once in the returned list.\n *\n * @param g the graph to look for predecessors in.\n * @param vertex the vertex to get the predecessors of.\n *\n * @return a list of the vertices that are the direct predecessors of the\n * specified vertex.\n */\npublic static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> predecessors = new ArrayList<V>();\n    Set<? extends E> edges = g.incomingEdgesOf(vertex);\n    for (E e : edges) {\n        predecessors.add(getOppositeVertex(g, e, vertex));\n    }\n    return predecessors;\n}"
            ],
            [
                "successorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct successors of a specified\n * vertex. If the graph is a multigraph vertices may appear more than once\n * in the returned list.\n *\n * @param g the graph to look for successors in.\n * @param vertex the vertex to get the successors of.\n *\n * @return a list of the vertices that are the direct successors of the\n * specified vertex.\n */\npublic static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> successors = new ArrayList<V>();\n    Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n    for (E e : edges) {\n        successors.add(getOppositeVertex(g, e, vertex));\n    }\n    return successors;\n}"
            ],
            [
                "undirectedGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns an undirected view of the specified graph. If the specified graph\n * is directed, returns an undirected view of it. If the specified graph is\n * already undirected, just returns it.\n *\n * @param g the graph for which an undirected view is to be returned.\n *\n * @return an undirected view of the specified graph, if it is directed, or\n * or the specified graph itself if it is already undirected.\n *\n * @throws IllegalArgumentException if the graph is neither DirectedGraph\n * nor UndirectedGraph.\n *\n * @see AsUndirectedGraph\n */\npublic static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n    } else if (g instanceof UndirectedGraph<?, ?>) {\n        return (UndirectedGraph<V, E>) g;\n    } else {\n        throw new IllegalArgumentException(\"Graph must be either DirectedGraph or UndirectedGraph\");\n    }\n}"
            ],
            [
                "testIncidence",
                "org.jgrapht",
                "Graphs",
                "/**\n * Tests whether an edge is incident to a vertex.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return true iff e is incident on v\n */\npublic static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v) {\n    return (g.getEdgeSource(e).equals(v)) || (g.getEdgeTarget(e).equals(v));\n}"
            ],
            [
                "getOppositeVertex",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the vertex opposite another vertex across an edge.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return vertex opposite to v across e\n */\npublic static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v) {\n    V source = g.getEdgeSource(e);\n    V target = g.getEdgeTarget(e);\n    if (v.equals(source)) {\n        return target;\n    } else if (v.equals(target)) {\n        return source;\n    } else {\n        throw new IllegalArgumentException(\"no such vertex: \" + v.toString());\n    }\n}"
            ],
            [
                "getPathVertexList",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the list of vertices visited by a path.\n *\n * @param path path of interest\n *\n * @return corresponding vertex list\n */\npublic static <V, E> List<V> getPathVertexList(GraphPath<V, E> path) {\n    Graph<V, E> g = path.getGraph();\n    List<V> list = new ArrayList<V>();\n    V v = path.getStartVertex();\n    list.add(v);\n    for (E e : path.getEdgeList()) {\n        v = getOppositeVertex(g, e, v);\n        list.add(v);\n    }\n    return list;\n}"
            ],
            [
                "range",
                "org.jgrapht.generate",
                "SimpleWeightedGraphMatrixGenerator",
                "///////////////////////////////////////////////////////////////////////////////////////////////\npublic static int[] range(final int from, final int to) {\n    int[] range = new int[to - from];\n    for (int i = from; i < to; ++i) {\n        range[i - from] = i;\n    }\n    return range;\n}"
            ],
            [
                "createGraphSpecifics",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "// -------------------------------------------------------------------------\n/**\n * @param <V>\n * @param <E>\n * @param g\n *\n * @return TODO Document me\n */\nstatic <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new DirectedSpecifics<V, E>((DirectedGraph<V, E>) g);\n    } else {\n        return new UndirectedSpecifics<V, E>(g);\n    }\n}"
            ],
            [
                "findGreedyChromaticNumber",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds the number of colors required for a greedy coloring of the graph.\n *\n * @param g an undirected graph to find the chromatic number of\n *\n * @return integer the approximate chromatic number from the greedy\n * algorithm\n */\npublic static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g) {\n    Map<Integer, Set<V>> coloredGroups = findGreedyColoredGroups(g);\n    return coloredGroups.keySet().size();\n}"
            ],
            [
                "findGreedyColoredGroups",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds a greedy coloring of the graph.\n *\n * @param g an undirected graph for which to find the coloring\n */\npublic static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g) {\n    // A copy of the graph is made, so that elements of the graph may be\n    // removed to carry out the algorithm\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // The Vertices will be sorted in decreasing order by degree, so that\n    // higher degree vertices have priority to be colored first\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    List<V> sortedVertices = new LinkedList<V>(sg.vertexSet());\n    Collections.sort(sortedVertices, comp);\n    Collections.reverse(sortedVertices);\n    int color;\n    // create a map which will hold color as key and Set<V> as value\n    Map<Integer, Set<V>> coloredGroups = new HashMap<Integer, Set<V>>();\n    // We'll attempt to color each vertex with a single color each\n    // iteration, and these vertices will be removed from the graph at the\n    // end of each iteration\n    for (color = 0; sg.vertexSet().size() > 0; color++) {\n        // This set will contain vertices that are colored with the\n        // current color of this iteration\n        Set<V> currentColor = new HashSet<V>();\n        for (Iterator<V> iter = sortedVertices.iterator(); iter.hasNext(); ) {\n            V v = iter.next();\n            // Add new vertices to be colored as long as they are not\n            // adjacent with any other vertex that has already been colored\n            // with the current color\n            boolean flag = true;\n            for (Iterator<V> innerIter = currentColor.iterator(); innerIter.hasNext(); ) {\n                V temp = innerIter.next();\n                if (sg.containsEdge(temp, v)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                currentColor.add(v);\n                iter.remove();\n            }\n        }\n        // Add all these vertices as a group for this color\n        coloredGroups.put(color, currentColor);\n        // Remove vertices from the graph and then repeat the process for\n        // the next iteration\n        sg.removeAllVertices(currentColor);\n    }\n    return coloredGroups;\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "BellmanFordShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by hops, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    BellmanFordShortestPath<V, E> alg = new BellmanFordShortestPath<V, E>(graph, startVertex);\n    return alg.getPathEdgeList(endVertex);\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "DijkstraShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by radius, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    DijkstraShortestPath<V, E> alg = new DijkstraShortestPath<V, E>(graph, startVertex, endVertex);\n    return alg.getPathEdgeList();\n}"
            ],
            [
                "of",
                "org.jgrapht.alg.util",
                "Pair",
                "/**\n * Creates new pair of elements pulling of the necessity to provide\n * corresponding types of the elements supplied\n *\n * @param a first element\n * @param b second element\n *\n * @return new pair\n */\npublic static <A, B> Pair<A, B> of(A a, B b) {\n    return new Pair<A, B>(a, b);\n}"
            ],
            [
                "isEulerian",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will check whether the graph passed in is Eulerian or not.\n *\n * @param g The graph to be checked\n *\n * @return true for Eulerian and false for non-Eulerian\n */\npublic static <V, E> boolean isEulerian(UndirectedGraph<V, E> g) {\n    // If the graph is not connected, then no Eulerian circuit exists\n    if (!(new ConnectivityInspector<V, E>(g)).isGraphConnected()) {\n        return false;\n    }\n    // A graph is Eulerian if and only if all vertices have even degree\n    // So, this code will check for that\n    Iterator<V> iter = g.vertexSet().iterator();\n    while (iter.hasNext()) {\n        V v = iter.next();\n        if ((g.degreeOf(v) % 2) == 1) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "getEulerianCircuitVertices",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will return a list of vertices which represents the Eulerian\n * circuit of the graph.\n *\n * @param g The graph to find an Eulerian circuit\n *\n * @return null if no Eulerian circuit exists, or a list of vertices\n * representing the Eulerian circuit if one does exist\n */\npublic static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g) {\n    // If the graph is not Eulerian then just return a null since no\n    // Eulerian circuit exists\n    if (!isEulerian(g)) {\n        return null;\n    }\n    // The circuit will be represented by a linked list\n    List<V> path = new LinkedList<V>();\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    path.add(sg.vertexSet().iterator().next());\n    // Algorithm for finding an Eulerian circuit Basically this will find an\n    // arbitrary circuit, then it will find another arbitrary circuit until\n    // every edge has been traversed\n    while (sg.edgeSet().size() > 0) {\n        V v = null;\n        // Find a vertex which has an edge that hasn't been traversed yet,\n        // and keep its index position in the circuit list\n        int index = 0;\n        for (Iterator<V> iter = path.iterator(); iter.hasNext(); index++) {\n            v = iter.next();\n            if (sg.degreeOf(v) > 0) {\n                break;\n            }\n        }\n        // Finds an arbitrary circuit of the current vertex and\n        // appends this into the circuit list\n        while (sg.degreeOf(v) > 0) {\n            for (Iterator<V> iter = sg.vertexSet().iterator(); iter.hasNext(); ) {\n                V temp = iter.next();\n                if (sg.containsEdge(v, temp)) {\n                    path.add(index, temp);\n                    sg.removeEdge(v, temp);\n                    v = temp;\n                    break;\n                }\n            }\n        }\n    }\n    return path;\n}"
            ],
            [
                "getApproximateOptimalForCompleteGraph",
                "org.jgrapht.alg",
                "HamiltonianCycle",
                "/**\n * This method will return an approximate minimal traveling salesman tour\n * (hamiltonian cycle). This algorithm requires that the graph be complete\n * and the triangle inequality exists (if x,y,z are vertices then\n * d(x,y)+d(y,z) &lt; d(x,z) for all x,y,z) then this algorithm will\n * guarantee a hamiltonian cycle such that the total weight of the cycle is\n * less than or equal to double the total weight of the optimal hamiltonian\n * cycle. The optimal solution is NP-complete, so this is a decent\n * approximation that runs in polynomial time.\n *\n * @param <V>\n * @param <E>\n * @param g is the graph to find the optimal tour for.\n *\n * @return The optimal tour as a list of vertices.\n */\npublic static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g) {\n    List<V> vertices = new LinkedList<V>(g.vertexSet());\n    // If the graph is not complete then return null since this algorithm\n    // requires the graph be complete\n    if ((vertices.size() * (vertices.size() - 1) / 2) != g.edgeSet().size()) {\n        return null;\n    }\n    List<V> tour = new LinkedList<V>();\n    // Each iteration a new vertex will be added to the tour until all\n    // vertices have been added\n    while (tour.size() != g.vertexSet().size()) {\n        boolean firstEdge = true;\n        double minEdgeValue = 0;\n        int minVertexFound = 0;\n        int vertexConnectedTo = 0;\n        // A check will be made for the shortest edge to a vertex not within\n        // the tour and that new vertex will be added to the vertex\n        for (int i = 0; i < tour.size(); i++) {\n            V v = tour.get(i);\n            for (int j = 0; j < vertices.size(); j++) {\n                double weight = g.getEdgeWeight(g.getEdge(v, vertices.get(j)));\n                if (firstEdge || (weight < minEdgeValue)) {\n                    firstEdge = false;\n                    minEdgeValue = weight;\n                    minVertexFound = j;\n                    vertexConnectedTo = i;\n                }\n            }\n        }\n        tour.add(vertexConnectedTo, vertices.get(minVertexFound));\n        vertices.remove(minVertexFound);\n    }\n    return tour;\n}"
            ],
            [
                "find2ApproximationCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a 2-approximation for a minimal vertex cover of the specified\n * graph. The algorithm promises a cover that is at most double the size of\n * a minimal cover. The algorithm takes O(|E|) time.\n *\n * <p>For more details see Jenny Walter, CMPU-240: Lecture notes for\n * Language Theory and Computation, Fall 2002, Vassar College, <a\n * href=\"http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf\">\n * http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf</a>.\n * </p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G'=(V',E') <-- G(V,E)\n    Subgraph<V, E, Graph<V, E>> sg = new Subgraph<V, E, Graph<V, E>>(g, null, null);\n    // while E' is non-empty\n    while (sg.edgeSet().size() > 0) {\n        // let (u,v) be an arbitrary edge of E'\n        E e = sg.edgeSet().iterator().next();\n        // C <-- C U {u,v}\n        V u = g.getEdgeSource(e);\n        V v = g.getEdgeTarget(e);\n        cover.add(u);\n        cover.add(v);\n        // remove from E' every edge incident on either u or v\n        sg.removeVertex(u);\n        sg.removeVertex(v);\n    }\n    // return C\n    return cover;\n}"
            ],
            [
                "findGreedyCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a greedy approximation for a minimal vertex cover of a specified\n * graph. At each iteration, the algorithm picks the vertex with the highest\n * degree and adds it to the cover, until all edges are covered.\n *\n * <p>The algorithm works on undirected graphs, but can also work on\n * directed graphs when their edge-directions are ignored. To ignore edge\n * directions you can use {@link org.jgrapht.Graphs#undirectedGraph(Graph)}\n * or {@link org.jgrapht.graph.AsUndirectedGraph}.</p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G' <-- G\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // compare vertices in descending order of degree\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    // while G' != {}\n    while (sg.edgeSet().size() > 0) {\n        // v <-- vertex with maximum degree in G'\n        V v = Collections.max(sg.vertexSet(), comp);\n        // C <-- C U {v}\n        cover.add(v);\n        // remove from G' every edge incident on v, and v itself\n        sg.removeVertex(v);\n    }\n    return cover;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "BEST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int BEST_ORDER = 0;"
            ],
            [
                "NATURAL_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int NATURAL_ORDER = 1;"
            ],
            [
                "SMALLEST_DEGREE_LAST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;"
            ],
            [
                "LARGEST_SATURATION_FIRST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;"
            ],
            [
                "DEFAULT_EDGE_WEIGHT",
                "org.jgrapht",
                "WeightedGraph",
                "/**\n * The default weight for an edge.\n */\npublic static double DEFAULT_EDGE_WEIGHT = 1.0;"
            ],
            [
                "HUB_VERTEX",
                "org.jgrapht.generate",
                "WheelGraphGenerator",
                "/**\n * Role for the hub vertex.\n */\npublic static final String HUB_VERTEX = \"Hub Vertex\";"
            ],
            [
                "CORNER_VERTEX",
                "org.jgrapht.generate",
                "GridGraphGenerator",
                "/**\n * Role for the vertices at the corners.\n */\npublic static final String CORNER_VERTEX = \"Corner Vertex\";"
            ],
            [
                "START_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the first vertex generated.\n */\npublic static final String START_VERTEX = \"Start Vertex\";"
            ],
            [
                "END_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the last vertex generated.\n */\npublic static final String END_VERTEX = \"End Vertex\";"
            ],
            [
                "CENTER_VERTEX",
                "org.jgrapht.generate",
                "StarGraphGenerator",
                "public static final String CENTER_VERTEX = \"Center Vertex\";"
            ],
            [
                "SENTINEL",
                "org.jgrapht.traverse",
                "DepthFirstIterator",
                "/**\n * Sentinel object. Unfortunately, we can't use null, because ArrayDeque\n * won't accept those. And we don't want to rely on the caller to provide a\n * sentinel object for us. So we have to play typecasting games.\n */\npublic static final Object SENTINEL = new Object();"
            ],
            [
                "BEFORE_EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge added event. This event is fired before an edge is added to a\n * graph.\n */\npublic static final int BEFORE_EDGE_ADDED = 21;"
            ],
            [
                "BEFORE_EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge removed event. This event is fired before an edge is removed\n * from a graph.\n */\npublic static final int BEFORE_EDGE_REMOVED = 22;"
            ],
            [
                "EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge added event. This event is fired after an edge is added to a graph.\n */\npublic static final int EDGE_ADDED = 23;"
            ],
            [
                "EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge removed event. This event is fired after an edge is removed from a\n * graph.\n */\npublic static final int EDGE_REMOVED = 24;"
            ],
            [
                "CONNECTED_COMPONENT_STARTED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal started event.\n */\npublic static final int CONNECTED_COMPONENT_STARTED = 31;"
            ],
            [
                "CONNECTED_COMPONENT_FINISHED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal finished event.\n */\npublic static final int CONNECTED_COMPONENT_FINISHED = 32;"
            ],
            [
                "BEFORE_VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex added event. This event is fired before a vertex is added\n * to a graph.\n */\npublic static final int BEFORE_VERTEX_ADDED = 11;"
            ],
            [
                "BEFORE_VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex removed event. This event is fired before a vertex is\n * removed from a graph.\n */\npublic static final int BEFORE_VERTEX_REMOVED = 12;"
            ],
            [
                "VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex added event. This event is fired after a vertex is added to a\n * graph.\n */\npublic static final int VERTEX_ADDED = 13;"
            ],
            [
                "VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex removed event. This event is fired after a vertex is removed from\n * a graph.\n */\npublic static final int VERTEX_REMOVED = 14;"
            ],
            [
                "NULL_NODE",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "public static final int NULL_NODE = -1;"
            ],
            [
                "DEBUG",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected static final boolean DEBUG = false;"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg",
                "EdmondsKarpMaximumFlow",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 0.000000001;"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveClosure",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveClosure INSTANCE = new TransitiveClosure();"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveReduction",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveReduction INSTANCE = new TransitiveReduction();"
            ],
            [
                "NEGATIVE_UNDIRECTED_EDGE",
                "org.jgrapht.alg",
                "BellmanFordIterator",
                "/**\n * Error message.\n */\nprotected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg.flow",
                "MaximumFlowAlgorithmBase",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 1e-9;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [
            [
                "vertex",
                "",
                "V"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "containsEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean containsEdge(V arg0, V arg1)"
            ],
            [
                "getEdge",
                "org.jgrapht",
                "Graph",
                "public abstract E getEdge(V arg0, V arg1)"
            ],
            [
                "containsEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean containsEdge(E arg0)"
            ],
            [
                "getEdgeTarget",
                "org.jgrapht",
                "Graph",
                "public abstract V getEdgeTarget(E arg0)"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "removeAllVertices",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeAllVertices(Collection<? extends V> arg0)"
            ],
            [
                "getEdgeFactory",
                "org.jgrapht",
                "Graph",
                "public abstract EdgeFactory<V, E> getEdgeFactory()"
            ],
            [
                "removeAllEdges",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeAllEdges(Collection<? extends E> arg0)"
            ],
            [
                "removeVertex",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeVertex(V arg0)"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graph",
                "public abstract E addEdge(V arg0, V arg1)"
            ],
            [
                "vertexSet",
                "org.jgrapht",
                "Graph",
                "public abstract Set<V> vertexSet()"
            ],
            [
                "edgesOf",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> edgesOf(V arg0)"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "containsVertex",
                "org.jgrapht",
                "Graph",
                "public abstract boolean containsVertex(V arg0)"
            ],
            [
                "removeEdge",
                "org.jgrapht",
                "Graph",
                "public abstract E removeEdge(V arg0, V arg1)"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean addEdge(V arg0, V arg1, E arg2)"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "getEdgeSource",
                "org.jgrapht",
                "Graph",
                "public abstract V getEdgeSource(E arg0)"
            ],
            [
                "degreeOf",
                "org.jgrapht",
                "UndirectedGraph",
                "/**\n * Returns the degree of the specified vertex. A degree of a vertex in an\n * undirected graph is the number of edges touching that vertex.\n *\n * @param vertex vertex whose degree is to be calculated.\n *\n * @return the degree of the specified vertex.\n */\npublic int degreeOf(V vertex);"
            ],
            [
                "getAllEdges",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> getAllEdges(V arg0, V arg1)"
            ],
            [
                "addVertex",
                "org.jgrapht",
                "Graph",
                "public abstract boolean addVertex(V arg0)"
            ],
            [
                "edgeSet",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> edgeSet()"
            ],
            [
                "removeEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeEdge(E arg0)"
            ],
            [
                "getEdgeWeight",
                "org.jgrapht",
                "Graph",
                "public abstract double getEdgeWeight(E arg0)"
            ],
            [
                "removeAllEdges",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> removeAllEdges(V arg0, V arg1)"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 26154,
        "oracle": ";",
        "oracleType": "PRE",
        "projectName": "jgrapht-core-0.9.2",
        "packageName": "org.jgrapht.traverse",
        "className": "TopologicalOrderIterator",
        "javadocTag": "@param inDegreeMap initializer for inDegreeMap",
        "methodJavadoc": "    /**\n     * Initializes the internal traversal object structure. Sets up the internal\n     * queue with the directed graph vertices and creates the control structure\n     * for the in-degrees.\n     *\n     * @param dg the directed graph to be iterated.\n     * @param queue initializer for queue\n     * @param inDegreeMap initializer for inDegreeMap\n     *\n     * @return start vertex\n     */",
        "methodSourceCode": "private static <V, E> V initialize(DirectedGraph<V, E> dg, Queue<V> queue, Map<V, ModifiableInteger> inDegreeMap){\n    for (Iterator<V> i = dg.vertexSet().iterator(); i.hasNext(); ) {\n        V vertex = i.next();\n        int inDegree = dg.inDegreeOf(vertex);\n        inDegreeMap.put(vertex, new ModifiableInteger(inDegree));\n        if (inDegree == 0) {\n            queue.offer(vertex);\n        }\n    }\n    if (queue.isEmpty()) {\n        return null;\n    } else {\n        return queue.peek();\n    }\n}",
        "classJavadoc": "/**\n * Implements topological order traversal for a directed acyclic graph. A\n * topological sort is a permutation <tt>p</tt> of the vertices of a graph such\n * that an edge <tt>(i,j)</tt> implies that <tt>i</tt> appears before <tt>j</tt>\n * in <tt>p</tt> (Skiena 1990, p. 208). See also <a\n * href=\"http://mathworld.wolfram.com/TopologicalSort.html\">\n * http://mathworld.wolfram.com/TopologicalSort.html</a>.\n *\n * <p>See \"Algorithms in Java, Third Edition, Part 5: Graph Algorithms\" by\n * Robert Sedgewick and \"Data Structures and Algorithms with Object-Oriented\n * Design Patterns in Java\" by Bruno R. Preiss for implementation alternatives.\n * The latter can be found online at <a\n * href=\"http://www.brpreiss.com/books/opus5/\">\n * http://www.brpreiss.com/books/opus5/</a></p>\n *\n * <p>For this iterator to work correctly the graph must be acyclic, and must\n * not be modified during iteration. Currently there are no means to ensure\n * that, nor to fail-fast; the results with cyclic input (including self-loops)\n * or concurrent modifications are undefined. To precheck a graph for cycles,\n * consider using {@link org.jgrapht.alg.CycleDetector} or {@link\n * KosarajuStrongConnectivityInspector}.</p>\n *\n * @author Marden Neubert\n * @since Dec 18, 2004\n */",
        "classSourceCode": "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -----------------------------\n * TopologicalOrderIterator.java\n * -----------------------------\n * (C) Copyright 2004-2008, by Marden Neubert and Contributors.\n *\n * Original Author:  Marden Neubert\n * Contributor(s):   Barak Naveh, John V. Sichi\n *\n * $Id$\n *\n * Changes\n * -------\n * 17-Dec-2004 : Initial revision (MN);\n * 25-Apr-2005 : Fixes for start vertex order (JVS);\n * 06-Jun-2005 : Made generic (CH);\n *\n */\npackage org.jgrapht.traverse;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\nimport org.jgrapht.alg.*;\nimport org.jgrapht.util.*;\n\n\n/**\n * Implements topological order traversal for a directed acyclic graph. A\n * topological sort is a permutation <tt>p</tt> of the vertices of a graph such\n * that an edge <tt>(i,j)</tt> implies that <tt>i</tt> appears before <tt>j</tt>\n * in <tt>p</tt> (Skiena 1990, p. 208). See also <a\n * href=\"http://mathworld.wolfram.com/TopologicalSort.html\">\n * http://mathworld.wolfram.com/TopologicalSort.html</a>.\n *\n * <p>See \"Algorithms in Java, Third Edition, Part 5: Graph Algorithms\" by\n * Robert Sedgewick and \"Data Structures and Algorithms with Object-Oriented\n * Design Patterns in Java\" by Bruno R. Preiss for implementation alternatives.\n * The latter can be found online at <a\n * href=\"http://www.brpreiss.com/books/opus5/\">\n * http://www.brpreiss.com/books/opus5/</a></p>\n *\n * <p>For this iterator to work correctly the graph must be acyclic, and must\n * not be modified during iteration. Currently there are no means to ensure\n * that, nor to fail-fast; the results with cyclic input (including self-loops)\n * or concurrent modifications are undefined. To precheck a graph for cycles,\n * consider using {@link org.jgrapht.alg.CycleDetector} or {@link\n * KosarajuStrongConnectivityInspector}.</p>\n *\n * @author Marden Neubert\n * @since Dec 18, 2004\n */\npublic class TopologicalOrderIterator<V, E>\n    extends CrossComponentIterator<V, E, Object>\n{\n    private Queue<V> queue;\n    private Map<V, ModifiableInteger> inDegreeMap;\n\n    /**\n     * Creates a new topological order iterator over the directed graph\n     * specified, with arbitrary tie-breaking in case of partial order.\n     * Traversal will start at one of the graph's <i>sources</i>. See the\n     * definition of source at <a\n     * href=\"http://mathworld.wolfram.com/Source.html\">\n     * http://mathworld.wolfram.com/Source.html</a>.\n     *\n     * @param dg the directed graph to be iterated.\n     */\n    public TopologicalOrderIterator(DirectedGraph<V, E> dg)\n    {\n        this(dg, new LinkedListQueue<V>());\n    }\n\n    /**\n     * Creates a new topological order iterator over the directed graph\n     * specified, with a user-supplied queue implementation to allow customized\n     * control over tie-breaking in case of partial order. Traversal will start\n     * at one of the graph's <i>sources</i>. See the definition of source at <a\n     * href=\"http://mathworld.wolfram.com/Source.html\">\n     * http://mathworld.wolfram.com/Source.html</a>.\n     *\n     * @param dg the directed graph to be iterated.\n     * @param queue queue to use for tie-break in case of partial order (e.g. a\n     * PriorityQueue can be used to break ties according to vertex priority);\n     * must be initially empty\n     */\n    public TopologicalOrderIterator(DirectedGraph<V, E> dg, Queue<V> queue)\n    {\n        this(dg, queue, new HashMap<V, ModifiableInteger>());\n    }\n\n    // NOTE: This is a hack to deal with the fact that CrossComponentIterator\n    // needs to know the start vertex in its constructor\n    private TopologicalOrderIterator(\n        DirectedGraph<V, E> dg,\n        Queue<V> queue,\n        Map<V, ModifiableInteger> inDegreeMap)\n    {\n        this(dg, initialize(dg, queue, inDegreeMap));\n        this.queue = queue;\n        this.inDegreeMap = inDegreeMap;\n\n        // empty queue for non-empty graph would indicate presence of\n        // cycles (no roots found)\n        assert dg.vertexSet().isEmpty() || !queue.isEmpty();\n    }\n\n    // NOTE: This is intentionally private, because starting the sort \"in the\n    // middle\" doesn't make sense.\n    private TopologicalOrderIterator(DirectedGraph<V, E> dg, V start)\n    {\n        super(dg, start);\n    }\n\n    /**\n     * @see CrossComponentIterator#isConnectedComponentExhausted()\n     */\n    @Override protected boolean isConnectedComponentExhausted()\n    {\n        // FIXME jvs 25-Apr-2005: This isn't correct for a graph with more than\n        // one component.  We will actually exhaust a connected component\n        // before the queue is empty, because initialize adds roots from all\n        // components to the queue.\n        return queue.isEmpty();\n    }\n\n    /**\n     * @see CrossComponentIterator#encounterVertex(Object, Object)\n     */\n    @Override protected void encounterVertex(V vertex, E edge)\n    {\n        putSeenData(vertex, null);\n        decrementInDegree(vertex);\n    }\n\n    /**\n     * @see CrossComponentIterator#encounterVertexAgain(Object, Object)\n     */\n    @Override protected void encounterVertexAgain(V vertex, E edge)\n    {\n        decrementInDegree(vertex);\n    }\n\n    /**\n     * @see CrossComponentIterator#provideNextVertex()\n     */\n    @Override protected V provideNextVertex()\n    {\n        return queue.remove();\n    }\n\n    /**\n     * Decrements the in-degree of a vertex.\n     *\n     * @param vertex the vertex whose in-degree will be decremented.\n     */\n    private void decrementInDegree(V vertex)\n    {\n        ModifiableInteger inDegree = inDegreeMap.get(vertex);\n\n        if (inDegree.value > 0) {\n            inDegree.value--;\n\n            if (inDegree.value == 0) {\n                queue.offer(vertex);\n            }\n        }\n    }\n\n    /**\n     * Initializes the internal traversal object structure. Sets up the internal\n     * queue with the directed graph vertices and creates the control structure\n     * for the in-degrees.\n     *\n     * @param dg the directed graph to be iterated.\n     * @param queue initializer for queue\n     * @param inDegreeMap initializer for inDegreeMap\n     *\n     * @return start vertex\n     */\n    private static <V, E> V initialize(\n        DirectedGraph<V, E> dg,\n        Queue<V> queue,\n        Map<V, ModifiableInteger> inDegreeMap)\n    {\n        for (Iterator<V> i = dg.vertexSet().iterator(); i.hasNext();) {\n            V vertex = i.next();\n\n            int inDegree = dg.inDegreeOf(vertex);\n            inDegreeMap.put(vertex, new ModifiableInteger(inDegree));\n\n            if (inDegree == 0) {\n                queue.offer(vertex);\n            }\n        }\n\n        if (queue.isEmpty()) {\n            return null;\n        } else {\n            return queue.peek();\n        }\n    }\n\n    // NOTE jvs 22-Dec-2006:  For JDK1.4-compatibility, we can't assume\n    // that LinkedList implements Queue, since that wasn't introduced\n    // until JDK1.5, so use an adapter here.  Move this to\n    // top-level in org.jgrapht.util if anyone else needs it.\n    private static class LinkedListQueue<T>\n        extends LinkedList<T>\n        implements Queue<T>\n    {\n        private static final long serialVersionUID = 4217659843476891334L;\n\n        @Override public T element()\n        {\n            return getFirst();\n        }\n\n        @Override public boolean offer(T o)\n        {\n            return add(o);\n        }\n\n        @Override public T peek()\n        {\n            if (isEmpty()) {\n                return null;\n            }\n            return getFirst();\n        }\n\n        @Override public T poll()\n        {\n            if (isEmpty()) {\n                return null;\n            }\n            return removeFirst();\n        }\n\n        @Override public T remove()\n        {\n            return removeFirst();\n        }\n    }\n}\n\n// End TopologicalOrderIterator.java\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "PartiteRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "RandomGraphHelper",
                "org.jgrapht.experimental"
            ],
            [
                "GraphReader",
                "org.jgrapht.experimental"
            ],
            [
                "DirectedAcyclicGraph",
                "org.jgrapht.experimental.dag"
            ],
            [
                "GraphSquare",
                "org.jgrapht.experimental"
            ],
            [
                "UniformRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "GraphTests",
                "org.jgrapht.experimental"
            ],
            [
                "ApproximationAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "BrownBacktrackColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "GreedyColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "IntArrayGraphAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ExactAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ListenableGraph",
                "org.jgrapht"
            ],
            [
                "ModifiableInteger",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeapNode",
                "org.jgrapht.util"
            ],
            [
                "WeightCombiner",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeap",
                "org.jgrapht.util"
            ],
            [
                "TypeUtil",
                "org.jgrapht.util"
            ],
            [
                "ArrayUnenforcedSet",
                "org.jgrapht.util"
            ],
            [
                "VertexPair",
                "org.jgrapht.util"
            ],
            [
                "MathUtil",
                "org.jgrapht.util"
            ],
            [
                "PrefetchIterator",
                "org.jgrapht.util"
            ],
            [
                "VertexFactory",
                "org.jgrapht"
            ],
            [
                "Graph",
                "org.jgrapht"
            ],
            [
                "GraphPath",
                "org.jgrapht"
            ],
            [
                "UndirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraph",
                "org.jgrapht.graph"
            ],
            [
                "MixedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DefaultGraphMapping",
                "org.jgrapht.graph"
            ],
            [
                "WeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskEdgeSet",
                "org.jgrapht.graph"
            ],
            [
                "Pseudograph",
                "org.jgrapht.graph"
            ],
            [
                "MaskFunctor",
                "org.jgrapht.graph"
            ],
            [
                "GraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractBaseGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "Multigraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultWeightedEdge",
                "org.jgrapht.graph"
            ],
            [
                "ListenableDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeSetFactory",
                "org.jgrapht.graph"
            ],
            [
                "GraphDelegator",
                "org.jgrapht.graph"
            ],
            [
                "DefaultListenableGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedVertexFactory",
                "org.jgrapht.graph"
            ],
            [
                "DefaultEdge",
                "org.jgrapht.graph"
            ],
            [
                "MaskVertexSet",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "IntrusiveEdge",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphPathImpl",
                "org.jgrapht.graph"
            ],
            [
                "Subgraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractGraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedEdgeFactory",
                "org.jgrapht.graph"
            ],
            [
                "SimpleWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "WeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeReversedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "AbstractGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "ListenableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraphPath",
                "org.jgrapht.graph"
            ],
            [
                "ParanoidGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphHelper",
                "org.jgrapht"
            ],
            [
                "Graphs",
                "org.jgrapht"
            ],
            [
                "DirectedGraph",
                "org.jgrapht"
            ],
            [
                "WeightedGraph",
                "org.jgrapht"
            ],
            [
                "HyperCubeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RingGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WheelGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GridGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "ScaleFreeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedBipartiteGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "LinearGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RandomGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGeneratorAdapter",
                "org.jgrapht.generate"
            ],
            [
                "EmptyGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteBipartiteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "StarGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "UndirectedGraph",
                "org.jgrapht"
            ],
            [
                "TopologicalOrderIterator",
                "org.jgrapht.traverse"
            ],
            [
                "CrossComponentIterator",
                "org.jgrapht.traverse"
            ],
            [
                "AbstractGraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "ClosestFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "BreadthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "DepthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "GraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "EdgeFactory",
                "org.jgrapht"
            ],
            [
                "GraphMapping",
                "org.jgrapht"
            ],
            [
                "VertexSetListener",
                "org.jgrapht.event"
            ],
            [
                "EdgeTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "TraversalListener",
                "org.jgrapht.event"
            ],
            [
                "GraphEdgeChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "VertexTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphListener",
                "org.jgrapht.event"
            ],
            [
                "TraversalListenerAdapter",
                "org.jgrapht.event"
            ],
            [
                "ConnectedComponentTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphVertexChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "TarjanLowestCommonAncestor",
                "org.jgrapht.alg"
            ],
            [
                "PrimMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "BlockCutpointGraph",
                "org.jgrapht.alg"
            ],
            [
                "AllDirectedPaths",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPathsIterator",
                "org.jgrapht.alg"
            ],
            [
                "KruskalMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "StrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "VF2State",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2AbstractIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "GraphOrdering",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphicGraphMapping",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2MappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "BronKerboschCliqueFinder",
                "org.jgrapht.alg"
            ],
            [
                "ChromaticNumber",
                "org.jgrapht.alg"
            ],
            [
                "KosarajuStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "DijkstraShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElement",
                "org.jgrapht.alg"
            ],
            [
                "AStarShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordPathElement",
                "org.jgrapht.alg"
            ],
            [
                "FloydWarshallShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "UnionFind",
                "org.jgrapht.alg.util"
            ],
            [
                "AlwaysEqualComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Extension",
                "org.jgrapht.alg.util"
            ],
            [
                "VertexDegreeComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Pair",
                "org.jgrapht.alg.util"
            ],
            [
                "GabowStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "HawickJamesSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "DirectedSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "JohnsonSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TiernanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "UndirectedCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "PatonCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TarjanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "SzwarcfiterLauerSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "BiconnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "ConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "MinSourceSinkCut",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsBlossomShrinking",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveClosure",
                "org.jgrapht.alg"
            ],
            [
                "HopcroftKarpBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "StoerWagnerMinimumCut",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "KuhnMunkresMinimalWeightBipartitePerfectMatching",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveReduction",
                "org.jgrapht.alg"
            ],
            [
                "EulerianCircuit",
                "org.jgrapht.alg"
            ],
            [
                "DirectedNeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "NaiveLcaFinder",
                "org.jgrapht.alg"
            ],
            [
                "MaximumWeightBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "HamiltonianCycle",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "NeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "VertexCovers",
                "org.jgrapht.alg"
            ],
            [
                "CycleDetector",
                "org.jgrapht.alg"
            ],
            [
                "AStarAdmissibleHeuristic",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MinimumSpanningTree",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "WeightedMatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "StrongConnectivityAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MaximumFlowAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "CliqueMinimalSeparatorDecomposition",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordIterator",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElement",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "PushRelabelMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "MaximumFlowAlgorithmBase",
                "org.jgrapht.alg.flow"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "addVertices",
                "org.jgrapht.experimental",
                "RandomGraphHelper",
                "/**\n * .\n *\n * @param target\n * @param vertexFactory\n * @param numVertices\n *\n * @return vertices\n */\n@SuppressWarnings(\"unchecked\")\npublic static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices) {\n    Object[] vertices = new Object[numVertices];\n    for (int i = 0; i < numVertices; ++i) {\n        vertices[i] = vertexFactory.createVertex();\n        target.addVertex(vertices[i]);\n    }\n    return vertices;\n}"
            ],
            [
                "isEmpty",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isEmpty(Graph<V, E> g) {\n    return g.edgeSet().isEmpty();\n}"
            ],
            [
                "isComplete",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isComplete(Graph<V, E> g) {\n    int n = g.vertexSet().size();\n    return g.edgeSet().size() == (n * (n - 1) / 2);\n}"
            ],
            [
                "isConnected",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isConnected(Graph<V, E> g) {\n    int numVertices = g.vertexSet().size();\n    int numEdges = g.edgeSet().size();\n    if (numEdges < (numVertices - 1)) {\n        return false;\n    }\n    if ((numVertices < 2) || (numEdges > ((numVertices - 1) * (numVertices - 2) / 2))) {\n        return true;\n    }\n    Set<V> known = new HashSet<V>();\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = g.vertexSet().iterator().next();\n    // start with node 1\n    queue.add(v);\n    known.add(v);\n    while (!queue.isEmpty()) {\n        v = queue.removeFirst();\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            v = it.next();\n            if (!known.contains(v)) {\n                known.add(v);\n                queue.add(v);\n            }\n        }\n    }\n    return known.size() == numVertices;\n}"
            ],
            [
                "isTree",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isTree(Graph<V, E> g) {\n    return isConnected(g) && (g.edgeSet().size() == (g.vertexSet().size() - 1));\n}"
            ],
            [
                "isBipartite",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isBipartite(Graph<V, E> g) {\n    if ((4 * g.edgeSet().size()) > (g.vertexSet().size() * g.vertexSet().size())) {\n        return false;\n    }\n    if (isEmpty(g)) {\n        return true;\n    }\n    Set<V> unknown = new HashSet<V>(g.vertexSet());\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = unknown.iterator().next();\n    Set<V> odd = new HashSet<V>();\n    queue.add(v);\n    while (!unknown.isEmpty()) {\n        if (queue.isEmpty()) {\n            queue.add(unknown.iterator().next());\n        }\n        v = queue.removeFirst();\n        unknown.remove(v);\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            V n = it.next();\n            if (unknown.contains(n)) {\n                queue.add(n);\n                if (!odd.contains(v)) {\n                    odd.add(n);\n                }\n            } else if (!(odd.contains(v) ^ odd.contains(n))) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
            ],
            [
                "union",
                "org.jgrapht.util",
                "FibonacciHeap",
                "// size\n/**\n * Joins two Fibonacci heaps into a new one. No heap consolidation is\n * performed at this time. The two root lists are simply joined together.\n *\n * <p>Running time: O(1) actual</p>\n *\n * @param h1 first heap\n * @param h2 second heap\n *\n * @return new heap containing h1 and h2\n */\npublic static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2) {\n    FibonacciHeap<T> h = new FibonacciHeap<T>();\n    if ((h1 != null) && (h2 != null)) {\n        h.minNode = h1.minNode;\n        if (h.minNode != null) {\n            if (h2.minNode != null) {\n                h.minNode.right.left = h2.minNode.left;\n                h2.minNode.left.right = h.minNode.right;\n                h.minNode.right = h2.minNode;\n                h2.minNode.left = h.minNode;\n                if (h2.minNode.key < h1.minNode.key) {\n                    h.minNode = h2.minNode;\n                }\n            }\n        } else {\n            h.minNode = h2.minNode;\n        }\n        h.nNodes = h1.nNodes + h2.nNodes;\n    }\n    return h;\n}"
            ],
            [
                "uncheckedCast",
                "org.jgrapht.util",
                "TypeUtil",
                "/**\n * Casts an object to a type.\n *\n * @param o object to be cast\n * @param typeDecl conveys the target type information; the actual value is\n * unused and can be null since this is all just stupid compiler tricks\n *\n * @return the result of the cast\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl) {\n    return (T) o;\n}"
            ],
            [
                "factorial",
                "org.jgrapht.util",
                "MathUtil",
                "public static long factorial(int N) {\n    long multi = 1;\n    for (int i = 1; i <= N; i++) {\n        multi = multi * i;\n    }\n    return multi;\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graphs",
                "/**\n * Creates a new edge and adds it to the specified graph similarly to the\n * {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n *\n * @see Graph#addEdge(Object, Object)\n */\npublic static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    EdgeFactory<V, E> ef = g.getEdgeFactory();\n    E e = ef.createEdge(sourceVertex, targetVertex);\n    // we first create the edge and set the weight to make sure that\n    // listeners will see the correct weight upon addEdge.\n    assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n    ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n    return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new edge and adds it to the specified\n * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return g.addEdge(sourceVertex, targetVertex);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified edge to the graph, including its vertices if not\n * already included.\n *\n * @param targetGraph the graph for which the specified edge to be added.\n * @param sourceGraph the graph in which the specified edge is already\n * present\n * @param edge edge to add\n *\n * @return <tt>true</tt> if the target graph did not already contain the\n * specified edge.\n */\npublic static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge) {\n    V sourceVertex = sourceGraph.getEdgeSource(edge);\n    V targetVertex = sourceGraph.getEdgeTarget(edge);\n    targetGraph.addVertex(sourceVertex);\n    targetGraph.addVertex(targetVertex);\n    return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new weighted edge and adds it to the\n * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n * method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return addEdge(g, sourceVertex, targetVertex, weight);\n}"
            ],
            [
                "addGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all the vertices and all the edges of the specified source graph to\n * the specified destination graph. First all vertices of the source graph\n * are added to the destination graph. Then every edge of the source graph\n * is added to the destination graph. This method returns <code>true</code>\n * if the destination graph has been modified as a result of this operation,\n * otherwise it returns <code>false</code>.\n *\n * <p>The behavior of this operation is undefined if any of the specified\n * graphs is modified while operation is in progress.</p>\n *\n * @param destination the graph to which vertices and edges are added.\n * @param source the graph used as source for vertices and edges to add.\n *\n * @return <code>true</code> if and only if the destination graph has been\n * changed as a result of this operation.\n */\npublic static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source) {\n    boolean modified = addAllVertices(destination, source.vertexSet());\n    modified |= addAllEdges(destination, source, source.edgeSet());\n    return modified;\n}"
            ],
            [
                "addAllEdges",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds a subset of the edges of the specified source graph to the specified\n * destination graph. The behavior of this operation is undefined if either\n * of the graphs is modified while the operation is in progress. {@link\n * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n * be added automatically to the target graph.\n *\n * @param destination the graph to which edges are to be added\n * @param source the graph used as a source for edges to add\n * @param edges the edges to be added\n *\n * @return <tt>true</tt> if this graph changed as a result of the call\n */\npublic static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges) {\n    boolean modified = false;\n    for (E e : edges) {\n        V s = source.getEdgeSource(e);\n        V t = source.getEdgeTarget(e);\n        destination.addVertex(s);\n        destination.addVertex(t);\n        modified |= destination.addEdge(s, t, e);\n    }\n    return modified;\n}"
            ],
            [
                "addAllVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all of the specified vertices to the destination graph. The behavior\n * of this operation is undefined if the specified vertex collection is\n * modified while the operation is in progress. This method will invoke the\n * {@link Graph#addVertex(Object)} method.\n *\n * @param destination the graph to which edges are to be added\n * @param vertices the vertices to be added to the graph.\n *\n * @return <tt>true</tt> if graph changed as a result of the call\n *\n * @throws NullPointerException if the specified vertices contains one or\n * more null vertices, or if the specified vertex collection is <tt>\n * null</tt>.\n *\n * @see Graph#addVertex(Object)\n */\npublic static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices) {\n    boolean modified = false;\n    for (V v : vertices) {\n        modified |= destination.addVertex(v);\n    }\n    return modified;\n}"
            ],
            [
                "neighborListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the neighbors of a specified vertex.\n * If the graph is a multigraph vertices may appear more than once in the\n * returned list.\n *\n * @param g the graph to look for neighbors in.\n * @param vertex the vertex to get the neighbors of.\n *\n * @return a list of the vertices that are the neighbors of the specified\n * vertex.\n */\npublic static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex) {\n    List<V> neighbors = new ArrayList<V>();\n    for (E e : g.edgesOf(vertex)) {\n        neighbors.add(getOppositeVertex(g, e, vertex));\n    }\n    return neighbors;\n}"
            ],
            [
                "predecessorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct predecessors of a\n * specified vertex. If the graph is a multigraph, vertices may appear more\n * than once in the returned list.\n *\n * @param g the graph to look for predecessors in.\n * @param vertex the vertex to get the predecessors of.\n *\n * @return a list of the vertices that are the direct predecessors of the\n * specified vertex.\n */\npublic static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> predecessors = new ArrayList<V>();\n    Set<? extends E> edges = g.incomingEdgesOf(vertex);\n    for (E e : edges) {\n        predecessors.add(getOppositeVertex(g, e, vertex));\n    }\n    return predecessors;\n}"
            ],
            [
                "successorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct successors of a specified\n * vertex. If the graph is a multigraph vertices may appear more than once\n * in the returned list.\n *\n * @param g the graph to look for successors in.\n * @param vertex the vertex to get the successors of.\n *\n * @return a list of the vertices that are the direct successors of the\n * specified vertex.\n */\npublic static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> successors = new ArrayList<V>();\n    Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n    for (E e : edges) {\n        successors.add(getOppositeVertex(g, e, vertex));\n    }\n    return successors;\n}"
            ],
            [
                "undirectedGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns an undirected view of the specified graph. If the specified graph\n * is directed, returns an undirected view of it. If the specified graph is\n * already undirected, just returns it.\n *\n * @param g the graph for which an undirected view is to be returned.\n *\n * @return an undirected view of the specified graph, if it is directed, or\n * or the specified graph itself if it is already undirected.\n *\n * @throws IllegalArgumentException if the graph is neither DirectedGraph\n * nor UndirectedGraph.\n *\n * @see AsUndirectedGraph\n */\npublic static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n    } else if (g instanceof UndirectedGraph<?, ?>) {\n        return (UndirectedGraph<V, E>) g;\n    } else {\n        throw new IllegalArgumentException(\"Graph must be either DirectedGraph or UndirectedGraph\");\n    }\n}"
            ],
            [
                "testIncidence",
                "org.jgrapht",
                "Graphs",
                "/**\n * Tests whether an edge is incident to a vertex.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return true iff e is incident on v\n */\npublic static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v) {\n    return (g.getEdgeSource(e).equals(v)) || (g.getEdgeTarget(e).equals(v));\n}"
            ],
            [
                "getOppositeVertex",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the vertex opposite another vertex across an edge.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return vertex opposite to v across e\n */\npublic static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v) {\n    V source = g.getEdgeSource(e);\n    V target = g.getEdgeTarget(e);\n    if (v.equals(source)) {\n        return target;\n    } else if (v.equals(target)) {\n        return source;\n    } else {\n        throw new IllegalArgumentException(\"no such vertex: \" + v.toString());\n    }\n}"
            ],
            [
                "getPathVertexList",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the list of vertices visited by a path.\n *\n * @param path path of interest\n *\n * @return corresponding vertex list\n */\npublic static <V, E> List<V> getPathVertexList(GraphPath<V, E> path) {\n    Graph<V, E> g = path.getGraph();\n    List<V> list = new ArrayList<V>();\n    V v = path.getStartVertex();\n    list.add(v);\n    for (E e : path.getEdgeList()) {\n        v = getOppositeVertex(g, e, v);\n        list.add(v);\n    }\n    return list;\n}"
            ],
            [
                "range",
                "org.jgrapht.generate",
                "SimpleWeightedGraphMatrixGenerator",
                "///////////////////////////////////////////////////////////////////////////////////////////////\npublic static int[] range(final int from, final int to) {\n    int[] range = new int[to - from];\n    for (int i = from; i < to; ++i) {\n        range[i - from] = i;\n    }\n    return range;\n}"
            ],
            [
                "createGraphSpecifics",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "// -------------------------------------------------------------------------\n/**\n * @param <V>\n * @param <E>\n * @param g\n *\n * @return TODO Document me\n */\nstatic <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new DirectedSpecifics<V, E>((DirectedGraph<V, E>) g);\n    } else {\n        return new UndirectedSpecifics<V, E>(g);\n    }\n}"
            ],
            [
                "findGreedyChromaticNumber",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds the number of colors required for a greedy coloring of the graph.\n *\n * @param g an undirected graph to find the chromatic number of\n *\n * @return integer the approximate chromatic number from the greedy\n * algorithm\n */\npublic static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g) {\n    Map<Integer, Set<V>> coloredGroups = findGreedyColoredGroups(g);\n    return coloredGroups.keySet().size();\n}"
            ],
            [
                "findGreedyColoredGroups",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds a greedy coloring of the graph.\n *\n * @param g an undirected graph for which to find the coloring\n */\npublic static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g) {\n    // A copy of the graph is made, so that elements of the graph may be\n    // removed to carry out the algorithm\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // The Vertices will be sorted in decreasing order by degree, so that\n    // higher degree vertices have priority to be colored first\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    List<V> sortedVertices = new LinkedList<V>(sg.vertexSet());\n    Collections.sort(sortedVertices, comp);\n    Collections.reverse(sortedVertices);\n    int color;\n    // create a map which will hold color as key and Set<V> as value\n    Map<Integer, Set<V>> coloredGroups = new HashMap<Integer, Set<V>>();\n    // We'll attempt to color each vertex with a single color each\n    // iteration, and these vertices will be removed from the graph at the\n    // end of each iteration\n    for (color = 0; sg.vertexSet().size() > 0; color++) {\n        // This set will contain vertices that are colored with the\n        // current color of this iteration\n        Set<V> currentColor = new HashSet<V>();\n        for (Iterator<V> iter = sortedVertices.iterator(); iter.hasNext(); ) {\n            V v = iter.next();\n            // Add new vertices to be colored as long as they are not\n            // adjacent with any other vertex that has already been colored\n            // with the current color\n            boolean flag = true;\n            for (Iterator<V> innerIter = currentColor.iterator(); innerIter.hasNext(); ) {\n                V temp = innerIter.next();\n                if (sg.containsEdge(temp, v)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                currentColor.add(v);\n                iter.remove();\n            }\n        }\n        // Add all these vertices as a group for this color\n        coloredGroups.put(color, currentColor);\n        // Remove vertices from the graph and then repeat the process for\n        // the next iteration\n        sg.removeAllVertices(currentColor);\n    }\n    return coloredGroups;\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "BellmanFordShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by hops, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    BellmanFordShortestPath<V, E> alg = new BellmanFordShortestPath<V, E>(graph, startVertex);\n    return alg.getPathEdgeList(endVertex);\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "DijkstraShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by radius, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    DijkstraShortestPath<V, E> alg = new DijkstraShortestPath<V, E>(graph, startVertex, endVertex);\n    return alg.getPathEdgeList();\n}"
            ],
            [
                "of",
                "org.jgrapht.alg.util",
                "Pair",
                "/**\n * Creates new pair of elements pulling of the necessity to provide\n * corresponding types of the elements supplied\n *\n * @param a first element\n * @param b second element\n *\n * @return new pair\n */\npublic static <A, B> Pair<A, B> of(A a, B b) {\n    return new Pair<A, B>(a, b);\n}"
            ],
            [
                "isEulerian",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will check whether the graph passed in is Eulerian or not.\n *\n * @param g The graph to be checked\n *\n * @return true for Eulerian and false for non-Eulerian\n */\npublic static <V, E> boolean isEulerian(UndirectedGraph<V, E> g) {\n    // If the graph is not connected, then no Eulerian circuit exists\n    if (!(new ConnectivityInspector<V, E>(g)).isGraphConnected()) {\n        return false;\n    }\n    // A graph is Eulerian if and only if all vertices have even degree\n    // So, this code will check for that\n    Iterator<V> iter = g.vertexSet().iterator();\n    while (iter.hasNext()) {\n        V v = iter.next();\n        if ((g.degreeOf(v) % 2) == 1) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "getEulerianCircuitVertices",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will return a list of vertices which represents the Eulerian\n * circuit of the graph.\n *\n * @param g The graph to find an Eulerian circuit\n *\n * @return null if no Eulerian circuit exists, or a list of vertices\n * representing the Eulerian circuit if one does exist\n */\npublic static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g) {\n    // If the graph is not Eulerian then just return a null since no\n    // Eulerian circuit exists\n    if (!isEulerian(g)) {\n        return null;\n    }\n    // The circuit will be represented by a linked list\n    List<V> path = new LinkedList<V>();\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    path.add(sg.vertexSet().iterator().next());\n    // Algorithm for finding an Eulerian circuit Basically this will find an\n    // arbitrary circuit, then it will find another arbitrary circuit until\n    // every edge has been traversed\n    while (sg.edgeSet().size() > 0) {\n        V v = null;\n        // Find a vertex which has an edge that hasn't been traversed yet,\n        // and keep its index position in the circuit list\n        int index = 0;\n        for (Iterator<V> iter = path.iterator(); iter.hasNext(); index++) {\n            v = iter.next();\n            if (sg.degreeOf(v) > 0) {\n                break;\n            }\n        }\n        // Finds an arbitrary circuit of the current vertex and\n        // appends this into the circuit list\n        while (sg.degreeOf(v) > 0) {\n            for (Iterator<V> iter = sg.vertexSet().iterator(); iter.hasNext(); ) {\n                V temp = iter.next();\n                if (sg.containsEdge(v, temp)) {\n                    path.add(index, temp);\n                    sg.removeEdge(v, temp);\n                    v = temp;\n                    break;\n                }\n            }\n        }\n    }\n    return path;\n}"
            ],
            [
                "getApproximateOptimalForCompleteGraph",
                "org.jgrapht.alg",
                "HamiltonianCycle",
                "/**\n * This method will return an approximate minimal traveling salesman tour\n * (hamiltonian cycle). This algorithm requires that the graph be complete\n * and the triangle inequality exists (if x,y,z are vertices then\n * d(x,y)+d(y,z) &lt; d(x,z) for all x,y,z) then this algorithm will\n * guarantee a hamiltonian cycle such that the total weight of the cycle is\n * less than or equal to double the total weight of the optimal hamiltonian\n * cycle. The optimal solution is NP-complete, so this is a decent\n * approximation that runs in polynomial time.\n *\n * @param <V>\n * @param <E>\n * @param g is the graph to find the optimal tour for.\n *\n * @return The optimal tour as a list of vertices.\n */\npublic static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g) {\n    List<V> vertices = new LinkedList<V>(g.vertexSet());\n    // If the graph is not complete then return null since this algorithm\n    // requires the graph be complete\n    if ((vertices.size() * (vertices.size() - 1) / 2) != g.edgeSet().size()) {\n        return null;\n    }\n    List<V> tour = new LinkedList<V>();\n    // Each iteration a new vertex will be added to the tour until all\n    // vertices have been added\n    while (tour.size() != g.vertexSet().size()) {\n        boolean firstEdge = true;\n        double minEdgeValue = 0;\n        int minVertexFound = 0;\n        int vertexConnectedTo = 0;\n        // A check will be made for the shortest edge to a vertex not within\n        // the tour and that new vertex will be added to the vertex\n        for (int i = 0; i < tour.size(); i++) {\n            V v = tour.get(i);\n            for (int j = 0; j < vertices.size(); j++) {\n                double weight = g.getEdgeWeight(g.getEdge(v, vertices.get(j)));\n                if (firstEdge || (weight < minEdgeValue)) {\n                    firstEdge = false;\n                    minEdgeValue = weight;\n                    minVertexFound = j;\n                    vertexConnectedTo = i;\n                }\n            }\n        }\n        tour.add(vertexConnectedTo, vertices.get(minVertexFound));\n        vertices.remove(minVertexFound);\n    }\n    return tour;\n}"
            ],
            [
                "find2ApproximationCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a 2-approximation for a minimal vertex cover of the specified\n * graph. The algorithm promises a cover that is at most double the size of\n * a minimal cover. The algorithm takes O(|E|) time.\n *\n * <p>For more details see Jenny Walter, CMPU-240: Lecture notes for\n * Language Theory and Computation, Fall 2002, Vassar College, <a\n * href=\"http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf\">\n * http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf</a>.\n * </p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G'=(V',E') <-- G(V,E)\n    Subgraph<V, E, Graph<V, E>> sg = new Subgraph<V, E, Graph<V, E>>(g, null, null);\n    // while E' is non-empty\n    while (sg.edgeSet().size() > 0) {\n        // let (u,v) be an arbitrary edge of E'\n        E e = sg.edgeSet().iterator().next();\n        // C <-- C U {u,v}\n        V u = g.getEdgeSource(e);\n        V v = g.getEdgeTarget(e);\n        cover.add(u);\n        cover.add(v);\n        // remove from E' every edge incident on either u or v\n        sg.removeVertex(u);\n        sg.removeVertex(v);\n    }\n    // return C\n    return cover;\n}"
            ],
            [
                "findGreedyCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a greedy approximation for a minimal vertex cover of a specified\n * graph. At each iteration, the algorithm picks the vertex with the highest\n * degree and adds it to the cover, until all edges are covered.\n *\n * <p>The algorithm works on undirected graphs, but can also work on\n * directed graphs when their edge-directions are ignored. To ignore edge\n * directions you can use {@link org.jgrapht.Graphs#undirectedGraph(Graph)}\n * or {@link org.jgrapht.graph.AsUndirectedGraph}.</p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G' <-- G\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // compare vertices in descending order of degree\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    // while G' != {}\n    while (sg.edgeSet().size() > 0) {\n        // v <-- vertex with maximum degree in G'\n        V v = Collections.max(sg.vertexSet(), comp);\n        // C <-- C U {v}\n        cover.add(v);\n        // remove from G' every edge incident on v, and v itself\n        sg.removeVertex(v);\n    }\n    return cover;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "BEST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int BEST_ORDER = 0;"
            ],
            [
                "NATURAL_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int NATURAL_ORDER = 1;"
            ],
            [
                "SMALLEST_DEGREE_LAST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;"
            ],
            [
                "LARGEST_SATURATION_FIRST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;"
            ],
            [
                "DEFAULT_EDGE_WEIGHT",
                "org.jgrapht",
                "WeightedGraph",
                "/**\n * The default weight for an edge.\n */\npublic static double DEFAULT_EDGE_WEIGHT = 1.0;"
            ],
            [
                "HUB_VERTEX",
                "org.jgrapht.generate",
                "WheelGraphGenerator",
                "/**\n * Role for the hub vertex.\n */\npublic static final String HUB_VERTEX = \"Hub Vertex\";"
            ],
            [
                "CORNER_VERTEX",
                "org.jgrapht.generate",
                "GridGraphGenerator",
                "/**\n * Role for the vertices at the corners.\n */\npublic static final String CORNER_VERTEX = \"Corner Vertex\";"
            ],
            [
                "START_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the first vertex generated.\n */\npublic static final String START_VERTEX = \"Start Vertex\";"
            ],
            [
                "END_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the last vertex generated.\n */\npublic static final String END_VERTEX = \"End Vertex\";"
            ],
            [
                "CENTER_VERTEX",
                "org.jgrapht.generate",
                "StarGraphGenerator",
                "public static final String CENTER_VERTEX = \"Center Vertex\";"
            ],
            [
                "SENTINEL",
                "org.jgrapht.traverse",
                "DepthFirstIterator",
                "/**\n * Sentinel object. Unfortunately, we can't use null, because ArrayDeque\n * won't accept those. And we don't want to rely on the caller to provide a\n * sentinel object for us. So we have to play typecasting games.\n */\npublic static final Object SENTINEL = new Object();"
            ],
            [
                "BEFORE_EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge added event. This event is fired before an edge is added to a\n * graph.\n */\npublic static final int BEFORE_EDGE_ADDED = 21;"
            ],
            [
                "BEFORE_EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge removed event. This event is fired before an edge is removed\n * from a graph.\n */\npublic static final int BEFORE_EDGE_REMOVED = 22;"
            ],
            [
                "EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge added event. This event is fired after an edge is added to a graph.\n */\npublic static final int EDGE_ADDED = 23;"
            ],
            [
                "EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge removed event. This event is fired after an edge is removed from a\n * graph.\n */\npublic static final int EDGE_REMOVED = 24;"
            ],
            [
                "CONNECTED_COMPONENT_STARTED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal started event.\n */\npublic static final int CONNECTED_COMPONENT_STARTED = 31;"
            ],
            [
                "CONNECTED_COMPONENT_FINISHED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal finished event.\n */\npublic static final int CONNECTED_COMPONENT_FINISHED = 32;"
            ],
            [
                "BEFORE_VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex added event. This event is fired before a vertex is added\n * to a graph.\n */\npublic static final int BEFORE_VERTEX_ADDED = 11;"
            ],
            [
                "BEFORE_VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex removed event. This event is fired before a vertex is\n * removed from a graph.\n */\npublic static final int BEFORE_VERTEX_REMOVED = 12;"
            ],
            [
                "VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex added event. This event is fired after a vertex is added to a\n * graph.\n */\npublic static final int VERTEX_ADDED = 13;"
            ],
            [
                "VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex removed event. This event is fired after a vertex is removed from\n * a graph.\n */\npublic static final int VERTEX_REMOVED = 14;"
            ],
            [
                "NULL_NODE",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "public static final int NULL_NODE = -1;"
            ],
            [
                "DEBUG",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected static final boolean DEBUG = false;"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg",
                "EdmondsKarpMaximumFlow",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 0.000000001;"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveClosure",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveClosure INSTANCE = new TransitiveClosure();"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveReduction",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveReduction INSTANCE = new TransitiveReduction();"
            ],
            [
                "NEGATIVE_UNDIRECTED_EDGE",
                "org.jgrapht.alg",
                "BellmanFordIterator",
                "/**\n * Error message.\n */\nprotected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg.flow",
                "MaximumFlowAlgorithmBase",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 1e-9;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [
            [
                "dg",
                "org.jgrapht.DirectedGraph",
                "DirectedGraph<V, E>"
            ],
            [
                "queue",
                "java.util.Queue",
                "Queue<V>"
            ],
            [
                "inDegreeMap",
                "java.util.Map",
                "Map<V, ModifiableInteger>"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "isCrossComponentTraversal",
                "org.jgrapht.traverse",
                "AbstractGraphIterator",
                "public boolean isCrossComponentTraversal()"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "putSeenData",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "protected D putSeenData(V arg0, D arg1)"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "getSeenData",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "protected D getSeenData(V arg0)"
            ],
            [
                "hasNext",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "public boolean hasNext()"
            ],
            [
                "getGraph",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "public Graph<V, E> getGraph()"
            ],
            [
                "isConnectedComponentExhausted",
                "org.jgrapht.traverse",
                "TopologicalOrderIterator",
                "/**\n * @see CrossComponentIterator#isConnectedComponentExhausted()\n */\n@Override\nprotected boolean isConnectedComponentExhausted() {\n    // FIXME jvs 25-Apr-2005: This isn't correct for a graph with more than\n    // one component.  We will actually exhaust a connected component\n    // before the queue is empty, because initialize adds roots from all\n    // components to the queue.\n    return queue.isEmpty();\n}"
            ],
            [
                "provideNextVertex",
                "org.jgrapht.traverse",
                "TopologicalOrderIterator",
                "/**\n * @see CrossComponentIterator#provideNextVertex()\n */\n@Override\nprotected V provideNextVertex() {\n    return queue.remove();\n}"
            ],
            [
                "next",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "public V next()"
            ],
            [
                "isSeenVertex",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "protected boolean isSeenVertex(Object arg0)"
            ],
            [
                "isReuseEvents",
                "org.jgrapht.traverse",
                "AbstractGraphIterator",
                "public boolean isReuseEvents()"
            ],
            [
                "next",
                "java.util",
                "Iterator",
                "public abstract E next()"
            ],
            [
                "outgoingEdgesOf",
                "org.jgrapht",
                "DirectedGraph",
                "public abstract Set<E> outgoingEdgesOf(V arg0)"
            ],
            [
                "outDegreeOf",
                "org.jgrapht",
                "DirectedGraph",
                "public abstract int outDegreeOf(V arg0)"
            ],
            [
                "inDegreeOf",
                "org.jgrapht",
                "DirectedGraph",
                "public abstract int inDegreeOf(V arg0)"
            ],
            [
                "incomingEdgesOf",
                "org.jgrapht",
                "DirectedGraph",
                "public abstract Set<E> incomingEdgesOf(V arg0)"
            ],
            [
                "containsVertex",
                "org.jgrapht",
                "Graph",
                "public abstract boolean containsVertex(V arg0)"
            ],
            [
                "getEdgeFactory",
                "org.jgrapht",
                "Graph",
                "public abstract EdgeFactory<V, E> getEdgeFactory()"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean addEdge(V arg0, V arg1, E arg2)"
            ],
            [
                "edgesOf",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> edgesOf(V arg0)"
            ],
            [
                "getEdge",
                "org.jgrapht",
                "Graph",
                "public abstract E getEdge(V arg0, V arg1)"
            ],
            [
                "removeEdge",
                "org.jgrapht",
                "Graph",
                "public abstract E removeEdge(V arg0, V arg1)"
            ],
            [
                "getEdgeSource",
                "org.jgrapht",
                "Graph",
                "public abstract V getEdgeSource(E arg0)"
            ],
            [
                "removeAllEdges",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> removeAllEdges(V arg0, V arg1)"
            ],
            [
                "addVertex",
                "org.jgrapht",
                "Graph",
                "public abstract boolean addVertex(V arg0)"
            ],
            [
                "removeEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeEdge(E arg0)"
            ],
            [
                "containsEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean containsEdge(V arg0, V arg1)"
            ],
            [
                "getEdgeWeight",
                "org.jgrapht",
                "Graph",
                "public abstract double getEdgeWeight(E arg0)"
            ],
            [
                "containsEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean containsEdge(E arg0)"
            ],
            [
                "getEdgeTarget",
                "org.jgrapht",
                "Graph",
                "public abstract V getEdgeTarget(E arg0)"
            ],
            [
                "vertexSet",
                "org.jgrapht",
                "Graph",
                "public abstract Set<V> vertexSet()"
            ],
            [
                "getAllEdges",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> getAllEdges(V arg0, V arg1)"
            ],
            [
                "edgeSet",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> edgeSet()"
            ],
            [
                "removeAllEdges",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeAllEdges(Collection<? extends E> arg0)"
            ],
            [
                "removeAllVertices",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeAllVertices(Collection<? extends V> arg0)"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graph",
                "public abstract E addEdge(V arg0, V arg1)"
            ],
            [
                "removeVertex",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeVertex(V arg0)"
            ],
            [
                "add",
                "java.util",
                "Queue",
                "public abstract boolean add(E arg0)"
            ],
            [
                "poll",
                "java.util",
                "Queue",
                "public abstract E poll()"
            ],
            [
                "remove",
                "java.util",
                "Queue",
                "public abstract E remove()"
            ],
            [
                "element",
                "java.util",
                "Queue",
                "public abstract E element()"
            ],
            [
                "peek",
                "java.util",
                "Queue",
                "public abstract E peek()"
            ],
            [
                "offer",
                "java.util",
                "Queue",
                "public abstract boolean offer(E arg0)"
            ],
            [
                "remove",
                "java.util",
                "Collection",
                "public abstract boolean remove(Object arg0)"
            ],
            [
                "addAll",
                "java.util",
                "Collection",
                "public abstract boolean addAll(Collection<? extends E> arg0)"
            ],
            [
                "isEmpty",
                "java.util",
                "Collection",
                "public abstract boolean isEmpty()"
            ],
            [
                "removeIf",
                "java.util",
                "Collection",
                "public default boolean removeIf(Predicate<? super E> arg0)"
            ],
            [
                "add",
                "java.util",
                "Collection",
                "public abstract boolean add(E arg0)"
            ],
            [
                "spliterator",
                "java.util",
                "Collection",
                "public default Spliterator<E> spliterator()"
            ],
            [
                "contains",
                "java.util",
                "Collection",
                "public abstract boolean contains(Object arg0)"
            ],
            [
                "hashCode",
                "java.util",
                "Collection",
                "public abstract int hashCode()"
            ],
            [
                "toArray",
                "java.util",
                "Collection",
                "public abstract Object[] toArray()"
            ],
            [
                "parallelStream",
                "java.util",
                "Collection",
                "public default Stream<E> parallelStream()"
            ],
            [
                "containsAll",
                "java.util",
                "Collection",
                "public abstract boolean containsAll(Collection<? extends Object> arg0)"
            ],
            [
                "stream",
                "java.util",
                "Collection",
                "public default Stream<E> stream()"
            ],
            [
                "removeAll",
                "java.util",
                "Collection",
                "public abstract boolean removeAll(Collection<? extends Object> arg0)"
            ],
            [
                "equals",
                "java.util",
                "Collection",
                "public abstract boolean equals(Object arg0)"
            ],
            [
                "size",
                "java.util",
                "Collection",
                "public abstract int size()"
            ],
            [
                "toArray",
                "java.util",
                "Collection",
                "public abstract <T> T[] toArray(T[] arg0)"
            ],
            [
                "retainAll",
                "java.util",
                "Collection",
                "public abstract boolean retainAll(Collection<? extends Object> arg0)"
            ],
            [
                "toArray",
                "java.util",
                "Collection",
                "public default <T> T[] toArray(IntFunction<T[]> arg0)"
            ],
            [
                "iterator",
                "java.util",
                "Collection",
                "public abstract Iterator<E> iterator()"
            ],
            [
                "spliterator",
                "java.lang",
                "Iterable",
                "public default Spliterator<T> spliterator()"
            ],
            [
                "iterator",
                "java.lang",
                "Iterable",
                "public abstract Iterator<T> iterator()"
            ],
            [
                "remove",
                "java.util",
                "Map",
                "public default boolean remove(Object arg0, Object arg1)"
            ],
            [
                "containsKey",
                "java.util",
                "Map",
                "public abstract boolean containsKey(Object arg0)"
            ],
            [
                "keySet",
                "java.util",
                "Map",
                "public abstract Set<K> keySet()"
            ],
            [
                "remove",
                "java.util",
                "Map",
                "public abstract V remove(Object arg0)"
            ],
            [
                "get",
                "java.util",
                "Map",
                "public abstract V get(Object arg0)"
            ],
            [
                "containsValue",
                "java.util",
                "Map",
                "public abstract boolean containsValue(Object arg0)"
            ],
            [
                "isEmpty",
                "java.util",
                "Map",
                "public abstract boolean isEmpty()"
            ],
            [
                "compute",
                "java.util",
                "Map",
                "public default V compute(K arg0, BiFunction<? super K, ? super V, ? extends V> arg1)"
            ],
            [
                "put",
                "java.util",
                "Map",
                "public abstract V put(K arg0, V arg1)"
            ],
            [
                "putIfAbsent",
                "java.util",
                "Map",
                "public default V putIfAbsent(K arg0, V arg1)"
            ],
            [
                "size",
                "java.util",
                "Map",
                "public abstract int size()"
            ],
            [
                "replace",
                "java.util",
                "Map",
                "public default V replace(K arg0, V arg1)"
            ],
            [
                "values",
                "java.util",
                "Map",
                "public abstract Collection<V> values()"
            ],
            [
                "entrySet",
                "java.util",
                "Map",
                "public abstract Set<Map.Entry<K, V>> entrySet()"
            ],
            [
                "replace",
                "java.util",
                "Map",
                "public default boolean replace(K arg0, V arg1, V arg2)"
            ],
            [
                "computeIfAbsent",
                "java.util",
                "Map",
                "public default V computeIfAbsent(K arg0, Function<? super K, ? extends V> arg1)"
            ],
            [
                "equals",
                "java.util",
                "Map",
                "public abstract boolean equals(Object arg0)"
            ],
            [
                "getOrDefault",
                "java.util",
                "Map",
                "public default V getOrDefault(Object arg0, V arg1)"
            ],
            [
                "hashCode",
                "java.util",
                "Map",
                "public abstract int hashCode()"
            ],
            [
                "computeIfPresent",
                "java.util",
                "Map",
                "public default V computeIfPresent(K arg0, BiFunction<? super K, ? super V, ? extends V> arg1)"
            ],
            [
                "merge",
                "java.util",
                "Map",
                "public default V merge(K arg0, V arg1, BiFunction<? super V, ? super V, ? extends V> arg2)"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [
            [
                "nListeners",
                "org.jgrapht.traverse",
                "AbstractGraphIterator",
                "protected int nListeners;"
            ]
        ],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 26156,
        "oracle": ";",
        "oracleType": "PRE",
        "projectName": "jgrapht-core-0.9.2",
        "packageName": "org.jgrapht.traverse",
        "className": "TopologicalOrderIterator",
        "javadocTag": "@param dg the directed graph to be iterated.",
        "methodJavadoc": "    /**\n     * Creates a new topological order iterator over the directed graph\n     * specified, with arbitrary tie-breaking in case of partial order.\n     * Traversal will start at one of the graph's <i>sources</i>. See the\n     * definition of source at <a\n     * href=\"http://mathworld.wolfram.com/Source.html\">\n     * http://mathworld.wolfram.com/Source.html</a>.\n     *\n     * @param dg the directed graph to be iterated.\n     */",
        "methodSourceCode": "public TopologicalOrderIterator(DirectedGraph<V, E> dg){\n    this(dg, new LinkedListQueue<V>());\n}",
        "classJavadoc": "/**\n * Implements topological order traversal for a directed acyclic graph. A\n * topological sort is a permutation <tt>p</tt> of the vertices of a graph such\n * that an edge <tt>(i,j)</tt> implies that <tt>i</tt> appears before <tt>j</tt>\n * in <tt>p</tt> (Skiena 1990, p. 208). See also <a\n * href=\"http://mathworld.wolfram.com/TopologicalSort.html\">\n * http://mathworld.wolfram.com/TopologicalSort.html</a>.\n *\n * <p>See \"Algorithms in Java, Third Edition, Part 5: Graph Algorithms\" by\n * Robert Sedgewick and \"Data Structures and Algorithms with Object-Oriented\n * Design Patterns in Java\" by Bruno R. Preiss for implementation alternatives.\n * The latter can be found online at <a\n * href=\"http://www.brpreiss.com/books/opus5/\">\n * http://www.brpreiss.com/books/opus5/</a></p>\n *\n * <p>For this iterator to work correctly the graph must be acyclic, and must\n * not be modified during iteration. Currently there are no means to ensure\n * that, nor to fail-fast; the results with cyclic input (including self-loops)\n * or concurrent modifications are undefined. To precheck a graph for cycles,\n * consider using {@link org.jgrapht.alg.CycleDetector} or {@link\n * KosarajuStrongConnectivityInspector}.</p>\n *\n * @author Marden Neubert\n * @since Dec 18, 2004\n */",
        "classSourceCode": "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -----------------------------\n * TopologicalOrderIterator.java\n * -----------------------------\n * (C) Copyright 2004-2008, by Marden Neubert and Contributors.\n *\n * Original Author:  Marden Neubert\n * Contributor(s):   Barak Naveh, John V. Sichi\n *\n * $Id$\n *\n * Changes\n * -------\n * 17-Dec-2004 : Initial revision (MN);\n * 25-Apr-2005 : Fixes for start vertex order (JVS);\n * 06-Jun-2005 : Made generic (CH);\n *\n */\npackage org.jgrapht.traverse;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\nimport org.jgrapht.alg.*;\nimport org.jgrapht.util.*;\n\n\n/**\n * Implements topological order traversal for a directed acyclic graph. A\n * topological sort is a permutation <tt>p</tt> of the vertices of a graph such\n * that an edge <tt>(i,j)</tt> implies that <tt>i</tt> appears before <tt>j</tt>\n * in <tt>p</tt> (Skiena 1990, p. 208). See also <a\n * href=\"http://mathworld.wolfram.com/TopologicalSort.html\">\n * http://mathworld.wolfram.com/TopologicalSort.html</a>.\n *\n * <p>See \"Algorithms in Java, Third Edition, Part 5: Graph Algorithms\" by\n * Robert Sedgewick and \"Data Structures and Algorithms with Object-Oriented\n * Design Patterns in Java\" by Bruno R. Preiss for implementation alternatives.\n * The latter can be found online at <a\n * href=\"http://www.brpreiss.com/books/opus5/\">\n * http://www.brpreiss.com/books/opus5/</a></p>\n *\n * <p>For this iterator to work correctly the graph must be acyclic, and must\n * not be modified during iteration. Currently there are no means to ensure\n * that, nor to fail-fast; the results with cyclic input (including self-loops)\n * or concurrent modifications are undefined. To precheck a graph for cycles,\n * consider using {@link org.jgrapht.alg.CycleDetector} or {@link\n * KosarajuStrongConnectivityInspector}.</p>\n *\n * @author Marden Neubert\n * @since Dec 18, 2004\n */\npublic class TopologicalOrderIterator<V, E>\n    extends CrossComponentIterator<V, E, Object>\n{\n    private Queue<V> queue;\n    private Map<V, ModifiableInteger> inDegreeMap;\n\n    /**\n     * Creates a new topological order iterator over the directed graph\n     * specified, with arbitrary tie-breaking in case of partial order.\n     * Traversal will start at one of the graph's <i>sources</i>. See the\n     * definition of source at <a\n     * href=\"http://mathworld.wolfram.com/Source.html\">\n     * http://mathworld.wolfram.com/Source.html</a>.\n     *\n     * @param dg the directed graph to be iterated.\n     */\n    public TopologicalOrderIterator(DirectedGraph<V, E> dg)\n    {\n        this(dg, new LinkedListQueue<V>());\n    }\n\n    /**\n     * Creates a new topological order iterator over the directed graph\n     * specified, with a user-supplied queue implementation to allow customized\n     * control over tie-breaking in case of partial order. Traversal will start\n     * at one of the graph's <i>sources</i>. See the definition of source at <a\n     * href=\"http://mathworld.wolfram.com/Source.html\">\n     * http://mathworld.wolfram.com/Source.html</a>.\n     *\n     * @param dg the directed graph to be iterated.\n     * @param queue queue to use for tie-break in case of partial order (e.g. a\n     * PriorityQueue can be used to break ties according to vertex priority);\n     * must be initially empty\n     */\n    public TopologicalOrderIterator(DirectedGraph<V, E> dg, Queue<V> queue)\n    {\n        this(dg, queue, new HashMap<V, ModifiableInteger>());\n    }\n\n    // NOTE: This is a hack to deal with the fact that CrossComponentIterator\n    // needs to know the start vertex in its constructor\n    private TopologicalOrderIterator(\n        DirectedGraph<V, E> dg,\n        Queue<V> queue,\n        Map<V, ModifiableInteger> inDegreeMap)\n    {\n        this(dg, initialize(dg, queue, inDegreeMap));\n        this.queue = queue;\n        this.inDegreeMap = inDegreeMap;\n\n        // empty queue for non-empty graph would indicate presence of\n        // cycles (no roots found)\n        assert dg.vertexSet().isEmpty() || !queue.isEmpty();\n    }\n\n    // NOTE: This is intentionally private, because starting the sort \"in the\n    // middle\" doesn't make sense.\n    private TopologicalOrderIterator(DirectedGraph<V, E> dg, V start)\n    {\n        super(dg, start);\n    }\n\n    /**\n     * @see CrossComponentIterator#isConnectedComponentExhausted()\n     */\n    @Override protected boolean isConnectedComponentExhausted()\n    {\n        // FIXME jvs 25-Apr-2005: This isn't correct for a graph with more than\n        // one component.  We will actually exhaust a connected component\n        // before the queue is empty, because initialize adds roots from all\n        // components to the queue.\n        return queue.isEmpty();\n    }\n\n    /**\n     * @see CrossComponentIterator#encounterVertex(Object, Object)\n     */\n    @Override protected void encounterVertex(V vertex, E edge)\n    {\n        putSeenData(vertex, null);\n        decrementInDegree(vertex);\n    }\n\n    /**\n     * @see CrossComponentIterator#encounterVertexAgain(Object, Object)\n     */\n    @Override protected void encounterVertexAgain(V vertex, E edge)\n    {\n        decrementInDegree(vertex);\n    }\n\n    /**\n     * @see CrossComponentIterator#provideNextVertex()\n     */\n    @Override protected V provideNextVertex()\n    {\n        return queue.remove();\n    }\n\n    /**\n     * Decrements the in-degree of a vertex.\n     *\n     * @param vertex the vertex whose in-degree will be decremented.\n     */\n    private void decrementInDegree(V vertex)\n    {\n        ModifiableInteger inDegree = inDegreeMap.get(vertex);\n\n        if (inDegree.value > 0) {\n            inDegree.value--;\n\n            if (inDegree.value == 0) {\n                queue.offer(vertex);\n            }\n        }\n    }\n\n    /**\n     * Initializes the internal traversal object structure. Sets up the internal\n     * queue with the directed graph vertices and creates the control structure\n     * for the in-degrees.\n     *\n     * @param dg the directed graph to be iterated.\n     * @param queue initializer for queue\n     * @param inDegreeMap initializer for inDegreeMap\n     *\n     * @return start vertex\n     */\n    private static <V, E> V initialize(\n        DirectedGraph<V, E> dg,\n        Queue<V> queue,\n        Map<V, ModifiableInteger> inDegreeMap)\n    {\n        for (Iterator<V> i = dg.vertexSet().iterator(); i.hasNext();) {\n            V vertex = i.next();\n\n            int inDegree = dg.inDegreeOf(vertex);\n            inDegreeMap.put(vertex, new ModifiableInteger(inDegree));\n\n            if (inDegree == 0) {\n                queue.offer(vertex);\n            }\n        }\n\n        if (queue.isEmpty()) {\n            return null;\n        } else {\n            return queue.peek();\n        }\n    }\n\n    // NOTE jvs 22-Dec-2006:  For JDK1.4-compatibility, we can't assume\n    // that LinkedList implements Queue, since that wasn't introduced\n    // until JDK1.5, so use an adapter here.  Move this to\n    // top-level in org.jgrapht.util if anyone else needs it.\n    private static class LinkedListQueue<T>\n        extends LinkedList<T>\n        implements Queue<T>\n    {\n        private static final long serialVersionUID = 4217659843476891334L;\n\n        @Override public T element()\n        {\n            return getFirst();\n        }\n\n        @Override public boolean offer(T o)\n        {\n            return add(o);\n        }\n\n        @Override public T peek()\n        {\n            if (isEmpty()) {\n                return null;\n            }\n            return getFirst();\n        }\n\n        @Override public T poll()\n        {\n            if (isEmpty()) {\n                return null;\n            }\n            return removeFirst();\n        }\n\n        @Override public T remove()\n        {\n            return removeFirst();\n        }\n    }\n}\n\n// End TopologicalOrderIterator.java\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "PartiteRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "RandomGraphHelper",
                "org.jgrapht.experimental"
            ],
            [
                "GraphReader",
                "org.jgrapht.experimental"
            ],
            [
                "DirectedAcyclicGraph",
                "org.jgrapht.experimental.dag"
            ],
            [
                "GraphSquare",
                "org.jgrapht.experimental"
            ],
            [
                "UniformRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "GraphTests",
                "org.jgrapht.experimental"
            ],
            [
                "ApproximationAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "BrownBacktrackColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "GreedyColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "IntArrayGraphAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ExactAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ListenableGraph",
                "org.jgrapht"
            ],
            [
                "ModifiableInteger",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeapNode",
                "org.jgrapht.util"
            ],
            [
                "WeightCombiner",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeap",
                "org.jgrapht.util"
            ],
            [
                "TypeUtil",
                "org.jgrapht.util"
            ],
            [
                "ArrayUnenforcedSet",
                "org.jgrapht.util"
            ],
            [
                "VertexPair",
                "org.jgrapht.util"
            ],
            [
                "MathUtil",
                "org.jgrapht.util"
            ],
            [
                "PrefetchIterator",
                "org.jgrapht.util"
            ],
            [
                "VertexFactory",
                "org.jgrapht"
            ],
            [
                "Graph",
                "org.jgrapht"
            ],
            [
                "GraphPath",
                "org.jgrapht"
            ],
            [
                "UndirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraph",
                "org.jgrapht.graph"
            ],
            [
                "MixedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DefaultGraphMapping",
                "org.jgrapht.graph"
            ],
            [
                "WeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskEdgeSet",
                "org.jgrapht.graph"
            ],
            [
                "Pseudograph",
                "org.jgrapht.graph"
            ],
            [
                "MaskFunctor",
                "org.jgrapht.graph"
            ],
            [
                "GraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractBaseGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "Multigraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultWeightedEdge",
                "org.jgrapht.graph"
            ],
            [
                "ListenableDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeSetFactory",
                "org.jgrapht.graph"
            ],
            [
                "GraphDelegator",
                "org.jgrapht.graph"
            ],
            [
                "DefaultListenableGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedVertexFactory",
                "org.jgrapht.graph"
            ],
            [
                "DefaultEdge",
                "org.jgrapht.graph"
            ],
            [
                "MaskVertexSet",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "IntrusiveEdge",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphPathImpl",
                "org.jgrapht.graph"
            ],
            [
                "Subgraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractGraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedEdgeFactory",
                "org.jgrapht.graph"
            ],
            [
                "SimpleWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "WeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeReversedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "AbstractGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "ListenableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraphPath",
                "org.jgrapht.graph"
            ],
            [
                "ParanoidGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphHelper",
                "org.jgrapht"
            ],
            [
                "Graphs",
                "org.jgrapht"
            ],
            [
                "DirectedGraph",
                "org.jgrapht"
            ],
            [
                "WeightedGraph",
                "org.jgrapht"
            ],
            [
                "HyperCubeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RingGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WheelGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GridGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "ScaleFreeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedBipartiteGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "LinearGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RandomGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGeneratorAdapter",
                "org.jgrapht.generate"
            ],
            [
                "EmptyGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteBipartiteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "StarGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "UndirectedGraph",
                "org.jgrapht"
            ],
            [
                "TopologicalOrderIterator",
                "org.jgrapht.traverse"
            ],
            [
                "CrossComponentIterator",
                "org.jgrapht.traverse"
            ],
            [
                "AbstractGraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "ClosestFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "BreadthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "DepthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "GraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "EdgeFactory",
                "org.jgrapht"
            ],
            [
                "GraphMapping",
                "org.jgrapht"
            ],
            [
                "VertexSetListener",
                "org.jgrapht.event"
            ],
            [
                "EdgeTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "TraversalListener",
                "org.jgrapht.event"
            ],
            [
                "GraphEdgeChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "VertexTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphListener",
                "org.jgrapht.event"
            ],
            [
                "TraversalListenerAdapter",
                "org.jgrapht.event"
            ],
            [
                "ConnectedComponentTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphVertexChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "TarjanLowestCommonAncestor",
                "org.jgrapht.alg"
            ],
            [
                "PrimMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "BlockCutpointGraph",
                "org.jgrapht.alg"
            ],
            [
                "AllDirectedPaths",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPathsIterator",
                "org.jgrapht.alg"
            ],
            [
                "KruskalMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "StrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "VF2State",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2AbstractIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "GraphOrdering",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphicGraphMapping",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2MappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "BronKerboschCliqueFinder",
                "org.jgrapht.alg"
            ],
            [
                "ChromaticNumber",
                "org.jgrapht.alg"
            ],
            [
                "KosarajuStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "DijkstraShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElement",
                "org.jgrapht.alg"
            ],
            [
                "AStarShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordPathElement",
                "org.jgrapht.alg"
            ],
            [
                "FloydWarshallShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "UnionFind",
                "org.jgrapht.alg.util"
            ],
            [
                "AlwaysEqualComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Extension",
                "org.jgrapht.alg.util"
            ],
            [
                "VertexDegreeComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Pair",
                "org.jgrapht.alg.util"
            ],
            [
                "GabowStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "HawickJamesSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "DirectedSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "JohnsonSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TiernanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "UndirectedCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "PatonCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TarjanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "SzwarcfiterLauerSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "BiconnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "ConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "MinSourceSinkCut",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsBlossomShrinking",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveClosure",
                "org.jgrapht.alg"
            ],
            [
                "HopcroftKarpBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "StoerWagnerMinimumCut",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "KuhnMunkresMinimalWeightBipartitePerfectMatching",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveReduction",
                "org.jgrapht.alg"
            ],
            [
                "EulerianCircuit",
                "org.jgrapht.alg"
            ],
            [
                "DirectedNeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "NaiveLcaFinder",
                "org.jgrapht.alg"
            ],
            [
                "MaximumWeightBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "HamiltonianCycle",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "NeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "VertexCovers",
                "org.jgrapht.alg"
            ],
            [
                "CycleDetector",
                "org.jgrapht.alg"
            ],
            [
                "AStarAdmissibleHeuristic",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MinimumSpanningTree",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "WeightedMatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "StrongConnectivityAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MaximumFlowAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "CliqueMinimalSeparatorDecomposition",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordIterator",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElement",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "PushRelabelMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "MaximumFlowAlgorithmBase",
                "org.jgrapht.alg.flow"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "addVertices",
                "org.jgrapht.experimental",
                "RandomGraphHelper",
                "/**\n * .\n *\n * @param target\n * @param vertexFactory\n * @param numVertices\n *\n * @return vertices\n */\n@SuppressWarnings(\"unchecked\")\npublic static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices) {\n    Object[] vertices = new Object[numVertices];\n    for (int i = 0; i < numVertices; ++i) {\n        vertices[i] = vertexFactory.createVertex();\n        target.addVertex(vertices[i]);\n    }\n    return vertices;\n}"
            ],
            [
                "isEmpty",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isEmpty(Graph<V, E> g) {\n    return g.edgeSet().isEmpty();\n}"
            ],
            [
                "isComplete",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isComplete(Graph<V, E> g) {\n    int n = g.vertexSet().size();\n    return g.edgeSet().size() == (n * (n - 1) / 2);\n}"
            ],
            [
                "isConnected",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isConnected(Graph<V, E> g) {\n    int numVertices = g.vertexSet().size();\n    int numEdges = g.edgeSet().size();\n    if (numEdges < (numVertices - 1)) {\n        return false;\n    }\n    if ((numVertices < 2) || (numEdges > ((numVertices - 1) * (numVertices - 2) / 2))) {\n        return true;\n    }\n    Set<V> known = new HashSet<V>();\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = g.vertexSet().iterator().next();\n    // start with node 1\n    queue.add(v);\n    known.add(v);\n    while (!queue.isEmpty()) {\n        v = queue.removeFirst();\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            v = it.next();\n            if (!known.contains(v)) {\n                known.add(v);\n                queue.add(v);\n            }\n        }\n    }\n    return known.size() == numVertices;\n}"
            ],
            [
                "isTree",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isTree(Graph<V, E> g) {\n    return isConnected(g) && (g.edgeSet().size() == (g.vertexSet().size() - 1));\n}"
            ],
            [
                "isBipartite",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isBipartite(Graph<V, E> g) {\n    if ((4 * g.edgeSet().size()) > (g.vertexSet().size() * g.vertexSet().size())) {\n        return false;\n    }\n    if (isEmpty(g)) {\n        return true;\n    }\n    Set<V> unknown = new HashSet<V>(g.vertexSet());\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = unknown.iterator().next();\n    Set<V> odd = new HashSet<V>();\n    queue.add(v);\n    while (!unknown.isEmpty()) {\n        if (queue.isEmpty()) {\n            queue.add(unknown.iterator().next());\n        }\n        v = queue.removeFirst();\n        unknown.remove(v);\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            V n = it.next();\n            if (unknown.contains(n)) {\n                queue.add(n);\n                if (!odd.contains(v)) {\n                    odd.add(n);\n                }\n            } else if (!(odd.contains(v) ^ odd.contains(n))) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
            ],
            [
                "union",
                "org.jgrapht.util",
                "FibonacciHeap",
                "// size\n/**\n * Joins two Fibonacci heaps into a new one. No heap consolidation is\n * performed at this time. The two root lists are simply joined together.\n *\n * <p>Running time: O(1) actual</p>\n *\n * @param h1 first heap\n * @param h2 second heap\n *\n * @return new heap containing h1 and h2\n */\npublic static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2) {\n    FibonacciHeap<T> h = new FibonacciHeap<T>();\n    if ((h1 != null) && (h2 != null)) {\n        h.minNode = h1.minNode;\n        if (h.minNode != null) {\n            if (h2.minNode != null) {\n                h.minNode.right.left = h2.minNode.left;\n                h2.minNode.left.right = h.minNode.right;\n                h.minNode.right = h2.minNode;\n                h2.minNode.left = h.minNode;\n                if (h2.minNode.key < h1.minNode.key) {\n                    h.minNode = h2.minNode;\n                }\n            }\n        } else {\n            h.minNode = h2.minNode;\n        }\n        h.nNodes = h1.nNodes + h2.nNodes;\n    }\n    return h;\n}"
            ],
            [
                "uncheckedCast",
                "org.jgrapht.util",
                "TypeUtil",
                "/**\n * Casts an object to a type.\n *\n * @param o object to be cast\n * @param typeDecl conveys the target type information; the actual value is\n * unused and can be null since this is all just stupid compiler tricks\n *\n * @return the result of the cast\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl) {\n    return (T) o;\n}"
            ],
            [
                "factorial",
                "org.jgrapht.util",
                "MathUtil",
                "public static long factorial(int N) {\n    long multi = 1;\n    for (int i = 1; i <= N; i++) {\n        multi = multi * i;\n    }\n    return multi;\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graphs",
                "/**\n * Creates a new edge and adds it to the specified graph similarly to the\n * {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n *\n * @see Graph#addEdge(Object, Object)\n */\npublic static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    EdgeFactory<V, E> ef = g.getEdgeFactory();\n    E e = ef.createEdge(sourceVertex, targetVertex);\n    // we first create the edge and set the weight to make sure that\n    // listeners will see the correct weight upon addEdge.\n    assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n    ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n    return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new edge and adds it to the specified\n * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return g.addEdge(sourceVertex, targetVertex);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified edge to the graph, including its vertices if not\n * already included.\n *\n * @param targetGraph the graph for which the specified edge to be added.\n * @param sourceGraph the graph in which the specified edge is already\n * present\n * @param edge edge to add\n *\n * @return <tt>true</tt> if the target graph did not already contain the\n * specified edge.\n */\npublic static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge) {\n    V sourceVertex = sourceGraph.getEdgeSource(edge);\n    V targetVertex = sourceGraph.getEdgeTarget(edge);\n    targetGraph.addVertex(sourceVertex);\n    targetGraph.addVertex(targetVertex);\n    return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new weighted edge and adds it to the\n * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n * method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return addEdge(g, sourceVertex, targetVertex, weight);\n}"
            ],
            [
                "addGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all the vertices and all the edges of the specified source graph to\n * the specified destination graph. First all vertices of the source graph\n * are added to the destination graph. Then every edge of the source graph\n * is added to the destination graph. This method returns <code>true</code>\n * if the destination graph has been modified as a result of this operation,\n * otherwise it returns <code>false</code>.\n *\n * <p>The behavior of this operation is undefined if any of the specified\n * graphs is modified while operation is in progress.</p>\n *\n * @param destination the graph to which vertices and edges are added.\n * @param source the graph used as source for vertices and edges to add.\n *\n * @return <code>true</code> if and only if the destination graph has been\n * changed as a result of this operation.\n */\npublic static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source) {\n    boolean modified = addAllVertices(destination, source.vertexSet());\n    modified |= addAllEdges(destination, source, source.edgeSet());\n    return modified;\n}"
            ],
            [
                "addAllEdges",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds a subset of the edges of the specified source graph to the specified\n * destination graph. The behavior of this operation is undefined if either\n * of the graphs is modified while the operation is in progress. {@link\n * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n * be added automatically to the target graph.\n *\n * @param destination the graph to which edges are to be added\n * @param source the graph used as a source for edges to add\n * @param edges the edges to be added\n *\n * @return <tt>true</tt> if this graph changed as a result of the call\n */\npublic static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges) {\n    boolean modified = false;\n    for (E e : edges) {\n        V s = source.getEdgeSource(e);\n        V t = source.getEdgeTarget(e);\n        destination.addVertex(s);\n        destination.addVertex(t);\n        modified |= destination.addEdge(s, t, e);\n    }\n    return modified;\n}"
            ],
            [
                "addAllVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all of the specified vertices to the destination graph. The behavior\n * of this operation is undefined if the specified vertex collection is\n * modified while the operation is in progress. This method will invoke the\n * {@link Graph#addVertex(Object)} method.\n *\n * @param destination the graph to which edges are to be added\n * @param vertices the vertices to be added to the graph.\n *\n * @return <tt>true</tt> if graph changed as a result of the call\n *\n * @throws NullPointerException if the specified vertices contains one or\n * more null vertices, or if the specified vertex collection is <tt>\n * null</tt>.\n *\n * @see Graph#addVertex(Object)\n */\npublic static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices) {\n    boolean modified = false;\n    for (V v : vertices) {\n        modified |= destination.addVertex(v);\n    }\n    return modified;\n}"
            ],
            [
                "neighborListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the neighbors of a specified vertex.\n * If the graph is a multigraph vertices may appear more than once in the\n * returned list.\n *\n * @param g the graph to look for neighbors in.\n * @param vertex the vertex to get the neighbors of.\n *\n * @return a list of the vertices that are the neighbors of the specified\n * vertex.\n */\npublic static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex) {\n    List<V> neighbors = new ArrayList<V>();\n    for (E e : g.edgesOf(vertex)) {\n        neighbors.add(getOppositeVertex(g, e, vertex));\n    }\n    return neighbors;\n}"
            ],
            [
                "predecessorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct predecessors of a\n * specified vertex. If the graph is a multigraph, vertices may appear more\n * than once in the returned list.\n *\n * @param g the graph to look for predecessors in.\n * @param vertex the vertex to get the predecessors of.\n *\n * @return a list of the vertices that are the direct predecessors of the\n * specified vertex.\n */\npublic static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> predecessors = new ArrayList<V>();\n    Set<? extends E> edges = g.incomingEdgesOf(vertex);\n    for (E e : edges) {\n        predecessors.add(getOppositeVertex(g, e, vertex));\n    }\n    return predecessors;\n}"
            ],
            [
                "successorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct successors of a specified\n * vertex. If the graph is a multigraph vertices may appear more than once\n * in the returned list.\n *\n * @param g the graph to look for successors in.\n * @param vertex the vertex to get the successors of.\n *\n * @return a list of the vertices that are the direct successors of the\n * specified vertex.\n */\npublic static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> successors = new ArrayList<V>();\n    Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n    for (E e : edges) {\n        successors.add(getOppositeVertex(g, e, vertex));\n    }\n    return successors;\n}"
            ],
            [
                "undirectedGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns an undirected view of the specified graph. If the specified graph\n * is directed, returns an undirected view of it. If the specified graph is\n * already undirected, just returns it.\n *\n * @param g the graph for which an undirected view is to be returned.\n *\n * @return an undirected view of the specified graph, if it is directed, or\n * or the specified graph itself if it is already undirected.\n *\n * @throws IllegalArgumentException if the graph is neither DirectedGraph\n * nor UndirectedGraph.\n *\n * @see AsUndirectedGraph\n */\npublic static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n    } else if (g instanceof UndirectedGraph<?, ?>) {\n        return (UndirectedGraph<V, E>) g;\n    } else {\n        throw new IllegalArgumentException(\"Graph must be either DirectedGraph or UndirectedGraph\");\n    }\n}"
            ],
            [
                "testIncidence",
                "org.jgrapht",
                "Graphs",
                "/**\n * Tests whether an edge is incident to a vertex.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return true iff e is incident on v\n */\npublic static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v) {\n    return (g.getEdgeSource(e).equals(v)) || (g.getEdgeTarget(e).equals(v));\n}"
            ],
            [
                "getOppositeVertex",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the vertex opposite another vertex across an edge.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return vertex opposite to v across e\n */\npublic static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v) {\n    V source = g.getEdgeSource(e);\n    V target = g.getEdgeTarget(e);\n    if (v.equals(source)) {\n        return target;\n    } else if (v.equals(target)) {\n        return source;\n    } else {\n        throw new IllegalArgumentException(\"no such vertex: \" + v.toString());\n    }\n}"
            ],
            [
                "getPathVertexList",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the list of vertices visited by a path.\n *\n * @param path path of interest\n *\n * @return corresponding vertex list\n */\npublic static <V, E> List<V> getPathVertexList(GraphPath<V, E> path) {\n    Graph<V, E> g = path.getGraph();\n    List<V> list = new ArrayList<V>();\n    V v = path.getStartVertex();\n    list.add(v);\n    for (E e : path.getEdgeList()) {\n        v = getOppositeVertex(g, e, v);\n        list.add(v);\n    }\n    return list;\n}"
            ],
            [
                "range",
                "org.jgrapht.generate",
                "SimpleWeightedGraphMatrixGenerator",
                "///////////////////////////////////////////////////////////////////////////////////////////////\npublic static int[] range(final int from, final int to) {\n    int[] range = new int[to - from];\n    for (int i = from; i < to; ++i) {\n        range[i - from] = i;\n    }\n    return range;\n}"
            ],
            [
                "createGraphSpecifics",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "// -------------------------------------------------------------------------\n/**\n * @param <V>\n * @param <E>\n * @param g\n *\n * @return TODO Document me\n */\nstatic <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new DirectedSpecifics<V, E>((DirectedGraph<V, E>) g);\n    } else {\n        return new UndirectedSpecifics<V, E>(g);\n    }\n}"
            ],
            [
                "findGreedyChromaticNumber",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds the number of colors required for a greedy coloring of the graph.\n *\n * @param g an undirected graph to find the chromatic number of\n *\n * @return integer the approximate chromatic number from the greedy\n * algorithm\n */\npublic static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g) {\n    Map<Integer, Set<V>> coloredGroups = findGreedyColoredGroups(g);\n    return coloredGroups.keySet().size();\n}"
            ],
            [
                "findGreedyColoredGroups",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds a greedy coloring of the graph.\n *\n * @param g an undirected graph for which to find the coloring\n */\npublic static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g) {\n    // A copy of the graph is made, so that elements of the graph may be\n    // removed to carry out the algorithm\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // The Vertices will be sorted in decreasing order by degree, so that\n    // higher degree vertices have priority to be colored first\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    List<V> sortedVertices = new LinkedList<V>(sg.vertexSet());\n    Collections.sort(sortedVertices, comp);\n    Collections.reverse(sortedVertices);\n    int color;\n    // create a map which will hold color as key and Set<V> as value\n    Map<Integer, Set<V>> coloredGroups = new HashMap<Integer, Set<V>>();\n    // We'll attempt to color each vertex with a single color each\n    // iteration, and these vertices will be removed from the graph at the\n    // end of each iteration\n    for (color = 0; sg.vertexSet().size() > 0; color++) {\n        // This set will contain vertices that are colored with the\n        // current color of this iteration\n        Set<V> currentColor = new HashSet<V>();\n        for (Iterator<V> iter = sortedVertices.iterator(); iter.hasNext(); ) {\n            V v = iter.next();\n            // Add new vertices to be colored as long as they are not\n            // adjacent with any other vertex that has already been colored\n            // with the current color\n            boolean flag = true;\n            for (Iterator<V> innerIter = currentColor.iterator(); innerIter.hasNext(); ) {\n                V temp = innerIter.next();\n                if (sg.containsEdge(temp, v)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                currentColor.add(v);\n                iter.remove();\n            }\n        }\n        // Add all these vertices as a group for this color\n        coloredGroups.put(color, currentColor);\n        // Remove vertices from the graph and then repeat the process for\n        // the next iteration\n        sg.removeAllVertices(currentColor);\n    }\n    return coloredGroups;\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "BellmanFordShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by hops, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    BellmanFordShortestPath<V, E> alg = new BellmanFordShortestPath<V, E>(graph, startVertex);\n    return alg.getPathEdgeList(endVertex);\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "DijkstraShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by radius, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    DijkstraShortestPath<V, E> alg = new DijkstraShortestPath<V, E>(graph, startVertex, endVertex);\n    return alg.getPathEdgeList();\n}"
            ],
            [
                "of",
                "org.jgrapht.alg.util",
                "Pair",
                "/**\n * Creates new pair of elements pulling of the necessity to provide\n * corresponding types of the elements supplied\n *\n * @param a first element\n * @param b second element\n *\n * @return new pair\n */\npublic static <A, B> Pair<A, B> of(A a, B b) {\n    return new Pair<A, B>(a, b);\n}"
            ],
            [
                "isEulerian",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will check whether the graph passed in is Eulerian or not.\n *\n * @param g The graph to be checked\n *\n * @return true for Eulerian and false for non-Eulerian\n */\npublic static <V, E> boolean isEulerian(UndirectedGraph<V, E> g) {\n    // If the graph is not connected, then no Eulerian circuit exists\n    if (!(new ConnectivityInspector<V, E>(g)).isGraphConnected()) {\n        return false;\n    }\n    // A graph is Eulerian if and only if all vertices have even degree\n    // So, this code will check for that\n    Iterator<V> iter = g.vertexSet().iterator();\n    while (iter.hasNext()) {\n        V v = iter.next();\n        if ((g.degreeOf(v) % 2) == 1) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "getEulerianCircuitVertices",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will return a list of vertices which represents the Eulerian\n * circuit of the graph.\n *\n * @param g The graph to find an Eulerian circuit\n *\n * @return null if no Eulerian circuit exists, or a list of vertices\n * representing the Eulerian circuit if one does exist\n */\npublic static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g) {\n    // If the graph is not Eulerian then just return a null since no\n    // Eulerian circuit exists\n    if (!isEulerian(g)) {\n        return null;\n    }\n    // The circuit will be represented by a linked list\n    List<V> path = new LinkedList<V>();\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    path.add(sg.vertexSet().iterator().next());\n    // Algorithm for finding an Eulerian circuit Basically this will find an\n    // arbitrary circuit, then it will find another arbitrary circuit until\n    // every edge has been traversed\n    while (sg.edgeSet().size() > 0) {\n        V v = null;\n        // Find a vertex which has an edge that hasn't been traversed yet,\n        // and keep its index position in the circuit list\n        int index = 0;\n        for (Iterator<V> iter = path.iterator(); iter.hasNext(); index++) {\n            v = iter.next();\n            if (sg.degreeOf(v) > 0) {\n                break;\n            }\n        }\n        // Finds an arbitrary circuit of the current vertex and\n        // appends this into the circuit list\n        while (sg.degreeOf(v) > 0) {\n            for (Iterator<V> iter = sg.vertexSet().iterator(); iter.hasNext(); ) {\n                V temp = iter.next();\n                if (sg.containsEdge(v, temp)) {\n                    path.add(index, temp);\n                    sg.removeEdge(v, temp);\n                    v = temp;\n                    break;\n                }\n            }\n        }\n    }\n    return path;\n}"
            ],
            [
                "getApproximateOptimalForCompleteGraph",
                "org.jgrapht.alg",
                "HamiltonianCycle",
                "/**\n * This method will return an approximate minimal traveling salesman tour\n * (hamiltonian cycle). This algorithm requires that the graph be complete\n * and the triangle inequality exists (if x,y,z are vertices then\n * d(x,y)+d(y,z) &lt; d(x,z) for all x,y,z) then this algorithm will\n * guarantee a hamiltonian cycle such that the total weight of the cycle is\n * less than or equal to double the total weight of the optimal hamiltonian\n * cycle. The optimal solution is NP-complete, so this is a decent\n * approximation that runs in polynomial time.\n *\n * @param <V>\n * @param <E>\n * @param g is the graph to find the optimal tour for.\n *\n * @return The optimal tour as a list of vertices.\n */\npublic static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g) {\n    List<V> vertices = new LinkedList<V>(g.vertexSet());\n    // If the graph is not complete then return null since this algorithm\n    // requires the graph be complete\n    if ((vertices.size() * (vertices.size() - 1) / 2) != g.edgeSet().size()) {\n        return null;\n    }\n    List<V> tour = new LinkedList<V>();\n    // Each iteration a new vertex will be added to the tour until all\n    // vertices have been added\n    while (tour.size() != g.vertexSet().size()) {\n        boolean firstEdge = true;\n        double minEdgeValue = 0;\n        int minVertexFound = 0;\n        int vertexConnectedTo = 0;\n        // A check will be made for the shortest edge to a vertex not within\n        // the tour and that new vertex will be added to the vertex\n        for (int i = 0; i < tour.size(); i++) {\n            V v = tour.get(i);\n            for (int j = 0; j < vertices.size(); j++) {\n                double weight = g.getEdgeWeight(g.getEdge(v, vertices.get(j)));\n                if (firstEdge || (weight < minEdgeValue)) {\n                    firstEdge = false;\n                    minEdgeValue = weight;\n                    minVertexFound = j;\n                    vertexConnectedTo = i;\n                }\n            }\n        }\n        tour.add(vertexConnectedTo, vertices.get(minVertexFound));\n        vertices.remove(minVertexFound);\n    }\n    return tour;\n}"
            ],
            [
                "find2ApproximationCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a 2-approximation for a minimal vertex cover of the specified\n * graph. The algorithm promises a cover that is at most double the size of\n * a minimal cover. The algorithm takes O(|E|) time.\n *\n * <p>For more details see Jenny Walter, CMPU-240: Lecture notes for\n * Language Theory and Computation, Fall 2002, Vassar College, <a\n * href=\"http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf\">\n * http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf</a>.\n * </p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G'=(V',E') <-- G(V,E)\n    Subgraph<V, E, Graph<V, E>> sg = new Subgraph<V, E, Graph<V, E>>(g, null, null);\n    // while E' is non-empty\n    while (sg.edgeSet().size() > 0) {\n        // let (u,v) be an arbitrary edge of E'\n        E e = sg.edgeSet().iterator().next();\n        // C <-- C U {u,v}\n        V u = g.getEdgeSource(e);\n        V v = g.getEdgeTarget(e);\n        cover.add(u);\n        cover.add(v);\n        // remove from E' every edge incident on either u or v\n        sg.removeVertex(u);\n        sg.removeVertex(v);\n    }\n    // return C\n    return cover;\n}"
            ],
            [
                "findGreedyCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a greedy approximation for a minimal vertex cover of a specified\n * graph. At each iteration, the algorithm picks the vertex with the highest\n * degree and adds it to the cover, until all edges are covered.\n *\n * <p>The algorithm works on undirected graphs, but can also work on\n * directed graphs when their edge-directions are ignored. To ignore edge\n * directions you can use {@link org.jgrapht.Graphs#undirectedGraph(Graph)}\n * or {@link org.jgrapht.graph.AsUndirectedGraph}.</p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G' <-- G\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // compare vertices in descending order of degree\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    // while G' != {}\n    while (sg.edgeSet().size() > 0) {\n        // v <-- vertex with maximum degree in G'\n        V v = Collections.max(sg.vertexSet(), comp);\n        // C <-- C U {v}\n        cover.add(v);\n        // remove from G' every edge incident on v, and v itself\n        sg.removeVertex(v);\n    }\n    return cover;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "BEST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int BEST_ORDER = 0;"
            ],
            [
                "NATURAL_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int NATURAL_ORDER = 1;"
            ],
            [
                "SMALLEST_DEGREE_LAST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;"
            ],
            [
                "LARGEST_SATURATION_FIRST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;"
            ],
            [
                "DEFAULT_EDGE_WEIGHT",
                "org.jgrapht",
                "WeightedGraph",
                "/**\n * The default weight for an edge.\n */\npublic static double DEFAULT_EDGE_WEIGHT = 1.0;"
            ],
            [
                "HUB_VERTEX",
                "org.jgrapht.generate",
                "WheelGraphGenerator",
                "/**\n * Role for the hub vertex.\n */\npublic static final String HUB_VERTEX = \"Hub Vertex\";"
            ],
            [
                "CORNER_VERTEX",
                "org.jgrapht.generate",
                "GridGraphGenerator",
                "/**\n * Role for the vertices at the corners.\n */\npublic static final String CORNER_VERTEX = \"Corner Vertex\";"
            ],
            [
                "START_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the first vertex generated.\n */\npublic static final String START_VERTEX = \"Start Vertex\";"
            ],
            [
                "END_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the last vertex generated.\n */\npublic static final String END_VERTEX = \"End Vertex\";"
            ],
            [
                "CENTER_VERTEX",
                "org.jgrapht.generate",
                "StarGraphGenerator",
                "public static final String CENTER_VERTEX = \"Center Vertex\";"
            ],
            [
                "SENTINEL",
                "org.jgrapht.traverse",
                "DepthFirstIterator",
                "/**\n * Sentinel object. Unfortunately, we can't use null, because ArrayDeque\n * won't accept those. And we don't want to rely on the caller to provide a\n * sentinel object for us. So we have to play typecasting games.\n */\npublic static final Object SENTINEL = new Object();"
            ],
            [
                "BEFORE_EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge added event. This event is fired before an edge is added to a\n * graph.\n */\npublic static final int BEFORE_EDGE_ADDED = 21;"
            ],
            [
                "BEFORE_EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge removed event. This event is fired before an edge is removed\n * from a graph.\n */\npublic static final int BEFORE_EDGE_REMOVED = 22;"
            ],
            [
                "EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge added event. This event is fired after an edge is added to a graph.\n */\npublic static final int EDGE_ADDED = 23;"
            ],
            [
                "EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge removed event. This event is fired after an edge is removed from a\n * graph.\n */\npublic static final int EDGE_REMOVED = 24;"
            ],
            [
                "CONNECTED_COMPONENT_STARTED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal started event.\n */\npublic static final int CONNECTED_COMPONENT_STARTED = 31;"
            ],
            [
                "CONNECTED_COMPONENT_FINISHED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal finished event.\n */\npublic static final int CONNECTED_COMPONENT_FINISHED = 32;"
            ],
            [
                "BEFORE_VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex added event. This event is fired before a vertex is added\n * to a graph.\n */\npublic static final int BEFORE_VERTEX_ADDED = 11;"
            ],
            [
                "BEFORE_VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex removed event. This event is fired before a vertex is\n * removed from a graph.\n */\npublic static final int BEFORE_VERTEX_REMOVED = 12;"
            ],
            [
                "VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex added event. This event is fired after a vertex is added to a\n * graph.\n */\npublic static final int VERTEX_ADDED = 13;"
            ],
            [
                "VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex removed event. This event is fired after a vertex is removed from\n * a graph.\n */\npublic static final int VERTEX_REMOVED = 14;"
            ],
            [
                "NULL_NODE",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "public static final int NULL_NODE = -1;"
            ],
            [
                "DEBUG",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected static final boolean DEBUG = false;"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg",
                "EdmondsKarpMaximumFlow",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 0.000000001;"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveClosure",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveClosure INSTANCE = new TransitiveClosure();"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveReduction",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveReduction INSTANCE = new TransitiveReduction();"
            ],
            [
                "NEGATIVE_UNDIRECTED_EDGE",
                "org.jgrapht.alg",
                "BellmanFordIterator",
                "/**\n * Error message.\n */\nprotected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg.flow",
                "MaximumFlowAlgorithmBase",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 1e-9;"
            ]
        ],
        "tokensMethodJavadocValues": [
            [
                "\"http://mathworld.wolfram.com/Source.html\"",
                "String"
            ]
        ],
        "tokensMethodArguments": [
            [
                "dg",
                "org.jgrapht.DirectedGraph",
                "DirectedGraph<V, E>"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "next",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "public V next()"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "isConnectedComponentExhausted",
                "org.jgrapht.traverse",
                "TopologicalOrderIterator",
                "/**\n * @see CrossComponentIterator#isConnectedComponentExhausted()\n */\n@Override\nprotected boolean isConnectedComponentExhausted() {\n    // FIXME jvs 25-Apr-2005: This isn't correct for a graph with more than\n    // one component.  We will actually exhaust a connected component\n    // before the queue is empty, because initialize adds roots from all\n    // components to the queue.\n    return queue.isEmpty();\n}"
            ],
            [
                "getGraph",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "public Graph<V, E> getGraph()"
            ],
            [
                "isCrossComponentTraversal",
                "org.jgrapht.traverse",
                "AbstractGraphIterator",
                "public boolean isCrossComponentTraversal()"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "provideNextVertex",
                "org.jgrapht.traverse",
                "TopologicalOrderIterator",
                "/**\n * @see CrossComponentIterator#provideNextVertex()\n */\n@Override\nprotected V provideNextVertex() {\n    return queue.remove();\n}"
            ],
            [
                "hasNext",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "public boolean hasNext()"
            ],
            [
                "putSeenData",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "protected D putSeenData(V arg0, D arg1)"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "getSeenData",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "protected D getSeenData(V arg0)"
            ],
            [
                "next",
                "java.util",
                "Iterator",
                "public abstract E next()"
            ],
            [
                "isReuseEvents",
                "org.jgrapht.traverse",
                "AbstractGraphIterator",
                "public boolean isReuseEvents()"
            ],
            [
                "isSeenVertex",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "protected boolean isSeenVertex(Object arg0)"
            ],
            [
                "incomingEdgesOf",
                "org.jgrapht",
                "DirectedGraph",
                "public abstract Set<E> incomingEdgesOf(V arg0)"
            ],
            [
                "inDegreeOf",
                "org.jgrapht",
                "DirectedGraph",
                "public abstract int inDegreeOf(V arg0)"
            ],
            [
                "outDegreeOf",
                "org.jgrapht",
                "DirectedGraph",
                "public abstract int outDegreeOf(V arg0)"
            ],
            [
                "outgoingEdgesOf",
                "org.jgrapht",
                "DirectedGraph",
                "public abstract Set<E> outgoingEdgesOf(V arg0)"
            ],
            [
                "removeEdge",
                "org.jgrapht",
                "Graph",
                "public abstract E removeEdge(V arg0, V arg1)"
            ],
            [
                "edgesOf",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> edgesOf(V arg0)"
            ],
            [
                "containsVertex",
                "org.jgrapht",
                "Graph",
                "public abstract boolean containsVertex(V arg0)"
            ],
            [
                "getEdgeSource",
                "org.jgrapht",
                "Graph",
                "public abstract V getEdgeSource(E arg0)"
            ],
            [
                "removeAllEdges",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeAllEdges(Collection<? extends E> arg0)"
            ],
            [
                "getAllEdges",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> getAllEdges(V arg0, V arg1)"
            ],
            [
                "getEdge",
                "org.jgrapht",
                "Graph",
                "public abstract E getEdge(V arg0, V arg1)"
            ],
            [
                "removeAllEdges",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> removeAllEdges(V arg0, V arg1)"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graph",
                "public abstract E addEdge(V arg0, V arg1)"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean addEdge(V arg0, V arg1, E arg2)"
            ],
            [
                "addVertex",
                "org.jgrapht",
                "Graph",
                "public abstract boolean addVertex(V arg0)"
            ],
            [
                "removeVertex",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeVertex(V arg0)"
            ],
            [
                "vertexSet",
                "org.jgrapht",
                "Graph",
                "public abstract Set<V> vertexSet()"
            ],
            [
                "removeAllVertices",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeAllVertices(Collection<? extends V> arg0)"
            ],
            [
                "removeEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeEdge(E arg0)"
            ],
            [
                "getEdgeFactory",
                "org.jgrapht",
                "Graph",
                "public abstract EdgeFactory<V, E> getEdgeFactory()"
            ],
            [
                "getEdgeTarget",
                "org.jgrapht",
                "Graph",
                "public abstract V getEdgeTarget(E arg0)"
            ],
            [
                "getEdgeWeight",
                "org.jgrapht",
                "Graph",
                "public abstract double getEdgeWeight(E arg0)"
            ],
            [
                "containsEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean containsEdge(V arg0, V arg1)"
            ],
            [
                "containsEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean containsEdge(E arg0)"
            ],
            [
                "edgeSet",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> edgeSet()"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [
            [
                "nListeners",
                "org.jgrapht.traverse",
                "AbstractGraphIterator",
                "protected int nListeners;"
            ]
        ],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 26160,
        "oracle": ";",
        "oracleType": "PRE",
        "projectName": "jgrapht-core-0.9.2",
        "packageName": "org.jgrapht.traverse",
        "className": "CrossComponentIterator",
        "javadocTag": "@param vertex the vertex encountered",
        "methodJavadoc": "    /**\n     * Update data structures the first time we see a vertex.\n     *\n     * @param vertex the vertex encountered\n     * @param edge the edge via which the vertex was encountered, or null if the\n     * vertex is a starting point\n     */",
        "methodSourceCode": "protected abstract void encounterVertex(V vertex, E edge);",
        "classJavadoc": "/**\n * Provides a cross-connected-component traversal functionality for iterator\n * subclasses.\n *\n * @param <V> vertex type\n * @param <E> edge type\n * @param <D> type of data associated to seen vertices\n *\n * @author Barak Naveh\n * @since Jan 31, 2004\n */",
        "classSourceCode": "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ---------------------------\n * CrossComponentIterator.java\n * ---------------------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   John V. Sichi\n *                   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 31-Jul-2003 : Initial revision (BN);\n * 11-Aug-2003 : Adaptation to new event model (BN);\n * 31-Jan-2004 : Extracted cross-component traversal functionality (BN);\n * 04-May-2004 : Made generic (CH)\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n *\n */\npackage org.jgrapht.traverse;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\nimport org.jgrapht.event.*;\n\n\n/**\n * Provides a cross-connected-component traversal functionality for iterator\n * subclasses.\n *\n * @param <V> vertex type\n * @param <E> edge type\n * @param <D> type of data associated to seen vertices\n *\n * @author Barak Naveh\n * @since Jan 31, 2004\n */\npublic abstract class CrossComponentIterator<V, E, D>\n    extends AbstractGraphIterator<V, E>\n{\n    private static final int CCS_BEFORE_COMPONENT = 1;\n    private static final int CCS_WITHIN_COMPONENT = 2;\n    private static final int CCS_AFTER_COMPONENT = 3;\n\n    /**\n     * Standard vertex visit state enumeration.\n     */\n    protected static enum VisitColor\n    {\n        /**\n         * Vertex has not been returned via iterator yet.\n         */\n        WHITE,\n\n        /**\n         * Vertex has been returned via iterator, but we're not done with all of\n         * its out-edges yet.\n         */\n        GRAY,\n\n        /**\n         * Vertex has been returned via iterator, and we're done with all of its\n         * out-edges.\n         */\n        BLACK\n    }\n\n    //\n    private final ConnectedComponentTraversalEvent ccFinishedEvent =\n        new ConnectedComponentTraversalEvent(\n            this,\n            ConnectedComponentTraversalEvent.CONNECTED_COMPONENT_FINISHED);\n    private final ConnectedComponentTraversalEvent ccStartedEvent =\n        new ConnectedComponentTraversalEvent(\n            this,\n            ConnectedComponentTraversalEvent.CONNECTED_COMPONENT_STARTED);\n\n    // TODO: support ConcurrentModificationException if graph modified\n    // during iteration.\n    private FlyweightEdgeEvent<V, E> reusableEdgeEvent;\n    private FlyweightVertexEvent<V> reusableVertexEvent;\n    private Iterator<V> vertexIterator = null;\n\n    /**\n     * Stores the vertices that have been seen during iteration and (optionally)\n     * some additional traversal info regarding each vertex.\n     */\n    private Map<V, D> seen = new HashMap<V, D>();\n    private V startVertex;\n    private Specifics<V, E> specifics;\n\n    private final Graph<V, E> graph;\n\n    /**\n     * The connected component state\n     */\n    private int state = CCS_BEFORE_COMPONENT;\n\n    /**\n     * Creates a new iterator for the specified graph. Iteration will start at\n     * the specified start vertex. If the specified start vertex is <code>\n     * null</code>, Iteration will start at an arbitrary graph vertex.\n     *\n     * @param g the graph to be iterated.\n     * @param startVertex the vertex iteration to be started.\n     *\n     * @throws IllegalArgumentException if <code>g==null</code> or does not\n     * contain <code>startVertex</code>\n     */\n    public CrossComponentIterator(Graph<V, E> g, V startVertex)\n    {\n        super();\n\n        if (g == null) {\n            throw new IllegalArgumentException(\"graph must not be null\");\n        }\n        graph = g;\n\n        specifics = createGraphSpecifics(g);\n        vertexIterator = g.vertexSet().iterator();\n        setCrossComponentTraversal(startVertex == null);\n\n        reusableEdgeEvent = new FlyweightEdgeEvent<V, E>(this, null);\n        reusableVertexEvent = new FlyweightVertexEvent<V>(this, null);\n\n        if (startVertex == null) {\n            // pick a start vertex if graph not empty\n            if (vertexIterator.hasNext()) {\n                this.startVertex = vertexIterator.next();\n            } else {\n                this.startVertex = null;\n            }\n        } else if (g.containsVertex(startVertex)) {\n            this.startVertex = startVertex;\n        } else {\n            throw new IllegalArgumentException(\n                \"graph must contain the start vertex\");\n        }\n    }\n\n    /**\n     * @return the graph being traversed\n     */\n    public Graph<V, E> getGraph()\n    {\n        return graph;\n    }\n\n    /**\n     * @see java.util.Iterator#hasNext()\n     */\n    @Override public boolean hasNext()\n    {\n        if (startVertex != null) {\n            encounterStartVertex();\n        }\n\n        if (isConnectedComponentExhausted()) {\n            if (state == CCS_WITHIN_COMPONENT) {\n                state = CCS_AFTER_COMPONENT;\n                if (nListeners != 0) {\n                    fireConnectedComponentFinished(ccFinishedEvent);\n                }\n            }\n\n            if (isCrossComponentTraversal()) {\n                while (vertexIterator.hasNext()) {\n                    V v = vertexIterator.next();\n\n                    if (!isSeenVertex(v)) {\n                        encounterVertex(v, null);\n                        state = CCS_BEFORE_COMPONENT;\n\n                        return true;\n                    }\n                }\n\n                return false;\n            } else {\n                return false;\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @see java.util.Iterator#next()\n     */\n    @Override public V next()\n    {\n        if (startVertex != null) {\n            encounterStartVertex();\n        }\n\n        if (hasNext()) {\n            if (state == CCS_BEFORE_COMPONENT) {\n                state = CCS_WITHIN_COMPONENT;\n                if (nListeners != 0) {\n                    fireConnectedComponentStarted(ccStartedEvent);\n                }\n            }\n\n            V nextVertex = provideNextVertex();\n            if (nListeners != 0) {\n                fireVertexTraversed(createVertexTraversalEvent(nextVertex));\n            }\n\n            addUnseenChildrenOf(nextVertex);\n\n            return nextVertex;\n        } else {\n            throw new NoSuchElementException();\n        }\n    }\n\n    /**\n     * Returns <tt>true</tt> if there are no more uniterated vertices in the\n     * currently iterated connected component; <tt>false</tt> otherwise.\n     *\n     * @return <tt>true</tt> if there are no more uniterated vertices in the\n     * currently iterated connected component; <tt>false</tt> otherwise.\n     */\n    protected abstract boolean isConnectedComponentExhausted();\n\n    /**\n     * Update data structures the first time we see a vertex.\n     *\n     * @param vertex the vertex encountered\n     * @param edge the edge via which the vertex was encountered, or null if the\n     * vertex is a starting point\n     */\n    protected abstract void encounterVertex(V vertex, E edge);\n\n    /**\n     * Returns the vertex to be returned in the following call to the iterator\n     * <code>next</code> method.\n     *\n     * @return the next vertex to be returned by this iterator.\n     */\n    protected abstract V provideNextVertex();\n\n    /**\n     * Access the data stored for a seen vertex.\n     *\n     * @param vertex a vertex which has already been seen.\n     *\n     * @return data associated with the seen vertex or <code>null</code> if no\n     * data was associated with the vertex. A <code>null</code> return can also\n     * indicate that the vertex was explicitly associated with <code>\n     * null</code>.\n     */\n    protected D getSeenData(V vertex)\n    {\n        return seen.get(vertex);\n    }\n\n    /**\n     * Determines whether a vertex has been seen yet by this traversal.\n     *\n     * @param vertex vertex in question\n     *\n     * @return <tt>true</tt> if vertex has already been seen\n     */\n    protected boolean isSeenVertex(Object vertex)\n    {\n        return seen.containsKey(vertex);\n    }\n\n    /**\n     * Called whenever we re-encounter a vertex. The default implementation does\n     * nothing.\n     *\n     * @param vertex the vertex re-encountered\n     * @param edge the edge via which the vertex was re-encountered\n     */\n    protected abstract void encounterVertexAgain(V vertex, E edge);\n\n    /**\n     * Stores iterator-dependent data for a vertex that has been seen.\n     *\n     * @param vertex a vertex which has been seen.\n     * @param data data to be associated with the seen vertex.\n     *\n     * @return previous value associated with specified vertex or <code>\n     * null</code> if no data was associated with the vertex. A <code>\n     * null</code> return can also indicate that the vertex was explicitly\n     * associated with <code>null</code>.\n     */\n    protected D putSeenData(V vertex, D data)\n    {\n        return seen.put(vertex, data);\n    }\n\n    /**\n     * Called when a vertex has been finished (meaning is dependent on traversal\n     * represented by subclass).\n     *\n     * @param vertex vertex which has been finished\n     */\n    protected void finishVertex(V vertex)\n    {\n        if (nListeners != 0) {\n            fireVertexFinished(createVertexTraversalEvent(vertex));\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    /**\n     * @param <V>\n     * @param <E>\n     * @param g\n     *\n     * @return TODO Document me\n     */\n    static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new DirectedSpecifics<V, E>((DirectedGraph<V, E>) g);\n        } else {\n            return new UndirectedSpecifics<V, E>(g);\n        }\n    }\n\n    private void addUnseenChildrenOf(V vertex)\n    {\n        for (E edge : specifics.edgesOf(vertex)) {\n            if (nListeners != 0) {\n                fireEdgeTraversed(createEdgeTraversalEvent(edge));\n            }\n\n            V oppositeV = Graphs.getOppositeVertex(graph, edge, vertex);\n\n            if (isSeenVertex(oppositeV)) {\n                encounterVertexAgain(oppositeV, edge);\n            } else {\n                encounterVertex(oppositeV, edge);\n            }\n        }\n    }\n\n    private EdgeTraversalEvent<V, E> createEdgeTraversalEvent(E edge)\n    {\n        if (isReuseEvents()) {\n            reusableEdgeEvent.setEdge(edge);\n\n            return reusableEdgeEvent;\n        } else {\n            return new EdgeTraversalEvent<V, E>(this, edge);\n        }\n    }\n\n    private VertexTraversalEvent<V> createVertexTraversalEvent(V vertex)\n    {\n        if (isReuseEvents()) {\n            reusableVertexEvent.setVertex(vertex);\n\n            return reusableVertexEvent;\n        } else {\n            return new VertexTraversalEvent<V>(this, vertex);\n        }\n    }\n\n    private void encounterStartVertex()\n    {\n        encounterVertex(startVertex, null);\n        startVertex = null;\n    }\n\n    static interface SimpleContainer<T>\n    {\n        /**\n         * Tests if this container is empty.\n         *\n         * @return <code>true</code> if empty, otherwise <code>false</code>.\n         */\n        public boolean isEmpty();\n\n        /**\n         * Adds the specified object to this container.\n         *\n         * @param o the object to be added.\n         */\n        public void add(T o);\n\n        /**\n         * Remove an object from this container and return it.\n         *\n         * @return the object removed from this container.\n         */\n        public T remove();\n    }\n\n    /**\n     * Provides unified interface for operations that are different in directed\n     * graphs and in undirected graphs.\n     */\n    abstract static class Specifics<VV, EE>\n    {\n        /**\n         * Returns the edges outgoing from the specified vertex in case of\n         * directed graph, and the edge touching the specified vertex in case of\n         * undirected graph.\n         *\n         * @param vertex the vertex whose outgoing edges are to be returned.\n         *\n         * @return the edges outgoing from the specified vertex in case of\n         * directed graph, and the edge touching the specified vertex in case of\n         * undirected graph.\n         */\n        public abstract Set<? extends EE> edgesOf(VV vertex);\n    }\n\n    /**\n     * A reusable edge event.\n     *\n     * @author Barak Naveh\n     * @since Aug 11, 2003\n     */\n    static class FlyweightEdgeEvent<VV, localE>\n        extends EdgeTraversalEvent<VV, localE>\n    {\n        private static final long serialVersionUID = 4051327833765000755L;\n\n        /**\n         * @see EdgeTraversalEvent#EdgeTraversalEvent(Object, Edge)\n         */\n        public FlyweightEdgeEvent(Object eventSource, localE edge)\n        {\n            super(eventSource, edge);\n        }\n\n        /**\n         * Sets the edge of this event.\n         *\n         * @param edge the edge to be set.\n         */\n        protected void setEdge(localE edge)\n        {\n            this.edge = edge;\n        }\n    }\n\n    /**\n     * A reusable vertex event.\n     *\n     * @author Barak Naveh\n     * @since Aug 11, 2003\n     */\n    static class FlyweightVertexEvent<VV>\n        extends VertexTraversalEvent<VV>\n    {\n        private static final long serialVersionUID = 3834024753848399924L;\n\n        /**\n         * @see VertexTraversalEvent#VertexTraversalEvent(Object, Object)\n         */\n        public FlyweightVertexEvent(Object eventSource, VV vertex)\n        {\n            super(eventSource, vertex);\n        }\n\n        /**\n         * Sets the vertex of this event.\n         *\n         * @param vertex the vertex to be set.\n         */\n        protected void setVertex(VV vertex)\n        {\n            this.vertex = vertex;\n        }\n    }\n\n    /**\n     * An implementation of {@link Specifics} for a directed graph.\n     */\n    private static class DirectedSpecifics<VV, EE>\n        extends Specifics<VV, EE>\n    {\n        private DirectedGraph<VV, EE> graph;\n\n        /**\n         * Creates a new DirectedSpecifics object.\n         *\n         * @param g the graph for which this specifics object to be created.\n         */\n        public DirectedSpecifics(DirectedGraph<VV, EE> g)\n        {\n            graph = g;\n        }\n\n        /**\n         * @see CrossComponentIterator.Specifics#edgesOf(Object)\n         */\n        @Override public Set<? extends EE> edgesOf(VV vertex)\n        {\n            return graph.outgoingEdgesOf(vertex);\n        }\n    }\n\n    /**\n     * An implementation of {@link Specifics} in which edge direction (if any)\n     * is ignored.\n     */\n    private static class UndirectedSpecifics<VV, EE>\n        extends Specifics<VV, EE>\n    {\n        private Graph<VV, EE> graph;\n\n        /**\n         * Creates a new UndirectedSpecifics object.\n         *\n         * @param g the graph for which this specifics object to be created.\n         */\n        public UndirectedSpecifics(Graph<VV, EE> g)\n        {\n            graph = g;\n        }\n\n        /**\n         * @see CrossComponentIterator.Specifics#edgesOf(Object)\n         */\n        @Override public Set<EE> edgesOf(VV vertex)\n        {\n            return graph.edgesOf(vertex);\n        }\n    }\n}\n\n// End CrossComponentIterator.java\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "PartiteRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "RandomGraphHelper",
                "org.jgrapht.experimental"
            ],
            [
                "GraphReader",
                "org.jgrapht.experimental"
            ],
            [
                "DirectedAcyclicGraph",
                "org.jgrapht.experimental.dag"
            ],
            [
                "GraphSquare",
                "org.jgrapht.experimental"
            ],
            [
                "UniformRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "GraphTests",
                "org.jgrapht.experimental"
            ],
            [
                "ApproximationAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "BrownBacktrackColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "GreedyColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "IntArrayGraphAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ExactAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ListenableGraph",
                "org.jgrapht"
            ],
            [
                "ModifiableInteger",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeapNode",
                "org.jgrapht.util"
            ],
            [
                "WeightCombiner",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeap",
                "org.jgrapht.util"
            ],
            [
                "TypeUtil",
                "org.jgrapht.util"
            ],
            [
                "ArrayUnenforcedSet",
                "org.jgrapht.util"
            ],
            [
                "VertexPair",
                "org.jgrapht.util"
            ],
            [
                "MathUtil",
                "org.jgrapht.util"
            ],
            [
                "PrefetchIterator",
                "org.jgrapht.util"
            ],
            [
                "VertexFactory",
                "org.jgrapht"
            ],
            [
                "Graph",
                "org.jgrapht"
            ],
            [
                "GraphPath",
                "org.jgrapht"
            ],
            [
                "UndirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraph",
                "org.jgrapht.graph"
            ],
            [
                "MixedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DefaultGraphMapping",
                "org.jgrapht.graph"
            ],
            [
                "WeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskEdgeSet",
                "org.jgrapht.graph"
            ],
            [
                "Pseudograph",
                "org.jgrapht.graph"
            ],
            [
                "MaskFunctor",
                "org.jgrapht.graph"
            ],
            [
                "GraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractBaseGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "Multigraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultWeightedEdge",
                "org.jgrapht.graph"
            ],
            [
                "ListenableDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeSetFactory",
                "org.jgrapht.graph"
            ],
            [
                "GraphDelegator",
                "org.jgrapht.graph"
            ],
            [
                "DefaultListenableGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedVertexFactory",
                "org.jgrapht.graph"
            ],
            [
                "DefaultEdge",
                "org.jgrapht.graph"
            ],
            [
                "MaskVertexSet",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "IntrusiveEdge",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphPathImpl",
                "org.jgrapht.graph"
            ],
            [
                "Subgraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractGraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedEdgeFactory",
                "org.jgrapht.graph"
            ],
            [
                "SimpleWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "WeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeReversedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "AbstractGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "ListenableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraphPath",
                "org.jgrapht.graph"
            ],
            [
                "ParanoidGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphHelper",
                "org.jgrapht"
            ],
            [
                "Graphs",
                "org.jgrapht"
            ],
            [
                "DirectedGraph",
                "org.jgrapht"
            ],
            [
                "WeightedGraph",
                "org.jgrapht"
            ],
            [
                "HyperCubeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RingGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WheelGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GridGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "ScaleFreeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedBipartiteGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "LinearGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RandomGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGeneratorAdapter",
                "org.jgrapht.generate"
            ],
            [
                "EmptyGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteBipartiteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "StarGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "UndirectedGraph",
                "org.jgrapht"
            ],
            [
                "TopologicalOrderIterator",
                "org.jgrapht.traverse"
            ],
            [
                "CrossComponentIterator",
                "org.jgrapht.traverse"
            ],
            [
                "AbstractGraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "ClosestFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "BreadthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "DepthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "GraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "EdgeFactory",
                "org.jgrapht"
            ],
            [
                "GraphMapping",
                "org.jgrapht"
            ],
            [
                "VertexSetListener",
                "org.jgrapht.event"
            ],
            [
                "EdgeTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "TraversalListener",
                "org.jgrapht.event"
            ],
            [
                "GraphEdgeChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "VertexTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphListener",
                "org.jgrapht.event"
            ],
            [
                "TraversalListenerAdapter",
                "org.jgrapht.event"
            ],
            [
                "ConnectedComponentTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphVertexChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "TarjanLowestCommonAncestor",
                "org.jgrapht.alg"
            ],
            [
                "PrimMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "BlockCutpointGraph",
                "org.jgrapht.alg"
            ],
            [
                "AllDirectedPaths",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPathsIterator",
                "org.jgrapht.alg"
            ],
            [
                "KruskalMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "StrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "VF2State",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2AbstractIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "GraphOrdering",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphicGraphMapping",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2MappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "BronKerboschCliqueFinder",
                "org.jgrapht.alg"
            ],
            [
                "ChromaticNumber",
                "org.jgrapht.alg"
            ],
            [
                "KosarajuStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "DijkstraShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElement",
                "org.jgrapht.alg"
            ],
            [
                "AStarShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordPathElement",
                "org.jgrapht.alg"
            ],
            [
                "FloydWarshallShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "UnionFind",
                "org.jgrapht.alg.util"
            ],
            [
                "AlwaysEqualComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Extension",
                "org.jgrapht.alg.util"
            ],
            [
                "VertexDegreeComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Pair",
                "org.jgrapht.alg.util"
            ],
            [
                "GabowStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "HawickJamesSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "DirectedSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "JohnsonSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TiernanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "UndirectedCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "PatonCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TarjanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "SzwarcfiterLauerSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "BiconnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "ConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "MinSourceSinkCut",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsBlossomShrinking",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveClosure",
                "org.jgrapht.alg"
            ],
            [
                "HopcroftKarpBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "StoerWagnerMinimumCut",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "KuhnMunkresMinimalWeightBipartitePerfectMatching",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveReduction",
                "org.jgrapht.alg"
            ],
            [
                "EulerianCircuit",
                "org.jgrapht.alg"
            ],
            [
                "DirectedNeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "NaiveLcaFinder",
                "org.jgrapht.alg"
            ],
            [
                "MaximumWeightBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "HamiltonianCycle",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "NeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "VertexCovers",
                "org.jgrapht.alg"
            ],
            [
                "CycleDetector",
                "org.jgrapht.alg"
            ],
            [
                "AStarAdmissibleHeuristic",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MinimumSpanningTree",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "WeightedMatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "StrongConnectivityAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MaximumFlowAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "CliqueMinimalSeparatorDecomposition",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordIterator",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElement",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "PushRelabelMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "MaximumFlowAlgorithmBase",
                "org.jgrapht.alg.flow"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "addVertices",
                "org.jgrapht.experimental",
                "RandomGraphHelper",
                "/**\n * .\n *\n * @param target\n * @param vertexFactory\n * @param numVertices\n *\n * @return vertices\n */\n@SuppressWarnings(\"unchecked\")\npublic static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices) {\n    Object[] vertices = new Object[numVertices];\n    for (int i = 0; i < numVertices; ++i) {\n        vertices[i] = vertexFactory.createVertex();\n        target.addVertex(vertices[i]);\n    }\n    return vertices;\n}"
            ],
            [
                "isEmpty",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isEmpty(Graph<V, E> g) {\n    return g.edgeSet().isEmpty();\n}"
            ],
            [
                "isComplete",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isComplete(Graph<V, E> g) {\n    int n = g.vertexSet().size();\n    return g.edgeSet().size() == (n * (n - 1) / 2);\n}"
            ],
            [
                "isConnected",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isConnected(Graph<V, E> g) {\n    int numVertices = g.vertexSet().size();\n    int numEdges = g.edgeSet().size();\n    if (numEdges < (numVertices - 1)) {\n        return false;\n    }\n    if ((numVertices < 2) || (numEdges > ((numVertices - 1) * (numVertices - 2) / 2))) {\n        return true;\n    }\n    Set<V> known = new HashSet<V>();\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = g.vertexSet().iterator().next();\n    // start with node 1\n    queue.add(v);\n    known.add(v);\n    while (!queue.isEmpty()) {\n        v = queue.removeFirst();\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            v = it.next();\n            if (!known.contains(v)) {\n                known.add(v);\n                queue.add(v);\n            }\n        }\n    }\n    return known.size() == numVertices;\n}"
            ],
            [
                "isTree",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isTree(Graph<V, E> g) {\n    return isConnected(g) && (g.edgeSet().size() == (g.vertexSet().size() - 1));\n}"
            ],
            [
                "isBipartite",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isBipartite(Graph<V, E> g) {\n    if ((4 * g.edgeSet().size()) > (g.vertexSet().size() * g.vertexSet().size())) {\n        return false;\n    }\n    if (isEmpty(g)) {\n        return true;\n    }\n    Set<V> unknown = new HashSet<V>(g.vertexSet());\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = unknown.iterator().next();\n    Set<V> odd = new HashSet<V>();\n    queue.add(v);\n    while (!unknown.isEmpty()) {\n        if (queue.isEmpty()) {\n            queue.add(unknown.iterator().next());\n        }\n        v = queue.removeFirst();\n        unknown.remove(v);\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            V n = it.next();\n            if (unknown.contains(n)) {\n                queue.add(n);\n                if (!odd.contains(v)) {\n                    odd.add(n);\n                }\n            } else if (!(odd.contains(v) ^ odd.contains(n))) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
            ],
            [
                "union",
                "org.jgrapht.util",
                "FibonacciHeap",
                "// size\n/**\n * Joins two Fibonacci heaps into a new one. No heap consolidation is\n * performed at this time. The two root lists are simply joined together.\n *\n * <p>Running time: O(1) actual</p>\n *\n * @param h1 first heap\n * @param h2 second heap\n *\n * @return new heap containing h1 and h2\n */\npublic static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2) {\n    FibonacciHeap<T> h = new FibonacciHeap<T>();\n    if ((h1 != null) && (h2 != null)) {\n        h.minNode = h1.minNode;\n        if (h.minNode != null) {\n            if (h2.minNode != null) {\n                h.minNode.right.left = h2.minNode.left;\n                h2.minNode.left.right = h.minNode.right;\n                h.minNode.right = h2.minNode;\n                h2.minNode.left = h.minNode;\n                if (h2.minNode.key < h1.minNode.key) {\n                    h.minNode = h2.minNode;\n                }\n            }\n        } else {\n            h.minNode = h2.minNode;\n        }\n        h.nNodes = h1.nNodes + h2.nNodes;\n    }\n    return h;\n}"
            ],
            [
                "uncheckedCast",
                "org.jgrapht.util",
                "TypeUtil",
                "/**\n * Casts an object to a type.\n *\n * @param o object to be cast\n * @param typeDecl conveys the target type information; the actual value is\n * unused and can be null since this is all just stupid compiler tricks\n *\n * @return the result of the cast\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl) {\n    return (T) o;\n}"
            ],
            [
                "factorial",
                "org.jgrapht.util",
                "MathUtil",
                "public static long factorial(int N) {\n    long multi = 1;\n    for (int i = 1; i <= N; i++) {\n        multi = multi * i;\n    }\n    return multi;\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graphs",
                "/**\n * Creates a new edge and adds it to the specified graph similarly to the\n * {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n *\n * @see Graph#addEdge(Object, Object)\n */\npublic static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    EdgeFactory<V, E> ef = g.getEdgeFactory();\n    E e = ef.createEdge(sourceVertex, targetVertex);\n    // we first create the edge and set the weight to make sure that\n    // listeners will see the correct weight upon addEdge.\n    assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n    ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n    return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new edge and adds it to the specified\n * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return g.addEdge(sourceVertex, targetVertex);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified edge to the graph, including its vertices if not\n * already included.\n *\n * @param targetGraph the graph for which the specified edge to be added.\n * @param sourceGraph the graph in which the specified edge is already\n * present\n * @param edge edge to add\n *\n * @return <tt>true</tt> if the target graph did not already contain the\n * specified edge.\n */\npublic static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge) {\n    V sourceVertex = sourceGraph.getEdgeSource(edge);\n    V targetVertex = sourceGraph.getEdgeTarget(edge);\n    targetGraph.addVertex(sourceVertex);\n    targetGraph.addVertex(targetVertex);\n    return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new weighted edge and adds it to the\n * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n * method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return addEdge(g, sourceVertex, targetVertex, weight);\n}"
            ],
            [
                "addGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all the vertices and all the edges of the specified source graph to\n * the specified destination graph. First all vertices of the source graph\n * are added to the destination graph. Then every edge of the source graph\n * is added to the destination graph. This method returns <code>true</code>\n * if the destination graph has been modified as a result of this operation,\n * otherwise it returns <code>false</code>.\n *\n * <p>The behavior of this operation is undefined if any of the specified\n * graphs is modified while operation is in progress.</p>\n *\n * @param destination the graph to which vertices and edges are added.\n * @param source the graph used as source for vertices and edges to add.\n *\n * @return <code>true</code> if and only if the destination graph has been\n * changed as a result of this operation.\n */\npublic static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source) {\n    boolean modified = addAllVertices(destination, source.vertexSet());\n    modified |= addAllEdges(destination, source, source.edgeSet());\n    return modified;\n}"
            ],
            [
                "addAllEdges",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds a subset of the edges of the specified source graph to the specified\n * destination graph. The behavior of this operation is undefined if either\n * of the graphs is modified while the operation is in progress. {@link\n * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n * be added automatically to the target graph.\n *\n * @param destination the graph to which edges are to be added\n * @param source the graph used as a source for edges to add\n * @param edges the edges to be added\n *\n * @return <tt>true</tt> if this graph changed as a result of the call\n */\npublic static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges) {\n    boolean modified = false;\n    for (E e : edges) {\n        V s = source.getEdgeSource(e);\n        V t = source.getEdgeTarget(e);\n        destination.addVertex(s);\n        destination.addVertex(t);\n        modified |= destination.addEdge(s, t, e);\n    }\n    return modified;\n}"
            ],
            [
                "addAllVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all of the specified vertices to the destination graph. The behavior\n * of this operation is undefined if the specified vertex collection is\n * modified while the operation is in progress. This method will invoke the\n * {@link Graph#addVertex(Object)} method.\n *\n * @param destination the graph to which edges are to be added\n * @param vertices the vertices to be added to the graph.\n *\n * @return <tt>true</tt> if graph changed as a result of the call\n *\n * @throws NullPointerException if the specified vertices contains one or\n * more null vertices, or if the specified vertex collection is <tt>\n * null</tt>.\n *\n * @see Graph#addVertex(Object)\n */\npublic static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices) {\n    boolean modified = false;\n    for (V v : vertices) {\n        modified |= destination.addVertex(v);\n    }\n    return modified;\n}"
            ],
            [
                "neighborListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the neighbors of a specified vertex.\n * If the graph is a multigraph vertices may appear more than once in the\n * returned list.\n *\n * @param g the graph to look for neighbors in.\n * @param vertex the vertex to get the neighbors of.\n *\n * @return a list of the vertices that are the neighbors of the specified\n * vertex.\n */\npublic static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex) {\n    List<V> neighbors = new ArrayList<V>();\n    for (E e : g.edgesOf(vertex)) {\n        neighbors.add(getOppositeVertex(g, e, vertex));\n    }\n    return neighbors;\n}"
            ],
            [
                "predecessorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct predecessors of a\n * specified vertex. If the graph is a multigraph, vertices may appear more\n * than once in the returned list.\n *\n * @param g the graph to look for predecessors in.\n * @param vertex the vertex to get the predecessors of.\n *\n * @return a list of the vertices that are the direct predecessors of the\n * specified vertex.\n */\npublic static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> predecessors = new ArrayList<V>();\n    Set<? extends E> edges = g.incomingEdgesOf(vertex);\n    for (E e : edges) {\n        predecessors.add(getOppositeVertex(g, e, vertex));\n    }\n    return predecessors;\n}"
            ],
            [
                "successorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct successors of a specified\n * vertex. If the graph is a multigraph vertices may appear more than once\n * in the returned list.\n *\n * @param g the graph to look for successors in.\n * @param vertex the vertex to get the successors of.\n *\n * @return a list of the vertices that are the direct successors of the\n * specified vertex.\n */\npublic static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> successors = new ArrayList<V>();\n    Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n    for (E e : edges) {\n        successors.add(getOppositeVertex(g, e, vertex));\n    }\n    return successors;\n}"
            ],
            [
                "undirectedGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns an undirected view of the specified graph. If the specified graph\n * is directed, returns an undirected view of it. If the specified graph is\n * already undirected, just returns it.\n *\n * @param g the graph for which an undirected view is to be returned.\n *\n * @return an undirected view of the specified graph, if it is directed, or\n * or the specified graph itself if it is already undirected.\n *\n * @throws IllegalArgumentException if the graph is neither DirectedGraph\n * nor UndirectedGraph.\n *\n * @see AsUndirectedGraph\n */\npublic static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n    } else if (g instanceof UndirectedGraph<?, ?>) {\n        return (UndirectedGraph<V, E>) g;\n    } else {\n        throw new IllegalArgumentException(\"Graph must be either DirectedGraph or UndirectedGraph\");\n    }\n}"
            ],
            [
                "testIncidence",
                "org.jgrapht",
                "Graphs",
                "/**\n * Tests whether an edge is incident to a vertex.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return true iff e is incident on v\n */\npublic static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v) {\n    return (g.getEdgeSource(e).equals(v)) || (g.getEdgeTarget(e).equals(v));\n}"
            ],
            [
                "getOppositeVertex",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the vertex opposite another vertex across an edge.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return vertex opposite to v across e\n */\npublic static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v) {\n    V source = g.getEdgeSource(e);\n    V target = g.getEdgeTarget(e);\n    if (v.equals(source)) {\n        return target;\n    } else if (v.equals(target)) {\n        return source;\n    } else {\n        throw new IllegalArgumentException(\"no such vertex: \" + v.toString());\n    }\n}"
            ],
            [
                "getPathVertexList",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the list of vertices visited by a path.\n *\n * @param path path of interest\n *\n * @return corresponding vertex list\n */\npublic static <V, E> List<V> getPathVertexList(GraphPath<V, E> path) {\n    Graph<V, E> g = path.getGraph();\n    List<V> list = new ArrayList<V>();\n    V v = path.getStartVertex();\n    list.add(v);\n    for (E e : path.getEdgeList()) {\n        v = getOppositeVertex(g, e, v);\n        list.add(v);\n    }\n    return list;\n}"
            ],
            [
                "range",
                "org.jgrapht.generate",
                "SimpleWeightedGraphMatrixGenerator",
                "///////////////////////////////////////////////////////////////////////////////////////////////\npublic static int[] range(final int from, final int to) {\n    int[] range = new int[to - from];\n    for (int i = from; i < to; ++i) {\n        range[i - from] = i;\n    }\n    return range;\n}"
            ],
            [
                "createGraphSpecifics",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "// -------------------------------------------------------------------------\n/**\n * @param <V>\n * @param <E>\n * @param g\n *\n * @return TODO Document me\n */\nstatic <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new DirectedSpecifics<V, E>((DirectedGraph<V, E>) g);\n    } else {\n        return new UndirectedSpecifics<V, E>(g);\n    }\n}"
            ],
            [
                "findGreedyChromaticNumber",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds the number of colors required for a greedy coloring of the graph.\n *\n * @param g an undirected graph to find the chromatic number of\n *\n * @return integer the approximate chromatic number from the greedy\n * algorithm\n */\npublic static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g) {\n    Map<Integer, Set<V>> coloredGroups = findGreedyColoredGroups(g);\n    return coloredGroups.keySet().size();\n}"
            ],
            [
                "findGreedyColoredGroups",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds a greedy coloring of the graph.\n *\n * @param g an undirected graph for which to find the coloring\n */\npublic static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g) {\n    // A copy of the graph is made, so that elements of the graph may be\n    // removed to carry out the algorithm\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // The Vertices will be sorted in decreasing order by degree, so that\n    // higher degree vertices have priority to be colored first\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    List<V> sortedVertices = new LinkedList<V>(sg.vertexSet());\n    Collections.sort(sortedVertices, comp);\n    Collections.reverse(sortedVertices);\n    int color;\n    // create a map which will hold color as key and Set<V> as value\n    Map<Integer, Set<V>> coloredGroups = new HashMap<Integer, Set<V>>();\n    // We'll attempt to color each vertex with a single color each\n    // iteration, and these vertices will be removed from the graph at the\n    // end of each iteration\n    for (color = 0; sg.vertexSet().size() > 0; color++) {\n        // This set will contain vertices that are colored with the\n        // current color of this iteration\n        Set<V> currentColor = new HashSet<V>();\n        for (Iterator<V> iter = sortedVertices.iterator(); iter.hasNext(); ) {\n            V v = iter.next();\n            // Add new vertices to be colored as long as they are not\n            // adjacent with any other vertex that has already been colored\n            // with the current color\n            boolean flag = true;\n            for (Iterator<V> innerIter = currentColor.iterator(); innerIter.hasNext(); ) {\n                V temp = innerIter.next();\n                if (sg.containsEdge(temp, v)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                currentColor.add(v);\n                iter.remove();\n            }\n        }\n        // Add all these vertices as a group for this color\n        coloredGroups.put(color, currentColor);\n        // Remove vertices from the graph and then repeat the process for\n        // the next iteration\n        sg.removeAllVertices(currentColor);\n    }\n    return coloredGroups;\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "BellmanFordShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by hops, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    BellmanFordShortestPath<V, E> alg = new BellmanFordShortestPath<V, E>(graph, startVertex);\n    return alg.getPathEdgeList(endVertex);\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "DijkstraShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by radius, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    DijkstraShortestPath<V, E> alg = new DijkstraShortestPath<V, E>(graph, startVertex, endVertex);\n    return alg.getPathEdgeList();\n}"
            ],
            [
                "of",
                "org.jgrapht.alg.util",
                "Pair",
                "/**\n * Creates new pair of elements pulling of the necessity to provide\n * corresponding types of the elements supplied\n *\n * @param a first element\n * @param b second element\n *\n * @return new pair\n */\npublic static <A, B> Pair<A, B> of(A a, B b) {\n    return new Pair<A, B>(a, b);\n}"
            ],
            [
                "isEulerian",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will check whether the graph passed in is Eulerian or not.\n *\n * @param g The graph to be checked\n *\n * @return true for Eulerian and false for non-Eulerian\n */\npublic static <V, E> boolean isEulerian(UndirectedGraph<V, E> g) {\n    // If the graph is not connected, then no Eulerian circuit exists\n    if (!(new ConnectivityInspector<V, E>(g)).isGraphConnected()) {\n        return false;\n    }\n    // A graph is Eulerian if and only if all vertices have even degree\n    // So, this code will check for that\n    Iterator<V> iter = g.vertexSet().iterator();\n    while (iter.hasNext()) {\n        V v = iter.next();\n        if ((g.degreeOf(v) % 2) == 1) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "getEulerianCircuitVertices",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will return a list of vertices which represents the Eulerian\n * circuit of the graph.\n *\n * @param g The graph to find an Eulerian circuit\n *\n * @return null if no Eulerian circuit exists, or a list of vertices\n * representing the Eulerian circuit if one does exist\n */\npublic static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g) {\n    // If the graph is not Eulerian then just return a null since no\n    // Eulerian circuit exists\n    if (!isEulerian(g)) {\n        return null;\n    }\n    // The circuit will be represented by a linked list\n    List<V> path = new LinkedList<V>();\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    path.add(sg.vertexSet().iterator().next());\n    // Algorithm for finding an Eulerian circuit Basically this will find an\n    // arbitrary circuit, then it will find another arbitrary circuit until\n    // every edge has been traversed\n    while (sg.edgeSet().size() > 0) {\n        V v = null;\n        // Find a vertex which has an edge that hasn't been traversed yet,\n        // and keep its index position in the circuit list\n        int index = 0;\n        for (Iterator<V> iter = path.iterator(); iter.hasNext(); index++) {\n            v = iter.next();\n            if (sg.degreeOf(v) > 0) {\n                break;\n            }\n        }\n        // Finds an arbitrary circuit of the current vertex and\n        // appends this into the circuit list\n        while (sg.degreeOf(v) > 0) {\n            for (Iterator<V> iter = sg.vertexSet().iterator(); iter.hasNext(); ) {\n                V temp = iter.next();\n                if (sg.containsEdge(v, temp)) {\n                    path.add(index, temp);\n                    sg.removeEdge(v, temp);\n                    v = temp;\n                    break;\n                }\n            }\n        }\n    }\n    return path;\n}"
            ],
            [
                "getApproximateOptimalForCompleteGraph",
                "org.jgrapht.alg",
                "HamiltonianCycle",
                "/**\n * This method will return an approximate minimal traveling salesman tour\n * (hamiltonian cycle). This algorithm requires that the graph be complete\n * and the triangle inequality exists (if x,y,z are vertices then\n * d(x,y)+d(y,z) &lt; d(x,z) for all x,y,z) then this algorithm will\n * guarantee a hamiltonian cycle such that the total weight of the cycle is\n * less than or equal to double the total weight of the optimal hamiltonian\n * cycle. The optimal solution is NP-complete, so this is a decent\n * approximation that runs in polynomial time.\n *\n * @param <V>\n * @param <E>\n * @param g is the graph to find the optimal tour for.\n *\n * @return The optimal tour as a list of vertices.\n */\npublic static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g) {\n    List<V> vertices = new LinkedList<V>(g.vertexSet());\n    // If the graph is not complete then return null since this algorithm\n    // requires the graph be complete\n    if ((vertices.size() * (vertices.size() - 1) / 2) != g.edgeSet().size()) {\n        return null;\n    }\n    List<V> tour = new LinkedList<V>();\n    // Each iteration a new vertex will be added to the tour until all\n    // vertices have been added\n    while (tour.size() != g.vertexSet().size()) {\n        boolean firstEdge = true;\n        double minEdgeValue = 0;\n        int minVertexFound = 0;\n        int vertexConnectedTo = 0;\n        // A check will be made for the shortest edge to a vertex not within\n        // the tour and that new vertex will be added to the vertex\n        for (int i = 0; i < tour.size(); i++) {\n            V v = tour.get(i);\n            for (int j = 0; j < vertices.size(); j++) {\n                double weight = g.getEdgeWeight(g.getEdge(v, vertices.get(j)));\n                if (firstEdge || (weight < minEdgeValue)) {\n                    firstEdge = false;\n                    minEdgeValue = weight;\n                    minVertexFound = j;\n                    vertexConnectedTo = i;\n                }\n            }\n        }\n        tour.add(vertexConnectedTo, vertices.get(minVertexFound));\n        vertices.remove(minVertexFound);\n    }\n    return tour;\n}"
            ],
            [
                "find2ApproximationCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a 2-approximation for a minimal vertex cover of the specified\n * graph. The algorithm promises a cover that is at most double the size of\n * a minimal cover. The algorithm takes O(|E|) time.\n *\n * <p>For more details see Jenny Walter, CMPU-240: Lecture notes for\n * Language Theory and Computation, Fall 2002, Vassar College, <a\n * href=\"http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf\">\n * http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf</a>.\n * </p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G'=(V',E') <-- G(V,E)\n    Subgraph<V, E, Graph<V, E>> sg = new Subgraph<V, E, Graph<V, E>>(g, null, null);\n    // while E' is non-empty\n    while (sg.edgeSet().size() > 0) {\n        // let (u,v) be an arbitrary edge of E'\n        E e = sg.edgeSet().iterator().next();\n        // C <-- C U {u,v}\n        V u = g.getEdgeSource(e);\n        V v = g.getEdgeTarget(e);\n        cover.add(u);\n        cover.add(v);\n        // remove from E' every edge incident on either u or v\n        sg.removeVertex(u);\n        sg.removeVertex(v);\n    }\n    // return C\n    return cover;\n}"
            ],
            [
                "findGreedyCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a greedy approximation for a minimal vertex cover of a specified\n * graph. At each iteration, the algorithm picks the vertex with the highest\n * degree and adds it to the cover, until all edges are covered.\n *\n * <p>The algorithm works on undirected graphs, but can also work on\n * directed graphs when their edge-directions are ignored. To ignore edge\n * directions you can use {@link org.jgrapht.Graphs#undirectedGraph(Graph)}\n * or {@link org.jgrapht.graph.AsUndirectedGraph}.</p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G' <-- G\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // compare vertices in descending order of degree\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    // while G' != {}\n    while (sg.edgeSet().size() > 0) {\n        // v <-- vertex with maximum degree in G'\n        V v = Collections.max(sg.vertexSet(), comp);\n        // C <-- C U {v}\n        cover.add(v);\n        // remove from G' every edge incident on v, and v itself\n        sg.removeVertex(v);\n    }\n    return cover;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "BEST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int BEST_ORDER = 0;"
            ],
            [
                "NATURAL_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int NATURAL_ORDER = 1;"
            ],
            [
                "SMALLEST_DEGREE_LAST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;"
            ],
            [
                "LARGEST_SATURATION_FIRST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;"
            ],
            [
                "DEFAULT_EDGE_WEIGHT",
                "org.jgrapht",
                "WeightedGraph",
                "/**\n * The default weight for an edge.\n */\npublic static double DEFAULT_EDGE_WEIGHT = 1.0;"
            ],
            [
                "HUB_VERTEX",
                "org.jgrapht.generate",
                "WheelGraphGenerator",
                "/**\n * Role for the hub vertex.\n */\npublic static final String HUB_VERTEX = \"Hub Vertex\";"
            ],
            [
                "CORNER_VERTEX",
                "org.jgrapht.generate",
                "GridGraphGenerator",
                "/**\n * Role for the vertices at the corners.\n */\npublic static final String CORNER_VERTEX = \"Corner Vertex\";"
            ],
            [
                "START_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the first vertex generated.\n */\npublic static final String START_VERTEX = \"Start Vertex\";"
            ],
            [
                "END_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the last vertex generated.\n */\npublic static final String END_VERTEX = \"End Vertex\";"
            ],
            [
                "CENTER_VERTEX",
                "org.jgrapht.generate",
                "StarGraphGenerator",
                "public static final String CENTER_VERTEX = \"Center Vertex\";"
            ],
            [
                "SENTINEL",
                "org.jgrapht.traverse",
                "DepthFirstIterator",
                "/**\n * Sentinel object. Unfortunately, we can't use null, because ArrayDeque\n * won't accept those. And we don't want to rely on the caller to provide a\n * sentinel object for us. So we have to play typecasting games.\n */\npublic static final Object SENTINEL = new Object();"
            ],
            [
                "BEFORE_EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge added event. This event is fired before an edge is added to a\n * graph.\n */\npublic static final int BEFORE_EDGE_ADDED = 21;"
            ],
            [
                "BEFORE_EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge removed event. This event is fired before an edge is removed\n * from a graph.\n */\npublic static final int BEFORE_EDGE_REMOVED = 22;"
            ],
            [
                "EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge added event. This event is fired after an edge is added to a graph.\n */\npublic static final int EDGE_ADDED = 23;"
            ],
            [
                "EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge removed event. This event is fired after an edge is removed from a\n * graph.\n */\npublic static final int EDGE_REMOVED = 24;"
            ],
            [
                "CONNECTED_COMPONENT_STARTED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal started event.\n */\npublic static final int CONNECTED_COMPONENT_STARTED = 31;"
            ],
            [
                "CONNECTED_COMPONENT_FINISHED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal finished event.\n */\npublic static final int CONNECTED_COMPONENT_FINISHED = 32;"
            ],
            [
                "BEFORE_VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex added event. This event is fired before a vertex is added\n * to a graph.\n */\npublic static final int BEFORE_VERTEX_ADDED = 11;"
            ],
            [
                "BEFORE_VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex removed event. This event is fired before a vertex is\n * removed from a graph.\n */\npublic static final int BEFORE_VERTEX_REMOVED = 12;"
            ],
            [
                "VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex added event. This event is fired after a vertex is added to a\n * graph.\n */\npublic static final int VERTEX_ADDED = 13;"
            ],
            [
                "VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex removed event. This event is fired after a vertex is removed from\n * a graph.\n */\npublic static final int VERTEX_REMOVED = 14;"
            ],
            [
                "NULL_NODE",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "public static final int NULL_NODE = -1;"
            ],
            [
                "DEBUG",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected static final boolean DEBUG = false;"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg",
                "EdmondsKarpMaximumFlow",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 0.000000001;"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveClosure",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveClosure INSTANCE = new TransitiveClosure();"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveReduction",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveReduction INSTANCE = new TransitiveReduction();"
            ],
            [
                "NEGATIVE_UNDIRECTED_EDGE",
                "org.jgrapht.alg",
                "BellmanFordIterator",
                "/**\n * Error message.\n */\nprotected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg.flow",
                "MaximumFlowAlgorithmBase",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 1e-9;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [
            [
                "vertex",
                "",
                "V"
            ],
            [
                "edge",
                "",
                "E"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "isConnectedComponentExhausted",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "/**\n * Returns <tt>true</tt> if there are no more uniterated vertices in the\n * currently iterated connected component; <tt>false</tt> otherwise.\n *\n * @return <tt>true</tt> if there are no more uniterated vertices in the\n * currently iterated connected component; <tt>false</tt> otherwise.\n */\nprotected abstract boolean isConnectedComponentExhausted();"
            ],
            [
                "next",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "/**\n * @see java.util.Iterator#next()\n */\n@Override\npublic V next() {\n    if (startVertex != null) {\n        encounterStartVertex();\n    }\n    if (hasNext()) {\n        if (state == CCS_BEFORE_COMPONENT) {\n            state = CCS_WITHIN_COMPONENT;\n            if (nListeners != 0) {\n                fireConnectedComponentStarted(ccStartedEvent);\n            }\n        }\n        V nextVertex = provideNextVertex();\n        if (nListeners != 0) {\n            fireVertexTraversed(createVertexTraversalEvent(nextVertex));\n        }\n        addUnseenChildrenOf(nextVertex);\n        return nextVertex;\n    } else {\n        throw new NoSuchElementException();\n    }\n}"
            ],
            [
                "hasNext",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "/**\n * @see java.util.Iterator#hasNext()\n */\n@Override\npublic boolean hasNext() {\n    if (startVertex != null) {\n        encounterStartVertex();\n    }\n    if (isConnectedComponentExhausted()) {\n        if (state == CCS_WITHIN_COMPONENT) {\n            state = CCS_AFTER_COMPONENT;\n            if (nListeners != 0) {\n                fireConnectedComponentFinished(ccFinishedEvent);\n            }\n        }\n        if (isCrossComponentTraversal()) {\n            while (vertexIterator.hasNext()) {\n                V v = vertexIterator.next();\n                if (!isSeenVertex(v)) {\n                    encounterVertex(v, null);\n                    state = CCS_BEFORE_COMPONENT;\n                    return true;\n                }\n            }\n            return false;\n        } else {\n            return false;\n        }\n    } else {\n        return true;\n    }\n}"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "getGraph",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "/**\n * @return the graph being traversed\n */\npublic Graph<V, E> getGraph() {\n    return graph;\n}"
            ],
            [
                "next",
                "java.util",
                "Iterator",
                "public abstract E next()"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "isSeenVertex",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "/**\n * Determines whether a vertex has been seen yet by this traversal.\n *\n * @param vertex vertex in question\n *\n * @return <tt>true</tt> if vertex has already been seen\n */\nprotected boolean isSeenVertex(Object vertex) {\n    return seen.containsKey(vertex);\n}"
            ],
            [
                "putSeenData",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "/**\n * Stores iterator-dependent data for a vertex that has been seen.\n *\n * @param vertex a vertex which has been seen.\n * @param data data to be associated with the seen vertex.\n *\n * @return previous value associated with specified vertex or <code>\n * null</code> if no data was associated with the vertex. A <code>\n * null</code> return can also indicate that the vertex was explicitly\n * associated with <code>null</code>.\n */\nprotected D putSeenData(V vertex, D data) {\n    return seen.put(vertex, data);\n}"
            ],
            [
                "isCrossComponentTraversal",
                "org.jgrapht.traverse",
                "AbstractGraphIterator",
                "public boolean isCrossComponentTraversal()"
            ],
            [
                "provideNextVertex",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "/**\n * Returns the vertex to be returned in the following call to the iterator\n * <code>next</code> method.\n *\n * @return the next vertex to be returned by this iterator.\n */\nprotected abstract V provideNextVertex();"
            ],
            [
                "isReuseEvents",
                "org.jgrapht.traverse",
                "AbstractGraphIterator",
                "public boolean isReuseEvents()"
            ],
            [
                "getSeenData",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "/**\n * Access the data stored for a seen vertex.\n *\n * @param vertex a vertex which has already been seen.\n *\n * @return data associated with the seen vertex or <code>null</code> if no\n * data was associated with the vertex. A <code>null</code> return can also\n * indicate that the vertex was explicitly associated with <code>\n * null</code>.\n */\nprotected D getSeenData(V vertex) {\n    return seen.get(vertex);\n}"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [
            [
                "nListeners",
                "org.jgrapht.traverse",
                "AbstractGraphIterator",
                "protected int nListeners;"
            ]
        ],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 26164,
        "oracle": ";",
        "oracleType": "PRE",
        "projectName": "jgrapht-core-0.9.2",
        "packageName": "org.jgrapht.traverse",
        "className": "CrossComponentIterator",
        "javadocTag": "@param vertex vertex in question",
        "methodJavadoc": "    /**\n     * Determines whether a vertex has been seen yet by this traversal.\n     *\n     * @param vertex vertex in question\n     *\n     * @return <tt>true</tt> if vertex has already been seen\n     */",
        "methodSourceCode": "protected boolean isSeenVertex(Object vertex){\n    return seen.containsKey(vertex);\n}",
        "classJavadoc": "/**\n * Provides a cross-connected-component traversal functionality for iterator\n * subclasses.\n *\n * @param <V> vertex type\n * @param <E> edge type\n * @param <D> type of data associated to seen vertices\n *\n * @author Barak Naveh\n * @since Jan 31, 2004\n */",
        "classSourceCode": "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ---------------------------\n * CrossComponentIterator.java\n * ---------------------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   John V. Sichi\n *                   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 31-Jul-2003 : Initial revision (BN);\n * 11-Aug-2003 : Adaptation to new event model (BN);\n * 31-Jan-2004 : Extracted cross-component traversal functionality (BN);\n * 04-May-2004 : Made generic (CH)\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n *\n */\npackage org.jgrapht.traverse;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\nimport org.jgrapht.event.*;\n\n\n/**\n * Provides a cross-connected-component traversal functionality for iterator\n * subclasses.\n *\n * @param <V> vertex type\n * @param <E> edge type\n * @param <D> type of data associated to seen vertices\n *\n * @author Barak Naveh\n * @since Jan 31, 2004\n */\npublic abstract class CrossComponentIterator<V, E, D>\n    extends AbstractGraphIterator<V, E>\n{\n    private static final int CCS_BEFORE_COMPONENT = 1;\n    private static final int CCS_WITHIN_COMPONENT = 2;\n    private static final int CCS_AFTER_COMPONENT = 3;\n\n    /**\n     * Standard vertex visit state enumeration.\n     */\n    protected static enum VisitColor\n    {\n        /**\n         * Vertex has not been returned via iterator yet.\n         */\n        WHITE,\n\n        /**\n         * Vertex has been returned via iterator, but we're not done with all of\n         * its out-edges yet.\n         */\n        GRAY,\n\n        /**\n         * Vertex has been returned via iterator, and we're done with all of its\n         * out-edges.\n         */\n        BLACK\n    }\n\n    //\n    private final ConnectedComponentTraversalEvent ccFinishedEvent =\n        new ConnectedComponentTraversalEvent(\n            this,\n            ConnectedComponentTraversalEvent.CONNECTED_COMPONENT_FINISHED);\n    private final ConnectedComponentTraversalEvent ccStartedEvent =\n        new ConnectedComponentTraversalEvent(\n            this,\n            ConnectedComponentTraversalEvent.CONNECTED_COMPONENT_STARTED);\n\n    // TODO: support ConcurrentModificationException if graph modified\n    // during iteration.\n    private FlyweightEdgeEvent<V, E> reusableEdgeEvent;\n    private FlyweightVertexEvent<V> reusableVertexEvent;\n    private Iterator<V> vertexIterator = null;\n\n    /**\n     * Stores the vertices that have been seen during iteration and (optionally)\n     * some additional traversal info regarding each vertex.\n     */\n    private Map<V, D> seen = new HashMap<V, D>();\n    private V startVertex;\n    private Specifics<V, E> specifics;\n\n    private final Graph<V, E> graph;\n\n    /**\n     * The connected component state\n     */\n    private int state = CCS_BEFORE_COMPONENT;\n\n    /**\n     * Creates a new iterator for the specified graph. Iteration will start at\n     * the specified start vertex. If the specified start vertex is <code>\n     * null</code>, Iteration will start at an arbitrary graph vertex.\n     *\n     * @param g the graph to be iterated.\n     * @param startVertex the vertex iteration to be started.\n     *\n     * @throws IllegalArgumentException if <code>g==null</code> or does not\n     * contain <code>startVertex</code>\n     */\n    public CrossComponentIterator(Graph<V, E> g, V startVertex)\n    {\n        super();\n\n        if (g == null) {\n            throw new IllegalArgumentException(\"graph must not be null\");\n        }\n        graph = g;\n\n        specifics = createGraphSpecifics(g);\n        vertexIterator = g.vertexSet().iterator();\n        setCrossComponentTraversal(startVertex == null);\n\n        reusableEdgeEvent = new FlyweightEdgeEvent<V, E>(this, null);\n        reusableVertexEvent = new FlyweightVertexEvent<V>(this, null);\n\n        if (startVertex == null) {\n            // pick a start vertex if graph not empty\n            if (vertexIterator.hasNext()) {\n                this.startVertex = vertexIterator.next();\n            } else {\n                this.startVertex = null;\n            }\n        } else if (g.containsVertex(startVertex)) {\n            this.startVertex = startVertex;\n        } else {\n            throw new IllegalArgumentException(\n                \"graph must contain the start vertex\");\n        }\n    }\n\n    /**\n     * @return the graph being traversed\n     */\n    public Graph<V, E> getGraph()\n    {\n        return graph;\n    }\n\n    /**\n     * @see java.util.Iterator#hasNext()\n     */\n    @Override public boolean hasNext()\n    {\n        if (startVertex != null) {\n            encounterStartVertex();\n        }\n\n        if (isConnectedComponentExhausted()) {\n            if (state == CCS_WITHIN_COMPONENT) {\n                state = CCS_AFTER_COMPONENT;\n                if (nListeners != 0) {\n                    fireConnectedComponentFinished(ccFinishedEvent);\n                }\n            }\n\n            if (isCrossComponentTraversal()) {\n                while (vertexIterator.hasNext()) {\n                    V v = vertexIterator.next();\n\n                    if (!isSeenVertex(v)) {\n                        encounterVertex(v, null);\n                        state = CCS_BEFORE_COMPONENT;\n\n                        return true;\n                    }\n                }\n\n                return false;\n            } else {\n                return false;\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @see java.util.Iterator#next()\n     */\n    @Override public V next()\n    {\n        if (startVertex != null) {\n            encounterStartVertex();\n        }\n\n        if (hasNext()) {\n            if (state == CCS_BEFORE_COMPONENT) {\n                state = CCS_WITHIN_COMPONENT;\n                if (nListeners != 0) {\n                    fireConnectedComponentStarted(ccStartedEvent);\n                }\n            }\n\n            V nextVertex = provideNextVertex();\n            if (nListeners != 0) {\n                fireVertexTraversed(createVertexTraversalEvent(nextVertex));\n            }\n\n            addUnseenChildrenOf(nextVertex);\n\n            return nextVertex;\n        } else {\n            throw new NoSuchElementException();\n        }\n    }\n\n    /**\n     * Returns <tt>true</tt> if there are no more uniterated vertices in the\n     * currently iterated connected component; <tt>false</tt> otherwise.\n     *\n     * @return <tt>true</tt> if there are no more uniterated vertices in the\n     * currently iterated connected component; <tt>false</tt> otherwise.\n     */\n    protected abstract boolean isConnectedComponentExhausted();\n\n    /**\n     * Update data structures the first time we see a vertex.\n     *\n     * @param vertex the vertex encountered\n     * @param edge the edge via which the vertex was encountered, or null if the\n     * vertex is a starting point\n     */\n    protected abstract void encounterVertex(V vertex, E edge);\n\n    /**\n     * Returns the vertex to be returned in the following call to the iterator\n     * <code>next</code> method.\n     *\n     * @return the next vertex to be returned by this iterator.\n     */\n    protected abstract V provideNextVertex();\n\n    /**\n     * Access the data stored for a seen vertex.\n     *\n     * @param vertex a vertex which has already been seen.\n     *\n     * @return data associated with the seen vertex or <code>null</code> if no\n     * data was associated with the vertex. A <code>null</code> return can also\n     * indicate that the vertex was explicitly associated with <code>\n     * null</code>.\n     */\n    protected D getSeenData(V vertex)\n    {\n        return seen.get(vertex);\n    }\n\n    /**\n     * Determines whether a vertex has been seen yet by this traversal.\n     *\n     * @param vertex vertex in question\n     *\n     * @return <tt>true</tt> if vertex has already been seen\n     */\n    protected boolean isSeenVertex(Object vertex)\n    {\n        return seen.containsKey(vertex);\n    }\n\n    /**\n     * Called whenever we re-encounter a vertex. The default implementation does\n     * nothing.\n     *\n     * @param vertex the vertex re-encountered\n     * @param edge the edge via which the vertex was re-encountered\n     */\n    protected abstract void encounterVertexAgain(V vertex, E edge);\n\n    /**\n     * Stores iterator-dependent data for a vertex that has been seen.\n     *\n     * @param vertex a vertex which has been seen.\n     * @param data data to be associated with the seen vertex.\n     *\n     * @return previous value associated with specified vertex or <code>\n     * null</code> if no data was associated with the vertex. A <code>\n     * null</code> return can also indicate that the vertex was explicitly\n     * associated with <code>null</code>.\n     */\n    protected D putSeenData(V vertex, D data)\n    {\n        return seen.put(vertex, data);\n    }\n\n    /**\n     * Called when a vertex has been finished (meaning is dependent on traversal\n     * represented by subclass).\n     *\n     * @param vertex vertex which has been finished\n     */\n    protected void finishVertex(V vertex)\n    {\n        if (nListeners != 0) {\n            fireVertexFinished(createVertexTraversalEvent(vertex));\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    /**\n     * @param <V>\n     * @param <E>\n     * @param g\n     *\n     * @return TODO Document me\n     */\n    static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new DirectedSpecifics<V, E>((DirectedGraph<V, E>) g);\n        } else {\n            return new UndirectedSpecifics<V, E>(g);\n        }\n    }\n\n    private void addUnseenChildrenOf(V vertex)\n    {\n        for (E edge : specifics.edgesOf(vertex)) {\n            if (nListeners != 0) {\n                fireEdgeTraversed(createEdgeTraversalEvent(edge));\n            }\n\n            V oppositeV = Graphs.getOppositeVertex(graph, edge, vertex);\n\n            if (isSeenVertex(oppositeV)) {\n                encounterVertexAgain(oppositeV, edge);\n            } else {\n                encounterVertex(oppositeV, edge);\n            }\n        }\n    }\n\n    private EdgeTraversalEvent<V, E> createEdgeTraversalEvent(E edge)\n    {\n        if (isReuseEvents()) {\n            reusableEdgeEvent.setEdge(edge);\n\n            return reusableEdgeEvent;\n        } else {\n            return new EdgeTraversalEvent<V, E>(this, edge);\n        }\n    }\n\n    private VertexTraversalEvent<V> createVertexTraversalEvent(V vertex)\n    {\n        if (isReuseEvents()) {\n            reusableVertexEvent.setVertex(vertex);\n\n            return reusableVertexEvent;\n        } else {\n            return new VertexTraversalEvent<V>(this, vertex);\n        }\n    }\n\n    private void encounterStartVertex()\n    {\n        encounterVertex(startVertex, null);\n        startVertex = null;\n    }\n\n    static interface SimpleContainer<T>\n    {\n        /**\n         * Tests if this container is empty.\n         *\n         * @return <code>true</code> if empty, otherwise <code>false</code>.\n         */\n        public boolean isEmpty();\n\n        /**\n         * Adds the specified object to this container.\n         *\n         * @param o the object to be added.\n         */\n        public void add(T o);\n\n        /**\n         * Remove an object from this container and return it.\n         *\n         * @return the object removed from this container.\n         */\n        public T remove();\n    }\n\n    /**\n     * Provides unified interface for operations that are different in directed\n     * graphs and in undirected graphs.\n     */\n    abstract static class Specifics<VV, EE>\n    {\n        /**\n         * Returns the edges outgoing from the specified vertex in case of\n         * directed graph, and the edge touching the specified vertex in case of\n         * undirected graph.\n         *\n         * @param vertex the vertex whose outgoing edges are to be returned.\n         *\n         * @return the edges outgoing from the specified vertex in case of\n         * directed graph, and the edge touching the specified vertex in case of\n         * undirected graph.\n         */\n        public abstract Set<? extends EE> edgesOf(VV vertex);\n    }\n\n    /**\n     * A reusable edge event.\n     *\n     * @author Barak Naveh\n     * @since Aug 11, 2003\n     */\n    static class FlyweightEdgeEvent<VV, localE>\n        extends EdgeTraversalEvent<VV, localE>\n    {\n        private static final long serialVersionUID = 4051327833765000755L;\n\n        /**\n         * @see EdgeTraversalEvent#EdgeTraversalEvent(Object, Edge)\n         */\n        public FlyweightEdgeEvent(Object eventSource, localE edge)\n        {\n            super(eventSource, edge);\n        }\n\n        /**\n         * Sets the edge of this event.\n         *\n         * @param edge the edge to be set.\n         */\n        protected void setEdge(localE edge)\n        {\n            this.edge = edge;\n        }\n    }\n\n    /**\n     * A reusable vertex event.\n     *\n     * @author Barak Naveh\n     * @since Aug 11, 2003\n     */\n    static class FlyweightVertexEvent<VV>\n        extends VertexTraversalEvent<VV>\n    {\n        private static final long serialVersionUID = 3834024753848399924L;\n\n        /**\n         * @see VertexTraversalEvent#VertexTraversalEvent(Object, Object)\n         */\n        public FlyweightVertexEvent(Object eventSource, VV vertex)\n        {\n            super(eventSource, vertex);\n        }\n\n        /**\n         * Sets the vertex of this event.\n         *\n         * @param vertex the vertex to be set.\n         */\n        protected void setVertex(VV vertex)\n        {\n            this.vertex = vertex;\n        }\n    }\n\n    /**\n     * An implementation of {@link Specifics} for a directed graph.\n     */\n    private static class DirectedSpecifics<VV, EE>\n        extends Specifics<VV, EE>\n    {\n        private DirectedGraph<VV, EE> graph;\n\n        /**\n         * Creates a new DirectedSpecifics object.\n         *\n         * @param g the graph for which this specifics object to be created.\n         */\n        public DirectedSpecifics(DirectedGraph<VV, EE> g)\n        {\n            graph = g;\n        }\n\n        /**\n         * @see CrossComponentIterator.Specifics#edgesOf(Object)\n         */\n        @Override public Set<? extends EE> edgesOf(VV vertex)\n        {\n            return graph.outgoingEdgesOf(vertex);\n        }\n    }\n\n    /**\n     * An implementation of {@link Specifics} in which edge direction (if any)\n     * is ignored.\n     */\n    private static class UndirectedSpecifics<VV, EE>\n        extends Specifics<VV, EE>\n    {\n        private Graph<VV, EE> graph;\n\n        /**\n         * Creates a new UndirectedSpecifics object.\n         *\n         * @param g the graph for which this specifics object to be created.\n         */\n        public UndirectedSpecifics(Graph<VV, EE> g)\n        {\n            graph = g;\n        }\n\n        /**\n         * @see CrossComponentIterator.Specifics#edgesOf(Object)\n         */\n        @Override public Set<EE> edgesOf(VV vertex)\n        {\n            return graph.edgesOf(vertex);\n        }\n    }\n}\n\n// End CrossComponentIterator.java\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "PartiteRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "RandomGraphHelper",
                "org.jgrapht.experimental"
            ],
            [
                "GraphReader",
                "org.jgrapht.experimental"
            ],
            [
                "DirectedAcyclicGraph",
                "org.jgrapht.experimental.dag"
            ],
            [
                "GraphSquare",
                "org.jgrapht.experimental"
            ],
            [
                "UniformRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "GraphTests",
                "org.jgrapht.experimental"
            ],
            [
                "ApproximationAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "BrownBacktrackColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "GreedyColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "IntArrayGraphAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ExactAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ListenableGraph",
                "org.jgrapht"
            ],
            [
                "ModifiableInteger",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeapNode",
                "org.jgrapht.util"
            ],
            [
                "WeightCombiner",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeap",
                "org.jgrapht.util"
            ],
            [
                "TypeUtil",
                "org.jgrapht.util"
            ],
            [
                "ArrayUnenforcedSet",
                "org.jgrapht.util"
            ],
            [
                "VertexPair",
                "org.jgrapht.util"
            ],
            [
                "MathUtil",
                "org.jgrapht.util"
            ],
            [
                "PrefetchIterator",
                "org.jgrapht.util"
            ],
            [
                "VertexFactory",
                "org.jgrapht"
            ],
            [
                "Graph",
                "org.jgrapht"
            ],
            [
                "GraphPath",
                "org.jgrapht"
            ],
            [
                "UndirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraph",
                "org.jgrapht.graph"
            ],
            [
                "MixedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DefaultGraphMapping",
                "org.jgrapht.graph"
            ],
            [
                "WeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskEdgeSet",
                "org.jgrapht.graph"
            ],
            [
                "Pseudograph",
                "org.jgrapht.graph"
            ],
            [
                "MaskFunctor",
                "org.jgrapht.graph"
            ],
            [
                "GraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractBaseGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "Multigraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultWeightedEdge",
                "org.jgrapht.graph"
            ],
            [
                "ListenableDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeSetFactory",
                "org.jgrapht.graph"
            ],
            [
                "GraphDelegator",
                "org.jgrapht.graph"
            ],
            [
                "DefaultListenableGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedVertexFactory",
                "org.jgrapht.graph"
            ],
            [
                "DefaultEdge",
                "org.jgrapht.graph"
            ],
            [
                "MaskVertexSet",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "IntrusiveEdge",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphPathImpl",
                "org.jgrapht.graph"
            ],
            [
                "Subgraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractGraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedEdgeFactory",
                "org.jgrapht.graph"
            ],
            [
                "SimpleWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "WeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeReversedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "AbstractGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "ListenableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraphPath",
                "org.jgrapht.graph"
            ],
            [
                "ParanoidGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphHelper",
                "org.jgrapht"
            ],
            [
                "Graphs",
                "org.jgrapht"
            ],
            [
                "DirectedGraph",
                "org.jgrapht"
            ],
            [
                "WeightedGraph",
                "org.jgrapht"
            ],
            [
                "HyperCubeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RingGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WheelGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GridGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "ScaleFreeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedBipartiteGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "LinearGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RandomGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGeneratorAdapter",
                "org.jgrapht.generate"
            ],
            [
                "EmptyGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteBipartiteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "StarGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "UndirectedGraph",
                "org.jgrapht"
            ],
            [
                "TopologicalOrderIterator",
                "org.jgrapht.traverse"
            ],
            [
                "CrossComponentIterator",
                "org.jgrapht.traverse"
            ],
            [
                "AbstractGraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "ClosestFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "BreadthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "DepthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "GraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "EdgeFactory",
                "org.jgrapht"
            ],
            [
                "GraphMapping",
                "org.jgrapht"
            ],
            [
                "VertexSetListener",
                "org.jgrapht.event"
            ],
            [
                "EdgeTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "TraversalListener",
                "org.jgrapht.event"
            ],
            [
                "GraphEdgeChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "VertexTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphListener",
                "org.jgrapht.event"
            ],
            [
                "TraversalListenerAdapter",
                "org.jgrapht.event"
            ],
            [
                "ConnectedComponentTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphVertexChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "TarjanLowestCommonAncestor",
                "org.jgrapht.alg"
            ],
            [
                "PrimMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "BlockCutpointGraph",
                "org.jgrapht.alg"
            ],
            [
                "AllDirectedPaths",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPathsIterator",
                "org.jgrapht.alg"
            ],
            [
                "KruskalMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "StrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "VF2State",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2AbstractIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "GraphOrdering",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphicGraphMapping",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2MappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "BronKerboschCliqueFinder",
                "org.jgrapht.alg"
            ],
            [
                "ChromaticNumber",
                "org.jgrapht.alg"
            ],
            [
                "KosarajuStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "DijkstraShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElement",
                "org.jgrapht.alg"
            ],
            [
                "AStarShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordPathElement",
                "org.jgrapht.alg"
            ],
            [
                "FloydWarshallShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "UnionFind",
                "org.jgrapht.alg.util"
            ],
            [
                "AlwaysEqualComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Extension",
                "org.jgrapht.alg.util"
            ],
            [
                "VertexDegreeComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Pair",
                "org.jgrapht.alg.util"
            ],
            [
                "GabowStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "HawickJamesSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "DirectedSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "JohnsonSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TiernanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "UndirectedCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "PatonCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TarjanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "SzwarcfiterLauerSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "BiconnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "ConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "MinSourceSinkCut",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsBlossomShrinking",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveClosure",
                "org.jgrapht.alg"
            ],
            [
                "HopcroftKarpBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "StoerWagnerMinimumCut",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "KuhnMunkresMinimalWeightBipartitePerfectMatching",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveReduction",
                "org.jgrapht.alg"
            ],
            [
                "EulerianCircuit",
                "org.jgrapht.alg"
            ],
            [
                "DirectedNeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "NaiveLcaFinder",
                "org.jgrapht.alg"
            ],
            [
                "MaximumWeightBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "HamiltonianCycle",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "NeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "VertexCovers",
                "org.jgrapht.alg"
            ],
            [
                "CycleDetector",
                "org.jgrapht.alg"
            ],
            [
                "AStarAdmissibleHeuristic",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MinimumSpanningTree",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "WeightedMatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "StrongConnectivityAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MaximumFlowAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "CliqueMinimalSeparatorDecomposition",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordIterator",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElement",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "PushRelabelMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "MaximumFlowAlgorithmBase",
                "org.jgrapht.alg.flow"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "addVertices",
                "org.jgrapht.experimental",
                "RandomGraphHelper",
                "/**\n * .\n *\n * @param target\n * @param vertexFactory\n * @param numVertices\n *\n * @return vertices\n */\n@SuppressWarnings(\"unchecked\")\npublic static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices) {\n    Object[] vertices = new Object[numVertices];\n    for (int i = 0; i < numVertices; ++i) {\n        vertices[i] = vertexFactory.createVertex();\n        target.addVertex(vertices[i]);\n    }\n    return vertices;\n}"
            ],
            [
                "isEmpty",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isEmpty(Graph<V, E> g) {\n    return g.edgeSet().isEmpty();\n}"
            ],
            [
                "isComplete",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isComplete(Graph<V, E> g) {\n    int n = g.vertexSet().size();\n    return g.edgeSet().size() == (n * (n - 1) / 2);\n}"
            ],
            [
                "isConnected",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isConnected(Graph<V, E> g) {\n    int numVertices = g.vertexSet().size();\n    int numEdges = g.edgeSet().size();\n    if (numEdges < (numVertices - 1)) {\n        return false;\n    }\n    if ((numVertices < 2) || (numEdges > ((numVertices - 1) * (numVertices - 2) / 2))) {\n        return true;\n    }\n    Set<V> known = new HashSet<V>();\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = g.vertexSet().iterator().next();\n    // start with node 1\n    queue.add(v);\n    known.add(v);\n    while (!queue.isEmpty()) {\n        v = queue.removeFirst();\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            v = it.next();\n            if (!known.contains(v)) {\n                known.add(v);\n                queue.add(v);\n            }\n        }\n    }\n    return known.size() == numVertices;\n}"
            ],
            [
                "isTree",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isTree(Graph<V, E> g) {\n    return isConnected(g) && (g.edgeSet().size() == (g.vertexSet().size() - 1));\n}"
            ],
            [
                "isBipartite",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isBipartite(Graph<V, E> g) {\n    if ((4 * g.edgeSet().size()) > (g.vertexSet().size() * g.vertexSet().size())) {\n        return false;\n    }\n    if (isEmpty(g)) {\n        return true;\n    }\n    Set<V> unknown = new HashSet<V>(g.vertexSet());\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = unknown.iterator().next();\n    Set<V> odd = new HashSet<V>();\n    queue.add(v);\n    while (!unknown.isEmpty()) {\n        if (queue.isEmpty()) {\n            queue.add(unknown.iterator().next());\n        }\n        v = queue.removeFirst();\n        unknown.remove(v);\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            V n = it.next();\n            if (unknown.contains(n)) {\n                queue.add(n);\n                if (!odd.contains(v)) {\n                    odd.add(n);\n                }\n            } else if (!(odd.contains(v) ^ odd.contains(n))) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
            ],
            [
                "union",
                "org.jgrapht.util",
                "FibonacciHeap",
                "// size\n/**\n * Joins two Fibonacci heaps into a new one. No heap consolidation is\n * performed at this time. The two root lists are simply joined together.\n *\n * <p>Running time: O(1) actual</p>\n *\n * @param h1 first heap\n * @param h2 second heap\n *\n * @return new heap containing h1 and h2\n */\npublic static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2) {\n    FibonacciHeap<T> h = new FibonacciHeap<T>();\n    if ((h1 != null) && (h2 != null)) {\n        h.minNode = h1.minNode;\n        if (h.minNode != null) {\n            if (h2.minNode != null) {\n                h.minNode.right.left = h2.minNode.left;\n                h2.minNode.left.right = h.minNode.right;\n                h.minNode.right = h2.minNode;\n                h2.minNode.left = h.minNode;\n                if (h2.minNode.key < h1.minNode.key) {\n                    h.minNode = h2.minNode;\n                }\n            }\n        } else {\n            h.minNode = h2.minNode;\n        }\n        h.nNodes = h1.nNodes + h2.nNodes;\n    }\n    return h;\n}"
            ],
            [
                "uncheckedCast",
                "org.jgrapht.util",
                "TypeUtil",
                "/**\n * Casts an object to a type.\n *\n * @param o object to be cast\n * @param typeDecl conveys the target type information; the actual value is\n * unused and can be null since this is all just stupid compiler tricks\n *\n * @return the result of the cast\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl) {\n    return (T) o;\n}"
            ],
            [
                "factorial",
                "org.jgrapht.util",
                "MathUtil",
                "public static long factorial(int N) {\n    long multi = 1;\n    for (int i = 1; i <= N; i++) {\n        multi = multi * i;\n    }\n    return multi;\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graphs",
                "/**\n * Creates a new edge and adds it to the specified graph similarly to the\n * {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n *\n * @see Graph#addEdge(Object, Object)\n */\npublic static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    EdgeFactory<V, E> ef = g.getEdgeFactory();\n    E e = ef.createEdge(sourceVertex, targetVertex);\n    // we first create the edge and set the weight to make sure that\n    // listeners will see the correct weight upon addEdge.\n    assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n    ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n    return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new edge and adds it to the specified\n * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return g.addEdge(sourceVertex, targetVertex);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified edge to the graph, including its vertices if not\n * already included.\n *\n * @param targetGraph the graph for which the specified edge to be added.\n * @param sourceGraph the graph in which the specified edge is already\n * present\n * @param edge edge to add\n *\n * @return <tt>true</tt> if the target graph did not already contain the\n * specified edge.\n */\npublic static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge) {\n    V sourceVertex = sourceGraph.getEdgeSource(edge);\n    V targetVertex = sourceGraph.getEdgeTarget(edge);\n    targetGraph.addVertex(sourceVertex);\n    targetGraph.addVertex(targetVertex);\n    return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new weighted edge and adds it to the\n * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n * method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return addEdge(g, sourceVertex, targetVertex, weight);\n}"
            ],
            [
                "addGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all the vertices and all the edges of the specified source graph to\n * the specified destination graph. First all vertices of the source graph\n * are added to the destination graph. Then every edge of the source graph\n * is added to the destination graph. This method returns <code>true</code>\n * if the destination graph has been modified as a result of this operation,\n * otherwise it returns <code>false</code>.\n *\n * <p>The behavior of this operation is undefined if any of the specified\n * graphs is modified while operation is in progress.</p>\n *\n * @param destination the graph to which vertices and edges are added.\n * @param source the graph used as source for vertices and edges to add.\n *\n * @return <code>true</code> if and only if the destination graph has been\n * changed as a result of this operation.\n */\npublic static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source) {\n    boolean modified = addAllVertices(destination, source.vertexSet());\n    modified |= addAllEdges(destination, source, source.edgeSet());\n    return modified;\n}"
            ],
            [
                "addAllEdges",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds a subset of the edges of the specified source graph to the specified\n * destination graph. The behavior of this operation is undefined if either\n * of the graphs is modified while the operation is in progress. {@link\n * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n * be added automatically to the target graph.\n *\n * @param destination the graph to which edges are to be added\n * @param source the graph used as a source for edges to add\n * @param edges the edges to be added\n *\n * @return <tt>true</tt> if this graph changed as a result of the call\n */\npublic static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges) {\n    boolean modified = false;\n    for (E e : edges) {\n        V s = source.getEdgeSource(e);\n        V t = source.getEdgeTarget(e);\n        destination.addVertex(s);\n        destination.addVertex(t);\n        modified |= destination.addEdge(s, t, e);\n    }\n    return modified;\n}"
            ],
            [
                "addAllVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all of the specified vertices to the destination graph. The behavior\n * of this operation is undefined if the specified vertex collection is\n * modified while the operation is in progress. This method will invoke the\n * {@link Graph#addVertex(Object)} method.\n *\n * @param destination the graph to which edges are to be added\n * @param vertices the vertices to be added to the graph.\n *\n * @return <tt>true</tt> if graph changed as a result of the call\n *\n * @throws NullPointerException if the specified vertices contains one or\n * more null vertices, or if the specified vertex collection is <tt>\n * null</tt>.\n *\n * @see Graph#addVertex(Object)\n */\npublic static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices) {\n    boolean modified = false;\n    for (V v : vertices) {\n        modified |= destination.addVertex(v);\n    }\n    return modified;\n}"
            ],
            [
                "neighborListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the neighbors of a specified vertex.\n * If the graph is a multigraph vertices may appear more than once in the\n * returned list.\n *\n * @param g the graph to look for neighbors in.\n * @param vertex the vertex to get the neighbors of.\n *\n * @return a list of the vertices that are the neighbors of the specified\n * vertex.\n */\npublic static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex) {\n    List<V> neighbors = new ArrayList<V>();\n    for (E e : g.edgesOf(vertex)) {\n        neighbors.add(getOppositeVertex(g, e, vertex));\n    }\n    return neighbors;\n}"
            ],
            [
                "predecessorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct predecessors of a\n * specified vertex. If the graph is a multigraph, vertices may appear more\n * than once in the returned list.\n *\n * @param g the graph to look for predecessors in.\n * @param vertex the vertex to get the predecessors of.\n *\n * @return a list of the vertices that are the direct predecessors of the\n * specified vertex.\n */\npublic static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> predecessors = new ArrayList<V>();\n    Set<? extends E> edges = g.incomingEdgesOf(vertex);\n    for (E e : edges) {\n        predecessors.add(getOppositeVertex(g, e, vertex));\n    }\n    return predecessors;\n}"
            ],
            [
                "successorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct successors of a specified\n * vertex. If the graph is a multigraph vertices may appear more than once\n * in the returned list.\n *\n * @param g the graph to look for successors in.\n * @param vertex the vertex to get the successors of.\n *\n * @return a list of the vertices that are the direct successors of the\n * specified vertex.\n */\npublic static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> successors = new ArrayList<V>();\n    Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n    for (E e : edges) {\n        successors.add(getOppositeVertex(g, e, vertex));\n    }\n    return successors;\n}"
            ],
            [
                "undirectedGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns an undirected view of the specified graph. If the specified graph\n * is directed, returns an undirected view of it. If the specified graph is\n * already undirected, just returns it.\n *\n * @param g the graph for which an undirected view is to be returned.\n *\n * @return an undirected view of the specified graph, if it is directed, or\n * or the specified graph itself if it is already undirected.\n *\n * @throws IllegalArgumentException if the graph is neither DirectedGraph\n * nor UndirectedGraph.\n *\n * @see AsUndirectedGraph\n */\npublic static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n    } else if (g instanceof UndirectedGraph<?, ?>) {\n        return (UndirectedGraph<V, E>) g;\n    } else {\n        throw new IllegalArgumentException(\"Graph must be either DirectedGraph or UndirectedGraph\");\n    }\n}"
            ],
            [
                "testIncidence",
                "org.jgrapht",
                "Graphs",
                "/**\n * Tests whether an edge is incident to a vertex.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return true iff e is incident on v\n */\npublic static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v) {\n    return (g.getEdgeSource(e).equals(v)) || (g.getEdgeTarget(e).equals(v));\n}"
            ],
            [
                "getOppositeVertex",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the vertex opposite another vertex across an edge.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return vertex opposite to v across e\n */\npublic static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v) {\n    V source = g.getEdgeSource(e);\n    V target = g.getEdgeTarget(e);\n    if (v.equals(source)) {\n        return target;\n    } else if (v.equals(target)) {\n        return source;\n    } else {\n        throw new IllegalArgumentException(\"no such vertex: \" + v.toString());\n    }\n}"
            ],
            [
                "getPathVertexList",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the list of vertices visited by a path.\n *\n * @param path path of interest\n *\n * @return corresponding vertex list\n */\npublic static <V, E> List<V> getPathVertexList(GraphPath<V, E> path) {\n    Graph<V, E> g = path.getGraph();\n    List<V> list = new ArrayList<V>();\n    V v = path.getStartVertex();\n    list.add(v);\n    for (E e : path.getEdgeList()) {\n        v = getOppositeVertex(g, e, v);\n        list.add(v);\n    }\n    return list;\n}"
            ],
            [
                "range",
                "org.jgrapht.generate",
                "SimpleWeightedGraphMatrixGenerator",
                "///////////////////////////////////////////////////////////////////////////////////////////////\npublic static int[] range(final int from, final int to) {\n    int[] range = new int[to - from];\n    for (int i = from; i < to; ++i) {\n        range[i - from] = i;\n    }\n    return range;\n}"
            ],
            [
                "createGraphSpecifics",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "// -------------------------------------------------------------------------\n/**\n * @param <V>\n * @param <E>\n * @param g\n *\n * @return TODO Document me\n */\nstatic <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new DirectedSpecifics<V, E>((DirectedGraph<V, E>) g);\n    } else {\n        return new UndirectedSpecifics<V, E>(g);\n    }\n}"
            ],
            [
                "findGreedyChromaticNumber",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds the number of colors required for a greedy coloring of the graph.\n *\n * @param g an undirected graph to find the chromatic number of\n *\n * @return integer the approximate chromatic number from the greedy\n * algorithm\n */\npublic static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g) {\n    Map<Integer, Set<V>> coloredGroups = findGreedyColoredGroups(g);\n    return coloredGroups.keySet().size();\n}"
            ],
            [
                "findGreedyColoredGroups",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds a greedy coloring of the graph.\n *\n * @param g an undirected graph for which to find the coloring\n */\npublic static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g) {\n    // A copy of the graph is made, so that elements of the graph may be\n    // removed to carry out the algorithm\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // The Vertices will be sorted in decreasing order by degree, so that\n    // higher degree vertices have priority to be colored first\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    List<V> sortedVertices = new LinkedList<V>(sg.vertexSet());\n    Collections.sort(sortedVertices, comp);\n    Collections.reverse(sortedVertices);\n    int color;\n    // create a map which will hold color as key and Set<V> as value\n    Map<Integer, Set<V>> coloredGroups = new HashMap<Integer, Set<V>>();\n    // We'll attempt to color each vertex with a single color each\n    // iteration, and these vertices will be removed from the graph at the\n    // end of each iteration\n    for (color = 0; sg.vertexSet().size() > 0; color++) {\n        // This set will contain vertices that are colored with the\n        // current color of this iteration\n        Set<V> currentColor = new HashSet<V>();\n        for (Iterator<V> iter = sortedVertices.iterator(); iter.hasNext(); ) {\n            V v = iter.next();\n            // Add new vertices to be colored as long as they are not\n            // adjacent with any other vertex that has already been colored\n            // with the current color\n            boolean flag = true;\n            for (Iterator<V> innerIter = currentColor.iterator(); innerIter.hasNext(); ) {\n                V temp = innerIter.next();\n                if (sg.containsEdge(temp, v)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                currentColor.add(v);\n                iter.remove();\n            }\n        }\n        // Add all these vertices as a group for this color\n        coloredGroups.put(color, currentColor);\n        // Remove vertices from the graph and then repeat the process for\n        // the next iteration\n        sg.removeAllVertices(currentColor);\n    }\n    return coloredGroups;\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "BellmanFordShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by hops, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    BellmanFordShortestPath<V, E> alg = new BellmanFordShortestPath<V, E>(graph, startVertex);\n    return alg.getPathEdgeList(endVertex);\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "DijkstraShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by radius, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    DijkstraShortestPath<V, E> alg = new DijkstraShortestPath<V, E>(graph, startVertex, endVertex);\n    return alg.getPathEdgeList();\n}"
            ],
            [
                "of",
                "org.jgrapht.alg.util",
                "Pair",
                "/**\n * Creates new pair of elements pulling of the necessity to provide\n * corresponding types of the elements supplied\n *\n * @param a first element\n * @param b second element\n *\n * @return new pair\n */\npublic static <A, B> Pair<A, B> of(A a, B b) {\n    return new Pair<A, B>(a, b);\n}"
            ],
            [
                "isEulerian",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will check whether the graph passed in is Eulerian or not.\n *\n * @param g The graph to be checked\n *\n * @return true for Eulerian and false for non-Eulerian\n */\npublic static <V, E> boolean isEulerian(UndirectedGraph<V, E> g) {\n    // If the graph is not connected, then no Eulerian circuit exists\n    if (!(new ConnectivityInspector<V, E>(g)).isGraphConnected()) {\n        return false;\n    }\n    // A graph is Eulerian if and only if all vertices have even degree\n    // So, this code will check for that\n    Iterator<V> iter = g.vertexSet().iterator();\n    while (iter.hasNext()) {\n        V v = iter.next();\n        if ((g.degreeOf(v) % 2) == 1) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "getEulerianCircuitVertices",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will return a list of vertices which represents the Eulerian\n * circuit of the graph.\n *\n * @param g The graph to find an Eulerian circuit\n *\n * @return null if no Eulerian circuit exists, or a list of vertices\n * representing the Eulerian circuit if one does exist\n */\npublic static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g) {\n    // If the graph is not Eulerian then just return a null since no\n    // Eulerian circuit exists\n    if (!isEulerian(g)) {\n        return null;\n    }\n    // The circuit will be represented by a linked list\n    List<V> path = new LinkedList<V>();\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    path.add(sg.vertexSet().iterator().next());\n    // Algorithm for finding an Eulerian circuit Basically this will find an\n    // arbitrary circuit, then it will find another arbitrary circuit until\n    // every edge has been traversed\n    while (sg.edgeSet().size() > 0) {\n        V v = null;\n        // Find a vertex which has an edge that hasn't been traversed yet,\n        // and keep its index position in the circuit list\n        int index = 0;\n        for (Iterator<V> iter = path.iterator(); iter.hasNext(); index++) {\n            v = iter.next();\n            if (sg.degreeOf(v) > 0) {\n                break;\n            }\n        }\n        // Finds an arbitrary circuit of the current vertex and\n        // appends this into the circuit list\n        while (sg.degreeOf(v) > 0) {\n            for (Iterator<V> iter = sg.vertexSet().iterator(); iter.hasNext(); ) {\n                V temp = iter.next();\n                if (sg.containsEdge(v, temp)) {\n                    path.add(index, temp);\n                    sg.removeEdge(v, temp);\n                    v = temp;\n                    break;\n                }\n            }\n        }\n    }\n    return path;\n}"
            ],
            [
                "getApproximateOptimalForCompleteGraph",
                "org.jgrapht.alg",
                "HamiltonianCycle",
                "/**\n * This method will return an approximate minimal traveling salesman tour\n * (hamiltonian cycle). This algorithm requires that the graph be complete\n * and the triangle inequality exists (if x,y,z are vertices then\n * d(x,y)+d(y,z) &lt; d(x,z) for all x,y,z) then this algorithm will\n * guarantee a hamiltonian cycle such that the total weight of the cycle is\n * less than or equal to double the total weight of the optimal hamiltonian\n * cycle. The optimal solution is NP-complete, so this is a decent\n * approximation that runs in polynomial time.\n *\n * @param <V>\n * @param <E>\n * @param g is the graph to find the optimal tour for.\n *\n * @return The optimal tour as a list of vertices.\n */\npublic static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g) {\n    List<V> vertices = new LinkedList<V>(g.vertexSet());\n    // If the graph is not complete then return null since this algorithm\n    // requires the graph be complete\n    if ((vertices.size() * (vertices.size() - 1) / 2) != g.edgeSet().size()) {\n        return null;\n    }\n    List<V> tour = new LinkedList<V>();\n    // Each iteration a new vertex will be added to the tour until all\n    // vertices have been added\n    while (tour.size() != g.vertexSet().size()) {\n        boolean firstEdge = true;\n        double minEdgeValue = 0;\n        int minVertexFound = 0;\n        int vertexConnectedTo = 0;\n        // A check will be made for the shortest edge to a vertex not within\n        // the tour and that new vertex will be added to the vertex\n        for (int i = 0; i < tour.size(); i++) {\n            V v = tour.get(i);\n            for (int j = 0; j < vertices.size(); j++) {\n                double weight = g.getEdgeWeight(g.getEdge(v, vertices.get(j)));\n                if (firstEdge || (weight < minEdgeValue)) {\n                    firstEdge = false;\n                    minEdgeValue = weight;\n                    minVertexFound = j;\n                    vertexConnectedTo = i;\n                }\n            }\n        }\n        tour.add(vertexConnectedTo, vertices.get(minVertexFound));\n        vertices.remove(minVertexFound);\n    }\n    return tour;\n}"
            ],
            [
                "find2ApproximationCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a 2-approximation for a minimal vertex cover of the specified\n * graph. The algorithm promises a cover that is at most double the size of\n * a minimal cover. The algorithm takes O(|E|) time.\n *\n * <p>For more details see Jenny Walter, CMPU-240: Lecture notes for\n * Language Theory and Computation, Fall 2002, Vassar College, <a\n * href=\"http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf\">\n * http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf</a>.\n * </p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G'=(V',E') <-- G(V,E)\n    Subgraph<V, E, Graph<V, E>> sg = new Subgraph<V, E, Graph<V, E>>(g, null, null);\n    // while E' is non-empty\n    while (sg.edgeSet().size() > 0) {\n        // let (u,v) be an arbitrary edge of E'\n        E e = sg.edgeSet().iterator().next();\n        // C <-- C U {u,v}\n        V u = g.getEdgeSource(e);\n        V v = g.getEdgeTarget(e);\n        cover.add(u);\n        cover.add(v);\n        // remove from E' every edge incident on either u or v\n        sg.removeVertex(u);\n        sg.removeVertex(v);\n    }\n    // return C\n    return cover;\n}"
            ],
            [
                "findGreedyCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a greedy approximation for a minimal vertex cover of a specified\n * graph. At each iteration, the algorithm picks the vertex with the highest\n * degree and adds it to the cover, until all edges are covered.\n *\n * <p>The algorithm works on undirected graphs, but can also work on\n * directed graphs when their edge-directions are ignored. To ignore edge\n * directions you can use {@link org.jgrapht.Graphs#undirectedGraph(Graph)}\n * or {@link org.jgrapht.graph.AsUndirectedGraph}.</p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G' <-- G\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // compare vertices in descending order of degree\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    // while G' != {}\n    while (sg.edgeSet().size() > 0) {\n        // v <-- vertex with maximum degree in G'\n        V v = Collections.max(sg.vertexSet(), comp);\n        // C <-- C U {v}\n        cover.add(v);\n        // remove from G' every edge incident on v, and v itself\n        sg.removeVertex(v);\n    }\n    return cover;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "BEST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int BEST_ORDER = 0;"
            ],
            [
                "NATURAL_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int NATURAL_ORDER = 1;"
            ],
            [
                "SMALLEST_DEGREE_LAST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;"
            ],
            [
                "LARGEST_SATURATION_FIRST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;"
            ],
            [
                "DEFAULT_EDGE_WEIGHT",
                "org.jgrapht",
                "WeightedGraph",
                "/**\n * The default weight for an edge.\n */\npublic static double DEFAULT_EDGE_WEIGHT = 1.0;"
            ],
            [
                "HUB_VERTEX",
                "org.jgrapht.generate",
                "WheelGraphGenerator",
                "/**\n * Role for the hub vertex.\n */\npublic static final String HUB_VERTEX = \"Hub Vertex\";"
            ],
            [
                "CORNER_VERTEX",
                "org.jgrapht.generate",
                "GridGraphGenerator",
                "/**\n * Role for the vertices at the corners.\n */\npublic static final String CORNER_VERTEX = \"Corner Vertex\";"
            ],
            [
                "START_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the first vertex generated.\n */\npublic static final String START_VERTEX = \"Start Vertex\";"
            ],
            [
                "END_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the last vertex generated.\n */\npublic static final String END_VERTEX = \"End Vertex\";"
            ],
            [
                "CENTER_VERTEX",
                "org.jgrapht.generate",
                "StarGraphGenerator",
                "public static final String CENTER_VERTEX = \"Center Vertex\";"
            ],
            [
                "SENTINEL",
                "org.jgrapht.traverse",
                "DepthFirstIterator",
                "/**\n * Sentinel object. Unfortunately, we can't use null, because ArrayDeque\n * won't accept those. And we don't want to rely on the caller to provide a\n * sentinel object for us. So we have to play typecasting games.\n */\npublic static final Object SENTINEL = new Object();"
            ],
            [
                "BEFORE_EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge added event. This event is fired before an edge is added to a\n * graph.\n */\npublic static final int BEFORE_EDGE_ADDED = 21;"
            ],
            [
                "BEFORE_EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge removed event. This event is fired before an edge is removed\n * from a graph.\n */\npublic static final int BEFORE_EDGE_REMOVED = 22;"
            ],
            [
                "EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge added event. This event is fired after an edge is added to a graph.\n */\npublic static final int EDGE_ADDED = 23;"
            ],
            [
                "EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge removed event. This event is fired after an edge is removed from a\n * graph.\n */\npublic static final int EDGE_REMOVED = 24;"
            ],
            [
                "CONNECTED_COMPONENT_STARTED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal started event.\n */\npublic static final int CONNECTED_COMPONENT_STARTED = 31;"
            ],
            [
                "CONNECTED_COMPONENT_FINISHED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal finished event.\n */\npublic static final int CONNECTED_COMPONENT_FINISHED = 32;"
            ],
            [
                "BEFORE_VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex added event. This event is fired before a vertex is added\n * to a graph.\n */\npublic static final int BEFORE_VERTEX_ADDED = 11;"
            ],
            [
                "BEFORE_VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex removed event. This event is fired before a vertex is\n * removed from a graph.\n */\npublic static final int BEFORE_VERTEX_REMOVED = 12;"
            ],
            [
                "VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex added event. This event is fired after a vertex is added to a\n * graph.\n */\npublic static final int VERTEX_ADDED = 13;"
            ],
            [
                "VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex removed event. This event is fired after a vertex is removed from\n * a graph.\n */\npublic static final int VERTEX_REMOVED = 14;"
            ],
            [
                "NULL_NODE",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "public static final int NULL_NODE = -1;"
            ],
            [
                "DEBUG",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected static final boolean DEBUG = false;"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg",
                "EdmondsKarpMaximumFlow",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 0.000000001;"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveClosure",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveClosure INSTANCE = new TransitiveClosure();"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveReduction",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveReduction INSTANCE = new TransitiveReduction();"
            ],
            [
                "NEGATIVE_UNDIRECTED_EDGE",
                "org.jgrapht.alg",
                "BellmanFordIterator",
                "/**\n * Error message.\n */\nprotected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg.flow",
                "MaximumFlowAlgorithmBase",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 1e-9;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [
            [
                "vertex",
                "java.lang",
                "Object"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "isCrossComponentTraversal",
                "org.jgrapht.traverse",
                "AbstractGraphIterator",
                "public boolean isCrossComponentTraversal()"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "provideNextVertex",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "/**\n * Returns the vertex to be returned in the following call to the iterator\n * <code>next</code> method.\n *\n * @return the next vertex to be returned by this iterator.\n */\nprotected abstract V provideNextVertex();"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "putSeenData",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "/**\n * Stores iterator-dependent data for a vertex that has been seen.\n *\n * @param vertex a vertex which has been seen.\n * @param data data to be associated with the seen vertex.\n *\n * @return previous value associated with specified vertex or <code>\n * null</code> if no data was associated with the vertex. A <code>\n * null</code> return can also indicate that the vertex was explicitly\n * associated with <code>null</code>.\n */\nprotected D putSeenData(V vertex, D data) {\n    return seen.put(vertex, data);\n}"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "hasNext",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "/**\n * @see java.util.Iterator#hasNext()\n */\n@Override\npublic boolean hasNext() {\n    if (startVertex != null) {\n        encounterStartVertex();\n    }\n    if (isConnectedComponentExhausted()) {\n        if (state == CCS_WITHIN_COMPONENT) {\n            state = CCS_AFTER_COMPONENT;\n            if (nListeners != 0) {\n                fireConnectedComponentFinished(ccFinishedEvent);\n            }\n        }\n        if (isCrossComponentTraversal()) {\n            while (vertexIterator.hasNext()) {\n                V v = vertexIterator.next();\n                if (!isSeenVertex(v)) {\n                    encounterVertex(v, null);\n                    state = CCS_BEFORE_COMPONENT;\n                    return true;\n                }\n            }\n            return false;\n        } else {\n            return false;\n        }\n    } else {\n        return true;\n    }\n}"
            ],
            [
                "getGraph",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "/**\n * @return the graph being traversed\n */\npublic Graph<V, E> getGraph() {\n    return graph;\n}"
            ],
            [
                "isConnectedComponentExhausted",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "/**\n * Returns <tt>true</tt> if there are no more uniterated vertices in the\n * currently iterated connected component; <tt>false</tt> otherwise.\n *\n * @return <tt>true</tt> if there are no more uniterated vertices in the\n * currently iterated connected component; <tt>false</tt> otherwise.\n */\nprotected abstract boolean isConnectedComponentExhausted();"
            ],
            [
                "isReuseEvents",
                "org.jgrapht.traverse",
                "AbstractGraphIterator",
                "public boolean isReuseEvents()"
            ],
            [
                "isSeenVertex",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "/**\n * Determines whether a vertex has been seen yet by this traversal.\n *\n * @param vertex vertex in question\n *\n * @return <tt>true</tt> if vertex has already been seen\n */\nprotected boolean isSeenVertex(Object vertex) {\n    return seen.containsKey(vertex);\n}"
            ],
            [
                "next",
                "java.util",
                "Iterator",
                "public abstract E next()"
            ],
            [
                "getSeenData",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "/**\n * Access the data stored for a seen vertex.\n *\n * @param vertex a vertex which has already been seen.\n *\n * @return data associated with the seen vertex or <code>null</code> if no\n * data was associated with the vertex. A <code>null</code> return can also\n * indicate that the vertex was explicitly associated with <code>\n * null</code>.\n */\nprotected D getSeenData(V vertex) {\n    return seen.get(vertex);\n}"
            ],
            [
                "next",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "/**\n * @see java.util.Iterator#next()\n */\n@Override\npublic V next() {\n    if (startVertex != null) {\n        encounterStartVertex();\n    }\n    if (hasNext()) {\n        if (state == CCS_BEFORE_COMPONENT) {\n            state = CCS_WITHIN_COMPONENT;\n            if (nListeners != 0) {\n                fireConnectedComponentStarted(ccStartedEvent);\n            }\n        }\n        V nextVertex = provideNextVertex();\n        if (nListeners != 0) {\n            fireVertexTraversed(createVertexTraversalEvent(nextVertex));\n        }\n        addUnseenChildrenOf(nextVertex);\n        return nextVertex;\n    } else {\n        throw new NoSuchElementException();\n    }\n}"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [
            [
                "nListeners",
                "org.jgrapht.traverse",
                "AbstractGraphIterator",
                "protected int nListeners;"
            ]
        ],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 26194,
        "oracle": ";",
        "oracleType": "PRE",
        "projectName": "jgrapht-core-0.9.2",
        "packageName": "org.jgrapht.traverse",
        "className": "ClosestFirstIterator",
        "javadocTag": "@param vertex the vertex for which to calculate the path length.",
        "methodJavadoc": "    /**\n     * Determine weighted path length to a vertex via an edge, using the path\n     * length for the opposite vertex.\n     *\n     * @param vertex the vertex for which to calculate the path length.\n     * @param edge the edge via which the path is being extended.\n     *\n     * @return calculated path length.\n     */",
        "methodSourceCode": "private double calculatePathLength(V vertex, E edge){\n    assertNonNegativeEdge(edge);\n    V otherVertex = Graphs.getOppositeVertex(getGraph(), edge, vertex);\n    FibonacciHeapNode<QueueEntry<V, E>> otherEntry = getSeenData(otherVertex);\n    return otherEntry.getKey() + getGraph().getEdgeWeight(edge);\n}",
        "classJavadoc": "/**\n * A closest-first iterator for a directed or undirected graph. For this\n * iterator to work correctly the graph must not be modified during iteration.\n * Currently there are no means to ensure that, nor to fail-fast. The results of\n * such modifications are undefined.\n *\n * <p>The metric for <i>closest</i> here is the weighted path length from a\n * start vertex, i.e. Graph.getEdgeWeight(Edge) is summed to calculate path\n * length. Negative edge weights will result in an IllegalArgumentException.\n * Optionally, path length may be bounded by a finite radius.</p>\n *\n * @author John V. Sichi\n * @since Sep 2, 2003\n */",
        "classSourceCode": "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------------\n * ClosestFirstIterator.java\n * -------------------------\n * (C) Copyright 2003-2008, by John V. Sichi and Contributors.\n *\n * Original Author:  John V. Sichi\n * Contributor(s):   Barak Naveh\n *\n * $Id$\n *\n * Changes\n * -------\n * 02-Sep-2003 : Initial revision (JVS);\n * 31-Jan-2004 : Reparented and changed interface to parent class (BN);\n * 29-May-2005 : Added radius support (JVS);\n * 06-Jun-2005 : Made generic (CH);\n *\n */\npackage org.jgrapht.traverse;\n\nimport org.jgrapht.*;\nimport org.jgrapht.util.*;\n\n\n/**\n * A closest-first iterator for a directed or undirected graph. For this\n * iterator to work correctly the graph must not be modified during iteration.\n * Currently there are no means to ensure that, nor to fail-fast. The results of\n * such modifications are undefined.\n *\n * <p>The metric for <i>closest</i> here is the weighted path length from a\n * start vertex, i.e. Graph.getEdgeWeight(Edge) is summed to calculate path\n * length. Negative edge weights will result in an IllegalArgumentException.\n * Optionally, path length may be bounded by a finite radius.</p>\n *\n * @author John V. Sichi\n * @since Sep 2, 2003\n */\npublic class ClosestFirstIterator<V, E>\n    extends CrossComponentIterator<V,\n        E, FibonacciHeapNode<ClosestFirstIterator.QueueEntry<V, E>>>\n{\n    /**\n     * Priority queue of fringe vertices.\n     */\n    private FibonacciHeap<QueueEntry<V, E>> heap =\n        new FibonacciHeap<QueueEntry<V, E>>();\n\n    /**\n     * Maximum distance to search.\n     */\n    private double radius = Double.POSITIVE_INFINITY;\n\n    private boolean initialized = false;\n\n    /**\n     * Creates a new closest-first iterator for the specified graph.\n     *\n     * @param g the graph to be iterated.\n     */\n    public ClosestFirstIterator(Graph<V, E> g)\n    {\n        this(g, null);\n    }\n\n    /**\n     * Creates a new closest-first iterator for the specified graph. Iteration\n     * will start at the specified start vertex and will be limited to the\n     * connected component that includes that vertex. If the specified start\n     * vertex is <code>null</code>, iteration will start at an arbitrary vertex\n     * and will not be limited, that is, will be able to traverse all the graph.\n     *\n     * @param g the graph to be iterated.\n     * @param startVertex the vertex iteration to be started.\n     */\n    public ClosestFirstIterator(Graph<V, E> g, V startVertex)\n    {\n        this(g, startVertex, Double.POSITIVE_INFINITY);\n    }\n\n    /**\n     * Creates a new radius-bounded closest-first iterator for the specified\n     * graph. Iteration will start at the specified start vertex and will be\n     * limited to the subset of the connected component which includes that\n     * vertex and is reachable via paths of weighted length less than or equal\n     * to the specified radius. The specified start vertex may not be <code>\n     * null</code>.\n     *\n     * @param g the graph to be iterated.\n     * @param startVertex the vertex iteration to be started.\n     * @param radius limit on weighted path length, or Double.POSITIVE_INFINITY\n     * for unbounded search.\n     */\n    public ClosestFirstIterator(Graph<V, E> g, V startVertex, double radius)\n    {\n        super(g, startVertex);\n        this.radius = radius;\n        checkRadiusTraversal(isCrossComponentTraversal());\n        initialized = true;\n    }\n\n    // override AbstractGraphIterator\n    @Override public void setCrossComponentTraversal(\n        boolean crossComponentTraversal)\n    {\n        if (initialized) {\n            checkRadiusTraversal(crossComponentTraversal);\n        }\n        super.setCrossComponentTraversal(crossComponentTraversal);\n    }\n\n    /**\n     * Get the weighted length of the shortest path known to the given vertex.\n     * If the vertex has already been visited, then it is truly the shortest\n     * path length; otherwise, it is the best known upper bound.\n     *\n     * @param vertex vertex being sought from start vertex\n     *\n     * @return weighted length of shortest path known, or\n     * Double.POSITIVE_INFINITY if no path found yet\n     */\n    public double getShortestPathLength(V vertex)\n    {\n        FibonacciHeapNode<QueueEntry<V, E>> node = getSeenData(vertex);\n\n        if (node == null) {\n            return Double.POSITIVE_INFINITY;\n        }\n\n        return node.getKey();\n    }\n\n    /**\n     * Get the spanning tree edge reaching a vertex which has been seen already\n     * in this traversal. This edge is the last link in the shortest known path\n     * between the start vertex and the requested vertex. If the vertex has\n     * already been visited, then it is truly the minimum spanning tree edge;\n     * otherwise, it is the best candidate seen so far.\n     *\n     * @param vertex the spanned vertex.\n     *\n     * @return the spanning tree edge, or null if the vertex either has not been\n     * seen yet or is the start vertex.\n     */\n    public E getSpanningTreeEdge(V vertex)\n    {\n        FibonacciHeapNode<QueueEntry<V, E>> node = getSeenData(vertex);\n\n        if (node == null) {\n            return null;\n        }\n\n        return node.getData().spanningTreeEdge;\n    }\n\n    /**\n     * @see CrossComponentIterator#isConnectedComponentExhausted()\n     */\n    @Override protected boolean isConnectedComponentExhausted()\n    {\n        if (heap.size() == 0) {\n            return true;\n        } else {\n            if (heap.min().getKey() > radius) {\n                heap.clear();\n\n                return true;\n            } else {\n                return false;\n            }\n        }\n    }\n\n    /**\n     * @see CrossComponentIterator#encounterVertex(Object, Object)\n     */\n    @Override protected void encounterVertex(V vertex, E edge)\n    {\n        double shortestPathLength;\n        if (edge == null) {\n            shortestPathLength = 0;\n        } else {\n            shortestPathLength = calculatePathLength(vertex, edge);\n        }\n        FibonacciHeapNode<QueueEntry<V, E>> node = createSeenData(vertex, edge);\n        putSeenData(vertex, node);\n        heap.insert(node, shortestPathLength);\n    }\n\n    /**\n     * Override superclass. When we see a vertex again, we need to see if the\n     * new edge provides a shorter path than the old edge.\n     *\n     * @param vertex the vertex re-encountered\n     * @param edge the edge via which the vertex was re-encountered\n     */\n    @Override protected void encounterVertexAgain(V vertex, E edge)\n    {\n        FibonacciHeapNode<QueueEntry<V, E>> node = getSeenData(vertex);\n\n        if (node.getData().frozen) {\n            // no improvement for this vertex possible\n            return;\n        }\n\n        double candidatePathLength = calculatePathLength(vertex, edge);\n\n        if (candidatePathLength < node.getKey()) {\n            node.getData().spanningTreeEdge = edge;\n            heap.decreaseKey(node, candidatePathLength);\n        }\n    }\n\n    /**\n     * @see CrossComponentIterator#provideNextVertex()\n     */\n    @Override protected V provideNextVertex()\n    {\n        FibonacciHeapNode<QueueEntry<V, E>> node = heap.removeMin();\n        node.getData().frozen = true;\n\n        return node.getData().vertex;\n    }\n\n    private void assertNonNegativeEdge(E edge)\n    {\n        if (getGraph().getEdgeWeight(edge) < 0) {\n            throw new IllegalArgumentException(\n                \"negative edge weights not allowed\");\n        }\n    }\n\n    /**\n     * Determine weighted path length to a vertex via an edge, using the path\n     * length for the opposite vertex.\n     *\n     * @param vertex the vertex for which to calculate the path length.\n     * @param edge the edge via which the path is being extended.\n     *\n     * @return calculated path length.\n     */\n    private double calculatePathLength(V vertex, E edge)\n    {\n        assertNonNegativeEdge(edge);\n\n        V otherVertex = Graphs.getOppositeVertex(getGraph(), edge, vertex);\n        FibonacciHeapNode<QueueEntry<V, E>> otherEntry =\n            getSeenData(otherVertex);\n\n        return otherEntry.getKey()\n            + getGraph().getEdgeWeight(edge);\n    }\n\n    private void checkRadiusTraversal(boolean crossComponentTraversal)\n    {\n        if (crossComponentTraversal && (radius != Double.POSITIVE_INFINITY)) {\n            throw new IllegalArgumentException(\n                \"radius may not be specified for cross-component traversal\");\n        }\n    }\n\n    /**\n     * The first time we see a vertex, make up a new heap node for it.\n     *\n     * @param vertex a vertex which has just been encountered.\n     * @param edge the edge via which the vertex was encountered.\n     *\n     * @return the new heap node.\n     */\n    private FibonacciHeapNode<QueueEntry<V, E>> createSeenData(\n        V vertex,\n        E edge)\n    {\n        QueueEntry<V, E> entry = new QueueEntry<V, E>();\n        entry.vertex = vertex;\n        entry.spanningTreeEdge = edge;\n\n        return new FibonacciHeapNode<QueueEntry<V, E>>(entry);\n    }\n\n    /**\n     * Private data to associate with each entry in the priority queue.\n     */\n    static class QueueEntry<V, E>\n    {\n        /**\n         * Best spanning tree edge to vertex seen so far.\n         */\n        E spanningTreeEdge;\n\n        /**\n         * The vertex reached.\n         */\n        V vertex;\n\n        /**\n         * True once spanningTreeEdge is guaranteed to be the true minimum.\n         */\n        boolean frozen;\n\n        QueueEntry()\n        {\n        }\n    }\n}\n\n// End ClosestFirstIterator.java\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "PartiteRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "RandomGraphHelper",
                "org.jgrapht.experimental"
            ],
            [
                "GraphReader",
                "org.jgrapht.experimental"
            ],
            [
                "DirectedAcyclicGraph",
                "org.jgrapht.experimental.dag"
            ],
            [
                "GraphSquare",
                "org.jgrapht.experimental"
            ],
            [
                "UniformRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "GraphTests",
                "org.jgrapht.experimental"
            ],
            [
                "ApproximationAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "BrownBacktrackColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "GreedyColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "IntArrayGraphAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ExactAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ListenableGraph",
                "org.jgrapht"
            ],
            [
                "ModifiableInteger",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeapNode",
                "org.jgrapht.util"
            ],
            [
                "WeightCombiner",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeap",
                "org.jgrapht.util"
            ],
            [
                "TypeUtil",
                "org.jgrapht.util"
            ],
            [
                "ArrayUnenforcedSet",
                "org.jgrapht.util"
            ],
            [
                "VertexPair",
                "org.jgrapht.util"
            ],
            [
                "MathUtil",
                "org.jgrapht.util"
            ],
            [
                "PrefetchIterator",
                "org.jgrapht.util"
            ],
            [
                "VertexFactory",
                "org.jgrapht"
            ],
            [
                "Graph",
                "org.jgrapht"
            ],
            [
                "GraphPath",
                "org.jgrapht"
            ],
            [
                "UndirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraph",
                "org.jgrapht.graph"
            ],
            [
                "MixedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DefaultGraphMapping",
                "org.jgrapht.graph"
            ],
            [
                "WeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskEdgeSet",
                "org.jgrapht.graph"
            ],
            [
                "Pseudograph",
                "org.jgrapht.graph"
            ],
            [
                "MaskFunctor",
                "org.jgrapht.graph"
            ],
            [
                "GraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractBaseGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "Multigraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultWeightedEdge",
                "org.jgrapht.graph"
            ],
            [
                "ListenableDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeSetFactory",
                "org.jgrapht.graph"
            ],
            [
                "GraphDelegator",
                "org.jgrapht.graph"
            ],
            [
                "DefaultListenableGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedVertexFactory",
                "org.jgrapht.graph"
            ],
            [
                "DefaultEdge",
                "org.jgrapht.graph"
            ],
            [
                "MaskVertexSet",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "IntrusiveEdge",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphPathImpl",
                "org.jgrapht.graph"
            ],
            [
                "Subgraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractGraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedEdgeFactory",
                "org.jgrapht.graph"
            ],
            [
                "SimpleWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "WeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeReversedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "AbstractGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "ListenableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraphPath",
                "org.jgrapht.graph"
            ],
            [
                "ParanoidGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphHelper",
                "org.jgrapht"
            ],
            [
                "Graphs",
                "org.jgrapht"
            ],
            [
                "DirectedGraph",
                "org.jgrapht"
            ],
            [
                "WeightedGraph",
                "org.jgrapht"
            ],
            [
                "HyperCubeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RingGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WheelGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GridGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "ScaleFreeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedBipartiteGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "LinearGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RandomGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGeneratorAdapter",
                "org.jgrapht.generate"
            ],
            [
                "EmptyGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteBipartiteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "StarGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "UndirectedGraph",
                "org.jgrapht"
            ],
            [
                "TopologicalOrderIterator",
                "org.jgrapht.traverse"
            ],
            [
                "CrossComponentIterator",
                "org.jgrapht.traverse"
            ],
            [
                "AbstractGraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "ClosestFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "BreadthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "DepthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "GraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "EdgeFactory",
                "org.jgrapht"
            ],
            [
                "GraphMapping",
                "org.jgrapht"
            ],
            [
                "VertexSetListener",
                "org.jgrapht.event"
            ],
            [
                "EdgeTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "TraversalListener",
                "org.jgrapht.event"
            ],
            [
                "GraphEdgeChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "VertexTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphListener",
                "org.jgrapht.event"
            ],
            [
                "TraversalListenerAdapter",
                "org.jgrapht.event"
            ],
            [
                "ConnectedComponentTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphVertexChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "TarjanLowestCommonAncestor",
                "org.jgrapht.alg"
            ],
            [
                "PrimMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "BlockCutpointGraph",
                "org.jgrapht.alg"
            ],
            [
                "AllDirectedPaths",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPathsIterator",
                "org.jgrapht.alg"
            ],
            [
                "KruskalMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "StrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "VF2State",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2AbstractIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "GraphOrdering",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphicGraphMapping",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2MappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "BronKerboschCliqueFinder",
                "org.jgrapht.alg"
            ],
            [
                "ChromaticNumber",
                "org.jgrapht.alg"
            ],
            [
                "KosarajuStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "DijkstraShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElement",
                "org.jgrapht.alg"
            ],
            [
                "AStarShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordPathElement",
                "org.jgrapht.alg"
            ],
            [
                "FloydWarshallShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "UnionFind",
                "org.jgrapht.alg.util"
            ],
            [
                "AlwaysEqualComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Extension",
                "org.jgrapht.alg.util"
            ],
            [
                "VertexDegreeComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Pair",
                "org.jgrapht.alg.util"
            ],
            [
                "GabowStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "HawickJamesSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "DirectedSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "JohnsonSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TiernanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "UndirectedCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "PatonCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TarjanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "SzwarcfiterLauerSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "BiconnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "ConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "MinSourceSinkCut",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsBlossomShrinking",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveClosure",
                "org.jgrapht.alg"
            ],
            [
                "HopcroftKarpBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "StoerWagnerMinimumCut",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "KuhnMunkresMinimalWeightBipartitePerfectMatching",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveReduction",
                "org.jgrapht.alg"
            ],
            [
                "EulerianCircuit",
                "org.jgrapht.alg"
            ],
            [
                "DirectedNeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "NaiveLcaFinder",
                "org.jgrapht.alg"
            ],
            [
                "MaximumWeightBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "HamiltonianCycle",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "NeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "VertexCovers",
                "org.jgrapht.alg"
            ],
            [
                "CycleDetector",
                "org.jgrapht.alg"
            ],
            [
                "AStarAdmissibleHeuristic",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MinimumSpanningTree",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "WeightedMatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "StrongConnectivityAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MaximumFlowAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "CliqueMinimalSeparatorDecomposition",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordIterator",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElement",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "PushRelabelMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "MaximumFlowAlgorithmBase",
                "org.jgrapht.alg.flow"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "addVertices",
                "org.jgrapht.experimental",
                "RandomGraphHelper",
                "/**\n * .\n *\n * @param target\n * @param vertexFactory\n * @param numVertices\n *\n * @return vertices\n */\n@SuppressWarnings(\"unchecked\")\npublic static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices) {\n    Object[] vertices = new Object[numVertices];\n    for (int i = 0; i < numVertices; ++i) {\n        vertices[i] = vertexFactory.createVertex();\n        target.addVertex(vertices[i]);\n    }\n    return vertices;\n}"
            ],
            [
                "isEmpty",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isEmpty(Graph<V, E> g) {\n    return g.edgeSet().isEmpty();\n}"
            ],
            [
                "isComplete",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isComplete(Graph<V, E> g) {\n    int n = g.vertexSet().size();\n    return g.edgeSet().size() == (n * (n - 1) / 2);\n}"
            ],
            [
                "isConnected",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isConnected(Graph<V, E> g) {\n    int numVertices = g.vertexSet().size();\n    int numEdges = g.edgeSet().size();\n    if (numEdges < (numVertices - 1)) {\n        return false;\n    }\n    if ((numVertices < 2) || (numEdges > ((numVertices - 1) * (numVertices - 2) / 2))) {\n        return true;\n    }\n    Set<V> known = new HashSet<V>();\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = g.vertexSet().iterator().next();\n    // start with node 1\n    queue.add(v);\n    known.add(v);\n    while (!queue.isEmpty()) {\n        v = queue.removeFirst();\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            v = it.next();\n            if (!known.contains(v)) {\n                known.add(v);\n                queue.add(v);\n            }\n        }\n    }\n    return known.size() == numVertices;\n}"
            ],
            [
                "isTree",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isTree(Graph<V, E> g) {\n    return isConnected(g) && (g.edgeSet().size() == (g.vertexSet().size() - 1));\n}"
            ],
            [
                "isBipartite",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isBipartite(Graph<V, E> g) {\n    if ((4 * g.edgeSet().size()) > (g.vertexSet().size() * g.vertexSet().size())) {\n        return false;\n    }\n    if (isEmpty(g)) {\n        return true;\n    }\n    Set<V> unknown = new HashSet<V>(g.vertexSet());\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = unknown.iterator().next();\n    Set<V> odd = new HashSet<V>();\n    queue.add(v);\n    while (!unknown.isEmpty()) {\n        if (queue.isEmpty()) {\n            queue.add(unknown.iterator().next());\n        }\n        v = queue.removeFirst();\n        unknown.remove(v);\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            V n = it.next();\n            if (unknown.contains(n)) {\n                queue.add(n);\n                if (!odd.contains(v)) {\n                    odd.add(n);\n                }\n            } else if (!(odd.contains(v) ^ odd.contains(n))) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
            ],
            [
                "union",
                "org.jgrapht.util",
                "FibonacciHeap",
                "// size\n/**\n * Joins two Fibonacci heaps into a new one. No heap consolidation is\n * performed at this time. The two root lists are simply joined together.\n *\n * <p>Running time: O(1) actual</p>\n *\n * @param h1 first heap\n * @param h2 second heap\n *\n * @return new heap containing h1 and h2\n */\npublic static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2) {\n    FibonacciHeap<T> h = new FibonacciHeap<T>();\n    if ((h1 != null) && (h2 != null)) {\n        h.minNode = h1.minNode;\n        if (h.minNode != null) {\n            if (h2.minNode != null) {\n                h.minNode.right.left = h2.minNode.left;\n                h2.minNode.left.right = h.minNode.right;\n                h.minNode.right = h2.minNode;\n                h2.minNode.left = h.minNode;\n                if (h2.minNode.key < h1.minNode.key) {\n                    h.minNode = h2.minNode;\n                }\n            }\n        } else {\n            h.minNode = h2.minNode;\n        }\n        h.nNodes = h1.nNodes + h2.nNodes;\n    }\n    return h;\n}"
            ],
            [
                "uncheckedCast",
                "org.jgrapht.util",
                "TypeUtil",
                "/**\n * Casts an object to a type.\n *\n * @param o object to be cast\n * @param typeDecl conveys the target type information; the actual value is\n * unused and can be null since this is all just stupid compiler tricks\n *\n * @return the result of the cast\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl) {\n    return (T) o;\n}"
            ],
            [
                "factorial",
                "org.jgrapht.util",
                "MathUtil",
                "public static long factorial(int N) {\n    long multi = 1;\n    for (int i = 1; i <= N; i++) {\n        multi = multi * i;\n    }\n    return multi;\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graphs",
                "/**\n * Creates a new edge and adds it to the specified graph similarly to the\n * {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n *\n * @see Graph#addEdge(Object, Object)\n */\npublic static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    EdgeFactory<V, E> ef = g.getEdgeFactory();\n    E e = ef.createEdge(sourceVertex, targetVertex);\n    // we first create the edge and set the weight to make sure that\n    // listeners will see the correct weight upon addEdge.\n    assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n    ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n    return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new edge and adds it to the specified\n * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return g.addEdge(sourceVertex, targetVertex);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified edge to the graph, including its vertices if not\n * already included.\n *\n * @param targetGraph the graph for which the specified edge to be added.\n * @param sourceGraph the graph in which the specified edge is already\n * present\n * @param edge edge to add\n *\n * @return <tt>true</tt> if the target graph did not already contain the\n * specified edge.\n */\npublic static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge) {\n    V sourceVertex = sourceGraph.getEdgeSource(edge);\n    V targetVertex = sourceGraph.getEdgeTarget(edge);\n    targetGraph.addVertex(sourceVertex);\n    targetGraph.addVertex(targetVertex);\n    return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new weighted edge and adds it to the\n * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n * method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return addEdge(g, sourceVertex, targetVertex, weight);\n}"
            ],
            [
                "addGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all the vertices and all the edges of the specified source graph to\n * the specified destination graph. First all vertices of the source graph\n * are added to the destination graph. Then every edge of the source graph\n * is added to the destination graph. This method returns <code>true</code>\n * if the destination graph has been modified as a result of this operation,\n * otherwise it returns <code>false</code>.\n *\n * <p>The behavior of this operation is undefined if any of the specified\n * graphs is modified while operation is in progress.</p>\n *\n * @param destination the graph to which vertices and edges are added.\n * @param source the graph used as source for vertices and edges to add.\n *\n * @return <code>true</code> if and only if the destination graph has been\n * changed as a result of this operation.\n */\npublic static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source) {\n    boolean modified = addAllVertices(destination, source.vertexSet());\n    modified |= addAllEdges(destination, source, source.edgeSet());\n    return modified;\n}"
            ],
            [
                "addAllEdges",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds a subset of the edges of the specified source graph to the specified\n * destination graph. The behavior of this operation is undefined if either\n * of the graphs is modified while the operation is in progress. {@link\n * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n * be added automatically to the target graph.\n *\n * @param destination the graph to which edges are to be added\n * @param source the graph used as a source for edges to add\n * @param edges the edges to be added\n *\n * @return <tt>true</tt> if this graph changed as a result of the call\n */\npublic static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges) {\n    boolean modified = false;\n    for (E e : edges) {\n        V s = source.getEdgeSource(e);\n        V t = source.getEdgeTarget(e);\n        destination.addVertex(s);\n        destination.addVertex(t);\n        modified |= destination.addEdge(s, t, e);\n    }\n    return modified;\n}"
            ],
            [
                "addAllVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all of the specified vertices to the destination graph. The behavior\n * of this operation is undefined if the specified vertex collection is\n * modified while the operation is in progress. This method will invoke the\n * {@link Graph#addVertex(Object)} method.\n *\n * @param destination the graph to which edges are to be added\n * @param vertices the vertices to be added to the graph.\n *\n * @return <tt>true</tt> if graph changed as a result of the call\n *\n * @throws NullPointerException if the specified vertices contains one or\n * more null vertices, or if the specified vertex collection is <tt>\n * null</tt>.\n *\n * @see Graph#addVertex(Object)\n */\npublic static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices) {\n    boolean modified = false;\n    for (V v : vertices) {\n        modified |= destination.addVertex(v);\n    }\n    return modified;\n}"
            ],
            [
                "neighborListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the neighbors of a specified vertex.\n * If the graph is a multigraph vertices may appear more than once in the\n * returned list.\n *\n * @param g the graph to look for neighbors in.\n * @param vertex the vertex to get the neighbors of.\n *\n * @return a list of the vertices that are the neighbors of the specified\n * vertex.\n */\npublic static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex) {\n    List<V> neighbors = new ArrayList<V>();\n    for (E e : g.edgesOf(vertex)) {\n        neighbors.add(getOppositeVertex(g, e, vertex));\n    }\n    return neighbors;\n}"
            ],
            [
                "predecessorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct predecessors of a\n * specified vertex. If the graph is a multigraph, vertices may appear more\n * than once in the returned list.\n *\n * @param g the graph to look for predecessors in.\n * @param vertex the vertex to get the predecessors of.\n *\n * @return a list of the vertices that are the direct predecessors of the\n * specified vertex.\n */\npublic static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> predecessors = new ArrayList<V>();\n    Set<? extends E> edges = g.incomingEdgesOf(vertex);\n    for (E e : edges) {\n        predecessors.add(getOppositeVertex(g, e, vertex));\n    }\n    return predecessors;\n}"
            ],
            [
                "successorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct successors of a specified\n * vertex. If the graph is a multigraph vertices may appear more than once\n * in the returned list.\n *\n * @param g the graph to look for successors in.\n * @param vertex the vertex to get the successors of.\n *\n * @return a list of the vertices that are the direct successors of the\n * specified vertex.\n */\npublic static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> successors = new ArrayList<V>();\n    Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n    for (E e : edges) {\n        successors.add(getOppositeVertex(g, e, vertex));\n    }\n    return successors;\n}"
            ],
            [
                "undirectedGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns an undirected view of the specified graph. If the specified graph\n * is directed, returns an undirected view of it. If the specified graph is\n * already undirected, just returns it.\n *\n * @param g the graph for which an undirected view is to be returned.\n *\n * @return an undirected view of the specified graph, if it is directed, or\n * or the specified graph itself if it is already undirected.\n *\n * @throws IllegalArgumentException if the graph is neither DirectedGraph\n * nor UndirectedGraph.\n *\n * @see AsUndirectedGraph\n */\npublic static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n    } else if (g instanceof UndirectedGraph<?, ?>) {\n        return (UndirectedGraph<V, E>) g;\n    } else {\n        throw new IllegalArgumentException(\"Graph must be either DirectedGraph or UndirectedGraph\");\n    }\n}"
            ],
            [
                "testIncidence",
                "org.jgrapht",
                "Graphs",
                "/**\n * Tests whether an edge is incident to a vertex.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return true iff e is incident on v\n */\npublic static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v) {\n    return (g.getEdgeSource(e).equals(v)) || (g.getEdgeTarget(e).equals(v));\n}"
            ],
            [
                "getOppositeVertex",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the vertex opposite another vertex across an edge.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return vertex opposite to v across e\n */\npublic static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v) {\n    V source = g.getEdgeSource(e);\n    V target = g.getEdgeTarget(e);\n    if (v.equals(source)) {\n        return target;\n    } else if (v.equals(target)) {\n        return source;\n    } else {\n        throw new IllegalArgumentException(\"no such vertex: \" + v.toString());\n    }\n}"
            ],
            [
                "getPathVertexList",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the list of vertices visited by a path.\n *\n * @param path path of interest\n *\n * @return corresponding vertex list\n */\npublic static <V, E> List<V> getPathVertexList(GraphPath<V, E> path) {\n    Graph<V, E> g = path.getGraph();\n    List<V> list = new ArrayList<V>();\n    V v = path.getStartVertex();\n    list.add(v);\n    for (E e : path.getEdgeList()) {\n        v = getOppositeVertex(g, e, v);\n        list.add(v);\n    }\n    return list;\n}"
            ],
            [
                "range",
                "org.jgrapht.generate",
                "SimpleWeightedGraphMatrixGenerator",
                "///////////////////////////////////////////////////////////////////////////////////////////////\npublic static int[] range(final int from, final int to) {\n    int[] range = new int[to - from];\n    for (int i = from; i < to; ++i) {\n        range[i - from] = i;\n    }\n    return range;\n}"
            ],
            [
                "createGraphSpecifics",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "// -------------------------------------------------------------------------\n/**\n * @param <V>\n * @param <E>\n * @param g\n *\n * @return TODO Document me\n */\nstatic <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new DirectedSpecifics<V, E>((DirectedGraph<V, E>) g);\n    } else {\n        return new UndirectedSpecifics<V, E>(g);\n    }\n}"
            ],
            [
                "findGreedyChromaticNumber",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds the number of colors required for a greedy coloring of the graph.\n *\n * @param g an undirected graph to find the chromatic number of\n *\n * @return integer the approximate chromatic number from the greedy\n * algorithm\n */\npublic static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g) {\n    Map<Integer, Set<V>> coloredGroups = findGreedyColoredGroups(g);\n    return coloredGroups.keySet().size();\n}"
            ],
            [
                "findGreedyColoredGroups",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds a greedy coloring of the graph.\n *\n * @param g an undirected graph for which to find the coloring\n */\npublic static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g) {\n    // A copy of the graph is made, so that elements of the graph may be\n    // removed to carry out the algorithm\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // The Vertices will be sorted in decreasing order by degree, so that\n    // higher degree vertices have priority to be colored first\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    List<V> sortedVertices = new LinkedList<V>(sg.vertexSet());\n    Collections.sort(sortedVertices, comp);\n    Collections.reverse(sortedVertices);\n    int color;\n    // create a map which will hold color as key and Set<V> as value\n    Map<Integer, Set<V>> coloredGroups = new HashMap<Integer, Set<V>>();\n    // We'll attempt to color each vertex with a single color each\n    // iteration, and these vertices will be removed from the graph at the\n    // end of each iteration\n    for (color = 0; sg.vertexSet().size() > 0; color++) {\n        // This set will contain vertices that are colored with the\n        // current color of this iteration\n        Set<V> currentColor = new HashSet<V>();\n        for (Iterator<V> iter = sortedVertices.iterator(); iter.hasNext(); ) {\n            V v = iter.next();\n            // Add new vertices to be colored as long as they are not\n            // adjacent with any other vertex that has already been colored\n            // with the current color\n            boolean flag = true;\n            for (Iterator<V> innerIter = currentColor.iterator(); innerIter.hasNext(); ) {\n                V temp = innerIter.next();\n                if (sg.containsEdge(temp, v)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                currentColor.add(v);\n                iter.remove();\n            }\n        }\n        // Add all these vertices as a group for this color\n        coloredGroups.put(color, currentColor);\n        // Remove vertices from the graph and then repeat the process for\n        // the next iteration\n        sg.removeAllVertices(currentColor);\n    }\n    return coloredGroups;\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "BellmanFordShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by hops, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    BellmanFordShortestPath<V, E> alg = new BellmanFordShortestPath<V, E>(graph, startVertex);\n    return alg.getPathEdgeList(endVertex);\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "DijkstraShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by radius, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    DijkstraShortestPath<V, E> alg = new DijkstraShortestPath<V, E>(graph, startVertex, endVertex);\n    return alg.getPathEdgeList();\n}"
            ],
            [
                "of",
                "org.jgrapht.alg.util",
                "Pair",
                "/**\n * Creates new pair of elements pulling of the necessity to provide\n * corresponding types of the elements supplied\n *\n * @param a first element\n * @param b second element\n *\n * @return new pair\n */\npublic static <A, B> Pair<A, B> of(A a, B b) {\n    return new Pair<A, B>(a, b);\n}"
            ],
            [
                "isEulerian",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will check whether the graph passed in is Eulerian or not.\n *\n * @param g The graph to be checked\n *\n * @return true for Eulerian and false for non-Eulerian\n */\npublic static <V, E> boolean isEulerian(UndirectedGraph<V, E> g) {\n    // If the graph is not connected, then no Eulerian circuit exists\n    if (!(new ConnectivityInspector<V, E>(g)).isGraphConnected()) {\n        return false;\n    }\n    // A graph is Eulerian if and only if all vertices have even degree\n    // So, this code will check for that\n    Iterator<V> iter = g.vertexSet().iterator();\n    while (iter.hasNext()) {\n        V v = iter.next();\n        if ((g.degreeOf(v) % 2) == 1) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "getEulerianCircuitVertices",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will return a list of vertices which represents the Eulerian\n * circuit of the graph.\n *\n * @param g The graph to find an Eulerian circuit\n *\n * @return null if no Eulerian circuit exists, or a list of vertices\n * representing the Eulerian circuit if one does exist\n */\npublic static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g) {\n    // If the graph is not Eulerian then just return a null since no\n    // Eulerian circuit exists\n    if (!isEulerian(g)) {\n        return null;\n    }\n    // The circuit will be represented by a linked list\n    List<V> path = new LinkedList<V>();\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    path.add(sg.vertexSet().iterator().next());\n    // Algorithm for finding an Eulerian circuit Basically this will find an\n    // arbitrary circuit, then it will find another arbitrary circuit until\n    // every edge has been traversed\n    while (sg.edgeSet().size() > 0) {\n        V v = null;\n        // Find a vertex which has an edge that hasn't been traversed yet,\n        // and keep its index position in the circuit list\n        int index = 0;\n        for (Iterator<V> iter = path.iterator(); iter.hasNext(); index++) {\n            v = iter.next();\n            if (sg.degreeOf(v) > 0) {\n                break;\n            }\n        }\n        // Finds an arbitrary circuit of the current vertex and\n        // appends this into the circuit list\n        while (sg.degreeOf(v) > 0) {\n            for (Iterator<V> iter = sg.vertexSet().iterator(); iter.hasNext(); ) {\n                V temp = iter.next();\n                if (sg.containsEdge(v, temp)) {\n                    path.add(index, temp);\n                    sg.removeEdge(v, temp);\n                    v = temp;\n                    break;\n                }\n            }\n        }\n    }\n    return path;\n}"
            ],
            [
                "getApproximateOptimalForCompleteGraph",
                "org.jgrapht.alg",
                "HamiltonianCycle",
                "/**\n * This method will return an approximate minimal traveling salesman tour\n * (hamiltonian cycle). This algorithm requires that the graph be complete\n * and the triangle inequality exists (if x,y,z are vertices then\n * d(x,y)+d(y,z) &lt; d(x,z) for all x,y,z) then this algorithm will\n * guarantee a hamiltonian cycle such that the total weight of the cycle is\n * less than or equal to double the total weight of the optimal hamiltonian\n * cycle. The optimal solution is NP-complete, so this is a decent\n * approximation that runs in polynomial time.\n *\n * @param <V>\n * @param <E>\n * @param g is the graph to find the optimal tour for.\n *\n * @return The optimal tour as a list of vertices.\n */\npublic static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g) {\n    List<V> vertices = new LinkedList<V>(g.vertexSet());\n    // If the graph is not complete then return null since this algorithm\n    // requires the graph be complete\n    if ((vertices.size() * (vertices.size() - 1) / 2) != g.edgeSet().size()) {\n        return null;\n    }\n    List<V> tour = new LinkedList<V>();\n    // Each iteration a new vertex will be added to the tour until all\n    // vertices have been added\n    while (tour.size() != g.vertexSet().size()) {\n        boolean firstEdge = true;\n        double minEdgeValue = 0;\n        int minVertexFound = 0;\n        int vertexConnectedTo = 0;\n        // A check will be made for the shortest edge to a vertex not within\n        // the tour and that new vertex will be added to the vertex\n        for (int i = 0; i < tour.size(); i++) {\n            V v = tour.get(i);\n            for (int j = 0; j < vertices.size(); j++) {\n                double weight = g.getEdgeWeight(g.getEdge(v, vertices.get(j)));\n                if (firstEdge || (weight < minEdgeValue)) {\n                    firstEdge = false;\n                    minEdgeValue = weight;\n                    minVertexFound = j;\n                    vertexConnectedTo = i;\n                }\n            }\n        }\n        tour.add(vertexConnectedTo, vertices.get(minVertexFound));\n        vertices.remove(minVertexFound);\n    }\n    return tour;\n}"
            ],
            [
                "find2ApproximationCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a 2-approximation for a minimal vertex cover of the specified\n * graph. The algorithm promises a cover that is at most double the size of\n * a minimal cover. The algorithm takes O(|E|) time.\n *\n * <p>For more details see Jenny Walter, CMPU-240: Lecture notes for\n * Language Theory and Computation, Fall 2002, Vassar College, <a\n * href=\"http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf\">\n * http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf</a>.\n * </p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G'=(V',E') <-- G(V,E)\n    Subgraph<V, E, Graph<V, E>> sg = new Subgraph<V, E, Graph<V, E>>(g, null, null);\n    // while E' is non-empty\n    while (sg.edgeSet().size() > 0) {\n        // let (u,v) be an arbitrary edge of E'\n        E e = sg.edgeSet().iterator().next();\n        // C <-- C U {u,v}\n        V u = g.getEdgeSource(e);\n        V v = g.getEdgeTarget(e);\n        cover.add(u);\n        cover.add(v);\n        // remove from E' every edge incident on either u or v\n        sg.removeVertex(u);\n        sg.removeVertex(v);\n    }\n    // return C\n    return cover;\n}"
            ],
            [
                "findGreedyCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a greedy approximation for a minimal vertex cover of a specified\n * graph. At each iteration, the algorithm picks the vertex with the highest\n * degree and adds it to the cover, until all edges are covered.\n *\n * <p>The algorithm works on undirected graphs, but can also work on\n * directed graphs when their edge-directions are ignored. To ignore edge\n * directions you can use {@link org.jgrapht.Graphs#undirectedGraph(Graph)}\n * or {@link org.jgrapht.graph.AsUndirectedGraph}.</p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G' <-- G\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // compare vertices in descending order of degree\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    // while G' != {}\n    while (sg.edgeSet().size() > 0) {\n        // v <-- vertex with maximum degree in G'\n        V v = Collections.max(sg.vertexSet(), comp);\n        // C <-- C U {v}\n        cover.add(v);\n        // remove from G' every edge incident on v, and v itself\n        sg.removeVertex(v);\n    }\n    return cover;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "BEST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int BEST_ORDER = 0;"
            ],
            [
                "NATURAL_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int NATURAL_ORDER = 1;"
            ],
            [
                "SMALLEST_DEGREE_LAST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;"
            ],
            [
                "LARGEST_SATURATION_FIRST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;"
            ],
            [
                "DEFAULT_EDGE_WEIGHT",
                "org.jgrapht",
                "WeightedGraph",
                "/**\n * The default weight for an edge.\n */\npublic static double DEFAULT_EDGE_WEIGHT = 1.0;"
            ],
            [
                "HUB_VERTEX",
                "org.jgrapht.generate",
                "WheelGraphGenerator",
                "/**\n * Role for the hub vertex.\n */\npublic static final String HUB_VERTEX = \"Hub Vertex\";"
            ],
            [
                "CORNER_VERTEX",
                "org.jgrapht.generate",
                "GridGraphGenerator",
                "/**\n * Role for the vertices at the corners.\n */\npublic static final String CORNER_VERTEX = \"Corner Vertex\";"
            ],
            [
                "START_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the first vertex generated.\n */\npublic static final String START_VERTEX = \"Start Vertex\";"
            ],
            [
                "END_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the last vertex generated.\n */\npublic static final String END_VERTEX = \"End Vertex\";"
            ],
            [
                "CENTER_VERTEX",
                "org.jgrapht.generate",
                "StarGraphGenerator",
                "public static final String CENTER_VERTEX = \"Center Vertex\";"
            ],
            [
                "SENTINEL",
                "org.jgrapht.traverse",
                "DepthFirstIterator",
                "/**\n * Sentinel object. Unfortunately, we can't use null, because ArrayDeque\n * won't accept those. And we don't want to rely on the caller to provide a\n * sentinel object for us. So we have to play typecasting games.\n */\npublic static final Object SENTINEL = new Object();"
            ],
            [
                "BEFORE_EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge added event. This event is fired before an edge is added to a\n * graph.\n */\npublic static final int BEFORE_EDGE_ADDED = 21;"
            ],
            [
                "BEFORE_EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge removed event. This event is fired before an edge is removed\n * from a graph.\n */\npublic static final int BEFORE_EDGE_REMOVED = 22;"
            ],
            [
                "EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge added event. This event is fired after an edge is added to a graph.\n */\npublic static final int EDGE_ADDED = 23;"
            ],
            [
                "EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge removed event. This event is fired after an edge is removed from a\n * graph.\n */\npublic static final int EDGE_REMOVED = 24;"
            ],
            [
                "CONNECTED_COMPONENT_STARTED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal started event.\n */\npublic static final int CONNECTED_COMPONENT_STARTED = 31;"
            ],
            [
                "CONNECTED_COMPONENT_FINISHED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal finished event.\n */\npublic static final int CONNECTED_COMPONENT_FINISHED = 32;"
            ],
            [
                "BEFORE_VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex added event. This event is fired before a vertex is added\n * to a graph.\n */\npublic static final int BEFORE_VERTEX_ADDED = 11;"
            ],
            [
                "BEFORE_VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex removed event. This event is fired before a vertex is\n * removed from a graph.\n */\npublic static final int BEFORE_VERTEX_REMOVED = 12;"
            ],
            [
                "VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex added event. This event is fired after a vertex is added to a\n * graph.\n */\npublic static final int VERTEX_ADDED = 13;"
            ],
            [
                "VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex removed event. This event is fired after a vertex is removed from\n * a graph.\n */\npublic static final int VERTEX_REMOVED = 14;"
            ],
            [
                "NULL_NODE",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "public static final int NULL_NODE = -1;"
            ],
            [
                "DEBUG",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected static final boolean DEBUG = false;"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg",
                "EdmondsKarpMaximumFlow",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 0.000000001;"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveClosure",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveClosure INSTANCE = new TransitiveClosure();"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveReduction",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveReduction INSTANCE = new TransitiveReduction();"
            ],
            [
                "NEGATIVE_UNDIRECTED_EDGE",
                "org.jgrapht.alg",
                "BellmanFordIterator",
                "/**\n * Error message.\n */\nprotected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg.flow",
                "MaximumFlowAlgorithmBase",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 1e-9;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [
            [
                "vertex",
                "",
                "V"
            ],
            [
                "edge",
                "",
                "E"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "isConnectedComponentExhausted",
                "org.jgrapht.traverse",
                "ClosestFirstIterator",
                "/**\n * @see CrossComponentIterator#isConnectedComponentExhausted()\n */\n@Override\nprotected boolean isConnectedComponentExhausted() {\n    if (heap.size() == 0) {\n        return true;\n    } else {\n        if (heap.min().getKey() > radius) {\n            heap.clear();\n            return true;\n        } else {\n            return false;\n        }\n    }\n}"
            ],
            [
                "provideNextVertex",
                "org.jgrapht.traverse",
                "ClosestFirstIterator",
                "/**\n * @see CrossComponentIterator#provideNextVertex()\n */\n@Override\nprotected V provideNextVertex() {\n    FibonacciHeapNode<QueueEntry<V, E>> node = heap.removeMin();\n    node.getData().frozen = true;\n    return node.getData().vertex;\n}"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "getSpanningTreeEdge",
                "org.jgrapht.traverse",
                "ClosestFirstIterator",
                "/**\n * Get the spanning tree edge reaching a vertex which has been seen already\n * in this traversal. This edge is the last link in the shortest known path\n * between the start vertex and the requested vertex. If the vertex has\n * already been visited, then it is truly the minimum spanning tree edge;\n * otherwise, it is the best candidate seen so far.\n *\n * @param vertex the spanned vertex.\n *\n * @return the spanning tree edge, or null if the vertex either has not been\n * seen yet or is the start vertex.\n */\npublic E getSpanningTreeEdge(V vertex) {\n    FibonacciHeapNode<QueueEntry<V, E>> node = getSeenData(vertex);\n    if (node == null) {\n        return null;\n    }\n    return node.getData().spanningTreeEdge;\n}"
            ],
            [
                "putSeenData",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "protected D putSeenData(V arg0, D arg1)"
            ],
            [
                "isReuseEvents",
                "org.jgrapht.traverse",
                "AbstractGraphIterator",
                "public boolean isReuseEvents()"
            ],
            [
                "getGraph",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "public Graph<V, E> getGraph()"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "next",
                "java.util",
                "Iterator",
                "public abstract E next()"
            ],
            [
                "getSeenData",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "protected D getSeenData(V arg0)"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "hasNext",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "public boolean hasNext()"
            ],
            [
                "isCrossComponentTraversal",
                "org.jgrapht.traverse",
                "AbstractGraphIterator",
                "public boolean isCrossComponentTraversal()"
            ],
            [
                "getShortestPathLength",
                "org.jgrapht.traverse",
                "ClosestFirstIterator",
                "/**\n * Get the weighted length of the shortest path known to the given vertex.\n * If the vertex has already been visited, then it is truly the shortest\n * path length; otherwise, it is the best known upper bound.\n *\n * @param vertex vertex being sought from start vertex\n *\n * @return weighted length of shortest path known, or\n * Double.POSITIVE_INFINITY if no path found yet\n */\npublic double getShortestPathLength(V vertex) {\n    FibonacciHeapNode<QueueEntry<V, E>> node = getSeenData(vertex);\n    if (node == null) {\n        return Double.POSITIVE_INFINITY;\n    }\n    return node.getKey();\n}"
            ],
            [
                "isSeenVertex",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "protected boolean isSeenVertex(Object arg0)"
            ],
            [
                "next",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "public V next()"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [
            [
                "nListeners",
                "org.jgrapht.traverse",
                "AbstractGraphIterator",
                "protected int nListeners;"
            ]
        ],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 26197,
        "oracle": ";",
        "oracleType": "PRE",
        "projectName": "jgrapht-core-0.9.2",
        "packageName": "org.jgrapht.traverse",
        "className": "ClosestFirstIterator",
        "javadocTag": "@param vertex a vertex which has just been encountered.",
        "methodJavadoc": "    /**\n     * The first time we see a vertex, make up a new heap node for it.\n     *\n     * @param vertex a vertex which has just been encountered.\n     * @param edge the edge via which the vertex was encountered.\n     *\n     * @return the new heap node.\n     */",
        "methodSourceCode": "private FibonacciHeapNode<QueueEntry<V, E>> createSeenData(V vertex, E edge){\n    QueueEntry<V, E> entry = new QueueEntry<V, E>();\n    entry.vertex = vertex;\n    entry.spanningTreeEdge = edge;\n    return new FibonacciHeapNode<QueueEntry<V, E>>(entry);\n}",
        "classJavadoc": "/**\n * A closest-first iterator for a directed or undirected graph. For this\n * iterator to work correctly the graph must not be modified during iteration.\n * Currently there are no means to ensure that, nor to fail-fast. The results of\n * such modifications are undefined.\n *\n * <p>The metric for <i>closest</i> here is the weighted path length from a\n * start vertex, i.e. Graph.getEdgeWeight(Edge) is summed to calculate path\n * length. Negative edge weights will result in an IllegalArgumentException.\n * Optionally, path length may be bounded by a finite radius.</p>\n *\n * @author John V. Sichi\n * @since Sep 2, 2003\n */",
        "classSourceCode": "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------------\n * ClosestFirstIterator.java\n * -------------------------\n * (C) Copyright 2003-2008, by John V. Sichi and Contributors.\n *\n * Original Author:  John V. Sichi\n * Contributor(s):   Barak Naveh\n *\n * $Id$\n *\n * Changes\n * -------\n * 02-Sep-2003 : Initial revision (JVS);\n * 31-Jan-2004 : Reparented and changed interface to parent class (BN);\n * 29-May-2005 : Added radius support (JVS);\n * 06-Jun-2005 : Made generic (CH);\n *\n */\npackage org.jgrapht.traverse;\n\nimport org.jgrapht.*;\nimport org.jgrapht.util.*;\n\n\n/**\n * A closest-first iterator for a directed or undirected graph. For this\n * iterator to work correctly the graph must not be modified during iteration.\n * Currently there are no means to ensure that, nor to fail-fast. The results of\n * such modifications are undefined.\n *\n * <p>The metric for <i>closest</i> here is the weighted path length from a\n * start vertex, i.e. Graph.getEdgeWeight(Edge) is summed to calculate path\n * length. Negative edge weights will result in an IllegalArgumentException.\n * Optionally, path length may be bounded by a finite radius.</p>\n *\n * @author John V. Sichi\n * @since Sep 2, 2003\n */\npublic class ClosestFirstIterator<V, E>\n    extends CrossComponentIterator<V,\n        E, FibonacciHeapNode<ClosestFirstIterator.QueueEntry<V, E>>>\n{\n    /**\n     * Priority queue of fringe vertices.\n     */\n    private FibonacciHeap<QueueEntry<V, E>> heap =\n        new FibonacciHeap<QueueEntry<V, E>>();\n\n    /**\n     * Maximum distance to search.\n     */\n    private double radius = Double.POSITIVE_INFINITY;\n\n    private boolean initialized = false;\n\n    /**\n     * Creates a new closest-first iterator for the specified graph.\n     *\n     * @param g the graph to be iterated.\n     */\n    public ClosestFirstIterator(Graph<V, E> g)\n    {\n        this(g, null);\n    }\n\n    /**\n     * Creates a new closest-first iterator for the specified graph. Iteration\n     * will start at the specified start vertex and will be limited to the\n     * connected component that includes that vertex. If the specified start\n     * vertex is <code>null</code>, iteration will start at an arbitrary vertex\n     * and will not be limited, that is, will be able to traverse all the graph.\n     *\n     * @param g the graph to be iterated.\n     * @param startVertex the vertex iteration to be started.\n     */\n    public ClosestFirstIterator(Graph<V, E> g, V startVertex)\n    {\n        this(g, startVertex, Double.POSITIVE_INFINITY);\n    }\n\n    /**\n     * Creates a new radius-bounded closest-first iterator for the specified\n     * graph. Iteration will start at the specified start vertex and will be\n     * limited to the subset of the connected component which includes that\n     * vertex and is reachable via paths of weighted length less than or equal\n     * to the specified radius. The specified start vertex may not be <code>\n     * null</code>.\n     *\n     * @param g the graph to be iterated.\n     * @param startVertex the vertex iteration to be started.\n     * @param radius limit on weighted path length, or Double.POSITIVE_INFINITY\n     * for unbounded search.\n     */\n    public ClosestFirstIterator(Graph<V, E> g, V startVertex, double radius)\n    {\n        super(g, startVertex);\n        this.radius = radius;\n        checkRadiusTraversal(isCrossComponentTraversal());\n        initialized = true;\n    }\n\n    // override AbstractGraphIterator\n    @Override public void setCrossComponentTraversal(\n        boolean crossComponentTraversal)\n    {\n        if (initialized) {\n            checkRadiusTraversal(crossComponentTraversal);\n        }\n        super.setCrossComponentTraversal(crossComponentTraversal);\n    }\n\n    /**\n     * Get the weighted length of the shortest path known to the given vertex.\n     * If the vertex has already been visited, then it is truly the shortest\n     * path length; otherwise, it is the best known upper bound.\n     *\n     * @param vertex vertex being sought from start vertex\n     *\n     * @return weighted length of shortest path known, or\n     * Double.POSITIVE_INFINITY if no path found yet\n     */\n    public double getShortestPathLength(V vertex)\n    {\n        FibonacciHeapNode<QueueEntry<V, E>> node = getSeenData(vertex);\n\n        if (node == null) {\n            return Double.POSITIVE_INFINITY;\n        }\n\n        return node.getKey();\n    }\n\n    /**\n     * Get the spanning tree edge reaching a vertex which has been seen already\n     * in this traversal. This edge is the last link in the shortest known path\n     * between the start vertex and the requested vertex. If the vertex has\n     * already been visited, then it is truly the minimum spanning tree edge;\n     * otherwise, it is the best candidate seen so far.\n     *\n     * @param vertex the spanned vertex.\n     *\n     * @return the spanning tree edge, or null if the vertex either has not been\n     * seen yet or is the start vertex.\n     */\n    public E getSpanningTreeEdge(V vertex)\n    {\n        FibonacciHeapNode<QueueEntry<V, E>> node = getSeenData(vertex);\n\n        if (node == null) {\n            return null;\n        }\n\n        return node.getData().spanningTreeEdge;\n    }\n\n    /**\n     * @see CrossComponentIterator#isConnectedComponentExhausted()\n     */\n    @Override protected boolean isConnectedComponentExhausted()\n    {\n        if (heap.size() == 0) {\n            return true;\n        } else {\n            if (heap.min().getKey() > radius) {\n                heap.clear();\n\n                return true;\n            } else {\n                return false;\n            }\n        }\n    }\n\n    /**\n     * @see CrossComponentIterator#encounterVertex(Object, Object)\n     */\n    @Override protected void encounterVertex(V vertex, E edge)\n    {\n        double shortestPathLength;\n        if (edge == null) {\n            shortestPathLength = 0;\n        } else {\n            shortestPathLength = calculatePathLength(vertex, edge);\n        }\n        FibonacciHeapNode<QueueEntry<V, E>> node = createSeenData(vertex, edge);\n        putSeenData(vertex, node);\n        heap.insert(node, shortestPathLength);\n    }\n\n    /**\n     * Override superclass. When we see a vertex again, we need to see if the\n     * new edge provides a shorter path than the old edge.\n     *\n     * @param vertex the vertex re-encountered\n     * @param edge the edge via which the vertex was re-encountered\n     */\n    @Override protected void encounterVertexAgain(V vertex, E edge)\n    {\n        FibonacciHeapNode<QueueEntry<V, E>> node = getSeenData(vertex);\n\n        if (node.getData().frozen) {\n            // no improvement for this vertex possible\n            return;\n        }\n\n        double candidatePathLength = calculatePathLength(vertex, edge);\n\n        if (candidatePathLength < node.getKey()) {\n            node.getData().spanningTreeEdge = edge;\n            heap.decreaseKey(node, candidatePathLength);\n        }\n    }\n\n    /**\n     * @see CrossComponentIterator#provideNextVertex()\n     */\n    @Override protected V provideNextVertex()\n    {\n        FibonacciHeapNode<QueueEntry<V, E>> node = heap.removeMin();\n        node.getData().frozen = true;\n\n        return node.getData().vertex;\n    }\n\n    private void assertNonNegativeEdge(E edge)\n    {\n        if (getGraph().getEdgeWeight(edge) < 0) {\n            throw new IllegalArgumentException(\n                \"negative edge weights not allowed\");\n        }\n    }\n\n    /**\n     * Determine weighted path length to a vertex via an edge, using the path\n     * length for the opposite vertex.\n     *\n     * @param vertex the vertex for which to calculate the path length.\n     * @param edge the edge via which the path is being extended.\n     *\n     * @return calculated path length.\n     */\n    private double calculatePathLength(V vertex, E edge)\n    {\n        assertNonNegativeEdge(edge);\n\n        V otherVertex = Graphs.getOppositeVertex(getGraph(), edge, vertex);\n        FibonacciHeapNode<QueueEntry<V, E>> otherEntry =\n            getSeenData(otherVertex);\n\n        return otherEntry.getKey()\n            + getGraph().getEdgeWeight(edge);\n    }\n\n    private void checkRadiusTraversal(boolean crossComponentTraversal)\n    {\n        if (crossComponentTraversal && (radius != Double.POSITIVE_INFINITY)) {\n            throw new IllegalArgumentException(\n                \"radius may not be specified for cross-component traversal\");\n        }\n    }\n\n    /**\n     * The first time we see a vertex, make up a new heap node for it.\n     *\n     * @param vertex a vertex which has just been encountered.\n     * @param edge the edge via which the vertex was encountered.\n     *\n     * @return the new heap node.\n     */\n    private FibonacciHeapNode<QueueEntry<V, E>> createSeenData(\n        V vertex,\n        E edge)\n    {\n        QueueEntry<V, E> entry = new QueueEntry<V, E>();\n        entry.vertex = vertex;\n        entry.spanningTreeEdge = edge;\n\n        return new FibonacciHeapNode<QueueEntry<V, E>>(entry);\n    }\n\n    /**\n     * Private data to associate with each entry in the priority queue.\n     */\n    static class QueueEntry<V, E>\n    {\n        /**\n         * Best spanning tree edge to vertex seen so far.\n         */\n        E spanningTreeEdge;\n\n        /**\n         * The vertex reached.\n         */\n        V vertex;\n\n        /**\n         * True once spanningTreeEdge is guaranteed to be the true minimum.\n         */\n        boolean frozen;\n\n        QueueEntry()\n        {\n        }\n    }\n}\n\n// End ClosestFirstIterator.java\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "PartiteRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "RandomGraphHelper",
                "org.jgrapht.experimental"
            ],
            [
                "GraphReader",
                "org.jgrapht.experimental"
            ],
            [
                "DirectedAcyclicGraph",
                "org.jgrapht.experimental.dag"
            ],
            [
                "GraphSquare",
                "org.jgrapht.experimental"
            ],
            [
                "UniformRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "GraphTests",
                "org.jgrapht.experimental"
            ],
            [
                "ApproximationAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "BrownBacktrackColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "GreedyColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "IntArrayGraphAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ExactAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ListenableGraph",
                "org.jgrapht"
            ],
            [
                "ModifiableInteger",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeapNode",
                "org.jgrapht.util"
            ],
            [
                "WeightCombiner",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeap",
                "org.jgrapht.util"
            ],
            [
                "TypeUtil",
                "org.jgrapht.util"
            ],
            [
                "ArrayUnenforcedSet",
                "org.jgrapht.util"
            ],
            [
                "VertexPair",
                "org.jgrapht.util"
            ],
            [
                "MathUtil",
                "org.jgrapht.util"
            ],
            [
                "PrefetchIterator",
                "org.jgrapht.util"
            ],
            [
                "VertexFactory",
                "org.jgrapht"
            ],
            [
                "Graph",
                "org.jgrapht"
            ],
            [
                "GraphPath",
                "org.jgrapht"
            ],
            [
                "UndirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraph",
                "org.jgrapht.graph"
            ],
            [
                "MixedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DefaultGraphMapping",
                "org.jgrapht.graph"
            ],
            [
                "WeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskEdgeSet",
                "org.jgrapht.graph"
            ],
            [
                "Pseudograph",
                "org.jgrapht.graph"
            ],
            [
                "MaskFunctor",
                "org.jgrapht.graph"
            ],
            [
                "GraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractBaseGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "Multigraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultWeightedEdge",
                "org.jgrapht.graph"
            ],
            [
                "ListenableDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeSetFactory",
                "org.jgrapht.graph"
            ],
            [
                "GraphDelegator",
                "org.jgrapht.graph"
            ],
            [
                "DefaultListenableGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedVertexFactory",
                "org.jgrapht.graph"
            ],
            [
                "DefaultEdge",
                "org.jgrapht.graph"
            ],
            [
                "MaskVertexSet",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "IntrusiveEdge",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphPathImpl",
                "org.jgrapht.graph"
            ],
            [
                "Subgraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractGraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedEdgeFactory",
                "org.jgrapht.graph"
            ],
            [
                "SimpleWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "WeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeReversedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "AbstractGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "ListenableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraphPath",
                "org.jgrapht.graph"
            ],
            [
                "ParanoidGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphHelper",
                "org.jgrapht"
            ],
            [
                "Graphs",
                "org.jgrapht"
            ],
            [
                "DirectedGraph",
                "org.jgrapht"
            ],
            [
                "WeightedGraph",
                "org.jgrapht"
            ],
            [
                "HyperCubeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RingGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WheelGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GridGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "ScaleFreeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedBipartiteGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "LinearGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RandomGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGeneratorAdapter",
                "org.jgrapht.generate"
            ],
            [
                "EmptyGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteBipartiteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "StarGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "UndirectedGraph",
                "org.jgrapht"
            ],
            [
                "TopologicalOrderIterator",
                "org.jgrapht.traverse"
            ],
            [
                "CrossComponentIterator",
                "org.jgrapht.traverse"
            ],
            [
                "AbstractGraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "ClosestFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "BreadthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "DepthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "GraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "EdgeFactory",
                "org.jgrapht"
            ],
            [
                "GraphMapping",
                "org.jgrapht"
            ],
            [
                "VertexSetListener",
                "org.jgrapht.event"
            ],
            [
                "EdgeTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "TraversalListener",
                "org.jgrapht.event"
            ],
            [
                "GraphEdgeChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "VertexTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphListener",
                "org.jgrapht.event"
            ],
            [
                "TraversalListenerAdapter",
                "org.jgrapht.event"
            ],
            [
                "ConnectedComponentTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphVertexChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "TarjanLowestCommonAncestor",
                "org.jgrapht.alg"
            ],
            [
                "PrimMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "BlockCutpointGraph",
                "org.jgrapht.alg"
            ],
            [
                "AllDirectedPaths",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPathsIterator",
                "org.jgrapht.alg"
            ],
            [
                "KruskalMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "StrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "VF2State",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2AbstractIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "GraphOrdering",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphicGraphMapping",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2MappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "BronKerboschCliqueFinder",
                "org.jgrapht.alg"
            ],
            [
                "ChromaticNumber",
                "org.jgrapht.alg"
            ],
            [
                "KosarajuStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "DijkstraShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElement",
                "org.jgrapht.alg"
            ],
            [
                "AStarShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordPathElement",
                "org.jgrapht.alg"
            ],
            [
                "FloydWarshallShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "UnionFind",
                "org.jgrapht.alg.util"
            ],
            [
                "AlwaysEqualComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Extension",
                "org.jgrapht.alg.util"
            ],
            [
                "VertexDegreeComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Pair",
                "org.jgrapht.alg.util"
            ],
            [
                "GabowStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "HawickJamesSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "DirectedSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "JohnsonSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TiernanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "UndirectedCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "PatonCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TarjanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "SzwarcfiterLauerSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "BiconnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "ConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "MinSourceSinkCut",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsBlossomShrinking",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveClosure",
                "org.jgrapht.alg"
            ],
            [
                "HopcroftKarpBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "StoerWagnerMinimumCut",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "KuhnMunkresMinimalWeightBipartitePerfectMatching",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveReduction",
                "org.jgrapht.alg"
            ],
            [
                "EulerianCircuit",
                "org.jgrapht.alg"
            ],
            [
                "DirectedNeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "NaiveLcaFinder",
                "org.jgrapht.alg"
            ],
            [
                "MaximumWeightBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "HamiltonianCycle",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "NeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "VertexCovers",
                "org.jgrapht.alg"
            ],
            [
                "CycleDetector",
                "org.jgrapht.alg"
            ],
            [
                "AStarAdmissibleHeuristic",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MinimumSpanningTree",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "WeightedMatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "StrongConnectivityAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MaximumFlowAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "CliqueMinimalSeparatorDecomposition",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordIterator",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElement",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "PushRelabelMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "MaximumFlowAlgorithmBase",
                "org.jgrapht.alg.flow"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "addVertices",
                "org.jgrapht.experimental",
                "RandomGraphHelper",
                "/**\n * .\n *\n * @param target\n * @param vertexFactory\n * @param numVertices\n *\n * @return vertices\n */\n@SuppressWarnings(\"unchecked\")\npublic static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices) {\n    Object[] vertices = new Object[numVertices];\n    for (int i = 0; i < numVertices; ++i) {\n        vertices[i] = vertexFactory.createVertex();\n        target.addVertex(vertices[i]);\n    }\n    return vertices;\n}"
            ],
            [
                "isEmpty",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isEmpty(Graph<V, E> g) {\n    return g.edgeSet().isEmpty();\n}"
            ],
            [
                "isComplete",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isComplete(Graph<V, E> g) {\n    int n = g.vertexSet().size();\n    return g.edgeSet().size() == (n * (n - 1) / 2);\n}"
            ],
            [
                "isConnected",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isConnected(Graph<V, E> g) {\n    int numVertices = g.vertexSet().size();\n    int numEdges = g.edgeSet().size();\n    if (numEdges < (numVertices - 1)) {\n        return false;\n    }\n    if ((numVertices < 2) || (numEdges > ((numVertices - 1) * (numVertices - 2) / 2))) {\n        return true;\n    }\n    Set<V> known = new HashSet<V>();\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = g.vertexSet().iterator().next();\n    // start with node 1\n    queue.add(v);\n    known.add(v);\n    while (!queue.isEmpty()) {\n        v = queue.removeFirst();\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            v = it.next();\n            if (!known.contains(v)) {\n                known.add(v);\n                queue.add(v);\n            }\n        }\n    }\n    return known.size() == numVertices;\n}"
            ],
            [
                "isTree",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isTree(Graph<V, E> g) {\n    return isConnected(g) && (g.edgeSet().size() == (g.vertexSet().size() - 1));\n}"
            ],
            [
                "isBipartite",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isBipartite(Graph<V, E> g) {\n    if ((4 * g.edgeSet().size()) > (g.vertexSet().size() * g.vertexSet().size())) {\n        return false;\n    }\n    if (isEmpty(g)) {\n        return true;\n    }\n    Set<V> unknown = new HashSet<V>(g.vertexSet());\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = unknown.iterator().next();\n    Set<V> odd = new HashSet<V>();\n    queue.add(v);\n    while (!unknown.isEmpty()) {\n        if (queue.isEmpty()) {\n            queue.add(unknown.iterator().next());\n        }\n        v = queue.removeFirst();\n        unknown.remove(v);\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            V n = it.next();\n            if (unknown.contains(n)) {\n                queue.add(n);\n                if (!odd.contains(v)) {\n                    odd.add(n);\n                }\n            } else if (!(odd.contains(v) ^ odd.contains(n))) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
            ],
            [
                "union",
                "org.jgrapht.util",
                "FibonacciHeap",
                "// size\n/**\n * Joins two Fibonacci heaps into a new one. No heap consolidation is\n * performed at this time. The two root lists are simply joined together.\n *\n * <p>Running time: O(1) actual</p>\n *\n * @param h1 first heap\n * @param h2 second heap\n *\n * @return new heap containing h1 and h2\n */\npublic static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2) {\n    FibonacciHeap<T> h = new FibonacciHeap<T>();\n    if ((h1 != null) && (h2 != null)) {\n        h.minNode = h1.minNode;\n        if (h.minNode != null) {\n            if (h2.minNode != null) {\n                h.minNode.right.left = h2.minNode.left;\n                h2.minNode.left.right = h.minNode.right;\n                h.minNode.right = h2.minNode;\n                h2.minNode.left = h.minNode;\n                if (h2.minNode.key < h1.minNode.key) {\n                    h.minNode = h2.minNode;\n                }\n            }\n        } else {\n            h.minNode = h2.minNode;\n        }\n        h.nNodes = h1.nNodes + h2.nNodes;\n    }\n    return h;\n}"
            ],
            [
                "uncheckedCast",
                "org.jgrapht.util",
                "TypeUtil",
                "/**\n * Casts an object to a type.\n *\n * @param o object to be cast\n * @param typeDecl conveys the target type information; the actual value is\n * unused and can be null since this is all just stupid compiler tricks\n *\n * @return the result of the cast\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl) {\n    return (T) o;\n}"
            ],
            [
                "factorial",
                "org.jgrapht.util",
                "MathUtil",
                "public static long factorial(int N) {\n    long multi = 1;\n    for (int i = 1; i <= N; i++) {\n        multi = multi * i;\n    }\n    return multi;\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graphs",
                "/**\n * Creates a new edge and adds it to the specified graph similarly to the\n * {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n *\n * @see Graph#addEdge(Object, Object)\n */\npublic static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    EdgeFactory<V, E> ef = g.getEdgeFactory();\n    E e = ef.createEdge(sourceVertex, targetVertex);\n    // we first create the edge and set the weight to make sure that\n    // listeners will see the correct weight upon addEdge.\n    assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n    ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n    return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new edge and adds it to the specified\n * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return g.addEdge(sourceVertex, targetVertex);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified edge to the graph, including its vertices if not\n * already included.\n *\n * @param targetGraph the graph for which the specified edge to be added.\n * @param sourceGraph the graph in which the specified edge is already\n * present\n * @param edge edge to add\n *\n * @return <tt>true</tt> if the target graph did not already contain the\n * specified edge.\n */\npublic static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge) {\n    V sourceVertex = sourceGraph.getEdgeSource(edge);\n    V targetVertex = sourceGraph.getEdgeTarget(edge);\n    targetGraph.addVertex(sourceVertex);\n    targetGraph.addVertex(targetVertex);\n    return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new weighted edge and adds it to the\n * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n * method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return addEdge(g, sourceVertex, targetVertex, weight);\n}"
            ],
            [
                "addGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all the vertices and all the edges of the specified source graph to\n * the specified destination graph. First all vertices of the source graph\n * are added to the destination graph. Then every edge of the source graph\n * is added to the destination graph. This method returns <code>true</code>\n * if the destination graph has been modified as a result of this operation,\n * otherwise it returns <code>false</code>.\n *\n * <p>The behavior of this operation is undefined if any of the specified\n * graphs is modified while operation is in progress.</p>\n *\n * @param destination the graph to which vertices and edges are added.\n * @param source the graph used as source for vertices and edges to add.\n *\n * @return <code>true</code> if and only if the destination graph has been\n * changed as a result of this operation.\n */\npublic static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source) {\n    boolean modified = addAllVertices(destination, source.vertexSet());\n    modified |= addAllEdges(destination, source, source.edgeSet());\n    return modified;\n}"
            ],
            [
                "addAllEdges",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds a subset of the edges of the specified source graph to the specified\n * destination graph. The behavior of this operation is undefined if either\n * of the graphs is modified while the operation is in progress. {@link\n * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n * be added automatically to the target graph.\n *\n * @param destination the graph to which edges are to be added\n * @param source the graph used as a source for edges to add\n * @param edges the edges to be added\n *\n * @return <tt>true</tt> if this graph changed as a result of the call\n */\npublic static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges) {\n    boolean modified = false;\n    for (E e : edges) {\n        V s = source.getEdgeSource(e);\n        V t = source.getEdgeTarget(e);\n        destination.addVertex(s);\n        destination.addVertex(t);\n        modified |= destination.addEdge(s, t, e);\n    }\n    return modified;\n}"
            ],
            [
                "addAllVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all of the specified vertices to the destination graph. The behavior\n * of this operation is undefined if the specified vertex collection is\n * modified while the operation is in progress. This method will invoke the\n * {@link Graph#addVertex(Object)} method.\n *\n * @param destination the graph to which edges are to be added\n * @param vertices the vertices to be added to the graph.\n *\n * @return <tt>true</tt> if graph changed as a result of the call\n *\n * @throws NullPointerException if the specified vertices contains one or\n * more null vertices, or if the specified vertex collection is <tt>\n * null</tt>.\n *\n * @see Graph#addVertex(Object)\n */\npublic static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices) {\n    boolean modified = false;\n    for (V v : vertices) {\n        modified |= destination.addVertex(v);\n    }\n    return modified;\n}"
            ],
            [
                "neighborListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the neighbors of a specified vertex.\n * If the graph is a multigraph vertices may appear more than once in the\n * returned list.\n *\n * @param g the graph to look for neighbors in.\n * @param vertex the vertex to get the neighbors of.\n *\n * @return a list of the vertices that are the neighbors of the specified\n * vertex.\n */\npublic static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex) {\n    List<V> neighbors = new ArrayList<V>();\n    for (E e : g.edgesOf(vertex)) {\n        neighbors.add(getOppositeVertex(g, e, vertex));\n    }\n    return neighbors;\n}"
            ],
            [
                "predecessorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct predecessors of a\n * specified vertex. If the graph is a multigraph, vertices may appear more\n * than once in the returned list.\n *\n * @param g the graph to look for predecessors in.\n * @param vertex the vertex to get the predecessors of.\n *\n * @return a list of the vertices that are the direct predecessors of the\n * specified vertex.\n */\npublic static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> predecessors = new ArrayList<V>();\n    Set<? extends E> edges = g.incomingEdgesOf(vertex);\n    for (E e : edges) {\n        predecessors.add(getOppositeVertex(g, e, vertex));\n    }\n    return predecessors;\n}"
            ],
            [
                "successorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct successors of a specified\n * vertex. If the graph is a multigraph vertices may appear more than once\n * in the returned list.\n *\n * @param g the graph to look for successors in.\n * @param vertex the vertex to get the successors of.\n *\n * @return a list of the vertices that are the direct successors of the\n * specified vertex.\n */\npublic static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> successors = new ArrayList<V>();\n    Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n    for (E e : edges) {\n        successors.add(getOppositeVertex(g, e, vertex));\n    }\n    return successors;\n}"
            ],
            [
                "undirectedGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns an undirected view of the specified graph. If the specified graph\n * is directed, returns an undirected view of it. If the specified graph is\n * already undirected, just returns it.\n *\n * @param g the graph for which an undirected view is to be returned.\n *\n * @return an undirected view of the specified graph, if it is directed, or\n * or the specified graph itself if it is already undirected.\n *\n * @throws IllegalArgumentException if the graph is neither DirectedGraph\n * nor UndirectedGraph.\n *\n * @see AsUndirectedGraph\n */\npublic static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n    } else if (g instanceof UndirectedGraph<?, ?>) {\n        return (UndirectedGraph<V, E>) g;\n    } else {\n        throw new IllegalArgumentException(\"Graph must be either DirectedGraph or UndirectedGraph\");\n    }\n}"
            ],
            [
                "testIncidence",
                "org.jgrapht",
                "Graphs",
                "/**\n * Tests whether an edge is incident to a vertex.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return true iff e is incident on v\n */\npublic static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v) {\n    return (g.getEdgeSource(e).equals(v)) || (g.getEdgeTarget(e).equals(v));\n}"
            ],
            [
                "getOppositeVertex",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the vertex opposite another vertex across an edge.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return vertex opposite to v across e\n */\npublic static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v) {\n    V source = g.getEdgeSource(e);\n    V target = g.getEdgeTarget(e);\n    if (v.equals(source)) {\n        return target;\n    } else if (v.equals(target)) {\n        return source;\n    } else {\n        throw new IllegalArgumentException(\"no such vertex: \" + v.toString());\n    }\n}"
            ],
            [
                "getPathVertexList",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the list of vertices visited by a path.\n *\n * @param path path of interest\n *\n * @return corresponding vertex list\n */\npublic static <V, E> List<V> getPathVertexList(GraphPath<V, E> path) {\n    Graph<V, E> g = path.getGraph();\n    List<V> list = new ArrayList<V>();\n    V v = path.getStartVertex();\n    list.add(v);\n    for (E e : path.getEdgeList()) {\n        v = getOppositeVertex(g, e, v);\n        list.add(v);\n    }\n    return list;\n}"
            ],
            [
                "range",
                "org.jgrapht.generate",
                "SimpleWeightedGraphMatrixGenerator",
                "///////////////////////////////////////////////////////////////////////////////////////////////\npublic static int[] range(final int from, final int to) {\n    int[] range = new int[to - from];\n    for (int i = from; i < to; ++i) {\n        range[i - from] = i;\n    }\n    return range;\n}"
            ],
            [
                "createGraphSpecifics",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "// -------------------------------------------------------------------------\n/**\n * @param <V>\n * @param <E>\n * @param g\n *\n * @return TODO Document me\n */\nstatic <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new DirectedSpecifics<V, E>((DirectedGraph<V, E>) g);\n    } else {\n        return new UndirectedSpecifics<V, E>(g);\n    }\n}"
            ],
            [
                "findGreedyChromaticNumber",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds the number of colors required for a greedy coloring of the graph.\n *\n * @param g an undirected graph to find the chromatic number of\n *\n * @return integer the approximate chromatic number from the greedy\n * algorithm\n */\npublic static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g) {\n    Map<Integer, Set<V>> coloredGroups = findGreedyColoredGroups(g);\n    return coloredGroups.keySet().size();\n}"
            ],
            [
                "findGreedyColoredGroups",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds a greedy coloring of the graph.\n *\n * @param g an undirected graph for which to find the coloring\n */\npublic static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g) {\n    // A copy of the graph is made, so that elements of the graph may be\n    // removed to carry out the algorithm\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // The Vertices will be sorted in decreasing order by degree, so that\n    // higher degree vertices have priority to be colored first\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    List<V> sortedVertices = new LinkedList<V>(sg.vertexSet());\n    Collections.sort(sortedVertices, comp);\n    Collections.reverse(sortedVertices);\n    int color;\n    // create a map which will hold color as key and Set<V> as value\n    Map<Integer, Set<V>> coloredGroups = new HashMap<Integer, Set<V>>();\n    // We'll attempt to color each vertex with a single color each\n    // iteration, and these vertices will be removed from the graph at the\n    // end of each iteration\n    for (color = 0; sg.vertexSet().size() > 0; color++) {\n        // This set will contain vertices that are colored with the\n        // current color of this iteration\n        Set<V> currentColor = new HashSet<V>();\n        for (Iterator<V> iter = sortedVertices.iterator(); iter.hasNext(); ) {\n            V v = iter.next();\n            // Add new vertices to be colored as long as they are not\n            // adjacent with any other vertex that has already been colored\n            // with the current color\n            boolean flag = true;\n            for (Iterator<V> innerIter = currentColor.iterator(); innerIter.hasNext(); ) {\n                V temp = innerIter.next();\n                if (sg.containsEdge(temp, v)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                currentColor.add(v);\n                iter.remove();\n            }\n        }\n        // Add all these vertices as a group for this color\n        coloredGroups.put(color, currentColor);\n        // Remove vertices from the graph and then repeat the process for\n        // the next iteration\n        sg.removeAllVertices(currentColor);\n    }\n    return coloredGroups;\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "BellmanFordShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by hops, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    BellmanFordShortestPath<V, E> alg = new BellmanFordShortestPath<V, E>(graph, startVertex);\n    return alg.getPathEdgeList(endVertex);\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "DijkstraShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by radius, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    DijkstraShortestPath<V, E> alg = new DijkstraShortestPath<V, E>(graph, startVertex, endVertex);\n    return alg.getPathEdgeList();\n}"
            ],
            [
                "of",
                "org.jgrapht.alg.util",
                "Pair",
                "/**\n * Creates new pair of elements pulling of the necessity to provide\n * corresponding types of the elements supplied\n *\n * @param a first element\n * @param b second element\n *\n * @return new pair\n */\npublic static <A, B> Pair<A, B> of(A a, B b) {\n    return new Pair<A, B>(a, b);\n}"
            ],
            [
                "isEulerian",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will check whether the graph passed in is Eulerian or not.\n *\n * @param g The graph to be checked\n *\n * @return true for Eulerian and false for non-Eulerian\n */\npublic static <V, E> boolean isEulerian(UndirectedGraph<V, E> g) {\n    // If the graph is not connected, then no Eulerian circuit exists\n    if (!(new ConnectivityInspector<V, E>(g)).isGraphConnected()) {\n        return false;\n    }\n    // A graph is Eulerian if and only if all vertices have even degree\n    // So, this code will check for that\n    Iterator<V> iter = g.vertexSet().iterator();\n    while (iter.hasNext()) {\n        V v = iter.next();\n        if ((g.degreeOf(v) % 2) == 1) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "getEulerianCircuitVertices",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will return a list of vertices which represents the Eulerian\n * circuit of the graph.\n *\n * @param g The graph to find an Eulerian circuit\n *\n * @return null if no Eulerian circuit exists, or a list of vertices\n * representing the Eulerian circuit if one does exist\n */\npublic static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g) {\n    // If the graph is not Eulerian then just return a null since no\n    // Eulerian circuit exists\n    if (!isEulerian(g)) {\n        return null;\n    }\n    // The circuit will be represented by a linked list\n    List<V> path = new LinkedList<V>();\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    path.add(sg.vertexSet().iterator().next());\n    // Algorithm for finding an Eulerian circuit Basically this will find an\n    // arbitrary circuit, then it will find another arbitrary circuit until\n    // every edge has been traversed\n    while (sg.edgeSet().size() > 0) {\n        V v = null;\n        // Find a vertex which has an edge that hasn't been traversed yet,\n        // and keep its index position in the circuit list\n        int index = 0;\n        for (Iterator<V> iter = path.iterator(); iter.hasNext(); index++) {\n            v = iter.next();\n            if (sg.degreeOf(v) > 0) {\n                break;\n            }\n        }\n        // Finds an arbitrary circuit of the current vertex and\n        // appends this into the circuit list\n        while (sg.degreeOf(v) > 0) {\n            for (Iterator<V> iter = sg.vertexSet().iterator(); iter.hasNext(); ) {\n                V temp = iter.next();\n                if (sg.containsEdge(v, temp)) {\n                    path.add(index, temp);\n                    sg.removeEdge(v, temp);\n                    v = temp;\n                    break;\n                }\n            }\n        }\n    }\n    return path;\n}"
            ],
            [
                "getApproximateOptimalForCompleteGraph",
                "org.jgrapht.alg",
                "HamiltonianCycle",
                "/**\n * This method will return an approximate minimal traveling salesman tour\n * (hamiltonian cycle). This algorithm requires that the graph be complete\n * and the triangle inequality exists (if x,y,z are vertices then\n * d(x,y)+d(y,z) &lt; d(x,z) for all x,y,z) then this algorithm will\n * guarantee a hamiltonian cycle such that the total weight of the cycle is\n * less than or equal to double the total weight of the optimal hamiltonian\n * cycle. The optimal solution is NP-complete, so this is a decent\n * approximation that runs in polynomial time.\n *\n * @param <V>\n * @param <E>\n * @param g is the graph to find the optimal tour for.\n *\n * @return The optimal tour as a list of vertices.\n */\npublic static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g) {\n    List<V> vertices = new LinkedList<V>(g.vertexSet());\n    // If the graph is not complete then return null since this algorithm\n    // requires the graph be complete\n    if ((vertices.size() * (vertices.size() - 1) / 2) != g.edgeSet().size()) {\n        return null;\n    }\n    List<V> tour = new LinkedList<V>();\n    // Each iteration a new vertex will be added to the tour until all\n    // vertices have been added\n    while (tour.size() != g.vertexSet().size()) {\n        boolean firstEdge = true;\n        double minEdgeValue = 0;\n        int minVertexFound = 0;\n        int vertexConnectedTo = 0;\n        // A check will be made for the shortest edge to a vertex not within\n        // the tour and that new vertex will be added to the vertex\n        for (int i = 0; i < tour.size(); i++) {\n            V v = tour.get(i);\n            for (int j = 0; j < vertices.size(); j++) {\n                double weight = g.getEdgeWeight(g.getEdge(v, vertices.get(j)));\n                if (firstEdge || (weight < minEdgeValue)) {\n                    firstEdge = false;\n                    minEdgeValue = weight;\n                    minVertexFound = j;\n                    vertexConnectedTo = i;\n                }\n            }\n        }\n        tour.add(vertexConnectedTo, vertices.get(minVertexFound));\n        vertices.remove(minVertexFound);\n    }\n    return tour;\n}"
            ],
            [
                "find2ApproximationCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a 2-approximation for a minimal vertex cover of the specified\n * graph. The algorithm promises a cover that is at most double the size of\n * a minimal cover. The algorithm takes O(|E|) time.\n *\n * <p>For more details see Jenny Walter, CMPU-240: Lecture notes for\n * Language Theory and Computation, Fall 2002, Vassar College, <a\n * href=\"http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf\">\n * http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf</a>.\n * </p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G'=(V',E') <-- G(V,E)\n    Subgraph<V, E, Graph<V, E>> sg = new Subgraph<V, E, Graph<V, E>>(g, null, null);\n    // while E' is non-empty\n    while (sg.edgeSet().size() > 0) {\n        // let (u,v) be an arbitrary edge of E'\n        E e = sg.edgeSet().iterator().next();\n        // C <-- C U {u,v}\n        V u = g.getEdgeSource(e);\n        V v = g.getEdgeTarget(e);\n        cover.add(u);\n        cover.add(v);\n        // remove from E' every edge incident on either u or v\n        sg.removeVertex(u);\n        sg.removeVertex(v);\n    }\n    // return C\n    return cover;\n}"
            ],
            [
                "findGreedyCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a greedy approximation for a minimal vertex cover of a specified\n * graph. At each iteration, the algorithm picks the vertex with the highest\n * degree and adds it to the cover, until all edges are covered.\n *\n * <p>The algorithm works on undirected graphs, but can also work on\n * directed graphs when their edge-directions are ignored. To ignore edge\n * directions you can use {@link org.jgrapht.Graphs#undirectedGraph(Graph)}\n * or {@link org.jgrapht.graph.AsUndirectedGraph}.</p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G' <-- G\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // compare vertices in descending order of degree\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    // while G' != {}\n    while (sg.edgeSet().size() > 0) {\n        // v <-- vertex with maximum degree in G'\n        V v = Collections.max(sg.vertexSet(), comp);\n        // C <-- C U {v}\n        cover.add(v);\n        // remove from G' every edge incident on v, and v itself\n        sg.removeVertex(v);\n    }\n    return cover;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "BEST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int BEST_ORDER = 0;"
            ],
            [
                "NATURAL_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int NATURAL_ORDER = 1;"
            ],
            [
                "SMALLEST_DEGREE_LAST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;"
            ],
            [
                "LARGEST_SATURATION_FIRST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;"
            ],
            [
                "DEFAULT_EDGE_WEIGHT",
                "org.jgrapht",
                "WeightedGraph",
                "/**\n * The default weight for an edge.\n */\npublic static double DEFAULT_EDGE_WEIGHT = 1.0;"
            ],
            [
                "HUB_VERTEX",
                "org.jgrapht.generate",
                "WheelGraphGenerator",
                "/**\n * Role for the hub vertex.\n */\npublic static final String HUB_VERTEX = \"Hub Vertex\";"
            ],
            [
                "CORNER_VERTEX",
                "org.jgrapht.generate",
                "GridGraphGenerator",
                "/**\n * Role for the vertices at the corners.\n */\npublic static final String CORNER_VERTEX = \"Corner Vertex\";"
            ],
            [
                "START_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the first vertex generated.\n */\npublic static final String START_VERTEX = \"Start Vertex\";"
            ],
            [
                "END_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the last vertex generated.\n */\npublic static final String END_VERTEX = \"End Vertex\";"
            ],
            [
                "CENTER_VERTEX",
                "org.jgrapht.generate",
                "StarGraphGenerator",
                "public static final String CENTER_VERTEX = \"Center Vertex\";"
            ],
            [
                "SENTINEL",
                "org.jgrapht.traverse",
                "DepthFirstIterator",
                "/**\n * Sentinel object. Unfortunately, we can't use null, because ArrayDeque\n * won't accept those. And we don't want to rely on the caller to provide a\n * sentinel object for us. So we have to play typecasting games.\n */\npublic static final Object SENTINEL = new Object();"
            ],
            [
                "BEFORE_EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge added event. This event is fired before an edge is added to a\n * graph.\n */\npublic static final int BEFORE_EDGE_ADDED = 21;"
            ],
            [
                "BEFORE_EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge removed event. This event is fired before an edge is removed\n * from a graph.\n */\npublic static final int BEFORE_EDGE_REMOVED = 22;"
            ],
            [
                "EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge added event. This event is fired after an edge is added to a graph.\n */\npublic static final int EDGE_ADDED = 23;"
            ],
            [
                "EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge removed event. This event is fired after an edge is removed from a\n * graph.\n */\npublic static final int EDGE_REMOVED = 24;"
            ],
            [
                "CONNECTED_COMPONENT_STARTED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal started event.\n */\npublic static final int CONNECTED_COMPONENT_STARTED = 31;"
            ],
            [
                "CONNECTED_COMPONENT_FINISHED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal finished event.\n */\npublic static final int CONNECTED_COMPONENT_FINISHED = 32;"
            ],
            [
                "BEFORE_VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex added event. This event is fired before a vertex is added\n * to a graph.\n */\npublic static final int BEFORE_VERTEX_ADDED = 11;"
            ],
            [
                "BEFORE_VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex removed event. This event is fired before a vertex is\n * removed from a graph.\n */\npublic static final int BEFORE_VERTEX_REMOVED = 12;"
            ],
            [
                "VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex added event. This event is fired after a vertex is added to a\n * graph.\n */\npublic static final int VERTEX_ADDED = 13;"
            ],
            [
                "VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex removed event. This event is fired after a vertex is removed from\n * a graph.\n */\npublic static final int VERTEX_REMOVED = 14;"
            ],
            [
                "NULL_NODE",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "public static final int NULL_NODE = -1;"
            ],
            [
                "DEBUG",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected static final boolean DEBUG = false;"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg",
                "EdmondsKarpMaximumFlow",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 0.000000001;"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveClosure",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveClosure INSTANCE = new TransitiveClosure();"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveReduction",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveReduction INSTANCE = new TransitiveReduction();"
            ],
            [
                "NEGATIVE_UNDIRECTED_EDGE",
                "org.jgrapht.alg",
                "BellmanFordIterator",
                "/**\n * Error message.\n */\nprotected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg.flow",
                "MaximumFlowAlgorithmBase",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 1e-9;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [
            [
                "vertex",
                "",
                "V"
            ],
            [
                "edge",
                "",
                "E"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "getSeenData",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "protected D getSeenData(V arg0)"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "isReuseEvents",
                "org.jgrapht.traverse",
                "AbstractGraphIterator",
                "public boolean isReuseEvents()"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "isSeenVertex",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "protected boolean isSeenVertex(Object arg0)"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "next",
                "java.util",
                "Iterator",
                "public abstract E next()"
            ],
            [
                "next",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "public V next()"
            ],
            [
                "provideNextVertex",
                "org.jgrapht.traverse",
                "ClosestFirstIterator",
                "/**\n * @see CrossComponentIterator#provideNextVertex()\n */\n@Override\nprotected V provideNextVertex() {\n    FibonacciHeapNode<QueueEntry<V, E>> node = heap.removeMin();\n    node.getData().frozen = true;\n    return node.getData().vertex;\n}"
            ],
            [
                "isCrossComponentTraversal",
                "org.jgrapht.traverse",
                "AbstractGraphIterator",
                "public boolean isCrossComponentTraversal()"
            ],
            [
                "getSpanningTreeEdge",
                "org.jgrapht.traverse",
                "ClosestFirstIterator",
                "/**\n * Get the spanning tree edge reaching a vertex which has been seen already\n * in this traversal. This edge is the last link in the shortest known path\n * between the start vertex and the requested vertex. If the vertex has\n * already been visited, then it is truly the minimum spanning tree edge;\n * otherwise, it is the best candidate seen so far.\n *\n * @param vertex the spanned vertex.\n *\n * @return the spanning tree edge, or null if the vertex either has not been\n * seen yet or is the start vertex.\n */\npublic E getSpanningTreeEdge(V vertex) {\n    FibonacciHeapNode<QueueEntry<V, E>> node = getSeenData(vertex);\n    if (node == null) {\n        return null;\n    }\n    return node.getData().spanningTreeEdge;\n}"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "getShortestPathLength",
                "org.jgrapht.traverse",
                "ClosestFirstIterator",
                "/**\n * Get the weighted length of the shortest path known to the given vertex.\n * If the vertex has already been visited, then it is truly the shortest\n * path length; otherwise, it is the best known upper bound.\n *\n * @param vertex vertex being sought from start vertex\n *\n * @return weighted length of shortest path known, or\n * Double.POSITIVE_INFINITY if no path found yet\n */\npublic double getShortestPathLength(V vertex) {\n    FibonacciHeapNode<QueueEntry<V, E>> node = getSeenData(vertex);\n    if (node == null) {\n        return Double.POSITIVE_INFINITY;\n    }\n    return node.getKey();\n}"
            ],
            [
                "putSeenData",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "protected D putSeenData(V arg0, D arg1)"
            ],
            [
                "getGraph",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "public Graph<V, E> getGraph()"
            ],
            [
                "isConnectedComponentExhausted",
                "org.jgrapht.traverse",
                "ClosestFirstIterator",
                "/**\n * @see CrossComponentIterator#isConnectedComponentExhausted()\n */\n@Override\nprotected boolean isConnectedComponentExhausted() {\n    if (heap.size() == 0) {\n        return true;\n    } else {\n        if (heap.min().getKey() > radius) {\n            heap.clear();\n            return true;\n        } else {\n            return false;\n        }\n    }\n}"
            ],
            [
                "hasNext",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "public boolean hasNext()"
            ],
            [
                "getKey",
                "org.jgrapht.util",
                "FibonacciHeapNode",
                "public final double getKey()"
            ],
            [
                "toString",
                "org.jgrapht.util",
                "FibonacciHeapNode",
                "public String toString()"
            ],
            [
                "getData",
                "org.jgrapht.util",
                "FibonacciHeapNode",
                "public final T getData()"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [
            [
                "nListeners",
                "org.jgrapht.traverse",
                "AbstractGraphIterator",
                "protected int nListeners;"
            ],
            [
                "data",
                "org.jgrapht.util",
                "FibonacciHeapNode",
                "T data;"
            ],
            [
                "child",
                "org.jgrapht.util",
                "FibonacciHeapNode",
                "FibonacciHeapNode<T> child;"
            ],
            [
                "left",
                "org.jgrapht.util",
                "FibonacciHeapNode",
                "FibonacciHeapNode<T> left;"
            ],
            [
                "parent",
                "org.jgrapht.util",
                "FibonacciHeapNode",
                "FibonacciHeapNode<T> parent;"
            ],
            [
                "right",
                "org.jgrapht.util",
                "FibonacciHeapNode",
                "FibonacciHeapNode<T> right;"
            ],
            [
                "mark",
                "org.jgrapht.util",
                "FibonacciHeapNode",
                "boolean mark;"
            ],
            [
                "key",
                "org.jgrapht.util",
                "FibonacciHeapNode",
                "double key;"
            ],
            [
                "degree",
                "org.jgrapht.util",
                "FibonacciHeapNode",
                "int degree;"
            ]
        ],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 26207,
        "oracle": ";",
        "oracleType": "PRE",
        "projectName": "jgrapht-core-0.9.2",
        "packageName": "org.jgrapht.traverse",
        "className": "BreadthFirstIterator",
        "javadocTag": "@param g the graph to be iterated.",
        "methodJavadoc": "    /**\n     * Creates a new breadth-first iterator for the specified graph. Iteration\n     * will start at the specified start vertex and will be limited to the\n     * connected component that includes that vertex. If the specified start\n     * vertex is <code>null</code>, iteration will start at an arbitrary vertex\n     * and will not be limited, that is, will be able to traverse all the graph.\n     *\n     * @param g the graph to be iterated.\n     * @param startVertex the vertex iteration to be started.\n     */",
        "methodSourceCode": "public BreadthFirstIterator(Graph<V, E> g, V startVertex){\n    super(g, startVertex);\n}",
        "classJavadoc": "/**\n * A breadth-first iterator for a directed and an undirected graph. For this\n * iterator to work correctly the graph must not be modified during iteration.\n * Currently there are no means to ensure that, nor to fail-fast. The results of\n * such modifications are undefined.\n *\n * @author Barak Naveh\n * @since Jul 19, 2003\n */",
        "classSourceCode": "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------------\n * BreadthFirstIterator.java\n * -------------------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Liviu Rau\n *                   Christian Hammer\n *                   Ross Judson\n *\n * $Id$\n *\n * Changes\n * -------\n * 24-Jul-2003 : Initial revision (BN);\n * 06-Aug-2003 : Extracted common logic to TraverseUtils.XXFirstIterator (BN);\n * 31-Jan-2004 : Reparented and changed interface to parent class (BN);\n * 28-Sep-2008 : Optimized using ArrayDeque per suggestion from Ross (JVS)\n *\n */\npackage org.jgrapht.traverse;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\n\n\n/**\n * A breadth-first iterator for a directed and an undirected graph. For this\n * iterator to work correctly the graph must not be modified during iteration.\n * Currently there are no means to ensure that, nor to fail-fast. The results of\n * such modifications are undefined.\n *\n * @author Barak Naveh\n * @since Jul 19, 2003\n */\npublic class BreadthFirstIterator<V, E>\n    extends CrossComponentIterator<V, E, Object>\n{\n    private Deque<V> queue = new ArrayDeque<V>();\n\n    /**\n     * Creates a new breadth-first iterator for the specified graph.\n     *\n     * @param g the graph to be iterated.\n     */\n    public BreadthFirstIterator(Graph<V, E> g)\n    {\n        this(g, null);\n    }\n\n    /**\n     * Creates a new breadth-first iterator for the specified graph. Iteration\n     * will start at the specified start vertex and will be limited to the\n     * connected component that includes that vertex. If the specified start\n     * vertex is <code>null</code>, iteration will start at an arbitrary vertex\n     * and will not be limited, that is, will be able to traverse all the graph.\n     *\n     * @param g the graph to be iterated.\n     * @param startVertex the vertex iteration to be started.\n     */\n    public BreadthFirstIterator(Graph<V, E> g, V startVertex)\n    {\n        super(g, startVertex);\n    }\n\n    /**\n     * @see CrossComponentIterator#isConnectedComponentExhausted()\n     */\n    @Override protected boolean isConnectedComponentExhausted()\n    {\n        return queue.isEmpty();\n    }\n\n    /**\n     * @see CrossComponentIterator#encounterVertex(Object, Object)\n     */\n    @Override protected void encounterVertex(V vertex, E edge)\n    {\n        putSeenData(vertex, null);\n        queue.add(vertex);\n    }\n\n    /**\n     * @see CrossComponentIterator#encounterVertexAgain(Object, Object)\n     */\n    @Override protected void encounterVertexAgain(V vertex, E edge)\n    {\n    }\n\n    /**\n     * @see CrossComponentIterator#provideNextVertex()\n     */\n    @Override protected V provideNextVertex()\n    {\n        return queue.removeFirst();\n    }\n}\n\n// End BreadthFirstIterator.java\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "PartiteRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "RandomGraphHelper",
                "org.jgrapht.experimental"
            ],
            [
                "GraphReader",
                "org.jgrapht.experimental"
            ],
            [
                "DirectedAcyclicGraph",
                "org.jgrapht.experimental.dag"
            ],
            [
                "GraphSquare",
                "org.jgrapht.experimental"
            ],
            [
                "UniformRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "GraphTests",
                "org.jgrapht.experimental"
            ],
            [
                "ApproximationAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "BrownBacktrackColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "GreedyColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "IntArrayGraphAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ExactAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ListenableGraph",
                "org.jgrapht"
            ],
            [
                "ModifiableInteger",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeapNode",
                "org.jgrapht.util"
            ],
            [
                "WeightCombiner",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeap",
                "org.jgrapht.util"
            ],
            [
                "TypeUtil",
                "org.jgrapht.util"
            ],
            [
                "ArrayUnenforcedSet",
                "org.jgrapht.util"
            ],
            [
                "VertexPair",
                "org.jgrapht.util"
            ],
            [
                "MathUtil",
                "org.jgrapht.util"
            ],
            [
                "PrefetchIterator",
                "org.jgrapht.util"
            ],
            [
                "VertexFactory",
                "org.jgrapht"
            ],
            [
                "Graph",
                "org.jgrapht"
            ],
            [
                "GraphPath",
                "org.jgrapht"
            ],
            [
                "UndirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraph",
                "org.jgrapht.graph"
            ],
            [
                "MixedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DefaultGraphMapping",
                "org.jgrapht.graph"
            ],
            [
                "WeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskEdgeSet",
                "org.jgrapht.graph"
            ],
            [
                "Pseudograph",
                "org.jgrapht.graph"
            ],
            [
                "MaskFunctor",
                "org.jgrapht.graph"
            ],
            [
                "GraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractBaseGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "Multigraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultWeightedEdge",
                "org.jgrapht.graph"
            ],
            [
                "ListenableDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeSetFactory",
                "org.jgrapht.graph"
            ],
            [
                "GraphDelegator",
                "org.jgrapht.graph"
            ],
            [
                "DefaultListenableGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedVertexFactory",
                "org.jgrapht.graph"
            ],
            [
                "DefaultEdge",
                "org.jgrapht.graph"
            ],
            [
                "MaskVertexSet",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "IntrusiveEdge",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphPathImpl",
                "org.jgrapht.graph"
            ],
            [
                "Subgraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractGraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedEdgeFactory",
                "org.jgrapht.graph"
            ],
            [
                "SimpleWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "WeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeReversedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "AbstractGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "ListenableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraphPath",
                "org.jgrapht.graph"
            ],
            [
                "ParanoidGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphHelper",
                "org.jgrapht"
            ],
            [
                "Graphs",
                "org.jgrapht"
            ],
            [
                "DirectedGraph",
                "org.jgrapht"
            ],
            [
                "WeightedGraph",
                "org.jgrapht"
            ],
            [
                "HyperCubeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RingGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WheelGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GridGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "ScaleFreeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedBipartiteGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "LinearGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RandomGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGeneratorAdapter",
                "org.jgrapht.generate"
            ],
            [
                "EmptyGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteBipartiteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "StarGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "UndirectedGraph",
                "org.jgrapht"
            ],
            [
                "TopologicalOrderIterator",
                "org.jgrapht.traverse"
            ],
            [
                "CrossComponentIterator",
                "org.jgrapht.traverse"
            ],
            [
                "AbstractGraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "ClosestFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "BreadthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "DepthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "GraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "EdgeFactory",
                "org.jgrapht"
            ],
            [
                "GraphMapping",
                "org.jgrapht"
            ],
            [
                "VertexSetListener",
                "org.jgrapht.event"
            ],
            [
                "EdgeTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "TraversalListener",
                "org.jgrapht.event"
            ],
            [
                "GraphEdgeChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "VertexTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphListener",
                "org.jgrapht.event"
            ],
            [
                "TraversalListenerAdapter",
                "org.jgrapht.event"
            ],
            [
                "ConnectedComponentTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphVertexChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "TarjanLowestCommonAncestor",
                "org.jgrapht.alg"
            ],
            [
                "PrimMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "BlockCutpointGraph",
                "org.jgrapht.alg"
            ],
            [
                "AllDirectedPaths",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPathsIterator",
                "org.jgrapht.alg"
            ],
            [
                "KruskalMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "StrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "VF2State",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2AbstractIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "GraphOrdering",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphicGraphMapping",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2MappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "BronKerboschCliqueFinder",
                "org.jgrapht.alg"
            ],
            [
                "ChromaticNumber",
                "org.jgrapht.alg"
            ],
            [
                "KosarajuStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "DijkstraShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElement",
                "org.jgrapht.alg"
            ],
            [
                "AStarShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordPathElement",
                "org.jgrapht.alg"
            ],
            [
                "FloydWarshallShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "UnionFind",
                "org.jgrapht.alg.util"
            ],
            [
                "AlwaysEqualComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Extension",
                "org.jgrapht.alg.util"
            ],
            [
                "VertexDegreeComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Pair",
                "org.jgrapht.alg.util"
            ],
            [
                "GabowStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "HawickJamesSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "DirectedSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "JohnsonSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TiernanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "UndirectedCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "PatonCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TarjanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "SzwarcfiterLauerSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "BiconnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "ConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "MinSourceSinkCut",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsBlossomShrinking",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveClosure",
                "org.jgrapht.alg"
            ],
            [
                "HopcroftKarpBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "StoerWagnerMinimumCut",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "KuhnMunkresMinimalWeightBipartitePerfectMatching",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveReduction",
                "org.jgrapht.alg"
            ],
            [
                "EulerianCircuit",
                "org.jgrapht.alg"
            ],
            [
                "DirectedNeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "NaiveLcaFinder",
                "org.jgrapht.alg"
            ],
            [
                "MaximumWeightBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "HamiltonianCycle",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "NeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "VertexCovers",
                "org.jgrapht.alg"
            ],
            [
                "CycleDetector",
                "org.jgrapht.alg"
            ],
            [
                "AStarAdmissibleHeuristic",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MinimumSpanningTree",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "WeightedMatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "StrongConnectivityAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MaximumFlowAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "CliqueMinimalSeparatorDecomposition",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordIterator",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElement",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "PushRelabelMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "MaximumFlowAlgorithmBase",
                "org.jgrapht.alg.flow"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "addVertices",
                "org.jgrapht.experimental",
                "RandomGraphHelper",
                "/**\n * .\n *\n * @param target\n * @param vertexFactory\n * @param numVertices\n *\n * @return vertices\n */\n@SuppressWarnings(\"unchecked\")\npublic static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices) {\n    Object[] vertices = new Object[numVertices];\n    for (int i = 0; i < numVertices; ++i) {\n        vertices[i] = vertexFactory.createVertex();\n        target.addVertex(vertices[i]);\n    }\n    return vertices;\n}"
            ],
            [
                "isEmpty",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isEmpty(Graph<V, E> g) {\n    return g.edgeSet().isEmpty();\n}"
            ],
            [
                "isComplete",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isComplete(Graph<V, E> g) {\n    int n = g.vertexSet().size();\n    return g.edgeSet().size() == (n * (n - 1) / 2);\n}"
            ],
            [
                "isConnected",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isConnected(Graph<V, E> g) {\n    int numVertices = g.vertexSet().size();\n    int numEdges = g.edgeSet().size();\n    if (numEdges < (numVertices - 1)) {\n        return false;\n    }\n    if ((numVertices < 2) || (numEdges > ((numVertices - 1) * (numVertices - 2) / 2))) {\n        return true;\n    }\n    Set<V> known = new HashSet<V>();\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = g.vertexSet().iterator().next();\n    // start with node 1\n    queue.add(v);\n    known.add(v);\n    while (!queue.isEmpty()) {\n        v = queue.removeFirst();\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            v = it.next();\n            if (!known.contains(v)) {\n                known.add(v);\n                queue.add(v);\n            }\n        }\n    }\n    return known.size() == numVertices;\n}"
            ],
            [
                "isTree",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isTree(Graph<V, E> g) {\n    return isConnected(g) && (g.edgeSet().size() == (g.vertexSet().size() - 1));\n}"
            ],
            [
                "isBipartite",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isBipartite(Graph<V, E> g) {\n    if ((4 * g.edgeSet().size()) > (g.vertexSet().size() * g.vertexSet().size())) {\n        return false;\n    }\n    if (isEmpty(g)) {\n        return true;\n    }\n    Set<V> unknown = new HashSet<V>(g.vertexSet());\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = unknown.iterator().next();\n    Set<V> odd = new HashSet<V>();\n    queue.add(v);\n    while (!unknown.isEmpty()) {\n        if (queue.isEmpty()) {\n            queue.add(unknown.iterator().next());\n        }\n        v = queue.removeFirst();\n        unknown.remove(v);\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            V n = it.next();\n            if (unknown.contains(n)) {\n                queue.add(n);\n                if (!odd.contains(v)) {\n                    odd.add(n);\n                }\n            } else if (!(odd.contains(v) ^ odd.contains(n))) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
            ],
            [
                "union",
                "org.jgrapht.util",
                "FibonacciHeap",
                "// size\n/**\n * Joins two Fibonacci heaps into a new one. No heap consolidation is\n * performed at this time. The two root lists are simply joined together.\n *\n * <p>Running time: O(1) actual</p>\n *\n * @param h1 first heap\n * @param h2 second heap\n *\n * @return new heap containing h1 and h2\n */\npublic static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2) {\n    FibonacciHeap<T> h = new FibonacciHeap<T>();\n    if ((h1 != null) && (h2 != null)) {\n        h.minNode = h1.minNode;\n        if (h.minNode != null) {\n            if (h2.minNode != null) {\n                h.minNode.right.left = h2.minNode.left;\n                h2.minNode.left.right = h.minNode.right;\n                h.minNode.right = h2.minNode;\n                h2.minNode.left = h.minNode;\n                if (h2.minNode.key < h1.minNode.key) {\n                    h.minNode = h2.minNode;\n                }\n            }\n        } else {\n            h.minNode = h2.minNode;\n        }\n        h.nNodes = h1.nNodes + h2.nNodes;\n    }\n    return h;\n}"
            ],
            [
                "uncheckedCast",
                "org.jgrapht.util",
                "TypeUtil",
                "/**\n * Casts an object to a type.\n *\n * @param o object to be cast\n * @param typeDecl conveys the target type information; the actual value is\n * unused and can be null since this is all just stupid compiler tricks\n *\n * @return the result of the cast\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl) {\n    return (T) o;\n}"
            ],
            [
                "factorial",
                "org.jgrapht.util",
                "MathUtil",
                "public static long factorial(int N) {\n    long multi = 1;\n    for (int i = 1; i <= N; i++) {\n        multi = multi * i;\n    }\n    return multi;\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graphs",
                "/**\n * Creates a new edge and adds it to the specified graph similarly to the\n * {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n *\n * @see Graph#addEdge(Object, Object)\n */\npublic static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    EdgeFactory<V, E> ef = g.getEdgeFactory();\n    E e = ef.createEdge(sourceVertex, targetVertex);\n    // we first create the edge and set the weight to make sure that\n    // listeners will see the correct weight upon addEdge.\n    assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n    ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n    return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new edge and adds it to the specified\n * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return g.addEdge(sourceVertex, targetVertex);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified edge to the graph, including its vertices if not\n * already included.\n *\n * @param targetGraph the graph for which the specified edge to be added.\n * @param sourceGraph the graph in which the specified edge is already\n * present\n * @param edge edge to add\n *\n * @return <tt>true</tt> if the target graph did not already contain the\n * specified edge.\n */\npublic static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge) {\n    V sourceVertex = sourceGraph.getEdgeSource(edge);\n    V targetVertex = sourceGraph.getEdgeTarget(edge);\n    targetGraph.addVertex(sourceVertex);\n    targetGraph.addVertex(targetVertex);\n    return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new weighted edge and adds it to the\n * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n * method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return addEdge(g, sourceVertex, targetVertex, weight);\n}"
            ],
            [
                "addGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all the vertices and all the edges of the specified source graph to\n * the specified destination graph. First all vertices of the source graph\n * are added to the destination graph. Then every edge of the source graph\n * is added to the destination graph. This method returns <code>true</code>\n * if the destination graph has been modified as a result of this operation,\n * otherwise it returns <code>false</code>.\n *\n * <p>The behavior of this operation is undefined if any of the specified\n * graphs is modified while operation is in progress.</p>\n *\n * @param destination the graph to which vertices and edges are added.\n * @param source the graph used as source for vertices and edges to add.\n *\n * @return <code>true</code> if and only if the destination graph has been\n * changed as a result of this operation.\n */\npublic static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source) {\n    boolean modified = addAllVertices(destination, source.vertexSet());\n    modified |= addAllEdges(destination, source, source.edgeSet());\n    return modified;\n}"
            ],
            [
                "addAllEdges",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds a subset of the edges of the specified source graph to the specified\n * destination graph. The behavior of this operation is undefined if either\n * of the graphs is modified while the operation is in progress. {@link\n * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n * be added automatically to the target graph.\n *\n * @param destination the graph to which edges are to be added\n * @param source the graph used as a source for edges to add\n * @param edges the edges to be added\n *\n * @return <tt>true</tt> if this graph changed as a result of the call\n */\npublic static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges) {\n    boolean modified = false;\n    for (E e : edges) {\n        V s = source.getEdgeSource(e);\n        V t = source.getEdgeTarget(e);\n        destination.addVertex(s);\n        destination.addVertex(t);\n        modified |= destination.addEdge(s, t, e);\n    }\n    return modified;\n}"
            ],
            [
                "addAllVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all of the specified vertices to the destination graph. The behavior\n * of this operation is undefined if the specified vertex collection is\n * modified while the operation is in progress. This method will invoke the\n * {@link Graph#addVertex(Object)} method.\n *\n * @param destination the graph to which edges are to be added\n * @param vertices the vertices to be added to the graph.\n *\n * @return <tt>true</tt> if graph changed as a result of the call\n *\n * @throws NullPointerException if the specified vertices contains one or\n * more null vertices, or if the specified vertex collection is <tt>\n * null</tt>.\n *\n * @see Graph#addVertex(Object)\n */\npublic static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices) {\n    boolean modified = false;\n    for (V v : vertices) {\n        modified |= destination.addVertex(v);\n    }\n    return modified;\n}"
            ],
            [
                "neighborListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the neighbors of a specified vertex.\n * If the graph is a multigraph vertices may appear more than once in the\n * returned list.\n *\n * @param g the graph to look for neighbors in.\n * @param vertex the vertex to get the neighbors of.\n *\n * @return a list of the vertices that are the neighbors of the specified\n * vertex.\n */\npublic static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex) {\n    List<V> neighbors = new ArrayList<V>();\n    for (E e : g.edgesOf(vertex)) {\n        neighbors.add(getOppositeVertex(g, e, vertex));\n    }\n    return neighbors;\n}"
            ],
            [
                "predecessorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct predecessors of a\n * specified vertex. If the graph is a multigraph, vertices may appear more\n * than once in the returned list.\n *\n * @param g the graph to look for predecessors in.\n * @param vertex the vertex to get the predecessors of.\n *\n * @return a list of the vertices that are the direct predecessors of the\n * specified vertex.\n */\npublic static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> predecessors = new ArrayList<V>();\n    Set<? extends E> edges = g.incomingEdgesOf(vertex);\n    for (E e : edges) {\n        predecessors.add(getOppositeVertex(g, e, vertex));\n    }\n    return predecessors;\n}"
            ],
            [
                "successorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct successors of a specified\n * vertex. If the graph is a multigraph vertices may appear more than once\n * in the returned list.\n *\n * @param g the graph to look for successors in.\n * @param vertex the vertex to get the successors of.\n *\n * @return a list of the vertices that are the direct successors of the\n * specified vertex.\n */\npublic static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> successors = new ArrayList<V>();\n    Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n    for (E e : edges) {\n        successors.add(getOppositeVertex(g, e, vertex));\n    }\n    return successors;\n}"
            ],
            [
                "undirectedGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns an undirected view of the specified graph. If the specified graph\n * is directed, returns an undirected view of it. If the specified graph is\n * already undirected, just returns it.\n *\n * @param g the graph for which an undirected view is to be returned.\n *\n * @return an undirected view of the specified graph, if it is directed, or\n * or the specified graph itself if it is already undirected.\n *\n * @throws IllegalArgumentException if the graph is neither DirectedGraph\n * nor UndirectedGraph.\n *\n * @see AsUndirectedGraph\n */\npublic static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n    } else if (g instanceof UndirectedGraph<?, ?>) {\n        return (UndirectedGraph<V, E>) g;\n    } else {\n        throw new IllegalArgumentException(\"Graph must be either DirectedGraph or UndirectedGraph\");\n    }\n}"
            ],
            [
                "testIncidence",
                "org.jgrapht",
                "Graphs",
                "/**\n * Tests whether an edge is incident to a vertex.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return true iff e is incident on v\n */\npublic static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v) {\n    return (g.getEdgeSource(e).equals(v)) || (g.getEdgeTarget(e).equals(v));\n}"
            ],
            [
                "getOppositeVertex",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the vertex opposite another vertex across an edge.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return vertex opposite to v across e\n */\npublic static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v) {\n    V source = g.getEdgeSource(e);\n    V target = g.getEdgeTarget(e);\n    if (v.equals(source)) {\n        return target;\n    } else if (v.equals(target)) {\n        return source;\n    } else {\n        throw new IllegalArgumentException(\"no such vertex: \" + v.toString());\n    }\n}"
            ],
            [
                "getPathVertexList",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the list of vertices visited by a path.\n *\n * @param path path of interest\n *\n * @return corresponding vertex list\n */\npublic static <V, E> List<V> getPathVertexList(GraphPath<V, E> path) {\n    Graph<V, E> g = path.getGraph();\n    List<V> list = new ArrayList<V>();\n    V v = path.getStartVertex();\n    list.add(v);\n    for (E e : path.getEdgeList()) {\n        v = getOppositeVertex(g, e, v);\n        list.add(v);\n    }\n    return list;\n}"
            ],
            [
                "range",
                "org.jgrapht.generate",
                "SimpleWeightedGraphMatrixGenerator",
                "///////////////////////////////////////////////////////////////////////////////////////////////\npublic static int[] range(final int from, final int to) {\n    int[] range = new int[to - from];\n    for (int i = from; i < to; ++i) {\n        range[i - from] = i;\n    }\n    return range;\n}"
            ],
            [
                "createGraphSpecifics",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "// -------------------------------------------------------------------------\n/**\n * @param <V>\n * @param <E>\n * @param g\n *\n * @return TODO Document me\n */\nstatic <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new DirectedSpecifics<V, E>((DirectedGraph<V, E>) g);\n    } else {\n        return new UndirectedSpecifics<V, E>(g);\n    }\n}"
            ],
            [
                "findGreedyChromaticNumber",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds the number of colors required for a greedy coloring of the graph.\n *\n * @param g an undirected graph to find the chromatic number of\n *\n * @return integer the approximate chromatic number from the greedy\n * algorithm\n */\npublic static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g) {\n    Map<Integer, Set<V>> coloredGroups = findGreedyColoredGroups(g);\n    return coloredGroups.keySet().size();\n}"
            ],
            [
                "findGreedyColoredGroups",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds a greedy coloring of the graph.\n *\n * @param g an undirected graph for which to find the coloring\n */\npublic static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g) {\n    // A copy of the graph is made, so that elements of the graph may be\n    // removed to carry out the algorithm\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // The Vertices will be sorted in decreasing order by degree, so that\n    // higher degree vertices have priority to be colored first\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    List<V> sortedVertices = new LinkedList<V>(sg.vertexSet());\n    Collections.sort(sortedVertices, comp);\n    Collections.reverse(sortedVertices);\n    int color;\n    // create a map which will hold color as key and Set<V> as value\n    Map<Integer, Set<V>> coloredGroups = new HashMap<Integer, Set<V>>();\n    // We'll attempt to color each vertex with a single color each\n    // iteration, and these vertices will be removed from the graph at the\n    // end of each iteration\n    for (color = 0; sg.vertexSet().size() > 0; color++) {\n        // This set will contain vertices that are colored with the\n        // current color of this iteration\n        Set<V> currentColor = new HashSet<V>();\n        for (Iterator<V> iter = sortedVertices.iterator(); iter.hasNext(); ) {\n            V v = iter.next();\n            // Add new vertices to be colored as long as they are not\n            // adjacent with any other vertex that has already been colored\n            // with the current color\n            boolean flag = true;\n            for (Iterator<V> innerIter = currentColor.iterator(); innerIter.hasNext(); ) {\n                V temp = innerIter.next();\n                if (sg.containsEdge(temp, v)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                currentColor.add(v);\n                iter.remove();\n            }\n        }\n        // Add all these vertices as a group for this color\n        coloredGroups.put(color, currentColor);\n        // Remove vertices from the graph and then repeat the process for\n        // the next iteration\n        sg.removeAllVertices(currentColor);\n    }\n    return coloredGroups;\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "BellmanFordShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by hops, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    BellmanFordShortestPath<V, E> alg = new BellmanFordShortestPath<V, E>(graph, startVertex);\n    return alg.getPathEdgeList(endVertex);\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "DijkstraShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by radius, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    DijkstraShortestPath<V, E> alg = new DijkstraShortestPath<V, E>(graph, startVertex, endVertex);\n    return alg.getPathEdgeList();\n}"
            ],
            [
                "of",
                "org.jgrapht.alg.util",
                "Pair",
                "/**\n * Creates new pair of elements pulling of the necessity to provide\n * corresponding types of the elements supplied\n *\n * @param a first element\n * @param b second element\n *\n * @return new pair\n */\npublic static <A, B> Pair<A, B> of(A a, B b) {\n    return new Pair<A, B>(a, b);\n}"
            ],
            [
                "isEulerian",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will check whether the graph passed in is Eulerian or not.\n *\n * @param g The graph to be checked\n *\n * @return true for Eulerian and false for non-Eulerian\n */\npublic static <V, E> boolean isEulerian(UndirectedGraph<V, E> g) {\n    // If the graph is not connected, then no Eulerian circuit exists\n    if (!(new ConnectivityInspector<V, E>(g)).isGraphConnected()) {\n        return false;\n    }\n    // A graph is Eulerian if and only if all vertices have even degree\n    // So, this code will check for that\n    Iterator<V> iter = g.vertexSet().iterator();\n    while (iter.hasNext()) {\n        V v = iter.next();\n        if ((g.degreeOf(v) % 2) == 1) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "getEulerianCircuitVertices",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will return a list of vertices which represents the Eulerian\n * circuit of the graph.\n *\n * @param g The graph to find an Eulerian circuit\n *\n * @return null if no Eulerian circuit exists, or a list of vertices\n * representing the Eulerian circuit if one does exist\n */\npublic static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g) {\n    // If the graph is not Eulerian then just return a null since no\n    // Eulerian circuit exists\n    if (!isEulerian(g)) {\n        return null;\n    }\n    // The circuit will be represented by a linked list\n    List<V> path = new LinkedList<V>();\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    path.add(sg.vertexSet().iterator().next());\n    // Algorithm for finding an Eulerian circuit Basically this will find an\n    // arbitrary circuit, then it will find another arbitrary circuit until\n    // every edge has been traversed\n    while (sg.edgeSet().size() > 0) {\n        V v = null;\n        // Find a vertex which has an edge that hasn't been traversed yet,\n        // and keep its index position in the circuit list\n        int index = 0;\n        for (Iterator<V> iter = path.iterator(); iter.hasNext(); index++) {\n            v = iter.next();\n            if (sg.degreeOf(v) > 0) {\n                break;\n            }\n        }\n        // Finds an arbitrary circuit of the current vertex and\n        // appends this into the circuit list\n        while (sg.degreeOf(v) > 0) {\n            for (Iterator<V> iter = sg.vertexSet().iterator(); iter.hasNext(); ) {\n                V temp = iter.next();\n                if (sg.containsEdge(v, temp)) {\n                    path.add(index, temp);\n                    sg.removeEdge(v, temp);\n                    v = temp;\n                    break;\n                }\n            }\n        }\n    }\n    return path;\n}"
            ],
            [
                "getApproximateOptimalForCompleteGraph",
                "org.jgrapht.alg",
                "HamiltonianCycle",
                "/**\n * This method will return an approximate minimal traveling salesman tour\n * (hamiltonian cycle). This algorithm requires that the graph be complete\n * and the triangle inequality exists (if x,y,z are vertices then\n * d(x,y)+d(y,z) &lt; d(x,z) for all x,y,z) then this algorithm will\n * guarantee a hamiltonian cycle such that the total weight of the cycle is\n * less than or equal to double the total weight of the optimal hamiltonian\n * cycle. The optimal solution is NP-complete, so this is a decent\n * approximation that runs in polynomial time.\n *\n * @param <V>\n * @param <E>\n * @param g is the graph to find the optimal tour for.\n *\n * @return The optimal tour as a list of vertices.\n */\npublic static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g) {\n    List<V> vertices = new LinkedList<V>(g.vertexSet());\n    // If the graph is not complete then return null since this algorithm\n    // requires the graph be complete\n    if ((vertices.size() * (vertices.size() - 1) / 2) != g.edgeSet().size()) {\n        return null;\n    }\n    List<V> tour = new LinkedList<V>();\n    // Each iteration a new vertex will be added to the tour until all\n    // vertices have been added\n    while (tour.size() != g.vertexSet().size()) {\n        boolean firstEdge = true;\n        double minEdgeValue = 0;\n        int minVertexFound = 0;\n        int vertexConnectedTo = 0;\n        // A check will be made for the shortest edge to a vertex not within\n        // the tour and that new vertex will be added to the vertex\n        for (int i = 0; i < tour.size(); i++) {\n            V v = tour.get(i);\n            for (int j = 0; j < vertices.size(); j++) {\n                double weight = g.getEdgeWeight(g.getEdge(v, vertices.get(j)));\n                if (firstEdge || (weight < minEdgeValue)) {\n                    firstEdge = false;\n                    minEdgeValue = weight;\n                    minVertexFound = j;\n                    vertexConnectedTo = i;\n                }\n            }\n        }\n        tour.add(vertexConnectedTo, vertices.get(minVertexFound));\n        vertices.remove(minVertexFound);\n    }\n    return tour;\n}"
            ],
            [
                "find2ApproximationCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a 2-approximation for a minimal vertex cover of the specified\n * graph. The algorithm promises a cover that is at most double the size of\n * a minimal cover. The algorithm takes O(|E|) time.\n *\n * <p>For more details see Jenny Walter, CMPU-240: Lecture notes for\n * Language Theory and Computation, Fall 2002, Vassar College, <a\n * href=\"http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf\">\n * http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf</a>.\n * </p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G'=(V',E') <-- G(V,E)\n    Subgraph<V, E, Graph<V, E>> sg = new Subgraph<V, E, Graph<V, E>>(g, null, null);\n    // while E' is non-empty\n    while (sg.edgeSet().size() > 0) {\n        // let (u,v) be an arbitrary edge of E'\n        E e = sg.edgeSet().iterator().next();\n        // C <-- C U {u,v}\n        V u = g.getEdgeSource(e);\n        V v = g.getEdgeTarget(e);\n        cover.add(u);\n        cover.add(v);\n        // remove from E' every edge incident on either u or v\n        sg.removeVertex(u);\n        sg.removeVertex(v);\n    }\n    // return C\n    return cover;\n}"
            ],
            [
                "findGreedyCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a greedy approximation for a minimal vertex cover of a specified\n * graph. At each iteration, the algorithm picks the vertex with the highest\n * degree and adds it to the cover, until all edges are covered.\n *\n * <p>The algorithm works on undirected graphs, but can also work on\n * directed graphs when their edge-directions are ignored. To ignore edge\n * directions you can use {@link org.jgrapht.Graphs#undirectedGraph(Graph)}\n * or {@link org.jgrapht.graph.AsUndirectedGraph}.</p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G' <-- G\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // compare vertices in descending order of degree\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    // while G' != {}\n    while (sg.edgeSet().size() > 0) {\n        // v <-- vertex with maximum degree in G'\n        V v = Collections.max(sg.vertexSet(), comp);\n        // C <-- C U {v}\n        cover.add(v);\n        // remove from G' every edge incident on v, and v itself\n        sg.removeVertex(v);\n    }\n    return cover;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "BEST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int BEST_ORDER = 0;"
            ],
            [
                "NATURAL_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int NATURAL_ORDER = 1;"
            ],
            [
                "SMALLEST_DEGREE_LAST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;"
            ],
            [
                "LARGEST_SATURATION_FIRST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;"
            ],
            [
                "DEFAULT_EDGE_WEIGHT",
                "org.jgrapht",
                "WeightedGraph",
                "/**\n * The default weight for an edge.\n */\npublic static double DEFAULT_EDGE_WEIGHT = 1.0;"
            ],
            [
                "HUB_VERTEX",
                "org.jgrapht.generate",
                "WheelGraphGenerator",
                "/**\n * Role for the hub vertex.\n */\npublic static final String HUB_VERTEX = \"Hub Vertex\";"
            ],
            [
                "CORNER_VERTEX",
                "org.jgrapht.generate",
                "GridGraphGenerator",
                "/**\n * Role for the vertices at the corners.\n */\npublic static final String CORNER_VERTEX = \"Corner Vertex\";"
            ],
            [
                "START_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the first vertex generated.\n */\npublic static final String START_VERTEX = \"Start Vertex\";"
            ],
            [
                "END_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the last vertex generated.\n */\npublic static final String END_VERTEX = \"End Vertex\";"
            ],
            [
                "CENTER_VERTEX",
                "org.jgrapht.generate",
                "StarGraphGenerator",
                "public static final String CENTER_VERTEX = \"Center Vertex\";"
            ],
            [
                "SENTINEL",
                "org.jgrapht.traverse",
                "DepthFirstIterator",
                "/**\n * Sentinel object. Unfortunately, we can't use null, because ArrayDeque\n * won't accept those. And we don't want to rely on the caller to provide a\n * sentinel object for us. So we have to play typecasting games.\n */\npublic static final Object SENTINEL = new Object();"
            ],
            [
                "BEFORE_EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge added event. This event is fired before an edge is added to a\n * graph.\n */\npublic static final int BEFORE_EDGE_ADDED = 21;"
            ],
            [
                "BEFORE_EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge removed event. This event is fired before an edge is removed\n * from a graph.\n */\npublic static final int BEFORE_EDGE_REMOVED = 22;"
            ],
            [
                "EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge added event. This event is fired after an edge is added to a graph.\n */\npublic static final int EDGE_ADDED = 23;"
            ],
            [
                "EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge removed event. This event is fired after an edge is removed from a\n * graph.\n */\npublic static final int EDGE_REMOVED = 24;"
            ],
            [
                "CONNECTED_COMPONENT_STARTED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal started event.\n */\npublic static final int CONNECTED_COMPONENT_STARTED = 31;"
            ],
            [
                "CONNECTED_COMPONENT_FINISHED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal finished event.\n */\npublic static final int CONNECTED_COMPONENT_FINISHED = 32;"
            ],
            [
                "BEFORE_VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex added event. This event is fired before a vertex is added\n * to a graph.\n */\npublic static final int BEFORE_VERTEX_ADDED = 11;"
            ],
            [
                "BEFORE_VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex removed event. This event is fired before a vertex is\n * removed from a graph.\n */\npublic static final int BEFORE_VERTEX_REMOVED = 12;"
            ],
            [
                "VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex added event. This event is fired after a vertex is added to a\n * graph.\n */\npublic static final int VERTEX_ADDED = 13;"
            ],
            [
                "VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex removed event. This event is fired after a vertex is removed from\n * a graph.\n */\npublic static final int VERTEX_REMOVED = 14;"
            ],
            [
                "NULL_NODE",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "public static final int NULL_NODE = -1;"
            ],
            [
                "DEBUG",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected static final boolean DEBUG = false;"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg",
                "EdmondsKarpMaximumFlow",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 0.000000001;"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveClosure",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveClosure INSTANCE = new TransitiveClosure();"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveReduction",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveReduction INSTANCE = new TransitiveReduction();"
            ],
            [
                "NEGATIVE_UNDIRECTED_EDGE",
                "org.jgrapht.alg",
                "BellmanFordIterator",
                "/**\n * Error message.\n */\nprotected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg.flow",
                "MaximumFlowAlgorithmBase",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 1e-9;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [
            [
                "g",
                "org.jgrapht.Graph",
                "Graph<V, E>"
            ],
            [
                "startVertex",
                "",
                "V"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "isConnectedComponentExhausted",
                "org.jgrapht.traverse",
                "BreadthFirstIterator",
                "/**\n * @see CrossComponentIterator#isConnectedComponentExhausted()\n */\n@Override\nprotected boolean isConnectedComponentExhausted() {\n    return queue.isEmpty();\n}"
            ],
            [
                "putSeenData",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "protected D putSeenData(V arg0, D arg1)"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "getGraph",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "public Graph<V, E> getGraph()"
            ],
            [
                "next",
                "java.util",
                "Iterator",
                "public abstract E next()"
            ],
            [
                "isSeenVertex",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "protected boolean isSeenVertex(Object arg0)"
            ],
            [
                "isCrossComponentTraversal",
                "org.jgrapht.traverse",
                "AbstractGraphIterator",
                "public boolean isCrossComponentTraversal()"
            ],
            [
                "getSeenData",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "protected D getSeenData(V arg0)"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "provideNextVertex",
                "org.jgrapht.traverse",
                "BreadthFirstIterator",
                "/**\n * @see CrossComponentIterator#provideNextVertex()\n */\n@Override\nprotected V provideNextVertex() {\n    return queue.removeFirst();\n}"
            ],
            [
                "next",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "public V next()"
            ],
            [
                "isReuseEvents",
                "org.jgrapht.traverse",
                "AbstractGraphIterator",
                "public boolean isReuseEvents()"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "hasNext",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "public boolean hasNext()"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "containsVertex",
                "org.jgrapht",
                "Graph",
                "public abstract boolean containsVertex(V arg0)"
            ],
            [
                "getAllEdges",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> getAllEdges(V arg0, V arg1)"
            ],
            [
                "removeEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeEdge(E arg0)"
            ],
            [
                "getEdgeSource",
                "org.jgrapht",
                "Graph",
                "public abstract V getEdgeSource(E arg0)"
            ],
            [
                "getEdgeFactory",
                "org.jgrapht",
                "Graph",
                "public abstract EdgeFactory<V, E> getEdgeFactory()"
            ],
            [
                "removeVertex",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeVertex(V arg0)"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graph",
                "public abstract E addEdge(V arg0, V arg1)"
            ],
            [
                "containsEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean containsEdge(E arg0)"
            ],
            [
                "edgeSet",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> edgeSet()"
            ],
            [
                "edgesOf",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> edgesOf(V arg0)"
            ],
            [
                "removeAllEdges",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeAllEdges(Collection<? extends E> arg0)"
            ],
            [
                "removeAllVertices",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeAllVertices(Collection<? extends V> arg0)"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean addEdge(V arg0, V arg1, E arg2)"
            ],
            [
                "addVertex",
                "org.jgrapht",
                "Graph",
                "public abstract boolean addVertex(V arg0)"
            ],
            [
                "getEdgeTarget",
                "org.jgrapht",
                "Graph",
                "public abstract V getEdgeTarget(E arg0)"
            ],
            [
                "getEdgeWeight",
                "org.jgrapht",
                "Graph",
                "public abstract double getEdgeWeight(E arg0)"
            ],
            [
                "getEdge",
                "org.jgrapht",
                "Graph",
                "public abstract E getEdge(V arg0, V arg1)"
            ],
            [
                "removeEdge",
                "org.jgrapht",
                "Graph",
                "public abstract E removeEdge(V arg0, V arg1)"
            ],
            [
                "vertexSet",
                "org.jgrapht",
                "Graph",
                "public abstract Set<V> vertexSet()"
            ],
            [
                "removeAllEdges",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> removeAllEdges(V arg0, V arg1)"
            ],
            [
                "containsEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean containsEdge(V arg0, V arg1)"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [
            [
                "nListeners",
                "org.jgrapht.traverse",
                "AbstractGraphIterator",
                "protected int nListeners;"
            ]
        ],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 26217,
        "oracle": ";",
        "oracleType": "EXCEPT_POST",
        "projectName": "jgrapht-core-0.9.2",
        "packageName": "org.jgrapht.traverse",
        "className": "GraphIterator",
        "javadocTag": "@throws UnsupportedOperationException",
        "methodJavadoc": "    /**\n     * Unsupported.\n     *\n     * @throws UnsupportedOperationException\n     */",
        "methodSourceCode": "public void remove();",
        "classJavadoc": "/**\n * A graph iterator.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */",
        "classSourceCode": "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (barak_naveh@users.sourceforge.net)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ------------------\n * GraphIterator.java\n * ------------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 31-Jul-2003 : Initial revision (BN);\n * 11-Aug-2003 : Adaptation to new event model (BN);\n * 04-May-2004 : Made generic (CH)\n *\n */\npackage org.jgrapht.traverse;\n\nimport java.util.*;\n\nimport org.jgrapht.event.*;\n\n\n/**\n * A graph iterator.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic interface GraphIterator<V, E>\n    extends Iterator<V>\n{\n    /**\n     * Test whether this iterator is set to traverse the grpah across connected\n     * components.\n     *\n     * @return <code>true</code> if traverses across connected components,\n     * otherwise <code>false</code>.\n     */\n    public boolean isCrossComponentTraversal();\n\n    /**\n     * Sets a value the <code>reuseEvents</code> flag. If the <code>\n     * reuseEvents</code> flag is set to <code>true</code> this class will reuse\n     * previously fired events and will not create a new object for each event.\n     * This option increases performance but should be used with care,\n     * especially in multithreaded environment.\n     *\n     * @param reuseEvents whether to reuse previously fired event objects\n     * instead of creating a new event object for each event.\n     */\n    public void setReuseEvents(boolean reuseEvents);\n\n    /**\n     * Tests whether the <code>reuseEvents</code> flag is set. If the flag is\n     * set to <code>true</code> this class will reuse previously fired events\n     * and will not create a new object for each event. This option increases\n     * performance but should be used with care, especially in multithreaded\n     * environment.\n     *\n     * @return the value of the <code>reuseEvents</code> flag.\n     */\n    public boolean isReuseEvents();\n\n    /**\n     * Adds the specified traversal listener to this iterator.\n     *\n     * @param l the traversal listener to be added.\n     */\n    public void addTraversalListener(TraversalListener<V, E> l);\n\n    /**\n     * Unsupported.\n     *\n     * @throws UnsupportedOperationException\n     */\n    @Override public void remove();\n\n    /**\n     * Removes the specified traversal listener from this iterator.\n     *\n     * @param l the traversal listener to be removed.\n     */\n    public void removeTraversalListener(TraversalListener<V, E> l);\n}\n\n// End GraphIterator.java\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "PartiteRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "RandomGraphHelper",
                "org.jgrapht.experimental"
            ],
            [
                "GraphReader",
                "org.jgrapht.experimental"
            ],
            [
                "DirectedAcyclicGraph",
                "org.jgrapht.experimental.dag"
            ],
            [
                "GraphSquare",
                "org.jgrapht.experimental"
            ],
            [
                "UniformRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "GraphTests",
                "org.jgrapht.experimental"
            ],
            [
                "ApproximationAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "BrownBacktrackColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "GreedyColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "IntArrayGraphAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ExactAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ListenableGraph",
                "org.jgrapht"
            ],
            [
                "ModifiableInteger",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeapNode",
                "org.jgrapht.util"
            ],
            [
                "WeightCombiner",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeap",
                "org.jgrapht.util"
            ],
            [
                "TypeUtil",
                "org.jgrapht.util"
            ],
            [
                "ArrayUnenforcedSet",
                "org.jgrapht.util"
            ],
            [
                "VertexPair",
                "org.jgrapht.util"
            ],
            [
                "MathUtil",
                "org.jgrapht.util"
            ],
            [
                "PrefetchIterator",
                "org.jgrapht.util"
            ],
            [
                "VertexFactory",
                "org.jgrapht"
            ],
            [
                "Graph",
                "org.jgrapht"
            ],
            [
                "GraphPath",
                "org.jgrapht"
            ],
            [
                "UndirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraph",
                "org.jgrapht.graph"
            ],
            [
                "MixedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DefaultGraphMapping",
                "org.jgrapht.graph"
            ],
            [
                "WeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskEdgeSet",
                "org.jgrapht.graph"
            ],
            [
                "Pseudograph",
                "org.jgrapht.graph"
            ],
            [
                "MaskFunctor",
                "org.jgrapht.graph"
            ],
            [
                "GraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractBaseGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "Multigraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultWeightedEdge",
                "org.jgrapht.graph"
            ],
            [
                "ListenableDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeSetFactory",
                "org.jgrapht.graph"
            ],
            [
                "GraphDelegator",
                "org.jgrapht.graph"
            ],
            [
                "DefaultListenableGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedVertexFactory",
                "org.jgrapht.graph"
            ],
            [
                "DefaultEdge",
                "org.jgrapht.graph"
            ],
            [
                "MaskVertexSet",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "IntrusiveEdge",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphPathImpl",
                "org.jgrapht.graph"
            ],
            [
                "Subgraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractGraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedEdgeFactory",
                "org.jgrapht.graph"
            ],
            [
                "SimpleWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "WeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeReversedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "AbstractGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "ListenableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraphPath",
                "org.jgrapht.graph"
            ],
            [
                "ParanoidGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphHelper",
                "org.jgrapht"
            ],
            [
                "Graphs",
                "org.jgrapht"
            ],
            [
                "DirectedGraph",
                "org.jgrapht"
            ],
            [
                "WeightedGraph",
                "org.jgrapht"
            ],
            [
                "HyperCubeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RingGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WheelGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GridGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "ScaleFreeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedBipartiteGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "LinearGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RandomGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGeneratorAdapter",
                "org.jgrapht.generate"
            ],
            [
                "EmptyGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteBipartiteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "StarGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "UndirectedGraph",
                "org.jgrapht"
            ],
            [
                "TopologicalOrderIterator",
                "org.jgrapht.traverse"
            ],
            [
                "CrossComponentIterator",
                "org.jgrapht.traverse"
            ],
            [
                "AbstractGraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "ClosestFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "BreadthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "DepthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "GraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "EdgeFactory",
                "org.jgrapht"
            ],
            [
                "GraphMapping",
                "org.jgrapht"
            ],
            [
                "VertexSetListener",
                "org.jgrapht.event"
            ],
            [
                "EdgeTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "TraversalListener",
                "org.jgrapht.event"
            ],
            [
                "GraphEdgeChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "VertexTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphListener",
                "org.jgrapht.event"
            ],
            [
                "TraversalListenerAdapter",
                "org.jgrapht.event"
            ],
            [
                "ConnectedComponentTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphVertexChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "TarjanLowestCommonAncestor",
                "org.jgrapht.alg"
            ],
            [
                "PrimMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "BlockCutpointGraph",
                "org.jgrapht.alg"
            ],
            [
                "AllDirectedPaths",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPathsIterator",
                "org.jgrapht.alg"
            ],
            [
                "KruskalMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "StrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "VF2State",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2AbstractIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "GraphOrdering",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphicGraphMapping",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2MappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "BronKerboschCliqueFinder",
                "org.jgrapht.alg"
            ],
            [
                "ChromaticNumber",
                "org.jgrapht.alg"
            ],
            [
                "KosarajuStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "DijkstraShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElement",
                "org.jgrapht.alg"
            ],
            [
                "AStarShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordPathElement",
                "org.jgrapht.alg"
            ],
            [
                "FloydWarshallShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "UnionFind",
                "org.jgrapht.alg.util"
            ],
            [
                "AlwaysEqualComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Extension",
                "org.jgrapht.alg.util"
            ],
            [
                "VertexDegreeComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Pair",
                "org.jgrapht.alg.util"
            ],
            [
                "GabowStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "HawickJamesSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "DirectedSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "JohnsonSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TiernanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "UndirectedCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "PatonCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TarjanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "SzwarcfiterLauerSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "BiconnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "ConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "MinSourceSinkCut",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsBlossomShrinking",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveClosure",
                "org.jgrapht.alg"
            ],
            [
                "HopcroftKarpBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "StoerWagnerMinimumCut",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "KuhnMunkresMinimalWeightBipartitePerfectMatching",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveReduction",
                "org.jgrapht.alg"
            ],
            [
                "EulerianCircuit",
                "org.jgrapht.alg"
            ],
            [
                "DirectedNeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "NaiveLcaFinder",
                "org.jgrapht.alg"
            ],
            [
                "MaximumWeightBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "HamiltonianCycle",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "NeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "VertexCovers",
                "org.jgrapht.alg"
            ],
            [
                "CycleDetector",
                "org.jgrapht.alg"
            ],
            [
                "AStarAdmissibleHeuristic",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MinimumSpanningTree",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "WeightedMatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "StrongConnectivityAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MaximumFlowAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "CliqueMinimalSeparatorDecomposition",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordIterator",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElement",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "PushRelabelMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "MaximumFlowAlgorithmBase",
                "org.jgrapht.alg.flow"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "addVertices",
                "org.jgrapht.experimental",
                "RandomGraphHelper",
                "/**\n * .\n *\n * @param target\n * @param vertexFactory\n * @param numVertices\n *\n * @return vertices\n */\n@SuppressWarnings(\"unchecked\")\npublic static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices) {\n    Object[] vertices = new Object[numVertices];\n    for (int i = 0; i < numVertices; ++i) {\n        vertices[i] = vertexFactory.createVertex();\n        target.addVertex(vertices[i]);\n    }\n    return vertices;\n}"
            ],
            [
                "isEmpty",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isEmpty(Graph<V, E> g) {\n    return g.edgeSet().isEmpty();\n}"
            ],
            [
                "isComplete",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isComplete(Graph<V, E> g) {\n    int n = g.vertexSet().size();\n    return g.edgeSet().size() == (n * (n - 1) / 2);\n}"
            ],
            [
                "isConnected",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isConnected(Graph<V, E> g) {\n    int numVertices = g.vertexSet().size();\n    int numEdges = g.edgeSet().size();\n    if (numEdges < (numVertices - 1)) {\n        return false;\n    }\n    if ((numVertices < 2) || (numEdges > ((numVertices - 1) * (numVertices - 2) / 2))) {\n        return true;\n    }\n    Set<V> known = new HashSet<V>();\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = g.vertexSet().iterator().next();\n    // start with node 1\n    queue.add(v);\n    known.add(v);\n    while (!queue.isEmpty()) {\n        v = queue.removeFirst();\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            v = it.next();\n            if (!known.contains(v)) {\n                known.add(v);\n                queue.add(v);\n            }\n        }\n    }\n    return known.size() == numVertices;\n}"
            ],
            [
                "isTree",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isTree(Graph<V, E> g) {\n    return isConnected(g) && (g.edgeSet().size() == (g.vertexSet().size() - 1));\n}"
            ],
            [
                "isBipartite",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isBipartite(Graph<V, E> g) {\n    if ((4 * g.edgeSet().size()) > (g.vertexSet().size() * g.vertexSet().size())) {\n        return false;\n    }\n    if (isEmpty(g)) {\n        return true;\n    }\n    Set<V> unknown = new HashSet<V>(g.vertexSet());\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = unknown.iterator().next();\n    Set<V> odd = new HashSet<V>();\n    queue.add(v);\n    while (!unknown.isEmpty()) {\n        if (queue.isEmpty()) {\n            queue.add(unknown.iterator().next());\n        }\n        v = queue.removeFirst();\n        unknown.remove(v);\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            V n = it.next();\n            if (unknown.contains(n)) {\n                queue.add(n);\n                if (!odd.contains(v)) {\n                    odd.add(n);\n                }\n            } else if (!(odd.contains(v) ^ odd.contains(n))) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
            ],
            [
                "union",
                "org.jgrapht.util",
                "FibonacciHeap",
                "// size\n/**\n * Joins two Fibonacci heaps into a new one. No heap consolidation is\n * performed at this time. The two root lists are simply joined together.\n *\n * <p>Running time: O(1) actual</p>\n *\n * @param h1 first heap\n * @param h2 second heap\n *\n * @return new heap containing h1 and h2\n */\npublic static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2) {\n    FibonacciHeap<T> h = new FibonacciHeap<T>();\n    if ((h1 != null) && (h2 != null)) {\n        h.minNode = h1.minNode;\n        if (h.minNode != null) {\n            if (h2.minNode != null) {\n                h.minNode.right.left = h2.minNode.left;\n                h2.minNode.left.right = h.minNode.right;\n                h.minNode.right = h2.minNode;\n                h2.minNode.left = h.minNode;\n                if (h2.minNode.key < h1.minNode.key) {\n                    h.minNode = h2.minNode;\n                }\n            }\n        } else {\n            h.minNode = h2.minNode;\n        }\n        h.nNodes = h1.nNodes + h2.nNodes;\n    }\n    return h;\n}"
            ],
            [
                "uncheckedCast",
                "org.jgrapht.util",
                "TypeUtil",
                "/**\n * Casts an object to a type.\n *\n * @param o object to be cast\n * @param typeDecl conveys the target type information; the actual value is\n * unused and can be null since this is all just stupid compiler tricks\n *\n * @return the result of the cast\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl) {\n    return (T) o;\n}"
            ],
            [
                "factorial",
                "org.jgrapht.util",
                "MathUtil",
                "public static long factorial(int N) {\n    long multi = 1;\n    for (int i = 1; i <= N; i++) {\n        multi = multi * i;\n    }\n    return multi;\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graphs",
                "/**\n * Creates a new edge and adds it to the specified graph similarly to the\n * {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n *\n * @see Graph#addEdge(Object, Object)\n */\npublic static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    EdgeFactory<V, E> ef = g.getEdgeFactory();\n    E e = ef.createEdge(sourceVertex, targetVertex);\n    // we first create the edge and set the weight to make sure that\n    // listeners will see the correct weight upon addEdge.\n    assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n    ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n    return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new edge and adds it to the specified\n * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return g.addEdge(sourceVertex, targetVertex);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified edge to the graph, including its vertices if not\n * already included.\n *\n * @param targetGraph the graph for which the specified edge to be added.\n * @param sourceGraph the graph in which the specified edge is already\n * present\n * @param edge edge to add\n *\n * @return <tt>true</tt> if the target graph did not already contain the\n * specified edge.\n */\npublic static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge) {\n    V sourceVertex = sourceGraph.getEdgeSource(edge);\n    V targetVertex = sourceGraph.getEdgeTarget(edge);\n    targetGraph.addVertex(sourceVertex);\n    targetGraph.addVertex(targetVertex);\n    return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new weighted edge and adds it to the\n * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n * method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return addEdge(g, sourceVertex, targetVertex, weight);\n}"
            ],
            [
                "addGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all the vertices and all the edges of the specified source graph to\n * the specified destination graph. First all vertices of the source graph\n * are added to the destination graph. Then every edge of the source graph\n * is added to the destination graph. This method returns <code>true</code>\n * if the destination graph has been modified as a result of this operation,\n * otherwise it returns <code>false</code>.\n *\n * <p>The behavior of this operation is undefined if any of the specified\n * graphs is modified while operation is in progress.</p>\n *\n * @param destination the graph to which vertices and edges are added.\n * @param source the graph used as source for vertices and edges to add.\n *\n * @return <code>true</code> if and only if the destination graph has been\n * changed as a result of this operation.\n */\npublic static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source) {\n    boolean modified = addAllVertices(destination, source.vertexSet());\n    modified |= addAllEdges(destination, source, source.edgeSet());\n    return modified;\n}"
            ],
            [
                "addAllEdges",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds a subset of the edges of the specified source graph to the specified\n * destination graph. The behavior of this operation is undefined if either\n * of the graphs is modified while the operation is in progress. {@link\n * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n * be added automatically to the target graph.\n *\n * @param destination the graph to which edges are to be added\n * @param source the graph used as a source for edges to add\n * @param edges the edges to be added\n *\n * @return <tt>true</tt> if this graph changed as a result of the call\n */\npublic static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges) {\n    boolean modified = false;\n    for (E e : edges) {\n        V s = source.getEdgeSource(e);\n        V t = source.getEdgeTarget(e);\n        destination.addVertex(s);\n        destination.addVertex(t);\n        modified |= destination.addEdge(s, t, e);\n    }\n    return modified;\n}"
            ],
            [
                "addAllVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all of the specified vertices to the destination graph. The behavior\n * of this operation is undefined if the specified vertex collection is\n * modified while the operation is in progress. This method will invoke the\n * {@link Graph#addVertex(Object)} method.\n *\n * @param destination the graph to which edges are to be added\n * @param vertices the vertices to be added to the graph.\n *\n * @return <tt>true</tt> if graph changed as a result of the call\n *\n * @throws NullPointerException if the specified vertices contains one or\n * more null vertices, or if the specified vertex collection is <tt>\n * null</tt>.\n *\n * @see Graph#addVertex(Object)\n */\npublic static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices) {\n    boolean modified = false;\n    for (V v : vertices) {\n        modified |= destination.addVertex(v);\n    }\n    return modified;\n}"
            ],
            [
                "neighborListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the neighbors of a specified vertex.\n * If the graph is a multigraph vertices may appear more than once in the\n * returned list.\n *\n * @param g the graph to look for neighbors in.\n * @param vertex the vertex to get the neighbors of.\n *\n * @return a list of the vertices that are the neighbors of the specified\n * vertex.\n */\npublic static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex) {\n    List<V> neighbors = new ArrayList<V>();\n    for (E e : g.edgesOf(vertex)) {\n        neighbors.add(getOppositeVertex(g, e, vertex));\n    }\n    return neighbors;\n}"
            ],
            [
                "predecessorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct predecessors of a\n * specified vertex. If the graph is a multigraph, vertices may appear more\n * than once in the returned list.\n *\n * @param g the graph to look for predecessors in.\n * @param vertex the vertex to get the predecessors of.\n *\n * @return a list of the vertices that are the direct predecessors of the\n * specified vertex.\n */\npublic static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> predecessors = new ArrayList<V>();\n    Set<? extends E> edges = g.incomingEdgesOf(vertex);\n    for (E e : edges) {\n        predecessors.add(getOppositeVertex(g, e, vertex));\n    }\n    return predecessors;\n}"
            ],
            [
                "successorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct successors of a specified\n * vertex. If the graph is a multigraph vertices may appear more than once\n * in the returned list.\n *\n * @param g the graph to look for successors in.\n * @param vertex the vertex to get the successors of.\n *\n * @return a list of the vertices that are the direct successors of the\n * specified vertex.\n */\npublic static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> successors = new ArrayList<V>();\n    Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n    for (E e : edges) {\n        successors.add(getOppositeVertex(g, e, vertex));\n    }\n    return successors;\n}"
            ],
            [
                "undirectedGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns an undirected view of the specified graph. If the specified graph\n * is directed, returns an undirected view of it. If the specified graph is\n * already undirected, just returns it.\n *\n * @param g the graph for which an undirected view is to be returned.\n *\n * @return an undirected view of the specified graph, if it is directed, or\n * or the specified graph itself if it is already undirected.\n *\n * @throws IllegalArgumentException if the graph is neither DirectedGraph\n * nor UndirectedGraph.\n *\n * @see AsUndirectedGraph\n */\npublic static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n    } else if (g instanceof UndirectedGraph<?, ?>) {\n        return (UndirectedGraph<V, E>) g;\n    } else {\n        throw new IllegalArgumentException(\"Graph must be either DirectedGraph or UndirectedGraph\");\n    }\n}"
            ],
            [
                "testIncidence",
                "org.jgrapht",
                "Graphs",
                "/**\n * Tests whether an edge is incident to a vertex.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return true iff e is incident on v\n */\npublic static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v) {\n    return (g.getEdgeSource(e).equals(v)) || (g.getEdgeTarget(e).equals(v));\n}"
            ],
            [
                "getOppositeVertex",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the vertex opposite another vertex across an edge.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return vertex opposite to v across e\n */\npublic static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v) {\n    V source = g.getEdgeSource(e);\n    V target = g.getEdgeTarget(e);\n    if (v.equals(source)) {\n        return target;\n    } else if (v.equals(target)) {\n        return source;\n    } else {\n        throw new IllegalArgumentException(\"no such vertex: \" + v.toString());\n    }\n}"
            ],
            [
                "getPathVertexList",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the list of vertices visited by a path.\n *\n * @param path path of interest\n *\n * @return corresponding vertex list\n */\npublic static <V, E> List<V> getPathVertexList(GraphPath<V, E> path) {\n    Graph<V, E> g = path.getGraph();\n    List<V> list = new ArrayList<V>();\n    V v = path.getStartVertex();\n    list.add(v);\n    for (E e : path.getEdgeList()) {\n        v = getOppositeVertex(g, e, v);\n        list.add(v);\n    }\n    return list;\n}"
            ],
            [
                "range",
                "org.jgrapht.generate",
                "SimpleWeightedGraphMatrixGenerator",
                "///////////////////////////////////////////////////////////////////////////////////////////////\npublic static int[] range(final int from, final int to) {\n    int[] range = new int[to - from];\n    for (int i = from; i < to; ++i) {\n        range[i - from] = i;\n    }\n    return range;\n}"
            ],
            [
                "createGraphSpecifics",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "// -------------------------------------------------------------------------\n/**\n * @param <V>\n * @param <E>\n * @param g\n *\n * @return TODO Document me\n */\nstatic <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new DirectedSpecifics<V, E>((DirectedGraph<V, E>) g);\n    } else {\n        return new UndirectedSpecifics<V, E>(g);\n    }\n}"
            ],
            [
                "findGreedyChromaticNumber",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds the number of colors required for a greedy coloring of the graph.\n *\n * @param g an undirected graph to find the chromatic number of\n *\n * @return integer the approximate chromatic number from the greedy\n * algorithm\n */\npublic static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g) {\n    Map<Integer, Set<V>> coloredGroups = findGreedyColoredGroups(g);\n    return coloredGroups.keySet().size();\n}"
            ],
            [
                "findGreedyColoredGroups",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds a greedy coloring of the graph.\n *\n * @param g an undirected graph for which to find the coloring\n */\npublic static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g) {\n    // A copy of the graph is made, so that elements of the graph may be\n    // removed to carry out the algorithm\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // The Vertices will be sorted in decreasing order by degree, so that\n    // higher degree vertices have priority to be colored first\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    List<V> sortedVertices = new LinkedList<V>(sg.vertexSet());\n    Collections.sort(sortedVertices, comp);\n    Collections.reverse(sortedVertices);\n    int color;\n    // create a map which will hold color as key and Set<V> as value\n    Map<Integer, Set<V>> coloredGroups = new HashMap<Integer, Set<V>>();\n    // We'll attempt to color each vertex with a single color each\n    // iteration, and these vertices will be removed from the graph at the\n    // end of each iteration\n    for (color = 0; sg.vertexSet().size() > 0; color++) {\n        // This set will contain vertices that are colored with the\n        // current color of this iteration\n        Set<V> currentColor = new HashSet<V>();\n        for (Iterator<V> iter = sortedVertices.iterator(); iter.hasNext(); ) {\n            V v = iter.next();\n            // Add new vertices to be colored as long as they are not\n            // adjacent with any other vertex that has already been colored\n            // with the current color\n            boolean flag = true;\n            for (Iterator<V> innerIter = currentColor.iterator(); innerIter.hasNext(); ) {\n                V temp = innerIter.next();\n                if (sg.containsEdge(temp, v)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                currentColor.add(v);\n                iter.remove();\n            }\n        }\n        // Add all these vertices as a group for this color\n        coloredGroups.put(color, currentColor);\n        // Remove vertices from the graph and then repeat the process for\n        // the next iteration\n        sg.removeAllVertices(currentColor);\n    }\n    return coloredGroups;\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "BellmanFordShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by hops, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    BellmanFordShortestPath<V, E> alg = new BellmanFordShortestPath<V, E>(graph, startVertex);\n    return alg.getPathEdgeList(endVertex);\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "DijkstraShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by radius, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    DijkstraShortestPath<V, E> alg = new DijkstraShortestPath<V, E>(graph, startVertex, endVertex);\n    return alg.getPathEdgeList();\n}"
            ],
            [
                "of",
                "org.jgrapht.alg.util",
                "Pair",
                "/**\n * Creates new pair of elements pulling of the necessity to provide\n * corresponding types of the elements supplied\n *\n * @param a first element\n * @param b second element\n *\n * @return new pair\n */\npublic static <A, B> Pair<A, B> of(A a, B b) {\n    return new Pair<A, B>(a, b);\n}"
            ],
            [
                "isEulerian",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will check whether the graph passed in is Eulerian or not.\n *\n * @param g The graph to be checked\n *\n * @return true for Eulerian and false for non-Eulerian\n */\npublic static <V, E> boolean isEulerian(UndirectedGraph<V, E> g) {\n    // If the graph is not connected, then no Eulerian circuit exists\n    if (!(new ConnectivityInspector<V, E>(g)).isGraphConnected()) {\n        return false;\n    }\n    // A graph is Eulerian if and only if all vertices have even degree\n    // So, this code will check for that\n    Iterator<V> iter = g.vertexSet().iterator();\n    while (iter.hasNext()) {\n        V v = iter.next();\n        if ((g.degreeOf(v) % 2) == 1) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "getEulerianCircuitVertices",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will return a list of vertices which represents the Eulerian\n * circuit of the graph.\n *\n * @param g The graph to find an Eulerian circuit\n *\n * @return null if no Eulerian circuit exists, or a list of vertices\n * representing the Eulerian circuit if one does exist\n */\npublic static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g) {\n    // If the graph is not Eulerian then just return a null since no\n    // Eulerian circuit exists\n    if (!isEulerian(g)) {\n        return null;\n    }\n    // The circuit will be represented by a linked list\n    List<V> path = new LinkedList<V>();\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    path.add(sg.vertexSet().iterator().next());\n    // Algorithm for finding an Eulerian circuit Basically this will find an\n    // arbitrary circuit, then it will find another arbitrary circuit until\n    // every edge has been traversed\n    while (sg.edgeSet().size() > 0) {\n        V v = null;\n        // Find a vertex which has an edge that hasn't been traversed yet,\n        // and keep its index position in the circuit list\n        int index = 0;\n        for (Iterator<V> iter = path.iterator(); iter.hasNext(); index++) {\n            v = iter.next();\n            if (sg.degreeOf(v) > 0) {\n                break;\n            }\n        }\n        // Finds an arbitrary circuit of the current vertex and\n        // appends this into the circuit list\n        while (sg.degreeOf(v) > 0) {\n            for (Iterator<V> iter = sg.vertexSet().iterator(); iter.hasNext(); ) {\n                V temp = iter.next();\n                if (sg.containsEdge(v, temp)) {\n                    path.add(index, temp);\n                    sg.removeEdge(v, temp);\n                    v = temp;\n                    break;\n                }\n            }\n        }\n    }\n    return path;\n}"
            ],
            [
                "getApproximateOptimalForCompleteGraph",
                "org.jgrapht.alg",
                "HamiltonianCycle",
                "/**\n * This method will return an approximate minimal traveling salesman tour\n * (hamiltonian cycle). This algorithm requires that the graph be complete\n * and the triangle inequality exists (if x,y,z are vertices then\n * d(x,y)+d(y,z) &lt; d(x,z) for all x,y,z) then this algorithm will\n * guarantee a hamiltonian cycle such that the total weight of the cycle is\n * less than or equal to double the total weight of the optimal hamiltonian\n * cycle. The optimal solution is NP-complete, so this is a decent\n * approximation that runs in polynomial time.\n *\n * @param <V>\n * @param <E>\n * @param g is the graph to find the optimal tour for.\n *\n * @return The optimal tour as a list of vertices.\n */\npublic static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g) {\n    List<V> vertices = new LinkedList<V>(g.vertexSet());\n    // If the graph is not complete then return null since this algorithm\n    // requires the graph be complete\n    if ((vertices.size() * (vertices.size() - 1) / 2) != g.edgeSet().size()) {\n        return null;\n    }\n    List<V> tour = new LinkedList<V>();\n    // Each iteration a new vertex will be added to the tour until all\n    // vertices have been added\n    while (tour.size() != g.vertexSet().size()) {\n        boolean firstEdge = true;\n        double minEdgeValue = 0;\n        int minVertexFound = 0;\n        int vertexConnectedTo = 0;\n        // A check will be made for the shortest edge to a vertex not within\n        // the tour and that new vertex will be added to the vertex\n        for (int i = 0; i < tour.size(); i++) {\n            V v = tour.get(i);\n            for (int j = 0; j < vertices.size(); j++) {\n                double weight = g.getEdgeWeight(g.getEdge(v, vertices.get(j)));\n                if (firstEdge || (weight < minEdgeValue)) {\n                    firstEdge = false;\n                    minEdgeValue = weight;\n                    minVertexFound = j;\n                    vertexConnectedTo = i;\n                }\n            }\n        }\n        tour.add(vertexConnectedTo, vertices.get(minVertexFound));\n        vertices.remove(minVertexFound);\n    }\n    return tour;\n}"
            ],
            [
                "find2ApproximationCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a 2-approximation for a minimal vertex cover of the specified\n * graph. The algorithm promises a cover that is at most double the size of\n * a minimal cover. The algorithm takes O(|E|) time.\n *\n * <p>For more details see Jenny Walter, CMPU-240: Lecture notes for\n * Language Theory and Computation, Fall 2002, Vassar College, <a\n * href=\"http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf\">\n * http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf</a>.\n * </p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G'=(V',E') <-- G(V,E)\n    Subgraph<V, E, Graph<V, E>> sg = new Subgraph<V, E, Graph<V, E>>(g, null, null);\n    // while E' is non-empty\n    while (sg.edgeSet().size() > 0) {\n        // let (u,v) be an arbitrary edge of E'\n        E e = sg.edgeSet().iterator().next();\n        // C <-- C U {u,v}\n        V u = g.getEdgeSource(e);\n        V v = g.getEdgeTarget(e);\n        cover.add(u);\n        cover.add(v);\n        // remove from E' every edge incident on either u or v\n        sg.removeVertex(u);\n        sg.removeVertex(v);\n    }\n    // return C\n    return cover;\n}"
            ],
            [
                "findGreedyCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a greedy approximation for a minimal vertex cover of a specified\n * graph. At each iteration, the algorithm picks the vertex with the highest\n * degree and adds it to the cover, until all edges are covered.\n *\n * <p>The algorithm works on undirected graphs, but can also work on\n * directed graphs when their edge-directions are ignored. To ignore edge\n * directions you can use {@link org.jgrapht.Graphs#undirectedGraph(Graph)}\n * or {@link org.jgrapht.graph.AsUndirectedGraph}.</p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G' <-- G\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // compare vertices in descending order of degree\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    // while G' != {}\n    while (sg.edgeSet().size() > 0) {\n        // v <-- vertex with maximum degree in G'\n        V v = Collections.max(sg.vertexSet(), comp);\n        // C <-- C U {v}\n        cover.add(v);\n        // remove from G' every edge incident on v, and v itself\n        sg.removeVertex(v);\n    }\n    return cover;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "BEST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int BEST_ORDER = 0;"
            ],
            [
                "NATURAL_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int NATURAL_ORDER = 1;"
            ],
            [
                "SMALLEST_DEGREE_LAST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;"
            ],
            [
                "LARGEST_SATURATION_FIRST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;"
            ],
            [
                "DEFAULT_EDGE_WEIGHT",
                "org.jgrapht",
                "WeightedGraph",
                "/**\n * The default weight for an edge.\n */\npublic static double DEFAULT_EDGE_WEIGHT = 1.0;"
            ],
            [
                "HUB_VERTEX",
                "org.jgrapht.generate",
                "WheelGraphGenerator",
                "/**\n * Role for the hub vertex.\n */\npublic static final String HUB_VERTEX = \"Hub Vertex\";"
            ],
            [
                "CORNER_VERTEX",
                "org.jgrapht.generate",
                "GridGraphGenerator",
                "/**\n * Role for the vertices at the corners.\n */\npublic static final String CORNER_VERTEX = \"Corner Vertex\";"
            ],
            [
                "START_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the first vertex generated.\n */\npublic static final String START_VERTEX = \"Start Vertex\";"
            ],
            [
                "END_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the last vertex generated.\n */\npublic static final String END_VERTEX = \"End Vertex\";"
            ],
            [
                "CENTER_VERTEX",
                "org.jgrapht.generate",
                "StarGraphGenerator",
                "public static final String CENTER_VERTEX = \"Center Vertex\";"
            ],
            [
                "SENTINEL",
                "org.jgrapht.traverse",
                "DepthFirstIterator",
                "/**\n * Sentinel object. Unfortunately, we can't use null, because ArrayDeque\n * won't accept those. And we don't want to rely on the caller to provide a\n * sentinel object for us. So we have to play typecasting games.\n */\npublic static final Object SENTINEL = new Object();"
            ],
            [
                "BEFORE_EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge added event. This event is fired before an edge is added to a\n * graph.\n */\npublic static final int BEFORE_EDGE_ADDED = 21;"
            ],
            [
                "BEFORE_EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge removed event. This event is fired before an edge is removed\n * from a graph.\n */\npublic static final int BEFORE_EDGE_REMOVED = 22;"
            ],
            [
                "EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge added event. This event is fired after an edge is added to a graph.\n */\npublic static final int EDGE_ADDED = 23;"
            ],
            [
                "EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge removed event. This event is fired after an edge is removed from a\n * graph.\n */\npublic static final int EDGE_REMOVED = 24;"
            ],
            [
                "CONNECTED_COMPONENT_STARTED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal started event.\n */\npublic static final int CONNECTED_COMPONENT_STARTED = 31;"
            ],
            [
                "CONNECTED_COMPONENT_FINISHED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal finished event.\n */\npublic static final int CONNECTED_COMPONENT_FINISHED = 32;"
            ],
            [
                "BEFORE_VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex added event. This event is fired before a vertex is added\n * to a graph.\n */\npublic static final int BEFORE_VERTEX_ADDED = 11;"
            ],
            [
                "BEFORE_VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex removed event. This event is fired before a vertex is\n * removed from a graph.\n */\npublic static final int BEFORE_VERTEX_REMOVED = 12;"
            ],
            [
                "VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex added event. This event is fired after a vertex is added to a\n * graph.\n */\npublic static final int VERTEX_ADDED = 13;"
            ],
            [
                "VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex removed event. This event is fired after a vertex is removed from\n * a graph.\n */\npublic static final int VERTEX_REMOVED = 14;"
            ],
            [
                "NULL_NODE",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "public static final int NULL_NODE = -1;"
            ],
            [
                "DEBUG",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected static final boolean DEBUG = false;"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg",
                "EdmondsKarpMaximumFlow",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 0.000000001;"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveClosure",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveClosure INSTANCE = new TransitiveClosure();"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveReduction",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveReduction INSTANCE = new TransitiveReduction();"
            ],
            [
                "NEGATIVE_UNDIRECTED_EDGE",
                "org.jgrapht.alg",
                "BellmanFordIterator",
                "/**\n * Error message.\n */\nprotected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg.flow",
                "MaximumFlowAlgorithmBase",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 1e-9;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "isCrossComponentTraversal",
                "org.jgrapht.traverse",
                "GraphIterator",
                "/**\n * Test whether this iterator is set to traverse the grpah across connected\n * components.\n *\n * @return <code>true</code> if traverses across connected components,\n * otherwise <code>false</code>.\n */\npublic boolean isCrossComponentTraversal();"
            ],
            [
                "hasNext",
                "java.util",
                "Iterator",
                "public abstract boolean hasNext()"
            ],
            [
                "next",
                "java.util",
                "Iterator",
                "public abstract E next()"
            ],
            [
                "isReuseEvents",
                "org.jgrapht.traverse",
                "GraphIterator",
                "/**\n * Tests whether the <code>reuseEvents</code> flag is set. If the flag is\n * set to <code>true</code> this class will reuse previously fired events\n * and will not create a new object for each event. This option increases\n * performance but should be used with care, especially in multithreaded\n * environment.\n *\n * @return the value of the <code>reuseEvents</code> flag.\n */\npublic boolean isReuseEvents();"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    }
]