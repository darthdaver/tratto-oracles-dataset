[ {
  "id" : 26655,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.alg",
  "className" : "BellmanFordIterator",
  "javadocTag" : "@throws IllegalArgumentException if the graph is undirected and the\nedge-weight is negative.",
  "methodJavadoc" : "    /**\n     * @param edge\n     *\n     * @throws IllegalArgumentException if the graph is undirected and the\n     * edge-weight is negative.\n     */",
  "methodSourceCode" : "protected void assertValidEdge(E edge){\n    if (this.graph instanceof UndirectedGraph<?, ?>) {\n        if (graph.getEdgeWeight(edge) < 0) {\n            throw new IllegalArgumentException(NEGATIVE_UNDIRECTED_EDGE);\n        }\n    }\n}",
  "classJavadoc" : "/**\n * Helper class for {@link BellmanFordShortestPath}; not intended for general\n * use.\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------------\n * BellmanFordIterator.java\n * -------------------------\n * (C) Copyright 2006-2008, by France Telecom and Contributors.\n *\n * Original Author:  Guillaume Boulmier and Contributors.\n * Contributor(s):   John V. Sichi\n *\n * $Id$\n *\n * Changes\n * -------\n * 05-Jan-2006 : Initial revision (GB);\n * 14-Jan-2006 : Added support for generics (JVS);\n *\n */\npackage org.jgrapht.alg;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\n\n\n/**\n * Helper class for {@link BellmanFordShortestPath}; not intended for general\n * use.\n */\nclass BellmanFordIterator<V, E>\n    implements Iterator<List<V>>\n{\n    /**\n     * Error message.\n     */\n    protected final static String NEGATIVE_UNDIRECTED_EDGE =\n        \"Negative\"\n        + \"edge-weights are not allowed in an unidrected graph!\";\n\n    /**\n     * Graph on which shortest paths are searched.\n     */\n    protected Graph<V, E> graph;\n\n    /**\n     * Start vertex.\n     */\n    protected V startVertex;\n\n    /**\n     * Vertices whose shortest path cost have been improved during the previous\n     * pass.\n     */\n    private List<V> prevImprovedVertices = new ArrayList<V>();\n\n    private Map<V, BellmanFordPathElement<V, E>> prevVertexData;\n\n    private boolean startVertexEncountered = false;\n\n    /**\n     * Stores the vertices that have been seen during iteration and (optionally)\n     * some additional traversal info regarding each vertex.\n     */\n    private Map<V, BellmanFordPathElement<V, E>> vertexData;\n\n    private double epsilon;\n\n    /**\n     * @param graph\n     * @param startVertex start vertex.\n     * @param epsilon tolerance factor.\n     */\n    protected BellmanFordIterator(\n        Graph<V, E> graph,\n        V startVertex,\n        double epsilon)\n    {\n        assertBellmanFordIterator(graph, startVertex);\n\n        this.graph = graph;\n        this.startVertex = startVertex;\n        this.epsilon = epsilon;\n    }\n\n    /**\n     * Returns the path element of the shortest path with less than <code>\n     * nMaxHops</code> edges between the start vertex and the end vertex.\n     *\n     * @param endVertex end vertex.\n     *\n     * @return .\n     */\n    public BellmanFordPathElement<V, E> getPathElement(V endVertex)\n    {\n        return getSeenData(endVertex);\n    }\n\n    /**\n     * @return <code>true</code> if at least one path has been improved during\n     * the previous pass, <code>false</code> otherwise.\n     */\n    @Override public boolean hasNext()\n    {\n        if (!this.startVertexEncountered) {\n            encounterStartVertex();\n        }\n\n        return !(this.prevImprovedVertices.isEmpty());\n    }\n\n    /**\n     * Returns the list <code>Collection</code> of vertices whose path has been\n     * improved during the current pass.\n     *\n     * @see java.util.Iterator#next()\n     */\n    @Override public List<V> next()\n    {\n        if (!this.startVertexEncountered) {\n            encounterStartVertex();\n        }\n\n        if (hasNext()) {\n            List<V> improvedVertices = new ArrayList<V>();\n            for (int i = this.prevImprovedVertices.size() - 1; i >= 0; i--) {\n                V vertex = this.prevImprovedVertices.get(i);\n                for (\n                    Iterator<? extends E> iter = edgesOfIterator(vertex);\n                    iter.hasNext();)\n                {\n                    E edge = iter.next();\n                    V oppositeVertex =\n                        Graphs.getOppositeVertex(\n                            graph,\n                            edge,\n                            vertex);\n                    if (getPathElement(oppositeVertex) != null) {\n                        boolean relaxed =\n                            relaxVertexAgain(oppositeVertex, edge);\n                        if (relaxed) {\n                            improvedVertices.add(oppositeVertex);\n                        }\n                    } else {\n                        relaxVertex(oppositeVertex, edge);\n                        improvedVertices.add(oppositeVertex);\n                    }\n                }\n            }\n\n            savePassData(improvedVertices);\n\n            return improvedVertices;\n        }\n\n        throw new NoSuchElementException();\n    }\n\n    /**\n     * Unsupported\n     *\n     * @see java.util.Iterator#remove()\n     */\n    @Override public void remove()\n    {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * @param edge\n     *\n     * @throws IllegalArgumentException if the graph is undirected and the\n     * edge-weight is negative.\n     */\n    protected void assertValidEdge(E edge)\n    {\n        if (this.graph instanceof UndirectedGraph<?, ?>) {\n            if (graph.getEdgeWeight(edge) < 0) {\n                throw new IllegalArgumentException(NEGATIVE_UNDIRECTED_EDGE);\n            }\n        }\n    }\n\n    /**\n     * Costs taken into account are the weights stored in <code>Edge</code>\n     * objects.\n     *\n     * @param vertex a vertex which has just been encountered.\n     * @param edge the edge via which the vertex was encountered.\n     *\n     * @return the cost obtained by concatenation.\n     *\n     * @see Graph#getEdgeWeight(E)\n     */\n    protected double calculatePathCost(V vertex, E edge)\n    {\n        V oppositeVertex = Graphs.getOppositeVertex(graph, edge, vertex);\n\n        // we get the data of the previous pass.\n        BellmanFordPathElement<V, E> oppositePrevData =\n            getPrevSeenData(oppositeVertex);\n\n        double pathCost = graph.getEdgeWeight(edge);\n\n        if (!oppositePrevData.getVertex().equals(this.startVertex)) {\n            // if it's not the start vertex, we add the cost of the previous\n            // pass.\n            pathCost += oppositePrevData.getCost();\n        }\n\n        return pathCost;\n    }\n\n    /**\n     * Returns an iterator to loop over outgoing edges <code>Edge</code> of the\n     * vertex.\n     *\n     * @param vertex\n     *\n     * @return .\n     */\n    protected Iterator<E> edgesOfIterator(V vertex)\n    {\n        if (this.graph instanceof DirectedGraph<?, ?>) {\n            return ((DirectedGraph<V, E>) this.graph).outgoingEdgesOf(vertex)\n                .iterator();\n        } else {\n            return this.graph.edgesOf(vertex).iterator();\n        }\n    }\n\n    /**\n     * Access the data stored for a seen vertex in the previous pass.\n     *\n     * @param vertex a vertex which has already been seen.\n     *\n     * @return data associated with the seen vertex or <code>null</code> if no\n     * data was associated with the vertex.\n     */\n    protected BellmanFordPathElement<V, E> getPrevSeenData(V vertex)\n    {\n        return this.prevVertexData.get(vertex);\n    }\n\n    /**\n     * Access the data stored for a seen vertex in the current pass.\n     *\n     * @param vertex a vertex which has already been seen.\n     *\n     * @return data associated with the seen vertex or <code>null</code> if no\n     * data was associated with the vertex.\n     */\n    protected BellmanFordPathElement<V, E> getSeenData(V vertex)\n    {\n        return this.vertexData.get(vertex);\n    }\n\n    /**\n     * Determines whether a vertex has been seen yet by this traversal.\n     *\n     * @param vertex vertex in question.\n     *\n     * @return <tt>true</tt> if vertex has already been seen.\n     */\n    protected boolean isSeenVertex(V vertex)\n    {\n        return this.vertexData.containsKey(vertex);\n    }\n\n    /**\n     * @param vertex\n     * @param data\n     *\n     * @return .\n     */\n    protected BellmanFordPathElement<V, E> putPrevSeenData(\n        V vertex,\n        BellmanFordPathElement<V, E> data)\n    {\n        if (this.prevVertexData == null) {\n            this.prevVertexData =\n                new HashMap<V, BellmanFordPathElement<V, E>>();\n        }\n\n        return this.prevVertexData.put(vertex, data);\n    }\n\n    /**\n     * Stores iterator-dependent data for a vertex that has been seen during the\n     * current pass.\n     *\n     * @param vertex a vertex which has been seen.\n     * @param data data to be associated with the seen vertex.\n     *\n     * @return previous value associated with specified vertex or <code>\n     * null</code> if no data was associated with the vertex.\n     */\n    protected BellmanFordPathElement<V, E> putSeenData(\n        V vertex,\n        BellmanFordPathElement<V, E> data)\n    {\n        if (this.vertexData == null) {\n            this.vertexData = new HashMap<V, BellmanFordPathElement<V, E>>();\n        }\n\n        return this.vertexData.put(vertex, data);\n    }\n\n    private void assertBellmanFordIterator(Graph<V, E> graph, V startVertex)\n    {\n        if (!(graph.containsVertex(startVertex))) {\n            throw new IllegalArgumentException(\n                \"Graph must contain the start vertex!\");\n        }\n    }\n\n    /**\n     * The first time we see a vertex, make up a new entry for it.\n     *\n     * @param vertex a vertex which has just been encountered.\n     * @param edge the edge via which the vertex was encountered.\n     * @param cost cost of the created path element.\n     *\n     * @return the new entry.\n     */\n    private BellmanFordPathElement<V, E> createSeenData(\n        V vertex,\n        E edge,\n        double cost)\n    {\n        BellmanFordPathElement<V, E> prevPathElement =\n            getPrevSeenData(\n                Graphs.getOppositeVertex(graph, edge, vertex));\n\n        BellmanFordPathElement<V, E> data =\n            new BellmanFordPathElement<V, E>(\n                graph,\n                prevPathElement,\n                edge,\n                cost,\n                epsilon);\n\n        return data;\n    }\n\n    private void encounterStartVertex()\n    {\n        BellmanFordPathElement<V, E> data =\n            new BellmanFordPathElement<V, E>(\n                this.startVertex,\n                epsilon);\n\n        // first the only vertex considered as improved is the start vertex.\n        this.prevImprovedVertices.add(this.startVertex);\n\n        putSeenData(this.startVertex, data);\n        putPrevSeenData(this.startVertex, data);\n\n        this.startVertexEncountered = true;\n    }\n\n    /**\n     * Upates data first time a vertex is reached by a path.\n     *\n     * @param vertex a vertex which has just been encountered.\n     * @param edge the edge via which the vertex was encountered.\n     */\n    private void relaxVertex(V vertex, E edge)\n    {\n        assertValidEdge(edge);\n\n        double shortestPathCost = calculatePathCost(vertex, edge);\n\n        BellmanFordPathElement<V, E> data =\n            createSeenData(vertex, edge,\n                shortestPathCost);\n\n        putSeenData(vertex, data);\n    }\n\n    /**\n     * Check if the cost of the best path so far reaching the specified vertex\n     * could be improved if the vertex is reached through the specified edge.\n     *\n     * @param vertex a vertex which has just been encountered.\n     * @param edge the edge via which the vertex was encountered.\n     *\n     * @return <code>true</code> if the cost has been improved, <code>\n     * false</code> otherwise.\n     */\n    private boolean relaxVertexAgain(V vertex, E edge)\n    {\n        assertValidEdge(edge);\n\n        double candidateCost = calculatePathCost(vertex, edge);\n\n        // we get the data of the previous pass.\n        BellmanFordPathElement<V, E> oppositePrevData =\n            getPrevSeenData(\n                Graphs.getOppositeVertex(graph, edge, vertex));\n\n        BellmanFordPathElement<V, E> pathElement = getSeenData(vertex);\n        return pathElement.improve(oppositePrevData, edge, candidateCost);\n    }\n\n    private void savePassData(List<V> improvedVertices)\n    {\n        for (V vertex : improvedVertices) {\n            BellmanFordPathElement<V, E> orig = getSeenData(vertex);\n            BellmanFordPathElement<V, E> clonedData =\n                new BellmanFordPathElement<V, E>(orig);\n            putPrevSeenData(vertex, clonedData);\n        }\n\n        this.prevImprovedVertices = improvedVertices;\n    }\n}\n\n// End BellmanFordIterator.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "edge", "", "E" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "putSeenData", "org.jgrapht.alg", "BellmanFordIterator", "protected BellmanFordPathElement<V, E> putSeenData(V vertex, BellmanFordPathElement<V, E> data)" ], [ "putPrevSeenData", "org.jgrapht.alg", "BellmanFordIterator", "protected BellmanFordPathElement<V, E> putPrevSeenData(V vertex, BellmanFordPathElement<V, E> data)" ], [ "next", "java.util", "Iterator", "public abstract E next()" ], [ "calculatePathCost", "org.jgrapht.alg", "BellmanFordIterator", "protected double calculatePathCost(V vertex, E edge)" ], [ "isSeenVertex", "org.jgrapht.alg", "BellmanFordIterator", "protected boolean isSeenVertex(V vertex)" ], [ "getPathElement", "org.jgrapht.alg", "BellmanFordIterator", "public BellmanFordPathElement<V, E> getPathElement(V endVertex)" ], [ "hasNext", "org.jgrapht.alg", "BellmanFordIterator", "public boolean hasNext()" ], [ "edgesOfIterator", "org.jgrapht.alg", "BellmanFordIterator", "protected Iterator<E> edgesOfIterator(V vertex)" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getPrevSeenData", "org.jgrapht.alg", "BellmanFordIterator", "protected BellmanFordPathElement<V, E> getPrevSeenData(V vertex)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "getSeenData", "org.jgrapht.alg", "BellmanFordIterator", "protected BellmanFordPathElement<V, E> getSeenData(V vertex)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "next", "org.jgrapht.alg", "BellmanFordIterator", "public List<V> next()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "graph", "org.jgrapht.alg", "BellmanFordIterator", "protected Graph<V,E> graph;" ], [ "startVertex", "org.jgrapht.alg", "BellmanFordIterator", "protected V startVertex;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 26670,
  "oracle" : ";",
  "oracleType" : "PRE",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.alg",
  "className" : "BellmanFordIterator",
  "javadocTag" : "@param vertex a vertex which has been seen.",
  "methodJavadoc" : "    /**\n     * Stores iterator-dependent data for a vertex that has been seen during the\n     * current pass.\n     *\n     * @param vertex a vertex which has been seen.\n     * @param data data to be associated with the seen vertex.\n     *\n     * @return previous value associated with specified vertex or <code>\n     * null</code> if no data was associated with the vertex.\n     */",
  "methodSourceCode" : "protected BellmanFordPathElement<V, E> putSeenData(V vertex, BellmanFordPathElement<V, E> data){\n    if (this.vertexData == null) {\n        this.vertexData = new HashMap<V, BellmanFordPathElement<V, E>>();\n    }\n    return this.vertexData.put(vertex, data);\n}",
  "classJavadoc" : "/**\n * Helper class for {@link BellmanFordShortestPath}; not intended for general\n * use.\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------------\n * BellmanFordIterator.java\n * -------------------------\n * (C) Copyright 2006-2008, by France Telecom and Contributors.\n *\n * Original Author:  Guillaume Boulmier and Contributors.\n * Contributor(s):   John V. Sichi\n *\n * $Id$\n *\n * Changes\n * -------\n * 05-Jan-2006 : Initial revision (GB);\n * 14-Jan-2006 : Added support for generics (JVS);\n *\n */\npackage org.jgrapht.alg;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\n\n\n/**\n * Helper class for {@link BellmanFordShortestPath}; not intended for general\n * use.\n */\nclass BellmanFordIterator<V, E>\n    implements Iterator<List<V>>\n{\n    /**\n     * Error message.\n     */\n    protected final static String NEGATIVE_UNDIRECTED_EDGE =\n        \"Negative\"\n        + \"edge-weights are not allowed in an unidrected graph!\";\n\n    /**\n     * Graph on which shortest paths are searched.\n     */\n    protected Graph<V, E> graph;\n\n    /**\n     * Start vertex.\n     */\n    protected V startVertex;\n\n    /**\n     * Vertices whose shortest path cost have been improved during the previous\n     * pass.\n     */\n    private List<V> prevImprovedVertices = new ArrayList<V>();\n\n    private Map<V, BellmanFordPathElement<V, E>> prevVertexData;\n\n    private boolean startVertexEncountered = false;\n\n    /**\n     * Stores the vertices that have been seen during iteration and (optionally)\n     * some additional traversal info regarding each vertex.\n     */\n    private Map<V, BellmanFordPathElement<V, E>> vertexData;\n\n    private double epsilon;\n\n    /**\n     * @param graph\n     * @param startVertex start vertex.\n     * @param epsilon tolerance factor.\n     */\n    protected BellmanFordIterator(\n        Graph<V, E> graph,\n        V startVertex,\n        double epsilon)\n    {\n        assertBellmanFordIterator(graph, startVertex);\n\n        this.graph = graph;\n        this.startVertex = startVertex;\n        this.epsilon = epsilon;\n    }\n\n    /**\n     * Returns the path element of the shortest path with less than <code>\n     * nMaxHops</code> edges between the start vertex and the end vertex.\n     *\n     * @param endVertex end vertex.\n     *\n     * @return .\n     */\n    public BellmanFordPathElement<V, E> getPathElement(V endVertex)\n    {\n        return getSeenData(endVertex);\n    }\n\n    /**\n     * @return <code>true</code> if at least one path has been improved during\n     * the previous pass, <code>false</code> otherwise.\n     */\n    @Override public boolean hasNext()\n    {\n        if (!this.startVertexEncountered) {\n            encounterStartVertex();\n        }\n\n        return !(this.prevImprovedVertices.isEmpty());\n    }\n\n    /**\n     * Returns the list <code>Collection</code> of vertices whose path has been\n     * improved during the current pass.\n     *\n     * @see java.util.Iterator#next()\n     */\n    @Override public List<V> next()\n    {\n        if (!this.startVertexEncountered) {\n            encounterStartVertex();\n        }\n\n        if (hasNext()) {\n            List<V> improvedVertices = new ArrayList<V>();\n            for (int i = this.prevImprovedVertices.size() - 1; i >= 0; i--) {\n                V vertex = this.prevImprovedVertices.get(i);\n                for (\n                    Iterator<? extends E> iter = edgesOfIterator(vertex);\n                    iter.hasNext();)\n                {\n                    E edge = iter.next();\n                    V oppositeVertex =\n                        Graphs.getOppositeVertex(\n                            graph,\n                            edge,\n                            vertex);\n                    if (getPathElement(oppositeVertex) != null) {\n                        boolean relaxed =\n                            relaxVertexAgain(oppositeVertex, edge);\n                        if (relaxed) {\n                            improvedVertices.add(oppositeVertex);\n                        }\n                    } else {\n                        relaxVertex(oppositeVertex, edge);\n                        improvedVertices.add(oppositeVertex);\n                    }\n                }\n            }\n\n            savePassData(improvedVertices);\n\n            return improvedVertices;\n        }\n\n        throw new NoSuchElementException();\n    }\n\n    /**\n     * Unsupported\n     *\n     * @see java.util.Iterator#remove()\n     */\n    @Override public void remove()\n    {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * @param edge\n     *\n     * @throws IllegalArgumentException if the graph is undirected and the\n     * edge-weight is negative.\n     */\n    protected void assertValidEdge(E edge)\n    {\n        if (this.graph instanceof UndirectedGraph<?, ?>) {\n            if (graph.getEdgeWeight(edge) < 0) {\n                throw new IllegalArgumentException(NEGATIVE_UNDIRECTED_EDGE);\n            }\n        }\n    }\n\n    /**\n     * Costs taken into account are the weights stored in <code>Edge</code>\n     * objects.\n     *\n     * @param vertex a vertex which has just been encountered.\n     * @param edge the edge via which the vertex was encountered.\n     *\n     * @return the cost obtained by concatenation.\n     *\n     * @see Graph#getEdgeWeight(E)\n     */\n    protected double calculatePathCost(V vertex, E edge)\n    {\n        V oppositeVertex = Graphs.getOppositeVertex(graph, edge, vertex);\n\n        // we get the data of the previous pass.\n        BellmanFordPathElement<V, E> oppositePrevData =\n            getPrevSeenData(oppositeVertex);\n\n        double pathCost = graph.getEdgeWeight(edge);\n\n        if (!oppositePrevData.getVertex().equals(this.startVertex)) {\n            // if it's not the start vertex, we add the cost of the previous\n            // pass.\n            pathCost += oppositePrevData.getCost();\n        }\n\n        return pathCost;\n    }\n\n    /**\n     * Returns an iterator to loop over outgoing edges <code>Edge</code> of the\n     * vertex.\n     *\n     * @param vertex\n     *\n     * @return .\n     */\n    protected Iterator<E> edgesOfIterator(V vertex)\n    {\n        if (this.graph instanceof DirectedGraph<?, ?>) {\n            return ((DirectedGraph<V, E>) this.graph).outgoingEdgesOf(vertex)\n                .iterator();\n        } else {\n            return this.graph.edgesOf(vertex).iterator();\n        }\n    }\n\n    /**\n     * Access the data stored for a seen vertex in the previous pass.\n     *\n     * @param vertex a vertex which has already been seen.\n     *\n     * @return data associated with the seen vertex or <code>null</code> if no\n     * data was associated with the vertex.\n     */\n    protected BellmanFordPathElement<V, E> getPrevSeenData(V vertex)\n    {\n        return this.prevVertexData.get(vertex);\n    }\n\n    /**\n     * Access the data stored for a seen vertex in the current pass.\n     *\n     * @param vertex a vertex which has already been seen.\n     *\n     * @return data associated with the seen vertex or <code>null</code> if no\n     * data was associated with the vertex.\n     */\n    protected BellmanFordPathElement<V, E> getSeenData(V vertex)\n    {\n        return this.vertexData.get(vertex);\n    }\n\n    /**\n     * Determines whether a vertex has been seen yet by this traversal.\n     *\n     * @param vertex vertex in question.\n     *\n     * @return <tt>true</tt> if vertex has already been seen.\n     */\n    protected boolean isSeenVertex(V vertex)\n    {\n        return this.vertexData.containsKey(vertex);\n    }\n\n    /**\n     * @param vertex\n     * @param data\n     *\n     * @return .\n     */\n    protected BellmanFordPathElement<V, E> putPrevSeenData(\n        V vertex,\n        BellmanFordPathElement<V, E> data)\n    {\n        if (this.prevVertexData == null) {\n            this.prevVertexData =\n                new HashMap<V, BellmanFordPathElement<V, E>>();\n        }\n\n        return this.prevVertexData.put(vertex, data);\n    }\n\n    /**\n     * Stores iterator-dependent data for a vertex that has been seen during the\n     * current pass.\n     *\n     * @param vertex a vertex which has been seen.\n     * @param data data to be associated with the seen vertex.\n     *\n     * @return previous value associated with specified vertex or <code>\n     * null</code> if no data was associated with the vertex.\n     */\n    protected BellmanFordPathElement<V, E> putSeenData(\n        V vertex,\n        BellmanFordPathElement<V, E> data)\n    {\n        if (this.vertexData == null) {\n            this.vertexData = new HashMap<V, BellmanFordPathElement<V, E>>();\n        }\n\n        return this.vertexData.put(vertex, data);\n    }\n\n    private void assertBellmanFordIterator(Graph<V, E> graph, V startVertex)\n    {\n        if (!(graph.containsVertex(startVertex))) {\n            throw new IllegalArgumentException(\n                \"Graph must contain the start vertex!\");\n        }\n    }\n\n    /**\n     * The first time we see a vertex, make up a new entry for it.\n     *\n     * @param vertex a vertex which has just been encountered.\n     * @param edge the edge via which the vertex was encountered.\n     * @param cost cost of the created path element.\n     *\n     * @return the new entry.\n     */\n    private BellmanFordPathElement<V, E> createSeenData(\n        V vertex,\n        E edge,\n        double cost)\n    {\n        BellmanFordPathElement<V, E> prevPathElement =\n            getPrevSeenData(\n                Graphs.getOppositeVertex(graph, edge, vertex));\n\n        BellmanFordPathElement<V, E> data =\n            new BellmanFordPathElement<V, E>(\n                graph,\n                prevPathElement,\n                edge,\n                cost,\n                epsilon);\n\n        return data;\n    }\n\n    private void encounterStartVertex()\n    {\n        BellmanFordPathElement<V, E> data =\n            new BellmanFordPathElement<V, E>(\n                this.startVertex,\n                epsilon);\n\n        // first the only vertex considered as improved is the start vertex.\n        this.prevImprovedVertices.add(this.startVertex);\n\n        putSeenData(this.startVertex, data);\n        putPrevSeenData(this.startVertex, data);\n\n        this.startVertexEncountered = true;\n    }\n\n    /**\n     * Upates data first time a vertex is reached by a path.\n     *\n     * @param vertex a vertex which has just been encountered.\n     * @param edge the edge via which the vertex was encountered.\n     */\n    private void relaxVertex(V vertex, E edge)\n    {\n        assertValidEdge(edge);\n\n        double shortestPathCost = calculatePathCost(vertex, edge);\n\n        BellmanFordPathElement<V, E> data =\n            createSeenData(vertex, edge,\n                shortestPathCost);\n\n        putSeenData(vertex, data);\n    }\n\n    /**\n     * Check if the cost of the best path so far reaching the specified vertex\n     * could be improved if the vertex is reached through the specified edge.\n     *\n     * @param vertex a vertex which has just been encountered.\n     * @param edge the edge via which the vertex was encountered.\n     *\n     * @return <code>true</code> if the cost has been improved, <code>\n     * false</code> otherwise.\n     */\n    private boolean relaxVertexAgain(V vertex, E edge)\n    {\n        assertValidEdge(edge);\n\n        double candidateCost = calculatePathCost(vertex, edge);\n\n        // we get the data of the previous pass.\n        BellmanFordPathElement<V, E> oppositePrevData =\n            getPrevSeenData(\n                Graphs.getOppositeVertex(graph, edge, vertex));\n\n        BellmanFordPathElement<V, E> pathElement = getSeenData(vertex);\n        return pathElement.improve(oppositePrevData, edge, candidateCost);\n    }\n\n    private void savePassData(List<V> improvedVertices)\n    {\n        for (V vertex : improvedVertices) {\n            BellmanFordPathElement<V, E> orig = getSeenData(vertex);\n            BellmanFordPathElement<V, E> clonedData =\n                new BellmanFordPathElement<V, E>(orig);\n            putPrevSeenData(vertex, clonedData);\n        }\n\n        this.prevImprovedVertices = improvedVertices;\n    }\n}\n\n// End BellmanFordIterator.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "vertex", "", "V" ], [ "data", "org.jgrapht.alg.BellmanFordPathElement", "BellmanFordPathElement<V, E>" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "next", "org.jgrapht.alg", "BellmanFordIterator", "public List<V> next()" ], [ "putPrevSeenData", "org.jgrapht.alg", "BellmanFordIterator", "protected BellmanFordPathElement<V, E> putPrevSeenData(V vertex, BellmanFordPathElement<V, E> data)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "next", "java.util", "Iterator", "public abstract E next()" ], [ "calculatePathCost", "org.jgrapht.alg", "BellmanFordIterator", "protected double calculatePathCost(V vertex, E edge)" ], [ "getPathElement", "org.jgrapht.alg", "BellmanFordIterator", "public BellmanFordPathElement<V, E> getPathElement(V endVertex)" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getSeenData", "org.jgrapht.alg", "BellmanFordIterator", "protected BellmanFordPathElement<V, E> getSeenData(V vertex)" ], [ "edgesOfIterator", "org.jgrapht.alg", "BellmanFordIterator", "protected Iterator<E> edgesOfIterator(V vertex)" ], [ "putSeenData", "org.jgrapht.alg", "BellmanFordIterator", "protected BellmanFordPathElement<V, E> putSeenData(V vertex, BellmanFordPathElement<V, E> data)" ], [ "hasNext", "org.jgrapht.alg", "BellmanFordIterator", "public boolean hasNext()" ], [ "isSeenVertex", "org.jgrapht.alg", "BellmanFordIterator", "protected boolean isSeenVertex(V vertex)" ], [ "getPrevSeenData", "org.jgrapht.alg", "BellmanFordIterator", "protected BellmanFordPathElement<V, E> getPrevSeenData(V vertex)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "improve", "org.jgrapht.alg", "BellmanFordPathElement", "protected boolean improve(BellmanFordPathElement<V, E> arg0, E arg1, double arg2)" ], [ "getCost", "org.jgrapht.alg", "BellmanFordPathElement", "public double getCost()" ], [ "getVertex", "org.jgrapht.alg", "AbstractPathElement", "public V getVertex()" ], [ "createEdgeListPath", "org.jgrapht.alg", "AbstractPathElement", "public List<E> createEdgeListPath()" ], [ "getPrevPathElement", "org.jgrapht.alg", "AbstractPathElement", "public AbstractPathElement<V, E> getPrevPathElement()" ], [ "getPrevEdge", "org.jgrapht.alg", "AbstractPathElement", "public E getPrevEdge()" ], [ "getHopCount", "org.jgrapht.alg", "AbstractPathElement", "public int getHopCount()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "graph", "org.jgrapht.alg", "BellmanFordIterator", "protected Graph<V,E> graph;" ], [ "startVertex", "org.jgrapht.alg", "BellmanFordIterator", "protected V startVertex;" ], [ "nHops", "org.jgrapht.alg", "AbstractPathElement", "protected int nHops;" ], [ "prevEdge", "org.jgrapht.alg", "AbstractPathElement", "protected E prevEdge;" ], [ "prevPathElement", "org.jgrapht.alg", "AbstractPathElement", "protected AbstractPathElement<V, E> prevPathElement;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
} ]