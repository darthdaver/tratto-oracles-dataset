[ {
  "id" : 10938,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "ArraysMDE",
  "javadocTag" : "@throws UnsupportedOperationException when the function is not invertible",
  "methodJavadoc" : "    /**\n   * Return the inverse of the given function, which is represented as an array.\n   * @param a an array representing a function from [0..a.length) to [0..arange);\n   *  each element of a is between 0 and arange inclusive\n   * @param arange length of the argument's range and the result's domain\n   * @return function from [0..arange) to [0..a.length) that is the inverse of a\n   * @throws IllegalArgumentException if a value of a is outside of arange\n   * @throws UnsupportedOperationException when the function is not invertible\n   */",
  "methodSourceCode" : "public static int[] fn_inverse(int[] a, int arange){\n    int[] result = new int[arange];\n    Arrays.fill(result, -1);\n    for (int i = 0; i < a.length; i++) {\n        int ai = a[i];\n        if (ai < -1 || ai >= arange) {\n            throw new IllegalArgumentException(String.format(\"Bad range value: a[%d]=%d\", i, ai));\n        }\n        // ai is either -1 or a valid index\n        if (ai >= 0) {\n            if (result[ai] != -1) {\n                throw new UnsupportedOperationException(String.format(\"Not invertible; a[%d]=%d and a[%d]=%d\", result[ai], ai, i, ai));\n            }\n            result[ai] = i;\n        }\n    }\n    return result;\n}",
  "classJavadoc" : "/**\n * Utilities for manipulating arrays and collections.\n * This complements {@link java.util.Arrays} and {@link java.util.Collections}.\n */",
  "classSourceCode" : "// If you edit this file, you must also edit its tests.\n// For tests of this and the entire plume package, see class TestPlume.\n\npackage plume;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.Vector;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.dataflow.qual.*;\nimport org.checkerframework.framework.qual.PolyAll;\n*/\n\n/**\n * Utilities for manipulating arrays and collections.\n * This complements {@link java.util.Arrays} and {@link java.util.Collections}.\n */\n@SuppressWarnings(\"interning\") // to do later\npublic final class ArraysMDE {\n  /** This class is a collecton of methods; it does not represent anything. */\n  private ArraysMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// min, max\n  ///\n\n  // Could also add linear-time orderStatistics if I liked.\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int min(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long min(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static double min(double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Integer min(Integer[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Integer[])\");\n    }\n    Integer result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() < result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Long min(Long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Long[])\");\n    }\n    Long result = a[0]; // to return a value actually in the array\n    long result_long = result.longValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].longValue() < result_long) {\n        result = a[i];\n        result_long = result.longValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Double min(Double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Double[])\");\n    }\n    Double result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() < result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int max(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long max(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static double max(double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Integer max(Integer[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Integer[])\");\n    }\n    Integer result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() > result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Long max(Long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Long[])\");\n    }\n    Long result = a[0]; // to return a value actually in the array\n    long result_long = result.longValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].longValue() > result_long) {\n        result = a[i];\n        result_long = result.longValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Double max(Double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Double[])\");\n    }\n    Double result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() > result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return a two-element array containing the smallest and largest values in the array.\n   * @param a an array\n   * @return a two-element array containing the smallest and largest values in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int[] min_max(int[] a) {\n    if (a.length == 0) {\n      // return null;\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(int[])\");\n    }\n    int result_min = a[0];\n    int result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result_min = Math.min(result_min, a[i]);\n      result_max = Math.max(result_max, a[i]);\n    }\n    return new int[] {result_min, result_max};\n  }\n\n  /**\n   * Return a two-element array containing the smallest and largest values in the array.\n   * @param a an array\n   * @return a two-element array containing the smallest and largest values in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long[] min_max(long[] a) {\n    if (a.length == 0) {\n      // return null;\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(long[])\");\n    }\n    long result_min = a[0];\n    long result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result_min = Math.min(result_min, a[i]);\n      result_max = Math.max(result_max, a[i]);\n    }\n    return new long[] {result_min, result_max};\n  }\n\n  /**\n   * Return the difference between the smallest and largest array elements.\n   * @param a an array\n   * @return the difference between the smallest and largest array elements\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int element_range(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(int[])\");\n    }\n    int[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n  }\n\n  /**\n   * Return the difference between the smallest and largest array elements.\n   * @param a an array\n   * @return the difference between the smallest and largest array elements\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long element_range(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(long[])\");\n    }\n    long[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n  }\n\n  /**\n   * Returns the sum of an array of integers.\n   * @param a an array\n   * @return the sum of an array of integers\n   */\n  public static int sum(int[] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      sum += a[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of all the elements of a 2d array of integers.\n   * @param a a 2d array\n   * @return the sum of all the elements of a 2d array of integers\n   */\n  public static int sum(int[][] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      for (int j = 0; j < a[i].length; j++) {\n        sum += a[i][j];\n      }\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of an array of doubles.\n   * @param a an array\n   * @return the sum of an array of doubles\n   */\n  public static double sum(double[] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      sum += a[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of all the elements of a 2d array of doubles.\n   * @param a a 2d array\n   * @return the sum of all the elements of a 2d array of doubles\n   */\n  public static double sum(double[][] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      for (int j = 0; j < a[i].length; j++) {\n        sum += a[i][j];\n      }\n    }\n    return sum;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// indexOf\n  ///\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using the equals method.\n   * @param <T> type of the elements of the array\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index whose element is equal to the specified element,\n   *    or -1 if no such element is found in the array\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static <T> int indexOf(T[] a, /*@Nullable*/ Object elt) {\n    if (elt == null) {\n      return indexOfEq(a, elt);\n    }\n    for (int i = 0; i < a.length; i++) {\n      if (elt.equals(a[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using the equals method.\n   * @param <T> the type of the elements\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the array\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static <T> int indexOf(T[] a, /*@Nullable*/ Object elt, int minindex, int indexlimit) {\n    if (elt == null) {\n      return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt.equals(a[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using the equals method.\n   *    Identical to List.indexOf, but included for completeness.\n   * @param a a list\n   * @param elt the element to search for\n   * @return the first index whose element is equal to the specified element,\n   *    or -1 if no such element is found in the list\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(List<? extends /*@PolyNull*/ Object> a, /*@Nullable*/ Object elt) {\n    return a.indexOf(elt);\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the list\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(\n      List<? extends /*@PolyNull*/ Object> a,\n      /*@Nullable*/ Object elt,\n      int minindex,\n      int indexlimit) {\n    if (elt == null) {\n      return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt.equals(a.get(i))) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, /*@Nullable*/ Object elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(\n      /*@PolyNull*/ Object[] a, /*@Nullable*/ Object elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<? extends /*@PolyNull*/ Object> a, /*@Nullable*/ Object elt) {\n    for (int i = 0; i < a.size(); i++) {\n      if (elt == a.get(i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(\n      List<? extends /*@PolyNull*/ Object> a,\n      /*@Nullable*/ Object elt,\n      int minindex,\n      int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a.get(i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(double[] a, double elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// indexOf, for finding subarrays\n  ///\n\n  // This is analogous to Common Lisp's \"search\" function.\n\n  // This implementation is very inefficient; I could use tricky Boyer-Moore\n  // search techniques if I liked, but it's not worth it to me yet.\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(/*@PolyAll*/ Object[] a, Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  // The signature on this method is unnecessarily strict because it\n  // requires that the component types be identical.  The signature should\n  // be indexOfEq(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n  // @PolyAll qualifier does not yet take an argument.\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given array elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first list,\n   *    or -1 if no such element is found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(List<?> a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given array elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first list,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<?> a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given list elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first array,\n   *    or -1 if no such element is found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(/*@PolyAll*/ Object[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given list elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given list elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first list,\n   *    or -1 if no such element is found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given list elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first list,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(double[] a, double[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// mismatch\n  ///\n\n  // This is analogous to Common Lisp's \"mismatch\" function.\n\n  // Put it off until later; for now, use the simpler subarray function,\n  // which is a specialization of mismatch,\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// subarray extraction\n  ///\n\n  // Note that the second argument is a length, not an end position.\n  // That's to avoid confusion over whether it would be the last included\n  // index or the first non-included index.\n\n  /**\n   * Return a subarray of the given array.\n   * @return a subarray of the given array\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   */\n  /*@SideEffectFree*/\n  public static /*@PolyAll*/ Object[] subarray(\n      /*@PolyAll*/ Object[] a, int startindex, int length) {\n    /*@PolyAll*/ Object[] result = new /*@PolyAll*/ Object[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a sublist of the given list.\n   * @param <T> type of the elements\n   * @param a the original list\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a sublist of the given list\n   */\n  /*@SideEffectFree*/\n  public static <T> List<T> subarray(List<T> a, int startindex, int length) {\n    return a.subList(startindex, startindex + length);\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static /*@PolyAll*/ String[] subarray(\n      /*@PolyAll*/ String[] a, int startindex, int length) {\n    /*@PolyAll*/ String[] result = new /*@PolyAll*/ String[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static byte[] subarray(byte[] a, int startindex, int length) {\n    byte[] result = new byte[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static boolean[] subarray(boolean[] a, int startindex, int length) {\n    boolean[] result = new boolean[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static char[] subarray(char[] a, int startindex, int length) {\n    char[] result = new char[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static double[] subarray(double[] a, int startindex, int length) {\n    double[] result = new double[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static float[] subarray(float[] a, int startindex, int length) {\n    float[] result = new float[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static int[] subarray(int[] a, int startindex, int length) {\n    int[] result = new int[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static long[] subarray(long[] a, int startindex, int length) {\n    long[] result = new long[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static short[] subarray(short[] a, int startindex, int length) {\n    short[] result = new short[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// subarray testing\n  ///\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(\n      /*@PolyAll*/ Object[] a, /*@PolyNull*/ Object[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub[i], a[a_offset + i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(\n      /*@PolyAll*/ Object[] a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(/*@PolyAll*/ Object[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub.get(i), a[a_offset + i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(/*@PolyAll*/ Object[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub.get(i) != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(List<?> a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub[i], a.get(a_offset + i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(List<?> a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a.get(a_offset + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub.get(i), a.get(a_offset + i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub.get(i) != a.get(a_offset + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(int[] a, int[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(long[] a, long[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(double[] a, double[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// concatenation\n  ///\n\n  // Concat used to return null if both arguments are null.  That is\n  // convenient for the implementer, but not so good for clients.\n\n  /**\n   * Call this method in order to suppress compiler warnings.\n   * @param <T> the base type of the result\n   * @param lst the list to convert to an array\n   * @return the result of lst.toArray, casted to a more precise type than Object[]\n   */\n  private static <T> T[] toTArray(List<T> lst) {\n    @SuppressWarnings(\"unchecked\")\n    T[] asArray = (T[]) lst.toArray();\n    return asArray;\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(T /*@Nullable*/ [] a, T /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b != null) {\n        return b;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(T /*@Nullable*/ [] a, /*@Nullable*/ List<T> b) {\n    if (a == null) {\n      if (b != null) {\n        return toTArray(b);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.length + b.size()];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        // System.arraycopy(b, 0, result, a.length, b.size());\n        for (int i = 0; i < b.size(); i++) {\n          result[i + a.length] = b.get(i);\n        }\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(/*@Nullable*/ List<T> a, T /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b != null) {\n        return b;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return toTArray(a);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.size() + b.length];\n\n        // System.arraycopy(a, 0, result, 0, a.size());\n        for (int i = 0; i < a.size(); i++) {\n          result[i] = a.get(i);\n        }\n        System.arraycopy(b, 0, result, a.size(), b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(/*@Nullable*/ List<T> a, /*@Nullable*/ List<T> b) {\n    if (a == null) {\n      if (b != null) {\n        return toTArray(b);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return toTArray(a);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.size() + b.size()];\n\n        // System.arraycopy(a, 0, result, 0, a.length);\n        for (int i = 0; i < a.size(); i++) {\n          result[i] = a.get(i);\n        }\n        // System.arraycopy(b, 0, result, a.length, b.length);\n        for (int i = 0; i < b.size(); i++) {\n          result[i + a.size()] = b.get(i);\n        }\n        return result;\n      }\n    }\n  }\n\n  // Note: PolyAll is not quite right.  Need to review.\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first array to concatenate\n   * @param b the second array to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static /*@PolyAll*/ String[] concat(\n      /*@PolyAll*/ String /*@Nullable*/ [] a, /*@PolyAll*/ String /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new String[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        /*@PolyAll*/ String[] result = new String[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static byte[] concat(byte /*@Nullable*/ [] a, byte /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new byte[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        byte[] result = new byte[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static boolean[] concat(boolean /*@Nullable*/ [] a, boolean /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new boolean[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        boolean[] result = new boolean[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static char[] concat(char /*@Nullable*/ [] a, char /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new char[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        char[] result = new char[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static double[] concat(double /*@Nullable*/ [] a, double /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new double[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        double[] result = new double[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static float[] concat(float /*@Nullable*/ [] a, float /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new float[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        float[] result = new float[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static int[] concat(int /*@Nullable*/ [] a, int /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new int[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        int[] result = new int[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static long[] concat(long /*@Nullable*/ [] a, long /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new long[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        long[] result = new long[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static short[] concat(short /*@Nullable*/ [] a, short /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new short[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        short[] result = new short[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Printing\n  ///\n\n  // This should be extended to all types, when I get around to it.  The\n  // methods are patterned after that of java.util.Vector (and use its\n  // output format).\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toString(/*@PolyAll*/ Object /*@Nullable*/ [] a) {\n    return toString(a, false);\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * Furthermore, each element is quoted like a Java String.\n   * @param a an array\n   * @return a string representation of the array, with the elements quoted\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toStringQuoted(/*@PolyAll*/ Object /*@Nullable*/ [] a) {\n    return toString(a, true);\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * Furthermore, if quoted is true, then each element is quoted like a Java String.\n   * @param a an array\n   * @param quoted whether to quote the array elements\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(/*@PolyAll*/ Object /*@Nullable*/ [] a, boolean quoted) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        if (quoted && a[i] instanceof String) {\n          String elt = (String) a[i];\n          sb.append('\\\"');\n          sb.append(UtilMDE.escapeNonJava(elt));\n          sb.append('\\\"');\n        } else {\n          sb.append(a[i]);\n        }\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @return a string representation of the collection\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toString(/*@Nullable*/ Collection<?> a) {\n    return toString(a, false);\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @return a string representation of the collection, with the elements quoted\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toStringQuoted(/*@Nullable*/ Collection<?> a) {\n    return toString(a, true);\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @param quoted whether to quote the collection elements that are Java strings\n   * @return a string representation of the list\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(/*@Nullable*/ Collection<?> a, boolean quoted) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.size() > 0) {\n      Iterator<?> itor = a.iterator();\n      sb.append(itor.next());\n      while (itor.hasNext()) {\n        sb.append(\", \");\n        Object elt = itor.next();\n        if (quoted && elt instanceof String) {\n          sb.append('\\\"');\n          sb.append(UtilMDE.escapeNonJava((String) elt));\n          sb.append('\\\"');\n        } else {\n          sb.append(elt);\n        }\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(int /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(long /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(double /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(float /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(boolean /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Casts obj down to the proper array type then calls the appropriate\n   * toString() method.  Only call this method if obj is a boolean, double,\n   * int, long, or Object array.\n   * @param obj an array\n   * @return a string representation of the array\n   * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n   */\n  @SuppressWarnings(\"purity\") // defensive coding: throw exception when argument is invalid\n  /*@SideEffectFree*/\n  public static String toString(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n      return toString((boolean[]) obj);\n    } else if (obj instanceof double[]) {\n      return toString((double[]) obj);\n    } else if (obj instanceof float[]) {\n      return toString((float[]) obj);\n    } else if (obj instanceof int[]) {\n      return toString((int[]) obj);\n    } else if (obj instanceof long[]) {\n      return toString((long[]) obj);\n    } else if (obj instanceof Object[]) {\n      return toString((Object[]) obj);\n    } else if (obj instanceof List<?>) {\n      return toString((List<?>) obj);\n    } else {\n      throw new IllegalArgumentException(\n          \"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n  }\n\n  /**\n   * Casts obj down to the proper array type then calls .length.\n   * Only call this method if obj is a boolean, double, int, long, or Object array.\n   * @param obj a list\n   * @return a string representation of the array\n   * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n   */\n  @SuppressWarnings(\"purity\") // defensive coding: throw exception when argument is invalid\n  /*@Pure*/\n  public static int length(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n      return ((boolean[]) obj).length;\n    } else if (obj instanceof double[]) {\n      return ((double[]) obj).length;\n    } else if (obj instanceof int[]) {\n      return ((int[]) obj).length;\n    } else if (obj instanceof long[]) {\n      return ((long[]) obj).length;\n    } else if (obj instanceof Object[]) {\n      return ((Object[]) obj).length;\n    } else if (obj instanceof List<?>) {\n      return ((List<?>) obj).size();\n    } else {\n      throw new IllegalArgumentException(\n          \"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Sortedness\n  ///\n\n  /**\n   * Returns whether the array is sorted.\n   * @param a an array\n   * @return true iff the array is sorted\n   */\n  /*@Pure*/\n  public static boolean sorted(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] < a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted.\n   * @param a an array\n   * @return true iff the array is sorted\n   */\n  /*@Pure*/\n  public static boolean sorted(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] < a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted in desending order.\n   * @param a an array\n   * @return true iff the array is sorted in desending order\n   */\n  /*@Pure*/\n  public static boolean sorted_descending(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] > a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted in desending order.\n   * @param a an array\n   * @return true iff the array is sorted in desending order\n   */\n  /*@Pure*/\n  public static boolean sorted_descending(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] > a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(boolean[] a) {\n    HashSet<Boolean> hs = new HashSet<Boolean>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Boolean n = Boolean.valueOf(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(byte[] a) {\n    HashSet<Byte> hs = new HashSet<Byte>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Byte n = new Byte(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(char[] a) {\n    HashSet<Character> hs = new HashSet<Character>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Character n = new Character(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(float[] a) {\n    HashSet<Float> hs = new HashSet<Float>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Float n = new Float(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(short[] a) {\n    HashSet<Short> hs = new HashSet<Short>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Short n = new Short(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(int[] a) {\n    HashSet<Integer> hs = new HashSet<Integer>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Integer n = new Integer(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space. Equality checking\n   * uses the .equals() method for java.lang.Double.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(double[] a) {\n    HashSet<Double> hs = new HashSet<Double>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to create the last element,\n      // but that would make the code much less readable.\n      Double n = new Double(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(long[] a) {\n    HashSet<Long> hs = new HashSet<Long>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to create the last element,\n      // but that would make the code much less readable.\n      Long n = new Long(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(String[] a) {\n    HashSet<String> hs = new HashSet<String>();\n    for (int i = 0; i < a.length; i++) {\n      if (hs.contains(a[i])) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a[i]);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(Object[] a) {\n    HashSet<Object> hs = new HashSet<Object>();\n    for (int i = 0; i < a.length; i++) {\n      if (hs.contains(a[i])) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a[i]);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param <T> the type of the elements\n   * @param a a list\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static <T> boolean noDuplicates(List<T> a) {\n    HashSet<T> hs = new HashSet<T>();\n    for (int i = 0; i < a.size(); i++) {\n      if (hs.contains(a.get(i))) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a.get(i));\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Arrays as partial functions of int->int\n  ///\n\n  /**\n   * Returns true if the array is a permutation of [0..a.length).\n   * @param a an array, representing a function\n   * @return true iff all elements of a are in [0..a.length) and a\n   * contains no duplicates.\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (array)\n  /*@Pure*/\n  public static boolean fn_is_permutation(int[] a) {\n    // In the common case we expect to succeed, so use as few loops as possible\n    boolean[] see = new boolean[a.length];\n    for (int i = 0; i < a.length; i++) {\n      int n = a[i];\n      if (n < 0 || n >= a.length || see[n]) {\n        return false;\n      }\n      see[n] = true;\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff the array does not contain -1.\n   * @param a an array, representing a function\n   * @return true iff no element of a maps to -1\n   */\n  /*@Pure*/\n  public static boolean fn_is_total(int[] a) {\n    return indexOf(a, -1) == -1; // not found\n  }\n\n  /**\n   * Return an array [0..lenth).\n   * @param length the length of the result\n   * @return fresh array that is the identity function of the given length\n   */\n  public static int[] fn_identity(int length) {\n    int[] result = new int[length];\n    for (int i = 0; i < length; i++) {\n      result[i] = i;\n    }\n    return result;\n  }\n\n  /**\n   * Requires that fn_is_permutation(a) holds.\n   * @param a the input permutation\n   * @return fresh array which is the inverse of the given permutation\n   * @see #fn_is_permutation(int[])\n   */\n  public static int[] fn_inverse_permutation(int[] a) {\n    return fn_inverse(a, a.length);\n  }\n\n  /**\n   * Return the inverse of the given function, which is represented as an array.\n   * @param a an array representing a function from [0..a.length) to [0..arange);\n   *  each element of a is between 0 and arange inclusive\n   * @param arange length of the argument's range and the result's domain\n   * @return function from [0..arange) to [0..a.length) that is the inverse of a\n   * @throws IllegalArgumentException if a value of a is outside of arange\n   * @exception UnsupportedOperationException when the function is not invertible\n   */\n  public static int[] fn_inverse(int[] a, int arange) {\n    int[] result = new int[arange];\n    Arrays.fill(result, -1);\n    for (int i = 0; i < a.length; i++) {\n      int ai = a[i];\n      if (ai < -1 || ai >= arange) {\n        throw new IllegalArgumentException(String.format(\"Bad range value: a[%d]=%d\", i, ai));\n      }\n      // ai is either -1 or a valid index\n      if (ai >= 0) {\n        if (result[ai] != -1) {\n          throw new UnsupportedOperationException(\n              String.format(\"Not invertible; a[%d]=%d and a[%d]=%d\", result[ai], ai, i, ai));\n        }\n        result[ai] = i;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the composition of the given two functions, all of which are\n   * represented as arrays.\n   * @param a function from [0..a.length) to [0..b.length)\n   * @param b function from [0..b.length) to range R\n   * @return function from [0..a.length) to range R that is the\n   * composition of a and b\n   */\n  public static int[] fn_compose(int[] a, int[] b) {\n    int[] result = new int[a.length];\n    for (int i = 0; i < a.length; i++) {\n      int inner = a[i];\n      if (inner == -1) {\n        result[i] = -1;\n      } else {\n        result[i] = b[inner];\n      }\n    }\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Set operations, such as subset, unions, and intersections\n  ///\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(long[] smaller, long[] bigger) {\n    Set<Long> setBigger = new HashSet<Long>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(new Long(bigger[i]));\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      Long elt = new Long(smaller[i]);\n      if (!setBigger.contains(elt)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(double[] smaller, double[] bigger) {\n    Set<Double> setBigger = new HashSet<Double>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(new Double(bigger[i]));\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      Double elt = new Double(smaller[i]);\n      if (!setBigger.contains(elt)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(String[] smaller, String[] bigger) {\n    Set<String> setBigger = new HashSet<String>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(bigger[i]);\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      if (!setBigger.contains(smaller[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Array comparators\n  ///\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class IntArrayComparatorLexical implements Comparator<int[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer,\n     * depending on whether the first argument is less than,\n     * equal to, or greater than the second argument\n     */\n    /*@Pure*/\n    public int compare(int[] a1, int[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class LongArrayComparatorLexical implements Comparator<long[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(long[] a1, long[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class DoubleArrayComparatorLexical\n      implements Comparator<double[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(double[] a1, double[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        int result = Double.compare(a1[i], a2[i]);\n        if (result != 0) {\n          return (result);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * Strings).\n   */\n  public static final class StringArrayComparatorLexical\n      implements Comparator<String[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) String[], @PolyAll(2) String[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ String[] a1, /*@PolyAll*/ String[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        int tmp = 0;\n        if ((a1[i] == null) && (a2[i] == null)) {\n          tmp = 0;\n        } else if (a1[i] == null) {\n          tmp = -1;\n        } else if (a2[i] == null) {\n          tmp = 1;\n        } else {\n          tmp = a1[i].compareTo(a2[i]);\n        }\n        if (tmp != 0) {\n          return (tmp);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ComparableArrayComparatorLexical<T extends Comparable<T>>\n      implements Comparator<T[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) T[], @PolyAll(2) T[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ T[] a1, /*@PolyAll*/ T[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        T elt1 = a1[i];\n        T elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        int tmp = elt1.compareTo(elt2);\n        if (tmp != 0) {\n          return tmp;\n        }\n        // Check the assumption that the two elements are equal.\n        assert elt1.equals(elt2);\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ObjectArrayComparatorLexical\n      implements Comparator<Object[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ Object[] a1, /*@PolyAll*/ Object[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        Object elt1 = a1[i];\n        Object elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        int tmp = elt1.hashCode() - elt2.hashCode();\n        if (tmp != 0) {\n          return tmp;\n        }\n        // I'm counting on the fact that hashCode returns a different\n        // number for each Object in the system.  This checks that assumption.\n        assert elt1.equals(elt2);\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class IntArrayComparatorLengthFirst\n      implements Comparator<int[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(int[] a1, int[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class LongArrayComparatorLengthFirst\n      implements Comparator<long[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(long[] a1, long[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int lendiff = a1.length - a2.length;\n      if (lendiff != 0) {\n        return lendiff;\n      }\n      long tmp;\n      for (int i = 0; i < a1.length; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ComparableArrayComparatorLengthFirst<T extends Comparable<T>>\n      implements Comparator<T[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) T[], @PolyAll(2) T[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ T[] a1, /*@PolyAll*/ T[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        T elt1 = a1[i];\n        T elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        tmp = elt1.compareTo(elt2);\n        if (tmp != 0) {\n          return tmp;\n        }\n        // Check the assumption that the two elements are equal.\n        assert elt1.equals(elt2);\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ObjectArrayComparatorLengthFirst\n      implements Comparator<Object[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ Object[] a1, /*@PolyAll*/ Object[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        Object elt1 = a1[i];\n        Object elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        tmp = elt1.hashCode() - elt2.hashCode();\n        if (tmp != 0) {\n          return tmp;\n        }\n        // I'm counting on the fact that hashCode returns a different\n        // number for each Object in the system.  This checks that assumption.\n        assert elt1.equals(elt2);\n      }\n      return 0;\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// nullness\n  ///\n\n  /**\n   * Return true if a contains null.\n   * @param a an array\n   * @return true iff some element of a is null (false if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean any_null(/*@PolyAll*/ Object[] a) {\n    if (a.length == 0) {\n      return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/ Object) null) >= 0;\n  }\n\n  /**\n   * Return true if all elements of a are null.\n   * @param a an array\n   * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean all_null(/*@PolyAll*/ Object[] a) {\n    for (int i = 0; i < a.length; i++) {\n      if (!(a[i] == null)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Return true if a contains null.\n   * @param a an array\n   * @return true iff some element of a is null (false if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean any_null(List<?> a) {\n    if (a.size() == 0) {\n      return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/ Object) null) >= 0;\n  }\n\n  /**\n   * Return true if all elements of a are null.\n   * @param a an array\n   * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean all_null(List<?> a) {\n    for (int i = 0; i < a.size(); i++) {\n      if (!(a.get(i) == null)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// javadoc hacks\n  ///\n\n  // Without this, the Javadoc mentions of \"java.util.Vector\", are not links\n  // in the generated HTML.\n  // \"private static Vector v;\" doesn't work, nor does\n  // \"static { new java.util.Vector(); }\", nor does \"private Vector v\".\n  // Yuck!\n  public Vector<?> javadocLossage;\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ [ "0", "int" ], [ "0", "int" ], [ "0", "int" ], [ "0", "int" ], [ "0", "int" ], [ "\"s range and the result\"", "String" ] ],
  "tokensMethodArguments" : [ [ "a", "", "int[]" ], [ "arange", "", "int" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "toString", "java.lang", "Object", "public String toString()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "equals", "", "int[]", "public boolean equals(Object);" ], [ "toString", "", "int[]", "public String toString()" ], [ "hashCode", "", "int[]", "public native int hashCode()" ], [ "getClass", "", "int[]", "public final native Class getClass();" ], [ "clone", "", "int[]", "public T[] clone();" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "javadocLossage", "plume", "ArraysMDE", "public Vector<?> javadocLossage;" ], [ "length", "", "int[]", "public final int length;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10953,
  "oracle" : ";",
  "oracleType" : "PRE",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "StrTok",
  "javadocTag" : "@param ch the comment character",
  "methodJavadoc" : "    /**\n   * Specifies the single line comment character.\n   * @param ch the comment character\n   * @see StreamTokenizer#commentChar(int)\n   */",
  "methodSourceCode" : "public void commentChar(int ch){\n    stok.commentChar(ch);\n}",
  "classJavadoc" : "/**\n * Provides a somewhat simpler interface for tokenizing strings than\n * does StreamTokenizer.  All tokenizing is done by StreamTokenizer. <p>\n *\n * The major difference from StreamTokenizer is that all tokens are\n * returned as strings.  EOF returns a null, EOL returns an empty string.\n * A delimiter is returned as a one-character string.  Words and numbers\n * are returned as strings.  Quoted strings are also returned as strings\n * including their quote characters (so they can easily be differentiated\n * from words and numbers).\n *\n * Other differences are: <ul>\n *  <li> Automatic setup for tokenizing strings.\n *  <li> Underscores are included in identifiers (words).\n *  <li> I/O errors (which should be impossible when tokenizing strings) are\n *       converted to RuntimeExceptions so that every call doesn't have to\n *       be included in a try block.\n *  <li> Convenience functions isWord(), isQString(), and need().\n *  <li> Returned string tokens are interned for easier comparisons.\n * </ul>\n */",
  "classSourceCode" : "package plume;\n\n/*>>>\nimport org.checkerframework.checker.initialization.qual.*;\nimport org.checkerframework.checker.interning.qual.*;\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.dataflow.qual.*;\n*/\n\nimport java.io.Reader;\nimport java.io.StreamTokenizer;\nimport java.io.StringReader;\n\n/**\n * Provides a somewhat simpler interface for tokenizing strings than\n * does StreamTokenizer.  All tokenizing is done by StreamTokenizer. <p>\n *\n * The major difference from StreamTokenizer is that all tokens are\n * returned as strings.  EOF returns a null, EOL returns an empty string.\n * A delimiter is returned as a one-character string.  Words and numbers\n * are returned as strings.  Quoted strings are also returned as strings\n * including their quote characters (so they can easily be differentiated\n * from words and numbers).\n *\n * Other differences are: <ul>\n *  <li> Automatic setup for tokenizing strings.\n *  <li> Underscores are included in identifiers (words).\n *  <li> I/O errors (which should be impossible when tokenizing strings) are\n *       converted to RuntimeExceptions so that every call doesn't have to\n *       be included in a try block.\n *  <li> Convenience functions isWord(), isQString(), and need().\n *  <li> Returned string tokens are interned for easier comparisons.\n * </ul>\n */\npublic class StrTok {\n\n  /** Where to read tokens from. */\n  Reader reader;\n  /** The StreamTokenizer to which all work is delegated. */\n  public StreamTokenizer stok;\n  /** How to handle errors. */\n  ErrorHandler errorHandler;\n\n  /**\n   * Creates a tokenizer for the specified string.\n   * @param s string to tokenize\n   */\n  public StrTok(String s) {\n    this(s, new ErrorHandler());\n  }\n\n  /**\n   * Creates a tokenizer for the specified string with the specified\n   * error handler.\n   * @param s string to tokenize\n   * @param e error handler\n   */\n  public StrTok(String s, ErrorHandler e) {\n    reader = new StringReader(s);\n    stok = new StreamTokenizer(reader);\n    stok.wordChars('_', '_');\n    set_error_handler(e);\n  }\n\n  /**\n   * Default class for error handling.  Throws a RuntimeException when an\n   * error occurs.\n   *\n   * @see #set_error_handler(ErrorHandler)\n   */\n  public static class ErrorHandler {\n\n    /**\n     * Called when an unexpected token is found (see {@link #need(String)}).\n     * @param s unexpected token that has been found\n     */\n    public void tok_error(String s) {\n      throw new RuntimeException(\"StrTok error: \" + s);\n    }\n  }\n\n  /**\n   * Returns the next token as a string.  EOF returns a null, EOL\n   * returns an empty string.  Delimiters are returned as one character\n   * strings.  Quoted strings and words are returned as strings.\n   * @return the next token\n   */\n  public /*@Nullable*/ /*@Interned*/ String nextToken() {\n\n    // Get the next token.  Turn IO exceptions into runtime exceptions\n    // so that callers don't have to catch them.\n    try {\n      stok.nextToken();\n    } catch (Exception e) {\n      throw new RuntimeException(\"StreamTokenizer exception: \", e);\n    }\n\n    return (token());\n  }\n\n  /** Causes the next call to nextToken() to return the current token. */\n  public void pushBack() {\n    stok.pushBack();\n  }\n\n  /**\n   * Return the current token.\n   * @return the current token\n   * @see #nextToken()\n   */\n  public /*@Nullable*/ /*@Interned*/ String token() {\n\n    int ttype = stok.ttype;\n\n    // Null indicates eof\n    if (ttype == StreamTokenizer.TT_EOF) {\n      return (null);\n    }\n\n    // Return end of line as an empty string\n    if (ttype == StreamTokenizer.TT_EOL) {\n      return (\"\");\n    }\n\n    // Return identifiers (words) and quoted strings.  Quoted strings\n    // include their quote characters (for recognition)\n    if (stok.sval != null) {\n      if (ttype > 0) {\n        String s = ((char) ttype) + stok.sval + ((char) ttype);\n        return (s.intern());\n      }\n      return (stok.sval.intern());\n    }\n\n    // Other tokens are delimiters\n    if (ttype > 0) {\n      String s = \"\" + (char) ttype;\n      return (s.intern());\n    }\n\n    throw new RuntimeException(\"Unexpected return \" + ttype + \" from StreamTokenizer\");\n  }\n\n  /**\n   * Specifies the single line comment character.\n   * @param ch the comment character\n   * @see StreamTokenizer#commentChar(int)\n   */\n  public void commentChar(int ch) {\n    stok.commentChar(ch);\n  }\n\n  /**\n   * Specifies that matching pairs of this character delimit string constants.\n   * @param ch the quoting character\n   * @see StreamTokenizer#quoteChar(int)\n   */\n  public void quoteChar(int ch) {\n    stok.quoteChar(ch);\n  }\n\n  /**\n   * Return the type of the current token.\n   * @return the type of the current token\n   * @see StreamTokenizer#ttype\n   */\n  public int ttype() {\n    return stok.ttype;\n  }\n\n  /** Returns true if the current token is a word (identifier).\n   * @return true iff the current token is a word (identifier)\n   */\n  /*@Pure*/\n  public boolean isWord() {\n    return (stok.ttype == StreamTokenizer.TT_WORD);\n  }\n\n  /** Returns true if the current token is a quoted string.\n   * @return true iff the current token is a quoted string\n   */\n  /*@Pure*/\n  public boolean isQString() {\n    return ((stok.sval != null) && (stok.ttype > 0));\n  }\n\n  /**\n   * Sets the error handler.  The default error handler will throw a\n   * runtime exception on errors.\n   * @param errorHandler the new error handler\n   * @see ErrorHandler\n   */\n  /*@EnsuresNonNull(\"this.errorHandler\")*/\n  public void set_error_handler(\n      /*>>>@UnknownInitialization @Raw StrTok this,*/ ErrorHandler errorHandler) {\n    this.errorHandler = errorHandler;\n  }\n\n  /**\n   * Reads the next token and checks that it matches tok.  If it does\n   * not match, calls the current error handling routine (see\n   * {@link #set_error_handler(StrTok.ErrorHandler) set_error_handler()}).\n   * If it does match, just returns.\n   * @param tok string to check next token against\n   */\n  public void need(String tok) {\n\n    String t = nextToken();\n    if (tok.equals(t)) {\n      return;\n    }\n\n    errorHandler.tok_error(String.format(\"Token %s found where %s expected\", t, tok));\n  }\n\n  /**\n   * Reads the next token and checks to make sure that it is a word (id).\n   * If it is not a word, calls the error handling routine.  If it is,\n   * returns the string of the word.\n   * @return next token, if if it a word; otherwise calls the error handling routine\n   */\n  public String need_word() {\n    String t = nextToken();\n    if (!isWord()) {\n      errorHandler.tok_error(String.format(\"'%s' found where identifier expected\", t));\n    }\n    assert t != null : \"@AssumeAssertion(nullness): dependent: because of isWord check\";\n    return t;\n  }\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "ch", "", "int" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "token", "plume", "StrTok", "public String token()" ], [ "need_word", "plume", "StrTok", "public String need_word()" ], [ "nextToken", "plume", "StrTok", "public String nextToken()" ], [ "ttype", "plume", "StrTok", "public int ttype()" ], [ "isQString", "plume", "StrTok", "public boolean isQString()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "isWord", "plume", "StrTok", "public boolean isWord()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "reader", "plume", "StrTok", "Reader reader;" ], [ "stok", "plume", "StrTok", "public StreamTokenizer stok;" ], [ "errorHandler", "plume", "StrTok", "ErrorHandler errorHandler;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10961,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "TestPlume",
  "javadocTag" : "@throws ArgException if there is an illegal argument",
  "methodJavadoc" : "    /**\n   * Test command line option parsing (Options).\n   * @throws ArgException if there is an illegal argument\n   */",
  "methodSourceCode" : "public void testOptions() throws ArgException{\n    TestOptions t = new TestOptions();\n    Options options = new Options(\"test\", t);\n    options.parse(new String[] { \"--lp=foo\", \"--lp\", \"bar\", \"-i\", \"24\", \"-d=37.8\", \"-b\", \"-b=false\", \"--ld\", \"34.6\", \"--ld\", \"17.8\" });\n    assert t.lp.get(0).toString().equals(\"foo\");\n    assert t.lp.get(1).toString().equals(\"bar\");\n    assert t.integer_reference != null && t.integer_reference.intValue() == 24;\n    assert t.temperature == 37.8;\n    assert t.bool == false;\n    assert t.ld.get(0).doubleValue() == 34.6;\n    assert t.ld.get(1).doubleValue() == 17.8;\n    // Test non-options\n    t.bool = false;\n    String[] args = options.parse(new String[] { \"one\", \"two\", \"three\", \"-b\" });\n    assert args[0].equals(\"one\") : args[0];\n    assert args[1].equals(\"two\") : args[1];\n    assert args[2].equals(\"three\") : args[2];\n    assert t.bool;\n    // Test --\n    t.bool = false;\n    args = options.parse(new String[] { \"--\", \"one\", \"two\", \"-b\" });\n    assert args[0].equals(\"one\") : args[0];\n    assert args[1].equals(\"two\") : args[1];\n    assert args[2].equals(\"-b\") : args[2];\n    assert !t.bool;\n    // Test split_lists\n    t.ld.clear();\n    Options.split_lists = true;\n    args = options.parse(new String[] { \"--ld\", \"42.1 9.3 10.5\", \"--ld\", \"2.7\" });\n    assert args.length == 0;\n    assert t.ld.size() == 4;\n    assert t.ld.get(0).doubleValue() == 42.1;\n    assert t.ld.get(1).doubleValue() == 9.3;\n    assert t.ld.get(2).doubleValue() == 10.5;\n    assert t.ld.get(3).doubleValue() == 2.7;\n    // Test list with no default\n    args = options.parse(new String[] { \"--ls\", \"hello\", \"--ls\", \"world\" });\n    assert args.length == 0;\n    assert t.ls != null : \"@AssumeAssertion(nullness)\";\n    assert t.ls.size() == 2;\n    assert t.ls.get(0).equals(\"hello\");\n    assert t.ls.get(1).equals(\"world\");\n}",
  "classJavadoc" : "/** Test code for the plume package. */",
  "classSourceCode" : "package plume;\n\nimport static plume.Options.ArgException;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.CharArrayWriter;\nimport java.io.File;\nimport java.io.IOException;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Calendar;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Random;\nimport java.util.Vector;\nimport java.util.regex.Pattern;\nimport org.junit.Test;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.checker.signature.qual.*;\n*/\n\n// run like this:\n//   java plume.TestPlume\n\n// Files to test:\n// ArraysMDE.java\n// ClassFileVersion.java\n// CountingPrintWriter.java\n// Digest.java\n// FileIOException.java\n// FuzzyFloat.java\n// GraphMDE.java\n// Hasher.java\n// Intern.java\n// ICalAvailable.java\n// LimitedSizeIntSet.java\n// MathMDE.java\n// Options.java\n// OrderedPairIterator.java\n// StringBuilderDelimited.java\n// UtilMDE.java\n// WeakHasherMap.java\n\n/** Test code for the plume package. */\n@SuppressWarnings({\"interning\"}) // interning is due to apparent bugs\npublic final class TestPlume {\n\n  // If true, do 100 instead of 100000 iterations when testing randomElements.\n  // This saves only a little time.  However, it is significant when running\n  // under instrumentation such as that of Chicory.\n  static boolean short_run = false;\n\n  //   public static void main(String[] args) {\n  //     testUtilMDE();\n  //     testArraysMDE();\n  //     testHasher();\n  //     testIntern();\n  //     testMathMDE();\n  //     testOrderedPairIterator();\n  //     testPlume();\n  //     testWeakHasherMap();\n  //     System.out.println(\"All plume tests succeeded.\");\n  //   }\n\n  public static void assert_arrays_equals(int /*@Nullable*/ [] a1, int /*@Nullable*/ [] a2) {\n    boolean result = Arrays.equals(a1, a2);\n    if (!result) {\n      System.out.println(\n          \"Arrays differ: \" + ArraysMDE.toString(a1) + \", \" + ArraysMDE.toString(a2));\n    }\n    assert result;\n    //      assert(Arrays.equals(a1, a2),\n    //         \"Arrays differ: \" + ArraysMDE.toString(a1) + \", \" + ArraysMDE.toString(a2));\n  }\n\n  public static void assert_arrays_equals(double[] a1, double[] a2) {\n    boolean result = Arrays.equals(a1, a2);\n    if (!result) {\n      System.out.println(\n          \"Arrays differ: \" + ArraysMDE.toString(a1) + \", \" + ArraysMDE.toString(a2));\n    }\n    assert result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Utility functions\n  ///\n\n  public static Iterator<Integer> int_array_iterator(int[] nums) {\n    List<Integer> asList = new ArrayList<Integer>(nums.length);\n    for (int i = 0; i < nums.length; i++) {\n      asList.add(nums[i]);\n    }\n    return asList.iterator();\n  }\n\n  public static int[] int_iterator_array(Iterator<Integer> itor) {\n    Vector<Integer> v = new Vector<Integer>();\n    while (itor.hasNext()) {\n      v.add(itor.next());\n    }\n    int[] a = new int[v.size()];\n    for (int i = 0; i < a.length; i++) {\n      a[i] = v.elementAt(i).intValue();\n    }\n    return a;\n  }\n\n  public static <T> Vector<T> toVector(Iterator<T> itor) {\n    Vector<T> v = new Vector<T>();\n    while (itor.hasNext()) {\n      v.add(itor.next());\n    }\n    return v;\n  }\n\n  public static <T> Vector<T> toVector(Enumeration<T> e) {\n    Vector<T> v = new Vector<T>();\n    while (e.hasMoreElements()) {\n      v.add(e.nextElement());\n    }\n    return v;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Now the actual testing\n  ///\n\n  @Test\n  public void testArraysMDE() {\n\n    // public static int min(int[] a)\n    assert ArraysMDE.min(new int[] {1, 2, 3}) == 1;\n    assert ArraysMDE.min(new int[] {2, 33, 1}) == 1;\n    assert ArraysMDE.min(new int[] {3, -2, 1}) == -2;\n    assert ArraysMDE.min(new int[] {3}) == 3;\n\n    // public static int max(int[] a)\n    assert ArraysMDE.max(new int[] {1, 2, 3}) == 3;\n    assert ArraysMDE.max(new int[] {2, 33, 1}) == 33;\n    assert ArraysMDE.max(new int[] {3, -2, 1}) == 3;\n    assert ArraysMDE.max(new int[] {3}) == 3;\n\n    // public static int[] min_max(int[] a)\n    assert_arrays_equals(ArraysMDE.min_max(new int[] {1, 2, 3}), new int[] {1, 3});\n    assert_arrays_equals(ArraysMDE.min_max(new int[] {2, 33, 1}), new int[] {1, 33});\n    assert_arrays_equals(ArraysMDE.min_max(new int[] {3, -2, 1}), new int[] {-2, 3});\n    assert_arrays_equals(ArraysMDE.min_max(new int[] {3}), new int[] {3, 3});\n    try {\n      ArraysMDE.min_max(new int[] {});\n      throw new Error(\"Didn't throw ArrayIndexOutOfBoundsException\");\n    } catch (ArrayIndexOutOfBoundsException e) {\n    }\n    try {\n      ArraysMDE.min_max(new long[] {});\n      throw new Error(\"Didn't throw ArrayIndexOutOfBoundsException\");\n    } catch (ArrayIndexOutOfBoundsException e) {\n    }\n\n    // public static int sum(int[] a)\n    assert 0 == ArraysMDE.sum(new int[0]);\n    assert 10 == ArraysMDE.sum(new int[] {10});\n    assert 10 == ArraysMDE.sum(new int[] {1, 2, 3, 4});\n\n    // public static int sum(int[][] a)\n    assert 0 == ArraysMDE.sum(new int[0][0]);\n    assert 78 == ArraysMDE.sum(new int[][] {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}});\n    assert 68 == ArraysMDE.sum(new int[][] {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 11, 12}});\n\n    // public static double sum(double[] a)\n    assert 0 == ArraysMDE.sum(new double[0]);\n    assert 3.14 == ArraysMDE.sum(new double[] {3.14});\n    assert 8.624 == ArraysMDE.sum(new double[] {3.14, 2.718, -1.234, 4});\n\n    // public static double sum(double[][] a)\n    assert 0 == ArraysMDE.sum(new double[0][0]);\n    assert 79.5\n        == ArraysMDE.sum(new double[][] {{1.1, 2.2, 3.3, 4.4}, {5.5, 6, 7, 8}, {9, 10, 11, 12}});\n\n    // public static int element_range(int[] a)\n    assert ArraysMDE.element_range(new int[] {1, 2, 3}) == 2;\n    assert ArraysMDE.element_range(new int[] {2, 33, 1}) == 32;\n    assert ArraysMDE.element_range(new int[] {3, -2, 1}) == 5;\n    assert ArraysMDE.element_range(new int[] {3}) == 0;\n\n    // public static int indexOf(Object[] a, Object elt)\n    // public static int indexOfEq(Object[] a, Object elt)\n    {\n      Integer[] a = new Integer[10];\n      for (int i = 0; i < a.length; i++) {\n        a[i] = new Integer(i);\n      }\n      assert ArraysMDE.indexOf(a, new Integer(-1)) == -1;\n      assert ArraysMDE.indexOf(a, new Integer(0)) == 0;\n      assert ArraysMDE.indexOf(a, new Integer(7)) == 7;\n      assert ArraysMDE.indexOf(a, new Integer(9)) == 9;\n      assert ArraysMDE.indexOf(a, new Integer(10)) == -1;\n      assert ArraysMDE.indexOf(a, new Integer(20)) == -1;\n      assert ArraysMDE.indexOf(a, (Object) null) == -1;\n      assert ArraysMDE.indexOf(a, (Object) null, 1, 5) == -1;\n\n      assert ArraysMDE.indexOfEq(a, new Integer(-1)) == -1;\n      assert ArraysMDE.indexOfEq(a, new Integer(0)) == -1;\n      assert ArraysMDE.indexOfEq(a, new Integer(7)) == -1;\n      assert ArraysMDE.indexOfEq(a, new Integer(9)) == -1;\n      assert ArraysMDE.indexOfEq(a, new Integer(10)) == -1;\n      assert ArraysMDE.indexOfEq(a, new Integer(20)) == -1;\n      assert ArraysMDE.indexOfEq(a, (Object) null) == -1;\n      assert ArraysMDE.indexOfEq(a, (Object) null, 1, 5) == -1;\n      assert ArraysMDE.indexOfEq(a, a[0]) == 0;\n      assert ArraysMDE.indexOfEq(a, a[7]) == 7;\n      assert ArraysMDE.indexOfEq(a, a[9]) == 9;\n    }\n\n    // public static int indexOf(List<?> a, Object elt)\n    // public static int indexOf(List<?> a, Object elt, int minindex, int indexlimit)\n    // public static int indexOfEq(List<?> a, Object elt, int minindex, int indexlimit)\n    // public static int indexOfEq(List<?> a, Object elt)\n    {\n      assert ArraysMDE.indexOf((List<?>) new ArrayList<Object>(), (Object) null) == -1;\n      assert ArraysMDE.indexOf((List<?>) new ArrayList<Object>(), (Object) null, 0, -1) == -1;\n      assert ArraysMDE.indexOfEq((List<?>) new ArrayList<Object>(), (Object) null) == -1;\n      assert ArraysMDE.indexOfEq((List<?>) new ArrayList<Object>(), (Object) null, 0, -1) == -1;\n    }\n\n    // public static int indexOf(int[] a, int elt)\n    {\n      int[] a = new int[10];\n      for (int i = 0; i < a.length; i++) {\n        a[i] = i;\n      }\n      assert ArraysMDE.indexOf(a, -1) == -1;\n      assert ArraysMDE.indexOf(a, 0) == 0;\n      assert ArraysMDE.indexOf(a, 7) == 7;\n      assert ArraysMDE.indexOf(a, 9) == 9;\n      assert ArraysMDE.indexOf(a, 10) == -1;\n      assert ArraysMDE.indexOf(a, 20) == -1;\n    }\n\n    // public static int indexOf(boolean[] a, boolean elt)\n    {\n      boolean[] a = new boolean[10];\n      for (int i = 0; i < a.length; i++) {\n        a[i] = false;\n      }\n      assert ArraysMDE.indexOf(a, true) == -1;\n      assert ArraysMDE.indexOf(a, false) == 0;\n      a[9] = true;\n      assert ArraysMDE.indexOf(a, true) == 9;\n      assert ArraysMDE.indexOf(a, false) == 0;\n      a[7] = true;\n      assert ArraysMDE.indexOf(a, true) == 7;\n      assert ArraysMDE.indexOf(a, false) == 0;\n      a[0] = true;\n      assert ArraysMDE.indexOf(a, true) == 0;\n      assert ArraysMDE.indexOf(a, false) == 1;\n      for (int i = 0; i < a.length; i++) {\n        a[i] = true;\n      }\n      assert ArraysMDE.indexOf(a, true) == 0;\n      assert ArraysMDE.indexOf(a, false) == -1;\n    }\n\n    // public static int indexOf(Object[] a, Object[] sub)\n    // public static int indexOfEq(Object[] a, Object[] sub)\n    {\n      Integer[] a = new Integer[10];\n      for (int i = 0; i < a.length; i++) {\n        a[i] = new Integer(i);\n      }\n      Integer[] b = new Integer[] {};\n      Integer[] c = new Integer[] {a[0], a[1], a[2]};\n      Integer[] d = new Integer[] {a[1], a[2]};\n      Integer[] e = new Integer[] {a[2], a[3], a[4], a[5]};\n      Integer[] f = new Integer[] {a[7], a[8], a[9]};\n      Integer[] g = new Integer[] {a[7], new Integer(8), a[9]};\n      Integer[] h = new Integer[] {a[7], a[8], a[9], new Integer(10)};\n      @SuppressWarnings(\"nullness\") // accommodates poor annotation on indexOf(Object[], Object[])\n      Integer[] i = new Integer[] {a[7], a[8], null, a[9], new Integer(10)};\n      @SuppressWarnings(\"nullness\") // accommodates poor annotation on indexOf(Object[], Object[])\n      Integer[] j = new Integer[] {a[8], null, a[9]};\n      Integer[] c2 = new Integer[] {new Integer(0), new Integer(1), new Integer(2)};\n      Integer[] d2 = new Integer[] {new Integer(1), new Integer(2)};\n      Integer[] e2 = new Integer[] {new Integer(2), new Integer(3), new Integer(4), new Integer(5)};\n      Integer[] f2 = new Integer[] {new Integer(7), new Integer(8), new Integer(9)};\n\n      assert ArraysMDE.indexOf(a, b) == 0;\n      assert ArraysMDE.indexOfEq(a, b) == 0;\n      assert ArraysMDE.indexOf(a, c) == 0;\n      assert ArraysMDE.indexOfEq(a, c) == 0;\n      assert ArraysMDE.indexOf(a, c2) == 0;\n      assert ArraysMDE.indexOfEq(a, c2) == -1;\n      assert ArraysMDE.indexOf(a, d) == 1;\n      assert ArraysMDE.indexOfEq(a, d) == 1;\n      assert ArraysMDE.indexOf(a, d2) == 1;\n      assert ArraysMDE.indexOfEq(a, d2) == -1;\n      assert ArraysMDE.indexOf(a, e) == 2;\n      assert ArraysMDE.indexOfEq(a, e) == 2;\n      assert ArraysMDE.indexOf(a, e2) == 2;\n      assert ArraysMDE.indexOfEq(a, e2) == -1;\n      assert ArraysMDE.indexOf(a, f) == 7;\n      assert ArraysMDE.indexOfEq(a, f) == 7;\n      assert ArraysMDE.indexOf(a, f2) == 7;\n      assert ArraysMDE.indexOfEq(a, f2) == -1;\n      assert ArraysMDE.indexOf(a, g) == 7;\n      assert ArraysMDE.indexOfEq(a, g) == -1;\n      assert ArraysMDE.indexOf(a, h) == -1;\n      assert ArraysMDE.indexOfEq(a, h) == -1;\n      assert ArraysMDE.indexOf(i, j) == 1;\n      assert ArraysMDE.indexOfEq(i, j) == 1;\n      assert ArraysMDE.indexOf(a, i) == -1;\n      assert ArraysMDE.indexOfEq(a, i) == -1;\n    }\n\n    // public static int indexOf(int[] a, int[] sub)\n    {\n      int[] a = new int[10];\n      for (int i = 0; i < a.length; i++) {\n        a[i] = i;\n      }\n      int[] b = new int[] {};\n      int[] c = new int[] {a[0], a[1], a[2]};\n      int[] d = new int[] {a[1], a[2]};\n      int[] e = new int[] {a[2], a[3], a[4], a[5]};\n      int[] f = new int[] {a[7], a[8], a[9]};\n      int[] g = new int[] {a[7], 22, a[9]};\n      int[] h = new int[] {a[7], a[8], a[9], 10};\n\n      assert ArraysMDE.indexOf(a, b) == 0;\n      assert ArraysMDE.indexOf(a, c) == 0;\n      assert ArraysMDE.indexOf(a, d) == 1;\n      assert ArraysMDE.indexOf(a, e) == 2;\n      assert ArraysMDE.indexOf(a, f) == 7;\n      assert ArraysMDE.indexOf(a, g) == -1;\n      assert ArraysMDE.indexOf(a, h) == -1;\n\n      // Tests pulled from actual StackAr data\n      int[] origTheArray =\n          new int[] {\n            1267757, 1267757, 1267757, 1267757, 1267757, 1267757, 1267757, 1267757, 1267757,\n            1267757, 1267757, 0, 0, 0, 0, 0, 0, 0, 0, 0\n          };\n\n      int[] postTheArray = new int[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n      assert ArraysMDE.indexOf(postTheArray, origTheArray) == -1;\n      assert ArraysMDE.indexOf(origTheArray, postTheArray) == -1;\n    }\n\n    // public static int indexOf(boolean[] a, boolean[] sub)\n    // [I'm punting on this for now; deal with it later...]\n\n    // public static Object[] subarray(Object[] a, int startindex, int length)\n    // public static byte[] subarray(byte[] a, int startindex, int length)\n    // public static boolean[] subarray(boolean[] a, int startindex, int length)\n    // public static char[] subarray(char[] a, int startindex, int length)\n    // public static double[] subarray(double[] a, int startindex, int length)\n    // public static float[] subarray(float[] a, int startindex, int length)\n    // public static int[] subarray(int[] a, int startindex, int length)\n    // public static long[] subarray(long[] a, int startindex, int length)\n    // public static short[] subarray(short[] a, int startindex, int length)\n\n    // public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)\n    // public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)\n    // public static boolean isSubarray(int[] a, int[] sub, int a_offset)\n    // public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)\n    // (The subarray tests are missing; I hope that the indexOf(..., array)\n    // operations above test them sufficiently.)\n\n    // public static String toString(Object /*@Nullable*/ [] a)\n    // public static String toStringQuoted(Object /*@Nullable*/ [] a)\n    // public static String toString(Object /*@Nullable*/ [] a, boolean quoted)\n    // public static String toString(List<?> a)\n    // public static String toStringQuoted(List<?> a)\n    // public static String toString(List<?> a, boolean quoted)\n    {\n      assert ArraysMDE.toString((Object[]) null).equals(\"null\");\n      assert ArraysMDE.toStringQuoted((Object[]) null).equals(\"null\");\n      assert ArraysMDE.toString((List<?>) null).equals(\"null\");\n      assert ArraysMDE.toStringQuoted((List<?>) null).equals(\"null\");\n      assert ArraysMDE.toStringQuoted(Arrays.asList(new Object[] {3.14, null, \"hello\"}))\n          .equals(\"[3.14, null, \\\"hello\\\"]\");\n    }\n\n    // static String toString(int[] a)\n    assert ArraysMDE.toString(new int[] {}).equals(\"[]\");\n    assert ArraysMDE.toString(new int[] {0}).equals(\"[0]\");\n    assert ArraysMDE.toString(new int[] {0, 1, 2}).equals(\"[0, 1, 2]\");\n\n    // public static boolean sorted(int[] a)\n    assert ArraysMDE.sorted(new int[] {0, 1, 2});\n    assert ArraysMDE.sorted(new int[] {0, 1, 2, 2, 3, 3});\n    assert ArraysMDE.sorted(new int[] {});\n    assert ArraysMDE.sorted(new int[] {0});\n    assert ArraysMDE.sorted(new int[] {0, 1});\n    assert !ArraysMDE.sorted(new int[] {1, 0});\n    assert !ArraysMDE.sorted(new int[] {0, 1, 2, 1, 2, 3});\n\n    // public static int noDuplicates(int[] a)\n    assert ArraysMDE.noDuplicates(new int[] {1, 2, 3, 5, 4, 0}) == true;\n    assert ArraysMDE.noDuplicates(new int[] {1, 2, 3, 5, 4, 100}) == true;\n    assert ArraysMDE.noDuplicates(new int[] {2, 2, 3, 5, 4, 0}) == false;\n    assert ArraysMDE.noDuplicates(new int[] {1, 2, 3, 5, 4, 1}) == false;\n    assert ArraysMDE.noDuplicates(new int[] {1, 2, -3, -5, 4, 0}) == true;\n    assert ArraysMDE.noDuplicates(new int[] {1, 2, -2, -2, 4, 100}) == false;\n    assert ArraysMDE.noDuplicates(new int[] {}) == true;\n    assert ArraysMDE.noDuplicates(new int[] {42}) == true;\n\n    // public static int noDuplicates(long[] a)\n    assert ArraysMDE.noDuplicates(new long[] {1, 2, 3, 5, 4, 0}) == true;\n    assert ArraysMDE.noDuplicates(new long[] {1, 2, 3, 5, 4, 100}) == true;\n    assert ArraysMDE.noDuplicates(new long[] {2, 2, 3, 5, 4, 0}) == false;\n    assert ArraysMDE.noDuplicates(new long[] {1, 2, 3, 5, 4, 1}) == false;\n    assert ArraysMDE.noDuplicates(new long[] {1, 2, -3, -5, 4, 0}) == true;\n    assert ArraysMDE.noDuplicates(new long[] {1, 2, -2, -2, 4, 100}) == false;\n    assert ArraysMDE.noDuplicates(new long[] {}) == true;\n    assert ArraysMDE.noDuplicates(new long[] {42}) == true;\n\n    // public static int noDuplicates(double[] a)\n    assert ArraysMDE.noDuplicates(new double[] {1, 2, 3, 5, 4, 0}) == true;\n    assert ArraysMDE.noDuplicates(new double[] {1, 2, 3, 5, 4, 100}) == true;\n    assert ArraysMDE.noDuplicates(new double[] {2, 2, 3, 5, 4, 0}) == false;\n    assert ArraysMDE.noDuplicates(new double[] {1, 2, 3, 5, 4, 1}) == false;\n    assert ArraysMDE.noDuplicates(new double[] {1., 1.001, -3, -5, 4, 0}) == true;\n    assert ArraysMDE.noDuplicates(new double[] {1., 2, -2.00, -2, 4, 100}) == false;\n    assert ArraysMDE.noDuplicates(new double[] {}) == true;\n    assert ArraysMDE.noDuplicates(new double[] {42}) == true;\n\n    // public static int noDuplicates(String[] a)\n    assert ArraysMDE.noDuplicates(new String[] {\"1\", \"2\", \"3\", \"5\", \"4\", \"0\"}) == true;\n    assert ArraysMDE.noDuplicates(new String[] {\"A\", \"a\", \"foo\", \"Foo\", \"\"}) == true;\n    assert ArraysMDE.noDuplicates(new String[] {\" \", \" \"}) == false;\n    assert ArraysMDE.noDuplicates(new String[] {\"  \", \" \"}) == true;\n\n    // public static boolean fn_is_permutation(int[] a)\n    assert ArraysMDE.fn_is_permutation(new int[] {0, 1, 2, 3}) == true;\n    assert ArraysMDE.fn_is_permutation(new int[] {1, 2, 3, 0}) == true;\n    assert ArraysMDE.fn_is_permutation(new int[] {3, 2, 1, 0}) == true;\n    assert ArraysMDE.fn_is_permutation(new int[] {0, 1, 2, 2}) == false;\n    assert ArraysMDE.fn_is_permutation(new int[] {0, -1, 2, 3}) == false;\n    assert ArraysMDE.fn_is_permutation(new int[] {0, 1, 2, 4}) == false;\n    assert ArraysMDE.fn_is_permutation(new int[] {0, 0, 0, 0}) == false;\n\n    // public static boolean fn_is_total(int[] a)\n    assert ArraysMDE.fn_is_total(new int[] {0, 1, 2, 3}) == true;\n    assert ArraysMDE.fn_is_total(new int[] {1, 2, 3, 0}) == true;\n    assert ArraysMDE.fn_is_total(new int[] {3, 2, 1, 0}) == true;\n    assert ArraysMDE.fn_is_total(new int[] {0, 1, 2, 2}) == true;\n    assert ArraysMDE.fn_is_total(new int[] {-1, 0, 2, 3}) == false;\n    assert ArraysMDE.fn_is_total(new int[] {0, -1, 2, 3}) == false;\n    assert ArraysMDE.fn_is_total(new int[] {0, -2, 1, 3}) == true; // weird\n    assert ArraysMDE.fn_is_total(new int[] {0, 2, 3, -1}) == false;\n    assert ArraysMDE.fn_is_total(new int[] {0, 1, 2, 4}) == true;\n    assert ArraysMDE.fn_is_total(new int[] {0, 0, 0, 0}) == true;\n\n    // public static int[] fn_identity(int length)\n    assert_arrays_equals(ArraysMDE.fn_identity(0), new int[] {});\n    assert_arrays_equals(ArraysMDE.fn_identity(1), new int[] {0});\n    assert_arrays_equals(ArraysMDE.fn_identity(2), new int[] {0, 1});\n    assert_arrays_equals(ArraysMDE.fn_identity(3), new int[] {0, 1, 2});\n\n    // public static int[] fn_inverse_permutation(int[] a)\n    assert_arrays_equals(\n        ArraysMDE.fn_inverse_permutation(new int[] {0, 1, 2, 3}), new int[] {0, 1, 2, 3});\n    assert_arrays_equals(\n        ArraysMDE.fn_inverse_permutation(new int[] {1, 2, 3, 0}), new int[] {3, 0, 1, 2});\n    assert_arrays_equals(\n        ArraysMDE.fn_inverse_permutation(new int[] {3, 2, 1, 0}), new int[] {3, 2, 1, 0});\n\n    // public static int[] fn_inverse(int[] a, int arange)\n    assert_arrays_equals(ArraysMDE.fn_inverse(new int[] {0, 1, 2, 3}, 4), new int[] {0, 1, 2, 3});\n    assert_arrays_equals(ArraysMDE.fn_inverse(new int[] {1, 2, 3, 0}, 4), new int[] {3, 0, 1, 2});\n    assert_arrays_equals(ArraysMDE.fn_inverse(new int[] {3, 2, 1, 0}, 4), new int[] {3, 2, 1, 0});\n    try {\n      ArraysMDE.fn_inverse(new int[] {1, 0, 3, 0}, 4);\n      throw new Error();\n    } catch (UnsupportedOperationException e) {\n      assert e.getMessage() != null && e.getMessage().equals(\"Not invertible; a[1]=0 and a[3]=0\");\n    }\n    assert_arrays_equals(ArraysMDE.fn_inverse(new int[] {5}, 6), new int[] {-1, -1, -1, -1, -1, 0});\n    assert_arrays_equals(\n        ArraysMDE.fn_inverse(new int[] {1, 2, 3, 5}, 6), new int[] {-1, 0, 1, 2, -1, 3});\n\n    try {\n      assert_arrays_equals(\n          ArraysMDE.fn_inverse(new int[] {100, 101, 102, 103}, 4), new int[] {40, 41, 42, 43});\n      throw new Error();\n    } catch (IllegalArgumentException e) {\n      assert e.getMessage() != null && e.getMessage().equals(\"Bad range value: a[0]=100\");\n    }\n\n    // public static int[] fn_compose(int[] a, int[] b)\n    assert_arrays_equals(\n        ArraysMDE.fn_compose(new int[] {0, 1, 2, 3}, new int[] {0, 1, 2, 3}),\n        new int[] {0, 1, 2, 3});\n    assert_arrays_equals(\n        ArraysMDE.fn_compose(new int[] {1, 2, 3, 0}, new int[] {1, 2, 3, 0}),\n        new int[] {2, 3, 0, 1});\n    assert_arrays_equals(\n        ArraysMDE.fn_compose(new int[] {3, 2, 1, 0}, new int[] {3, 2, 1, 0}),\n        new int[] {0, 1, 2, 3});\n    assert_arrays_equals(\n        ArraysMDE.fn_compose(new int[] {0, 1, 0, 3}, new int[] {0, 5, 2, 1}),\n        new int[] {0, 5, 0, 1});\n    assert_arrays_equals(ArraysMDE.fn_compose(new int[] {0}, new int[] {5}), new int[] {5});\n    assert_arrays_equals(\n        ArraysMDE.fn_compose(new int[] {1, 2, 3, 5}, new int[] {1, 2, 3, 5, -1, -1}),\n        new int[] {2, 3, 5, -1});\n\n    // public static boolean isSubset(long[] smaller, long[] bigger)\n    // public static boolean isSubset(double[] smaller, double[] bigger)\n    // public static boolean isSubset(String[] smaller, String[] bigger)\n\n    {\n      double[] f1 = new double[10];\n      double[] f2 = new double[20];\n\n      for (int j = 0; j < f2.length; j++) {\n        f2[j] = j;\n      }\n      for (int i = 0; i < f2.length - f1.length; i++) {\n\n        //fill up f1 with elements of f2\n        for (int j = 0; j < f1.length; j++) {\n          f1[j] = f2[i + j];\n        }\n\n        f1[5] = f2[i];\n\n        double[] f1_copy = f1.clone();\n        double[] f2_copy = f2.clone();\n\n        assert ArraysMDE.isSubset(f1, f2);\n        assert_arrays_equals(f1, f1_copy);\n        assert_arrays_equals(f2, f2_copy);\n      }\n\n      double[] a1 = new double[] {1, 5, 10};\n      double[] a2 = new double[] {};\n      double[] a3 = new double[] {1};\n      double[] a4 = new double[] {10};\n      double[] a5 = new double[] {1, 10, 15, 20};\n      double[] a6 = new double[] {10, 10, 10, 10, 10, 1};\n\n      assert ArraysMDE.isSubset(a2, a1);\n      assert !ArraysMDE.isSubset(a1, a2);\n      assert !ArraysMDE.isSubset(a1, a5);\n      assert ArraysMDE.isSubset(a3, a1);\n      assert ArraysMDE.isSubset(a4, a1);\n      assert ArraysMDE.isSubset(a6, a1);\n      assert !ArraysMDE.isSubset(a1, a6);\n    }\n\n    // public static class IntArrayComparatorLexical implements Comparator\n    // public static class IntArrayComparatorLengthFirst implements Comparator\n    {\n      Comparator<int[]> iacl = new ArraysMDE.IntArrayComparatorLexical();\n      Comparator<int[]> iaclf = new ArraysMDE.IntArrayComparatorLengthFirst();\n\n      int[] a0 = new int[] {};\n      int[] a1 = new int[] {};\n      int[] a2 = new int[] {0, 1, 2, 3};\n      int[] a3 = new int[] {0, 1, 2, 3, 0};\n      int[] a4 = new int[] {0, 1, 2, 3, 4};\n      int[] a5 = new int[] {0, 1, 2, 3, 4};\n      int[] a6 = new int[] {0, 1, 5, 3, 4};\n      int[] a7 = new int[] {1, 2, 3, 4};\n      int[] a8 = new int[] {-5};\n      int[] a9 = new int[] {Integer.MAX_VALUE};\n      int[] a10 = new int[] {Integer.MIN_VALUE};\n\n      assert iacl.compare(a0, a1) == 0;\n      assert iaclf.compare(a0, a1) == 0;\n      assert iacl.compare(a1, a0) == 0;\n      assert iaclf.compare(a1, a0) == 0;\n      assert iacl.compare(a1, a2) < 0;\n      assert iaclf.compare(a1, a2) < 0;\n      assert iacl.compare(a2, a1) > 0;\n      assert iaclf.compare(a2, a1) > 0;\n      assert iacl.compare(a2, a3) < 0;\n      assert iaclf.compare(a2, a3) < 0;\n      assert iacl.compare(a3, a2) > 0;\n      assert iaclf.compare(a3, a2) > 0;\n      assert iacl.compare(a3, a4) < 0;\n      assert iaclf.compare(a3, a4) < 0;\n      assert iacl.compare(a4, a3) > 0;\n      assert iaclf.compare(a4, a3) > 0;\n      assert iacl.compare(a4, a5) == 0;\n      assert iaclf.compare(a4, a5) == 0;\n      assert iacl.compare(a5, a4) == 0;\n      assert iaclf.compare(a5, a4) == 0;\n      assert iacl.compare(a5, a6) < 0;\n      assert iaclf.compare(a5, a6) < 0;\n      assert iacl.compare(a6, a5) > 0;\n      assert iaclf.compare(a6, a5) > 0;\n      assert iacl.compare(a6, a7) < 0;\n      assert iaclf.compare(a6, a7) > 0;\n      assert iacl.compare(a7, a6) > 0;\n      assert iaclf.compare(a7, a6) < 0;\n      assert iacl.compare(a1, a4) < 0;\n      assert iaclf.compare(a1, a4) < 0;\n      assert iacl.compare(a4, a1) > 0;\n      assert iaclf.compare(a4, a1) > 0;\n      assert iacl.compare(a2, a4) < 0;\n      assert iaclf.compare(a2, a4) < 0;\n      assert iacl.compare(a4, a2) > 0;\n      assert iaclf.compare(a4, a2) > 0;\n      assert iacl.compare(a6, a4) > 0;\n      assert iaclf.compare(a6, a4) > 0;\n      assert iacl.compare(a4, a6) < 0;\n      assert iaclf.compare(a4, a6) < 0;\n      assert iacl.compare(a7, a4) > 0;\n      assert iaclf.compare(a7, a4) < 0;\n      assert iacl.compare(a4, a7) < 0;\n      assert iaclf.compare(a4, a7) > 0;\n      assert iacl.compare(a8, a9) < 0;\n      assert iaclf.compare(a8, a9) < 0;\n      assert iacl.compare(a10, a7) < 0;\n    }\n\n    // public static class LongArrayComparatorLexical implements Comparator\n    // public static class LongArrayComparatorLengthFirst implements Comparator\n    {\n      Comparator<long[]> lacl = new ArraysMDE.LongArrayComparatorLexical();\n      Comparator<long[]> laclf = new ArraysMDE.LongArrayComparatorLengthFirst();\n      long[] a0 = new long[] {};\n      long[] a1 = new long[] {};\n      long[] a2 = new long[] {0, 1, 2, 3};\n      long[] a3 = new long[] {0, 1, 2, 3, 0};\n      long[] a4 = new long[] {0, 1, 2, 3, 4};\n      long[] a5 = new long[] {0, 1, 2, 3, 4};\n      long[] a6 = new long[] {0, 1, 5, 3, 4};\n      long[] a7 = new long[] {1, 2, 3, 4};\n      long[] a8 = new long[] {-5};\n      long[] a9 = new long[] {Long.MAX_VALUE};\n      long[] a10 = new long[] {Long.MIN_VALUE};\n\n      assert lacl.compare(a0, a1) == 0;\n      assert laclf.compare(a0, a1) == 0;\n      assert lacl.compare(a1, a0) == 0;\n      assert laclf.compare(a1, a0) == 0;\n      assert lacl.compare(a1, a2) < 0;\n      assert laclf.compare(a1, a2) < 0;\n      assert lacl.compare(a2, a1) > 0;\n      assert laclf.compare(a2, a1) > 0;\n      assert lacl.compare(a2, a3) < 0;\n      assert laclf.compare(a2, a3) < 0;\n      assert lacl.compare(a3, a2) > 0;\n      assert laclf.compare(a3, a2) > 0;\n      assert lacl.compare(a3, a4) < 0;\n      assert laclf.compare(a3, a4) < 0;\n      assert lacl.compare(a4, a3) > 0;\n      assert laclf.compare(a4, a3) > 0;\n      assert lacl.compare(a4, a5) == 0;\n      assert laclf.compare(a4, a5) == 0;\n      assert lacl.compare(a5, a4) == 0;\n      assert laclf.compare(a5, a4) == 0;\n      assert lacl.compare(a5, a6) < 0;\n      assert laclf.compare(a5, a6) < 0;\n      assert lacl.compare(a6, a5) > 0;\n      assert laclf.compare(a6, a5) > 0;\n      assert lacl.compare(a6, a7) < 0;\n      assert laclf.compare(a6, a7) > 0;\n      assert lacl.compare(a7, a6) > 0;\n      assert laclf.compare(a7, a6) < 0;\n      assert lacl.compare(a1, a4) < 0;\n      assert laclf.compare(a1, a4) < 0;\n      assert lacl.compare(a4, a1) > 0;\n      assert laclf.compare(a4, a1) > 0;\n      assert lacl.compare(a2, a4) < 0;\n      assert laclf.compare(a2, a4) < 0;\n      assert lacl.compare(a4, a2) > 0;\n      assert laclf.compare(a4, a2) > 0;\n      assert lacl.compare(a6, a4) > 0;\n      assert laclf.compare(a6, a4) > 0;\n      assert lacl.compare(a4, a6) < 0;\n      assert laclf.compare(a4, a6) < 0;\n      assert lacl.compare(a7, a4) > 0;\n      assert laclf.compare(a7, a4) < 0;\n      assert lacl.compare(a4, a7) < 0;\n      assert laclf.compare(a4, a7) > 0;\n      assert lacl.compare(a8, a9) < 0;\n      assert laclf.compare(a8, a9) < 0;\n      assert lacl.compare(a10, a7) < 0;\n    }\n\n    // public static class DoubleArrayComparatorLexical implements Comparator\n    {\n      Comparator<double[]> dacl = new ArraysMDE.DoubleArrayComparatorLexical();\n      double[] a0 = new double[] {};\n      double[] a1 = new double[] {};\n      double[] a2 = new double[] {0, 1, 2, 3};\n      double[] a3 = new double[] {0, 1, 2, 3, 0};\n      double[] a4 = new double[] {0, 1, 2, 3, 4};\n      double[] a5 = new double[] {0, 1, 2, 3, 4};\n      double[] a6 = new double[] {0, 1, 5, 3, 4};\n      double[] a7 = new double[] {1, 2, 3, 4};\n      double[] a8 = new double[] {0.005};\n      double[] a9 = new double[] {0.004};\n      double[] a10 = new double[] {-0.005};\n      double[] a11 = new double[] {-0.004};\n      double[] a12 = new double[] {10.0 * Integer.MAX_VALUE};\n      double[] a13 = new double[] {10.0 * Integer.MIN_VALUE};\n\n      assert dacl.compare(a0, a1) == 0;\n      assert dacl.compare(a1, a0) == 0;\n      assert dacl.compare(a1, a2) < 0;\n      assert dacl.compare(a2, a1) > 0;\n      assert dacl.compare(a2, a3) < 0;\n      assert dacl.compare(a3, a2) > 0;\n      assert dacl.compare(a3, a4) < 0;\n      assert dacl.compare(a4, a3) > 0;\n      assert dacl.compare(a4, a5) == 0;\n      assert dacl.compare(a5, a4) == 0;\n      assert dacl.compare(a5, a6) < 0;\n      assert dacl.compare(a6, a5) > 0;\n      assert dacl.compare(a6, a7) < 0;\n      assert dacl.compare(a7, a6) > 0;\n      assert dacl.compare(a1, a4) < 0;\n      assert dacl.compare(a4, a1) > 0;\n      assert dacl.compare(a2, a4) < 0;\n      assert dacl.compare(a4, a2) > 0;\n      assert dacl.compare(a6, a4) > 0;\n      assert dacl.compare(a4, a6) < 0;\n      assert dacl.compare(a7, a4) > 0;\n      assert dacl.compare(a4, a7) < 0;\n\n      // Test the comparisons on small/large numbers\n      assert dacl.compare(a8, a9) > 0;\n      assert dacl.compare(a10, a11) < 0;\n      assert dacl.compare(a11, a12) < 0;\n      assert dacl.compare(a12, a13) > 0;\n      assert dacl.compare(a13, a11) < 0;\n    }\n\n    // public static class ObjectArrayComparatorLexical implements Comparator\n    // public static class ObjectArrayComparatorLengthFirst implements Comparator\n\n    // public static final class ComparableArrayComparatorLexical implements Comparator\n    // public static final class ComparableArrayComparatorLengthFirst implements Comparator\n    {\n      Comparator<String[]> cacl = new ArraysMDE.ComparableArrayComparatorLexical<String>();\n      Comparator<String[]> caclf = new ArraysMDE.ComparableArrayComparatorLengthFirst<String>();\n      String[] a0 = new String[] {};\n      String[] a1 = new String[] {};\n      String[] a2 = new String[] {\"0\", \"1\", \"2\", \"3\"};\n      String[] a3 = new String[] {\"0\", \"1\", \"2\", \"3\", \"0\"};\n      String[] a4 = new String[] {\"0\", \"1\", \"2\", \"3\", \"4\"};\n      String[] a5 = new String[] {\"0\", \"1\", \"2\", \"3\", \"4\"};\n      String[] a6 = new String[] {\"0\", \"1\", \"5\", \"3\", \"4\"};\n      String[] a7 = new String[] {\"1\", \"2\", \"3\", \"4\"};\n      @SuppressWarnings(\n          \"nullness\") // accommodates poor annotation on ComparableArrayComparatorLexical.compare() and ComparableArrayComparatorLengthFirst.compare()\n      String[] a8 = new String[] {\"0\", \"1\", null, \"3\", \"4\"};\n\n      assert cacl.compare(a0, a1) == 0;\n      assert caclf.compare(a0, a1) == 0;\n      assert cacl.compare(a1, a0) == 0;\n      assert caclf.compare(a1, a0) == 0;\n      assert cacl.compare(a1, a2) < 0;\n      assert caclf.compare(a1, a2) < 0;\n      assert cacl.compare(a2, a1) > 0;\n      assert caclf.compare(a2, a1) > 0;\n      assert cacl.compare(a2, a3) < 0;\n      assert caclf.compare(a2, a3) < 0;\n      assert cacl.compare(a3, a2) > 0;\n      assert caclf.compare(a3, a2) > 0;\n      assert cacl.compare(a3, a4) < 0;\n      assert caclf.compare(a3, a4) < 0;\n      assert cacl.compare(a4, a3) > 0;\n      assert caclf.compare(a4, a3) > 0;\n      assert cacl.compare(a4, a5) == 0;\n      assert caclf.compare(a4, a5) == 0;\n      assert cacl.compare(a5, a4) == 0;\n      assert caclf.compare(a5, a4) == 0;\n      assert cacl.compare(a5, a6) < 0;\n      assert caclf.compare(a5, a6) < 0;\n      assert cacl.compare(a6, a5) > 0;\n      assert caclf.compare(a6, a5) > 0;\n      assert cacl.compare(a6, a7) < 0;\n      assert caclf.compare(a6, a7) > 0;\n      assert cacl.compare(a7, a6) > 0;\n      assert caclf.compare(a7, a6) < 0;\n      assert cacl.compare(a1, a4) < 0;\n      assert caclf.compare(a1, a4) < 0;\n      assert cacl.compare(a4, a1) > 0;\n      assert caclf.compare(a4, a1) > 0;\n      assert cacl.compare(a2, a4) < 0;\n      assert caclf.compare(a2, a4) < 0;\n      assert cacl.compare(a4, a2) > 0;\n      assert caclf.compare(a4, a2) > 0;\n      assert cacl.compare(a6, a4) > 0;\n      assert caclf.compare(a6, a4) > 0;\n      assert cacl.compare(a4, a6) < 0;\n      assert caclf.compare(a4, a6) < 0;\n      assert cacl.compare(a7, a4) > 0;\n      assert caclf.compare(a7, a4) < 0;\n      assert cacl.compare(a8, a1) > 0;\n      assert caclf.compare(a8, a1) > 0;\n      assert cacl.compare(a1, a8) < 0;\n      assert caclf.compare(a1, a8) < 0;\n      assert cacl.compare(a8, a2) < 0;\n      assert caclf.compare(a8, a2) > 0;\n      assert cacl.compare(a2, a8) > 0;\n      assert caclf.compare(a2, a8) < 0;\n      assert cacl.compare(a8, a3) < 0;\n      assert caclf.compare(a8, a3) < 0;\n      assert cacl.compare(a3, a8) > 0;\n      assert caclf.compare(a3, a8) > 0;\n    }\n\n    // public static boolean any_null(Object[] a)\n    {\n      Object o = new Object();\n      assert ArraysMDE.any_null(new Object[] {}) == false;\n      assert ArraysMDE.any_null(new Object[] {null}) == true;\n      assert ArraysMDE.any_null(new Object[] {null, null}) == true;\n      assert ArraysMDE.any_null(new Object[] {o}) == false;\n      assert ArraysMDE.any_null(new Object[] {o, o}) == false;\n      assert ArraysMDE.any_null(new Object[] {o, null, null}) == true;\n      assert ArraysMDE.any_null(new Object[] {null, o, null}) == true;\n      assert ArraysMDE.any_null(new Object[] {o, null, o}) == true;\n      assert ArraysMDE.any_null(new Object[] {null, o, o}) == true;\n      assert ArraysMDE.any_null(new Object[][] {}) == false;\n      assert ArraysMDE.any_null(new Object[][] {null}) == true;\n      // Extraneous @Nullable on the following lines are due to CF issue #599:\n      // https://github.com/typetools/checker-framework/issues/599\n      assert ArraysMDE.any_null(new /*@Nullable*/ Object[][] {new Object[] {null}}) == false;\n      assert ArraysMDE.any_null(new /*@Nullable*/ Object[][] {new Object[] {null}, null}) == true;\n      assert ArraysMDE.any_null(\n              new /*@Nullable*/ Object[][] {new Object[] {null}, new Object[] {o}})\n          == false;\n    }\n\n    // public static boolean all_null(Object[] a)\n    {\n      Object o = new Object();\n      assert ArraysMDE.all_null(new Object[] {}) == true;\n      assert ArraysMDE.all_null(new Object[] {null}) == true;\n      assert ArraysMDE.all_null(new Object[] {null, null}) == true;\n      assert ArraysMDE.all_null(new Object[] {o}) == false;\n      assert ArraysMDE.all_null(new Object[] {o, o}) == false;\n      assert ArraysMDE.all_null(new Object[] {o, null, null}) == false;\n      assert ArraysMDE.all_null(new Object[] {null, o, null}) == false;\n      assert ArraysMDE.all_null(new Object[] {o, null, o}) == false;\n      assert ArraysMDE.all_null(new Object[] {null, o, o}) == false;\n      assert ArraysMDE.all_null(new Object[][] {}) == true;\n      assert ArraysMDE.all_null(new Object[][] {null}) == true;\n      assert ArraysMDE.all_null(new Object[][] {null, null}) == true;\n      assert ArraysMDE.all_null(new /*@Nullable*/ Object[][] {new Object[] {null}}) == false;\n      assert ArraysMDE.all_null(new /*@Nullable*/ Object[][] {new Object[] {null}, null}) == false;\n      assert ArraysMDE.all_null(\n              new /*@Nullable*/ Object[][] {new Object[] {null}, new Object[] {o}})\n          == false;\n    }\n  }\n\n  // This cannot be static because it instantiates an inner class.\n  @Test\n  public void testHasher() {\n\n    /// To check (maybe some of these are done already).\n    /// All of these methods are in Intern; should the tests appear in\n    /// testIntern() or here?\n    // public static void internStrings(String[] a)\n    // public static boolean isInterned(Object value)\n    // public static int numIntegers()\n    // public static int numIntArrays()\n    // public static int numDoubles()\n    // public static int numDoubleArrays()\n    // public static int numObjectArrays()\n    // public static Iterator integers()\n    // public static Iterator intArrays()\n    // public static Iterator doubles()\n    // public static Iterator doubleArrays()\n    // public static Iterator objectArrays()\n    // public static Integer intern(Integer a)\n    // public static Integer internedInteger(int i)\n    // public static Integer internedInteger(String s)\n    // public static int[] intern(int[] a)\n    // public static Double intern(Double a)\n    // public static Double internedDouble(int i)\n    // public static Double internedDouble(String s)\n    // public static double[] intern(double[] a)\n    // public static Object[] intern(Object[] a)\n\n    // private static class IntArrayHasher implements Hasher\n    // private static class ObjectArrayHasher implements Hasher\n    // public static int[] intern(int[] a)\n    // public static Object[] intern(Object[] a)\n\n    class InternTest {\n      // javadoc won't let this be static.\n      void test(boolean random) {\n        int size1 = (random ? 100 : 1);\n        int size2 = (random ? 10 : 1);\n\n        Random random_gen = new Random();\n\n        int[][] arrays = new int[100][];\n        for (int i = 0; i < arrays.length; i++) {\n          int[] a = new int[10];\n          for (int j = 0; j < a.length; j++) {\n            if (random) {\n              a[j] = random_gen.nextInt(1000);\n            } else {\n              a[j] = j;\n            }\n          }\n          arrays[i] = a;\n          // System.out.println(ArraysMDE.toString(a));\n          // Sadly, this is required to get the last array to be\n          // garbage-collected with Jikes 1.03 and JDK 1.2.2.\n          a = null;\n        }\n        System.gc();\n        if (Intern.numIntArrays() != 0) {\n          throw new Error(\" expected 0 int arrays at start, found \" + Intern.numIntArrays());\n        }\n        for (int i = 0; i < arrays.length; i++) {\n          Intern.intern(arrays[i]);\n        }\n        if (Intern.numIntArrays() != size1) {\n          throw new Error(\"Expected \" + size1 + \", got \" + Intern.numIntArrays() + \" int arrays\");\n        }\n        System.gc();\n        if (Intern.numIntArrays() != size1) {\n          throw new Error();\n        }\n        for (int i = 10; i < arrays.length; i++) {\n          @SuppressWarnings(\"nullness\")\n          int /*@NonNull*/ [] reset_value = null;\n          arrays[i] = reset_value;\n        }\n        System.gc();\n        if (Intern.numIntArrays() != size2) {\n          if (Intern.numIntArrays() < size2 + 10) {\n            System.out.println(\n                \"Is JIT disabled?  Size should have been \"\n                    + size2\n                    + \", actually was \"\n                    + Intern.numIntArrays());\n          } else {\n            System.out.println(\"================\");\n            for (int i = 0; i < arrays.length; i++) {\n              System.out.println(ArraysMDE.toString(arrays[i]));\n            }\n            System.out.println(\"================\");\n            for (Iterator<int[]> itor = Intern.intArrays(); itor.hasNext(); ) {\n              System.out.println(ArraysMDE.toString(itor.next()));\n            }\n            String message =\n                (\"Size should have been \" + size2 + \", actually was \" + Intern.numIntArrays());\n            System.out.println(message);\n            throw new Error(message);\n          }\n        }\n      }\n    }\n\n    InternTest intern = new InternTest();\n    intern.test(true);\n    intern.test(false);\n  }\n\n  @Test\n  public void testIntern() {\n    Integer i = Intern.internedInteger(\"1234\");\n    assert Intern.isInterned(i);\n    assert i.intValue() == 1234;\n    i = Intern.internedInteger(\"0x12ab\");\n    assert Intern.isInterned(i);\n    assert i.intValue() == 0x12ab;\n\n    Long l = Intern.internedLong(\"12345678\");\n    assert Intern.isInterned(l);\n    assert l.intValue() == 12345678;\n    l = Intern.internedLong(\"0x1234abcd\");\n    assert Intern.isInterned(l);\n    assert l.intValue() == 0x1234abcd;\n  }\n\n  // Tests the method \"Object intern(Object)\" in Intern.java\n  @Test\n  public void testInternObject() {\n    Object nIntern = Intern.intern((/*@Nullable*/ Object) null);\n    assert nIntern == null;\n\n    String sOrig = new String(\"foo\");\n    String sIntern = Intern.intern(sOrig);\n    Object sObjIntern = Intern.intern((Object) sOrig);\n    assert sIntern == sObjIntern;\n    Object sOtherIntern = Intern.intern(new String(\"foo\"));\n    assert sIntern == sOtherIntern;\n\n    String[] saOrig = new String[] {\"foo\", \"bar\"};\n    String[] saIntern = Intern.intern(saOrig);\n    Object saObjIntern = Intern.intern((Object) saOrig);\n    assert saIntern == saObjIntern;\n    Object saOtherIntern = Intern.intern(new String[] {\"foo\", \"bar\"});\n    assert saIntern == saOtherIntern;\n\n    Integer iOrig = new Integer(1);\n    Integer iIntern = Intern.intern(iOrig);\n    Object iObjIntern = Intern.intern((Object) iOrig);\n    assert iIntern == iObjIntern;\n    Object iOtherIntern = Intern.intern((Object) new Integer(1));\n    assert iIntern == iOtherIntern;\n\n    Long lOrig = new Long(12345678901234L);\n    Long lIntern = Intern.intern(lOrig);\n    Object lObjIntern = Intern.intern((Object) lOrig);\n    assert lIntern == lObjIntern;\n    Object lOtherIntern = Intern.intern((Object) new Long(12345678901234L));\n    assert lIntern == lOtherIntern;\n\n    int[] iaOrig = new int[] {1, 2, 3};\n    int[] iaIntern = Intern.intern(iaOrig);\n    Object iaObjIntern = Intern.intern((Object) iaOrig);\n    assert iaIntern == iaObjIntern;\n    Object iaOtherIntern = Intern.intern((Object) new int[] {1, 2, 3});\n    assert iaIntern == iaOtherIntern;\n\n    long[] laOrig = new long[] {12345678901234L, 98765432109876L};\n    long[] laIntern = Intern.intern(laOrig);\n    Object laObjIntern = Intern.intern((Object) laOrig);\n    assert laIntern == laObjIntern;\n    Object laOtherIntern = Intern.intern((Object) new long[] {12345678901234L, 98765432109876L});\n    assert laIntern == laOtherIntern;\n\n    // Need to test positive and negative zeros, infinities.\n\n    Double dOrig = new Double(3.14);\n    Double dIntern = Intern.intern(dOrig);\n    Object dObjIntern = Intern.intern((Object) dOrig);\n    assert dIntern == dObjIntern;\n    Object dOtherIntern = Intern.intern((Object) dOrig);\n    assert dIntern == dOtherIntern;\n\n    Double dnOrig = new Double(Double.NaN);\n    Double dnIntern = Intern.intern(dnOrig);\n    Object dnObjIntern = Intern.intern((Object) dnOrig);\n    assert dnIntern == dnObjIntern;\n    Object dnOtherIntern =\n        Intern.intern((Object) new Double(Double.POSITIVE_INFINITY / Double.POSITIVE_INFINITY));\n    assert dnIntern == dnOtherIntern;\n\n    Double diOrig = new Double(Double.POSITIVE_INFINITY);\n    Double diIntern = Intern.intern(diOrig);\n    Object diObjIntern = Intern.intern((Object) diOrig);\n    assert diIntern == diObjIntern;\n    Object diOtherIntern = Intern.intern((Object) new Double(2 * Double.MAX_VALUE));\n    assert diIntern == diOtherIntern;\n\n    double positive_zero = +0.0;\n    double negative_zero = -0.0;\n    assert positive_zero == negative_zero;\n    assert 1 / positive_zero == Double.POSITIVE_INFINITY;\n    assert 1 / negative_zero == Double.NEGATIVE_INFINITY;\n\n    Double dzOrig = new Double(positive_zero);\n    Double dzIntern = Intern.intern(dzOrig);\n    Object dzObjIntern = Intern.intern((Object) dzOrig);\n    assert dzIntern == dzObjIntern;\n    Object dzOtherIntern = Intern.intern((Object) new Double(negative_zero));\n    assert dzIntern == dzOtherIntern;\n\n    double[] daOrig = new double[] {3.14, 2.71};\n    double[] daIntern = Intern.intern(daOrig);\n    Object daObjIntern = Intern.intern((Object) daOrig);\n    assert daIntern == daObjIntern;\n    Object daOtherIntern = Intern.intern((Object) new double[] {3.14, 2.71});\n    assert daIntern == daOtherIntern;\n\n    double[] da2Orig = new double[] {+0.0, Double.NaN};\n    double[] da2Intern = Intern.intern(da2Orig);\n    Object da2ObjIntern = Intern.intern((Object) da2Orig);\n    assert da2Intern == da2ObjIntern;\n    Object da2OtherIntern =\n        Intern.intern(\n            (Object) new double[] {-0.0, Double.POSITIVE_INFINITY / Double.POSITIVE_INFINITY});\n    assert da2Intern == da2OtherIntern;\n\n    Object[] oaOrig = new Object[] {new String(\"foo\"), new Integer(1)};\n    Object[] oaIntern = Intern.intern(oaOrig);\n    Object oaObjIntern = Intern.intern((Object) oaOrig);\n    assert oaIntern == oaObjIntern;\n    Object oaOtherIntern = Intern.intern((Object) new Object[] {new String(\"foo\"), new Integer(1)});\n    assert oaIntern == oaOtherIntern;\n\n    java.awt.Point pOrig = new java.awt.Point(1, 2);\n    try {\n      Intern.intern((Object) pOrig); // performed for side effect\n      throw new Error(\"Didn't throw IllegalArgumentException\");\n    } catch (IllegalArgumentException e) {\n    }\n  }\n\n  // Add 100 elements randomly selected from the range 0..limit-1 to the set.\n  private static void lsis_add_elts(int limit, LimitedSizeSet<Integer> s) {\n    Random r = new Random(20140613);\n    for (int i = 0; i < 100; i++) {\n      s.add(r.nextInt(limit));\n    }\n  }\n\n  // Create a LimitedSizeSet of the given size, and add elements to it.\n  private static void lsis_test(int max_size) {\n    LimitedSizeSet<Integer> s = new LimitedSizeSet<Integer>(max_size);\n    for (int i = 1; i < 2 * max_size; i++) {\n      lsis_add_elts(i, s);\n      int size = s.size();\n      assert ((i <= max_size) ? (size == i) : (size == max_size + 1))\n          : String.format(\n              \"(%d<=%d) ? (%d==%d) : (%d==%d+1)   size=%d, i=%d, max_size=%d, s=%s\",\n              i,\n              max_size,\n              size,\n              i,\n              size,\n              max_size,\n              size,\n              i,\n              max_size,\n              s);\n    }\n  }\n\n  private static void lss_with_null_test() {\n    LimitedSizeSet</*@Nullable*/ Integer> s = new LimitedSizeSet</*@Nullable*/ Integer>(10);\n    s.add(1);\n    s.add(2);\n    s.add(null);\n    assert s.size() == 3;\n    assert s.contains(1);\n    assert s.contains(null);\n    s.add(3);\n    assert s.size() == 4;\n    assert s.contains(1);\n    assert s.contains(null);\n    assert s.contains(3);\n  }\n\n  @Test\n  public void testLimitedSizeSet() {\n    for (int i = 1; i < 10; i++) {\n      lsis_test(i);\n    }\n    lss_with_null_test();\n  }\n\n  // This cannot be static because it instantiates an inner class.\n  @Test\n  public void testMathMDE() {\n\n    // int negate(int a)\n    assert MathMDE.negate(3) == -3;\n    assert MathMDE.negate(-22) == 22;\n    assert MathMDE.negate(0) == 0;\n\n    // int bitwiseComplement(int a)\n    assert MathMDE.bitwiseComplement(3) == -4;\n    assert MathMDE.bitwiseComplement(-22) == 21;\n    assert MathMDE.bitwiseComplement(0) == -1;\n\n    // int sign(int a)\n    assert MathMDE.sign(3) == 1;\n    assert MathMDE.sign(-22) == -1;\n    assert MathMDE.sign(0) == 0;\n\n    // int pow(int base, int expt)\n    try {\n      assert MathMDE.pow(3, 3) == 27;\n      assert MathMDE.pow(-5, 5) == -3125;\n      assert MathMDE.pow(22, 0) == 1;\n      assert MathMDE.pow(4, 6) == 4096;\n      assert MathMDE.pow(1, 222222) == 1;\n      assert MathMDE.pow(-2, 25) == -33554432;\n      // This is beyond the precision.  Maybe return a long instead of an int?\n      // assert MathMDE.pow(-3, 25) == ...;\n    } catch (Exception e) {\n      e.printStackTrace();\n      throw new Error(e);\n    }\n    try {\n      MathMDE.pow(3, -3);\n      throw new Error(\"Didn't throw ArithmeticException\");\n    } catch (ArithmeticException e) {\n    }\n\n    // int gcd(int a, int b)\n    assert MathMDE.gcd(2, 50) == 2;\n    assert MathMDE.gcd(50, 2) == 2;\n    assert MathMDE.gcd(12, 144) == 12;\n    assert MathMDE.gcd(144, 12) == 12;\n    assert MathMDE.gcd(96, 144) == 48;\n    assert MathMDE.gcd(144, 96) == 48;\n    assert MathMDE.gcd(10, 25) == 5;\n    assert MathMDE.gcd(25, 10) == 5;\n    assert MathMDE.gcd(17, 25) == 1;\n    assert MathMDE.gcd(25, 17) == 1;\n    assert MathMDE.gcd(0, 10) == 10;\n    assert MathMDE.gcd(10, 0) == 10;\n    assert MathMDE.gcd(25, -10) == 5;\n    assert MathMDE.gcd(-25, -10) == 5;\n    assert MathMDE.gcd(-25, 10) == 5;\n\n    // int gcd(int[] a)\n    assert MathMDE.gcd(new int[] {2, 50}) == 2;\n    assert MathMDE.gcd(new int[] {12, 144}) == 12;\n    assert MathMDE.gcd(new int[] {96, 144}) == 48;\n    assert MathMDE.gcd(new int[] {10, 25}) == 5;\n    assert MathMDE.gcd(new int[] {100, 10, 25}) == 5;\n    assert MathMDE.gcd(new int[] {768, 324}) == 12;\n    assert MathMDE.gcd(new int[] {2400, 48, 36}) == 12;\n    assert MathMDE.gcd(new int[] {2400, 72, 36}) == 12;\n\n    // int gcd_differences(int[] a)\n    // Weak set of tests, derived directly from those of \"int gcd(int[] a)\".\n    assert MathMDE.gcd_differences(new int[] {0, 2, 52}) == 2;\n    assert MathMDE.gcd_differences(new int[] {0, 12, 156}) == 12;\n    assert MathMDE.gcd_differences(new int[] {0, 96, 240}) == 48;\n    assert MathMDE.gcd_differences(new int[] {0, 10, 35}) == 5;\n    assert MathMDE.gcd_differences(new int[] {0, 100, 110, 135}) == 5;\n    assert MathMDE.gcd_differences(new int[] {0, 768, 1092}) == 12;\n    assert MathMDE.gcd_differences(new int[] {0, 2400, 2448, 2484}) == 12;\n    assert MathMDE.gcd_differences(new int[] {0, 2400, 2472, 2508}) == 12;\n    assert MathMDE.gcd_differences(new int[] {5, 5, 5, 5}) == 0;\n\n    // int mod_positive(int x, int y)\n    assert MathMDE.mod_positive(33, 5) == 3;\n    assert MathMDE.mod_positive(-33, 5) == 2;\n    assert MathMDE.mod_positive(33, -5) == 3;\n    assert MathMDE.mod_positive(-33, -5) == 2;\n\n    // int[] missing_numbers(int[] nums)\n    assert_arrays_equals(MathMDE.missing_numbers(new int[] {3, 4, 5, 6, 7, 8}), new int[] {});\n    assert_arrays_equals(MathMDE.missing_numbers(new int[] {3, 4, 6, 7, 8}), new int[] {5});\n    assert_arrays_equals(MathMDE.missing_numbers(new int[] {3, 4, 8}), new int[] {5, 6, 7});\n    assert_arrays_equals(MathMDE.missing_numbers(new int[] {3, 5, 6, 8}), new int[] {4, 7});\n    assert_arrays_equals(MathMDE.missing_numbers(new int[] {3, 6, 8}), new int[] {4, 5, 7});\n\n    // class MissingNumbersIteratorInt\n    class TestMissingNumbersIteratorInt {\n      // javadoc won't let this be static\n      void test(int[] orig, boolean add_ends, int[] goal_missing) {\n        Iterator<Integer> orig_iterator = int_array_iterator(orig);\n        Iterator<Integer> missing_iterator =\n            new MathMDE.MissingNumbersIteratorInt(orig_iterator, add_ends);\n        int[] missing = TestPlume.int_iterator_array(missing_iterator);\n        assert_arrays_equals(missing, goal_missing);\n      }\n    }\n\n    TestMissingNumbersIteratorInt tmni = new TestMissingNumbersIteratorInt();\n    tmni.test(new int[] {3, 4, 5, 6, 7, 8}, false, new int[] {});\n    tmni.test(new int[] {3, 4, 6, 7, 8}, false, new int[] {5});\n    tmni.test(new int[] {3, 4, 8}, false, new int[] {5, 6, 7});\n    tmni.test(new int[] {3, 5, 6, 8}, false, new int[] {4, 7});\n    tmni.test(new int[] {3, 6, 8}, false, new int[] {4, 5, 7});\n    tmni.test(new int[] {3}, false, new int[] {});\n    tmni.test(new int[] {3, 4, 5}, false, new int[] {});\n    tmni.test(new int[] {3, 4, 5, 6, 7, 8}, true, new int[] {2, 9});\n    tmni.test(new int[] {3, 4, 6, 7, 8}, true, new int[] {2, 5, 9});\n    tmni.test(new int[] {3, 4, 8}, true, new int[] {2, 5, 6, 7, 9});\n    tmni.test(new int[] {3, 5, 6, 8}, true, new int[] {2, 4, 7, 9});\n    tmni.test(new int[] {3, 6, 8}, true, new int[] {2, 4, 5, 7, 9});\n    tmni.test(new int[] {3, 4, 5}, true, new int[] {2, 6});\n\n    tmni.test(new int[] {-1, 1, 2, 3, 5, 6, 7, 9}, true, new int[] {-2, 0, 4, 8, 10});\n\n    // int[] modulus(int[] nums)\n    // int[] modulus(Iterator itor)\n\n    class TestModulus {\n      // javadoc won't let this be static\n      void check(int[] nums, int /*@Nullable*/ [] goal_rm) {\n        int[] rm = MathMDE.modulus(nums);\n        if (!Arrays.equals(rm, goal_rm)) {\n          throw new Error(\n              \"Expected (r,m)=\"\n                  + ArraysMDE.toString(goal_rm)\n                  + \", saw (r,m)=\"\n                  + ArraysMDE.toString(rm));\n        }\n        if (rm == null) {\n          return;\n        }\n        int goal_r = rm[0];\n        int m = rm[1];\n        for (int i = 0; i < nums.length; i++) {\n          int r = nums[i] % m;\n          if (r < 0) {\n            r += m;\n          }\n          if (r != goal_r) {\n            throw new Error(\"Expected \" + nums[i] + \" % \" + m + \" = \" + goal_r + \", got \" + r);\n          }\n        }\n      }\n\n      // javadoc won't let this be static\n      void check(Iterator<Integer> itor, int /*@Nullable*/ [] goal_rm) {\n        // There would be no point to this:  it's testing\n        // int_iterator_array, not the iterator version!\n        // return check(int_iterator_array(itor), goal_rm);\n        assert_arrays_equals(MathMDE.modulus_int(itor), goal_rm);\n      }\n\n      // javadoc won't let this be static\n      void check_iterator(int[] nums, int /*@Nullable*/ [] goal_rm) {\n        check(int_array_iterator(nums), goal_rm);\n      }\n    }\n\n    TestModulus testModulus = new TestModulus();\n\n    testModulus.check(new int[] {3, 7, 47, 51}, new int[] {3, 4});\n    testModulus.check(new int[] {3, 11, 43, 51}, new int[] {3, 8});\n    testModulus.check(new int[] {3, 11, 47, 55}, new int[] {3, 4});\n    testModulus.check(new int[] {2383, 4015, -81, 463, -689}, new int[] {15, 32});\n    testModulus.check(new int[] {}, null);\n    testModulus.check(new int[] {1}, null);\n    testModulus.check(new int[] {3, 7}, null);\n    testModulus.check(new int[] {2, 3, 5, 7}, null);\n    testModulus.check(new int[] {2, 19, 101}, null);\n    testModulus.check(new int[] {5, 5, 5, 5, 5}, null);\n\n    testModulus.check_iterator(new int[] {}, null);\n    testModulus.check_iterator(new int[] {1}, null);\n    testModulus.check_iterator(new int[] {3, 7, 47, 51}, new int[] {3, 4});\n    testModulus.check_iterator(new int[] {3, 11, 43, 51}, new int[] {3, 8});\n    testModulus.check_iterator(new int[] {3, 11, 47, 55}, new int[] {3, 4});\n    testModulus.check_iterator(new int[] {2383, 4015, -81, 463, -689}, new int[] {15, 32});\n    testModulus.check_iterator(new int[] {5, 5, 5, 5, 5}, null);\n\n    // int[] nonmodulus_strict(int[] nums)\n    // int[] nonmodulus_nonstrict(int[] nums)\n    // int[] nonmodulus_strict(Iterator nums)\n\n    class TestNonModulus {\n      // javadoc won't let this be static\n      void check_strict(int[] nums, int /*@Nullable*/ [] goal_rm) {\n        check(nums, goal_rm, true);\n        Iterator<Integer> itor = int_array_iterator(nums);\n        assert_arrays_equals(MathMDE.nonmodulus_strict_int(itor), goal_rm);\n      }\n\n      // javadoc won't let this be static\n      void check_nonstrict(int[] nums, int /*@Nullable*/ [] goal_rm) {\n        check(nums, goal_rm, false);\n      }\n\n      // javadoc won't let this be static\n      void check(int[] nums, int /*@Nullable*/ [] goal_rm, boolean strict) {\n        int[] rm;\n        if (strict) {\n          rm = MathMDE.nonmodulus_strict(nums);\n        } else {\n          rm = MathMDE.nonmodulus_nonstrict(nums);\n        }\n        if (!Arrays.equals(rm, goal_rm)) {\n          throw new Error(\n              \"Expected (r,m)=\"\n                  + ArraysMDE.toString(goal_rm)\n                  + \", saw (r,m)=\"\n                  + ArraysMDE.toString(rm));\n        }\n        if (rm == null) {\n          return;\n        }\n        int goal_r = rm[0];\n        int m = rm[1];\n        for (int i = 0; i < nums.length; i++) {\n          int r = nums[i] % m;\n          if (r < 0) {\n            r += m;\n          }\n          if (r == goal_r) {\n            throw new Error(\"Expected inequality, saw \" + nums[i] + \" % \" + m + \" = \" + r);\n          }\n        }\n      }\n    }\n\n    TestNonModulus testNonModulus = new TestNonModulus();\n\n    testNonModulus.check_strict(new int[] {1, 2, 3, 5, 6, 7, 9}, null);\n    testNonModulus.check_strict(new int[] {-1, 1, 2, 3, 5, 6, 7, 9}, new int[] {0, 4});\n    testNonModulus.check_strict(new int[] {1, 2, 3, 5, 6, 7, 9, 11}, null);\n    testNonModulus.check_strict(new int[] {1, 2, 3, 5, 6, 7, 11}, null);\n    testNonModulus.check_strict(new int[] {1, 2, 4, 6, 8, 10}, null);\n\n    // null because only 7 elements, so don't try modulus = 4\n    testNonModulus.check_nonstrict(new int[] {1, 2, 3, 5, 6, 7, 9}, null);\n    testNonModulus.check_nonstrict(new int[] {1, 2, 3, 5, 6, 7, 9, 10}, new int[] {0, 4});\n    testNonModulus.check_nonstrict(new int[] {1, 2, 3, 5, 6, 7, 9, 11}, new int[] {0, 4});\n    testNonModulus.check_nonstrict(new int[] {1, 2, 3, 5, 6, 7, 9, 11, 12, 13}, null);\n    testNonModulus.check_nonstrict(\n        new int[] {1, 2, 3, 5, 6, 7, 9, 11, 12, 13, 14, 15}, new int[] {4, 6});\n    testNonModulus.check_nonstrict(new int[] {1, 2, 3, 5, 6, 7, 9, 11, 12, 13, 14, 15, 22}, null);\n  }\n\n  @Test\n  public void testOrderedPairIterator() {\n    final int NULL = -2222;\n\n    Vector<Integer> ones = new Vector<Integer>();\n    for (int i = 1; i <= 30; i++) {\n      ones.add(new Integer(i));\n    }\n    Vector<Integer> twos = new Vector<Integer>();\n    for (int i = 2; i <= 30; i += 2) {\n      twos.add(new Integer(i));\n    }\n    Vector<Integer> threes = new Vector<Integer>();\n    for (int i = 3; i <= 30; i += 3) {\n      threes.add(new Integer(i));\n    }\n\n    // I've replaced the nulls by 0 in order to permit the array elements\n    // to be ints instead of Integers.\n\n    compareOrderedPairIterator(\n        new OrderedPairIterator<Integer>(ones.iterator(), ones.iterator()),\n        new int[][] {\n          {1, 1}, {2, 2}, {3, 3}, {4, 4}, {5, 5}, {6, 6}, {7, 7}, {8, 8}, {9, 9}, {10, 10},\n          {11, 11}, {12, 12}, {13, 13}, {14, 14}, {15, 15}, {16, 16}, {17, 17}, {18, 18}, {19, 19},\n          {20, 20}, {21, 21}, {22, 22}, {23, 23}, {24, 24}, {25, 25}, {26, 26}, {27, 27}, {28, 28},\n          {29, 29}, {30, 30},\n        });\n\n    compareOrderedPairIterator(\n        new OrderedPairIterator<Integer>(ones.iterator(), twos.iterator()),\n        new int[][] {\n          {1, NULL},\n          {2, 2},\n          {3, NULL},\n          {4, 4},\n          {5, NULL},\n          {6, 6},\n          {7, NULL},\n          {8, 8},\n          {9, NULL},\n          {10, 10},\n          {11, NULL},\n          {12, 12},\n          {13, NULL},\n          {14, 14},\n          {15, NULL},\n          {16, 16},\n          {17, NULL},\n          {18, 18},\n          {19, NULL},\n          {20, 20},\n          {21, NULL},\n          {22, 22},\n          {23, NULL},\n          {24, 24},\n          {25, NULL},\n          {26, 26},\n          {27, NULL},\n          {28, 28},\n          {29, NULL},\n          {30, 30},\n        });\n\n    compareOrderedPairIterator(\n        new OrderedPairIterator<Integer>(twos.iterator(), ones.iterator()),\n        new int[][] {\n          {NULL, 1},\n          {2, 2},\n          {NULL, 3},\n          {4, 4},\n          {NULL, 5},\n          {6, 6},\n          {NULL, 7},\n          {8, 8},\n          {NULL, 9},\n          {10, 10},\n          {NULL, 11},\n          {12, 12},\n          {NULL, 13},\n          {14, 14},\n          {NULL, 15},\n          {16, 16},\n          {NULL, 17},\n          {18, 18},\n          {NULL, 19},\n          {20, 20},\n          {NULL, 21},\n          {22, 22},\n          {NULL, 23},\n          {24, 24},\n          {NULL, 25},\n          {26, 26},\n          {NULL, 27},\n          {28, 28},\n          {NULL, 29},\n          {30, 30},\n        });\n\n    compareOrderedPairIterator(\n        new OrderedPairIterator<Integer>(ones.iterator(), threes.iterator()),\n        new int[][] {\n          {1, NULL},\n          {2, NULL},\n          {3, 3},\n          {4, NULL},\n          {5, NULL},\n          {6, 6},\n          {7, NULL},\n          {8, NULL},\n          {9, 9},\n          {10, NULL},\n          {11, NULL},\n          {12, 12},\n          {13, NULL},\n          {14, NULL},\n          {15, 15},\n          {16, NULL},\n          {17, NULL},\n          {18, 18},\n          {19, NULL},\n          {20, NULL},\n          {21, 21},\n          {22, NULL},\n          {23, NULL},\n          {24, 24},\n          {25, NULL},\n          {26, NULL},\n          {27, 27},\n          {28, NULL},\n          {29, NULL},\n          {30, 30},\n        });\n\n    compareOrderedPairIterator(\n        new OrderedPairIterator<Integer>(twos.iterator(), threes.iterator()),\n        new int[][] {\n          {2, NULL},\n          {NULL, 3},\n          {4, NULL},\n          {6, 6},\n          {8, NULL},\n          {NULL, 9},\n          {10, NULL},\n          {12, 12},\n          {14, NULL},\n          {NULL, 15},\n          {16, NULL},\n          {18, 18},\n          {20, NULL},\n          {NULL, 21},\n          {22, NULL},\n          {24, 24},\n          {26, NULL},\n          {NULL, 27},\n          {28, NULL},\n          {30, 30},\n        });\n  }\n\n  /** Throws an assertion unless the paired iterator contains the same values as the argument array. */\n  public static void compareOrderedPairIterator(OrderedPairIterator<Integer> opi, int[][] ints) {\n    int pairno = 0;\n    while (opi.hasNext()) {\n      Pair</*@Nullable*/ Integer, /*@Nullable*/ Integer> pair = opi.next();\n      // System.out.println(\"Iterator: <\" + pair.a + \",\" + pair.b + \">, array: <\" + ints[pairno][0] + \",\" + ints[pairno][1] + \">\");\n      assert (pair.a == null) || (pair.a.intValue() == ints[pairno][0]);\n      assert (pair.b == null) || (pair.b.intValue() == ints[pairno][1]);\n      pairno++;\n    }\n    assert pairno == ints.length;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// TimeLimitProcess\n  ///\n\n  /**\n   * Print one integer periodically.\n   * <p>\n   * Example use from the command line, for one integer each half-second:\n   * <pre>  java plume.TestPlume\\$PrintOneIntPerSecond 500</pre>\n   */\n  public static class PrintOneIntPerTimePeriod {\n    /**\n     * @param args  two-element array containing:  how many to print; how many milliseconds between each\n     */\n    public static void main(String[] args) {\n      if (args.length != 2) {\n        System.err.println(\"Needs 2 arguments, got \" + args.length);\n      }\n      int limit = Integer.parseInt(args[0]);\n      int period = Integer.parseInt(args[1]);\n      for (int i = 0; i < limit; i++) {\n        System.out.printf(\"out%d \", i);\n        System.err.printf(\"err%d \", i);\n        try {\n          Thread.sleep(period);\n        } catch (InterruptedException e) {\n          // We don't care if this is interrupted\n        }\n      }\n    }\n  }\n\n  private static Runtime runtime = java.lang.Runtime.getRuntime();\n\n  // timePerNumber needs to be small so tests run fast, but large so that\n  // more output doesn't sneak out before the timeout kicks in.\n  private static Triple<Integer, String, String> printFive(\n      int timePerNumber, int timeLimit, boolean cache_stdout) {\n    String command = \"java plume.TestPlume$PrintOneIntPerTimePeriod 5 \" + timePerNumber;\n    TimeLimitProcess p;\n    try {\n      p = new TimeLimitProcess(runtime.exec(command), timeLimit, cache_stdout);\n    } catch (IOException e) {\n      throw new Error(e);\n    }\n    int result;\n    try {\n      result = p.waitFor();\n    } catch (InterruptedException e) {\n      throw new Error(e);\n    }\n    // System.out.printf(\"command:%s%n\", command);\n    // System.out.printf(\"result:%s%n\", result);\n    // System.out.printf(\"buffered stdout:%s%n\", p.cached_stdout);\n    // System.out.printf(\"buffered stderr:%s%n\", p.cached_stderr);\n    String out = UtilMDE.streamString(p.getInputStream());\n    String err = UtilMDE.streamString(p.getErrorStream());\n    // System.out.printf(\"out:%s%n\", out);\n    // System.out.printf(\"err:%s%n\", err);\n    return Triple.of(result, out, err);\n  }\n\n  private static void checkPrintFive(\n      int timePerNumber, int timeLimit, boolean cache_stdout, String out, String err) {\n    Triple<Integer, String, String> results = printFive(timePerNumber, timeLimit, cache_stdout);\n    if (!results.b.equals(out)) {\n      throw new Error(String.format(\"Expected %s, got %s\", out, results.b));\n    }\n    if (!results.c.equals(err)) {\n      throw new Error(String.format(\"Expected %s, got %s\", err, results.c));\n    }\n  }\n\n  /**\n   * On a heavily-loaded machine, this test fails.\n   * Try again when the load is lower.\n   * (Better might be exponential backoff up to some limit.)\n   */\n  @Test\n  public void testTimeLimitProcess() {\n    // checkPrintFive(10, 1000, false, \"out0 out1 out2 out3 out4 \", \"err0 err1 err2 err3 err4 \");\n    // checkPrintFive(10, 1000, true, \"out0 out1 out2 out3 out4 \", \"err0 err1 err2 err3 err4 \");\n\n    // These are too timing-dependent -- they sometimes succeed and\n    // sometimes fail -- so leave them commented out.\n    // checkPrintFive(2000, 1000, true, \"out0 \", \"err0 \");\n    // checkPrintFive(2000, 3000, true, \"out0 out1 \", \"err0 err1 \");\n\n    // This is expected to fail because of trying to read a closed stream.\n    // printFive(3, false);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// UtilMDE\n  ///\n\n  private static BitSet randomBitSet(int length, Random r) {\n    BitSet result = new BitSet(length);\n    for (int i = 0; i < length; i++) {\n      result.set(i, r.nextBoolean());\n    }\n    return result;\n  }\n\n  @Test\n  public void testStringBuilderDelimited() {\n    compareJoinAndSBD(new String[] {\"foo\", \"bar\", \"baz\"});\n    compareJoinAndSBD(new String[] {\"foo\"});\n    compareJoinAndSBD(new String[] {});\n  }\n\n  public void compareJoinAndSBD(String[] strings) {\n    StringBuilderDelimited sbd = new StringBuilderDelimited(\",\");\n    for (String str : strings) {\n      sbd.append(str);\n    }\n    assert sbd.toString().equals(UtilMDE.join(strings, \",\"));\n  }\n\n  private static void checkTypeStrings(\n      /*@FullyQualifiedName*/ String fqn,\n      /*@BinaryName*/ String bn,\n      /*@ClassGetName*/ String cgn,\n      /*@FieldDescriptor*/ String fd) {\n    checkTypeStrings(fqn, bn, cgn, fd, false);\n  }\n\n  private static void checkTypeStrings(\n      /*@FullyQualifiedName*/ String fqn,\n      /*@BinaryName*/ String bn,\n      /*@ClassGetName*/ String cgn,\n      /*@FieldDescriptor*/ String fd,\n      boolean skipClassForName) {\n    if (!skipClassForName) {\n      try {\n        UtilMDE.classForName(cgn); // ensure this does not crash\n      } catch (ClassNotFoundException e) {\n        throw new Error(e);\n      }\n    }\n    assert fd.equals(UtilMDE.binaryNameToFieldDescriptor(bn));\n    assert cgn.equals(UtilMDE.binaryNameToClassGetName(bn))\n        : bn + \" => \" + UtilMDE.binaryNameToClassGetName(bn) + \", should be \" + cgn;\n    assert cgn.equals(UtilMDE.fieldDescriptorToClassGetName(fd)) : fd + \" => \" + cgn;\n    assert bn.equals(UtilMDE.fieldDescriptorToBinaryName(fd));\n  }\n\n  // This cannot be static because it instantiates an inner class.\n  @Test\n  public void testUtilMDE() {\n\n    // public static intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)\n    {\n      Random r = new Random(20031008);\n      for (int i = 0; i < 100; i++) {\n        BitSet b1 = randomBitSet(r.nextInt(100), r);\n        BitSet b2 = randomBitSet(r.nextInt(100), r);\n        BitSet b3 = randomBitSet(r.nextInt(100), r);\n        BitSet intersection = (BitSet) b1.clone();\n        intersection.and(b2);\n        int card = intersection.cardinality();\n        for (int j = 0; j < 100; j++) {\n          assert UtilMDE.intersectionCardinalityAtLeast(b1, b2, j) == (card >= j);\n        }\n        intersection.and(b3);\n        card = intersection.cardinality();\n        for (int j = 0; j < 100; j++) {\n          assert UtilMDE.intersectionCardinalityAtLeast(b1, b2, b3, j) == (card >= j);\n        }\n      }\n    }\n\n    // public static BufferedReader bufferedFileReader(String filename)\n    // public static LineNumberReader lineNumberFileReader(String filename)\n    // public static BufferedWriter bufferedFileWriter(String filename) throws IOException\n    // public static Class classForName(String className)\n\n    // private boolean isSubtype(Class<?> sub, Class<?> sup) {\n    assert UtilMDE.isSubtype(Integer.class, Integer.class);\n    assert UtilMDE.isSubtype(Cloneable.class, Cloneable.class);\n    assert UtilMDE.isSubtype(Object.class, Object.class);\n    assert UtilMDE.isSubtype(Integer.class, Number.class);\n    assert !UtilMDE.isSubtype(Number.class, Integer.class);\n    assert UtilMDE.isSubtype(Integer.class, Comparable.class);\n    assert !UtilMDE.isSubtype(Comparable.class, Integer.class);\n    assert UtilMDE.isSubtype(Integer.class, Object.class);\n    assert !UtilMDE.isSubtype(Object.class, Integer.class);\n    assert !UtilMDE.isSubtype(Integer.class, Float.class);\n    assert UtilMDE.isSubtype(Collection.class, Iterable.class);\n    assert !UtilMDE.isSubtype(Iterable.class, Collection.class);\n    assert UtilMDE.isSubtype(ArrayList.class, Iterable.class);\n    assert !UtilMDE.isSubtype(Iterable.class, ArrayList.class);\n    assert UtilMDE.isSubtype(ArrayList.class, Cloneable.class);\n    assert !UtilMDE.isSubtype(Cloneable.class, ArrayList.class);\n    assert UtilMDE.isSubtype(ArrayList.class, List.class);\n    assert !UtilMDE.isSubtype(List.class, ArrayList.class);\n\n    // public static String binaryNameToFieldDescriptor(String classname)\n    assert UtilMDE.binaryNameToFieldDescriptor(\"boolean\").equals(\"Z\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"byte\").equals(\"B\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"char\").equals(\"C\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"double\").equals(\"D\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"float\").equals(\"F\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"int\").equals(\"I\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"long\").equals(\"J\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"short\").equals(\"S\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"Integer\").equals(\"LInteger;\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"Java.lang.Integer\").equals(\"LJava/lang/Integer;\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"int[][]\").equals(\"[[I\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"Java.lang.Integer[][][]\")\n        .equals(\"[[[LJava/lang/Integer;\");\n\n    // public static /*@ClassGetName*/ String binaryNameToClassGetName(/*BinaryName*/ String bn)\n    assert UtilMDE.binaryNameToClassGetName(\"boolean\").equals(\"boolean\");\n    assert UtilMDE.binaryNameToClassGetName(\"byte\").equals(\"byte\");\n    assert UtilMDE.binaryNameToClassGetName(\"char\").equals(\"char\");\n    assert UtilMDE.binaryNameToClassGetName(\"double\").equals(\"double\");\n    assert UtilMDE.binaryNameToClassGetName(\"float\").equals(\"float\");\n    assert UtilMDE.binaryNameToClassGetName(\"int\").equals(\"int\");\n    assert UtilMDE.binaryNameToClassGetName(\"long\").equals(\"long\");\n    assert UtilMDE.binaryNameToClassGetName(\"short\").equals(\"short\");\n    assert UtilMDE.binaryNameToClassGetName(\"Integer\").equals(\"Integer\");\n    assert UtilMDE.binaryNameToClassGetName(\"Java.lang.Integer\").equals(\"Java.lang.Integer\");\n    assert UtilMDE.binaryNameToClassGetName(\"int[][]\").equals(\"[[I\");\n    assert UtilMDE.binaryNameToClassGetName(\"Java.lang.Integer[][][]\")\n        .equals(\"[[[LJava.lang.Integer;\");\n\n    // public static String arglistToJvm(String arglist)\n    assert UtilMDE.arglistToJvm(\"()\").equals(\"()\");\n    assert UtilMDE.arglistToJvm(\"(int)\").equals(\"(I)\");\n    assert UtilMDE.arglistToJvm(\"(int, int)\").equals(\"(II)\");\n    assert UtilMDE.arglistToJvm(\"(int, long, short)\").equals(\"(IJS)\");\n    assert UtilMDE.arglistToJvm(\"(java.lang.Integer, int, java.lang.Integer)\")\n        .equals(\"(Ljava/lang/Integer;ILjava/lang/Integer;)\");\n    assert UtilMDE.arglistToJvm(\"(int[])\").equals(\"([I)\");\n    assert UtilMDE.arglistToJvm(\"(int[], int, int)\").equals(\"([III)\");\n    assert UtilMDE.arglistToJvm(\"(int, int[][], int)\").equals(\"(I[[II)\");\n    assert UtilMDE.arglistToJvm(\"(java.lang.Integer[], int, java.lang.Integer[][])\")\n        .equals(\"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\");\n\n    // public static String fieldDescriptorToBinaryName(String classname)\n    assert UtilMDE.fieldDescriptorToBinaryName(\"Z\").equals(\"boolean\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"B\").equals(\"byte\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"C\").equals(\"char\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"D\").equals(\"double\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"F\").equals(\"float\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"I\").equals(\"int\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"J\").equals(\"long\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"S\").equals(\"short\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"LInteger;\").equals(\"Integer\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"LJava/lang/Integer;\").equals(\"Java.lang.Integer\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"[[I\").equals(\"int[][]\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"[[LJava/lang/Integer;\")\n        .equals(\"Java.lang.Integer[][]\");\n\n    // public static /*@ClassGetName*/ String fieldDescriptorToClassGetName(/*FieldDescriptor*/ String fd)\n    assert UtilMDE.fieldDescriptorToClassGetName(\"Z\").equals(\"boolean\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"B\").equals(\"byte\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"C\").equals(\"char\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"D\").equals(\"double\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"F\").equals(\"float\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"I\").equals(\"int\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"J\").equals(\"long\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"S\").equals(\"short\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"LInteger;\").equals(\"Integer\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"LJava/lang/Integer;\").equals(\"Java.lang.Integer\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"[[I\").equals(\"[[I\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"[[LJava/lang/Integer;\")\n        .equals(\"[[LJava.lang.Integer;\");\n\n    // public static String arglistFromJvm(String arglist)\n    assert UtilMDE.arglistFromJvm(\"()\").equals(\"()\");\n    assert UtilMDE.arglistFromJvm(\"(I)\").equals(\"(int)\");\n    assert UtilMDE.arglistFromJvm(\"(II)\").equals(\"(int, int)\");\n    assert UtilMDE.arglistFromJvm(\"(IJS)\").equals(\"(int, long, short)\");\n    assert UtilMDE.arglistFromJvm(\"(Ljava/lang/Integer;ILjava/lang/Integer;)\")\n        .equals(\"(java.lang.Integer, int, java.lang.Integer)\");\n    assert UtilMDE.arglistFromJvm(\"([I)\").equals(\"(int[])\");\n    assert UtilMDE.arglistFromJvm(\"([III)\").equals(\"(int[], int, int)\");\n    assert UtilMDE.arglistFromJvm(\"(I[[II)\").equals(\"(int, int[][], int)\");\n    assert UtilMDE.arglistFromJvm(\"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\")\n        .equals(\"(java.lang.Integer[], int, java.lang.Integer[][])\");\n\n    // More tests for type representation conversions.\n    // Table from Signature Checker manual.\n    checkTypeStrings(\"int\", \"int\", \"int\", \"I\");\n    checkTypeStrings(\"int[][]\", \"int[][]\", \"[[I\", \"[[I\");\n    checkTypeStrings(\"MyClass\", \"MyClass\", \"MyClass\", \"LMyClass;\", true);\n    checkTypeStrings(\"MyClass[]\", \"MyClass[]\", \"[LMyClass;\", \"[LMyClass;\", true);\n    checkTypeStrings(\n        \"java.lang.Integer\", \"java.lang.Integer\", \"java.lang.Integer\", \"Ljava/lang/Integer;\");\n    checkTypeStrings(\n        \"java.lang.Integer[]\",\n        \"java.lang.Integer[]\",\n        \"[Ljava.lang.Integer;\",\n        \"[Ljava/lang/Integer;\");\n    checkTypeStrings(\n        \"java.lang.Byte.ByteCache\",\n        \"java.lang.Byte$ByteCache\",\n        \"java.lang.Byte$ByteCache\",\n        \"Ljava/lang/Byte$ByteCache;\");\n    checkTypeStrings(\n        \"java.lang.Byte.ByteCache[]\",\n        \"java.lang.Byte$ByteCache[]\",\n        \"[Ljava.lang.Byte$ByteCache;\",\n        \"[Ljava/lang/Byte$ByteCache;\");\n\n    // public static void addToClasspath(String dir)\n    // public static final class WildcardFilter implements FilenameFilter\n    //   public WildcardFilter(String filename)\n    //   public boolean accept(File dir, String name)\n    // public static boolean canCreateAndWrite(File file)\n    // public static void writeObject(Object o, File file) throws IOException\n    // public static Object readObject(File file)\n    // public static File createTempDir(String prefix, String suffix)\n\n    // public Object incrementHashMap(HashMap hm, Object key, int count)\n\n    try {\n      assert UtilMDE.canCreateAndWrite(new File(\"TestPlume.java\"));\n\n      // This test fails if run by the superuser (who can overwrite\n      // any file).\n      if (!System.getProperty(\"user.name\").equals(\"root\")) {\n        File readOnly = new File(\"temp\");\n        readOnly.createNewFile();\n        readOnly.setReadOnly();\n        assert !UtilMDE.canCreateAndWrite(readOnly);\n        readOnly.delete();\n      }\n\n      assert UtilMDE.canCreateAndWrite(new File(\"temp\"));\n      assert !UtilMDE.canCreateAndWrite(new File(\"temp/temp\"));\n    } catch (IOException e) {\n      e.printStackTrace();\n      org.junit.Assert.fail(\"failure while testing UtilMDE.canCreateAndWrite(): \" + e.toString());\n    }\n\n    {\n      // These names are taken from APL notation, where iota creates an\n      // array of all the numbers up to its argument.\n      Vector<Integer> iota0 = new Vector<Integer>();\n      Vector<Integer> iota10 = new Vector<Integer>();\n      for (int i = 0; i < 10; i++) {\n        iota10.add(new Integer(i));\n      }\n      Vector<Integer> iota10_twice = new Vector<Integer>();\n      iota10_twice.addAll(iota10);\n      iota10_twice.addAll(iota10);\n      Vector<Integer> iota10_thrice = new Vector<Integer>();\n      iota10_thrice.addAll(iota10);\n      iota10_thrice.addAll(iota10);\n      iota10_thrice.addAll(iota10);\n\n      // public static class EnumerationIterator implements Iterator\n      // public static class IteratorEnumeration implements Enumeration\n\n      assert iota0.equals(toVector(iota0.iterator()));\n      assert iota0.equals(toVector(new UtilMDE.IteratorEnumeration<Integer>(iota0.iterator())));\n      assert iota0.equals(toVector(iota0.elements()));\n      assert iota0.equals(toVector(new UtilMDE.EnumerationIterator<Integer>(iota0.elements())));\n      assert iota10.equals(toVector(iota10.iterator()));\n      assert iota10.equals(toVector(new UtilMDE.IteratorEnumeration<Integer>(iota10.iterator())));\n      assert iota10.equals(toVector(iota10.elements()));\n      assert iota10.equals(toVector(new UtilMDE.EnumerationIterator<Integer>(iota10.elements())));\n\n      // public static class MergedIterator2 implements Iterator {\n      assert iota10_twice.equals(\n          toVector(new UtilMDE.MergedIterator2<Integer>(iota10.iterator(), iota10.iterator())));\n      assert iota10.equals(\n          toVector(new UtilMDE.MergedIterator2<Integer>(iota0.iterator(), iota10.iterator())));\n      assert iota10.equals(\n          toVector(new UtilMDE.MergedIterator2<Integer>(iota10.iterator(), iota0.iterator())));\n\n      // public static class MergedIterator implements Iterator {\n      Vector<Iterator<Integer>> iota10_iterator_thrice = new Vector<Iterator<Integer>>();\n      iota10_iterator_thrice.add(iota10.iterator());\n      iota10_iterator_thrice.add(iota10.iterator());\n      iota10_iterator_thrice.add(iota10.iterator());\n      assert iota10_thrice.equals(\n          toVector(new UtilMDE.MergedIterator<Integer>(iota10_iterator_thrice.iterator())));\n      Vector<Iterator<Integer>> iota10_iterator_twice_1 = new Vector<Iterator<Integer>>();\n      iota10_iterator_twice_1.add(iota0.iterator());\n      iota10_iterator_twice_1.add(iota10.iterator());\n      iota10_iterator_twice_1.add(iota10.iterator());\n      Vector<Iterator<Integer>> iota10_iterator_twice_2 = new Vector<Iterator<Integer>>();\n      iota10_iterator_twice_2.add(iota10.iterator());\n      iota10_iterator_twice_2.add(iota0.iterator());\n      iota10_iterator_twice_2.add(iota10.iterator());\n      Vector<Iterator<Integer>> iota10_iterator_twice_3 = new Vector<Iterator<Integer>>();\n      iota10_iterator_twice_3.add(iota10.iterator());\n      iota10_iterator_twice_3.add(iota10.iterator());\n      iota10_iterator_twice_3.add(iota0.iterator());\n      assert iota10_twice.equals(\n          toVector(new UtilMDE.MergedIterator<Integer>(iota10_iterator_twice_1.iterator())));\n      assert iota10_twice.equals(\n          toVector(new UtilMDE.MergedIterator<Integer>(iota10_iterator_twice_2.iterator())));\n      assert iota10_twice.equals(\n          toVector(new UtilMDE.MergedIterator<Integer>(iota10_iterator_twice_3.iterator())));\n\n      class OddFilter implements Filter<Integer> {\n        public OddFilter() {}\n\n        public boolean accept(Integer i) {\n          return i.intValue() % 2 != 0;\n        }\n      }\n\n      // public static final class FilteredIterator implements Iterator\n\n      Vector<Integer> iota10_odd = new Vector<Integer>();\n      for (int i = 0; i < iota10.size(); i++) {\n        if (i % 2 != 0) {\n          iota10_odd.add(new Integer(i));\n        }\n      }\n      assert iota10_odd.equals(\n          toVector(new UtilMDE.FilteredIterator<Integer>(iota10.iterator(), new OddFilter())));\n    }\n\n    // public static final class RemoveFirstAndLastIterator implements Iterator\n    {\n      Vector<Integer> iota5 = new Vector<Integer>();\n      for (int i = 0; i < 5; i++) {\n        iota5.add(new Integer(i));\n      }\n      Vector<Integer> iota5middle = new Vector<Integer>();\n      for (int i = 1; i < 4; i++) {\n        iota5middle.add(new Integer(i));\n      }\n      UtilMDE.RemoveFirstAndLastIterator<Integer> rfali =\n          new UtilMDE.RemoveFirstAndLastIterator<Integer>(iota5.iterator());\n      Vector<Integer> rfali_vector = toVector(rfali);\n      assert iota5middle.equals(rfali_vector);\n      assert rfali.getFirst().equals(new Integer(0));\n      assert rfali.getLast().equals(new Integer(4));\n    }\n\n    // public static ArrayList randomElements(Iterator itor, int num_elts)\n    // public static ArrayList randomElements(Iterator itor, int num_elts, Random random)\n\n    // Iterate through numbers from zero up to the argument (non-inclusive)\n    class IotaIterator implements Iterator<Integer> {\n      int i = 0;\n      int limit;\n\n      public IotaIterator(int limit) {\n        this.limit = limit;\n      }\n\n      @Override\n      public boolean hasNext() {\n        return i < limit;\n      }\n\n      @Override\n      public Integer next() {\n        if (!hasNext()) {\n          throw new NoSuchElementException();\n        }\n        return new Integer(i++);\n      }\n\n      @Override\n      public void remove() {\n        throw new UnsupportedOperationException();\n      }\n    }\n    {\n      // Typically, no progress reports are printed, because the loop\n      // finishes in well under 1 minute.  Users will see progress reports\n      // when this class is slowed down by instrumentation.\n      Calendar nextNotification = Calendar.getInstance();\n      nextNotification.add(Calendar.MINUTE, 1);\n      DateFormat df = new SimpleDateFormat();\n\n      int itor_size = 10;\n      int num_elts_limit = 12;\n      int tries = short_run ? 100 : 100000;\n      double ratio_limit = .02;\n      Random r = new Random(20020311);\n      // \"i++\" instead of \"i+=3\" here works, but is slow\n      for (int i = 1; i < num_elts_limit; i += 3) {\n        int[] totals = new int[num_elts_limit];\n        for (int j = 0; j < tries; j++) {\n          if (j % 100 == 0) {\n            Calendar now = Calendar.getInstance();\n            if (now.after(nextNotification)) {\n              System.out.printf(\n                  \"%s: iteration (%d,%d) out of (%d,%d)%n\",\n                  df.format(nextNotification.getTime()),\n                  i,\n                  j,\n                  num_elts_limit,\n                  tries);\n              nextNotification.add(Calendar.MINUTE, 1);\n            }\n          }\n          List<Integer> chosen = UtilMDE.randomElements(new IotaIterator(itor_size), i, r);\n          for (int m = 0; m < chosen.size(); m++) {\n            for (int n = m + 1; n < chosen.size(); n++) {\n              if (chosen.get(m).intValue() == chosen.get(n).intValue()) {\n                throw new Error(\"Duplicate at \" + m + \",\" + n);\n              }\n            }\n          }\n          for (int k = 0; k < chosen.size(); k++) {\n            totals[chosen.get(k).intValue()]++;\n          }\n        }\n        int i_truncated = Math.min(itor_size, i);\n        int grand_total = tries * i_truncated;\n        assert ArraysMDE.sum(totals) == grand_total : \"Totals = \" + ArraysMDE.sum(totals);\n        // System.out.print(\"chosen:\\t\");\n        for (int k = 0; k < num_elts_limit; k++) {\n          int this_total = totals[k];\n          int expected = tries * i_truncated / itor_size;\n          double ratio = (double) this_total / (double) expected;\n          // System.out.print(((k<10) ? \" \" : \"\") + k + \" \" + this_total + \"\\t\");\n          // System.out.print(\"\\nExp=\" + expected + \"\\tratio=\" + ratio + \"\\t\");\n          assert k >= itor_size || (ratio > ratio_limit && ratio < 1 / ratio_limit);\n        }\n        // System.out.println();\n      }\n    }\n\n    // public static <T> /*@Nullable*/ Integer incrementMap(Map<T,Integer> m, T key, int count) {\n    // public static <K,V> String mapToString(Map<K,V> m) {\n    // public static <K,V> void mapToString(Appendable sb, Map<K,V> m, String linePrefix) {\n    // public static <K extends Comparable<? super K>,V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(Map<K,V> m) {\n    // public static <K,V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(Map<K,V> m, Comparator<K> comparator) {\n\n    // public static Method methodForName(String methodname) throws ClassNotFoundException\n    //\n    // essentially I am just testing whether the return is erroneous\n    try {\n      assert null\n          != UtilMDE.methodForName(\n              \"plume.UtilMDE.methodForName(java.lang.String, java.lang.String, java.lang.Class[])\");\n      assert null\n          != UtilMDE.methodForName(\n              \"plume.UtilMDE.methodForName(java.lang.String,java.lang.String,java.lang.Class[])\");\n      assert null != UtilMDE.methodForName(\"java.lang.Math.min(int,int)\");\n    } catch (Exception e) {\n      e.printStackTrace();\n      throw new Error(e);\n    }\n    try {\n      java.lang.reflect.Method m = UtilMDE.methodForName(\"plume.UtilMDE.methodForName()\");\n      throw new Error(\"Didn't throw NoSuchMethodException\");\n    } catch (NoSuchMethodException e) {\n      // nothing to do; this is the expected case\n    } catch (Exception e) {\n      e.printStackTrace();\n      throw new Error(e);\n    }\n\n    // public static boolean propertyIsTrue(Properties p, String key)\n    // public static String appendProperty(Properties p, String key, String value)\n    // public static String setDefault(Properties p, String key, String value)\n    // public static void streamCopy(java.io.InputStream from, java.io.OutputStream to)\n\n    // public static String replaceString(String target, String oldStr, String newStr)\n\n    assert UtilMDE.replaceString(\"hello dolly well hello dolly\", \" \", \"  \")\n        .equals(\"hello  dolly  well  hello  dolly\");\n    assert UtilMDE.replaceString(\"  hello  dolly well hello dolly  \", \" \", \"  \")\n        .equals(\"    hello    dolly  well  hello  dolly    \");\n    assert UtilMDE.replaceString(\"hello dolly well hello dolly\", \"ll\", \"y\")\n        .equals(\"heyo doyy wey heyo doyy\");\n    assert UtilMDE.replaceString(\"hello dolly well hello dolly\", \"q\", \"yyy\")\n        .equals(\"hello dolly well hello dolly\");\n\n    // public static String[] split(String s, char delim)\n    // public static String[] split(String s, String delim)\n\n    assert Arrays.equals(UtilMDE.split(\"foo,bar,baz\", ','), new String[] {\"foo\", \"bar\", \"baz\"});\n    assert Arrays.equals(UtilMDE.split(\"foo\", ','), new String[] {\"foo\"});\n    assert Arrays.equals(UtilMDE.split(\"\", ','), new String[] {\"\"});\n    assert Arrays.equals(UtilMDE.split(\",foo,\", ','), new String[] {\"\", \"foo\", \"\"});\n    assert Arrays.equals(UtilMDE.split(\"foo,bar,baz\", \",\"), new String[] {\"foo\", \"bar\", \"baz\"});\n    assert Arrays.equals(UtilMDE.split(\"foo\", \",\"), new String[] {\"foo\"});\n    assert Arrays.equals(UtilMDE.split(\"\", \",\"), new String[] {\"\"});\n    assert Arrays.equals(UtilMDE.split(\",foo,\", \",\"), new String[] {\"\", \"foo\", \"\"});\n    assert Arrays.equals(UtilMDE.split(\"foo, bar, baz\", \", \"), new String[] {\"foo\", \"bar\", \"baz\"});\n    assert Arrays.equals(UtilMDE.split(\"foo\", \", \"), new String[] {\"foo\"});\n    assert Arrays.equals(UtilMDE.split(\"\", \", \"), new String[] {\"\"});\n    assert Arrays.equals(UtilMDE.split(\", foo, \", \", \"), new String[] {\"\", \"foo\", \"\"});\n\n    // public static String join(Object[] a, String delim)\n    // public static String join(Vector v, String delim)\n\n    assert UtilMDE.join(new String[] {\"foo\", \"bar\", \"baz\"}, \", \").equals(\"foo, bar, baz\");\n    assert UtilMDE.join(new String[] {\"foo\"}, \", \").equals(\"foo\");\n    assert UtilMDE.join(new String[] {}, \", \").equals(\"\");\n    assert UtilMDE.join(\n            new Integer[] {\n              new Integer(0), new Integer(1), new Integer(2), new Integer(3), new Integer(4)\n            },\n            \"\")\n        .equals(\"01234\");\n    Vector<Object> potpourri = new Vector<Object>();\n    potpourri.add(\"day\");\n    potpourri.add(new Integer(2));\n    potpourri.add(\"day\");\n    assert UtilMDE.join(potpourri, \" \").equals(\"day 2 day\");\n\n    // public static String escapeNonJava(String orig)\n    // public static String escapeNonJava(Character ch)\n\n    assert UtilMDE.escapeNonJava(\"foobar\").equals(\"foobar\");\n    assert UtilMDE.escapeNonJava(\"\").equals(\"\");\n    assert UtilMDE.escapeNonJava(\"\\\\\").equals(\"\\\\\\\\\");\n    assert UtilMDE.escapeNonJava(\"\\\\\\n\\r\\\"\").equals(\"\\\\\\\\\\\\n\\\\r\\\\\\\"\");\n    assert UtilMDE.escapeNonJava(\"split\\nlines\").equals(\"split\\\\nlines\");\n    assert UtilMDE.escapeNonJava(\"\\\\relax\").equals(\"\\\\\\\\relax\");\n    assert UtilMDE.escapeNonJava(\"\\\"hello\\\"\").equals(\"\\\\\\\"hello\\\\\\\"\");\n    assert UtilMDE.escapeNonJava(\"\\\"hello\\\" \\\"world\\\"\").equals(\"\\\\\\\"hello\\\\\\\" \\\\\\\"world\\\\\\\"\");\n\n    // public static String escapeNonASCII(String orig)\n\n    assert UtilMDE.escapeNonASCII(\"foobar\").equals(\"foobar\");\n    assert UtilMDE.escapeNonASCII(\"\").equals(\"\");\n    assert UtilMDE.escapeNonASCII(\"\\\\\").equals(\"\\\\\\\\\");\n    assert UtilMDE.escapeNonASCII(\"\\\\\\n\\r\\\"\").equals(\"\\\\\\\\\\\\n\\\\r\\\\\\\"\");\n    assert UtilMDE.escapeNonASCII(\"split\\nlines\").equals(\"split\\\\nlines\");\n    assert UtilMDE.escapeNonASCII(\"\\\\relax\").equals(\"\\\\\\\\relax\");\n    assert UtilMDE.escapeNonASCII(\"\\\"hello\\\"\").equals(\"\\\\\\\"hello\\\\\\\"\");\n    assert UtilMDE.escapeNonASCII(\"\\\"hello\\\" \\\"world\\\"\").equals(\"\\\\\\\"hello\\\\\\\" \\\\\\\"world\\\\\\\"\");\n    assert UtilMDE.escapeNonASCII(\"\\0\\1\\2\\7\\12\\70\\100\\111\\222\")\n        .equals(\"\\\\000\\\\001\\\\002\\\\007\\\\n8@I\\\\222\");\n    assert UtilMDE.escapeNonASCII(\"\\u0100\\u1000\\ucafe\\uffff\")\n        .equals(\"\\\\u0100\\\\u1000\\\\ucafe\\\\uffff\");\n\n    // private static String escapeNonASCII(char c)\n\n    // public static String unescapeNonJava(String orig)\n\n    assert UtilMDE.unescapeNonJava(\"foobar\").equals(\"foobar\");\n    assert UtilMDE.unescapeNonJava(\"\").equals(\"\");\n    assert UtilMDE.unescapeNonJava(\"\\\\\\\\\").equals(\"\\\\\");\n    assert UtilMDE.unescapeNonJava(\"\\\\\\\"\").equals(\"\\\"\");\n    assert UtilMDE.unescapeNonJava(\"\\\\n\").equals(\"\\n\"); // not lineSep\n    assert UtilMDE.unescapeNonJava(\"\\\\r\").equals(\"\\r\");\n    assert UtilMDE.unescapeNonJava(\"split\\\\nlines\").equals(\"split\\nlines\");\n    assert UtilMDE.unescapeNonJava(\"\\\\\\\\\\\\n\").equals(\"\\\\\\n\"); // not lineSep\n    assert UtilMDE.unescapeNonJava(\"\\\\n\\\\r\").equals(\"\\n\\r\"); // not lineSep\n    assert UtilMDE.unescapeNonJava(\"\\\\\\\\\\\\n\\\\r\\\\\\\"\").equals(\"\\\\\\n\\r\\\"\");\n    assert UtilMDE.unescapeNonJava(\"\\\\\\\\relax\").equals(\"\\\\relax\");\n    assert UtilMDE.unescapeNonJava(\"\\\\\\\"hello\\\\\\\"\").equals(\"\\\"hello\\\"\");\n    assert UtilMDE.unescapeNonJava(\"\\\\\\\"hello\\\\\\\" \\\\\\\"world\\\\\\\"\").equals(\"\\\"hello\\\" \\\"world\\\"\");\n    assert UtilMDE.unescapeNonJava(\"\\\\\").equals(\"\\\\\");\n    assert UtilMDE.unescapeNonJava(\"foo\\\\\").equals(\"foo\\\\\");\n    assert UtilMDE.unescapeNonJava(\"\\\\*abc\").equals(\"*abc\");\n    // Should add more tests here.\n\n    // Unfortunately, there isn't yet a unescapeNonASCII function.\n    // If implemented, it should have the following behavior:\n    // assert UtilMDE.unescapeNonASCII(\"\\\\115\").equals(\"M\");\n    // assert UtilMDE.unescapeNonASCII(\"\\\\115\\\\111\\\\124\").equals(\"MIT\");\n\n    // public static String removeWhitespaceAround(String arg, String delimiter)\n    // public static String removeWhitespaceAfter(String arg, String delimiter)\n    // public static String removeWhitespaceBefore(String arg, String delimiter)\n\n    assert UtilMDE.removeWhitespaceBefore(\"a,b\", \",\").equals(\"a,b\");\n    assert UtilMDE.removeWhitespaceBefore(\"a, b\", \",\").equals(\"a, b\");\n    assert UtilMDE.removeWhitespaceBefore(\"a ,b\", \",\").equals(\"a,b\");\n    assert UtilMDE.removeWhitespaceBefore(\"a , b\", \",\").equals(\"a, b\");\n    assert UtilMDE.removeWhitespaceBefore(\"ab=>cd\", \"=>\").equals(\"ab=>cd\");\n    assert UtilMDE.removeWhitespaceBefore(\"ab=> cd\", \"=>\").equals(\"ab=> cd\");\n    assert UtilMDE.removeWhitespaceBefore(\"ab =>cd\", \"=>\").equals(\"ab=>cd\");\n    assert UtilMDE.removeWhitespaceBefore(\"ab => cd\", \"=>\").equals(\"ab=> cd\");\n    assert UtilMDE.removeWhitespaceBefore(\"123cd\", \"123\").equals(\"123cd\");\n    assert UtilMDE.removeWhitespaceBefore(\" 123 cd\", \"123\").equals(\"123 cd\");\n    assert UtilMDE.removeWhitespaceBefore(\" 123cd\", \"123\").equals(\"123cd\");\n    assert UtilMDE.removeWhitespaceBefore(\"123 cd\", \"123\").equals(\"123 cd\");\n    assert UtilMDE.removeWhitespaceBefore(\"cd123\", \"123\").equals(\"cd123\");\n    assert UtilMDE.removeWhitespaceBefore(\"cd 123 \", \"123\").equals(\"cd123 \");\n    assert UtilMDE.removeWhitespaceBefore(\"cd123 \", \"123\").equals(\"cd123 \");\n    assert UtilMDE.removeWhitespaceBefore(\"cd 123\", \"123\").equals(\"cd123\");\n\n    assert UtilMDE.removeWhitespaceAfter(\"a,b\", \",\").equals(\"a,b\");\n    assert UtilMDE.removeWhitespaceAfter(\"a, b\", \",\").equals(\"a,b\");\n    assert UtilMDE.removeWhitespaceAfter(\"a ,b\", \",\").equals(\"a ,b\");\n    assert UtilMDE.removeWhitespaceAfter(\"a , b\", \",\").equals(\"a ,b\");\n    assert UtilMDE.removeWhitespaceAfter(\"ab=>cd\", \"=>\").equals(\"ab=>cd\");\n    assert UtilMDE.removeWhitespaceAfter(\"ab=> cd\", \"=>\").equals(\"ab=>cd\");\n    assert UtilMDE.removeWhitespaceAfter(\"ab =>cd\", \"=>\").equals(\"ab =>cd\");\n    assert UtilMDE.removeWhitespaceAfter(\"ab => cd\", \"=>\").equals(\"ab =>cd\");\n    assert UtilMDE.removeWhitespaceAfter(\"123cd\", \"123\").equals(\"123cd\");\n    assert UtilMDE.removeWhitespaceAfter(\" 123 cd\", \"123\").equals(\" 123cd\");\n    assert UtilMDE.removeWhitespaceAfter(\" 123cd\", \"123\").equals(\" 123cd\");\n    assert UtilMDE.removeWhitespaceAfter(\"123 cd\", \"123\").equals(\"123cd\");\n    assert UtilMDE.removeWhitespaceAfter(\"cd123\", \"123\").equals(\"cd123\");\n    assert UtilMDE.removeWhitespaceAfter(\"cd 123 \", \"123\").equals(\"cd 123\");\n    assert UtilMDE.removeWhitespaceAfter(\"cd123 \", \"123\").equals(\"cd123\");\n    assert UtilMDE.removeWhitespaceAfter(\"cd 123\", \"123\").equals(\"cd 123\");\n\n    assert UtilMDE.removeWhitespaceAround(\"a,b\", \",\").equals(\"a,b\");\n    assert UtilMDE.removeWhitespaceAround(\"a, b\", \",\").equals(\"a,b\");\n    assert UtilMDE.removeWhitespaceAround(\"a ,b\", \",\").equals(\"a,b\");\n    assert UtilMDE.removeWhitespaceAround(\"a , b\", \",\").equals(\"a,b\");\n    assert UtilMDE.removeWhitespaceAround(\"ab=>cd\", \"=>\").equals(\"ab=>cd\");\n    assert UtilMDE.removeWhitespaceAround(\"ab=> cd\", \"=>\").equals(\"ab=>cd\");\n    assert UtilMDE.removeWhitespaceAround(\"ab =>cd\", \"=>\").equals(\"ab=>cd\");\n    assert UtilMDE.removeWhitespaceAround(\"ab => cd\", \"=>\").equals(\"ab=>cd\");\n    assert UtilMDE.removeWhitespaceAround(\"123cd\", \"123\").equals(\"123cd\");\n    assert UtilMDE.removeWhitespaceAround(\" 123 cd\", \"123\").equals(\"123cd\");\n    assert UtilMDE.removeWhitespaceAround(\" 123cd\", \"123\").equals(\"123cd\");\n    assert UtilMDE.removeWhitespaceAround(\"123 cd\", \"123\").equals(\"123cd\");\n    assert UtilMDE.removeWhitespaceAround(\"cd123\", \"123\").equals(\"cd123\");\n    assert UtilMDE.removeWhitespaceAround(\"cd 123 \", \"123\").equals(\"cd123\");\n    assert UtilMDE.removeWhitespaceAround(\"cd123 \", \"123\").equals(\"cd123\");\n    assert UtilMDE.removeWhitespaceAround(\"cd 123\", \"123\").equals(\"cd123\");\n\n    // public static String nplural(int n, String noun)\n\n    assert UtilMDE.nplural(0, \"fuss\").equals(\"0 fusses\");\n    assert UtilMDE.nplural(1, \"fuss\").equals(\"1 fuss\");\n    assert UtilMDE.nplural(2, \"fuss\").equals(\"2 fusses\");\n    assert UtilMDE.nplural(0, \"fox\").equals(\"0 foxes\");\n    assert UtilMDE.nplural(1, \"fox\").equals(\"1 fox\");\n    assert UtilMDE.nplural(2, \"fox\").equals(\"2 foxes\");\n    assert UtilMDE.nplural(0, \"fish\").equals(\"0 fishes\");\n    assert UtilMDE.nplural(1, \"fish\").equals(\"1 fish\");\n    assert UtilMDE.nplural(2, \"fish\").equals(\"2 fishes\");\n    assert UtilMDE.nplural(0, \"fletch\").equals(\"0 fletches\");\n    assert UtilMDE.nplural(1, \"fletch\").equals(\"1 fletch\");\n    assert UtilMDE.nplural(2, \"fletch\").equals(\"2 fletches\");\n    assert UtilMDE.nplural(0, \"fund\").equals(\"0 funds\");\n    assert UtilMDE.nplural(1, \"fund\").equals(\"1 fund\");\n    assert UtilMDE.nplural(2, \"fund\").equals(\"2 funds\");\n    assert UtilMDE.nplural(0, \"f-stop\").equals(\"0 f-stops\");\n    assert UtilMDE.nplural(1, \"f-stop\").equals(\"1 f-stop\");\n    assert UtilMDE.nplural(2, \"f-stop\").equals(\"2 f-stops\");\n\n    // public static String rpad(String s, int length)\n    // public static String rpad(int num, int length)\n    // public static String rpad(double num, int length)\n\n    assert UtilMDE.rpad(\"\", 5).equals(\"     \");\n    assert UtilMDE.rpad(\"abcd\", 5).equals(\"abcd \");\n    assert UtilMDE.rpad(\"abcde\", 5).equals(\"abcde\");\n    assert UtilMDE.rpad(\"abcdef\", 5).equals(\"abcde\");\n    assert UtilMDE.rpad(\"abcde ghij\", 5).equals(\"abcde\");\n    assert UtilMDE.rpad(10, 5).equals(\"10   \");\n    assert UtilMDE.rpad(3.14, 5).equals(\"3.14 \");\n\n    // public static class NullableStringComparator\n    //   public int compare(Object o1, Object o2)\n\n    // public static int count(String s, int ch)\n    // public static int count(String s, String sub)\n\n    assert UtilMDE.count(\"abcde\", 'a') == 1;\n    assert UtilMDE.count(\"abcde\", 'c') == 1;\n    assert UtilMDE.count(\"abcde\", 'e') == 1;\n    assert UtilMDE.count(\"abcde\", 'z') == 0;\n    assert UtilMDE.count(\"abacadaea\", 'a') == 5;\n    assert UtilMDE.count(\"aaa aea\", 'a') == 5;\n    assert UtilMDE.count(\"daeaaa\", 'a') == 4;\n\n    // This will be easy to write tests for, when I get around to it.\n    // public static Vector tokens(String str, String delim, boolean returnTokens)\n    // public static Vector tokens(String str, String delim)\n    // public static Vector tokens(String str)\n\n    // public static List sortList (List l, Comparator c)\n    // public static <T> List<T> removeDuplicates(List<T> l) {\n\n    List<Integer> l123 = new ArrayList<Integer>();\n    l123.add(1);\n    l123.add(2);\n    l123.add(3);\n    List<Integer> l123123 = new ArrayList<Integer>();\n    l123123.add(1);\n    l123123.add(2);\n    l123123.add(3);\n    l123123.add(1);\n    l123123.add(2);\n    l123123.add(3);\n    List<Integer> l12223 = new ArrayList<Integer>();\n    l12223.add(1);\n    l12223.add(2);\n    l12223.add(2);\n    l12223.add(2);\n    l12223.add(3);\n    List<Integer> l1123 = new ArrayList<Integer>();\n    l1123.add(1);\n    l1123.add(1);\n    l1123.add(2);\n    l1123.add(3);\n    List<Integer> l1233 = new ArrayList<Integer>();\n    l1233.add(1);\n    l1233.add(1);\n    l1233.add(2);\n    l1233.add(3);\n\n    assert UtilMDE.removeDuplicates(l123).equals(l123);\n    assert UtilMDE.removeDuplicates(l123123).equals(l123);\n    assert UtilMDE.removeDuplicates(l12223).equals(l123);\n    assert UtilMDE.removeDuplicates(l1123).equals(l123);\n    assert UtilMDE.removeDuplicates(l1233).equals(l123);\n\n    // public boolean deepEquals(Object o1, Object o2)\n\n    boolean[] zatft1 = new boolean[] {true, false, true};\n    boolean[] zatft2 = new boolean[] {true, false, true};\n    boolean[] zatff = new boolean[] {true, false, false};\n    assert !zatft1.equals(zatft2);\n    assert UtilMDE.deepEquals(zatft1, zatft2);\n    assert !zatft1.equals(zatff);\n    assert !UtilMDE.deepEquals(zatft1, zatff);\n\n    List<Object> l1 = new ArrayList<Object>();\n    List<Object> l2 = new ArrayList<Object>();\n    List<Object> l3 = new ArrayList<Object>();\n    l1.add(l1);\n    l2.add(l2);\n    l3.add(l3);\n    l1.add(zatft1);\n    l2.add(zatft2);\n    l3.add(zatff);\n    // Don't test .equals because it suffers infinite recursion.\n    // assert ! l1.equals(l2);\n    // assert ! l1.equals(l3);\n    // assert ! l2.equals(l3);\n    assert UtilMDE.deepEquals(l1, l2);\n    assert !UtilMDE.deepEquals(l1, l3);\n    assert !UtilMDE.deepEquals(l2, l3);\n\n    // This is tested by the tokens methods.\n    // public static Vector makeVector(Enumeration e)\n\n    Locale.setDefault(Locale.US);\n    assert UtilMDE.abbreviateNumber(5).equals(\"5.00\");\n    assert UtilMDE.abbreviateNumber(5000).equals(\"5.00K\");\n    assert UtilMDE.abbreviateNumber(5000000).equals(\"5.00M\");\n    assert UtilMDE.abbreviateNumber(1000000000).equals(\"1.00G\");\n    assert UtilMDE.abbreviateNumber(1).equals(\"1.00\");\n    assert UtilMDE.abbreviateNumber(12).equals(\"12.0\");\n    assert UtilMDE.abbreviateNumber(123).equals(\"123\");\n    assert UtilMDE.abbreviateNumber(1234).equals(\"1.23K\");\n    assert UtilMDE.abbreviateNumber(12345).equals(\"12.3K\");\n    assert UtilMDE.abbreviateNumber(123456).equals(\"123K\");\n    assert UtilMDE.abbreviateNumber(1234567).equals(\"1.23M\");\n    assert UtilMDE.abbreviateNumber(12345678).equals(\"12.3M\");\n    assert UtilMDE.abbreviateNumber(123456789).equals(\"123M\");\n    assert UtilMDE.abbreviateNumber(1234567890).equals(\"1.23G\");\n    assert UtilMDE.abbreviateNumber(9).equals(\"9.00\");\n    assert UtilMDE.abbreviateNumber(98).equals(\"98.0\");\n    assert UtilMDE.abbreviateNumber(987).equals(\"987\");\n    assert UtilMDE.abbreviateNumber(9876).equals(\"9.88K\");\n    assert UtilMDE.abbreviateNumber(98765).equals(\"98.8K\");\n    assert UtilMDE.abbreviateNumber(987654).equals(\"988K\");\n    assert UtilMDE.abbreviateNumber(9876543).equals(\"9.88M\");\n    assert UtilMDE.abbreviateNumber(98765432).equals(\"98.8M\");\n    assert UtilMDE.abbreviateNumber(987654321).equals(\"988M\");\n    assert UtilMDE.abbreviateNumber(9876543210L).equals(\"9.88G\");\n  }\n\n  @Test\n  public void testTestUtilMDE() {\n    int[] a = new int[] {3, 4, 5};\n    assert_arrays_equals(int_iterator_array(int_array_iterator(a)), a);\n  }\n\n  @Test\n  public void testWeakHasherMap() {}\n\n  /**\n   * These tests could be much more thorough.  Basically all that is tested\n   * is that identity is used rather than a normal hash.  The tests will\n   * fail however, if WeakHashMap is swapped for WeakIdentityHashMap.\n   */\n  @Test\n  public void testWeakIdentityHashMap() {\n\n    String s1 = \"one\";\n    String s2 = \"two\";\n    String s3 = \"three\";\n\n    WeakIdentityHashMap<String, Integer> m = new WeakIdentityHashMap<String, Integer>();\n    // WeakHashMap<String,Integer> m = new WeakHashMap<String,Integer>();\n\n    m.put(s1, 1);\n    m.put(s2, 2);\n    m.put(s3, 3);\n\n    String s1a = new String(s1);\n    String s2a = new String(s2);\n    String s3a = new String(s3);\n\n    m.put(s1a, 1);\n    m.put(s2a, 2);\n    m.put(s3a, 3);\n\n    assert m.get(s1) == 1;\n    assert m.get(s2) == 2;\n    assert m.get(s3) == 3;\n    assert m.get(s1a) == 1;\n    assert m.get(s2a) == 2;\n    assert m.get(s3a) == 3;\n\n    m.remove(s1);\n    m.remove(s2);\n    m.remove(s3);\n    assert m.get(s1) == null;\n    assert m.get(s2) == null;\n    assert m.get(s3) == null;\n    assert m.get(s1a) == 1;\n    assert m.get(s2a) == 2;\n    assert m.get(s3a) == 3;\n  }\n\n  @Test\n  public void testClassFileVersion() {\n    // public static double [] versionNumbers(InputStream is)\n    assert ClassFileVersion.versionNumbers(new ByteArrayInputStream(new byte[0])) == null;\n  }\n\n  /**\n   * Tests whether CountingPrintWriter\n   * counts the bytes printed, written for\n   * different types (boolean, int, float etc.).\n   */\n  @Test\n  public void testCountingPrintWriter() {\n    CountingPrintWriter c1 = new CountingPrintWriter(new CharArrayWriter());\n    c1.print(\"a\");\n    assert c1.getNumberOfPrintedBytes() == 1;\n    c1.print(1);\n    assert c1.getNumberOfPrintedBytes() == 2;\n    c1.print(true);\n    assert c1.getNumberOfPrintedBytes() == 6;\n    c1.print(1.00);\n    assert c1.getNumberOfPrintedBytes() == 9;\n    c1.write(\"a\");\n    c1.write(\"-\");\n    assert c1.getNumberOfPrintedBytes() == 9;\n    assert c1.getNumberOfWrittenBytes() == 22;\n    assert c1.getNumberOfPrintedChars() == 9;\n    c1.println(\"a b\");\n    String lineSep = System.getProperty(\"line.separator\");\n    int ls_len = lineSep.length();\n    assert c1.getNumberOfPrintedBytes() == (12 + ls_len);\n    assert c1.getNumberOfWrittenBytes() == (28);\n    assert c1.getNumberOfPrintedChars() == (12 + ls_len);\n    c1.print((String) null);\n    c1.print((Object) null);\n    c1.println((String) null);\n    // need to add assertions about what got printed.\n  }\n\n  /**\n   * Test the intering of subsequences as triples of the original\n   * sequence, the start and the end indices.\n   */\n  @Test\n  public void testSequenceAndIndices() {\n    int[] a1 = Intern.intern(new int[] {1, 2, 3, 4, 5, 6, 7});\n    int[] a2 = Intern.intern(new int[] {1, 2, 3, 4, 5, 6, 7});\n    int[] a3 = Intern.intern(new int[] {2, 3, 4, 5, 6, 7});\n    int i = 2;\n    int j = 4;\n    int k = 5;\n\n    int[] s1 = Intern.internSubsequence(a1, i, j);\n    int[] s2 = Intern.internSubsequence(a2, i, j);\n    int[] s3 = Intern.internSubsequence(a1, j, k);\n    int[] s4 = Intern.internSubsequence(a1, j, k);\n    int[] s5 = Intern.internSubsequence(a3, j - 1, k - 1);\n\n    assert a1 == a2;\n    assert s1 == s2;\n    assert s3 == s4;\n    assert s3 == s5;\n    assert ArraysMDE.isSubarray(s1, ArraysMDE.subarray(a1, i, j - i), 0);\n    assert ArraysMDE.isSubarray(ArraysMDE.subarray(a1, i, j - i), s1, 0);\n\n    long[] l1 = Intern.intern(new long[] {1, 2, 3, 4, 5, 6});\n    assert l1 == Intern.internSubsequence(l1, 0, l1.length);\n  }\n\n  // To do\n  // @Test\n  // public static void testFileIOException() {\n  // }\n\n  /**\n   * Test the comparison, indexof, and set equivalence calls in fuzzy\n   * float.\n   */\n  @Test\n  public void testFuzzyFloat() {\n\n    FuzzyFloat ff = new FuzzyFloat(0.0001);\n    double offset = 0.00007;\n    double offhigh = 1 + offset;\n    double offlow = 1 - offset;\n    double offhigh2 = 1 + 2 * offset;\n    double offlow2 = 1 - 2 * offset;\n\n    //test equality for a variety of postive and negative numbers\n    for (double d = -20000; d < 20000; d += 1000.36) {\n      assert ff.eq(d, d * offhigh);\n      assert ff.eq(d, d * offlow);\n      assert !ff.eq(d, d * offhigh2);\n      assert !ff.eq(d, d * offlow2);\n      assert !ff.ne(d, d * offhigh);\n      assert !ff.ne(d, d * offlow);\n      assert ff.ne(d, d * offhigh2);\n      assert ff.ne(d, d * offlow2);\n    }\n\n    //make sure nothing is equal to zero\n    assert ff.eq(0, Double.MIN_VALUE);\n    assert ff.eq(0, -Double.MIN_VALUE);\n    assert !ff.ne(0, Double.MIN_VALUE);\n    assert !ff.ne(0, -Double.MIN_VALUE);\n\n    //make sure that 0 equals 0\n    assert ff.eq(0, 0);\n    assert !ff.ne(0, 0);\n\n    //make sure that NaNs are not equal\n    assert !ff.eq(Double.NaN, Double.NaN);\n\n    //make sure that various unusual values are equal\n    assert ff.eq(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n    assert ff.eq(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);\n\n    //rudimentary checks on the comparison operators (since they all just\n    //use eq and ne anyway)\n    {\n      double d = 2563.789;\n      assert !ff.gt(d, d * offlow);\n      assert !ff.lt(d, d * offhigh);\n      assert ff.gt(d, d * offlow2);\n      assert ff.lt(d, d * offhigh2);\n      assert ff.gte(d, d * offhigh);\n      assert ff.lte(d, d * offlow);\n      assert !ff.gte(d, d * offhigh2);\n      assert !ff.lte(d, d * offlow2);\n    }\n\n    // public int indexOf (double[] a, double elt)\n    {\n      double[] a = new double[10];\n      for (int i = 0; i < a.length; i++) {\n        a[i] = i;\n      }\n      double[] a_copy = a.clone();\n      assert ff.indexOf(a, -1) == -1;\n      assert ff.indexOf(a, 0) == 0;\n      assert ff.indexOf(a, 7) == 7;\n      assert ff.indexOf(a, 9) == 9;\n      assert ff.indexOf(a, 10) == -1;\n      assert ff.indexOf(a, 20) == -1;\n      assert ff.indexOf(a, Double.MIN_VALUE) == 0;\n      assert ff.indexOf(a, 7 * offhigh) == 7;\n      assert ff.indexOf(a, 9 * offlow) == 9;\n      assert ff.indexOf(a, 7 * offhigh2) == -1;\n      assert ff.indexOf(a, 9 * offlow2) == -1;\n      assert_arrays_equals(a, a_copy);\n    }\n\n    // public int indexOf (double[] a, double[] sub)\n    {\n      double[] a = new double[10];\n      for (int i = 0; i < a.length; i++) {\n        a[i] = i;\n      }\n      double[] b = new double[] {};\n      double[] c = new double[] {a[0], a[1], a[2]};\n      double[] d = new double[] {a[1], a[2]};\n      double[] e = new double[] {a[2], a[3], a[4], a[5]};\n      double[] f = new double[] {a[7], a[8], a[9]};\n      double[] g = new double[] {a[7], 22, a[9]};\n      double[] h = new double[] {a[7], a[8], a[9], 10};\n\n      assert ff.indexOf(a, b) == 0;\n      assert ff.indexOf(a, c) == 0;\n      assert ff.indexOf(a, d) == 1;\n      assert ff.indexOf(a, e) == 2;\n      assert ff.indexOf(a, f) == 7;\n      assert ff.indexOf(a, g) == -1;\n      assert ff.indexOf(a, h) == -1;\n    }\n    {\n      double[] a = new double[10];\n      for (int i = 0; i < a.length; i++) {\n        a[i] = i;\n      }\n      double[] b = new double[] {};\n      double[] c = new double[] {a[0] * offlow, a[1] * offhigh, a[2] * offlow};\n      double[] d = new double[] {a[1] * offhigh, a[2] * offlow};\n      double[] e = new double[] {a[2], a[3], a[4] * offlow, a[5] * offhigh};\n      double[] f = new double[] {a[7], a[8] * offlow, a[9] * offhigh};\n      double[] g = new double[] {a[7], 22, a[9]};\n      double[] h = new double[] {a[7], a[8], a[9], 10};\n      double[] a_copy = a.clone();\n      double[] b_copy = b.clone();\n      double[] c_copy = c.clone();\n      double[] d_copy = d.clone();\n      double[] e_copy = e.clone();\n      double[] f_copy = f.clone();\n      double[] g_copy = g.clone();\n      double[] h_copy = h.clone();\n\n      assert ff.indexOf(a, b) == 0;\n      assert ff.indexOf(a, c) == 0;\n      assert ff.indexOf(a, d) == 1;\n      assert ff.indexOf(a, e) == 2;\n      assert ff.indexOf(a, f) == 7;\n      assert ff.indexOf(a, g) == -1;\n      assert ff.indexOf(a, h) == -1;\n\n      assert_arrays_equals(a, a_copy);\n      assert_arrays_equals(b, b_copy);\n      assert_arrays_equals(c, c_copy);\n      assert_arrays_equals(d, d_copy);\n      assert_arrays_equals(e, e_copy);\n      assert_arrays_equals(f, f_copy);\n      assert_arrays_equals(g, g_copy);\n      assert_arrays_equals(h, h_copy);\n    }\n\n    // public boolean isElemMatch (double[] a1, double[] a2)\n    {\n      double[] f1 = new double[10];\n      double[] f2 = new double[20];\n\n      for (int j = 0; j < 10; j++) {\n\n        initialize_f1_and_f2(j, f1, f2);\n\n        //make two elements off just a little\n        f2[7] = f2[7] * (1 + offset);\n        f2[8] = f2[8] * (1 - offset);\n\n        //test with each array the bigger one\n        if ((j % 2) == 0) {\n          assert ff.isElemMatch(f1, f2);\n        } else {\n          assert ff.isElemMatch(f2, f1);\n        }\n      }\n      for (int j = 0; j < 200; j++) {\n\n        initialize_f1_and_f2(j, f1, f2);\n\n        //make two elements off just a little\n        f2[7] = f2[7] * (1 + 2 * offset);\n        f2[8] = f2[8] * (1 - 2 * offset);\n\n        //test with each array the bigger one\n        double[] f1_copy = f1.clone();\n        double[] f2_copy = f2.clone();\n        if ((j % 2) == 0) {\n          assert !ff.isElemMatch(f1, f2);\n        } else {\n          assert !ff.isElemMatch(f2, f1);\n        }\n        assert_arrays_equals(f1, f1_copy);\n        assert_arrays_equals(f2, f2_copy);\n      }\n    }\n    {\n      double[] a = new double[] {2, 1, 0};\n      double[] b = new double[] {};\n      double[] c = new double[] {1, 1, 1, 1};\n      double[] d = new double[] {1};\n      assert !ff.isElemMatch(a, b);\n      assert !ff.isElemMatch(b, a);\n      assert ff.isElemMatch(c, d);\n      assert ff.isElemMatch(d, c);\n      assert ff.isElemMatch(b, b);\n    }\n\n    // public class DoubleArrayComparatorLexical implements Comparator\n    // public int compare(Object o1, Object o2)\n    {\n      Comparator<double[]> comparator = ff.new DoubleArrayComparatorLexical();\n      double[] a0 = new double[] {};\n      double[] a1 = new double[] {};\n      double[] a2 = new double[] {0, 1, 2, 3};\n      double[] a3 = new double[] {0, 1, 2, 3, 0};\n      double[] a4 = new double[] {0, 1, 2, 3, 4};\n      double[] a5 = new double[] {0, 1, 2, 3, 4};\n      double[] a6 = new double[] {0, 1, 5, 3, 4};\n      double[] a7 = new double[] {1, 2, 3, 4};\n      double[] a0_copy = a0.clone();\n      double[] a1_copy = a1.clone();\n      double[] a2_copy = a2.clone();\n      double[] a3_copy = a3.clone();\n      double[] a4_copy = a4.clone();\n      double[] a5_copy = a5.clone();\n      double[] a6_copy = a6.clone();\n      double[] a7_copy = a7.clone();\n\n      assert comparator.compare(a0, a1) == 0;\n      assert comparator.compare(a1, a0) == 0;\n      assert comparator.compare(a1, a2) < 0;\n      assert comparator.compare(a2, a1) > 0;\n      assert comparator.compare(a2, a3) < 0;\n      assert comparator.compare(a3, a2) > 0;\n      assert comparator.compare(a3, a4) < 0;\n      assert comparator.compare(a4, a3) > 0;\n      assert comparator.compare(a4, a5) == 0;\n      assert comparator.compare(a5, a4) == 0;\n      assert comparator.compare(a5, a6) < 0;\n      assert comparator.compare(a6, a5) > 0;\n      assert comparator.compare(a6, a7) < 0;\n      assert comparator.compare(a7, a6) > 0;\n      assert comparator.compare(a1, a4) < 0;\n      assert comparator.compare(a4, a1) > 0;\n      assert comparator.compare(a2, a4) < 0;\n      assert comparator.compare(a4, a2) > 0;\n      assert comparator.compare(a6, a4) > 0;\n      assert comparator.compare(a4, a6) < 0;\n      assert comparator.compare(a7, a4) > 0;\n      assert comparator.compare(a4, a7) < 0;\n\n      assert_arrays_equals(a0, a0_copy);\n      assert_arrays_equals(a1, a1_copy);\n      assert_arrays_equals(a2, a2_copy);\n      assert_arrays_equals(a3, a3_copy);\n      assert_arrays_equals(a4, a4_copy);\n      assert_arrays_equals(a5, a5_copy);\n      assert_arrays_equals(a6, a6_copy);\n      assert_arrays_equals(a7, a7_copy);\n    }\n\n    // public boolean FuzzyFloat.isSubset (double[] a1, double[] a2)\n    {\n      double[] f1 = new double[10];\n      double[] f2 = new double[20];\n\n      for (int j = 0; j < f2.length; j++) {\n        f2[j] = j;\n      }\n      for (int i = 0; i < f2.length - f1.length; i++) {\n\n        //fill up f1 with elements of f2\n        for (int j = 0; j < f1.length; j++) {\n          f1[j] = f2[i + j];\n        }\n\n        f1[5] = f2[i] * offhigh;\n\n        double[] f1_copy = f1.clone();\n        double[] f2_copy = f2.clone();\n\n        assert ff.isSubset(f1, f2);\n        assert_arrays_equals(f1, f1_copy);\n        assert_arrays_equals(f2, f2_copy);\n      }\n\n      double[] a1 = new double[] {1, 5, 10};\n      double[] a2 = new double[] {};\n      double[] a3 = new double[] {1};\n      double[] a4 = new double[] {10};\n      double[] a5 = new double[] {1, 10, 15, 20};\n      double[] a6 = new double[] {10, 10, 10, 10, 10, 1};\n\n      assert ff.isSubset(a2, a1);\n      assert !ff.isSubset(a1, a2);\n      assert !ff.isSubset(a1, a5);\n      assert ff.isSubset(a3, a1);\n      assert ff.isSubset(a4, a1);\n      assert ff.isSubset(a6, a1);\n      assert !ff.isSubset(a1, a6);\n    }\n  }\n\n  /** Initialize f2 to be the same as two copies of f1 */\n  @SuppressWarnings(\"index\") // length of f1 is exactly 10, length of f2 is exactly 20\n  void initialize_f1_and_f2(int j, double[] f1, double[] f2) {\n\n    //start two arrays out exactly equal\n    for (int i = 0; i < f1.length; i++) {\n      f1[i] = j + i * 10;\n      f2[i] = j + i * 10;\n    }\n\n    //fill out the second half of f2 with dup of f1\n    for (int i = 10; i < f2.length; i++) {\n      f2[i] = j + (i - 10) * 10;\n    }\n  }\n\n  /**\n   * Tests UtilMDE create_combinations routines.\n   */\n  @Test\n  public void test_create_combinations() {\n\n    // public static List create_combinations (int dims, int start, List objs)\n    Object a = new Object();\n    Object b = new Object();\n    Object c = new Object();\n    List<Object> a_list = Arrays.<Object>asList(new Object[] {a});\n    List<Object> b_list = Arrays.<Object>asList(new Object[] {b});\n    List<Object> c_list = Arrays.<Object>asList(new Object[] {c});\n    List<Object> aa = Arrays.<Object>asList(new Object[] {a, a});\n    List<Object> bb = Arrays.<Object>asList(new Object[] {b, b});\n    List<Object> cc = Arrays.<Object>asList(new Object[] {c, c});\n    List<Object> ab = Arrays.<Object>asList(new Object[] {a, b});\n    List<Object> ac = Arrays.<Object>asList(new Object[] {a, c});\n    List<Object> bc = Arrays.<Object>asList(new Object[] {b, c});\n\n    List<Object> abc = Arrays.asList(a, b, c);\n    List<List<Object>> combo1 = UtilMDE.create_combinations(1, 0, abc);\n    assert combo1.size() == 3;\n    assert combo1.contains(a_list);\n    assert combo1.contains(b_list);\n    assert combo1.contains(c_list);\n\n    List<List<Object>> combo2 = UtilMDE.create_combinations(2, 0, abc);\n    assert combo2.size() == 6;\n    assert combo2.contains(aa);\n    assert combo2.contains(ab);\n    assert combo2.contains(ac);\n    assert combo2.contains(bb);\n    assert combo2.contains(bc);\n    assert combo2.contains(cc);\n\n    // public static List create_combinations (int arity, int start, int cnt)\n    Integer i0 = new Integer(0);\n    Integer i1 = new Integer(1);\n    Integer i2 = new Integer(2);\n\n    List<ArrayList<Integer>> combo3 = UtilMDE.create_combinations(1, 0, 2);\n    assert combo3.size() == 3;\n    assert combo3.contains(Arrays.asList(new Integer[] {i0}));\n    assert combo3.contains(Arrays.asList(new Integer[] {i1}));\n    assert combo3.contains(Arrays.asList(new Integer[] {i2}));\n\n    List<ArrayList<Integer>> combo4 = UtilMDE.create_combinations(2, 0, 2);\n    assert combo4.size() == 6;\n    assert combo4.contains(Arrays.asList(new Integer[] {i0, i0}));\n    assert combo4.contains(Arrays.asList(new Integer[] {i0, i1}));\n    assert combo4.contains(Arrays.asList(new Integer[] {i0, i2}));\n    assert combo4.contains(Arrays.asList(new Integer[] {i1, i1}));\n    assert combo4.contains(Arrays.asList(new Integer[] {i1, i2}));\n    assert combo4.contains(Arrays.asList(new Integer[] {i2, i2}));\n  }\n\n  @Test\n  public void test_fullyQualifiedNameToSimpleName() {\n\n    assert UtilMDE.fullyQualifiedNameToSimpleName(\"java.lang.String\").equals(\"String\");\n    assert UtilMDE.fullyQualifiedNameToSimpleName(\"String\").equals(\"String\");\n  }\n\n  /**\n   * Test class for Options testing.\n   */\n  public static class TestOptions {\n\n    // TODO: test the @Unpublicized annotation and the usage() message.\n\n    @Option(\"list of patterns\")\n    public List<Pattern> lp = new ArrayList<Pattern>();\n\n    @Option(\"-a <filename> argument 1\")\n    public String arg1 = \"/tmp/foobar\";\n\n    @Option(\"argument 2\")\n    public /*@Nullable*/ String arg2;\n\n    @Option(\"-d double value\")\n    public double temperature;\n\n    @Option(\"-f the input file\")\n    public /*@Nullable*/ File input_file;\n\n    @Option(\"-b boolean\")\n    public boolean bool;\n\n    @Option(\"-i Integer\")\n    public /*@Nullable*/ Integer integer_reference;\n\n    @Option(\"list of doubles\")\n    public List<Double> ld = new ArrayList<Double>();\n\n    @Option(\"list with no default\")\n    public /*@Nullable*/ List<String> ls;\n  }\n\n  /**\n   * Test command line option parsing (Options).\n   * @throws ArgException if there is an illegal argument\n   */\n  @Test\n  public void testOptions() throws ArgException {\n\n    TestOptions t = new TestOptions();\n    Options options = new Options(\"test\", t);\n    options.parse(\n        new String[] {\n          \"--lp=foo\",\n          \"--lp\",\n          \"bar\",\n          \"-i\",\n          \"24\",\n          \"-d=37.8\",\n          \"-b\",\n          \"-b=false\",\n          \"--ld\",\n          \"34.6\",\n          \"--ld\",\n          \"17.8\",\n        });\n    assert t.lp.get(0).toString().equals(\"foo\");\n    assert t.lp.get(1).toString().equals(\"bar\");\n    assert t.integer_reference != null && t.integer_reference.intValue() == 24;\n    assert t.temperature == 37.8;\n    assert t.bool == false;\n    assert t.ld.get(0).doubleValue() == 34.6;\n    assert t.ld.get(1).doubleValue() == 17.8;\n\n    // Test non-options\n    t.bool = false;\n    String[] args = options.parse(new String[] {\"one\", \"two\", \"three\", \"-b\"});\n    assert args[0].equals(\"one\") : args[0];\n    assert args[1].equals(\"two\") : args[1];\n    assert args[2].equals(\"three\") : args[2];\n    assert t.bool;\n\n    // Test --\n    t.bool = false;\n    args = options.parse(new String[] {\"--\", \"one\", \"two\", \"-b\"});\n    assert args[0].equals(\"one\") : args[0];\n    assert args[1].equals(\"two\") : args[1];\n    assert args[2].equals(\"-b\") : args[2];\n    assert !t.bool;\n\n    // Test split_lists\n    t.ld.clear();\n    Options.split_lists = true;\n    args = options.parse(new String[] {\"--ld\", \"42.1 9.3 10.5\", \"--ld\", \"2.7\"});\n    assert args.length == 0;\n    assert t.ld.size() == 4;\n    assert t.ld.get(0).doubleValue() == 42.1;\n    assert t.ld.get(1).doubleValue() == 9.3;\n    assert t.ld.get(2).doubleValue() == 10.5;\n    assert t.ld.get(3).doubleValue() == 2.7;\n\n    // Test list with no default\n    args = options.parse(new String[] {\"--ls\", \"hello\", \"--ls\", \"world\"});\n    assert args.length == 0;\n    assert t.ls != null : \"@AssumeAssertion(nullness)\";\n    assert t.ls.size() == 2;\n    assert t.ls.get(0).equals(\"hello\");\n    assert t.ls.get(1).equals(\"world\");\n  }\n\n  /** Test class for option alias testing. */\n  public static class TestOptionsAliases {\n    @Option(\"-d Set the day\")\n    public String day = \"Friday\";\n\n    @Option(\n      value = \"-t Set the temperature\",\n      aliases = {\"-temp\"}\n    )\n    public double temperature = 42.0;\n\n    @Option(\n      value = \"Print the program version\",\n      aliases = {\"-v\", \"-version\", \"--version\"}\n    )\n    public boolean printVersion = false;\n  }\n\n  /**\n   * Test option aliases (Options).\n   * @throws ArgException if there is an illegal argument\n   */\n  @Test\n  public void testOptionsAliases() throws ArgException {\n    TestOptionsAliases t = new TestOptionsAliases();\n    Options options = new Options(\"test\", t);\n\n    options.parse(new String[] {\"-d\", \"Monday\", \"-temp\", \"-12.3\"});\n    assert t.day.equals(\"Monday\");\n    assert t.temperature == -12.3;\n    assert !t.printVersion;\n\n    options.parse(\"-d Monday -temp -12.3\");\n    assert t.day.equals(\"Monday\");\n    assert t.temperature == -12.3;\n    assert !t.printVersion;\n\n    options.parse(new String[] {\"-t\", \"21.7\", \"-version\"});\n    assert t.day.equals(\"Monday\");\n    assert t.temperature == 21.7;\n    assert t.printVersion;\n\n    options.parse(\"-t 21.7 -version\");\n    assert t.day.equals(\"Monday\");\n    assert t.temperature == 21.7;\n    assert t.printVersion;\n\n    t.printVersion = false;\n    options.parse(new String[] {\"--version\", \"-temp=-60.1\", \"--day\", \"Tuesday\"});\n    assert t.day.equals(\"Tuesday\");\n    assert t.temperature == -60.1;\n    assert t.printVersion;\n\n    t.printVersion = false;\n    options.parse(\"--version -temp=-60.1 --day Tuesday\");\n    assert t.day.equals(\"Tuesday\");\n    assert t.temperature == -60.1;\n    assert t.printVersion;\n  }\n\n  /** Test class for testing option groups. */\n  public static class TestOptionGroups1 {\n    @Option(\"-m Set the mass\")\n    public static int mass;\n\n    @OptionGroup(\"Coordinate options\")\n    @Option(\"-x Set the X coordinate\")\n    public static int x;\n\n    @Option(\"-y Set the Y coordinate\")\n    public static int y;\n\n    @Option(\"-z Set the Z coordinate\")\n    public static int z;\n  }\n\n  /** Test class for testing option groups. */\n  public static class TestOptionGroups2 {\n    @OptionGroup(\"General options\")\n    @Option(\n      value = \"-h Display help message\",\n      aliases = {\"-help\"}\n    )\n    public static boolean help = false;\n\n    @OptionGroup(value = \"Internal options\", unpublicized = true)\n    @Option(\"Set mu\")\n    public static double mu = 4902.7;\n\n    @Unpublicized\n    @Option(\"Set pi\")\n    public static double pi = 3.14;\n\n    @OptionGroup(\"Display options\")\n    @Option(\n      value = \"Use colors\",\n      aliases = {\"--colour\"}\n    )\n    public static boolean color = false;\n  }\n\n  /** Test class for testing option groups. */\n  public static class TestOptionGroups3 {\n    @OptionGroup(\"General options\")\n    @Option(\n      value = \"-h Display help message\",\n      aliases = {\"-help\"}\n    )\n    public static boolean help = false;\n\n    @OptionGroup(\"Internal options\")\n    @Unpublicized\n    @Option(\"Set mu\")\n    public static double mu = 4902.7;\n\n    @Unpublicized\n    @Option(\"Set pi\")\n    public static double pi = 3.14;\n\n    @OptionGroup(\"Display options\")\n    @Option(\n      value = \"Use colors\",\n      aliases = {\"--colour\"}\n    )\n    public static boolean color = false;\n  }\n\n  /**\n   * Test option groups (Options).\n   * @throws ArgException if there is an illegal argument\n   */\n  @Test\n  public void testOptionGroups() throws ArgException {\n    // TODO: The following two exception tests are not adequate.  There must be\n    // a better way to do these.\n    try {\n      Options options = new Options(\"test\", TestOptionGroups1.class);\n    } catch (Error e) {\n      assert e.getMessage() != null\n          && e.getMessage()\n                  .indexOf(\"missing @OptionGroup annotation on the first @Option-annotated field\")\n              > -1;\n    }\n\n    try {\n      Options options = new Options(\"test\", TestOptionGroups2.class, TestOptionGroups1.class);\n    } catch (Error e) {\n      assert e.getMessage() != null\n          && e.getMessage().indexOf(\"missing @OptionGroup annotation in field\") > -1;\n    }\n\n    Options options = new Options(\"test\", TestOptionGroups2.class);\n\n    assert options.usage().indexOf(\"General options\") > -1;\n    assert options.usage().indexOf(\"Display options\") > -1;\n    // \"Internal options\" is unpublicized so it should not occur in the default\n    // usage message.\n    assert options.usage().indexOf(\"Internal options\") == -1;\n\n    assert options.usage(\"Internal options\").indexOf(\"Set mu\") > -1;\n    // \"Set pi\" should not appear in the usage message for \"Internal options\"\n    // because it is marked with @Unpublicized.\n    assert options.usage(\"Internal options\").indexOf(\"Set pi\") == -1;\n\n    options.parse(new String[] {\"--colour\", \"--pi\", \"3.15\"});\n    assert TestOptionGroups2.color;\n    assert TestOptionGroups2.pi == 3.15;\n\n    options.parse(\"--colour --pi 3.15\");\n    assert TestOptionGroups2.color;\n    assert TestOptionGroups2.pi == 3.15;\n\n    // Test that an option group that contains only unpublicized options is not\n    // included in the usage message.\n    Options options2 = new Options(\"test\", TestOptionGroups3.class);\n    assert options.usage().indexOf(\"Internal options\") == -1;\n    // ...unless include_unpublicized is true.\n    assert options.usage(true).indexOf(\"Internal options\") > -1;\n  }\n\n  public static class TestOptionsEnums {\n    enum Compressor {\n      RLE,\n      SMART_RLE,\n      HUFFMAN\n    }\n\n    @Option(\"Set the first compression pass\")\n    public static /*@Nullable*/ Compressor firstPass;\n\n    @Option(\"Set the second compression pass\")\n    public static /*@Nullable*/ Compressor secondPass;\n  }\n\n  @Test\n  public void testOptionsEnums() throws ArgException {\n    Options options = new Options(\"test\", TestOptionsEnums.class);\n\n    options.parse(new String[] {\"--firstPass\", \"SMART_RLE\"});\n    assert TestOptionsEnums.firstPass == TestOptionsEnums.Compressor.SMART_RLE;\n    TestOptionsEnums.firstPass = TestOptionsEnums.Compressor.HUFFMAN;\n\n    options.parse(new String[] {\"--firstPass\", \"smart_rle\"});\n    assert TestOptionsEnums.firstPass == TestOptionsEnums.Compressor.SMART_RLE;\n    TestOptionsEnums.firstPass = TestOptionsEnums.Compressor.HUFFMAN;\n\n    options.parse(new String[] {\"--firstPass\", \"smart-rle\"});\n    assert TestOptionsEnums.firstPass == TestOptionsEnums.Compressor.SMART_RLE;\n\n    options.parse(new String[] {\"--firstPass\", \"rle\", \"--secondPass\", \"SMART-RLE\"});\n    assert TestOptionsEnums.firstPass == TestOptionsEnums.Compressor.RLE;\n    assert TestOptionsEnums.secondPass == TestOptionsEnums.Compressor.SMART_RLE;\n\n    options.parse(new String[] {\"--secondPass\", \"Huffman\"});\n    assert TestOptionsEnums.firstPass == TestOptionsEnums.Compressor.RLE;\n    assert TestOptionsEnums.secondPass == TestOptionsEnums.Compressor.HUFFMAN;\n  }\n\n  @Test\n  public void testOptionsEnumsFail() {\n    Options options = new Options(\"test\", TestOptionsEnums.class);\n    try {\n      // should fail: can not leave out _ or -\n      options.parse(new String[] {\"--firstPass\", \"smartrle\"});\n      org.junit.Assert.fail(\"Didn't throw ArgException as expected\");\n    } catch (ArgException e) {\n    }\n  }\n\n  @Test\n  public void testSplitLines() {\n\n    String str = \"one\\ntwo\\n\\rthree\\r\\nfour\\rfive\\n\\n\\nsix\\r\\n\\r\\n\\r\\n\";\n    String[] sa = UtilMDE.splitLines(str);\n    // for (String s : sa)\n    //   System.out.printf (\"'%s'%n\", s);\n    assert sa.length == 11;\n    assert sa[0].equals(\"one\");\n    assert sa[1].equals(\"two\");\n    assert sa[2].equals(\"three\");\n    assert sa[3].equals(\"four\");\n    assert sa[4].equals(\"five\");\n    assert sa[5].equals(\"\");\n    assert sa[6].equals(\"\");\n    assert sa[7].equals(\"six\");\n    assert sa[8].equals(\"\");\n    assert sa[9].equals(\"\");\n    assert sa[10].equals(\"\");\n  }\n\n  // Figure 1 from http://www.boost.org/libs/graph/doc/lengauer_tarjan_dominator.htm#fig:dominator-tree-example\n  private static /*@Nullable*/ Map<Integer, List</*@KeyFor(\"preds1\")*/ Integer>> preds1;\n  private static /*@Nullable*/ Map<Integer, List</*@KeyFor(\"succs1\")*/ Integer>> succs1;\n\n  @SuppressWarnings({\"keyfor\", \"nullness\"})\n  /*@EnsuresNonNull({\"preds1\", \"succs1\"})*/\n  private static void initializePreds1AndSucc1() {\n    if (preds1 != null) {\n      return;\n    }\n\n    preds1 = new LinkedHashMap<Integer, List<Integer>>();\n    succs1 = new LinkedHashMap<Integer, List<Integer>>();\n    for (int i = 0; i <= 7; i++) {\n      preds1.put(new Integer(i), new ArrayList<Integer>());\n      succs1.put(new Integer(i), new ArrayList<Integer>());\n    }\n    succs1.get(0).add(1);\n    preds1.get(1).add(0);\n    succs1.get(1).add(2);\n    preds1.get(2).add(1);\n    succs1.get(1).add(3);\n    preds1.get(3).add(1);\n    succs1.get(2).add(7);\n    preds1.get(7).add(2);\n    succs1.get(3).add(4);\n    preds1.get(4).add(3);\n    succs1.get(4).add(5);\n    preds1.get(5).add(4);\n    succs1.get(4).add(6);\n    preds1.get(6).add(4);\n    succs1.get(5).add(7);\n    preds1.get(7).add(5);\n    succs1.get(6).add(4);\n    preds1.get(4).add(6);\n  }\n\n  @SuppressWarnings(\"nullness\")\n  @Test\n  public void testGraphMDE() {\n\n    initializePreds1AndSucc1();\n\n    Map<Integer, List<Integer>> dom1post = GraphMDE.dominators(succs1);\n    assert dom1post.get(0).toString().equals(\"[7, 1, 0]\");\n    assert dom1post.get(1).toString().equals(\"[7, 1]\");\n    assert dom1post.get(2).toString().equals(\"[7, 2]\");\n    assert dom1post.get(3).toString().equals(\"[7, 5, 4, 3]\");\n    assert dom1post.get(4).toString().equals(\"[7, 5, 4]\");\n    assert dom1post.get(5).toString().equals(\"[7, 5]\");\n    assert dom1post.get(6).toString().equals(\"[7, 5, 4, 6]\");\n    assert dom1post.get(7).toString().equals(\"[7]\");\n\n    Map<Integer, List<Integer>> dom1pre = GraphMDE.dominators(preds1);\n    assert dom1pre.get(0).toString().equals(\"[0]\");\n    assert dom1pre.get(1).toString().equals(\"[0, 1]\");\n    assert dom1pre.get(2).toString().equals(\"[0, 1, 2]\");\n    assert dom1pre.get(3).toString().equals(\"[0, 1, 3]\");\n    assert dom1pre.get(4).toString().equals(\"[0, 1, 3, 4]\");\n    assert dom1pre.get(5).toString().equals(\"[0, 1, 3, 4, 5]\");\n    assert dom1pre.get(6).toString().equals(\"[0, 1, 3, 4, 6]\");\n    assert dom1pre.get(7).toString().equals(\"[0, 1, 7]\");\n\n    // I should add some more tests.\n\n  }\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10962,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "TestPlume",
  "javadocTag" : "@throws ArgException if there is an illegal argument",
  "methodJavadoc" : "    /**\n   * Test option aliases (Options).\n   * @throws ArgException if there is an illegal argument\n   */",
  "methodSourceCode" : "public void testOptionsAliases() throws ArgException{\n    TestOptionsAliases t = new TestOptionsAliases();\n    Options options = new Options(\"test\", t);\n    options.parse(new String[] { \"-d\", \"Monday\", \"-temp\", \"-12.3\" });\n    assert t.day.equals(\"Monday\");\n    assert t.temperature == -12.3;\n    assert !t.printVersion;\n    options.parse(\"-d Monday -temp -12.3\");\n    assert t.day.equals(\"Monday\");\n    assert t.temperature == -12.3;\n    assert !t.printVersion;\n    options.parse(new String[] { \"-t\", \"21.7\", \"-version\" });\n    assert t.day.equals(\"Monday\");\n    assert t.temperature == 21.7;\n    assert t.printVersion;\n    options.parse(\"-t 21.7 -version\");\n    assert t.day.equals(\"Monday\");\n    assert t.temperature == 21.7;\n    assert t.printVersion;\n    t.printVersion = false;\n    options.parse(new String[] { \"--version\", \"-temp=-60.1\", \"--day\", \"Tuesday\" });\n    assert t.day.equals(\"Tuesday\");\n    assert t.temperature == -60.1;\n    assert t.printVersion;\n    t.printVersion = false;\n    options.parse(\"--version -temp=-60.1 --day Tuesday\");\n    assert t.day.equals(\"Tuesday\");\n    assert t.temperature == -60.1;\n    assert t.printVersion;\n}",
  "classJavadoc" : "/** Test code for the plume package. */",
  "classSourceCode" : "package plume;\n\nimport static plume.Options.ArgException;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.CharArrayWriter;\nimport java.io.File;\nimport java.io.IOException;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Calendar;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Random;\nimport java.util.Vector;\nimport java.util.regex.Pattern;\nimport org.junit.Test;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.checker.signature.qual.*;\n*/\n\n// run like this:\n//   java plume.TestPlume\n\n// Files to test:\n// ArraysMDE.java\n// ClassFileVersion.java\n// CountingPrintWriter.java\n// Digest.java\n// FileIOException.java\n// FuzzyFloat.java\n// GraphMDE.java\n// Hasher.java\n// Intern.java\n// ICalAvailable.java\n// LimitedSizeIntSet.java\n// MathMDE.java\n// Options.java\n// OrderedPairIterator.java\n// StringBuilderDelimited.java\n// UtilMDE.java\n// WeakHasherMap.java\n\n/** Test code for the plume package. */\n@SuppressWarnings({\"interning\"}) // interning is due to apparent bugs\npublic final class TestPlume {\n\n  // If true, do 100 instead of 100000 iterations when testing randomElements.\n  // This saves only a little time.  However, it is significant when running\n  // under instrumentation such as that of Chicory.\n  static boolean short_run = false;\n\n  //   public static void main(String[] args) {\n  //     testUtilMDE();\n  //     testArraysMDE();\n  //     testHasher();\n  //     testIntern();\n  //     testMathMDE();\n  //     testOrderedPairIterator();\n  //     testPlume();\n  //     testWeakHasherMap();\n  //     System.out.println(\"All plume tests succeeded.\");\n  //   }\n\n  public static void assert_arrays_equals(int /*@Nullable*/ [] a1, int /*@Nullable*/ [] a2) {\n    boolean result = Arrays.equals(a1, a2);\n    if (!result) {\n      System.out.println(\n          \"Arrays differ: \" + ArraysMDE.toString(a1) + \", \" + ArraysMDE.toString(a2));\n    }\n    assert result;\n    //      assert(Arrays.equals(a1, a2),\n    //         \"Arrays differ: \" + ArraysMDE.toString(a1) + \", \" + ArraysMDE.toString(a2));\n  }\n\n  public static void assert_arrays_equals(double[] a1, double[] a2) {\n    boolean result = Arrays.equals(a1, a2);\n    if (!result) {\n      System.out.println(\n          \"Arrays differ: \" + ArraysMDE.toString(a1) + \", \" + ArraysMDE.toString(a2));\n    }\n    assert result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Utility functions\n  ///\n\n  public static Iterator<Integer> int_array_iterator(int[] nums) {\n    List<Integer> asList = new ArrayList<Integer>(nums.length);\n    for (int i = 0; i < nums.length; i++) {\n      asList.add(nums[i]);\n    }\n    return asList.iterator();\n  }\n\n  public static int[] int_iterator_array(Iterator<Integer> itor) {\n    Vector<Integer> v = new Vector<Integer>();\n    while (itor.hasNext()) {\n      v.add(itor.next());\n    }\n    int[] a = new int[v.size()];\n    for (int i = 0; i < a.length; i++) {\n      a[i] = v.elementAt(i).intValue();\n    }\n    return a;\n  }\n\n  public static <T> Vector<T> toVector(Iterator<T> itor) {\n    Vector<T> v = new Vector<T>();\n    while (itor.hasNext()) {\n      v.add(itor.next());\n    }\n    return v;\n  }\n\n  public static <T> Vector<T> toVector(Enumeration<T> e) {\n    Vector<T> v = new Vector<T>();\n    while (e.hasMoreElements()) {\n      v.add(e.nextElement());\n    }\n    return v;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Now the actual testing\n  ///\n\n  @Test\n  public void testArraysMDE() {\n\n    // public static int min(int[] a)\n    assert ArraysMDE.min(new int[] {1, 2, 3}) == 1;\n    assert ArraysMDE.min(new int[] {2, 33, 1}) == 1;\n    assert ArraysMDE.min(new int[] {3, -2, 1}) == -2;\n    assert ArraysMDE.min(new int[] {3}) == 3;\n\n    // public static int max(int[] a)\n    assert ArraysMDE.max(new int[] {1, 2, 3}) == 3;\n    assert ArraysMDE.max(new int[] {2, 33, 1}) == 33;\n    assert ArraysMDE.max(new int[] {3, -2, 1}) == 3;\n    assert ArraysMDE.max(new int[] {3}) == 3;\n\n    // public static int[] min_max(int[] a)\n    assert_arrays_equals(ArraysMDE.min_max(new int[] {1, 2, 3}), new int[] {1, 3});\n    assert_arrays_equals(ArraysMDE.min_max(new int[] {2, 33, 1}), new int[] {1, 33});\n    assert_arrays_equals(ArraysMDE.min_max(new int[] {3, -2, 1}), new int[] {-2, 3});\n    assert_arrays_equals(ArraysMDE.min_max(new int[] {3}), new int[] {3, 3});\n    try {\n      ArraysMDE.min_max(new int[] {});\n      throw new Error(\"Didn't throw ArrayIndexOutOfBoundsException\");\n    } catch (ArrayIndexOutOfBoundsException e) {\n    }\n    try {\n      ArraysMDE.min_max(new long[] {});\n      throw new Error(\"Didn't throw ArrayIndexOutOfBoundsException\");\n    } catch (ArrayIndexOutOfBoundsException e) {\n    }\n\n    // public static int sum(int[] a)\n    assert 0 == ArraysMDE.sum(new int[0]);\n    assert 10 == ArraysMDE.sum(new int[] {10});\n    assert 10 == ArraysMDE.sum(new int[] {1, 2, 3, 4});\n\n    // public static int sum(int[][] a)\n    assert 0 == ArraysMDE.sum(new int[0][0]);\n    assert 78 == ArraysMDE.sum(new int[][] {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}});\n    assert 68 == ArraysMDE.sum(new int[][] {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 11, 12}});\n\n    // public static double sum(double[] a)\n    assert 0 == ArraysMDE.sum(new double[0]);\n    assert 3.14 == ArraysMDE.sum(new double[] {3.14});\n    assert 8.624 == ArraysMDE.sum(new double[] {3.14, 2.718, -1.234, 4});\n\n    // public static double sum(double[][] a)\n    assert 0 == ArraysMDE.sum(new double[0][0]);\n    assert 79.5\n        == ArraysMDE.sum(new double[][] {{1.1, 2.2, 3.3, 4.4}, {5.5, 6, 7, 8}, {9, 10, 11, 12}});\n\n    // public static int element_range(int[] a)\n    assert ArraysMDE.element_range(new int[] {1, 2, 3}) == 2;\n    assert ArraysMDE.element_range(new int[] {2, 33, 1}) == 32;\n    assert ArraysMDE.element_range(new int[] {3, -2, 1}) == 5;\n    assert ArraysMDE.element_range(new int[] {3}) == 0;\n\n    // public static int indexOf(Object[] a, Object elt)\n    // public static int indexOfEq(Object[] a, Object elt)\n    {\n      Integer[] a = new Integer[10];\n      for (int i = 0; i < a.length; i++) {\n        a[i] = new Integer(i);\n      }\n      assert ArraysMDE.indexOf(a, new Integer(-1)) == -1;\n      assert ArraysMDE.indexOf(a, new Integer(0)) == 0;\n      assert ArraysMDE.indexOf(a, new Integer(7)) == 7;\n      assert ArraysMDE.indexOf(a, new Integer(9)) == 9;\n      assert ArraysMDE.indexOf(a, new Integer(10)) == -1;\n      assert ArraysMDE.indexOf(a, new Integer(20)) == -1;\n      assert ArraysMDE.indexOf(a, (Object) null) == -1;\n      assert ArraysMDE.indexOf(a, (Object) null, 1, 5) == -1;\n\n      assert ArraysMDE.indexOfEq(a, new Integer(-1)) == -1;\n      assert ArraysMDE.indexOfEq(a, new Integer(0)) == -1;\n      assert ArraysMDE.indexOfEq(a, new Integer(7)) == -1;\n      assert ArraysMDE.indexOfEq(a, new Integer(9)) == -1;\n      assert ArraysMDE.indexOfEq(a, new Integer(10)) == -1;\n      assert ArraysMDE.indexOfEq(a, new Integer(20)) == -1;\n      assert ArraysMDE.indexOfEq(a, (Object) null) == -1;\n      assert ArraysMDE.indexOfEq(a, (Object) null, 1, 5) == -1;\n      assert ArraysMDE.indexOfEq(a, a[0]) == 0;\n      assert ArraysMDE.indexOfEq(a, a[7]) == 7;\n      assert ArraysMDE.indexOfEq(a, a[9]) == 9;\n    }\n\n    // public static int indexOf(List<?> a, Object elt)\n    // public static int indexOf(List<?> a, Object elt, int minindex, int indexlimit)\n    // public static int indexOfEq(List<?> a, Object elt, int minindex, int indexlimit)\n    // public static int indexOfEq(List<?> a, Object elt)\n    {\n      assert ArraysMDE.indexOf((List<?>) new ArrayList<Object>(), (Object) null) == -1;\n      assert ArraysMDE.indexOf((List<?>) new ArrayList<Object>(), (Object) null, 0, -1) == -1;\n      assert ArraysMDE.indexOfEq((List<?>) new ArrayList<Object>(), (Object) null) == -1;\n      assert ArraysMDE.indexOfEq((List<?>) new ArrayList<Object>(), (Object) null, 0, -1) == -1;\n    }\n\n    // public static int indexOf(int[] a, int elt)\n    {\n      int[] a = new int[10];\n      for (int i = 0; i < a.length; i++) {\n        a[i] = i;\n      }\n      assert ArraysMDE.indexOf(a, -1) == -1;\n      assert ArraysMDE.indexOf(a, 0) == 0;\n      assert ArraysMDE.indexOf(a, 7) == 7;\n      assert ArraysMDE.indexOf(a, 9) == 9;\n      assert ArraysMDE.indexOf(a, 10) == -1;\n      assert ArraysMDE.indexOf(a, 20) == -1;\n    }\n\n    // public static int indexOf(boolean[] a, boolean elt)\n    {\n      boolean[] a = new boolean[10];\n      for (int i = 0; i < a.length; i++) {\n        a[i] = false;\n      }\n      assert ArraysMDE.indexOf(a, true) == -1;\n      assert ArraysMDE.indexOf(a, false) == 0;\n      a[9] = true;\n      assert ArraysMDE.indexOf(a, true) == 9;\n      assert ArraysMDE.indexOf(a, false) == 0;\n      a[7] = true;\n      assert ArraysMDE.indexOf(a, true) == 7;\n      assert ArraysMDE.indexOf(a, false) == 0;\n      a[0] = true;\n      assert ArraysMDE.indexOf(a, true) == 0;\n      assert ArraysMDE.indexOf(a, false) == 1;\n      for (int i = 0; i < a.length; i++) {\n        a[i] = true;\n      }\n      assert ArraysMDE.indexOf(a, true) == 0;\n      assert ArraysMDE.indexOf(a, false) == -1;\n    }\n\n    // public static int indexOf(Object[] a, Object[] sub)\n    // public static int indexOfEq(Object[] a, Object[] sub)\n    {\n      Integer[] a = new Integer[10];\n      for (int i = 0; i < a.length; i++) {\n        a[i] = new Integer(i);\n      }\n      Integer[] b = new Integer[] {};\n      Integer[] c = new Integer[] {a[0], a[1], a[2]};\n      Integer[] d = new Integer[] {a[1], a[2]};\n      Integer[] e = new Integer[] {a[2], a[3], a[4], a[5]};\n      Integer[] f = new Integer[] {a[7], a[8], a[9]};\n      Integer[] g = new Integer[] {a[7], new Integer(8), a[9]};\n      Integer[] h = new Integer[] {a[7], a[8], a[9], new Integer(10)};\n      @SuppressWarnings(\"nullness\") // accommodates poor annotation on indexOf(Object[], Object[])\n      Integer[] i = new Integer[] {a[7], a[8], null, a[9], new Integer(10)};\n      @SuppressWarnings(\"nullness\") // accommodates poor annotation on indexOf(Object[], Object[])\n      Integer[] j = new Integer[] {a[8], null, a[9]};\n      Integer[] c2 = new Integer[] {new Integer(0), new Integer(1), new Integer(2)};\n      Integer[] d2 = new Integer[] {new Integer(1), new Integer(2)};\n      Integer[] e2 = new Integer[] {new Integer(2), new Integer(3), new Integer(4), new Integer(5)};\n      Integer[] f2 = new Integer[] {new Integer(7), new Integer(8), new Integer(9)};\n\n      assert ArraysMDE.indexOf(a, b) == 0;\n      assert ArraysMDE.indexOfEq(a, b) == 0;\n      assert ArraysMDE.indexOf(a, c) == 0;\n      assert ArraysMDE.indexOfEq(a, c) == 0;\n      assert ArraysMDE.indexOf(a, c2) == 0;\n      assert ArraysMDE.indexOfEq(a, c2) == -1;\n      assert ArraysMDE.indexOf(a, d) == 1;\n      assert ArraysMDE.indexOfEq(a, d) == 1;\n      assert ArraysMDE.indexOf(a, d2) == 1;\n      assert ArraysMDE.indexOfEq(a, d2) == -1;\n      assert ArraysMDE.indexOf(a, e) == 2;\n      assert ArraysMDE.indexOfEq(a, e) == 2;\n      assert ArraysMDE.indexOf(a, e2) == 2;\n      assert ArraysMDE.indexOfEq(a, e2) == -1;\n      assert ArraysMDE.indexOf(a, f) == 7;\n      assert ArraysMDE.indexOfEq(a, f) == 7;\n      assert ArraysMDE.indexOf(a, f2) == 7;\n      assert ArraysMDE.indexOfEq(a, f2) == -1;\n      assert ArraysMDE.indexOf(a, g) == 7;\n      assert ArraysMDE.indexOfEq(a, g) == -1;\n      assert ArraysMDE.indexOf(a, h) == -1;\n      assert ArraysMDE.indexOfEq(a, h) == -1;\n      assert ArraysMDE.indexOf(i, j) == 1;\n      assert ArraysMDE.indexOfEq(i, j) == 1;\n      assert ArraysMDE.indexOf(a, i) == -1;\n      assert ArraysMDE.indexOfEq(a, i) == -1;\n    }\n\n    // public static int indexOf(int[] a, int[] sub)\n    {\n      int[] a = new int[10];\n      for (int i = 0; i < a.length; i++) {\n        a[i] = i;\n      }\n      int[] b = new int[] {};\n      int[] c = new int[] {a[0], a[1], a[2]};\n      int[] d = new int[] {a[1], a[2]};\n      int[] e = new int[] {a[2], a[3], a[4], a[5]};\n      int[] f = new int[] {a[7], a[8], a[9]};\n      int[] g = new int[] {a[7], 22, a[9]};\n      int[] h = new int[] {a[7], a[8], a[9], 10};\n\n      assert ArraysMDE.indexOf(a, b) == 0;\n      assert ArraysMDE.indexOf(a, c) == 0;\n      assert ArraysMDE.indexOf(a, d) == 1;\n      assert ArraysMDE.indexOf(a, e) == 2;\n      assert ArraysMDE.indexOf(a, f) == 7;\n      assert ArraysMDE.indexOf(a, g) == -1;\n      assert ArraysMDE.indexOf(a, h) == -1;\n\n      // Tests pulled from actual StackAr data\n      int[] origTheArray =\n          new int[] {\n            1267757, 1267757, 1267757, 1267757, 1267757, 1267757, 1267757, 1267757, 1267757,\n            1267757, 1267757, 0, 0, 0, 0, 0, 0, 0, 0, 0\n          };\n\n      int[] postTheArray = new int[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n      assert ArraysMDE.indexOf(postTheArray, origTheArray) == -1;\n      assert ArraysMDE.indexOf(origTheArray, postTheArray) == -1;\n    }\n\n    // public static int indexOf(boolean[] a, boolean[] sub)\n    // [I'm punting on this for now; deal with it later...]\n\n    // public static Object[] subarray(Object[] a, int startindex, int length)\n    // public static byte[] subarray(byte[] a, int startindex, int length)\n    // public static boolean[] subarray(boolean[] a, int startindex, int length)\n    // public static char[] subarray(char[] a, int startindex, int length)\n    // public static double[] subarray(double[] a, int startindex, int length)\n    // public static float[] subarray(float[] a, int startindex, int length)\n    // public static int[] subarray(int[] a, int startindex, int length)\n    // public static long[] subarray(long[] a, int startindex, int length)\n    // public static short[] subarray(short[] a, int startindex, int length)\n\n    // public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)\n    // public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)\n    // public static boolean isSubarray(int[] a, int[] sub, int a_offset)\n    // public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)\n    // (The subarray tests are missing; I hope that the indexOf(..., array)\n    // operations above test them sufficiently.)\n\n    // public static String toString(Object /*@Nullable*/ [] a)\n    // public static String toStringQuoted(Object /*@Nullable*/ [] a)\n    // public static String toString(Object /*@Nullable*/ [] a, boolean quoted)\n    // public static String toString(List<?> a)\n    // public static String toStringQuoted(List<?> a)\n    // public static String toString(List<?> a, boolean quoted)\n    {\n      assert ArraysMDE.toString((Object[]) null).equals(\"null\");\n      assert ArraysMDE.toStringQuoted((Object[]) null).equals(\"null\");\n      assert ArraysMDE.toString((List<?>) null).equals(\"null\");\n      assert ArraysMDE.toStringQuoted((List<?>) null).equals(\"null\");\n      assert ArraysMDE.toStringQuoted(Arrays.asList(new Object[] {3.14, null, \"hello\"}))\n          .equals(\"[3.14, null, \\\"hello\\\"]\");\n    }\n\n    // static String toString(int[] a)\n    assert ArraysMDE.toString(new int[] {}).equals(\"[]\");\n    assert ArraysMDE.toString(new int[] {0}).equals(\"[0]\");\n    assert ArraysMDE.toString(new int[] {0, 1, 2}).equals(\"[0, 1, 2]\");\n\n    // public static boolean sorted(int[] a)\n    assert ArraysMDE.sorted(new int[] {0, 1, 2});\n    assert ArraysMDE.sorted(new int[] {0, 1, 2, 2, 3, 3});\n    assert ArraysMDE.sorted(new int[] {});\n    assert ArraysMDE.sorted(new int[] {0});\n    assert ArraysMDE.sorted(new int[] {0, 1});\n    assert !ArraysMDE.sorted(new int[] {1, 0});\n    assert !ArraysMDE.sorted(new int[] {0, 1, 2, 1, 2, 3});\n\n    // public static int noDuplicates(int[] a)\n    assert ArraysMDE.noDuplicates(new int[] {1, 2, 3, 5, 4, 0}) == true;\n    assert ArraysMDE.noDuplicates(new int[] {1, 2, 3, 5, 4, 100}) == true;\n    assert ArraysMDE.noDuplicates(new int[] {2, 2, 3, 5, 4, 0}) == false;\n    assert ArraysMDE.noDuplicates(new int[] {1, 2, 3, 5, 4, 1}) == false;\n    assert ArraysMDE.noDuplicates(new int[] {1, 2, -3, -5, 4, 0}) == true;\n    assert ArraysMDE.noDuplicates(new int[] {1, 2, -2, -2, 4, 100}) == false;\n    assert ArraysMDE.noDuplicates(new int[] {}) == true;\n    assert ArraysMDE.noDuplicates(new int[] {42}) == true;\n\n    // public static int noDuplicates(long[] a)\n    assert ArraysMDE.noDuplicates(new long[] {1, 2, 3, 5, 4, 0}) == true;\n    assert ArraysMDE.noDuplicates(new long[] {1, 2, 3, 5, 4, 100}) == true;\n    assert ArraysMDE.noDuplicates(new long[] {2, 2, 3, 5, 4, 0}) == false;\n    assert ArraysMDE.noDuplicates(new long[] {1, 2, 3, 5, 4, 1}) == false;\n    assert ArraysMDE.noDuplicates(new long[] {1, 2, -3, -5, 4, 0}) == true;\n    assert ArraysMDE.noDuplicates(new long[] {1, 2, -2, -2, 4, 100}) == false;\n    assert ArraysMDE.noDuplicates(new long[] {}) == true;\n    assert ArraysMDE.noDuplicates(new long[] {42}) == true;\n\n    // public static int noDuplicates(double[] a)\n    assert ArraysMDE.noDuplicates(new double[] {1, 2, 3, 5, 4, 0}) == true;\n    assert ArraysMDE.noDuplicates(new double[] {1, 2, 3, 5, 4, 100}) == true;\n    assert ArraysMDE.noDuplicates(new double[] {2, 2, 3, 5, 4, 0}) == false;\n    assert ArraysMDE.noDuplicates(new double[] {1, 2, 3, 5, 4, 1}) == false;\n    assert ArraysMDE.noDuplicates(new double[] {1., 1.001, -3, -5, 4, 0}) == true;\n    assert ArraysMDE.noDuplicates(new double[] {1., 2, -2.00, -2, 4, 100}) == false;\n    assert ArraysMDE.noDuplicates(new double[] {}) == true;\n    assert ArraysMDE.noDuplicates(new double[] {42}) == true;\n\n    // public static int noDuplicates(String[] a)\n    assert ArraysMDE.noDuplicates(new String[] {\"1\", \"2\", \"3\", \"5\", \"4\", \"0\"}) == true;\n    assert ArraysMDE.noDuplicates(new String[] {\"A\", \"a\", \"foo\", \"Foo\", \"\"}) == true;\n    assert ArraysMDE.noDuplicates(new String[] {\" \", \" \"}) == false;\n    assert ArraysMDE.noDuplicates(new String[] {\"  \", \" \"}) == true;\n\n    // public static boolean fn_is_permutation(int[] a)\n    assert ArraysMDE.fn_is_permutation(new int[] {0, 1, 2, 3}) == true;\n    assert ArraysMDE.fn_is_permutation(new int[] {1, 2, 3, 0}) == true;\n    assert ArraysMDE.fn_is_permutation(new int[] {3, 2, 1, 0}) == true;\n    assert ArraysMDE.fn_is_permutation(new int[] {0, 1, 2, 2}) == false;\n    assert ArraysMDE.fn_is_permutation(new int[] {0, -1, 2, 3}) == false;\n    assert ArraysMDE.fn_is_permutation(new int[] {0, 1, 2, 4}) == false;\n    assert ArraysMDE.fn_is_permutation(new int[] {0, 0, 0, 0}) == false;\n\n    // public static boolean fn_is_total(int[] a)\n    assert ArraysMDE.fn_is_total(new int[] {0, 1, 2, 3}) == true;\n    assert ArraysMDE.fn_is_total(new int[] {1, 2, 3, 0}) == true;\n    assert ArraysMDE.fn_is_total(new int[] {3, 2, 1, 0}) == true;\n    assert ArraysMDE.fn_is_total(new int[] {0, 1, 2, 2}) == true;\n    assert ArraysMDE.fn_is_total(new int[] {-1, 0, 2, 3}) == false;\n    assert ArraysMDE.fn_is_total(new int[] {0, -1, 2, 3}) == false;\n    assert ArraysMDE.fn_is_total(new int[] {0, -2, 1, 3}) == true; // weird\n    assert ArraysMDE.fn_is_total(new int[] {0, 2, 3, -1}) == false;\n    assert ArraysMDE.fn_is_total(new int[] {0, 1, 2, 4}) == true;\n    assert ArraysMDE.fn_is_total(new int[] {0, 0, 0, 0}) == true;\n\n    // public static int[] fn_identity(int length)\n    assert_arrays_equals(ArraysMDE.fn_identity(0), new int[] {});\n    assert_arrays_equals(ArraysMDE.fn_identity(1), new int[] {0});\n    assert_arrays_equals(ArraysMDE.fn_identity(2), new int[] {0, 1});\n    assert_arrays_equals(ArraysMDE.fn_identity(3), new int[] {0, 1, 2});\n\n    // public static int[] fn_inverse_permutation(int[] a)\n    assert_arrays_equals(\n        ArraysMDE.fn_inverse_permutation(new int[] {0, 1, 2, 3}), new int[] {0, 1, 2, 3});\n    assert_arrays_equals(\n        ArraysMDE.fn_inverse_permutation(new int[] {1, 2, 3, 0}), new int[] {3, 0, 1, 2});\n    assert_arrays_equals(\n        ArraysMDE.fn_inverse_permutation(new int[] {3, 2, 1, 0}), new int[] {3, 2, 1, 0});\n\n    // public static int[] fn_inverse(int[] a, int arange)\n    assert_arrays_equals(ArraysMDE.fn_inverse(new int[] {0, 1, 2, 3}, 4), new int[] {0, 1, 2, 3});\n    assert_arrays_equals(ArraysMDE.fn_inverse(new int[] {1, 2, 3, 0}, 4), new int[] {3, 0, 1, 2});\n    assert_arrays_equals(ArraysMDE.fn_inverse(new int[] {3, 2, 1, 0}, 4), new int[] {3, 2, 1, 0});\n    try {\n      ArraysMDE.fn_inverse(new int[] {1, 0, 3, 0}, 4);\n      throw new Error();\n    } catch (UnsupportedOperationException e) {\n      assert e.getMessage() != null && e.getMessage().equals(\"Not invertible; a[1]=0 and a[3]=0\");\n    }\n    assert_arrays_equals(ArraysMDE.fn_inverse(new int[] {5}, 6), new int[] {-1, -1, -1, -1, -1, 0});\n    assert_arrays_equals(\n        ArraysMDE.fn_inverse(new int[] {1, 2, 3, 5}, 6), new int[] {-1, 0, 1, 2, -1, 3});\n\n    try {\n      assert_arrays_equals(\n          ArraysMDE.fn_inverse(new int[] {100, 101, 102, 103}, 4), new int[] {40, 41, 42, 43});\n      throw new Error();\n    } catch (IllegalArgumentException e) {\n      assert e.getMessage() != null && e.getMessage().equals(\"Bad range value: a[0]=100\");\n    }\n\n    // public static int[] fn_compose(int[] a, int[] b)\n    assert_arrays_equals(\n        ArraysMDE.fn_compose(new int[] {0, 1, 2, 3}, new int[] {0, 1, 2, 3}),\n        new int[] {0, 1, 2, 3});\n    assert_arrays_equals(\n        ArraysMDE.fn_compose(new int[] {1, 2, 3, 0}, new int[] {1, 2, 3, 0}),\n        new int[] {2, 3, 0, 1});\n    assert_arrays_equals(\n        ArraysMDE.fn_compose(new int[] {3, 2, 1, 0}, new int[] {3, 2, 1, 0}),\n        new int[] {0, 1, 2, 3});\n    assert_arrays_equals(\n        ArraysMDE.fn_compose(new int[] {0, 1, 0, 3}, new int[] {0, 5, 2, 1}),\n        new int[] {0, 5, 0, 1});\n    assert_arrays_equals(ArraysMDE.fn_compose(new int[] {0}, new int[] {5}), new int[] {5});\n    assert_arrays_equals(\n        ArraysMDE.fn_compose(new int[] {1, 2, 3, 5}, new int[] {1, 2, 3, 5, -1, -1}),\n        new int[] {2, 3, 5, -1});\n\n    // public static boolean isSubset(long[] smaller, long[] bigger)\n    // public static boolean isSubset(double[] smaller, double[] bigger)\n    // public static boolean isSubset(String[] smaller, String[] bigger)\n\n    {\n      double[] f1 = new double[10];\n      double[] f2 = new double[20];\n\n      for (int j = 0; j < f2.length; j++) {\n        f2[j] = j;\n      }\n      for (int i = 0; i < f2.length - f1.length; i++) {\n\n        //fill up f1 with elements of f2\n        for (int j = 0; j < f1.length; j++) {\n          f1[j] = f2[i + j];\n        }\n\n        f1[5] = f2[i];\n\n        double[] f1_copy = f1.clone();\n        double[] f2_copy = f2.clone();\n\n        assert ArraysMDE.isSubset(f1, f2);\n        assert_arrays_equals(f1, f1_copy);\n        assert_arrays_equals(f2, f2_copy);\n      }\n\n      double[] a1 = new double[] {1, 5, 10};\n      double[] a2 = new double[] {};\n      double[] a3 = new double[] {1};\n      double[] a4 = new double[] {10};\n      double[] a5 = new double[] {1, 10, 15, 20};\n      double[] a6 = new double[] {10, 10, 10, 10, 10, 1};\n\n      assert ArraysMDE.isSubset(a2, a1);\n      assert !ArraysMDE.isSubset(a1, a2);\n      assert !ArraysMDE.isSubset(a1, a5);\n      assert ArraysMDE.isSubset(a3, a1);\n      assert ArraysMDE.isSubset(a4, a1);\n      assert ArraysMDE.isSubset(a6, a1);\n      assert !ArraysMDE.isSubset(a1, a6);\n    }\n\n    // public static class IntArrayComparatorLexical implements Comparator\n    // public static class IntArrayComparatorLengthFirst implements Comparator\n    {\n      Comparator<int[]> iacl = new ArraysMDE.IntArrayComparatorLexical();\n      Comparator<int[]> iaclf = new ArraysMDE.IntArrayComparatorLengthFirst();\n\n      int[] a0 = new int[] {};\n      int[] a1 = new int[] {};\n      int[] a2 = new int[] {0, 1, 2, 3};\n      int[] a3 = new int[] {0, 1, 2, 3, 0};\n      int[] a4 = new int[] {0, 1, 2, 3, 4};\n      int[] a5 = new int[] {0, 1, 2, 3, 4};\n      int[] a6 = new int[] {0, 1, 5, 3, 4};\n      int[] a7 = new int[] {1, 2, 3, 4};\n      int[] a8 = new int[] {-5};\n      int[] a9 = new int[] {Integer.MAX_VALUE};\n      int[] a10 = new int[] {Integer.MIN_VALUE};\n\n      assert iacl.compare(a0, a1) == 0;\n      assert iaclf.compare(a0, a1) == 0;\n      assert iacl.compare(a1, a0) == 0;\n      assert iaclf.compare(a1, a0) == 0;\n      assert iacl.compare(a1, a2) < 0;\n      assert iaclf.compare(a1, a2) < 0;\n      assert iacl.compare(a2, a1) > 0;\n      assert iaclf.compare(a2, a1) > 0;\n      assert iacl.compare(a2, a3) < 0;\n      assert iaclf.compare(a2, a3) < 0;\n      assert iacl.compare(a3, a2) > 0;\n      assert iaclf.compare(a3, a2) > 0;\n      assert iacl.compare(a3, a4) < 0;\n      assert iaclf.compare(a3, a4) < 0;\n      assert iacl.compare(a4, a3) > 0;\n      assert iaclf.compare(a4, a3) > 0;\n      assert iacl.compare(a4, a5) == 0;\n      assert iaclf.compare(a4, a5) == 0;\n      assert iacl.compare(a5, a4) == 0;\n      assert iaclf.compare(a5, a4) == 0;\n      assert iacl.compare(a5, a6) < 0;\n      assert iaclf.compare(a5, a6) < 0;\n      assert iacl.compare(a6, a5) > 0;\n      assert iaclf.compare(a6, a5) > 0;\n      assert iacl.compare(a6, a7) < 0;\n      assert iaclf.compare(a6, a7) > 0;\n      assert iacl.compare(a7, a6) > 0;\n      assert iaclf.compare(a7, a6) < 0;\n      assert iacl.compare(a1, a4) < 0;\n      assert iaclf.compare(a1, a4) < 0;\n      assert iacl.compare(a4, a1) > 0;\n      assert iaclf.compare(a4, a1) > 0;\n      assert iacl.compare(a2, a4) < 0;\n      assert iaclf.compare(a2, a4) < 0;\n      assert iacl.compare(a4, a2) > 0;\n      assert iaclf.compare(a4, a2) > 0;\n      assert iacl.compare(a6, a4) > 0;\n      assert iaclf.compare(a6, a4) > 0;\n      assert iacl.compare(a4, a6) < 0;\n      assert iaclf.compare(a4, a6) < 0;\n      assert iacl.compare(a7, a4) > 0;\n      assert iaclf.compare(a7, a4) < 0;\n      assert iacl.compare(a4, a7) < 0;\n      assert iaclf.compare(a4, a7) > 0;\n      assert iacl.compare(a8, a9) < 0;\n      assert iaclf.compare(a8, a9) < 0;\n      assert iacl.compare(a10, a7) < 0;\n    }\n\n    // public static class LongArrayComparatorLexical implements Comparator\n    // public static class LongArrayComparatorLengthFirst implements Comparator\n    {\n      Comparator<long[]> lacl = new ArraysMDE.LongArrayComparatorLexical();\n      Comparator<long[]> laclf = new ArraysMDE.LongArrayComparatorLengthFirst();\n      long[] a0 = new long[] {};\n      long[] a1 = new long[] {};\n      long[] a2 = new long[] {0, 1, 2, 3};\n      long[] a3 = new long[] {0, 1, 2, 3, 0};\n      long[] a4 = new long[] {0, 1, 2, 3, 4};\n      long[] a5 = new long[] {0, 1, 2, 3, 4};\n      long[] a6 = new long[] {0, 1, 5, 3, 4};\n      long[] a7 = new long[] {1, 2, 3, 4};\n      long[] a8 = new long[] {-5};\n      long[] a9 = new long[] {Long.MAX_VALUE};\n      long[] a10 = new long[] {Long.MIN_VALUE};\n\n      assert lacl.compare(a0, a1) == 0;\n      assert laclf.compare(a0, a1) == 0;\n      assert lacl.compare(a1, a0) == 0;\n      assert laclf.compare(a1, a0) == 0;\n      assert lacl.compare(a1, a2) < 0;\n      assert laclf.compare(a1, a2) < 0;\n      assert lacl.compare(a2, a1) > 0;\n      assert laclf.compare(a2, a1) > 0;\n      assert lacl.compare(a2, a3) < 0;\n      assert laclf.compare(a2, a3) < 0;\n      assert lacl.compare(a3, a2) > 0;\n      assert laclf.compare(a3, a2) > 0;\n      assert lacl.compare(a3, a4) < 0;\n      assert laclf.compare(a3, a4) < 0;\n      assert lacl.compare(a4, a3) > 0;\n      assert laclf.compare(a4, a3) > 0;\n      assert lacl.compare(a4, a5) == 0;\n      assert laclf.compare(a4, a5) == 0;\n      assert lacl.compare(a5, a4) == 0;\n      assert laclf.compare(a5, a4) == 0;\n      assert lacl.compare(a5, a6) < 0;\n      assert laclf.compare(a5, a6) < 0;\n      assert lacl.compare(a6, a5) > 0;\n      assert laclf.compare(a6, a5) > 0;\n      assert lacl.compare(a6, a7) < 0;\n      assert laclf.compare(a6, a7) > 0;\n      assert lacl.compare(a7, a6) > 0;\n      assert laclf.compare(a7, a6) < 0;\n      assert lacl.compare(a1, a4) < 0;\n      assert laclf.compare(a1, a4) < 0;\n      assert lacl.compare(a4, a1) > 0;\n      assert laclf.compare(a4, a1) > 0;\n      assert lacl.compare(a2, a4) < 0;\n      assert laclf.compare(a2, a4) < 0;\n      assert lacl.compare(a4, a2) > 0;\n      assert laclf.compare(a4, a2) > 0;\n      assert lacl.compare(a6, a4) > 0;\n      assert laclf.compare(a6, a4) > 0;\n      assert lacl.compare(a4, a6) < 0;\n      assert laclf.compare(a4, a6) < 0;\n      assert lacl.compare(a7, a4) > 0;\n      assert laclf.compare(a7, a4) < 0;\n      assert lacl.compare(a4, a7) < 0;\n      assert laclf.compare(a4, a7) > 0;\n      assert lacl.compare(a8, a9) < 0;\n      assert laclf.compare(a8, a9) < 0;\n      assert lacl.compare(a10, a7) < 0;\n    }\n\n    // public static class DoubleArrayComparatorLexical implements Comparator\n    {\n      Comparator<double[]> dacl = new ArraysMDE.DoubleArrayComparatorLexical();\n      double[] a0 = new double[] {};\n      double[] a1 = new double[] {};\n      double[] a2 = new double[] {0, 1, 2, 3};\n      double[] a3 = new double[] {0, 1, 2, 3, 0};\n      double[] a4 = new double[] {0, 1, 2, 3, 4};\n      double[] a5 = new double[] {0, 1, 2, 3, 4};\n      double[] a6 = new double[] {0, 1, 5, 3, 4};\n      double[] a7 = new double[] {1, 2, 3, 4};\n      double[] a8 = new double[] {0.005};\n      double[] a9 = new double[] {0.004};\n      double[] a10 = new double[] {-0.005};\n      double[] a11 = new double[] {-0.004};\n      double[] a12 = new double[] {10.0 * Integer.MAX_VALUE};\n      double[] a13 = new double[] {10.0 * Integer.MIN_VALUE};\n\n      assert dacl.compare(a0, a1) == 0;\n      assert dacl.compare(a1, a0) == 0;\n      assert dacl.compare(a1, a2) < 0;\n      assert dacl.compare(a2, a1) > 0;\n      assert dacl.compare(a2, a3) < 0;\n      assert dacl.compare(a3, a2) > 0;\n      assert dacl.compare(a3, a4) < 0;\n      assert dacl.compare(a4, a3) > 0;\n      assert dacl.compare(a4, a5) == 0;\n      assert dacl.compare(a5, a4) == 0;\n      assert dacl.compare(a5, a6) < 0;\n      assert dacl.compare(a6, a5) > 0;\n      assert dacl.compare(a6, a7) < 0;\n      assert dacl.compare(a7, a6) > 0;\n      assert dacl.compare(a1, a4) < 0;\n      assert dacl.compare(a4, a1) > 0;\n      assert dacl.compare(a2, a4) < 0;\n      assert dacl.compare(a4, a2) > 0;\n      assert dacl.compare(a6, a4) > 0;\n      assert dacl.compare(a4, a6) < 0;\n      assert dacl.compare(a7, a4) > 0;\n      assert dacl.compare(a4, a7) < 0;\n\n      // Test the comparisons on small/large numbers\n      assert dacl.compare(a8, a9) > 0;\n      assert dacl.compare(a10, a11) < 0;\n      assert dacl.compare(a11, a12) < 0;\n      assert dacl.compare(a12, a13) > 0;\n      assert dacl.compare(a13, a11) < 0;\n    }\n\n    // public static class ObjectArrayComparatorLexical implements Comparator\n    // public static class ObjectArrayComparatorLengthFirst implements Comparator\n\n    // public static final class ComparableArrayComparatorLexical implements Comparator\n    // public static final class ComparableArrayComparatorLengthFirst implements Comparator\n    {\n      Comparator<String[]> cacl = new ArraysMDE.ComparableArrayComparatorLexical<String>();\n      Comparator<String[]> caclf = new ArraysMDE.ComparableArrayComparatorLengthFirst<String>();\n      String[] a0 = new String[] {};\n      String[] a1 = new String[] {};\n      String[] a2 = new String[] {\"0\", \"1\", \"2\", \"3\"};\n      String[] a3 = new String[] {\"0\", \"1\", \"2\", \"3\", \"0\"};\n      String[] a4 = new String[] {\"0\", \"1\", \"2\", \"3\", \"4\"};\n      String[] a5 = new String[] {\"0\", \"1\", \"2\", \"3\", \"4\"};\n      String[] a6 = new String[] {\"0\", \"1\", \"5\", \"3\", \"4\"};\n      String[] a7 = new String[] {\"1\", \"2\", \"3\", \"4\"};\n      @SuppressWarnings(\n          \"nullness\") // accommodates poor annotation on ComparableArrayComparatorLexical.compare() and ComparableArrayComparatorLengthFirst.compare()\n      String[] a8 = new String[] {\"0\", \"1\", null, \"3\", \"4\"};\n\n      assert cacl.compare(a0, a1) == 0;\n      assert caclf.compare(a0, a1) == 0;\n      assert cacl.compare(a1, a0) == 0;\n      assert caclf.compare(a1, a0) == 0;\n      assert cacl.compare(a1, a2) < 0;\n      assert caclf.compare(a1, a2) < 0;\n      assert cacl.compare(a2, a1) > 0;\n      assert caclf.compare(a2, a1) > 0;\n      assert cacl.compare(a2, a3) < 0;\n      assert caclf.compare(a2, a3) < 0;\n      assert cacl.compare(a3, a2) > 0;\n      assert caclf.compare(a3, a2) > 0;\n      assert cacl.compare(a3, a4) < 0;\n      assert caclf.compare(a3, a4) < 0;\n      assert cacl.compare(a4, a3) > 0;\n      assert caclf.compare(a4, a3) > 0;\n      assert cacl.compare(a4, a5) == 0;\n      assert caclf.compare(a4, a5) == 0;\n      assert cacl.compare(a5, a4) == 0;\n      assert caclf.compare(a5, a4) == 0;\n      assert cacl.compare(a5, a6) < 0;\n      assert caclf.compare(a5, a6) < 0;\n      assert cacl.compare(a6, a5) > 0;\n      assert caclf.compare(a6, a5) > 0;\n      assert cacl.compare(a6, a7) < 0;\n      assert caclf.compare(a6, a7) > 0;\n      assert cacl.compare(a7, a6) > 0;\n      assert caclf.compare(a7, a6) < 0;\n      assert cacl.compare(a1, a4) < 0;\n      assert caclf.compare(a1, a4) < 0;\n      assert cacl.compare(a4, a1) > 0;\n      assert caclf.compare(a4, a1) > 0;\n      assert cacl.compare(a2, a4) < 0;\n      assert caclf.compare(a2, a4) < 0;\n      assert cacl.compare(a4, a2) > 0;\n      assert caclf.compare(a4, a2) > 0;\n      assert cacl.compare(a6, a4) > 0;\n      assert caclf.compare(a6, a4) > 0;\n      assert cacl.compare(a4, a6) < 0;\n      assert caclf.compare(a4, a6) < 0;\n      assert cacl.compare(a7, a4) > 0;\n      assert caclf.compare(a7, a4) < 0;\n      assert cacl.compare(a8, a1) > 0;\n      assert caclf.compare(a8, a1) > 0;\n      assert cacl.compare(a1, a8) < 0;\n      assert caclf.compare(a1, a8) < 0;\n      assert cacl.compare(a8, a2) < 0;\n      assert caclf.compare(a8, a2) > 0;\n      assert cacl.compare(a2, a8) > 0;\n      assert caclf.compare(a2, a8) < 0;\n      assert cacl.compare(a8, a3) < 0;\n      assert caclf.compare(a8, a3) < 0;\n      assert cacl.compare(a3, a8) > 0;\n      assert caclf.compare(a3, a8) > 0;\n    }\n\n    // public static boolean any_null(Object[] a)\n    {\n      Object o = new Object();\n      assert ArraysMDE.any_null(new Object[] {}) == false;\n      assert ArraysMDE.any_null(new Object[] {null}) == true;\n      assert ArraysMDE.any_null(new Object[] {null, null}) == true;\n      assert ArraysMDE.any_null(new Object[] {o}) == false;\n      assert ArraysMDE.any_null(new Object[] {o, o}) == false;\n      assert ArraysMDE.any_null(new Object[] {o, null, null}) == true;\n      assert ArraysMDE.any_null(new Object[] {null, o, null}) == true;\n      assert ArraysMDE.any_null(new Object[] {o, null, o}) == true;\n      assert ArraysMDE.any_null(new Object[] {null, o, o}) == true;\n      assert ArraysMDE.any_null(new Object[][] {}) == false;\n      assert ArraysMDE.any_null(new Object[][] {null}) == true;\n      // Extraneous @Nullable on the following lines are due to CF issue #599:\n      // https://github.com/typetools/checker-framework/issues/599\n      assert ArraysMDE.any_null(new /*@Nullable*/ Object[][] {new Object[] {null}}) == false;\n      assert ArraysMDE.any_null(new /*@Nullable*/ Object[][] {new Object[] {null}, null}) == true;\n      assert ArraysMDE.any_null(\n              new /*@Nullable*/ Object[][] {new Object[] {null}, new Object[] {o}})\n          == false;\n    }\n\n    // public static boolean all_null(Object[] a)\n    {\n      Object o = new Object();\n      assert ArraysMDE.all_null(new Object[] {}) == true;\n      assert ArraysMDE.all_null(new Object[] {null}) == true;\n      assert ArraysMDE.all_null(new Object[] {null, null}) == true;\n      assert ArraysMDE.all_null(new Object[] {o}) == false;\n      assert ArraysMDE.all_null(new Object[] {o, o}) == false;\n      assert ArraysMDE.all_null(new Object[] {o, null, null}) == false;\n      assert ArraysMDE.all_null(new Object[] {null, o, null}) == false;\n      assert ArraysMDE.all_null(new Object[] {o, null, o}) == false;\n      assert ArraysMDE.all_null(new Object[] {null, o, o}) == false;\n      assert ArraysMDE.all_null(new Object[][] {}) == true;\n      assert ArraysMDE.all_null(new Object[][] {null}) == true;\n      assert ArraysMDE.all_null(new Object[][] {null, null}) == true;\n      assert ArraysMDE.all_null(new /*@Nullable*/ Object[][] {new Object[] {null}}) == false;\n      assert ArraysMDE.all_null(new /*@Nullable*/ Object[][] {new Object[] {null}, null}) == false;\n      assert ArraysMDE.all_null(\n              new /*@Nullable*/ Object[][] {new Object[] {null}, new Object[] {o}})\n          == false;\n    }\n  }\n\n  // This cannot be static because it instantiates an inner class.\n  @Test\n  public void testHasher() {\n\n    /// To check (maybe some of these are done already).\n    /// All of these methods are in Intern; should the tests appear in\n    /// testIntern() or here?\n    // public static void internStrings(String[] a)\n    // public static boolean isInterned(Object value)\n    // public static int numIntegers()\n    // public static int numIntArrays()\n    // public static int numDoubles()\n    // public static int numDoubleArrays()\n    // public static int numObjectArrays()\n    // public static Iterator integers()\n    // public static Iterator intArrays()\n    // public static Iterator doubles()\n    // public static Iterator doubleArrays()\n    // public static Iterator objectArrays()\n    // public static Integer intern(Integer a)\n    // public static Integer internedInteger(int i)\n    // public static Integer internedInteger(String s)\n    // public static int[] intern(int[] a)\n    // public static Double intern(Double a)\n    // public static Double internedDouble(int i)\n    // public static Double internedDouble(String s)\n    // public static double[] intern(double[] a)\n    // public static Object[] intern(Object[] a)\n\n    // private static class IntArrayHasher implements Hasher\n    // private static class ObjectArrayHasher implements Hasher\n    // public static int[] intern(int[] a)\n    // public static Object[] intern(Object[] a)\n\n    class InternTest {\n      // javadoc won't let this be static.\n      void test(boolean random) {\n        int size1 = (random ? 100 : 1);\n        int size2 = (random ? 10 : 1);\n\n        Random random_gen = new Random();\n\n        int[][] arrays = new int[100][];\n        for (int i = 0; i < arrays.length; i++) {\n          int[] a = new int[10];\n          for (int j = 0; j < a.length; j++) {\n            if (random) {\n              a[j] = random_gen.nextInt(1000);\n            } else {\n              a[j] = j;\n            }\n          }\n          arrays[i] = a;\n          // System.out.println(ArraysMDE.toString(a));\n          // Sadly, this is required to get the last array to be\n          // garbage-collected with Jikes 1.03 and JDK 1.2.2.\n          a = null;\n        }\n        System.gc();\n        if (Intern.numIntArrays() != 0) {\n          throw new Error(\" expected 0 int arrays at start, found \" + Intern.numIntArrays());\n        }\n        for (int i = 0; i < arrays.length; i++) {\n          Intern.intern(arrays[i]);\n        }\n        if (Intern.numIntArrays() != size1) {\n          throw new Error(\"Expected \" + size1 + \", got \" + Intern.numIntArrays() + \" int arrays\");\n        }\n        System.gc();\n        if (Intern.numIntArrays() != size1) {\n          throw new Error();\n        }\n        for (int i = 10; i < arrays.length; i++) {\n          @SuppressWarnings(\"nullness\")\n          int /*@NonNull*/ [] reset_value = null;\n          arrays[i] = reset_value;\n        }\n        System.gc();\n        if (Intern.numIntArrays() != size2) {\n          if (Intern.numIntArrays() < size2 + 10) {\n            System.out.println(\n                \"Is JIT disabled?  Size should have been \"\n                    + size2\n                    + \", actually was \"\n                    + Intern.numIntArrays());\n          } else {\n            System.out.println(\"================\");\n            for (int i = 0; i < arrays.length; i++) {\n              System.out.println(ArraysMDE.toString(arrays[i]));\n            }\n            System.out.println(\"================\");\n            for (Iterator<int[]> itor = Intern.intArrays(); itor.hasNext(); ) {\n              System.out.println(ArraysMDE.toString(itor.next()));\n            }\n            String message =\n                (\"Size should have been \" + size2 + \", actually was \" + Intern.numIntArrays());\n            System.out.println(message);\n            throw new Error(message);\n          }\n        }\n      }\n    }\n\n    InternTest intern = new InternTest();\n    intern.test(true);\n    intern.test(false);\n  }\n\n  @Test\n  public void testIntern() {\n    Integer i = Intern.internedInteger(\"1234\");\n    assert Intern.isInterned(i);\n    assert i.intValue() == 1234;\n    i = Intern.internedInteger(\"0x12ab\");\n    assert Intern.isInterned(i);\n    assert i.intValue() == 0x12ab;\n\n    Long l = Intern.internedLong(\"12345678\");\n    assert Intern.isInterned(l);\n    assert l.intValue() == 12345678;\n    l = Intern.internedLong(\"0x1234abcd\");\n    assert Intern.isInterned(l);\n    assert l.intValue() == 0x1234abcd;\n  }\n\n  // Tests the method \"Object intern(Object)\" in Intern.java\n  @Test\n  public void testInternObject() {\n    Object nIntern = Intern.intern((/*@Nullable*/ Object) null);\n    assert nIntern == null;\n\n    String sOrig = new String(\"foo\");\n    String sIntern = Intern.intern(sOrig);\n    Object sObjIntern = Intern.intern((Object) sOrig);\n    assert sIntern == sObjIntern;\n    Object sOtherIntern = Intern.intern(new String(\"foo\"));\n    assert sIntern == sOtherIntern;\n\n    String[] saOrig = new String[] {\"foo\", \"bar\"};\n    String[] saIntern = Intern.intern(saOrig);\n    Object saObjIntern = Intern.intern((Object) saOrig);\n    assert saIntern == saObjIntern;\n    Object saOtherIntern = Intern.intern(new String[] {\"foo\", \"bar\"});\n    assert saIntern == saOtherIntern;\n\n    Integer iOrig = new Integer(1);\n    Integer iIntern = Intern.intern(iOrig);\n    Object iObjIntern = Intern.intern((Object) iOrig);\n    assert iIntern == iObjIntern;\n    Object iOtherIntern = Intern.intern((Object) new Integer(1));\n    assert iIntern == iOtherIntern;\n\n    Long lOrig = new Long(12345678901234L);\n    Long lIntern = Intern.intern(lOrig);\n    Object lObjIntern = Intern.intern((Object) lOrig);\n    assert lIntern == lObjIntern;\n    Object lOtherIntern = Intern.intern((Object) new Long(12345678901234L));\n    assert lIntern == lOtherIntern;\n\n    int[] iaOrig = new int[] {1, 2, 3};\n    int[] iaIntern = Intern.intern(iaOrig);\n    Object iaObjIntern = Intern.intern((Object) iaOrig);\n    assert iaIntern == iaObjIntern;\n    Object iaOtherIntern = Intern.intern((Object) new int[] {1, 2, 3});\n    assert iaIntern == iaOtherIntern;\n\n    long[] laOrig = new long[] {12345678901234L, 98765432109876L};\n    long[] laIntern = Intern.intern(laOrig);\n    Object laObjIntern = Intern.intern((Object) laOrig);\n    assert laIntern == laObjIntern;\n    Object laOtherIntern = Intern.intern((Object) new long[] {12345678901234L, 98765432109876L});\n    assert laIntern == laOtherIntern;\n\n    // Need to test positive and negative zeros, infinities.\n\n    Double dOrig = new Double(3.14);\n    Double dIntern = Intern.intern(dOrig);\n    Object dObjIntern = Intern.intern((Object) dOrig);\n    assert dIntern == dObjIntern;\n    Object dOtherIntern = Intern.intern((Object) dOrig);\n    assert dIntern == dOtherIntern;\n\n    Double dnOrig = new Double(Double.NaN);\n    Double dnIntern = Intern.intern(dnOrig);\n    Object dnObjIntern = Intern.intern((Object) dnOrig);\n    assert dnIntern == dnObjIntern;\n    Object dnOtherIntern =\n        Intern.intern((Object) new Double(Double.POSITIVE_INFINITY / Double.POSITIVE_INFINITY));\n    assert dnIntern == dnOtherIntern;\n\n    Double diOrig = new Double(Double.POSITIVE_INFINITY);\n    Double diIntern = Intern.intern(diOrig);\n    Object diObjIntern = Intern.intern((Object) diOrig);\n    assert diIntern == diObjIntern;\n    Object diOtherIntern = Intern.intern((Object) new Double(2 * Double.MAX_VALUE));\n    assert diIntern == diOtherIntern;\n\n    double positive_zero = +0.0;\n    double negative_zero = -0.0;\n    assert positive_zero == negative_zero;\n    assert 1 / positive_zero == Double.POSITIVE_INFINITY;\n    assert 1 / negative_zero == Double.NEGATIVE_INFINITY;\n\n    Double dzOrig = new Double(positive_zero);\n    Double dzIntern = Intern.intern(dzOrig);\n    Object dzObjIntern = Intern.intern((Object) dzOrig);\n    assert dzIntern == dzObjIntern;\n    Object dzOtherIntern = Intern.intern((Object) new Double(negative_zero));\n    assert dzIntern == dzOtherIntern;\n\n    double[] daOrig = new double[] {3.14, 2.71};\n    double[] daIntern = Intern.intern(daOrig);\n    Object daObjIntern = Intern.intern((Object) daOrig);\n    assert daIntern == daObjIntern;\n    Object daOtherIntern = Intern.intern((Object) new double[] {3.14, 2.71});\n    assert daIntern == daOtherIntern;\n\n    double[] da2Orig = new double[] {+0.0, Double.NaN};\n    double[] da2Intern = Intern.intern(da2Orig);\n    Object da2ObjIntern = Intern.intern((Object) da2Orig);\n    assert da2Intern == da2ObjIntern;\n    Object da2OtherIntern =\n        Intern.intern(\n            (Object) new double[] {-0.0, Double.POSITIVE_INFINITY / Double.POSITIVE_INFINITY});\n    assert da2Intern == da2OtherIntern;\n\n    Object[] oaOrig = new Object[] {new String(\"foo\"), new Integer(1)};\n    Object[] oaIntern = Intern.intern(oaOrig);\n    Object oaObjIntern = Intern.intern((Object) oaOrig);\n    assert oaIntern == oaObjIntern;\n    Object oaOtherIntern = Intern.intern((Object) new Object[] {new String(\"foo\"), new Integer(1)});\n    assert oaIntern == oaOtherIntern;\n\n    java.awt.Point pOrig = new java.awt.Point(1, 2);\n    try {\n      Intern.intern((Object) pOrig); // performed for side effect\n      throw new Error(\"Didn't throw IllegalArgumentException\");\n    } catch (IllegalArgumentException e) {\n    }\n  }\n\n  // Add 100 elements randomly selected from the range 0..limit-1 to the set.\n  private static void lsis_add_elts(int limit, LimitedSizeSet<Integer> s) {\n    Random r = new Random(20140613);\n    for (int i = 0; i < 100; i++) {\n      s.add(r.nextInt(limit));\n    }\n  }\n\n  // Create a LimitedSizeSet of the given size, and add elements to it.\n  private static void lsis_test(int max_size) {\n    LimitedSizeSet<Integer> s = new LimitedSizeSet<Integer>(max_size);\n    for (int i = 1; i < 2 * max_size; i++) {\n      lsis_add_elts(i, s);\n      int size = s.size();\n      assert ((i <= max_size) ? (size == i) : (size == max_size + 1))\n          : String.format(\n              \"(%d<=%d) ? (%d==%d) : (%d==%d+1)   size=%d, i=%d, max_size=%d, s=%s\",\n              i,\n              max_size,\n              size,\n              i,\n              size,\n              max_size,\n              size,\n              i,\n              max_size,\n              s);\n    }\n  }\n\n  private static void lss_with_null_test() {\n    LimitedSizeSet</*@Nullable*/ Integer> s = new LimitedSizeSet</*@Nullable*/ Integer>(10);\n    s.add(1);\n    s.add(2);\n    s.add(null);\n    assert s.size() == 3;\n    assert s.contains(1);\n    assert s.contains(null);\n    s.add(3);\n    assert s.size() == 4;\n    assert s.contains(1);\n    assert s.contains(null);\n    assert s.contains(3);\n  }\n\n  @Test\n  public void testLimitedSizeSet() {\n    for (int i = 1; i < 10; i++) {\n      lsis_test(i);\n    }\n    lss_with_null_test();\n  }\n\n  // This cannot be static because it instantiates an inner class.\n  @Test\n  public void testMathMDE() {\n\n    // int negate(int a)\n    assert MathMDE.negate(3) == -3;\n    assert MathMDE.negate(-22) == 22;\n    assert MathMDE.negate(0) == 0;\n\n    // int bitwiseComplement(int a)\n    assert MathMDE.bitwiseComplement(3) == -4;\n    assert MathMDE.bitwiseComplement(-22) == 21;\n    assert MathMDE.bitwiseComplement(0) == -1;\n\n    // int sign(int a)\n    assert MathMDE.sign(3) == 1;\n    assert MathMDE.sign(-22) == -1;\n    assert MathMDE.sign(0) == 0;\n\n    // int pow(int base, int expt)\n    try {\n      assert MathMDE.pow(3, 3) == 27;\n      assert MathMDE.pow(-5, 5) == -3125;\n      assert MathMDE.pow(22, 0) == 1;\n      assert MathMDE.pow(4, 6) == 4096;\n      assert MathMDE.pow(1, 222222) == 1;\n      assert MathMDE.pow(-2, 25) == -33554432;\n      // This is beyond the precision.  Maybe return a long instead of an int?\n      // assert MathMDE.pow(-3, 25) == ...;\n    } catch (Exception e) {\n      e.printStackTrace();\n      throw new Error(e);\n    }\n    try {\n      MathMDE.pow(3, -3);\n      throw new Error(\"Didn't throw ArithmeticException\");\n    } catch (ArithmeticException e) {\n    }\n\n    // int gcd(int a, int b)\n    assert MathMDE.gcd(2, 50) == 2;\n    assert MathMDE.gcd(50, 2) == 2;\n    assert MathMDE.gcd(12, 144) == 12;\n    assert MathMDE.gcd(144, 12) == 12;\n    assert MathMDE.gcd(96, 144) == 48;\n    assert MathMDE.gcd(144, 96) == 48;\n    assert MathMDE.gcd(10, 25) == 5;\n    assert MathMDE.gcd(25, 10) == 5;\n    assert MathMDE.gcd(17, 25) == 1;\n    assert MathMDE.gcd(25, 17) == 1;\n    assert MathMDE.gcd(0, 10) == 10;\n    assert MathMDE.gcd(10, 0) == 10;\n    assert MathMDE.gcd(25, -10) == 5;\n    assert MathMDE.gcd(-25, -10) == 5;\n    assert MathMDE.gcd(-25, 10) == 5;\n\n    // int gcd(int[] a)\n    assert MathMDE.gcd(new int[] {2, 50}) == 2;\n    assert MathMDE.gcd(new int[] {12, 144}) == 12;\n    assert MathMDE.gcd(new int[] {96, 144}) == 48;\n    assert MathMDE.gcd(new int[] {10, 25}) == 5;\n    assert MathMDE.gcd(new int[] {100, 10, 25}) == 5;\n    assert MathMDE.gcd(new int[] {768, 324}) == 12;\n    assert MathMDE.gcd(new int[] {2400, 48, 36}) == 12;\n    assert MathMDE.gcd(new int[] {2400, 72, 36}) == 12;\n\n    // int gcd_differences(int[] a)\n    // Weak set of tests, derived directly from those of \"int gcd(int[] a)\".\n    assert MathMDE.gcd_differences(new int[] {0, 2, 52}) == 2;\n    assert MathMDE.gcd_differences(new int[] {0, 12, 156}) == 12;\n    assert MathMDE.gcd_differences(new int[] {0, 96, 240}) == 48;\n    assert MathMDE.gcd_differences(new int[] {0, 10, 35}) == 5;\n    assert MathMDE.gcd_differences(new int[] {0, 100, 110, 135}) == 5;\n    assert MathMDE.gcd_differences(new int[] {0, 768, 1092}) == 12;\n    assert MathMDE.gcd_differences(new int[] {0, 2400, 2448, 2484}) == 12;\n    assert MathMDE.gcd_differences(new int[] {0, 2400, 2472, 2508}) == 12;\n    assert MathMDE.gcd_differences(new int[] {5, 5, 5, 5}) == 0;\n\n    // int mod_positive(int x, int y)\n    assert MathMDE.mod_positive(33, 5) == 3;\n    assert MathMDE.mod_positive(-33, 5) == 2;\n    assert MathMDE.mod_positive(33, -5) == 3;\n    assert MathMDE.mod_positive(-33, -5) == 2;\n\n    // int[] missing_numbers(int[] nums)\n    assert_arrays_equals(MathMDE.missing_numbers(new int[] {3, 4, 5, 6, 7, 8}), new int[] {});\n    assert_arrays_equals(MathMDE.missing_numbers(new int[] {3, 4, 6, 7, 8}), new int[] {5});\n    assert_arrays_equals(MathMDE.missing_numbers(new int[] {3, 4, 8}), new int[] {5, 6, 7});\n    assert_arrays_equals(MathMDE.missing_numbers(new int[] {3, 5, 6, 8}), new int[] {4, 7});\n    assert_arrays_equals(MathMDE.missing_numbers(new int[] {3, 6, 8}), new int[] {4, 5, 7});\n\n    // class MissingNumbersIteratorInt\n    class TestMissingNumbersIteratorInt {\n      // javadoc won't let this be static\n      void test(int[] orig, boolean add_ends, int[] goal_missing) {\n        Iterator<Integer> orig_iterator = int_array_iterator(orig);\n        Iterator<Integer> missing_iterator =\n            new MathMDE.MissingNumbersIteratorInt(orig_iterator, add_ends);\n        int[] missing = TestPlume.int_iterator_array(missing_iterator);\n        assert_arrays_equals(missing, goal_missing);\n      }\n    }\n\n    TestMissingNumbersIteratorInt tmni = new TestMissingNumbersIteratorInt();\n    tmni.test(new int[] {3, 4, 5, 6, 7, 8}, false, new int[] {});\n    tmni.test(new int[] {3, 4, 6, 7, 8}, false, new int[] {5});\n    tmni.test(new int[] {3, 4, 8}, false, new int[] {5, 6, 7});\n    tmni.test(new int[] {3, 5, 6, 8}, false, new int[] {4, 7});\n    tmni.test(new int[] {3, 6, 8}, false, new int[] {4, 5, 7});\n    tmni.test(new int[] {3}, false, new int[] {});\n    tmni.test(new int[] {3, 4, 5}, false, new int[] {});\n    tmni.test(new int[] {3, 4, 5, 6, 7, 8}, true, new int[] {2, 9});\n    tmni.test(new int[] {3, 4, 6, 7, 8}, true, new int[] {2, 5, 9});\n    tmni.test(new int[] {3, 4, 8}, true, new int[] {2, 5, 6, 7, 9});\n    tmni.test(new int[] {3, 5, 6, 8}, true, new int[] {2, 4, 7, 9});\n    tmni.test(new int[] {3, 6, 8}, true, new int[] {2, 4, 5, 7, 9});\n    tmni.test(new int[] {3, 4, 5}, true, new int[] {2, 6});\n\n    tmni.test(new int[] {-1, 1, 2, 3, 5, 6, 7, 9}, true, new int[] {-2, 0, 4, 8, 10});\n\n    // int[] modulus(int[] nums)\n    // int[] modulus(Iterator itor)\n\n    class TestModulus {\n      // javadoc won't let this be static\n      void check(int[] nums, int /*@Nullable*/ [] goal_rm) {\n        int[] rm = MathMDE.modulus(nums);\n        if (!Arrays.equals(rm, goal_rm)) {\n          throw new Error(\n              \"Expected (r,m)=\"\n                  + ArraysMDE.toString(goal_rm)\n                  + \", saw (r,m)=\"\n                  + ArraysMDE.toString(rm));\n        }\n        if (rm == null) {\n          return;\n        }\n        int goal_r = rm[0];\n        int m = rm[1];\n        for (int i = 0; i < nums.length; i++) {\n          int r = nums[i] % m;\n          if (r < 0) {\n            r += m;\n          }\n          if (r != goal_r) {\n            throw new Error(\"Expected \" + nums[i] + \" % \" + m + \" = \" + goal_r + \", got \" + r);\n          }\n        }\n      }\n\n      // javadoc won't let this be static\n      void check(Iterator<Integer> itor, int /*@Nullable*/ [] goal_rm) {\n        // There would be no point to this:  it's testing\n        // int_iterator_array, not the iterator version!\n        // return check(int_iterator_array(itor), goal_rm);\n        assert_arrays_equals(MathMDE.modulus_int(itor), goal_rm);\n      }\n\n      // javadoc won't let this be static\n      void check_iterator(int[] nums, int /*@Nullable*/ [] goal_rm) {\n        check(int_array_iterator(nums), goal_rm);\n      }\n    }\n\n    TestModulus testModulus = new TestModulus();\n\n    testModulus.check(new int[] {3, 7, 47, 51}, new int[] {3, 4});\n    testModulus.check(new int[] {3, 11, 43, 51}, new int[] {3, 8});\n    testModulus.check(new int[] {3, 11, 47, 55}, new int[] {3, 4});\n    testModulus.check(new int[] {2383, 4015, -81, 463, -689}, new int[] {15, 32});\n    testModulus.check(new int[] {}, null);\n    testModulus.check(new int[] {1}, null);\n    testModulus.check(new int[] {3, 7}, null);\n    testModulus.check(new int[] {2, 3, 5, 7}, null);\n    testModulus.check(new int[] {2, 19, 101}, null);\n    testModulus.check(new int[] {5, 5, 5, 5, 5}, null);\n\n    testModulus.check_iterator(new int[] {}, null);\n    testModulus.check_iterator(new int[] {1}, null);\n    testModulus.check_iterator(new int[] {3, 7, 47, 51}, new int[] {3, 4});\n    testModulus.check_iterator(new int[] {3, 11, 43, 51}, new int[] {3, 8});\n    testModulus.check_iterator(new int[] {3, 11, 47, 55}, new int[] {3, 4});\n    testModulus.check_iterator(new int[] {2383, 4015, -81, 463, -689}, new int[] {15, 32});\n    testModulus.check_iterator(new int[] {5, 5, 5, 5, 5}, null);\n\n    // int[] nonmodulus_strict(int[] nums)\n    // int[] nonmodulus_nonstrict(int[] nums)\n    // int[] nonmodulus_strict(Iterator nums)\n\n    class TestNonModulus {\n      // javadoc won't let this be static\n      void check_strict(int[] nums, int /*@Nullable*/ [] goal_rm) {\n        check(nums, goal_rm, true);\n        Iterator<Integer> itor = int_array_iterator(nums);\n        assert_arrays_equals(MathMDE.nonmodulus_strict_int(itor), goal_rm);\n      }\n\n      // javadoc won't let this be static\n      void check_nonstrict(int[] nums, int /*@Nullable*/ [] goal_rm) {\n        check(nums, goal_rm, false);\n      }\n\n      // javadoc won't let this be static\n      void check(int[] nums, int /*@Nullable*/ [] goal_rm, boolean strict) {\n        int[] rm;\n        if (strict) {\n          rm = MathMDE.nonmodulus_strict(nums);\n        } else {\n          rm = MathMDE.nonmodulus_nonstrict(nums);\n        }\n        if (!Arrays.equals(rm, goal_rm)) {\n          throw new Error(\n              \"Expected (r,m)=\"\n                  + ArraysMDE.toString(goal_rm)\n                  + \", saw (r,m)=\"\n                  + ArraysMDE.toString(rm));\n        }\n        if (rm == null) {\n          return;\n        }\n        int goal_r = rm[0];\n        int m = rm[1];\n        for (int i = 0; i < nums.length; i++) {\n          int r = nums[i] % m;\n          if (r < 0) {\n            r += m;\n          }\n          if (r == goal_r) {\n            throw new Error(\"Expected inequality, saw \" + nums[i] + \" % \" + m + \" = \" + r);\n          }\n        }\n      }\n    }\n\n    TestNonModulus testNonModulus = new TestNonModulus();\n\n    testNonModulus.check_strict(new int[] {1, 2, 3, 5, 6, 7, 9}, null);\n    testNonModulus.check_strict(new int[] {-1, 1, 2, 3, 5, 6, 7, 9}, new int[] {0, 4});\n    testNonModulus.check_strict(new int[] {1, 2, 3, 5, 6, 7, 9, 11}, null);\n    testNonModulus.check_strict(new int[] {1, 2, 3, 5, 6, 7, 11}, null);\n    testNonModulus.check_strict(new int[] {1, 2, 4, 6, 8, 10}, null);\n\n    // null because only 7 elements, so don't try modulus = 4\n    testNonModulus.check_nonstrict(new int[] {1, 2, 3, 5, 6, 7, 9}, null);\n    testNonModulus.check_nonstrict(new int[] {1, 2, 3, 5, 6, 7, 9, 10}, new int[] {0, 4});\n    testNonModulus.check_nonstrict(new int[] {1, 2, 3, 5, 6, 7, 9, 11}, new int[] {0, 4});\n    testNonModulus.check_nonstrict(new int[] {1, 2, 3, 5, 6, 7, 9, 11, 12, 13}, null);\n    testNonModulus.check_nonstrict(\n        new int[] {1, 2, 3, 5, 6, 7, 9, 11, 12, 13, 14, 15}, new int[] {4, 6});\n    testNonModulus.check_nonstrict(new int[] {1, 2, 3, 5, 6, 7, 9, 11, 12, 13, 14, 15, 22}, null);\n  }\n\n  @Test\n  public void testOrderedPairIterator() {\n    final int NULL = -2222;\n\n    Vector<Integer> ones = new Vector<Integer>();\n    for (int i = 1; i <= 30; i++) {\n      ones.add(new Integer(i));\n    }\n    Vector<Integer> twos = new Vector<Integer>();\n    for (int i = 2; i <= 30; i += 2) {\n      twos.add(new Integer(i));\n    }\n    Vector<Integer> threes = new Vector<Integer>();\n    for (int i = 3; i <= 30; i += 3) {\n      threes.add(new Integer(i));\n    }\n\n    // I've replaced the nulls by 0 in order to permit the array elements\n    // to be ints instead of Integers.\n\n    compareOrderedPairIterator(\n        new OrderedPairIterator<Integer>(ones.iterator(), ones.iterator()),\n        new int[][] {\n          {1, 1}, {2, 2}, {3, 3}, {4, 4}, {5, 5}, {6, 6}, {7, 7}, {8, 8}, {9, 9}, {10, 10},\n          {11, 11}, {12, 12}, {13, 13}, {14, 14}, {15, 15}, {16, 16}, {17, 17}, {18, 18}, {19, 19},\n          {20, 20}, {21, 21}, {22, 22}, {23, 23}, {24, 24}, {25, 25}, {26, 26}, {27, 27}, {28, 28},\n          {29, 29}, {30, 30},\n        });\n\n    compareOrderedPairIterator(\n        new OrderedPairIterator<Integer>(ones.iterator(), twos.iterator()),\n        new int[][] {\n          {1, NULL},\n          {2, 2},\n          {3, NULL},\n          {4, 4},\n          {5, NULL},\n          {6, 6},\n          {7, NULL},\n          {8, 8},\n          {9, NULL},\n          {10, 10},\n          {11, NULL},\n          {12, 12},\n          {13, NULL},\n          {14, 14},\n          {15, NULL},\n          {16, 16},\n          {17, NULL},\n          {18, 18},\n          {19, NULL},\n          {20, 20},\n          {21, NULL},\n          {22, 22},\n          {23, NULL},\n          {24, 24},\n          {25, NULL},\n          {26, 26},\n          {27, NULL},\n          {28, 28},\n          {29, NULL},\n          {30, 30},\n        });\n\n    compareOrderedPairIterator(\n        new OrderedPairIterator<Integer>(twos.iterator(), ones.iterator()),\n        new int[][] {\n          {NULL, 1},\n          {2, 2},\n          {NULL, 3},\n          {4, 4},\n          {NULL, 5},\n          {6, 6},\n          {NULL, 7},\n          {8, 8},\n          {NULL, 9},\n          {10, 10},\n          {NULL, 11},\n          {12, 12},\n          {NULL, 13},\n          {14, 14},\n          {NULL, 15},\n          {16, 16},\n          {NULL, 17},\n          {18, 18},\n          {NULL, 19},\n          {20, 20},\n          {NULL, 21},\n          {22, 22},\n          {NULL, 23},\n          {24, 24},\n          {NULL, 25},\n          {26, 26},\n          {NULL, 27},\n          {28, 28},\n          {NULL, 29},\n          {30, 30},\n        });\n\n    compareOrderedPairIterator(\n        new OrderedPairIterator<Integer>(ones.iterator(), threes.iterator()),\n        new int[][] {\n          {1, NULL},\n          {2, NULL},\n          {3, 3},\n          {4, NULL},\n          {5, NULL},\n          {6, 6},\n          {7, NULL},\n          {8, NULL},\n          {9, 9},\n          {10, NULL},\n          {11, NULL},\n          {12, 12},\n          {13, NULL},\n          {14, NULL},\n          {15, 15},\n          {16, NULL},\n          {17, NULL},\n          {18, 18},\n          {19, NULL},\n          {20, NULL},\n          {21, 21},\n          {22, NULL},\n          {23, NULL},\n          {24, 24},\n          {25, NULL},\n          {26, NULL},\n          {27, 27},\n          {28, NULL},\n          {29, NULL},\n          {30, 30},\n        });\n\n    compareOrderedPairIterator(\n        new OrderedPairIterator<Integer>(twos.iterator(), threes.iterator()),\n        new int[][] {\n          {2, NULL},\n          {NULL, 3},\n          {4, NULL},\n          {6, 6},\n          {8, NULL},\n          {NULL, 9},\n          {10, NULL},\n          {12, 12},\n          {14, NULL},\n          {NULL, 15},\n          {16, NULL},\n          {18, 18},\n          {20, NULL},\n          {NULL, 21},\n          {22, NULL},\n          {24, 24},\n          {26, NULL},\n          {NULL, 27},\n          {28, NULL},\n          {30, 30},\n        });\n  }\n\n  /** Throws an assertion unless the paired iterator contains the same values as the argument array. */\n  public static void compareOrderedPairIterator(OrderedPairIterator<Integer> opi, int[][] ints) {\n    int pairno = 0;\n    while (opi.hasNext()) {\n      Pair</*@Nullable*/ Integer, /*@Nullable*/ Integer> pair = opi.next();\n      // System.out.println(\"Iterator: <\" + pair.a + \",\" + pair.b + \">, array: <\" + ints[pairno][0] + \",\" + ints[pairno][1] + \">\");\n      assert (pair.a == null) || (pair.a.intValue() == ints[pairno][0]);\n      assert (pair.b == null) || (pair.b.intValue() == ints[pairno][1]);\n      pairno++;\n    }\n    assert pairno == ints.length;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// TimeLimitProcess\n  ///\n\n  /**\n   * Print one integer periodically.\n   * <p>\n   * Example use from the command line, for one integer each half-second:\n   * <pre>  java plume.TestPlume\\$PrintOneIntPerSecond 500</pre>\n   */\n  public static class PrintOneIntPerTimePeriod {\n    /**\n     * @param args  two-element array containing:  how many to print; how many milliseconds between each\n     */\n    public static void main(String[] args) {\n      if (args.length != 2) {\n        System.err.println(\"Needs 2 arguments, got \" + args.length);\n      }\n      int limit = Integer.parseInt(args[0]);\n      int period = Integer.parseInt(args[1]);\n      for (int i = 0; i < limit; i++) {\n        System.out.printf(\"out%d \", i);\n        System.err.printf(\"err%d \", i);\n        try {\n          Thread.sleep(period);\n        } catch (InterruptedException e) {\n          // We don't care if this is interrupted\n        }\n      }\n    }\n  }\n\n  private static Runtime runtime = java.lang.Runtime.getRuntime();\n\n  // timePerNumber needs to be small so tests run fast, but large so that\n  // more output doesn't sneak out before the timeout kicks in.\n  private static Triple<Integer, String, String> printFive(\n      int timePerNumber, int timeLimit, boolean cache_stdout) {\n    String command = \"java plume.TestPlume$PrintOneIntPerTimePeriod 5 \" + timePerNumber;\n    TimeLimitProcess p;\n    try {\n      p = new TimeLimitProcess(runtime.exec(command), timeLimit, cache_stdout);\n    } catch (IOException e) {\n      throw new Error(e);\n    }\n    int result;\n    try {\n      result = p.waitFor();\n    } catch (InterruptedException e) {\n      throw new Error(e);\n    }\n    // System.out.printf(\"command:%s%n\", command);\n    // System.out.printf(\"result:%s%n\", result);\n    // System.out.printf(\"buffered stdout:%s%n\", p.cached_stdout);\n    // System.out.printf(\"buffered stderr:%s%n\", p.cached_stderr);\n    String out = UtilMDE.streamString(p.getInputStream());\n    String err = UtilMDE.streamString(p.getErrorStream());\n    // System.out.printf(\"out:%s%n\", out);\n    // System.out.printf(\"err:%s%n\", err);\n    return Triple.of(result, out, err);\n  }\n\n  private static void checkPrintFive(\n      int timePerNumber, int timeLimit, boolean cache_stdout, String out, String err) {\n    Triple<Integer, String, String> results = printFive(timePerNumber, timeLimit, cache_stdout);\n    if (!results.b.equals(out)) {\n      throw new Error(String.format(\"Expected %s, got %s\", out, results.b));\n    }\n    if (!results.c.equals(err)) {\n      throw new Error(String.format(\"Expected %s, got %s\", err, results.c));\n    }\n  }\n\n  /**\n   * On a heavily-loaded machine, this test fails.\n   * Try again when the load is lower.\n   * (Better might be exponential backoff up to some limit.)\n   */\n  @Test\n  public void testTimeLimitProcess() {\n    // checkPrintFive(10, 1000, false, \"out0 out1 out2 out3 out4 \", \"err0 err1 err2 err3 err4 \");\n    // checkPrintFive(10, 1000, true, \"out0 out1 out2 out3 out4 \", \"err0 err1 err2 err3 err4 \");\n\n    // These are too timing-dependent -- they sometimes succeed and\n    // sometimes fail -- so leave them commented out.\n    // checkPrintFive(2000, 1000, true, \"out0 \", \"err0 \");\n    // checkPrintFive(2000, 3000, true, \"out0 out1 \", \"err0 err1 \");\n\n    // This is expected to fail because of trying to read a closed stream.\n    // printFive(3, false);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// UtilMDE\n  ///\n\n  private static BitSet randomBitSet(int length, Random r) {\n    BitSet result = new BitSet(length);\n    for (int i = 0; i < length; i++) {\n      result.set(i, r.nextBoolean());\n    }\n    return result;\n  }\n\n  @Test\n  public void testStringBuilderDelimited() {\n    compareJoinAndSBD(new String[] {\"foo\", \"bar\", \"baz\"});\n    compareJoinAndSBD(new String[] {\"foo\"});\n    compareJoinAndSBD(new String[] {});\n  }\n\n  public void compareJoinAndSBD(String[] strings) {\n    StringBuilderDelimited sbd = new StringBuilderDelimited(\",\");\n    for (String str : strings) {\n      sbd.append(str);\n    }\n    assert sbd.toString().equals(UtilMDE.join(strings, \",\"));\n  }\n\n  private static void checkTypeStrings(\n      /*@FullyQualifiedName*/ String fqn,\n      /*@BinaryName*/ String bn,\n      /*@ClassGetName*/ String cgn,\n      /*@FieldDescriptor*/ String fd) {\n    checkTypeStrings(fqn, bn, cgn, fd, false);\n  }\n\n  private static void checkTypeStrings(\n      /*@FullyQualifiedName*/ String fqn,\n      /*@BinaryName*/ String bn,\n      /*@ClassGetName*/ String cgn,\n      /*@FieldDescriptor*/ String fd,\n      boolean skipClassForName) {\n    if (!skipClassForName) {\n      try {\n        UtilMDE.classForName(cgn); // ensure this does not crash\n      } catch (ClassNotFoundException e) {\n        throw new Error(e);\n      }\n    }\n    assert fd.equals(UtilMDE.binaryNameToFieldDescriptor(bn));\n    assert cgn.equals(UtilMDE.binaryNameToClassGetName(bn))\n        : bn + \" => \" + UtilMDE.binaryNameToClassGetName(bn) + \", should be \" + cgn;\n    assert cgn.equals(UtilMDE.fieldDescriptorToClassGetName(fd)) : fd + \" => \" + cgn;\n    assert bn.equals(UtilMDE.fieldDescriptorToBinaryName(fd));\n  }\n\n  // This cannot be static because it instantiates an inner class.\n  @Test\n  public void testUtilMDE() {\n\n    // public static intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)\n    {\n      Random r = new Random(20031008);\n      for (int i = 0; i < 100; i++) {\n        BitSet b1 = randomBitSet(r.nextInt(100), r);\n        BitSet b2 = randomBitSet(r.nextInt(100), r);\n        BitSet b3 = randomBitSet(r.nextInt(100), r);\n        BitSet intersection = (BitSet) b1.clone();\n        intersection.and(b2);\n        int card = intersection.cardinality();\n        for (int j = 0; j < 100; j++) {\n          assert UtilMDE.intersectionCardinalityAtLeast(b1, b2, j) == (card >= j);\n        }\n        intersection.and(b3);\n        card = intersection.cardinality();\n        for (int j = 0; j < 100; j++) {\n          assert UtilMDE.intersectionCardinalityAtLeast(b1, b2, b3, j) == (card >= j);\n        }\n      }\n    }\n\n    // public static BufferedReader bufferedFileReader(String filename)\n    // public static LineNumberReader lineNumberFileReader(String filename)\n    // public static BufferedWriter bufferedFileWriter(String filename) throws IOException\n    // public static Class classForName(String className)\n\n    // private boolean isSubtype(Class<?> sub, Class<?> sup) {\n    assert UtilMDE.isSubtype(Integer.class, Integer.class);\n    assert UtilMDE.isSubtype(Cloneable.class, Cloneable.class);\n    assert UtilMDE.isSubtype(Object.class, Object.class);\n    assert UtilMDE.isSubtype(Integer.class, Number.class);\n    assert !UtilMDE.isSubtype(Number.class, Integer.class);\n    assert UtilMDE.isSubtype(Integer.class, Comparable.class);\n    assert !UtilMDE.isSubtype(Comparable.class, Integer.class);\n    assert UtilMDE.isSubtype(Integer.class, Object.class);\n    assert !UtilMDE.isSubtype(Object.class, Integer.class);\n    assert !UtilMDE.isSubtype(Integer.class, Float.class);\n    assert UtilMDE.isSubtype(Collection.class, Iterable.class);\n    assert !UtilMDE.isSubtype(Iterable.class, Collection.class);\n    assert UtilMDE.isSubtype(ArrayList.class, Iterable.class);\n    assert !UtilMDE.isSubtype(Iterable.class, ArrayList.class);\n    assert UtilMDE.isSubtype(ArrayList.class, Cloneable.class);\n    assert !UtilMDE.isSubtype(Cloneable.class, ArrayList.class);\n    assert UtilMDE.isSubtype(ArrayList.class, List.class);\n    assert !UtilMDE.isSubtype(List.class, ArrayList.class);\n\n    // public static String binaryNameToFieldDescriptor(String classname)\n    assert UtilMDE.binaryNameToFieldDescriptor(\"boolean\").equals(\"Z\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"byte\").equals(\"B\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"char\").equals(\"C\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"double\").equals(\"D\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"float\").equals(\"F\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"int\").equals(\"I\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"long\").equals(\"J\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"short\").equals(\"S\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"Integer\").equals(\"LInteger;\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"Java.lang.Integer\").equals(\"LJava/lang/Integer;\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"int[][]\").equals(\"[[I\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"Java.lang.Integer[][][]\")\n        .equals(\"[[[LJava/lang/Integer;\");\n\n    // public static /*@ClassGetName*/ String binaryNameToClassGetName(/*BinaryName*/ String bn)\n    assert UtilMDE.binaryNameToClassGetName(\"boolean\").equals(\"boolean\");\n    assert UtilMDE.binaryNameToClassGetName(\"byte\").equals(\"byte\");\n    assert UtilMDE.binaryNameToClassGetName(\"char\").equals(\"char\");\n    assert UtilMDE.binaryNameToClassGetName(\"double\").equals(\"double\");\n    assert UtilMDE.binaryNameToClassGetName(\"float\").equals(\"float\");\n    assert UtilMDE.binaryNameToClassGetName(\"int\").equals(\"int\");\n    assert UtilMDE.binaryNameToClassGetName(\"long\").equals(\"long\");\n    assert UtilMDE.binaryNameToClassGetName(\"short\").equals(\"short\");\n    assert UtilMDE.binaryNameToClassGetName(\"Integer\").equals(\"Integer\");\n    assert UtilMDE.binaryNameToClassGetName(\"Java.lang.Integer\").equals(\"Java.lang.Integer\");\n    assert UtilMDE.binaryNameToClassGetName(\"int[][]\").equals(\"[[I\");\n    assert UtilMDE.binaryNameToClassGetName(\"Java.lang.Integer[][][]\")\n        .equals(\"[[[LJava.lang.Integer;\");\n\n    // public static String arglistToJvm(String arglist)\n    assert UtilMDE.arglistToJvm(\"()\").equals(\"()\");\n    assert UtilMDE.arglistToJvm(\"(int)\").equals(\"(I)\");\n    assert UtilMDE.arglistToJvm(\"(int, int)\").equals(\"(II)\");\n    assert UtilMDE.arglistToJvm(\"(int, long, short)\").equals(\"(IJS)\");\n    assert UtilMDE.arglistToJvm(\"(java.lang.Integer, int, java.lang.Integer)\")\n        .equals(\"(Ljava/lang/Integer;ILjava/lang/Integer;)\");\n    assert UtilMDE.arglistToJvm(\"(int[])\").equals(\"([I)\");\n    assert UtilMDE.arglistToJvm(\"(int[], int, int)\").equals(\"([III)\");\n    assert UtilMDE.arglistToJvm(\"(int, int[][], int)\").equals(\"(I[[II)\");\n    assert UtilMDE.arglistToJvm(\"(java.lang.Integer[], int, java.lang.Integer[][])\")\n        .equals(\"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\");\n\n    // public static String fieldDescriptorToBinaryName(String classname)\n    assert UtilMDE.fieldDescriptorToBinaryName(\"Z\").equals(\"boolean\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"B\").equals(\"byte\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"C\").equals(\"char\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"D\").equals(\"double\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"F\").equals(\"float\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"I\").equals(\"int\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"J\").equals(\"long\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"S\").equals(\"short\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"LInteger;\").equals(\"Integer\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"LJava/lang/Integer;\").equals(\"Java.lang.Integer\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"[[I\").equals(\"int[][]\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"[[LJava/lang/Integer;\")\n        .equals(\"Java.lang.Integer[][]\");\n\n    // public static /*@ClassGetName*/ String fieldDescriptorToClassGetName(/*FieldDescriptor*/ String fd)\n    assert UtilMDE.fieldDescriptorToClassGetName(\"Z\").equals(\"boolean\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"B\").equals(\"byte\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"C\").equals(\"char\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"D\").equals(\"double\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"F\").equals(\"float\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"I\").equals(\"int\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"J\").equals(\"long\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"S\").equals(\"short\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"LInteger;\").equals(\"Integer\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"LJava/lang/Integer;\").equals(\"Java.lang.Integer\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"[[I\").equals(\"[[I\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"[[LJava/lang/Integer;\")\n        .equals(\"[[LJava.lang.Integer;\");\n\n    // public static String arglistFromJvm(String arglist)\n    assert UtilMDE.arglistFromJvm(\"()\").equals(\"()\");\n    assert UtilMDE.arglistFromJvm(\"(I)\").equals(\"(int)\");\n    assert UtilMDE.arglistFromJvm(\"(II)\").equals(\"(int, int)\");\n    assert UtilMDE.arglistFromJvm(\"(IJS)\").equals(\"(int, long, short)\");\n    assert UtilMDE.arglistFromJvm(\"(Ljava/lang/Integer;ILjava/lang/Integer;)\")\n        .equals(\"(java.lang.Integer, int, java.lang.Integer)\");\n    assert UtilMDE.arglistFromJvm(\"([I)\").equals(\"(int[])\");\n    assert UtilMDE.arglistFromJvm(\"([III)\").equals(\"(int[], int, int)\");\n    assert UtilMDE.arglistFromJvm(\"(I[[II)\").equals(\"(int, int[][], int)\");\n    assert UtilMDE.arglistFromJvm(\"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\")\n        .equals(\"(java.lang.Integer[], int, java.lang.Integer[][])\");\n\n    // More tests for type representation conversions.\n    // Table from Signature Checker manual.\n    checkTypeStrings(\"int\", \"int\", \"int\", \"I\");\n    checkTypeStrings(\"int[][]\", \"int[][]\", \"[[I\", \"[[I\");\n    checkTypeStrings(\"MyClass\", \"MyClass\", \"MyClass\", \"LMyClass;\", true);\n    checkTypeStrings(\"MyClass[]\", \"MyClass[]\", \"[LMyClass;\", \"[LMyClass;\", true);\n    checkTypeStrings(\n        \"java.lang.Integer\", \"java.lang.Integer\", \"java.lang.Integer\", \"Ljava/lang/Integer;\");\n    checkTypeStrings(\n        \"java.lang.Integer[]\",\n        \"java.lang.Integer[]\",\n        \"[Ljava.lang.Integer;\",\n        \"[Ljava/lang/Integer;\");\n    checkTypeStrings(\n        \"java.lang.Byte.ByteCache\",\n        \"java.lang.Byte$ByteCache\",\n        \"java.lang.Byte$ByteCache\",\n        \"Ljava/lang/Byte$ByteCache;\");\n    checkTypeStrings(\n        \"java.lang.Byte.ByteCache[]\",\n        \"java.lang.Byte$ByteCache[]\",\n        \"[Ljava.lang.Byte$ByteCache;\",\n        \"[Ljava/lang/Byte$ByteCache;\");\n\n    // public static void addToClasspath(String dir)\n    // public static final class WildcardFilter implements FilenameFilter\n    //   public WildcardFilter(String filename)\n    //   public boolean accept(File dir, String name)\n    // public static boolean canCreateAndWrite(File file)\n    // public static void writeObject(Object o, File file) throws IOException\n    // public static Object readObject(File file)\n    // public static File createTempDir(String prefix, String suffix)\n\n    // public Object incrementHashMap(HashMap hm, Object key, int count)\n\n    try {\n      assert UtilMDE.canCreateAndWrite(new File(\"TestPlume.java\"));\n\n      // This test fails if run by the superuser (who can overwrite\n      // any file).\n      if (!System.getProperty(\"user.name\").equals(\"root\")) {\n        File readOnly = new File(\"temp\");\n        readOnly.createNewFile();\n        readOnly.setReadOnly();\n        assert !UtilMDE.canCreateAndWrite(readOnly);\n        readOnly.delete();\n      }\n\n      assert UtilMDE.canCreateAndWrite(new File(\"temp\"));\n      assert !UtilMDE.canCreateAndWrite(new File(\"temp/temp\"));\n    } catch (IOException e) {\n      e.printStackTrace();\n      org.junit.Assert.fail(\"failure while testing UtilMDE.canCreateAndWrite(): \" + e.toString());\n    }\n\n    {\n      // These names are taken from APL notation, where iota creates an\n      // array of all the numbers up to its argument.\n      Vector<Integer> iota0 = new Vector<Integer>();\n      Vector<Integer> iota10 = new Vector<Integer>();\n      for (int i = 0; i < 10; i++) {\n        iota10.add(new Integer(i));\n      }\n      Vector<Integer> iota10_twice = new Vector<Integer>();\n      iota10_twice.addAll(iota10);\n      iota10_twice.addAll(iota10);\n      Vector<Integer> iota10_thrice = new Vector<Integer>();\n      iota10_thrice.addAll(iota10);\n      iota10_thrice.addAll(iota10);\n      iota10_thrice.addAll(iota10);\n\n      // public static class EnumerationIterator implements Iterator\n      // public static class IteratorEnumeration implements Enumeration\n\n      assert iota0.equals(toVector(iota0.iterator()));\n      assert iota0.equals(toVector(new UtilMDE.IteratorEnumeration<Integer>(iota0.iterator())));\n      assert iota0.equals(toVector(iota0.elements()));\n      assert iota0.equals(toVector(new UtilMDE.EnumerationIterator<Integer>(iota0.elements())));\n      assert iota10.equals(toVector(iota10.iterator()));\n      assert iota10.equals(toVector(new UtilMDE.IteratorEnumeration<Integer>(iota10.iterator())));\n      assert iota10.equals(toVector(iota10.elements()));\n      assert iota10.equals(toVector(new UtilMDE.EnumerationIterator<Integer>(iota10.elements())));\n\n      // public static class MergedIterator2 implements Iterator {\n      assert iota10_twice.equals(\n          toVector(new UtilMDE.MergedIterator2<Integer>(iota10.iterator(), iota10.iterator())));\n      assert iota10.equals(\n          toVector(new UtilMDE.MergedIterator2<Integer>(iota0.iterator(), iota10.iterator())));\n      assert iota10.equals(\n          toVector(new UtilMDE.MergedIterator2<Integer>(iota10.iterator(), iota0.iterator())));\n\n      // public static class MergedIterator implements Iterator {\n      Vector<Iterator<Integer>> iota10_iterator_thrice = new Vector<Iterator<Integer>>();\n      iota10_iterator_thrice.add(iota10.iterator());\n      iota10_iterator_thrice.add(iota10.iterator());\n      iota10_iterator_thrice.add(iota10.iterator());\n      assert iota10_thrice.equals(\n          toVector(new UtilMDE.MergedIterator<Integer>(iota10_iterator_thrice.iterator())));\n      Vector<Iterator<Integer>> iota10_iterator_twice_1 = new Vector<Iterator<Integer>>();\n      iota10_iterator_twice_1.add(iota0.iterator());\n      iota10_iterator_twice_1.add(iota10.iterator());\n      iota10_iterator_twice_1.add(iota10.iterator());\n      Vector<Iterator<Integer>> iota10_iterator_twice_2 = new Vector<Iterator<Integer>>();\n      iota10_iterator_twice_2.add(iota10.iterator());\n      iota10_iterator_twice_2.add(iota0.iterator());\n      iota10_iterator_twice_2.add(iota10.iterator());\n      Vector<Iterator<Integer>> iota10_iterator_twice_3 = new Vector<Iterator<Integer>>();\n      iota10_iterator_twice_3.add(iota10.iterator());\n      iota10_iterator_twice_3.add(iota10.iterator());\n      iota10_iterator_twice_3.add(iota0.iterator());\n      assert iota10_twice.equals(\n          toVector(new UtilMDE.MergedIterator<Integer>(iota10_iterator_twice_1.iterator())));\n      assert iota10_twice.equals(\n          toVector(new UtilMDE.MergedIterator<Integer>(iota10_iterator_twice_2.iterator())));\n      assert iota10_twice.equals(\n          toVector(new UtilMDE.MergedIterator<Integer>(iota10_iterator_twice_3.iterator())));\n\n      class OddFilter implements Filter<Integer> {\n        public OddFilter() {}\n\n        public boolean accept(Integer i) {\n          return i.intValue() % 2 != 0;\n        }\n      }\n\n      // public static final class FilteredIterator implements Iterator\n\n      Vector<Integer> iota10_odd = new Vector<Integer>();\n      for (int i = 0; i < iota10.size(); i++) {\n        if (i % 2 != 0) {\n          iota10_odd.add(new Integer(i));\n        }\n      }\n      assert iota10_odd.equals(\n          toVector(new UtilMDE.FilteredIterator<Integer>(iota10.iterator(), new OddFilter())));\n    }\n\n    // public static final class RemoveFirstAndLastIterator implements Iterator\n    {\n      Vector<Integer> iota5 = new Vector<Integer>();\n      for (int i = 0; i < 5; i++) {\n        iota5.add(new Integer(i));\n      }\n      Vector<Integer> iota5middle = new Vector<Integer>();\n      for (int i = 1; i < 4; i++) {\n        iota5middle.add(new Integer(i));\n      }\n      UtilMDE.RemoveFirstAndLastIterator<Integer> rfali =\n          new UtilMDE.RemoveFirstAndLastIterator<Integer>(iota5.iterator());\n      Vector<Integer> rfali_vector = toVector(rfali);\n      assert iota5middle.equals(rfali_vector);\n      assert rfali.getFirst().equals(new Integer(0));\n      assert rfali.getLast().equals(new Integer(4));\n    }\n\n    // public static ArrayList randomElements(Iterator itor, int num_elts)\n    // public static ArrayList randomElements(Iterator itor, int num_elts, Random random)\n\n    // Iterate through numbers from zero up to the argument (non-inclusive)\n    class IotaIterator implements Iterator<Integer> {\n      int i = 0;\n      int limit;\n\n      public IotaIterator(int limit) {\n        this.limit = limit;\n      }\n\n      @Override\n      public boolean hasNext() {\n        return i < limit;\n      }\n\n      @Override\n      public Integer next() {\n        if (!hasNext()) {\n          throw new NoSuchElementException();\n        }\n        return new Integer(i++);\n      }\n\n      @Override\n      public void remove() {\n        throw new UnsupportedOperationException();\n      }\n    }\n    {\n      // Typically, no progress reports are printed, because the loop\n      // finishes in well under 1 minute.  Users will see progress reports\n      // when this class is slowed down by instrumentation.\n      Calendar nextNotification = Calendar.getInstance();\n      nextNotification.add(Calendar.MINUTE, 1);\n      DateFormat df = new SimpleDateFormat();\n\n      int itor_size = 10;\n      int num_elts_limit = 12;\n      int tries = short_run ? 100 : 100000;\n      double ratio_limit = .02;\n      Random r = new Random(20020311);\n      // \"i++\" instead of \"i+=3\" here works, but is slow\n      for (int i = 1; i < num_elts_limit; i += 3) {\n        int[] totals = new int[num_elts_limit];\n        for (int j = 0; j < tries; j++) {\n          if (j % 100 == 0) {\n            Calendar now = Calendar.getInstance();\n            if (now.after(nextNotification)) {\n              System.out.printf(\n                  \"%s: iteration (%d,%d) out of (%d,%d)%n\",\n                  df.format(nextNotification.getTime()),\n                  i,\n                  j,\n                  num_elts_limit,\n                  tries);\n              nextNotification.add(Calendar.MINUTE, 1);\n            }\n          }\n          List<Integer> chosen = UtilMDE.randomElements(new IotaIterator(itor_size), i, r);\n          for (int m = 0; m < chosen.size(); m++) {\n            for (int n = m + 1; n < chosen.size(); n++) {\n              if (chosen.get(m).intValue() == chosen.get(n).intValue()) {\n                throw new Error(\"Duplicate at \" + m + \",\" + n);\n              }\n            }\n          }\n          for (int k = 0; k < chosen.size(); k++) {\n            totals[chosen.get(k).intValue()]++;\n          }\n        }\n        int i_truncated = Math.min(itor_size, i);\n        int grand_total = tries * i_truncated;\n        assert ArraysMDE.sum(totals) == grand_total : \"Totals = \" + ArraysMDE.sum(totals);\n        // System.out.print(\"chosen:\\t\");\n        for (int k = 0; k < num_elts_limit; k++) {\n          int this_total = totals[k];\n          int expected = tries * i_truncated / itor_size;\n          double ratio = (double) this_total / (double) expected;\n          // System.out.print(((k<10) ? \" \" : \"\") + k + \" \" + this_total + \"\\t\");\n          // System.out.print(\"\\nExp=\" + expected + \"\\tratio=\" + ratio + \"\\t\");\n          assert k >= itor_size || (ratio > ratio_limit && ratio < 1 / ratio_limit);\n        }\n        // System.out.println();\n      }\n    }\n\n    // public static <T> /*@Nullable*/ Integer incrementMap(Map<T,Integer> m, T key, int count) {\n    // public static <K,V> String mapToString(Map<K,V> m) {\n    // public static <K,V> void mapToString(Appendable sb, Map<K,V> m, String linePrefix) {\n    // public static <K extends Comparable<? super K>,V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(Map<K,V> m) {\n    // public static <K,V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(Map<K,V> m, Comparator<K> comparator) {\n\n    // public static Method methodForName(String methodname) throws ClassNotFoundException\n    //\n    // essentially I am just testing whether the return is erroneous\n    try {\n      assert null\n          != UtilMDE.methodForName(\n              \"plume.UtilMDE.methodForName(java.lang.String, java.lang.String, java.lang.Class[])\");\n      assert null\n          != UtilMDE.methodForName(\n              \"plume.UtilMDE.methodForName(java.lang.String,java.lang.String,java.lang.Class[])\");\n      assert null != UtilMDE.methodForName(\"java.lang.Math.min(int,int)\");\n    } catch (Exception e) {\n      e.printStackTrace();\n      throw new Error(e);\n    }\n    try {\n      java.lang.reflect.Method m = UtilMDE.methodForName(\"plume.UtilMDE.methodForName()\");\n      throw new Error(\"Didn't throw NoSuchMethodException\");\n    } catch (NoSuchMethodException e) {\n      // nothing to do; this is the expected case\n    } catch (Exception e) {\n      e.printStackTrace();\n      throw new Error(e);\n    }\n\n    // public static boolean propertyIsTrue(Properties p, String key)\n    // public static String appendProperty(Properties p, String key, String value)\n    // public static String setDefault(Properties p, String key, String value)\n    // public static void streamCopy(java.io.InputStream from, java.io.OutputStream to)\n\n    // public static String replaceString(String target, String oldStr, String newStr)\n\n    assert UtilMDE.replaceString(\"hello dolly well hello dolly\", \" \", \"  \")\n        .equals(\"hello  dolly  well  hello  dolly\");\n    assert UtilMDE.replaceString(\"  hello  dolly well hello dolly  \", \" \", \"  \")\n        .equals(\"    hello    dolly  well  hello  dolly    \");\n    assert UtilMDE.replaceString(\"hello dolly well hello dolly\", \"ll\", \"y\")\n        .equals(\"heyo doyy wey heyo doyy\");\n    assert UtilMDE.replaceString(\"hello dolly well hello dolly\", \"q\", \"yyy\")\n        .equals(\"hello dolly well hello dolly\");\n\n    // public static String[] split(String s, char delim)\n    // public static String[] split(String s, String delim)\n\n    assert Arrays.equals(UtilMDE.split(\"foo,bar,baz\", ','), new String[] {\"foo\", \"bar\", \"baz\"});\n    assert Arrays.equals(UtilMDE.split(\"foo\", ','), new String[] {\"foo\"});\n    assert Arrays.equals(UtilMDE.split(\"\", ','), new String[] {\"\"});\n    assert Arrays.equals(UtilMDE.split(\",foo,\", ','), new String[] {\"\", \"foo\", \"\"});\n    assert Arrays.equals(UtilMDE.split(\"foo,bar,baz\", \",\"), new String[] {\"foo\", \"bar\", \"baz\"});\n    assert Arrays.equals(UtilMDE.split(\"foo\", \",\"), new String[] {\"foo\"});\n    assert Arrays.equals(UtilMDE.split(\"\", \",\"), new String[] {\"\"});\n    assert Arrays.equals(UtilMDE.split(\",foo,\", \",\"), new String[] {\"\", \"foo\", \"\"});\n    assert Arrays.equals(UtilMDE.split(\"foo, bar, baz\", \", \"), new String[] {\"foo\", \"bar\", \"baz\"});\n    assert Arrays.equals(UtilMDE.split(\"foo\", \", \"), new String[] {\"foo\"});\n    assert Arrays.equals(UtilMDE.split(\"\", \", \"), new String[] {\"\"});\n    assert Arrays.equals(UtilMDE.split(\", foo, \", \", \"), new String[] {\"\", \"foo\", \"\"});\n\n    // public static String join(Object[] a, String delim)\n    // public static String join(Vector v, String delim)\n\n    assert UtilMDE.join(new String[] {\"foo\", \"bar\", \"baz\"}, \", \").equals(\"foo, bar, baz\");\n    assert UtilMDE.join(new String[] {\"foo\"}, \", \").equals(\"foo\");\n    assert UtilMDE.join(new String[] {}, \", \").equals(\"\");\n    assert UtilMDE.join(\n            new Integer[] {\n              new Integer(0), new Integer(1), new Integer(2), new Integer(3), new Integer(4)\n            },\n            \"\")\n        .equals(\"01234\");\n    Vector<Object> potpourri = new Vector<Object>();\n    potpourri.add(\"day\");\n    potpourri.add(new Integer(2));\n    potpourri.add(\"day\");\n    assert UtilMDE.join(potpourri, \" \").equals(\"day 2 day\");\n\n    // public static String escapeNonJava(String orig)\n    // public static String escapeNonJava(Character ch)\n\n    assert UtilMDE.escapeNonJava(\"foobar\").equals(\"foobar\");\n    assert UtilMDE.escapeNonJava(\"\").equals(\"\");\n    assert UtilMDE.escapeNonJava(\"\\\\\").equals(\"\\\\\\\\\");\n    assert UtilMDE.escapeNonJava(\"\\\\\\n\\r\\\"\").equals(\"\\\\\\\\\\\\n\\\\r\\\\\\\"\");\n    assert UtilMDE.escapeNonJava(\"split\\nlines\").equals(\"split\\\\nlines\");\n    assert UtilMDE.escapeNonJava(\"\\\\relax\").equals(\"\\\\\\\\relax\");\n    assert UtilMDE.escapeNonJava(\"\\\"hello\\\"\").equals(\"\\\\\\\"hello\\\\\\\"\");\n    assert UtilMDE.escapeNonJava(\"\\\"hello\\\" \\\"world\\\"\").equals(\"\\\\\\\"hello\\\\\\\" \\\\\\\"world\\\\\\\"\");\n\n    // public static String escapeNonASCII(String orig)\n\n    assert UtilMDE.escapeNonASCII(\"foobar\").equals(\"foobar\");\n    assert UtilMDE.escapeNonASCII(\"\").equals(\"\");\n    assert UtilMDE.escapeNonASCII(\"\\\\\").equals(\"\\\\\\\\\");\n    assert UtilMDE.escapeNonASCII(\"\\\\\\n\\r\\\"\").equals(\"\\\\\\\\\\\\n\\\\r\\\\\\\"\");\n    assert UtilMDE.escapeNonASCII(\"split\\nlines\").equals(\"split\\\\nlines\");\n    assert UtilMDE.escapeNonASCII(\"\\\\relax\").equals(\"\\\\\\\\relax\");\n    assert UtilMDE.escapeNonASCII(\"\\\"hello\\\"\").equals(\"\\\\\\\"hello\\\\\\\"\");\n    assert UtilMDE.escapeNonASCII(\"\\\"hello\\\" \\\"world\\\"\").equals(\"\\\\\\\"hello\\\\\\\" \\\\\\\"world\\\\\\\"\");\n    assert UtilMDE.escapeNonASCII(\"\\0\\1\\2\\7\\12\\70\\100\\111\\222\")\n        .equals(\"\\\\000\\\\001\\\\002\\\\007\\\\n8@I\\\\222\");\n    assert UtilMDE.escapeNonASCII(\"\\u0100\\u1000\\ucafe\\uffff\")\n        .equals(\"\\\\u0100\\\\u1000\\\\ucafe\\\\uffff\");\n\n    // private static String escapeNonASCII(char c)\n\n    // public static String unescapeNonJava(String orig)\n\n    assert UtilMDE.unescapeNonJava(\"foobar\").equals(\"foobar\");\n    assert UtilMDE.unescapeNonJava(\"\").equals(\"\");\n    assert UtilMDE.unescapeNonJava(\"\\\\\\\\\").equals(\"\\\\\");\n    assert UtilMDE.unescapeNonJava(\"\\\\\\\"\").equals(\"\\\"\");\n    assert UtilMDE.unescapeNonJava(\"\\\\n\").equals(\"\\n\"); // not lineSep\n    assert UtilMDE.unescapeNonJava(\"\\\\r\").equals(\"\\r\");\n    assert UtilMDE.unescapeNonJava(\"split\\\\nlines\").equals(\"split\\nlines\");\n    assert UtilMDE.unescapeNonJava(\"\\\\\\\\\\\\n\").equals(\"\\\\\\n\"); // not lineSep\n    assert UtilMDE.unescapeNonJava(\"\\\\n\\\\r\").equals(\"\\n\\r\"); // not lineSep\n    assert UtilMDE.unescapeNonJava(\"\\\\\\\\\\\\n\\\\r\\\\\\\"\").equals(\"\\\\\\n\\r\\\"\");\n    assert UtilMDE.unescapeNonJava(\"\\\\\\\\relax\").equals(\"\\\\relax\");\n    assert UtilMDE.unescapeNonJava(\"\\\\\\\"hello\\\\\\\"\").equals(\"\\\"hello\\\"\");\n    assert UtilMDE.unescapeNonJava(\"\\\\\\\"hello\\\\\\\" \\\\\\\"world\\\\\\\"\").equals(\"\\\"hello\\\" \\\"world\\\"\");\n    assert UtilMDE.unescapeNonJava(\"\\\\\").equals(\"\\\\\");\n    assert UtilMDE.unescapeNonJava(\"foo\\\\\").equals(\"foo\\\\\");\n    assert UtilMDE.unescapeNonJava(\"\\\\*abc\").equals(\"*abc\");\n    // Should add more tests here.\n\n    // Unfortunately, there isn't yet a unescapeNonASCII function.\n    // If implemented, it should have the following behavior:\n    // assert UtilMDE.unescapeNonASCII(\"\\\\115\").equals(\"M\");\n    // assert UtilMDE.unescapeNonASCII(\"\\\\115\\\\111\\\\124\").equals(\"MIT\");\n\n    // public static String removeWhitespaceAround(String arg, String delimiter)\n    // public static String removeWhitespaceAfter(String arg, String delimiter)\n    // public static String removeWhitespaceBefore(String arg, String delimiter)\n\n    assert UtilMDE.removeWhitespaceBefore(\"a,b\", \",\").equals(\"a,b\");\n    assert UtilMDE.removeWhitespaceBefore(\"a, b\", \",\").equals(\"a, b\");\n    assert UtilMDE.removeWhitespaceBefore(\"a ,b\", \",\").equals(\"a,b\");\n    assert UtilMDE.removeWhitespaceBefore(\"a , b\", \",\").equals(\"a, b\");\n    assert UtilMDE.removeWhitespaceBefore(\"ab=>cd\", \"=>\").equals(\"ab=>cd\");\n    assert UtilMDE.removeWhitespaceBefore(\"ab=> cd\", \"=>\").equals(\"ab=> cd\");\n    assert UtilMDE.removeWhitespaceBefore(\"ab =>cd\", \"=>\").equals(\"ab=>cd\");\n    assert UtilMDE.removeWhitespaceBefore(\"ab => cd\", \"=>\").equals(\"ab=> cd\");\n    assert UtilMDE.removeWhitespaceBefore(\"123cd\", \"123\").equals(\"123cd\");\n    assert UtilMDE.removeWhitespaceBefore(\" 123 cd\", \"123\").equals(\"123 cd\");\n    assert UtilMDE.removeWhitespaceBefore(\" 123cd\", \"123\").equals(\"123cd\");\n    assert UtilMDE.removeWhitespaceBefore(\"123 cd\", \"123\").equals(\"123 cd\");\n    assert UtilMDE.removeWhitespaceBefore(\"cd123\", \"123\").equals(\"cd123\");\n    assert UtilMDE.removeWhitespaceBefore(\"cd 123 \", \"123\").equals(\"cd123 \");\n    assert UtilMDE.removeWhitespaceBefore(\"cd123 \", \"123\").equals(\"cd123 \");\n    assert UtilMDE.removeWhitespaceBefore(\"cd 123\", \"123\").equals(\"cd123\");\n\n    assert UtilMDE.removeWhitespaceAfter(\"a,b\", \",\").equals(\"a,b\");\n    assert UtilMDE.removeWhitespaceAfter(\"a, b\", \",\").equals(\"a,b\");\n    assert UtilMDE.removeWhitespaceAfter(\"a ,b\", \",\").equals(\"a ,b\");\n    assert UtilMDE.removeWhitespaceAfter(\"a , b\", \",\").equals(\"a ,b\");\n    assert UtilMDE.removeWhitespaceAfter(\"ab=>cd\", \"=>\").equals(\"ab=>cd\");\n    assert UtilMDE.removeWhitespaceAfter(\"ab=> cd\", \"=>\").equals(\"ab=>cd\");\n    assert UtilMDE.removeWhitespaceAfter(\"ab =>cd\", \"=>\").equals(\"ab =>cd\");\n    assert UtilMDE.removeWhitespaceAfter(\"ab => cd\", \"=>\").equals(\"ab =>cd\");\n    assert UtilMDE.removeWhitespaceAfter(\"123cd\", \"123\").equals(\"123cd\");\n    assert UtilMDE.removeWhitespaceAfter(\" 123 cd\", \"123\").equals(\" 123cd\");\n    assert UtilMDE.removeWhitespaceAfter(\" 123cd\", \"123\").equals(\" 123cd\");\n    assert UtilMDE.removeWhitespaceAfter(\"123 cd\", \"123\").equals(\"123cd\");\n    assert UtilMDE.removeWhitespaceAfter(\"cd123\", \"123\").equals(\"cd123\");\n    assert UtilMDE.removeWhitespaceAfter(\"cd 123 \", \"123\").equals(\"cd 123\");\n    assert UtilMDE.removeWhitespaceAfter(\"cd123 \", \"123\").equals(\"cd123\");\n    assert UtilMDE.removeWhitespaceAfter(\"cd 123\", \"123\").equals(\"cd 123\");\n\n    assert UtilMDE.removeWhitespaceAround(\"a,b\", \",\").equals(\"a,b\");\n    assert UtilMDE.removeWhitespaceAround(\"a, b\", \",\").equals(\"a,b\");\n    assert UtilMDE.removeWhitespaceAround(\"a ,b\", \",\").equals(\"a,b\");\n    assert UtilMDE.removeWhitespaceAround(\"a , b\", \",\").equals(\"a,b\");\n    assert UtilMDE.removeWhitespaceAround(\"ab=>cd\", \"=>\").equals(\"ab=>cd\");\n    assert UtilMDE.removeWhitespaceAround(\"ab=> cd\", \"=>\").equals(\"ab=>cd\");\n    assert UtilMDE.removeWhitespaceAround(\"ab =>cd\", \"=>\").equals(\"ab=>cd\");\n    assert UtilMDE.removeWhitespaceAround(\"ab => cd\", \"=>\").equals(\"ab=>cd\");\n    assert UtilMDE.removeWhitespaceAround(\"123cd\", \"123\").equals(\"123cd\");\n    assert UtilMDE.removeWhitespaceAround(\" 123 cd\", \"123\").equals(\"123cd\");\n    assert UtilMDE.removeWhitespaceAround(\" 123cd\", \"123\").equals(\"123cd\");\n    assert UtilMDE.removeWhitespaceAround(\"123 cd\", \"123\").equals(\"123cd\");\n    assert UtilMDE.removeWhitespaceAround(\"cd123\", \"123\").equals(\"cd123\");\n    assert UtilMDE.removeWhitespaceAround(\"cd 123 \", \"123\").equals(\"cd123\");\n    assert UtilMDE.removeWhitespaceAround(\"cd123 \", \"123\").equals(\"cd123\");\n    assert UtilMDE.removeWhitespaceAround(\"cd 123\", \"123\").equals(\"cd123\");\n\n    // public static String nplural(int n, String noun)\n\n    assert UtilMDE.nplural(0, \"fuss\").equals(\"0 fusses\");\n    assert UtilMDE.nplural(1, \"fuss\").equals(\"1 fuss\");\n    assert UtilMDE.nplural(2, \"fuss\").equals(\"2 fusses\");\n    assert UtilMDE.nplural(0, \"fox\").equals(\"0 foxes\");\n    assert UtilMDE.nplural(1, \"fox\").equals(\"1 fox\");\n    assert UtilMDE.nplural(2, \"fox\").equals(\"2 foxes\");\n    assert UtilMDE.nplural(0, \"fish\").equals(\"0 fishes\");\n    assert UtilMDE.nplural(1, \"fish\").equals(\"1 fish\");\n    assert UtilMDE.nplural(2, \"fish\").equals(\"2 fishes\");\n    assert UtilMDE.nplural(0, \"fletch\").equals(\"0 fletches\");\n    assert UtilMDE.nplural(1, \"fletch\").equals(\"1 fletch\");\n    assert UtilMDE.nplural(2, \"fletch\").equals(\"2 fletches\");\n    assert UtilMDE.nplural(0, \"fund\").equals(\"0 funds\");\n    assert UtilMDE.nplural(1, \"fund\").equals(\"1 fund\");\n    assert UtilMDE.nplural(2, \"fund\").equals(\"2 funds\");\n    assert UtilMDE.nplural(0, \"f-stop\").equals(\"0 f-stops\");\n    assert UtilMDE.nplural(1, \"f-stop\").equals(\"1 f-stop\");\n    assert UtilMDE.nplural(2, \"f-stop\").equals(\"2 f-stops\");\n\n    // public static String rpad(String s, int length)\n    // public static String rpad(int num, int length)\n    // public static String rpad(double num, int length)\n\n    assert UtilMDE.rpad(\"\", 5).equals(\"     \");\n    assert UtilMDE.rpad(\"abcd\", 5).equals(\"abcd \");\n    assert UtilMDE.rpad(\"abcde\", 5).equals(\"abcde\");\n    assert UtilMDE.rpad(\"abcdef\", 5).equals(\"abcde\");\n    assert UtilMDE.rpad(\"abcde ghij\", 5).equals(\"abcde\");\n    assert UtilMDE.rpad(10, 5).equals(\"10   \");\n    assert UtilMDE.rpad(3.14, 5).equals(\"3.14 \");\n\n    // public static class NullableStringComparator\n    //   public int compare(Object o1, Object o2)\n\n    // public static int count(String s, int ch)\n    // public static int count(String s, String sub)\n\n    assert UtilMDE.count(\"abcde\", 'a') == 1;\n    assert UtilMDE.count(\"abcde\", 'c') == 1;\n    assert UtilMDE.count(\"abcde\", 'e') == 1;\n    assert UtilMDE.count(\"abcde\", 'z') == 0;\n    assert UtilMDE.count(\"abacadaea\", 'a') == 5;\n    assert UtilMDE.count(\"aaa aea\", 'a') == 5;\n    assert UtilMDE.count(\"daeaaa\", 'a') == 4;\n\n    // This will be easy to write tests for, when I get around to it.\n    // public static Vector tokens(String str, String delim, boolean returnTokens)\n    // public static Vector tokens(String str, String delim)\n    // public static Vector tokens(String str)\n\n    // public static List sortList (List l, Comparator c)\n    // public static <T> List<T> removeDuplicates(List<T> l) {\n\n    List<Integer> l123 = new ArrayList<Integer>();\n    l123.add(1);\n    l123.add(2);\n    l123.add(3);\n    List<Integer> l123123 = new ArrayList<Integer>();\n    l123123.add(1);\n    l123123.add(2);\n    l123123.add(3);\n    l123123.add(1);\n    l123123.add(2);\n    l123123.add(3);\n    List<Integer> l12223 = new ArrayList<Integer>();\n    l12223.add(1);\n    l12223.add(2);\n    l12223.add(2);\n    l12223.add(2);\n    l12223.add(3);\n    List<Integer> l1123 = new ArrayList<Integer>();\n    l1123.add(1);\n    l1123.add(1);\n    l1123.add(2);\n    l1123.add(3);\n    List<Integer> l1233 = new ArrayList<Integer>();\n    l1233.add(1);\n    l1233.add(1);\n    l1233.add(2);\n    l1233.add(3);\n\n    assert UtilMDE.removeDuplicates(l123).equals(l123);\n    assert UtilMDE.removeDuplicates(l123123).equals(l123);\n    assert UtilMDE.removeDuplicates(l12223).equals(l123);\n    assert UtilMDE.removeDuplicates(l1123).equals(l123);\n    assert UtilMDE.removeDuplicates(l1233).equals(l123);\n\n    // public boolean deepEquals(Object o1, Object o2)\n\n    boolean[] zatft1 = new boolean[] {true, false, true};\n    boolean[] zatft2 = new boolean[] {true, false, true};\n    boolean[] zatff = new boolean[] {true, false, false};\n    assert !zatft1.equals(zatft2);\n    assert UtilMDE.deepEquals(zatft1, zatft2);\n    assert !zatft1.equals(zatff);\n    assert !UtilMDE.deepEquals(zatft1, zatff);\n\n    List<Object> l1 = new ArrayList<Object>();\n    List<Object> l2 = new ArrayList<Object>();\n    List<Object> l3 = new ArrayList<Object>();\n    l1.add(l1);\n    l2.add(l2);\n    l3.add(l3);\n    l1.add(zatft1);\n    l2.add(zatft2);\n    l3.add(zatff);\n    // Don't test .equals because it suffers infinite recursion.\n    // assert ! l1.equals(l2);\n    // assert ! l1.equals(l3);\n    // assert ! l2.equals(l3);\n    assert UtilMDE.deepEquals(l1, l2);\n    assert !UtilMDE.deepEquals(l1, l3);\n    assert !UtilMDE.deepEquals(l2, l3);\n\n    // This is tested by the tokens methods.\n    // public static Vector makeVector(Enumeration e)\n\n    Locale.setDefault(Locale.US);\n    assert UtilMDE.abbreviateNumber(5).equals(\"5.00\");\n    assert UtilMDE.abbreviateNumber(5000).equals(\"5.00K\");\n    assert UtilMDE.abbreviateNumber(5000000).equals(\"5.00M\");\n    assert UtilMDE.abbreviateNumber(1000000000).equals(\"1.00G\");\n    assert UtilMDE.abbreviateNumber(1).equals(\"1.00\");\n    assert UtilMDE.abbreviateNumber(12).equals(\"12.0\");\n    assert UtilMDE.abbreviateNumber(123).equals(\"123\");\n    assert UtilMDE.abbreviateNumber(1234).equals(\"1.23K\");\n    assert UtilMDE.abbreviateNumber(12345).equals(\"12.3K\");\n    assert UtilMDE.abbreviateNumber(123456).equals(\"123K\");\n    assert UtilMDE.abbreviateNumber(1234567).equals(\"1.23M\");\n    assert UtilMDE.abbreviateNumber(12345678).equals(\"12.3M\");\n    assert UtilMDE.abbreviateNumber(123456789).equals(\"123M\");\n    assert UtilMDE.abbreviateNumber(1234567890).equals(\"1.23G\");\n    assert UtilMDE.abbreviateNumber(9).equals(\"9.00\");\n    assert UtilMDE.abbreviateNumber(98).equals(\"98.0\");\n    assert UtilMDE.abbreviateNumber(987).equals(\"987\");\n    assert UtilMDE.abbreviateNumber(9876).equals(\"9.88K\");\n    assert UtilMDE.abbreviateNumber(98765).equals(\"98.8K\");\n    assert UtilMDE.abbreviateNumber(987654).equals(\"988K\");\n    assert UtilMDE.abbreviateNumber(9876543).equals(\"9.88M\");\n    assert UtilMDE.abbreviateNumber(98765432).equals(\"98.8M\");\n    assert UtilMDE.abbreviateNumber(987654321).equals(\"988M\");\n    assert UtilMDE.abbreviateNumber(9876543210L).equals(\"9.88G\");\n  }\n\n  @Test\n  public void testTestUtilMDE() {\n    int[] a = new int[] {3, 4, 5};\n    assert_arrays_equals(int_iterator_array(int_array_iterator(a)), a);\n  }\n\n  @Test\n  public void testWeakHasherMap() {}\n\n  /**\n   * These tests could be much more thorough.  Basically all that is tested\n   * is that identity is used rather than a normal hash.  The tests will\n   * fail however, if WeakHashMap is swapped for WeakIdentityHashMap.\n   */\n  @Test\n  public void testWeakIdentityHashMap() {\n\n    String s1 = \"one\";\n    String s2 = \"two\";\n    String s3 = \"three\";\n\n    WeakIdentityHashMap<String, Integer> m = new WeakIdentityHashMap<String, Integer>();\n    // WeakHashMap<String,Integer> m = new WeakHashMap<String,Integer>();\n\n    m.put(s1, 1);\n    m.put(s2, 2);\n    m.put(s3, 3);\n\n    String s1a = new String(s1);\n    String s2a = new String(s2);\n    String s3a = new String(s3);\n\n    m.put(s1a, 1);\n    m.put(s2a, 2);\n    m.put(s3a, 3);\n\n    assert m.get(s1) == 1;\n    assert m.get(s2) == 2;\n    assert m.get(s3) == 3;\n    assert m.get(s1a) == 1;\n    assert m.get(s2a) == 2;\n    assert m.get(s3a) == 3;\n\n    m.remove(s1);\n    m.remove(s2);\n    m.remove(s3);\n    assert m.get(s1) == null;\n    assert m.get(s2) == null;\n    assert m.get(s3) == null;\n    assert m.get(s1a) == 1;\n    assert m.get(s2a) == 2;\n    assert m.get(s3a) == 3;\n  }\n\n  @Test\n  public void testClassFileVersion() {\n    // public static double [] versionNumbers(InputStream is)\n    assert ClassFileVersion.versionNumbers(new ByteArrayInputStream(new byte[0])) == null;\n  }\n\n  /**\n   * Tests whether CountingPrintWriter\n   * counts the bytes printed, written for\n   * different types (boolean, int, float etc.).\n   */\n  @Test\n  public void testCountingPrintWriter() {\n    CountingPrintWriter c1 = new CountingPrintWriter(new CharArrayWriter());\n    c1.print(\"a\");\n    assert c1.getNumberOfPrintedBytes() == 1;\n    c1.print(1);\n    assert c1.getNumberOfPrintedBytes() == 2;\n    c1.print(true);\n    assert c1.getNumberOfPrintedBytes() == 6;\n    c1.print(1.00);\n    assert c1.getNumberOfPrintedBytes() == 9;\n    c1.write(\"a\");\n    c1.write(\"-\");\n    assert c1.getNumberOfPrintedBytes() == 9;\n    assert c1.getNumberOfWrittenBytes() == 22;\n    assert c1.getNumberOfPrintedChars() == 9;\n    c1.println(\"a b\");\n    String lineSep = System.getProperty(\"line.separator\");\n    int ls_len = lineSep.length();\n    assert c1.getNumberOfPrintedBytes() == (12 + ls_len);\n    assert c1.getNumberOfWrittenBytes() == (28);\n    assert c1.getNumberOfPrintedChars() == (12 + ls_len);\n    c1.print((String) null);\n    c1.print((Object) null);\n    c1.println((String) null);\n    // need to add assertions about what got printed.\n  }\n\n  /**\n   * Test the intering of subsequences as triples of the original\n   * sequence, the start and the end indices.\n   */\n  @Test\n  public void testSequenceAndIndices() {\n    int[] a1 = Intern.intern(new int[] {1, 2, 3, 4, 5, 6, 7});\n    int[] a2 = Intern.intern(new int[] {1, 2, 3, 4, 5, 6, 7});\n    int[] a3 = Intern.intern(new int[] {2, 3, 4, 5, 6, 7});\n    int i = 2;\n    int j = 4;\n    int k = 5;\n\n    int[] s1 = Intern.internSubsequence(a1, i, j);\n    int[] s2 = Intern.internSubsequence(a2, i, j);\n    int[] s3 = Intern.internSubsequence(a1, j, k);\n    int[] s4 = Intern.internSubsequence(a1, j, k);\n    int[] s5 = Intern.internSubsequence(a3, j - 1, k - 1);\n\n    assert a1 == a2;\n    assert s1 == s2;\n    assert s3 == s4;\n    assert s3 == s5;\n    assert ArraysMDE.isSubarray(s1, ArraysMDE.subarray(a1, i, j - i), 0);\n    assert ArraysMDE.isSubarray(ArraysMDE.subarray(a1, i, j - i), s1, 0);\n\n    long[] l1 = Intern.intern(new long[] {1, 2, 3, 4, 5, 6});\n    assert l1 == Intern.internSubsequence(l1, 0, l1.length);\n  }\n\n  // To do\n  // @Test\n  // public static void testFileIOException() {\n  // }\n\n  /**\n   * Test the comparison, indexof, and set equivalence calls in fuzzy\n   * float.\n   */\n  @Test\n  public void testFuzzyFloat() {\n\n    FuzzyFloat ff = new FuzzyFloat(0.0001);\n    double offset = 0.00007;\n    double offhigh = 1 + offset;\n    double offlow = 1 - offset;\n    double offhigh2 = 1 + 2 * offset;\n    double offlow2 = 1 - 2 * offset;\n\n    //test equality for a variety of postive and negative numbers\n    for (double d = -20000; d < 20000; d += 1000.36) {\n      assert ff.eq(d, d * offhigh);\n      assert ff.eq(d, d * offlow);\n      assert !ff.eq(d, d * offhigh2);\n      assert !ff.eq(d, d * offlow2);\n      assert !ff.ne(d, d * offhigh);\n      assert !ff.ne(d, d * offlow);\n      assert ff.ne(d, d * offhigh2);\n      assert ff.ne(d, d * offlow2);\n    }\n\n    //make sure nothing is equal to zero\n    assert ff.eq(0, Double.MIN_VALUE);\n    assert ff.eq(0, -Double.MIN_VALUE);\n    assert !ff.ne(0, Double.MIN_VALUE);\n    assert !ff.ne(0, -Double.MIN_VALUE);\n\n    //make sure that 0 equals 0\n    assert ff.eq(0, 0);\n    assert !ff.ne(0, 0);\n\n    //make sure that NaNs are not equal\n    assert !ff.eq(Double.NaN, Double.NaN);\n\n    //make sure that various unusual values are equal\n    assert ff.eq(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n    assert ff.eq(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);\n\n    //rudimentary checks on the comparison operators (since they all just\n    //use eq and ne anyway)\n    {\n      double d = 2563.789;\n      assert !ff.gt(d, d * offlow);\n      assert !ff.lt(d, d * offhigh);\n      assert ff.gt(d, d * offlow2);\n      assert ff.lt(d, d * offhigh2);\n      assert ff.gte(d, d * offhigh);\n      assert ff.lte(d, d * offlow);\n      assert !ff.gte(d, d * offhigh2);\n      assert !ff.lte(d, d * offlow2);\n    }\n\n    // public int indexOf (double[] a, double elt)\n    {\n      double[] a = new double[10];\n      for (int i = 0; i < a.length; i++) {\n        a[i] = i;\n      }\n      double[] a_copy = a.clone();\n      assert ff.indexOf(a, -1) == -1;\n      assert ff.indexOf(a, 0) == 0;\n      assert ff.indexOf(a, 7) == 7;\n      assert ff.indexOf(a, 9) == 9;\n      assert ff.indexOf(a, 10) == -1;\n      assert ff.indexOf(a, 20) == -1;\n      assert ff.indexOf(a, Double.MIN_VALUE) == 0;\n      assert ff.indexOf(a, 7 * offhigh) == 7;\n      assert ff.indexOf(a, 9 * offlow) == 9;\n      assert ff.indexOf(a, 7 * offhigh2) == -1;\n      assert ff.indexOf(a, 9 * offlow2) == -1;\n      assert_arrays_equals(a, a_copy);\n    }\n\n    // public int indexOf (double[] a, double[] sub)\n    {\n      double[] a = new double[10];\n      for (int i = 0; i < a.length; i++) {\n        a[i] = i;\n      }\n      double[] b = new double[] {};\n      double[] c = new double[] {a[0], a[1], a[2]};\n      double[] d = new double[] {a[1], a[2]};\n      double[] e = new double[] {a[2], a[3], a[4], a[5]};\n      double[] f = new double[] {a[7], a[8], a[9]};\n      double[] g = new double[] {a[7], 22, a[9]};\n      double[] h = new double[] {a[7], a[8], a[9], 10};\n\n      assert ff.indexOf(a, b) == 0;\n      assert ff.indexOf(a, c) == 0;\n      assert ff.indexOf(a, d) == 1;\n      assert ff.indexOf(a, e) == 2;\n      assert ff.indexOf(a, f) == 7;\n      assert ff.indexOf(a, g) == -1;\n      assert ff.indexOf(a, h) == -1;\n    }\n    {\n      double[] a = new double[10];\n      for (int i = 0; i < a.length; i++) {\n        a[i] = i;\n      }\n      double[] b = new double[] {};\n      double[] c = new double[] {a[0] * offlow, a[1] * offhigh, a[2] * offlow};\n      double[] d = new double[] {a[1] * offhigh, a[2] * offlow};\n      double[] e = new double[] {a[2], a[3], a[4] * offlow, a[5] * offhigh};\n      double[] f = new double[] {a[7], a[8] * offlow, a[9] * offhigh};\n      double[] g = new double[] {a[7], 22, a[9]};\n      double[] h = new double[] {a[7], a[8], a[9], 10};\n      double[] a_copy = a.clone();\n      double[] b_copy = b.clone();\n      double[] c_copy = c.clone();\n      double[] d_copy = d.clone();\n      double[] e_copy = e.clone();\n      double[] f_copy = f.clone();\n      double[] g_copy = g.clone();\n      double[] h_copy = h.clone();\n\n      assert ff.indexOf(a, b) == 0;\n      assert ff.indexOf(a, c) == 0;\n      assert ff.indexOf(a, d) == 1;\n      assert ff.indexOf(a, e) == 2;\n      assert ff.indexOf(a, f) == 7;\n      assert ff.indexOf(a, g) == -1;\n      assert ff.indexOf(a, h) == -1;\n\n      assert_arrays_equals(a, a_copy);\n      assert_arrays_equals(b, b_copy);\n      assert_arrays_equals(c, c_copy);\n      assert_arrays_equals(d, d_copy);\n      assert_arrays_equals(e, e_copy);\n      assert_arrays_equals(f, f_copy);\n      assert_arrays_equals(g, g_copy);\n      assert_arrays_equals(h, h_copy);\n    }\n\n    // public boolean isElemMatch (double[] a1, double[] a2)\n    {\n      double[] f1 = new double[10];\n      double[] f2 = new double[20];\n\n      for (int j = 0; j < 10; j++) {\n\n        initialize_f1_and_f2(j, f1, f2);\n\n        //make two elements off just a little\n        f2[7] = f2[7] * (1 + offset);\n        f2[8] = f2[8] * (1 - offset);\n\n        //test with each array the bigger one\n        if ((j % 2) == 0) {\n          assert ff.isElemMatch(f1, f2);\n        } else {\n          assert ff.isElemMatch(f2, f1);\n        }\n      }\n      for (int j = 0; j < 200; j++) {\n\n        initialize_f1_and_f2(j, f1, f2);\n\n        //make two elements off just a little\n        f2[7] = f2[7] * (1 + 2 * offset);\n        f2[8] = f2[8] * (1 - 2 * offset);\n\n        //test with each array the bigger one\n        double[] f1_copy = f1.clone();\n        double[] f2_copy = f2.clone();\n        if ((j % 2) == 0) {\n          assert !ff.isElemMatch(f1, f2);\n        } else {\n          assert !ff.isElemMatch(f2, f1);\n        }\n        assert_arrays_equals(f1, f1_copy);\n        assert_arrays_equals(f2, f2_copy);\n      }\n    }\n    {\n      double[] a = new double[] {2, 1, 0};\n      double[] b = new double[] {};\n      double[] c = new double[] {1, 1, 1, 1};\n      double[] d = new double[] {1};\n      assert !ff.isElemMatch(a, b);\n      assert !ff.isElemMatch(b, a);\n      assert ff.isElemMatch(c, d);\n      assert ff.isElemMatch(d, c);\n      assert ff.isElemMatch(b, b);\n    }\n\n    // public class DoubleArrayComparatorLexical implements Comparator\n    // public int compare(Object o1, Object o2)\n    {\n      Comparator<double[]> comparator = ff.new DoubleArrayComparatorLexical();\n      double[] a0 = new double[] {};\n      double[] a1 = new double[] {};\n      double[] a2 = new double[] {0, 1, 2, 3};\n      double[] a3 = new double[] {0, 1, 2, 3, 0};\n      double[] a4 = new double[] {0, 1, 2, 3, 4};\n      double[] a5 = new double[] {0, 1, 2, 3, 4};\n      double[] a6 = new double[] {0, 1, 5, 3, 4};\n      double[] a7 = new double[] {1, 2, 3, 4};\n      double[] a0_copy = a0.clone();\n      double[] a1_copy = a1.clone();\n      double[] a2_copy = a2.clone();\n      double[] a3_copy = a3.clone();\n      double[] a4_copy = a4.clone();\n      double[] a5_copy = a5.clone();\n      double[] a6_copy = a6.clone();\n      double[] a7_copy = a7.clone();\n\n      assert comparator.compare(a0, a1) == 0;\n      assert comparator.compare(a1, a0) == 0;\n      assert comparator.compare(a1, a2) < 0;\n      assert comparator.compare(a2, a1) > 0;\n      assert comparator.compare(a2, a3) < 0;\n      assert comparator.compare(a3, a2) > 0;\n      assert comparator.compare(a3, a4) < 0;\n      assert comparator.compare(a4, a3) > 0;\n      assert comparator.compare(a4, a5) == 0;\n      assert comparator.compare(a5, a4) == 0;\n      assert comparator.compare(a5, a6) < 0;\n      assert comparator.compare(a6, a5) > 0;\n      assert comparator.compare(a6, a7) < 0;\n      assert comparator.compare(a7, a6) > 0;\n      assert comparator.compare(a1, a4) < 0;\n      assert comparator.compare(a4, a1) > 0;\n      assert comparator.compare(a2, a4) < 0;\n      assert comparator.compare(a4, a2) > 0;\n      assert comparator.compare(a6, a4) > 0;\n      assert comparator.compare(a4, a6) < 0;\n      assert comparator.compare(a7, a4) > 0;\n      assert comparator.compare(a4, a7) < 0;\n\n      assert_arrays_equals(a0, a0_copy);\n      assert_arrays_equals(a1, a1_copy);\n      assert_arrays_equals(a2, a2_copy);\n      assert_arrays_equals(a3, a3_copy);\n      assert_arrays_equals(a4, a4_copy);\n      assert_arrays_equals(a5, a5_copy);\n      assert_arrays_equals(a6, a6_copy);\n      assert_arrays_equals(a7, a7_copy);\n    }\n\n    // public boolean FuzzyFloat.isSubset (double[] a1, double[] a2)\n    {\n      double[] f1 = new double[10];\n      double[] f2 = new double[20];\n\n      for (int j = 0; j < f2.length; j++) {\n        f2[j] = j;\n      }\n      for (int i = 0; i < f2.length - f1.length; i++) {\n\n        //fill up f1 with elements of f2\n        for (int j = 0; j < f1.length; j++) {\n          f1[j] = f2[i + j];\n        }\n\n        f1[5] = f2[i] * offhigh;\n\n        double[] f1_copy = f1.clone();\n        double[] f2_copy = f2.clone();\n\n        assert ff.isSubset(f1, f2);\n        assert_arrays_equals(f1, f1_copy);\n        assert_arrays_equals(f2, f2_copy);\n      }\n\n      double[] a1 = new double[] {1, 5, 10};\n      double[] a2 = new double[] {};\n      double[] a3 = new double[] {1};\n      double[] a4 = new double[] {10};\n      double[] a5 = new double[] {1, 10, 15, 20};\n      double[] a6 = new double[] {10, 10, 10, 10, 10, 1};\n\n      assert ff.isSubset(a2, a1);\n      assert !ff.isSubset(a1, a2);\n      assert !ff.isSubset(a1, a5);\n      assert ff.isSubset(a3, a1);\n      assert ff.isSubset(a4, a1);\n      assert ff.isSubset(a6, a1);\n      assert !ff.isSubset(a1, a6);\n    }\n  }\n\n  /** Initialize f2 to be the same as two copies of f1 */\n  @SuppressWarnings(\"index\") // length of f1 is exactly 10, length of f2 is exactly 20\n  void initialize_f1_and_f2(int j, double[] f1, double[] f2) {\n\n    //start two arrays out exactly equal\n    for (int i = 0; i < f1.length; i++) {\n      f1[i] = j + i * 10;\n      f2[i] = j + i * 10;\n    }\n\n    //fill out the second half of f2 with dup of f1\n    for (int i = 10; i < f2.length; i++) {\n      f2[i] = j + (i - 10) * 10;\n    }\n  }\n\n  /**\n   * Tests UtilMDE create_combinations routines.\n   */\n  @Test\n  public void test_create_combinations() {\n\n    // public static List create_combinations (int dims, int start, List objs)\n    Object a = new Object();\n    Object b = new Object();\n    Object c = new Object();\n    List<Object> a_list = Arrays.<Object>asList(new Object[] {a});\n    List<Object> b_list = Arrays.<Object>asList(new Object[] {b});\n    List<Object> c_list = Arrays.<Object>asList(new Object[] {c});\n    List<Object> aa = Arrays.<Object>asList(new Object[] {a, a});\n    List<Object> bb = Arrays.<Object>asList(new Object[] {b, b});\n    List<Object> cc = Arrays.<Object>asList(new Object[] {c, c});\n    List<Object> ab = Arrays.<Object>asList(new Object[] {a, b});\n    List<Object> ac = Arrays.<Object>asList(new Object[] {a, c});\n    List<Object> bc = Arrays.<Object>asList(new Object[] {b, c});\n\n    List<Object> abc = Arrays.asList(a, b, c);\n    List<List<Object>> combo1 = UtilMDE.create_combinations(1, 0, abc);\n    assert combo1.size() == 3;\n    assert combo1.contains(a_list);\n    assert combo1.contains(b_list);\n    assert combo1.contains(c_list);\n\n    List<List<Object>> combo2 = UtilMDE.create_combinations(2, 0, abc);\n    assert combo2.size() == 6;\n    assert combo2.contains(aa);\n    assert combo2.contains(ab);\n    assert combo2.contains(ac);\n    assert combo2.contains(bb);\n    assert combo2.contains(bc);\n    assert combo2.contains(cc);\n\n    // public static List create_combinations (int arity, int start, int cnt)\n    Integer i0 = new Integer(0);\n    Integer i1 = new Integer(1);\n    Integer i2 = new Integer(2);\n\n    List<ArrayList<Integer>> combo3 = UtilMDE.create_combinations(1, 0, 2);\n    assert combo3.size() == 3;\n    assert combo3.contains(Arrays.asList(new Integer[] {i0}));\n    assert combo3.contains(Arrays.asList(new Integer[] {i1}));\n    assert combo3.contains(Arrays.asList(new Integer[] {i2}));\n\n    List<ArrayList<Integer>> combo4 = UtilMDE.create_combinations(2, 0, 2);\n    assert combo4.size() == 6;\n    assert combo4.contains(Arrays.asList(new Integer[] {i0, i0}));\n    assert combo4.contains(Arrays.asList(new Integer[] {i0, i1}));\n    assert combo4.contains(Arrays.asList(new Integer[] {i0, i2}));\n    assert combo4.contains(Arrays.asList(new Integer[] {i1, i1}));\n    assert combo4.contains(Arrays.asList(new Integer[] {i1, i2}));\n    assert combo4.contains(Arrays.asList(new Integer[] {i2, i2}));\n  }\n\n  @Test\n  public void test_fullyQualifiedNameToSimpleName() {\n\n    assert UtilMDE.fullyQualifiedNameToSimpleName(\"java.lang.String\").equals(\"String\");\n    assert UtilMDE.fullyQualifiedNameToSimpleName(\"String\").equals(\"String\");\n  }\n\n  /**\n   * Test class for Options testing.\n   */\n  public static class TestOptions {\n\n    // TODO: test the @Unpublicized annotation and the usage() message.\n\n    @Option(\"list of patterns\")\n    public List<Pattern> lp = new ArrayList<Pattern>();\n\n    @Option(\"-a <filename> argument 1\")\n    public String arg1 = \"/tmp/foobar\";\n\n    @Option(\"argument 2\")\n    public /*@Nullable*/ String arg2;\n\n    @Option(\"-d double value\")\n    public double temperature;\n\n    @Option(\"-f the input file\")\n    public /*@Nullable*/ File input_file;\n\n    @Option(\"-b boolean\")\n    public boolean bool;\n\n    @Option(\"-i Integer\")\n    public /*@Nullable*/ Integer integer_reference;\n\n    @Option(\"list of doubles\")\n    public List<Double> ld = new ArrayList<Double>();\n\n    @Option(\"list with no default\")\n    public /*@Nullable*/ List<String> ls;\n  }\n\n  /**\n   * Test command line option parsing (Options).\n   * @throws ArgException if there is an illegal argument\n   */\n  @Test\n  public void testOptions() throws ArgException {\n\n    TestOptions t = new TestOptions();\n    Options options = new Options(\"test\", t);\n    options.parse(\n        new String[] {\n          \"--lp=foo\",\n          \"--lp\",\n          \"bar\",\n          \"-i\",\n          \"24\",\n          \"-d=37.8\",\n          \"-b\",\n          \"-b=false\",\n          \"--ld\",\n          \"34.6\",\n          \"--ld\",\n          \"17.8\",\n        });\n    assert t.lp.get(0).toString().equals(\"foo\");\n    assert t.lp.get(1).toString().equals(\"bar\");\n    assert t.integer_reference != null && t.integer_reference.intValue() == 24;\n    assert t.temperature == 37.8;\n    assert t.bool == false;\n    assert t.ld.get(0).doubleValue() == 34.6;\n    assert t.ld.get(1).doubleValue() == 17.8;\n\n    // Test non-options\n    t.bool = false;\n    String[] args = options.parse(new String[] {\"one\", \"two\", \"three\", \"-b\"});\n    assert args[0].equals(\"one\") : args[0];\n    assert args[1].equals(\"two\") : args[1];\n    assert args[2].equals(\"three\") : args[2];\n    assert t.bool;\n\n    // Test --\n    t.bool = false;\n    args = options.parse(new String[] {\"--\", \"one\", \"two\", \"-b\"});\n    assert args[0].equals(\"one\") : args[0];\n    assert args[1].equals(\"two\") : args[1];\n    assert args[2].equals(\"-b\") : args[2];\n    assert !t.bool;\n\n    // Test split_lists\n    t.ld.clear();\n    Options.split_lists = true;\n    args = options.parse(new String[] {\"--ld\", \"42.1 9.3 10.5\", \"--ld\", \"2.7\"});\n    assert args.length == 0;\n    assert t.ld.size() == 4;\n    assert t.ld.get(0).doubleValue() == 42.1;\n    assert t.ld.get(1).doubleValue() == 9.3;\n    assert t.ld.get(2).doubleValue() == 10.5;\n    assert t.ld.get(3).doubleValue() == 2.7;\n\n    // Test list with no default\n    args = options.parse(new String[] {\"--ls\", \"hello\", \"--ls\", \"world\"});\n    assert args.length == 0;\n    assert t.ls != null : \"@AssumeAssertion(nullness)\";\n    assert t.ls.size() == 2;\n    assert t.ls.get(0).equals(\"hello\");\n    assert t.ls.get(1).equals(\"world\");\n  }\n\n  /** Test class for option alias testing. */\n  public static class TestOptionsAliases {\n    @Option(\"-d Set the day\")\n    public String day = \"Friday\";\n\n    @Option(\n      value = \"-t Set the temperature\",\n      aliases = {\"-temp\"}\n    )\n    public double temperature = 42.0;\n\n    @Option(\n      value = \"Print the program version\",\n      aliases = {\"-v\", \"-version\", \"--version\"}\n    )\n    public boolean printVersion = false;\n  }\n\n  /**\n   * Test option aliases (Options).\n   * @throws ArgException if there is an illegal argument\n   */\n  @Test\n  public void testOptionsAliases() throws ArgException {\n    TestOptionsAliases t = new TestOptionsAliases();\n    Options options = new Options(\"test\", t);\n\n    options.parse(new String[] {\"-d\", \"Monday\", \"-temp\", \"-12.3\"});\n    assert t.day.equals(\"Monday\");\n    assert t.temperature == -12.3;\n    assert !t.printVersion;\n\n    options.parse(\"-d Monday -temp -12.3\");\n    assert t.day.equals(\"Monday\");\n    assert t.temperature == -12.3;\n    assert !t.printVersion;\n\n    options.parse(new String[] {\"-t\", \"21.7\", \"-version\"});\n    assert t.day.equals(\"Monday\");\n    assert t.temperature == 21.7;\n    assert t.printVersion;\n\n    options.parse(\"-t 21.7 -version\");\n    assert t.day.equals(\"Monday\");\n    assert t.temperature == 21.7;\n    assert t.printVersion;\n\n    t.printVersion = false;\n    options.parse(new String[] {\"--version\", \"-temp=-60.1\", \"--day\", \"Tuesday\"});\n    assert t.day.equals(\"Tuesday\");\n    assert t.temperature == -60.1;\n    assert t.printVersion;\n\n    t.printVersion = false;\n    options.parse(\"--version -temp=-60.1 --day Tuesday\");\n    assert t.day.equals(\"Tuesday\");\n    assert t.temperature == -60.1;\n    assert t.printVersion;\n  }\n\n  /** Test class for testing option groups. */\n  public static class TestOptionGroups1 {\n    @Option(\"-m Set the mass\")\n    public static int mass;\n\n    @OptionGroup(\"Coordinate options\")\n    @Option(\"-x Set the X coordinate\")\n    public static int x;\n\n    @Option(\"-y Set the Y coordinate\")\n    public static int y;\n\n    @Option(\"-z Set the Z coordinate\")\n    public static int z;\n  }\n\n  /** Test class for testing option groups. */\n  public static class TestOptionGroups2 {\n    @OptionGroup(\"General options\")\n    @Option(\n      value = \"-h Display help message\",\n      aliases = {\"-help\"}\n    )\n    public static boolean help = false;\n\n    @OptionGroup(value = \"Internal options\", unpublicized = true)\n    @Option(\"Set mu\")\n    public static double mu = 4902.7;\n\n    @Unpublicized\n    @Option(\"Set pi\")\n    public static double pi = 3.14;\n\n    @OptionGroup(\"Display options\")\n    @Option(\n      value = \"Use colors\",\n      aliases = {\"--colour\"}\n    )\n    public static boolean color = false;\n  }\n\n  /** Test class for testing option groups. */\n  public static class TestOptionGroups3 {\n    @OptionGroup(\"General options\")\n    @Option(\n      value = \"-h Display help message\",\n      aliases = {\"-help\"}\n    )\n    public static boolean help = false;\n\n    @OptionGroup(\"Internal options\")\n    @Unpublicized\n    @Option(\"Set mu\")\n    public static double mu = 4902.7;\n\n    @Unpublicized\n    @Option(\"Set pi\")\n    public static double pi = 3.14;\n\n    @OptionGroup(\"Display options\")\n    @Option(\n      value = \"Use colors\",\n      aliases = {\"--colour\"}\n    )\n    public static boolean color = false;\n  }\n\n  /**\n   * Test option groups (Options).\n   * @throws ArgException if there is an illegal argument\n   */\n  @Test\n  public void testOptionGroups() throws ArgException {\n    // TODO: The following two exception tests are not adequate.  There must be\n    // a better way to do these.\n    try {\n      Options options = new Options(\"test\", TestOptionGroups1.class);\n    } catch (Error e) {\n      assert e.getMessage() != null\n          && e.getMessage()\n                  .indexOf(\"missing @OptionGroup annotation on the first @Option-annotated field\")\n              > -1;\n    }\n\n    try {\n      Options options = new Options(\"test\", TestOptionGroups2.class, TestOptionGroups1.class);\n    } catch (Error e) {\n      assert e.getMessage() != null\n          && e.getMessage().indexOf(\"missing @OptionGroup annotation in field\") > -1;\n    }\n\n    Options options = new Options(\"test\", TestOptionGroups2.class);\n\n    assert options.usage().indexOf(\"General options\") > -1;\n    assert options.usage().indexOf(\"Display options\") > -1;\n    // \"Internal options\" is unpublicized so it should not occur in the default\n    // usage message.\n    assert options.usage().indexOf(\"Internal options\") == -1;\n\n    assert options.usage(\"Internal options\").indexOf(\"Set mu\") > -1;\n    // \"Set pi\" should not appear in the usage message for \"Internal options\"\n    // because it is marked with @Unpublicized.\n    assert options.usage(\"Internal options\").indexOf(\"Set pi\") == -1;\n\n    options.parse(new String[] {\"--colour\", \"--pi\", \"3.15\"});\n    assert TestOptionGroups2.color;\n    assert TestOptionGroups2.pi == 3.15;\n\n    options.parse(\"--colour --pi 3.15\");\n    assert TestOptionGroups2.color;\n    assert TestOptionGroups2.pi == 3.15;\n\n    // Test that an option group that contains only unpublicized options is not\n    // included in the usage message.\n    Options options2 = new Options(\"test\", TestOptionGroups3.class);\n    assert options.usage().indexOf(\"Internal options\") == -1;\n    // ...unless include_unpublicized is true.\n    assert options.usage(true).indexOf(\"Internal options\") > -1;\n  }\n\n  public static class TestOptionsEnums {\n    enum Compressor {\n      RLE,\n      SMART_RLE,\n      HUFFMAN\n    }\n\n    @Option(\"Set the first compression pass\")\n    public static /*@Nullable*/ Compressor firstPass;\n\n    @Option(\"Set the second compression pass\")\n    public static /*@Nullable*/ Compressor secondPass;\n  }\n\n  @Test\n  public void testOptionsEnums() throws ArgException {\n    Options options = new Options(\"test\", TestOptionsEnums.class);\n\n    options.parse(new String[] {\"--firstPass\", \"SMART_RLE\"});\n    assert TestOptionsEnums.firstPass == TestOptionsEnums.Compressor.SMART_RLE;\n    TestOptionsEnums.firstPass = TestOptionsEnums.Compressor.HUFFMAN;\n\n    options.parse(new String[] {\"--firstPass\", \"smart_rle\"});\n    assert TestOptionsEnums.firstPass == TestOptionsEnums.Compressor.SMART_RLE;\n    TestOptionsEnums.firstPass = TestOptionsEnums.Compressor.HUFFMAN;\n\n    options.parse(new String[] {\"--firstPass\", \"smart-rle\"});\n    assert TestOptionsEnums.firstPass == TestOptionsEnums.Compressor.SMART_RLE;\n\n    options.parse(new String[] {\"--firstPass\", \"rle\", \"--secondPass\", \"SMART-RLE\"});\n    assert TestOptionsEnums.firstPass == TestOptionsEnums.Compressor.RLE;\n    assert TestOptionsEnums.secondPass == TestOptionsEnums.Compressor.SMART_RLE;\n\n    options.parse(new String[] {\"--secondPass\", \"Huffman\"});\n    assert TestOptionsEnums.firstPass == TestOptionsEnums.Compressor.RLE;\n    assert TestOptionsEnums.secondPass == TestOptionsEnums.Compressor.HUFFMAN;\n  }\n\n  @Test\n  public void testOptionsEnumsFail() {\n    Options options = new Options(\"test\", TestOptionsEnums.class);\n    try {\n      // should fail: can not leave out _ or -\n      options.parse(new String[] {\"--firstPass\", \"smartrle\"});\n      org.junit.Assert.fail(\"Didn't throw ArgException as expected\");\n    } catch (ArgException e) {\n    }\n  }\n\n  @Test\n  public void testSplitLines() {\n\n    String str = \"one\\ntwo\\n\\rthree\\r\\nfour\\rfive\\n\\n\\nsix\\r\\n\\r\\n\\r\\n\";\n    String[] sa = UtilMDE.splitLines(str);\n    // for (String s : sa)\n    //   System.out.printf (\"'%s'%n\", s);\n    assert sa.length == 11;\n    assert sa[0].equals(\"one\");\n    assert sa[1].equals(\"two\");\n    assert sa[2].equals(\"three\");\n    assert sa[3].equals(\"four\");\n    assert sa[4].equals(\"five\");\n    assert sa[5].equals(\"\");\n    assert sa[6].equals(\"\");\n    assert sa[7].equals(\"six\");\n    assert sa[8].equals(\"\");\n    assert sa[9].equals(\"\");\n    assert sa[10].equals(\"\");\n  }\n\n  // Figure 1 from http://www.boost.org/libs/graph/doc/lengauer_tarjan_dominator.htm#fig:dominator-tree-example\n  private static /*@Nullable*/ Map<Integer, List</*@KeyFor(\"preds1\")*/ Integer>> preds1;\n  private static /*@Nullable*/ Map<Integer, List</*@KeyFor(\"succs1\")*/ Integer>> succs1;\n\n  @SuppressWarnings({\"keyfor\", \"nullness\"})\n  /*@EnsuresNonNull({\"preds1\", \"succs1\"})*/\n  private static void initializePreds1AndSucc1() {\n    if (preds1 != null) {\n      return;\n    }\n\n    preds1 = new LinkedHashMap<Integer, List<Integer>>();\n    succs1 = new LinkedHashMap<Integer, List<Integer>>();\n    for (int i = 0; i <= 7; i++) {\n      preds1.put(new Integer(i), new ArrayList<Integer>());\n      succs1.put(new Integer(i), new ArrayList<Integer>());\n    }\n    succs1.get(0).add(1);\n    preds1.get(1).add(0);\n    succs1.get(1).add(2);\n    preds1.get(2).add(1);\n    succs1.get(1).add(3);\n    preds1.get(3).add(1);\n    succs1.get(2).add(7);\n    preds1.get(7).add(2);\n    succs1.get(3).add(4);\n    preds1.get(4).add(3);\n    succs1.get(4).add(5);\n    preds1.get(5).add(4);\n    succs1.get(4).add(6);\n    preds1.get(6).add(4);\n    succs1.get(5).add(7);\n    preds1.get(7).add(5);\n    succs1.get(6).add(4);\n    preds1.get(4).add(6);\n  }\n\n  @SuppressWarnings(\"nullness\")\n  @Test\n  public void testGraphMDE() {\n\n    initializePreds1AndSucc1();\n\n    Map<Integer, List<Integer>> dom1post = GraphMDE.dominators(succs1);\n    assert dom1post.get(0).toString().equals(\"[7, 1, 0]\");\n    assert dom1post.get(1).toString().equals(\"[7, 1]\");\n    assert dom1post.get(2).toString().equals(\"[7, 2]\");\n    assert dom1post.get(3).toString().equals(\"[7, 5, 4, 3]\");\n    assert dom1post.get(4).toString().equals(\"[7, 5, 4]\");\n    assert dom1post.get(5).toString().equals(\"[7, 5]\");\n    assert dom1post.get(6).toString().equals(\"[7, 5, 4, 6]\");\n    assert dom1post.get(7).toString().equals(\"[7]\");\n\n    Map<Integer, List<Integer>> dom1pre = GraphMDE.dominators(preds1);\n    assert dom1pre.get(0).toString().equals(\"[0]\");\n    assert dom1pre.get(1).toString().equals(\"[0, 1]\");\n    assert dom1pre.get(2).toString().equals(\"[0, 1, 2]\");\n    assert dom1pre.get(3).toString().equals(\"[0, 1, 3]\");\n    assert dom1pre.get(4).toString().equals(\"[0, 1, 3, 4]\");\n    assert dom1pre.get(5).toString().equals(\"[0, 1, 3, 4, 5]\");\n    assert dom1pre.get(6).toString().equals(\"[0, 1, 3, 4, 6]\");\n    assert dom1pre.get(7).toString().equals(\"[0, 1, 7]\");\n\n    // I should add some more tests.\n\n  }\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10963,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "TestPlume",
  "javadocTag" : "@throws ArgException if there is an illegal argument",
  "methodJavadoc" : "    /**\n   * Test option groups (Options).\n   * @throws ArgException if there is an illegal argument\n   */",
  "methodSourceCode" : "public void testOptionGroups() throws ArgException{\n    // TODO: The following two exception tests are not adequate.  There must be\n    // a better way to do these.\n    try {\n        Options options = new Options(\"test\", TestOptionGroups1.class);\n    } catch (Error e) {\n        assert e.getMessage() != null && e.getMessage().indexOf(\"missing @OptionGroup annotation on the first @Option-annotated field\") > -1;\n    }\n    try {\n        Options options = new Options(\"test\", TestOptionGroups2.class, TestOptionGroups1.class);\n    } catch (Error e) {\n        assert e.getMessage() != null && e.getMessage().indexOf(\"missing @OptionGroup annotation in field\") > -1;\n    }\n    Options options = new Options(\"test\", TestOptionGroups2.class);\n    assert options.usage().indexOf(\"General options\") > -1;\n    assert options.usage().indexOf(\"Display options\") > -1;\n    // \"Internal options\" is unpublicized so it should not occur in the default\n    // usage message.\n    assert options.usage().indexOf(\"Internal options\") == -1;\n    assert options.usage(\"Internal options\").indexOf(\"Set mu\") > -1;\n    // \"Set pi\" should not appear in the usage message for \"Internal options\"\n    // because it is marked with @Unpublicized.\n    assert options.usage(\"Internal options\").indexOf(\"Set pi\") == -1;\n    options.parse(new String[] { \"--colour\", \"--pi\", \"3.15\" });\n    assert TestOptionGroups2.color;\n    assert TestOptionGroups2.pi == 3.15;\n    options.parse(\"--colour --pi 3.15\");\n    assert TestOptionGroups2.color;\n    assert TestOptionGroups2.pi == 3.15;\n    // Test that an option group that contains only unpublicized options is not\n    // included in the usage message.\n    Options options2 = new Options(\"test\", TestOptionGroups3.class);\n    assert options.usage().indexOf(\"Internal options\") == -1;\n    // ...unless include_unpublicized is true.\n    assert options.usage(true).indexOf(\"Internal options\") > -1;\n}",
  "classJavadoc" : "/** Test code for the plume package. */",
  "classSourceCode" : "package plume;\n\nimport static plume.Options.ArgException;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.CharArrayWriter;\nimport java.io.File;\nimport java.io.IOException;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Calendar;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Random;\nimport java.util.Vector;\nimport java.util.regex.Pattern;\nimport org.junit.Test;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.checker.signature.qual.*;\n*/\n\n// run like this:\n//   java plume.TestPlume\n\n// Files to test:\n// ArraysMDE.java\n// ClassFileVersion.java\n// CountingPrintWriter.java\n// Digest.java\n// FileIOException.java\n// FuzzyFloat.java\n// GraphMDE.java\n// Hasher.java\n// Intern.java\n// ICalAvailable.java\n// LimitedSizeIntSet.java\n// MathMDE.java\n// Options.java\n// OrderedPairIterator.java\n// StringBuilderDelimited.java\n// UtilMDE.java\n// WeakHasherMap.java\n\n/** Test code for the plume package. */\n@SuppressWarnings({\"interning\"}) // interning is due to apparent bugs\npublic final class TestPlume {\n\n  // If true, do 100 instead of 100000 iterations when testing randomElements.\n  // This saves only a little time.  However, it is significant when running\n  // under instrumentation such as that of Chicory.\n  static boolean short_run = false;\n\n  //   public static void main(String[] args) {\n  //     testUtilMDE();\n  //     testArraysMDE();\n  //     testHasher();\n  //     testIntern();\n  //     testMathMDE();\n  //     testOrderedPairIterator();\n  //     testPlume();\n  //     testWeakHasherMap();\n  //     System.out.println(\"All plume tests succeeded.\");\n  //   }\n\n  public static void assert_arrays_equals(int /*@Nullable*/ [] a1, int /*@Nullable*/ [] a2) {\n    boolean result = Arrays.equals(a1, a2);\n    if (!result) {\n      System.out.println(\n          \"Arrays differ: \" + ArraysMDE.toString(a1) + \", \" + ArraysMDE.toString(a2));\n    }\n    assert result;\n    //      assert(Arrays.equals(a1, a2),\n    //         \"Arrays differ: \" + ArraysMDE.toString(a1) + \", \" + ArraysMDE.toString(a2));\n  }\n\n  public static void assert_arrays_equals(double[] a1, double[] a2) {\n    boolean result = Arrays.equals(a1, a2);\n    if (!result) {\n      System.out.println(\n          \"Arrays differ: \" + ArraysMDE.toString(a1) + \", \" + ArraysMDE.toString(a2));\n    }\n    assert result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Utility functions\n  ///\n\n  public static Iterator<Integer> int_array_iterator(int[] nums) {\n    List<Integer> asList = new ArrayList<Integer>(nums.length);\n    for (int i = 0; i < nums.length; i++) {\n      asList.add(nums[i]);\n    }\n    return asList.iterator();\n  }\n\n  public static int[] int_iterator_array(Iterator<Integer> itor) {\n    Vector<Integer> v = new Vector<Integer>();\n    while (itor.hasNext()) {\n      v.add(itor.next());\n    }\n    int[] a = new int[v.size()];\n    for (int i = 0; i < a.length; i++) {\n      a[i] = v.elementAt(i).intValue();\n    }\n    return a;\n  }\n\n  public static <T> Vector<T> toVector(Iterator<T> itor) {\n    Vector<T> v = new Vector<T>();\n    while (itor.hasNext()) {\n      v.add(itor.next());\n    }\n    return v;\n  }\n\n  public static <T> Vector<T> toVector(Enumeration<T> e) {\n    Vector<T> v = new Vector<T>();\n    while (e.hasMoreElements()) {\n      v.add(e.nextElement());\n    }\n    return v;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Now the actual testing\n  ///\n\n  @Test\n  public void testArraysMDE() {\n\n    // public static int min(int[] a)\n    assert ArraysMDE.min(new int[] {1, 2, 3}) == 1;\n    assert ArraysMDE.min(new int[] {2, 33, 1}) == 1;\n    assert ArraysMDE.min(new int[] {3, -2, 1}) == -2;\n    assert ArraysMDE.min(new int[] {3}) == 3;\n\n    // public static int max(int[] a)\n    assert ArraysMDE.max(new int[] {1, 2, 3}) == 3;\n    assert ArraysMDE.max(new int[] {2, 33, 1}) == 33;\n    assert ArraysMDE.max(new int[] {3, -2, 1}) == 3;\n    assert ArraysMDE.max(new int[] {3}) == 3;\n\n    // public static int[] min_max(int[] a)\n    assert_arrays_equals(ArraysMDE.min_max(new int[] {1, 2, 3}), new int[] {1, 3});\n    assert_arrays_equals(ArraysMDE.min_max(new int[] {2, 33, 1}), new int[] {1, 33});\n    assert_arrays_equals(ArraysMDE.min_max(new int[] {3, -2, 1}), new int[] {-2, 3});\n    assert_arrays_equals(ArraysMDE.min_max(new int[] {3}), new int[] {3, 3});\n    try {\n      ArraysMDE.min_max(new int[] {});\n      throw new Error(\"Didn't throw ArrayIndexOutOfBoundsException\");\n    } catch (ArrayIndexOutOfBoundsException e) {\n    }\n    try {\n      ArraysMDE.min_max(new long[] {});\n      throw new Error(\"Didn't throw ArrayIndexOutOfBoundsException\");\n    } catch (ArrayIndexOutOfBoundsException e) {\n    }\n\n    // public static int sum(int[] a)\n    assert 0 == ArraysMDE.sum(new int[0]);\n    assert 10 == ArraysMDE.sum(new int[] {10});\n    assert 10 == ArraysMDE.sum(new int[] {1, 2, 3, 4});\n\n    // public static int sum(int[][] a)\n    assert 0 == ArraysMDE.sum(new int[0][0]);\n    assert 78 == ArraysMDE.sum(new int[][] {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}});\n    assert 68 == ArraysMDE.sum(new int[][] {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 11, 12}});\n\n    // public static double sum(double[] a)\n    assert 0 == ArraysMDE.sum(new double[0]);\n    assert 3.14 == ArraysMDE.sum(new double[] {3.14});\n    assert 8.624 == ArraysMDE.sum(new double[] {3.14, 2.718, -1.234, 4});\n\n    // public static double sum(double[][] a)\n    assert 0 == ArraysMDE.sum(new double[0][0]);\n    assert 79.5\n        == ArraysMDE.sum(new double[][] {{1.1, 2.2, 3.3, 4.4}, {5.5, 6, 7, 8}, {9, 10, 11, 12}});\n\n    // public static int element_range(int[] a)\n    assert ArraysMDE.element_range(new int[] {1, 2, 3}) == 2;\n    assert ArraysMDE.element_range(new int[] {2, 33, 1}) == 32;\n    assert ArraysMDE.element_range(new int[] {3, -2, 1}) == 5;\n    assert ArraysMDE.element_range(new int[] {3}) == 0;\n\n    // public static int indexOf(Object[] a, Object elt)\n    // public static int indexOfEq(Object[] a, Object elt)\n    {\n      Integer[] a = new Integer[10];\n      for (int i = 0; i < a.length; i++) {\n        a[i] = new Integer(i);\n      }\n      assert ArraysMDE.indexOf(a, new Integer(-1)) == -1;\n      assert ArraysMDE.indexOf(a, new Integer(0)) == 0;\n      assert ArraysMDE.indexOf(a, new Integer(7)) == 7;\n      assert ArraysMDE.indexOf(a, new Integer(9)) == 9;\n      assert ArraysMDE.indexOf(a, new Integer(10)) == -1;\n      assert ArraysMDE.indexOf(a, new Integer(20)) == -1;\n      assert ArraysMDE.indexOf(a, (Object) null) == -1;\n      assert ArraysMDE.indexOf(a, (Object) null, 1, 5) == -1;\n\n      assert ArraysMDE.indexOfEq(a, new Integer(-1)) == -1;\n      assert ArraysMDE.indexOfEq(a, new Integer(0)) == -1;\n      assert ArraysMDE.indexOfEq(a, new Integer(7)) == -1;\n      assert ArraysMDE.indexOfEq(a, new Integer(9)) == -1;\n      assert ArraysMDE.indexOfEq(a, new Integer(10)) == -1;\n      assert ArraysMDE.indexOfEq(a, new Integer(20)) == -1;\n      assert ArraysMDE.indexOfEq(a, (Object) null) == -1;\n      assert ArraysMDE.indexOfEq(a, (Object) null, 1, 5) == -1;\n      assert ArraysMDE.indexOfEq(a, a[0]) == 0;\n      assert ArraysMDE.indexOfEq(a, a[7]) == 7;\n      assert ArraysMDE.indexOfEq(a, a[9]) == 9;\n    }\n\n    // public static int indexOf(List<?> a, Object elt)\n    // public static int indexOf(List<?> a, Object elt, int minindex, int indexlimit)\n    // public static int indexOfEq(List<?> a, Object elt, int minindex, int indexlimit)\n    // public static int indexOfEq(List<?> a, Object elt)\n    {\n      assert ArraysMDE.indexOf((List<?>) new ArrayList<Object>(), (Object) null) == -1;\n      assert ArraysMDE.indexOf((List<?>) new ArrayList<Object>(), (Object) null, 0, -1) == -1;\n      assert ArraysMDE.indexOfEq((List<?>) new ArrayList<Object>(), (Object) null) == -1;\n      assert ArraysMDE.indexOfEq((List<?>) new ArrayList<Object>(), (Object) null, 0, -1) == -1;\n    }\n\n    // public static int indexOf(int[] a, int elt)\n    {\n      int[] a = new int[10];\n      for (int i = 0; i < a.length; i++) {\n        a[i] = i;\n      }\n      assert ArraysMDE.indexOf(a, -1) == -1;\n      assert ArraysMDE.indexOf(a, 0) == 0;\n      assert ArraysMDE.indexOf(a, 7) == 7;\n      assert ArraysMDE.indexOf(a, 9) == 9;\n      assert ArraysMDE.indexOf(a, 10) == -1;\n      assert ArraysMDE.indexOf(a, 20) == -1;\n    }\n\n    // public static int indexOf(boolean[] a, boolean elt)\n    {\n      boolean[] a = new boolean[10];\n      for (int i = 0; i < a.length; i++) {\n        a[i] = false;\n      }\n      assert ArraysMDE.indexOf(a, true) == -1;\n      assert ArraysMDE.indexOf(a, false) == 0;\n      a[9] = true;\n      assert ArraysMDE.indexOf(a, true) == 9;\n      assert ArraysMDE.indexOf(a, false) == 0;\n      a[7] = true;\n      assert ArraysMDE.indexOf(a, true) == 7;\n      assert ArraysMDE.indexOf(a, false) == 0;\n      a[0] = true;\n      assert ArraysMDE.indexOf(a, true) == 0;\n      assert ArraysMDE.indexOf(a, false) == 1;\n      for (int i = 0; i < a.length; i++) {\n        a[i] = true;\n      }\n      assert ArraysMDE.indexOf(a, true) == 0;\n      assert ArraysMDE.indexOf(a, false) == -1;\n    }\n\n    // public static int indexOf(Object[] a, Object[] sub)\n    // public static int indexOfEq(Object[] a, Object[] sub)\n    {\n      Integer[] a = new Integer[10];\n      for (int i = 0; i < a.length; i++) {\n        a[i] = new Integer(i);\n      }\n      Integer[] b = new Integer[] {};\n      Integer[] c = new Integer[] {a[0], a[1], a[2]};\n      Integer[] d = new Integer[] {a[1], a[2]};\n      Integer[] e = new Integer[] {a[2], a[3], a[4], a[5]};\n      Integer[] f = new Integer[] {a[7], a[8], a[9]};\n      Integer[] g = new Integer[] {a[7], new Integer(8), a[9]};\n      Integer[] h = new Integer[] {a[7], a[8], a[9], new Integer(10)};\n      @SuppressWarnings(\"nullness\") // accommodates poor annotation on indexOf(Object[], Object[])\n      Integer[] i = new Integer[] {a[7], a[8], null, a[9], new Integer(10)};\n      @SuppressWarnings(\"nullness\") // accommodates poor annotation on indexOf(Object[], Object[])\n      Integer[] j = new Integer[] {a[8], null, a[9]};\n      Integer[] c2 = new Integer[] {new Integer(0), new Integer(1), new Integer(2)};\n      Integer[] d2 = new Integer[] {new Integer(1), new Integer(2)};\n      Integer[] e2 = new Integer[] {new Integer(2), new Integer(3), new Integer(4), new Integer(5)};\n      Integer[] f2 = new Integer[] {new Integer(7), new Integer(8), new Integer(9)};\n\n      assert ArraysMDE.indexOf(a, b) == 0;\n      assert ArraysMDE.indexOfEq(a, b) == 0;\n      assert ArraysMDE.indexOf(a, c) == 0;\n      assert ArraysMDE.indexOfEq(a, c) == 0;\n      assert ArraysMDE.indexOf(a, c2) == 0;\n      assert ArraysMDE.indexOfEq(a, c2) == -1;\n      assert ArraysMDE.indexOf(a, d) == 1;\n      assert ArraysMDE.indexOfEq(a, d) == 1;\n      assert ArraysMDE.indexOf(a, d2) == 1;\n      assert ArraysMDE.indexOfEq(a, d2) == -1;\n      assert ArraysMDE.indexOf(a, e) == 2;\n      assert ArraysMDE.indexOfEq(a, e) == 2;\n      assert ArraysMDE.indexOf(a, e2) == 2;\n      assert ArraysMDE.indexOfEq(a, e2) == -1;\n      assert ArraysMDE.indexOf(a, f) == 7;\n      assert ArraysMDE.indexOfEq(a, f) == 7;\n      assert ArraysMDE.indexOf(a, f2) == 7;\n      assert ArraysMDE.indexOfEq(a, f2) == -1;\n      assert ArraysMDE.indexOf(a, g) == 7;\n      assert ArraysMDE.indexOfEq(a, g) == -1;\n      assert ArraysMDE.indexOf(a, h) == -1;\n      assert ArraysMDE.indexOfEq(a, h) == -1;\n      assert ArraysMDE.indexOf(i, j) == 1;\n      assert ArraysMDE.indexOfEq(i, j) == 1;\n      assert ArraysMDE.indexOf(a, i) == -1;\n      assert ArraysMDE.indexOfEq(a, i) == -1;\n    }\n\n    // public static int indexOf(int[] a, int[] sub)\n    {\n      int[] a = new int[10];\n      for (int i = 0; i < a.length; i++) {\n        a[i] = i;\n      }\n      int[] b = new int[] {};\n      int[] c = new int[] {a[0], a[1], a[2]};\n      int[] d = new int[] {a[1], a[2]};\n      int[] e = new int[] {a[2], a[3], a[4], a[5]};\n      int[] f = new int[] {a[7], a[8], a[9]};\n      int[] g = new int[] {a[7], 22, a[9]};\n      int[] h = new int[] {a[7], a[8], a[9], 10};\n\n      assert ArraysMDE.indexOf(a, b) == 0;\n      assert ArraysMDE.indexOf(a, c) == 0;\n      assert ArraysMDE.indexOf(a, d) == 1;\n      assert ArraysMDE.indexOf(a, e) == 2;\n      assert ArraysMDE.indexOf(a, f) == 7;\n      assert ArraysMDE.indexOf(a, g) == -1;\n      assert ArraysMDE.indexOf(a, h) == -1;\n\n      // Tests pulled from actual StackAr data\n      int[] origTheArray =\n          new int[] {\n            1267757, 1267757, 1267757, 1267757, 1267757, 1267757, 1267757, 1267757, 1267757,\n            1267757, 1267757, 0, 0, 0, 0, 0, 0, 0, 0, 0\n          };\n\n      int[] postTheArray = new int[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n      assert ArraysMDE.indexOf(postTheArray, origTheArray) == -1;\n      assert ArraysMDE.indexOf(origTheArray, postTheArray) == -1;\n    }\n\n    // public static int indexOf(boolean[] a, boolean[] sub)\n    // [I'm punting on this for now; deal with it later...]\n\n    // public static Object[] subarray(Object[] a, int startindex, int length)\n    // public static byte[] subarray(byte[] a, int startindex, int length)\n    // public static boolean[] subarray(boolean[] a, int startindex, int length)\n    // public static char[] subarray(char[] a, int startindex, int length)\n    // public static double[] subarray(double[] a, int startindex, int length)\n    // public static float[] subarray(float[] a, int startindex, int length)\n    // public static int[] subarray(int[] a, int startindex, int length)\n    // public static long[] subarray(long[] a, int startindex, int length)\n    // public static short[] subarray(short[] a, int startindex, int length)\n\n    // public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)\n    // public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)\n    // public static boolean isSubarray(int[] a, int[] sub, int a_offset)\n    // public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)\n    // (The subarray tests are missing; I hope that the indexOf(..., array)\n    // operations above test them sufficiently.)\n\n    // public static String toString(Object /*@Nullable*/ [] a)\n    // public static String toStringQuoted(Object /*@Nullable*/ [] a)\n    // public static String toString(Object /*@Nullable*/ [] a, boolean quoted)\n    // public static String toString(List<?> a)\n    // public static String toStringQuoted(List<?> a)\n    // public static String toString(List<?> a, boolean quoted)\n    {\n      assert ArraysMDE.toString((Object[]) null).equals(\"null\");\n      assert ArraysMDE.toStringQuoted((Object[]) null).equals(\"null\");\n      assert ArraysMDE.toString((List<?>) null).equals(\"null\");\n      assert ArraysMDE.toStringQuoted((List<?>) null).equals(\"null\");\n      assert ArraysMDE.toStringQuoted(Arrays.asList(new Object[] {3.14, null, \"hello\"}))\n          .equals(\"[3.14, null, \\\"hello\\\"]\");\n    }\n\n    // static String toString(int[] a)\n    assert ArraysMDE.toString(new int[] {}).equals(\"[]\");\n    assert ArraysMDE.toString(new int[] {0}).equals(\"[0]\");\n    assert ArraysMDE.toString(new int[] {0, 1, 2}).equals(\"[0, 1, 2]\");\n\n    // public static boolean sorted(int[] a)\n    assert ArraysMDE.sorted(new int[] {0, 1, 2});\n    assert ArraysMDE.sorted(new int[] {0, 1, 2, 2, 3, 3});\n    assert ArraysMDE.sorted(new int[] {});\n    assert ArraysMDE.sorted(new int[] {0});\n    assert ArraysMDE.sorted(new int[] {0, 1});\n    assert !ArraysMDE.sorted(new int[] {1, 0});\n    assert !ArraysMDE.sorted(new int[] {0, 1, 2, 1, 2, 3});\n\n    // public static int noDuplicates(int[] a)\n    assert ArraysMDE.noDuplicates(new int[] {1, 2, 3, 5, 4, 0}) == true;\n    assert ArraysMDE.noDuplicates(new int[] {1, 2, 3, 5, 4, 100}) == true;\n    assert ArraysMDE.noDuplicates(new int[] {2, 2, 3, 5, 4, 0}) == false;\n    assert ArraysMDE.noDuplicates(new int[] {1, 2, 3, 5, 4, 1}) == false;\n    assert ArraysMDE.noDuplicates(new int[] {1, 2, -3, -5, 4, 0}) == true;\n    assert ArraysMDE.noDuplicates(new int[] {1, 2, -2, -2, 4, 100}) == false;\n    assert ArraysMDE.noDuplicates(new int[] {}) == true;\n    assert ArraysMDE.noDuplicates(new int[] {42}) == true;\n\n    // public static int noDuplicates(long[] a)\n    assert ArraysMDE.noDuplicates(new long[] {1, 2, 3, 5, 4, 0}) == true;\n    assert ArraysMDE.noDuplicates(new long[] {1, 2, 3, 5, 4, 100}) == true;\n    assert ArraysMDE.noDuplicates(new long[] {2, 2, 3, 5, 4, 0}) == false;\n    assert ArraysMDE.noDuplicates(new long[] {1, 2, 3, 5, 4, 1}) == false;\n    assert ArraysMDE.noDuplicates(new long[] {1, 2, -3, -5, 4, 0}) == true;\n    assert ArraysMDE.noDuplicates(new long[] {1, 2, -2, -2, 4, 100}) == false;\n    assert ArraysMDE.noDuplicates(new long[] {}) == true;\n    assert ArraysMDE.noDuplicates(new long[] {42}) == true;\n\n    // public static int noDuplicates(double[] a)\n    assert ArraysMDE.noDuplicates(new double[] {1, 2, 3, 5, 4, 0}) == true;\n    assert ArraysMDE.noDuplicates(new double[] {1, 2, 3, 5, 4, 100}) == true;\n    assert ArraysMDE.noDuplicates(new double[] {2, 2, 3, 5, 4, 0}) == false;\n    assert ArraysMDE.noDuplicates(new double[] {1, 2, 3, 5, 4, 1}) == false;\n    assert ArraysMDE.noDuplicates(new double[] {1., 1.001, -3, -5, 4, 0}) == true;\n    assert ArraysMDE.noDuplicates(new double[] {1., 2, -2.00, -2, 4, 100}) == false;\n    assert ArraysMDE.noDuplicates(new double[] {}) == true;\n    assert ArraysMDE.noDuplicates(new double[] {42}) == true;\n\n    // public static int noDuplicates(String[] a)\n    assert ArraysMDE.noDuplicates(new String[] {\"1\", \"2\", \"3\", \"5\", \"4\", \"0\"}) == true;\n    assert ArraysMDE.noDuplicates(new String[] {\"A\", \"a\", \"foo\", \"Foo\", \"\"}) == true;\n    assert ArraysMDE.noDuplicates(new String[] {\" \", \" \"}) == false;\n    assert ArraysMDE.noDuplicates(new String[] {\"  \", \" \"}) == true;\n\n    // public static boolean fn_is_permutation(int[] a)\n    assert ArraysMDE.fn_is_permutation(new int[] {0, 1, 2, 3}) == true;\n    assert ArraysMDE.fn_is_permutation(new int[] {1, 2, 3, 0}) == true;\n    assert ArraysMDE.fn_is_permutation(new int[] {3, 2, 1, 0}) == true;\n    assert ArraysMDE.fn_is_permutation(new int[] {0, 1, 2, 2}) == false;\n    assert ArraysMDE.fn_is_permutation(new int[] {0, -1, 2, 3}) == false;\n    assert ArraysMDE.fn_is_permutation(new int[] {0, 1, 2, 4}) == false;\n    assert ArraysMDE.fn_is_permutation(new int[] {0, 0, 0, 0}) == false;\n\n    // public static boolean fn_is_total(int[] a)\n    assert ArraysMDE.fn_is_total(new int[] {0, 1, 2, 3}) == true;\n    assert ArraysMDE.fn_is_total(new int[] {1, 2, 3, 0}) == true;\n    assert ArraysMDE.fn_is_total(new int[] {3, 2, 1, 0}) == true;\n    assert ArraysMDE.fn_is_total(new int[] {0, 1, 2, 2}) == true;\n    assert ArraysMDE.fn_is_total(new int[] {-1, 0, 2, 3}) == false;\n    assert ArraysMDE.fn_is_total(new int[] {0, -1, 2, 3}) == false;\n    assert ArraysMDE.fn_is_total(new int[] {0, -2, 1, 3}) == true; // weird\n    assert ArraysMDE.fn_is_total(new int[] {0, 2, 3, -1}) == false;\n    assert ArraysMDE.fn_is_total(new int[] {0, 1, 2, 4}) == true;\n    assert ArraysMDE.fn_is_total(new int[] {0, 0, 0, 0}) == true;\n\n    // public static int[] fn_identity(int length)\n    assert_arrays_equals(ArraysMDE.fn_identity(0), new int[] {});\n    assert_arrays_equals(ArraysMDE.fn_identity(1), new int[] {0});\n    assert_arrays_equals(ArraysMDE.fn_identity(2), new int[] {0, 1});\n    assert_arrays_equals(ArraysMDE.fn_identity(3), new int[] {0, 1, 2});\n\n    // public static int[] fn_inverse_permutation(int[] a)\n    assert_arrays_equals(\n        ArraysMDE.fn_inverse_permutation(new int[] {0, 1, 2, 3}), new int[] {0, 1, 2, 3});\n    assert_arrays_equals(\n        ArraysMDE.fn_inverse_permutation(new int[] {1, 2, 3, 0}), new int[] {3, 0, 1, 2});\n    assert_arrays_equals(\n        ArraysMDE.fn_inverse_permutation(new int[] {3, 2, 1, 0}), new int[] {3, 2, 1, 0});\n\n    // public static int[] fn_inverse(int[] a, int arange)\n    assert_arrays_equals(ArraysMDE.fn_inverse(new int[] {0, 1, 2, 3}, 4), new int[] {0, 1, 2, 3});\n    assert_arrays_equals(ArraysMDE.fn_inverse(new int[] {1, 2, 3, 0}, 4), new int[] {3, 0, 1, 2});\n    assert_arrays_equals(ArraysMDE.fn_inverse(new int[] {3, 2, 1, 0}, 4), new int[] {3, 2, 1, 0});\n    try {\n      ArraysMDE.fn_inverse(new int[] {1, 0, 3, 0}, 4);\n      throw new Error();\n    } catch (UnsupportedOperationException e) {\n      assert e.getMessage() != null && e.getMessage().equals(\"Not invertible; a[1]=0 and a[3]=0\");\n    }\n    assert_arrays_equals(ArraysMDE.fn_inverse(new int[] {5}, 6), new int[] {-1, -1, -1, -1, -1, 0});\n    assert_arrays_equals(\n        ArraysMDE.fn_inverse(new int[] {1, 2, 3, 5}, 6), new int[] {-1, 0, 1, 2, -1, 3});\n\n    try {\n      assert_arrays_equals(\n          ArraysMDE.fn_inverse(new int[] {100, 101, 102, 103}, 4), new int[] {40, 41, 42, 43});\n      throw new Error();\n    } catch (IllegalArgumentException e) {\n      assert e.getMessage() != null && e.getMessage().equals(\"Bad range value: a[0]=100\");\n    }\n\n    // public static int[] fn_compose(int[] a, int[] b)\n    assert_arrays_equals(\n        ArraysMDE.fn_compose(new int[] {0, 1, 2, 3}, new int[] {0, 1, 2, 3}),\n        new int[] {0, 1, 2, 3});\n    assert_arrays_equals(\n        ArraysMDE.fn_compose(new int[] {1, 2, 3, 0}, new int[] {1, 2, 3, 0}),\n        new int[] {2, 3, 0, 1});\n    assert_arrays_equals(\n        ArraysMDE.fn_compose(new int[] {3, 2, 1, 0}, new int[] {3, 2, 1, 0}),\n        new int[] {0, 1, 2, 3});\n    assert_arrays_equals(\n        ArraysMDE.fn_compose(new int[] {0, 1, 0, 3}, new int[] {0, 5, 2, 1}),\n        new int[] {0, 5, 0, 1});\n    assert_arrays_equals(ArraysMDE.fn_compose(new int[] {0}, new int[] {5}), new int[] {5});\n    assert_arrays_equals(\n        ArraysMDE.fn_compose(new int[] {1, 2, 3, 5}, new int[] {1, 2, 3, 5, -1, -1}),\n        new int[] {2, 3, 5, -1});\n\n    // public static boolean isSubset(long[] smaller, long[] bigger)\n    // public static boolean isSubset(double[] smaller, double[] bigger)\n    // public static boolean isSubset(String[] smaller, String[] bigger)\n\n    {\n      double[] f1 = new double[10];\n      double[] f2 = new double[20];\n\n      for (int j = 0; j < f2.length; j++) {\n        f2[j] = j;\n      }\n      for (int i = 0; i < f2.length - f1.length; i++) {\n\n        //fill up f1 with elements of f2\n        for (int j = 0; j < f1.length; j++) {\n          f1[j] = f2[i + j];\n        }\n\n        f1[5] = f2[i];\n\n        double[] f1_copy = f1.clone();\n        double[] f2_copy = f2.clone();\n\n        assert ArraysMDE.isSubset(f1, f2);\n        assert_arrays_equals(f1, f1_copy);\n        assert_arrays_equals(f2, f2_copy);\n      }\n\n      double[] a1 = new double[] {1, 5, 10};\n      double[] a2 = new double[] {};\n      double[] a3 = new double[] {1};\n      double[] a4 = new double[] {10};\n      double[] a5 = new double[] {1, 10, 15, 20};\n      double[] a6 = new double[] {10, 10, 10, 10, 10, 1};\n\n      assert ArraysMDE.isSubset(a2, a1);\n      assert !ArraysMDE.isSubset(a1, a2);\n      assert !ArraysMDE.isSubset(a1, a5);\n      assert ArraysMDE.isSubset(a3, a1);\n      assert ArraysMDE.isSubset(a4, a1);\n      assert ArraysMDE.isSubset(a6, a1);\n      assert !ArraysMDE.isSubset(a1, a6);\n    }\n\n    // public static class IntArrayComparatorLexical implements Comparator\n    // public static class IntArrayComparatorLengthFirst implements Comparator\n    {\n      Comparator<int[]> iacl = new ArraysMDE.IntArrayComparatorLexical();\n      Comparator<int[]> iaclf = new ArraysMDE.IntArrayComparatorLengthFirst();\n\n      int[] a0 = new int[] {};\n      int[] a1 = new int[] {};\n      int[] a2 = new int[] {0, 1, 2, 3};\n      int[] a3 = new int[] {0, 1, 2, 3, 0};\n      int[] a4 = new int[] {0, 1, 2, 3, 4};\n      int[] a5 = new int[] {0, 1, 2, 3, 4};\n      int[] a6 = new int[] {0, 1, 5, 3, 4};\n      int[] a7 = new int[] {1, 2, 3, 4};\n      int[] a8 = new int[] {-5};\n      int[] a9 = new int[] {Integer.MAX_VALUE};\n      int[] a10 = new int[] {Integer.MIN_VALUE};\n\n      assert iacl.compare(a0, a1) == 0;\n      assert iaclf.compare(a0, a1) == 0;\n      assert iacl.compare(a1, a0) == 0;\n      assert iaclf.compare(a1, a0) == 0;\n      assert iacl.compare(a1, a2) < 0;\n      assert iaclf.compare(a1, a2) < 0;\n      assert iacl.compare(a2, a1) > 0;\n      assert iaclf.compare(a2, a1) > 0;\n      assert iacl.compare(a2, a3) < 0;\n      assert iaclf.compare(a2, a3) < 0;\n      assert iacl.compare(a3, a2) > 0;\n      assert iaclf.compare(a3, a2) > 0;\n      assert iacl.compare(a3, a4) < 0;\n      assert iaclf.compare(a3, a4) < 0;\n      assert iacl.compare(a4, a3) > 0;\n      assert iaclf.compare(a4, a3) > 0;\n      assert iacl.compare(a4, a5) == 0;\n      assert iaclf.compare(a4, a5) == 0;\n      assert iacl.compare(a5, a4) == 0;\n      assert iaclf.compare(a5, a4) == 0;\n      assert iacl.compare(a5, a6) < 0;\n      assert iaclf.compare(a5, a6) < 0;\n      assert iacl.compare(a6, a5) > 0;\n      assert iaclf.compare(a6, a5) > 0;\n      assert iacl.compare(a6, a7) < 0;\n      assert iaclf.compare(a6, a7) > 0;\n      assert iacl.compare(a7, a6) > 0;\n      assert iaclf.compare(a7, a6) < 0;\n      assert iacl.compare(a1, a4) < 0;\n      assert iaclf.compare(a1, a4) < 0;\n      assert iacl.compare(a4, a1) > 0;\n      assert iaclf.compare(a4, a1) > 0;\n      assert iacl.compare(a2, a4) < 0;\n      assert iaclf.compare(a2, a4) < 0;\n      assert iacl.compare(a4, a2) > 0;\n      assert iaclf.compare(a4, a2) > 0;\n      assert iacl.compare(a6, a4) > 0;\n      assert iaclf.compare(a6, a4) > 0;\n      assert iacl.compare(a4, a6) < 0;\n      assert iaclf.compare(a4, a6) < 0;\n      assert iacl.compare(a7, a4) > 0;\n      assert iaclf.compare(a7, a4) < 0;\n      assert iacl.compare(a4, a7) < 0;\n      assert iaclf.compare(a4, a7) > 0;\n      assert iacl.compare(a8, a9) < 0;\n      assert iaclf.compare(a8, a9) < 0;\n      assert iacl.compare(a10, a7) < 0;\n    }\n\n    // public static class LongArrayComparatorLexical implements Comparator\n    // public static class LongArrayComparatorLengthFirst implements Comparator\n    {\n      Comparator<long[]> lacl = new ArraysMDE.LongArrayComparatorLexical();\n      Comparator<long[]> laclf = new ArraysMDE.LongArrayComparatorLengthFirst();\n      long[] a0 = new long[] {};\n      long[] a1 = new long[] {};\n      long[] a2 = new long[] {0, 1, 2, 3};\n      long[] a3 = new long[] {0, 1, 2, 3, 0};\n      long[] a4 = new long[] {0, 1, 2, 3, 4};\n      long[] a5 = new long[] {0, 1, 2, 3, 4};\n      long[] a6 = new long[] {0, 1, 5, 3, 4};\n      long[] a7 = new long[] {1, 2, 3, 4};\n      long[] a8 = new long[] {-5};\n      long[] a9 = new long[] {Long.MAX_VALUE};\n      long[] a10 = new long[] {Long.MIN_VALUE};\n\n      assert lacl.compare(a0, a1) == 0;\n      assert laclf.compare(a0, a1) == 0;\n      assert lacl.compare(a1, a0) == 0;\n      assert laclf.compare(a1, a0) == 0;\n      assert lacl.compare(a1, a2) < 0;\n      assert laclf.compare(a1, a2) < 0;\n      assert lacl.compare(a2, a1) > 0;\n      assert laclf.compare(a2, a1) > 0;\n      assert lacl.compare(a2, a3) < 0;\n      assert laclf.compare(a2, a3) < 0;\n      assert lacl.compare(a3, a2) > 0;\n      assert laclf.compare(a3, a2) > 0;\n      assert lacl.compare(a3, a4) < 0;\n      assert laclf.compare(a3, a4) < 0;\n      assert lacl.compare(a4, a3) > 0;\n      assert laclf.compare(a4, a3) > 0;\n      assert lacl.compare(a4, a5) == 0;\n      assert laclf.compare(a4, a5) == 0;\n      assert lacl.compare(a5, a4) == 0;\n      assert laclf.compare(a5, a4) == 0;\n      assert lacl.compare(a5, a6) < 0;\n      assert laclf.compare(a5, a6) < 0;\n      assert lacl.compare(a6, a5) > 0;\n      assert laclf.compare(a6, a5) > 0;\n      assert lacl.compare(a6, a7) < 0;\n      assert laclf.compare(a6, a7) > 0;\n      assert lacl.compare(a7, a6) > 0;\n      assert laclf.compare(a7, a6) < 0;\n      assert lacl.compare(a1, a4) < 0;\n      assert laclf.compare(a1, a4) < 0;\n      assert lacl.compare(a4, a1) > 0;\n      assert laclf.compare(a4, a1) > 0;\n      assert lacl.compare(a2, a4) < 0;\n      assert laclf.compare(a2, a4) < 0;\n      assert lacl.compare(a4, a2) > 0;\n      assert laclf.compare(a4, a2) > 0;\n      assert lacl.compare(a6, a4) > 0;\n      assert laclf.compare(a6, a4) > 0;\n      assert lacl.compare(a4, a6) < 0;\n      assert laclf.compare(a4, a6) < 0;\n      assert lacl.compare(a7, a4) > 0;\n      assert laclf.compare(a7, a4) < 0;\n      assert lacl.compare(a4, a7) < 0;\n      assert laclf.compare(a4, a7) > 0;\n      assert lacl.compare(a8, a9) < 0;\n      assert laclf.compare(a8, a9) < 0;\n      assert lacl.compare(a10, a7) < 0;\n    }\n\n    // public static class DoubleArrayComparatorLexical implements Comparator\n    {\n      Comparator<double[]> dacl = new ArraysMDE.DoubleArrayComparatorLexical();\n      double[] a0 = new double[] {};\n      double[] a1 = new double[] {};\n      double[] a2 = new double[] {0, 1, 2, 3};\n      double[] a3 = new double[] {0, 1, 2, 3, 0};\n      double[] a4 = new double[] {0, 1, 2, 3, 4};\n      double[] a5 = new double[] {0, 1, 2, 3, 4};\n      double[] a6 = new double[] {0, 1, 5, 3, 4};\n      double[] a7 = new double[] {1, 2, 3, 4};\n      double[] a8 = new double[] {0.005};\n      double[] a9 = new double[] {0.004};\n      double[] a10 = new double[] {-0.005};\n      double[] a11 = new double[] {-0.004};\n      double[] a12 = new double[] {10.0 * Integer.MAX_VALUE};\n      double[] a13 = new double[] {10.0 * Integer.MIN_VALUE};\n\n      assert dacl.compare(a0, a1) == 0;\n      assert dacl.compare(a1, a0) == 0;\n      assert dacl.compare(a1, a2) < 0;\n      assert dacl.compare(a2, a1) > 0;\n      assert dacl.compare(a2, a3) < 0;\n      assert dacl.compare(a3, a2) > 0;\n      assert dacl.compare(a3, a4) < 0;\n      assert dacl.compare(a4, a3) > 0;\n      assert dacl.compare(a4, a5) == 0;\n      assert dacl.compare(a5, a4) == 0;\n      assert dacl.compare(a5, a6) < 0;\n      assert dacl.compare(a6, a5) > 0;\n      assert dacl.compare(a6, a7) < 0;\n      assert dacl.compare(a7, a6) > 0;\n      assert dacl.compare(a1, a4) < 0;\n      assert dacl.compare(a4, a1) > 0;\n      assert dacl.compare(a2, a4) < 0;\n      assert dacl.compare(a4, a2) > 0;\n      assert dacl.compare(a6, a4) > 0;\n      assert dacl.compare(a4, a6) < 0;\n      assert dacl.compare(a7, a4) > 0;\n      assert dacl.compare(a4, a7) < 0;\n\n      // Test the comparisons on small/large numbers\n      assert dacl.compare(a8, a9) > 0;\n      assert dacl.compare(a10, a11) < 0;\n      assert dacl.compare(a11, a12) < 0;\n      assert dacl.compare(a12, a13) > 0;\n      assert dacl.compare(a13, a11) < 0;\n    }\n\n    // public static class ObjectArrayComparatorLexical implements Comparator\n    // public static class ObjectArrayComparatorLengthFirst implements Comparator\n\n    // public static final class ComparableArrayComparatorLexical implements Comparator\n    // public static final class ComparableArrayComparatorLengthFirst implements Comparator\n    {\n      Comparator<String[]> cacl = new ArraysMDE.ComparableArrayComparatorLexical<String>();\n      Comparator<String[]> caclf = new ArraysMDE.ComparableArrayComparatorLengthFirst<String>();\n      String[] a0 = new String[] {};\n      String[] a1 = new String[] {};\n      String[] a2 = new String[] {\"0\", \"1\", \"2\", \"3\"};\n      String[] a3 = new String[] {\"0\", \"1\", \"2\", \"3\", \"0\"};\n      String[] a4 = new String[] {\"0\", \"1\", \"2\", \"3\", \"4\"};\n      String[] a5 = new String[] {\"0\", \"1\", \"2\", \"3\", \"4\"};\n      String[] a6 = new String[] {\"0\", \"1\", \"5\", \"3\", \"4\"};\n      String[] a7 = new String[] {\"1\", \"2\", \"3\", \"4\"};\n      @SuppressWarnings(\n          \"nullness\") // accommodates poor annotation on ComparableArrayComparatorLexical.compare() and ComparableArrayComparatorLengthFirst.compare()\n      String[] a8 = new String[] {\"0\", \"1\", null, \"3\", \"4\"};\n\n      assert cacl.compare(a0, a1) == 0;\n      assert caclf.compare(a0, a1) == 0;\n      assert cacl.compare(a1, a0) == 0;\n      assert caclf.compare(a1, a0) == 0;\n      assert cacl.compare(a1, a2) < 0;\n      assert caclf.compare(a1, a2) < 0;\n      assert cacl.compare(a2, a1) > 0;\n      assert caclf.compare(a2, a1) > 0;\n      assert cacl.compare(a2, a3) < 0;\n      assert caclf.compare(a2, a3) < 0;\n      assert cacl.compare(a3, a2) > 0;\n      assert caclf.compare(a3, a2) > 0;\n      assert cacl.compare(a3, a4) < 0;\n      assert caclf.compare(a3, a4) < 0;\n      assert cacl.compare(a4, a3) > 0;\n      assert caclf.compare(a4, a3) > 0;\n      assert cacl.compare(a4, a5) == 0;\n      assert caclf.compare(a4, a5) == 0;\n      assert cacl.compare(a5, a4) == 0;\n      assert caclf.compare(a5, a4) == 0;\n      assert cacl.compare(a5, a6) < 0;\n      assert caclf.compare(a5, a6) < 0;\n      assert cacl.compare(a6, a5) > 0;\n      assert caclf.compare(a6, a5) > 0;\n      assert cacl.compare(a6, a7) < 0;\n      assert caclf.compare(a6, a7) > 0;\n      assert cacl.compare(a7, a6) > 0;\n      assert caclf.compare(a7, a6) < 0;\n      assert cacl.compare(a1, a4) < 0;\n      assert caclf.compare(a1, a4) < 0;\n      assert cacl.compare(a4, a1) > 0;\n      assert caclf.compare(a4, a1) > 0;\n      assert cacl.compare(a2, a4) < 0;\n      assert caclf.compare(a2, a4) < 0;\n      assert cacl.compare(a4, a2) > 0;\n      assert caclf.compare(a4, a2) > 0;\n      assert cacl.compare(a6, a4) > 0;\n      assert caclf.compare(a6, a4) > 0;\n      assert cacl.compare(a4, a6) < 0;\n      assert caclf.compare(a4, a6) < 0;\n      assert cacl.compare(a7, a4) > 0;\n      assert caclf.compare(a7, a4) < 0;\n      assert cacl.compare(a8, a1) > 0;\n      assert caclf.compare(a8, a1) > 0;\n      assert cacl.compare(a1, a8) < 0;\n      assert caclf.compare(a1, a8) < 0;\n      assert cacl.compare(a8, a2) < 0;\n      assert caclf.compare(a8, a2) > 0;\n      assert cacl.compare(a2, a8) > 0;\n      assert caclf.compare(a2, a8) < 0;\n      assert cacl.compare(a8, a3) < 0;\n      assert caclf.compare(a8, a3) < 0;\n      assert cacl.compare(a3, a8) > 0;\n      assert caclf.compare(a3, a8) > 0;\n    }\n\n    // public static boolean any_null(Object[] a)\n    {\n      Object o = new Object();\n      assert ArraysMDE.any_null(new Object[] {}) == false;\n      assert ArraysMDE.any_null(new Object[] {null}) == true;\n      assert ArraysMDE.any_null(new Object[] {null, null}) == true;\n      assert ArraysMDE.any_null(new Object[] {o}) == false;\n      assert ArraysMDE.any_null(new Object[] {o, o}) == false;\n      assert ArraysMDE.any_null(new Object[] {o, null, null}) == true;\n      assert ArraysMDE.any_null(new Object[] {null, o, null}) == true;\n      assert ArraysMDE.any_null(new Object[] {o, null, o}) == true;\n      assert ArraysMDE.any_null(new Object[] {null, o, o}) == true;\n      assert ArraysMDE.any_null(new Object[][] {}) == false;\n      assert ArraysMDE.any_null(new Object[][] {null}) == true;\n      // Extraneous @Nullable on the following lines are due to CF issue #599:\n      // https://github.com/typetools/checker-framework/issues/599\n      assert ArraysMDE.any_null(new /*@Nullable*/ Object[][] {new Object[] {null}}) == false;\n      assert ArraysMDE.any_null(new /*@Nullable*/ Object[][] {new Object[] {null}, null}) == true;\n      assert ArraysMDE.any_null(\n              new /*@Nullable*/ Object[][] {new Object[] {null}, new Object[] {o}})\n          == false;\n    }\n\n    // public static boolean all_null(Object[] a)\n    {\n      Object o = new Object();\n      assert ArraysMDE.all_null(new Object[] {}) == true;\n      assert ArraysMDE.all_null(new Object[] {null}) == true;\n      assert ArraysMDE.all_null(new Object[] {null, null}) == true;\n      assert ArraysMDE.all_null(new Object[] {o}) == false;\n      assert ArraysMDE.all_null(new Object[] {o, o}) == false;\n      assert ArraysMDE.all_null(new Object[] {o, null, null}) == false;\n      assert ArraysMDE.all_null(new Object[] {null, o, null}) == false;\n      assert ArraysMDE.all_null(new Object[] {o, null, o}) == false;\n      assert ArraysMDE.all_null(new Object[] {null, o, o}) == false;\n      assert ArraysMDE.all_null(new Object[][] {}) == true;\n      assert ArraysMDE.all_null(new Object[][] {null}) == true;\n      assert ArraysMDE.all_null(new Object[][] {null, null}) == true;\n      assert ArraysMDE.all_null(new /*@Nullable*/ Object[][] {new Object[] {null}}) == false;\n      assert ArraysMDE.all_null(new /*@Nullable*/ Object[][] {new Object[] {null}, null}) == false;\n      assert ArraysMDE.all_null(\n              new /*@Nullable*/ Object[][] {new Object[] {null}, new Object[] {o}})\n          == false;\n    }\n  }\n\n  // This cannot be static because it instantiates an inner class.\n  @Test\n  public void testHasher() {\n\n    /// To check (maybe some of these are done already).\n    /// All of these methods are in Intern; should the tests appear in\n    /// testIntern() or here?\n    // public static void internStrings(String[] a)\n    // public static boolean isInterned(Object value)\n    // public static int numIntegers()\n    // public static int numIntArrays()\n    // public static int numDoubles()\n    // public static int numDoubleArrays()\n    // public static int numObjectArrays()\n    // public static Iterator integers()\n    // public static Iterator intArrays()\n    // public static Iterator doubles()\n    // public static Iterator doubleArrays()\n    // public static Iterator objectArrays()\n    // public static Integer intern(Integer a)\n    // public static Integer internedInteger(int i)\n    // public static Integer internedInteger(String s)\n    // public static int[] intern(int[] a)\n    // public static Double intern(Double a)\n    // public static Double internedDouble(int i)\n    // public static Double internedDouble(String s)\n    // public static double[] intern(double[] a)\n    // public static Object[] intern(Object[] a)\n\n    // private static class IntArrayHasher implements Hasher\n    // private static class ObjectArrayHasher implements Hasher\n    // public static int[] intern(int[] a)\n    // public static Object[] intern(Object[] a)\n\n    class InternTest {\n      // javadoc won't let this be static.\n      void test(boolean random) {\n        int size1 = (random ? 100 : 1);\n        int size2 = (random ? 10 : 1);\n\n        Random random_gen = new Random();\n\n        int[][] arrays = new int[100][];\n        for (int i = 0; i < arrays.length; i++) {\n          int[] a = new int[10];\n          for (int j = 0; j < a.length; j++) {\n            if (random) {\n              a[j] = random_gen.nextInt(1000);\n            } else {\n              a[j] = j;\n            }\n          }\n          arrays[i] = a;\n          // System.out.println(ArraysMDE.toString(a));\n          // Sadly, this is required to get the last array to be\n          // garbage-collected with Jikes 1.03 and JDK 1.2.2.\n          a = null;\n        }\n        System.gc();\n        if (Intern.numIntArrays() != 0) {\n          throw new Error(\" expected 0 int arrays at start, found \" + Intern.numIntArrays());\n        }\n        for (int i = 0; i < arrays.length; i++) {\n          Intern.intern(arrays[i]);\n        }\n        if (Intern.numIntArrays() != size1) {\n          throw new Error(\"Expected \" + size1 + \", got \" + Intern.numIntArrays() + \" int arrays\");\n        }\n        System.gc();\n        if (Intern.numIntArrays() != size1) {\n          throw new Error();\n        }\n        for (int i = 10; i < arrays.length; i++) {\n          @SuppressWarnings(\"nullness\")\n          int /*@NonNull*/ [] reset_value = null;\n          arrays[i] = reset_value;\n        }\n        System.gc();\n        if (Intern.numIntArrays() != size2) {\n          if (Intern.numIntArrays() < size2 + 10) {\n            System.out.println(\n                \"Is JIT disabled?  Size should have been \"\n                    + size2\n                    + \", actually was \"\n                    + Intern.numIntArrays());\n          } else {\n            System.out.println(\"================\");\n            for (int i = 0; i < arrays.length; i++) {\n              System.out.println(ArraysMDE.toString(arrays[i]));\n            }\n            System.out.println(\"================\");\n            for (Iterator<int[]> itor = Intern.intArrays(); itor.hasNext(); ) {\n              System.out.println(ArraysMDE.toString(itor.next()));\n            }\n            String message =\n                (\"Size should have been \" + size2 + \", actually was \" + Intern.numIntArrays());\n            System.out.println(message);\n            throw new Error(message);\n          }\n        }\n      }\n    }\n\n    InternTest intern = new InternTest();\n    intern.test(true);\n    intern.test(false);\n  }\n\n  @Test\n  public void testIntern() {\n    Integer i = Intern.internedInteger(\"1234\");\n    assert Intern.isInterned(i);\n    assert i.intValue() == 1234;\n    i = Intern.internedInteger(\"0x12ab\");\n    assert Intern.isInterned(i);\n    assert i.intValue() == 0x12ab;\n\n    Long l = Intern.internedLong(\"12345678\");\n    assert Intern.isInterned(l);\n    assert l.intValue() == 12345678;\n    l = Intern.internedLong(\"0x1234abcd\");\n    assert Intern.isInterned(l);\n    assert l.intValue() == 0x1234abcd;\n  }\n\n  // Tests the method \"Object intern(Object)\" in Intern.java\n  @Test\n  public void testInternObject() {\n    Object nIntern = Intern.intern((/*@Nullable*/ Object) null);\n    assert nIntern == null;\n\n    String sOrig = new String(\"foo\");\n    String sIntern = Intern.intern(sOrig);\n    Object sObjIntern = Intern.intern((Object) sOrig);\n    assert sIntern == sObjIntern;\n    Object sOtherIntern = Intern.intern(new String(\"foo\"));\n    assert sIntern == sOtherIntern;\n\n    String[] saOrig = new String[] {\"foo\", \"bar\"};\n    String[] saIntern = Intern.intern(saOrig);\n    Object saObjIntern = Intern.intern((Object) saOrig);\n    assert saIntern == saObjIntern;\n    Object saOtherIntern = Intern.intern(new String[] {\"foo\", \"bar\"});\n    assert saIntern == saOtherIntern;\n\n    Integer iOrig = new Integer(1);\n    Integer iIntern = Intern.intern(iOrig);\n    Object iObjIntern = Intern.intern((Object) iOrig);\n    assert iIntern == iObjIntern;\n    Object iOtherIntern = Intern.intern((Object) new Integer(1));\n    assert iIntern == iOtherIntern;\n\n    Long lOrig = new Long(12345678901234L);\n    Long lIntern = Intern.intern(lOrig);\n    Object lObjIntern = Intern.intern((Object) lOrig);\n    assert lIntern == lObjIntern;\n    Object lOtherIntern = Intern.intern((Object) new Long(12345678901234L));\n    assert lIntern == lOtherIntern;\n\n    int[] iaOrig = new int[] {1, 2, 3};\n    int[] iaIntern = Intern.intern(iaOrig);\n    Object iaObjIntern = Intern.intern((Object) iaOrig);\n    assert iaIntern == iaObjIntern;\n    Object iaOtherIntern = Intern.intern((Object) new int[] {1, 2, 3});\n    assert iaIntern == iaOtherIntern;\n\n    long[] laOrig = new long[] {12345678901234L, 98765432109876L};\n    long[] laIntern = Intern.intern(laOrig);\n    Object laObjIntern = Intern.intern((Object) laOrig);\n    assert laIntern == laObjIntern;\n    Object laOtherIntern = Intern.intern((Object) new long[] {12345678901234L, 98765432109876L});\n    assert laIntern == laOtherIntern;\n\n    // Need to test positive and negative zeros, infinities.\n\n    Double dOrig = new Double(3.14);\n    Double dIntern = Intern.intern(dOrig);\n    Object dObjIntern = Intern.intern((Object) dOrig);\n    assert dIntern == dObjIntern;\n    Object dOtherIntern = Intern.intern((Object) dOrig);\n    assert dIntern == dOtherIntern;\n\n    Double dnOrig = new Double(Double.NaN);\n    Double dnIntern = Intern.intern(dnOrig);\n    Object dnObjIntern = Intern.intern((Object) dnOrig);\n    assert dnIntern == dnObjIntern;\n    Object dnOtherIntern =\n        Intern.intern((Object) new Double(Double.POSITIVE_INFINITY / Double.POSITIVE_INFINITY));\n    assert dnIntern == dnOtherIntern;\n\n    Double diOrig = new Double(Double.POSITIVE_INFINITY);\n    Double diIntern = Intern.intern(diOrig);\n    Object diObjIntern = Intern.intern((Object) diOrig);\n    assert diIntern == diObjIntern;\n    Object diOtherIntern = Intern.intern((Object) new Double(2 * Double.MAX_VALUE));\n    assert diIntern == diOtherIntern;\n\n    double positive_zero = +0.0;\n    double negative_zero = -0.0;\n    assert positive_zero == negative_zero;\n    assert 1 / positive_zero == Double.POSITIVE_INFINITY;\n    assert 1 / negative_zero == Double.NEGATIVE_INFINITY;\n\n    Double dzOrig = new Double(positive_zero);\n    Double dzIntern = Intern.intern(dzOrig);\n    Object dzObjIntern = Intern.intern((Object) dzOrig);\n    assert dzIntern == dzObjIntern;\n    Object dzOtherIntern = Intern.intern((Object) new Double(negative_zero));\n    assert dzIntern == dzOtherIntern;\n\n    double[] daOrig = new double[] {3.14, 2.71};\n    double[] daIntern = Intern.intern(daOrig);\n    Object daObjIntern = Intern.intern((Object) daOrig);\n    assert daIntern == daObjIntern;\n    Object daOtherIntern = Intern.intern((Object) new double[] {3.14, 2.71});\n    assert daIntern == daOtherIntern;\n\n    double[] da2Orig = new double[] {+0.0, Double.NaN};\n    double[] da2Intern = Intern.intern(da2Orig);\n    Object da2ObjIntern = Intern.intern((Object) da2Orig);\n    assert da2Intern == da2ObjIntern;\n    Object da2OtherIntern =\n        Intern.intern(\n            (Object) new double[] {-0.0, Double.POSITIVE_INFINITY / Double.POSITIVE_INFINITY});\n    assert da2Intern == da2OtherIntern;\n\n    Object[] oaOrig = new Object[] {new String(\"foo\"), new Integer(1)};\n    Object[] oaIntern = Intern.intern(oaOrig);\n    Object oaObjIntern = Intern.intern((Object) oaOrig);\n    assert oaIntern == oaObjIntern;\n    Object oaOtherIntern = Intern.intern((Object) new Object[] {new String(\"foo\"), new Integer(1)});\n    assert oaIntern == oaOtherIntern;\n\n    java.awt.Point pOrig = new java.awt.Point(1, 2);\n    try {\n      Intern.intern((Object) pOrig); // performed for side effect\n      throw new Error(\"Didn't throw IllegalArgumentException\");\n    } catch (IllegalArgumentException e) {\n    }\n  }\n\n  // Add 100 elements randomly selected from the range 0..limit-1 to the set.\n  private static void lsis_add_elts(int limit, LimitedSizeSet<Integer> s) {\n    Random r = new Random(20140613);\n    for (int i = 0; i < 100; i++) {\n      s.add(r.nextInt(limit));\n    }\n  }\n\n  // Create a LimitedSizeSet of the given size, and add elements to it.\n  private static void lsis_test(int max_size) {\n    LimitedSizeSet<Integer> s = new LimitedSizeSet<Integer>(max_size);\n    for (int i = 1; i < 2 * max_size; i++) {\n      lsis_add_elts(i, s);\n      int size = s.size();\n      assert ((i <= max_size) ? (size == i) : (size == max_size + 1))\n          : String.format(\n              \"(%d<=%d) ? (%d==%d) : (%d==%d+1)   size=%d, i=%d, max_size=%d, s=%s\",\n              i,\n              max_size,\n              size,\n              i,\n              size,\n              max_size,\n              size,\n              i,\n              max_size,\n              s);\n    }\n  }\n\n  private static void lss_with_null_test() {\n    LimitedSizeSet</*@Nullable*/ Integer> s = new LimitedSizeSet</*@Nullable*/ Integer>(10);\n    s.add(1);\n    s.add(2);\n    s.add(null);\n    assert s.size() == 3;\n    assert s.contains(1);\n    assert s.contains(null);\n    s.add(3);\n    assert s.size() == 4;\n    assert s.contains(1);\n    assert s.contains(null);\n    assert s.contains(3);\n  }\n\n  @Test\n  public void testLimitedSizeSet() {\n    for (int i = 1; i < 10; i++) {\n      lsis_test(i);\n    }\n    lss_with_null_test();\n  }\n\n  // This cannot be static because it instantiates an inner class.\n  @Test\n  public void testMathMDE() {\n\n    // int negate(int a)\n    assert MathMDE.negate(3) == -3;\n    assert MathMDE.negate(-22) == 22;\n    assert MathMDE.negate(0) == 0;\n\n    // int bitwiseComplement(int a)\n    assert MathMDE.bitwiseComplement(3) == -4;\n    assert MathMDE.bitwiseComplement(-22) == 21;\n    assert MathMDE.bitwiseComplement(0) == -1;\n\n    // int sign(int a)\n    assert MathMDE.sign(3) == 1;\n    assert MathMDE.sign(-22) == -1;\n    assert MathMDE.sign(0) == 0;\n\n    // int pow(int base, int expt)\n    try {\n      assert MathMDE.pow(3, 3) == 27;\n      assert MathMDE.pow(-5, 5) == -3125;\n      assert MathMDE.pow(22, 0) == 1;\n      assert MathMDE.pow(4, 6) == 4096;\n      assert MathMDE.pow(1, 222222) == 1;\n      assert MathMDE.pow(-2, 25) == -33554432;\n      // This is beyond the precision.  Maybe return a long instead of an int?\n      // assert MathMDE.pow(-3, 25) == ...;\n    } catch (Exception e) {\n      e.printStackTrace();\n      throw new Error(e);\n    }\n    try {\n      MathMDE.pow(3, -3);\n      throw new Error(\"Didn't throw ArithmeticException\");\n    } catch (ArithmeticException e) {\n    }\n\n    // int gcd(int a, int b)\n    assert MathMDE.gcd(2, 50) == 2;\n    assert MathMDE.gcd(50, 2) == 2;\n    assert MathMDE.gcd(12, 144) == 12;\n    assert MathMDE.gcd(144, 12) == 12;\n    assert MathMDE.gcd(96, 144) == 48;\n    assert MathMDE.gcd(144, 96) == 48;\n    assert MathMDE.gcd(10, 25) == 5;\n    assert MathMDE.gcd(25, 10) == 5;\n    assert MathMDE.gcd(17, 25) == 1;\n    assert MathMDE.gcd(25, 17) == 1;\n    assert MathMDE.gcd(0, 10) == 10;\n    assert MathMDE.gcd(10, 0) == 10;\n    assert MathMDE.gcd(25, -10) == 5;\n    assert MathMDE.gcd(-25, -10) == 5;\n    assert MathMDE.gcd(-25, 10) == 5;\n\n    // int gcd(int[] a)\n    assert MathMDE.gcd(new int[] {2, 50}) == 2;\n    assert MathMDE.gcd(new int[] {12, 144}) == 12;\n    assert MathMDE.gcd(new int[] {96, 144}) == 48;\n    assert MathMDE.gcd(new int[] {10, 25}) == 5;\n    assert MathMDE.gcd(new int[] {100, 10, 25}) == 5;\n    assert MathMDE.gcd(new int[] {768, 324}) == 12;\n    assert MathMDE.gcd(new int[] {2400, 48, 36}) == 12;\n    assert MathMDE.gcd(new int[] {2400, 72, 36}) == 12;\n\n    // int gcd_differences(int[] a)\n    // Weak set of tests, derived directly from those of \"int gcd(int[] a)\".\n    assert MathMDE.gcd_differences(new int[] {0, 2, 52}) == 2;\n    assert MathMDE.gcd_differences(new int[] {0, 12, 156}) == 12;\n    assert MathMDE.gcd_differences(new int[] {0, 96, 240}) == 48;\n    assert MathMDE.gcd_differences(new int[] {0, 10, 35}) == 5;\n    assert MathMDE.gcd_differences(new int[] {0, 100, 110, 135}) == 5;\n    assert MathMDE.gcd_differences(new int[] {0, 768, 1092}) == 12;\n    assert MathMDE.gcd_differences(new int[] {0, 2400, 2448, 2484}) == 12;\n    assert MathMDE.gcd_differences(new int[] {0, 2400, 2472, 2508}) == 12;\n    assert MathMDE.gcd_differences(new int[] {5, 5, 5, 5}) == 0;\n\n    // int mod_positive(int x, int y)\n    assert MathMDE.mod_positive(33, 5) == 3;\n    assert MathMDE.mod_positive(-33, 5) == 2;\n    assert MathMDE.mod_positive(33, -5) == 3;\n    assert MathMDE.mod_positive(-33, -5) == 2;\n\n    // int[] missing_numbers(int[] nums)\n    assert_arrays_equals(MathMDE.missing_numbers(new int[] {3, 4, 5, 6, 7, 8}), new int[] {});\n    assert_arrays_equals(MathMDE.missing_numbers(new int[] {3, 4, 6, 7, 8}), new int[] {5});\n    assert_arrays_equals(MathMDE.missing_numbers(new int[] {3, 4, 8}), new int[] {5, 6, 7});\n    assert_arrays_equals(MathMDE.missing_numbers(new int[] {3, 5, 6, 8}), new int[] {4, 7});\n    assert_arrays_equals(MathMDE.missing_numbers(new int[] {3, 6, 8}), new int[] {4, 5, 7});\n\n    // class MissingNumbersIteratorInt\n    class TestMissingNumbersIteratorInt {\n      // javadoc won't let this be static\n      void test(int[] orig, boolean add_ends, int[] goal_missing) {\n        Iterator<Integer> orig_iterator = int_array_iterator(orig);\n        Iterator<Integer> missing_iterator =\n            new MathMDE.MissingNumbersIteratorInt(orig_iterator, add_ends);\n        int[] missing = TestPlume.int_iterator_array(missing_iterator);\n        assert_arrays_equals(missing, goal_missing);\n      }\n    }\n\n    TestMissingNumbersIteratorInt tmni = new TestMissingNumbersIteratorInt();\n    tmni.test(new int[] {3, 4, 5, 6, 7, 8}, false, new int[] {});\n    tmni.test(new int[] {3, 4, 6, 7, 8}, false, new int[] {5});\n    tmni.test(new int[] {3, 4, 8}, false, new int[] {5, 6, 7});\n    tmni.test(new int[] {3, 5, 6, 8}, false, new int[] {4, 7});\n    tmni.test(new int[] {3, 6, 8}, false, new int[] {4, 5, 7});\n    tmni.test(new int[] {3}, false, new int[] {});\n    tmni.test(new int[] {3, 4, 5}, false, new int[] {});\n    tmni.test(new int[] {3, 4, 5, 6, 7, 8}, true, new int[] {2, 9});\n    tmni.test(new int[] {3, 4, 6, 7, 8}, true, new int[] {2, 5, 9});\n    tmni.test(new int[] {3, 4, 8}, true, new int[] {2, 5, 6, 7, 9});\n    tmni.test(new int[] {3, 5, 6, 8}, true, new int[] {2, 4, 7, 9});\n    tmni.test(new int[] {3, 6, 8}, true, new int[] {2, 4, 5, 7, 9});\n    tmni.test(new int[] {3, 4, 5}, true, new int[] {2, 6});\n\n    tmni.test(new int[] {-1, 1, 2, 3, 5, 6, 7, 9}, true, new int[] {-2, 0, 4, 8, 10});\n\n    // int[] modulus(int[] nums)\n    // int[] modulus(Iterator itor)\n\n    class TestModulus {\n      // javadoc won't let this be static\n      void check(int[] nums, int /*@Nullable*/ [] goal_rm) {\n        int[] rm = MathMDE.modulus(nums);\n        if (!Arrays.equals(rm, goal_rm)) {\n          throw new Error(\n              \"Expected (r,m)=\"\n                  + ArraysMDE.toString(goal_rm)\n                  + \", saw (r,m)=\"\n                  + ArraysMDE.toString(rm));\n        }\n        if (rm == null) {\n          return;\n        }\n        int goal_r = rm[0];\n        int m = rm[1];\n        for (int i = 0; i < nums.length; i++) {\n          int r = nums[i] % m;\n          if (r < 0) {\n            r += m;\n          }\n          if (r != goal_r) {\n            throw new Error(\"Expected \" + nums[i] + \" % \" + m + \" = \" + goal_r + \", got \" + r);\n          }\n        }\n      }\n\n      // javadoc won't let this be static\n      void check(Iterator<Integer> itor, int /*@Nullable*/ [] goal_rm) {\n        // There would be no point to this:  it's testing\n        // int_iterator_array, not the iterator version!\n        // return check(int_iterator_array(itor), goal_rm);\n        assert_arrays_equals(MathMDE.modulus_int(itor), goal_rm);\n      }\n\n      // javadoc won't let this be static\n      void check_iterator(int[] nums, int /*@Nullable*/ [] goal_rm) {\n        check(int_array_iterator(nums), goal_rm);\n      }\n    }\n\n    TestModulus testModulus = new TestModulus();\n\n    testModulus.check(new int[] {3, 7, 47, 51}, new int[] {3, 4});\n    testModulus.check(new int[] {3, 11, 43, 51}, new int[] {3, 8});\n    testModulus.check(new int[] {3, 11, 47, 55}, new int[] {3, 4});\n    testModulus.check(new int[] {2383, 4015, -81, 463, -689}, new int[] {15, 32});\n    testModulus.check(new int[] {}, null);\n    testModulus.check(new int[] {1}, null);\n    testModulus.check(new int[] {3, 7}, null);\n    testModulus.check(new int[] {2, 3, 5, 7}, null);\n    testModulus.check(new int[] {2, 19, 101}, null);\n    testModulus.check(new int[] {5, 5, 5, 5, 5}, null);\n\n    testModulus.check_iterator(new int[] {}, null);\n    testModulus.check_iterator(new int[] {1}, null);\n    testModulus.check_iterator(new int[] {3, 7, 47, 51}, new int[] {3, 4});\n    testModulus.check_iterator(new int[] {3, 11, 43, 51}, new int[] {3, 8});\n    testModulus.check_iterator(new int[] {3, 11, 47, 55}, new int[] {3, 4});\n    testModulus.check_iterator(new int[] {2383, 4015, -81, 463, -689}, new int[] {15, 32});\n    testModulus.check_iterator(new int[] {5, 5, 5, 5, 5}, null);\n\n    // int[] nonmodulus_strict(int[] nums)\n    // int[] nonmodulus_nonstrict(int[] nums)\n    // int[] nonmodulus_strict(Iterator nums)\n\n    class TestNonModulus {\n      // javadoc won't let this be static\n      void check_strict(int[] nums, int /*@Nullable*/ [] goal_rm) {\n        check(nums, goal_rm, true);\n        Iterator<Integer> itor = int_array_iterator(nums);\n        assert_arrays_equals(MathMDE.nonmodulus_strict_int(itor), goal_rm);\n      }\n\n      // javadoc won't let this be static\n      void check_nonstrict(int[] nums, int /*@Nullable*/ [] goal_rm) {\n        check(nums, goal_rm, false);\n      }\n\n      // javadoc won't let this be static\n      void check(int[] nums, int /*@Nullable*/ [] goal_rm, boolean strict) {\n        int[] rm;\n        if (strict) {\n          rm = MathMDE.nonmodulus_strict(nums);\n        } else {\n          rm = MathMDE.nonmodulus_nonstrict(nums);\n        }\n        if (!Arrays.equals(rm, goal_rm)) {\n          throw new Error(\n              \"Expected (r,m)=\"\n                  + ArraysMDE.toString(goal_rm)\n                  + \", saw (r,m)=\"\n                  + ArraysMDE.toString(rm));\n        }\n        if (rm == null) {\n          return;\n        }\n        int goal_r = rm[0];\n        int m = rm[1];\n        for (int i = 0; i < nums.length; i++) {\n          int r = nums[i] % m;\n          if (r < 0) {\n            r += m;\n          }\n          if (r == goal_r) {\n            throw new Error(\"Expected inequality, saw \" + nums[i] + \" % \" + m + \" = \" + r);\n          }\n        }\n      }\n    }\n\n    TestNonModulus testNonModulus = new TestNonModulus();\n\n    testNonModulus.check_strict(new int[] {1, 2, 3, 5, 6, 7, 9}, null);\n    testNonModulus.check_strict(new int[] {-1, 1, 2, 3, 5, 6, 7, 9}, new int[] {0, 4});\n    testNonModulus.check_strict(new int[] {1, 2, 3, 5, 6, 7, 9, 11}, null);\n    testNonModulus.check_strict(new int[] {1, 2, 3, 5, 6, 7, 11}, null);\n    testNonModulus.check_strict(new int[] {1, 2, 4, 6, 8, 10}, null);\n\n    // null because only 7 elements, so don't try modulus = 4\n    testNonModulus.check_nonstrict(new int[] {1, 2, 3, 5, 6, 7, 9}, null);\n    testNonModulus.check_nonstrict(new int[] {1, 2, 3, 5, 6, 7, 9, 10}, new int[] {0, 4});\n    testNonModulus.check_nonstrict(new int[] {1, 2, 3, 5, 6, 7, 9, 11}, new int[] {0, 4});\n    testNonModulus.check_nonstrict(new int[] {1, 2, 3, 5, 6, 7, 9, 11, 12, 13}, null);\n    testNonModulus.check_nonstrict(\n        new int[] {1, 2, 3, 5, 6, 7, 9, 11, 12, 13, 14, 15}, new int[] {4, 6});\n    testNonModulus.check_nonstrict(new int[] {1, 2, 3, 5, 6, 7, 9, 11, 12, 13, 14, 15, 22}, null);\n  }\n\n  @Test\n  public void testOrderedPairIterator() {\n    final int NULL = -2222;\n\n    Vector<Integer> ones = new Vector<Integer>();\n    for (int i = 1; i <= 30; i++) {\n      ones.add(new Integer(i));\n    }\n    Vector<Integer> twos = new Vector<Integer>();\n    for (int i = 2; i <= 30; i += 2) {\n      twos.add(new Integer(i));\n    }\n    Vector<Integer> threes = new Vector<Integer>();\n    for (int i = 3; i <= 30; i += 3) {\n      threes.add(new Integer(i));\n    }\n\n    // I've replaced the nulls by 0 in order to permit the array elements\n    // to be ints instead of Integers.\n\n    compareOrderedPairIterator(\n        new OrderedPairIterator<Integer>(ones.iterator(), ones.iterator()),\n        new int[][] {\n          {1, 1}, {2, 2}, {3, 3}, {4, 4}, {5, 5}, {6, 6}, {7, 7}, {8, 8}, {9, 9}, {10, 10},\n          {11, 11}, {12, 12}, {13, 13}, {14, 14}, {15, 15}, {16, 16}, {17, 17}, {18, 18}, {19, 19},\n          {20, 20}, {21, 21}, {22, 22}, {23, 23}, {24, 24}, {25, 25}, {26, 26}, {27, 27}, {28, 28},\n          {29, 29}, {30, 30},\n        });\n\n    compareOrderedPairIterator(\n        new OrderedPairIterator<Integer>(ones.iterator(), twos.iterator()),\n        new int[][] {\n          {1, NULL},\n          {2, 2},\n          {3, NULL},\n          {4, 4},\n          {5, NULL},\n          {6, 6},\n          {7, NULL},\n          {8, 8},\n          {9, NULL},\n          {10, 10},\n          {11, NULL},\n          {12, 12},\n          {13, NULL},\n          {14, 14},\n          {15, NULL},\n          {16, 16},\n          {17, NULL},\n          {18, 18},\n          {19, NULL},\n          {20, 20},\n          {21, NULL},\n          {22, 22},\n          {23, NULL},\n          {24, 24},\n          {25, NULL},\n          {26, 26},\n          {27, NULL},\n          {28, 28},\n          {29, NULL},\n          {30, 30},\n        });\n\n    compareOrderedPairIterator(\n        new OrderedPairIterator<Integer>(twos.iterator(), ones.iterator()),\n        new int[][] {\n          {NULL, 1},\n          {2, 2},\n          {NULL, 3},\n          {4, 4},\n          {NULL, 5},\n          {6, 6},\n          {NULL, 7},\n          {8, 8},\n          {NULL, 9},\n          {10, 10},\n          {NULL, 11},\n          {12, 12},\n          {NULL, 13},\n          {14, 14},\n          {NULL, 15},\n          {16, 16},\n          {NULL, 17},\n          {18, 18},\n          {NULL, 19},\n          {20, 20},\n          {NULL, 21},\n          {22, 22},\n          {NULL, 23},\n          {24, 24},\n          {NULL, 25},\n          {26, 26},\n          {NULL, 27},\n          {28, 28},\n          {NULL, 29},\n          {30, 30},\n        });\n\n    compareOrderedPairIterator(\n        new OrderedPairIterator<Integer>(ones.iterator(), threes.iterator()),\n        new int[][] {\n          {1, NULL},\n          {2, NULL},\n          {3, 3},\n          {4, NULL},\n          {5, NULL},\n          {6, 6},\n          {7, NULL},\n          {8, NULL},\n          {9, 9},\n          {10, NULL},\n          {11, NULL},\n          {12, 12},\n          {13, NULL},\n          {14, NULL},\n          {15, 15},\n          {16, NULL},\n          {17, NULL},\n          {18, 18},\n          {19, NULL},\n          {20, NULL},\n          {21, 21},\n          {22, NULL},\n          {23, NULL},\n          {24, 24},\n          {25, NULL},\n          {26, NULL},\n          {27, 27},\n          {28, NULL},\n          {29, NULL},\n          {30, 30},\n        });\n\n    compareOrderedPairIterator(\n        new OrderedPairIterator<Integer>(twos.iterator(), threes.iterator()),\n        new int[][] {\n          {2, NULL},\n          {NULL, 3},\n          {4, NULL},\n          {6, 6},\n          {8, NULL},\n          {NULL, 9},\n          {10, NULL},\n          {12, 12},\n          {14, NULL},\n          {NULL, 15},\n          {16, NULL},\n          {18, 18},\n          {20, NULL},\n          {NULL, 21},\n          {22, NULL},\n          {24, 24},\n          {26, NULL},\n          {NULL, 27},\n          {28, NULL},\n          {30, 30},\n        });\n  }\n\n  /** Throws an assertion unless the paired iterator contains the same values as the argument array. */\n  public static void compareOrderedPairIterator(OrderedPairIterator<Integer> opi, int[][] ints) {\n    int pairno = 0;\n    while (opi.hasNext()) {\n      Pair</*@Nullable*/ Integer, /*@Nullable*/ Integer> pair = opi.next();\n      // System.out.println(\"Iterator: <\" + pair.a + \",\" + pair.b + \">, array: <\" + ints[pairno][0] + \",\" + ints[pairno][1] + \">\");\n      assert (pair.a == null) || (pair.a.intValue() == ints[pairno][0]);\n      assert (pair.b == null) || (pair.b.intValue() == ints[pairno][1]);\n      pairno++;\n    }\n    assert pairno == ints.length;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// TimeLimitProcess\n  ///\n\n  /**\n   * Print one integer periodically.\n   * <p>\n   * Example use from the command line, for one integer each half-second:\n   * <pre>  java plume.TestPlume\\$PrintOneIntPerSecond 500</pre>\n   */\n  public static class PrintOneIntPerTimePeriod {\n    /**\n     * @param args  two-element array containing:  how many to print; how many milliseconds between each\n     */\n    public static void main(String[] args) {\n      if (args.length != 2) {\n        System.err.println(\"Needs 2 arguments, got \" + args.length);\n      }\n      int limit = Integer.parseInt(args[0]);\n      int period = Integer.parseInt(args[1]);\n      for (int i = 0; i < limit; i++) {\n        System.out.printf(\"out%d \", i);\n        System.err.printf(\"err%d \", i);\n        try {\n          Thread.sleep(period);\n        } catch (InterruptedException e) {\n          // We don't care if this is interrupted\n        }\n      }\n    }\n  }\n\n  private static Runtime runtime = java.lang.Runtime.getRuntime();\n\n  // timePerNumber needs to be small so tests run fast, but large so that\n  // more output doesn't sneak out before the timeout kicks in.\n  private static Triple<Integer, String, String> printFive(\n      int timePerNumber, int timeLimit, boolean cache_stdout) {\n    String command = \"java plume.TestPlume$PrintOneIntPerTimePeriod 5 \" + timePerNumber;\n    TimeLimitProcess p;\n    try {\n      p = new TimeLimitProcess(runtime.exec(command), timeLimit, cache_stdout);\n    } catch (IOException e) {\n      throw new Error(e);\n    }\n    int result;\n    try {\n      result = p.waitFor();\n    } catch (InterruptedException e) {\n      throw new Error(e);\n    }\n    // System.out.printf(\"command:%s%n\", command);\n    // System.out.printf(\"result:%s%n\", result);\n    // System.out.printf(\"buffered stdout:%s%n\", p.cached_stdout);\n    // System.out.printf(\"buffered stderr:%s%n\", p.cached_stderr);\n    String out = UtilMDE.streamString(p.getInputStream());\n    String err = UtilMDE.streamString(p.getErrorStream());\n    // System.out.printf(\"out:%s%n\", out);\n    // System.out.printf(\"err:%s%n\", err);\n    return Triple.of(result, out, err);\n  }\n\n  private static void checkPrintFive(\n      int timePerNumber, int timeLimit, boolean cache_stdout, String out, String err) {\n    Triple<Integer, String, String> results = printFive(timePerNumber, timeLimit, cache_stdout);\n    if (!results.b.equals(out)) {\n      throw new Error(String.format(\"Expected %s, got %s\", out, results.b));\n    }\n    if (!results.c.equals(err)) {\n      throw new Error(String.format(\"Expected %s, got %s\", err, results.c));\n    }\n  }\n\n  /**\n   * On a heavily-loaded machine, this test fails.\n   * Try again when the load is lower.\n   * (Better might be exponential backoff up to some limit.)\n   */\n  @Test\n  public void testTimeLimitProcess() {\n    // checkPrintFive(10, 1000, false, \"out0 out1 out2 out3 out4 \", \"err0 err1 err2 err3 err4 \");\n    // checkPrintFive(10, 1000, true, \"out0 out1 out2 out3 out4 \", \"err0 err1 err2 err3 err4 \");\n\n    // These are too timing-dependent -- they sometimes succeed and\n    // sometimes fail -- so leave them commented out.\n    // checkPrintFive(2000, 1000, true, \"out0 \", \"err0 \");\n    // checkPrintFive(2000, 3000, true, \"out0 out1 \", \"err0 err1 \");\n\n    // This is expected to fail because of trying to read a closed stream.\n    // printFive(3, false);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// UtilMDE\n  ///\n\n  private static BitSet randomBitSet(int length, Random r) {\n    BitSet result = new BitSet(length);\n    for (int i = 0; i < length; i++) {\n      result.set(i, r.nextBoolean());\n    }\n    return result;\n  }\n\n  @Test\n  public void testStringBuilderDelimited() {\n    compareJoinAndSBD(new String[] {\"foo\", \"bar\", \"baz\"});\n    compareJoinAndSBD(new String[] {\"foo\"});\n    compareJoinAndSBD(new String[] {});\n  }\n\n  public void compareJoinAndSBD(String[] strings) {\n    StringBuilderDelimited sbd = new StringBuilderDelimited(\",\");\n    for (String str : strings) {\n      sbd.append(str);\n    }\n    assert sbd.toString().equals(UtilMDE.join(strings, \",\"));\n  }\n\n  private static void checkTypeStrings(\n      /*@FullyQualifiedName*/ String fqn,\n      /*@BinaryName*/ String bn,\n      /*@ClassGetName*/ String cgn,\n      /*@FieldDescriptor*/ String fd) {\n    checkTypeStrings(fqn, bn, cgn, fd, false);\n  }\n\n  private static void checkTypeStrings(\n      /*@FullyQualifiedName*/ String fqn,\n      /*@BinaryName*/ String bn,\n      /*@ClassGetName*/ String cgn,\n      /*@FieldDescriptor*/ String fd,\n      boolean skipClassForName) {\n    if (!skipClassForName) {\n      try {\n        UtilMDE.classForName(cgn); // ensure this does not crash\n      } catch (ClassNotFoundException e) {\n        throw new Error(e);\n      }\n    }\n    assert fd.equals(UtilMDE.binaryNameToFieldDescriptor(bn));\n    assert cgn.equals(UtilMDE.binaryNameToClassGetName(bn))\n        : bn + \" => \" + UtilMDE.binaryNameToClassGetName(bn) + \", should be \" + cgn;\n    assert cgn.equals(UtilMDE.fieldDescriptorToClassGetName(fd)) : fd + \" => \" + cgn;\n    assert bn.equals(UtilMDE.fieldDescriptorToBinaryName(fd));\n  }\n\n  // This cannot be static because it instantiates an inner class.\n  @Test\n  public void testUtilMDE() {\n\n    // public static intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)\n    {\n      Random r = new Random(20031008);\n      for (int i = 0; i < 100; i++) {\n        BitSet b1 = randomBitSet(r.nextInt(100), r);\n        BitSet b2 = randomBitSet(r.nextInt(100), r);\n        BitSet b3 = randomBitSet(r.nextInt(100), r);\n        BitSet intersection = (BitSet) b1.clone();\n        intersection.and(b2);\n        int card = intersection.cardinality();\n        for (int j = 0; j < 100; j++) {\n          assert UtilMDE.intersectionCardinalityAtLeast(b1, b2, j) == (card >= j);\n        }\n        intersection.and(b3);\n        card = intersection.cardinality();\n        for (int j = 0; j < 100; j++) {\n          assert UtilMDE.intersectionCardinalityAtLeast(b1, b2, b3, j) == (card >= j);\n        }\n      }\n    }\n\n    // public static BufferedReader bufferedFileReader(String filename)\n    // public static LineNumberReader lineNumberFileReader(String filename)\n    // public static BufferedWriter bufferedFileWriter(String filename) throws IOException\n    // public static Class classForName(String className)\n\n    // private boolean isSubtype(Class<?> sub, Class<?> sup) {\n    assert UtilMDE.isSubtype(Integer.class, Integer.class);\n    assert UtilMDE.isSubtype(Cloneable.class, Cloneable.class);\n    assert UtilMDE.isSubtype(Object.class, Object.class);\n    assert UtilMDE.isSubtype(Integer.class, Number.class);\n    assert !UtilMDE.isSubtype(Number.class, Integer.class);\n    assert UtilMDE.isSubtype(Integer.class, Comparable.class);\n    assert !UtilMDE.isSubtype(Comparable.class, Integer.class);\n    assert UtilMDE.isSubtype(Integer.class, Object.class);\n    assert !UtilMDE.isSubtype(Object.class, Integer.class);\n    assert !UtilMDE.isSubtype(Integer.class, Float.class);\n    assert UtilMDE.isSubtype(Collection.class, Iterable.class);\n    assert !UtilMDE.isSubtype(Iterable.class, Collection.class);\n    assert UtilMDE.isSubtype(ArrayList.class, Iterable.class);\n    assert !UtilMDE.isSubtype(Iterable.class, ArrayList.class);\n    assert UtilMDE.isSubtype(ArrayList.class, Cloneable.class);\n    assert !UtilMDE.isSubtype(Cloneable.class, ArrayList.class);\n    assert UtilMDE.isSubtype(ArrayList.class, List.class);\n    assert !UtilMDE.isSubtype(List.class, ArrayList.class);\n\n    // public static String binaryNameToFieldDescriptor(String classname)\n    assert UtilMDE.binaryNameToFieldDescriptor(\"boolean\").equals(\"Z\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"byte\").equals(\"B\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"char\").equals(\"C\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"double\").equals(\"D\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"float\").equals(\"F\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"int\").equals(\"I\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"long\").equals(\"J\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"short\").equals(\"S\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"Integer\").equals(\"LInteger;\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"Java.lang.Integer\").equals(\"LJava/lang/Integer;\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"int[][]\").equals(\"[[I\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"Java.lang.Integer[][][]\")\n        .equals(\"[[[LJava/lang/Integer;\");\n\n    // public static /*@ClassGetName*/ String binaryNameToClassGetName(/*BinaryName*/ String bn)\n    assert UtilMDE.binaryNameToClassGetName(\"boolean\").equals(\"boolean\");\n    assert UtilMDE.binaryNameToClassGetName(\"byte\").equals(\"byte\");\n    assert UtilMDE.binaryNameToClassGetName(\"char\").equals(\"char\");\n    assert UtilMDE.binaryNameToClassGetName(\"double\").equals(\"double\");\n    assert UtilMDE.binaryNameToClassGetName(\"float\").equals(\"float\");\n    assert UtilMDE.binaryNameToClassGetName(\"int\").equals(\"int\");\n    assert UtilMDE.binaryNameToClassGetName(\"long\").equals(\"long\");\n    assert UtilMDE.binaryNameToClassGetName(\"short\").equals(\"short\");\n    assert UtilMDE.binaryNameToClassGetName(\"Integer\").equals(\"Integer\");\n    assert UtilMDE.binaryNameToClassGetName(\"Java.lang.Integer\").equals(\"Java.lang.Integer\");\n    assert UtilMDE.binaryNameToClassGetName(\"int[][]\").equals(\"[[I\");\n    assert UtilMDE.binaryNameToClassGetName(\"Java.lang.Integer[][][]\")\n        .equals(\"[[[LJava.lang.Integer;\");\n\n    // public static String arglistToJvm(String arglist)\n    assert UtilMDE.arglistToJvm(\"()\").equals(\"()\");\n    assert UtilMDE.arglistToJvm(\"(int)\").equals(\"(I)\");\n    assert UtilMDE.arglistToJvm(\"(int, int)\").equals(\"(II)\");\n    assert UtilMDE.arglistToJvm(\"(int, long, short)\").equals(\"(IJS)\");\n    assert UtilMDE.arglistToJvm(\"(java.lang.Integer, int, java.lang.Integer)\")\n        .equals(\"(Ljava/lang/Integer;ILjava/lang/Integer;)\");\n    assert UtilMDE.arglistToJvm(\"(int[])\").equals(\"([I)\");\n    assert UtilMDE.arglistToJvm(\"(int[], int, int)\").equals(\"([III)\");\n    assert UtilMDE.arglistToJvm(\"(int, int[][], int)\").equals(\"(I[[II)\");\n    assert UtilMDE.arglistToJvm(\"(java.lang.Integer[], int, java.lang.Integer[][])\")\n        .equals(\"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\");\n\n    // public static String fieldDescriptorToBinaryName(String classname)\n    assert UtilMDE.fieldDescriptorToBinaryName(\"Z\").equals(\"boolean\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"B\").equals(\"byte\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"C\").equals(\"char\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"D\").equals(\"double\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"F\").equals(\"float\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"I\").equals(\"int\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"J\").equals(\"long\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"S\").equals(\"short\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"LInteger;\").equals(\"Integer\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"LJava/lang/Integer;\").equals(\"Java.lang.Integer\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"[[I\").equals(\"int[][]\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"[[LJava/lang/Integer;\")\n        .equals(\"Java.lang.Integer[][]\");\n\n    // public static /*@ClassGetName*/ String fieldDescriptorToClassGetName(/*FieldDescriptor*/ String fd)\n    assert UtilMDE.fieldDescriptorToClassGetName(\"Z\").equals(\"boolean\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"B\").equals(\"byte\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"C\").equals(\"char\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"D\").equals(\"double\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"F\").equals(\"float\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"I\").equals(\"int\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"J\").equals(\"long\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"S\").equals(\"short\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"LInteger;\").equals(\"Integer\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"LJava/lang/Integer;\").equals(\"Java.lang.Integer\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"[[I\").equals(\"[[I\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"[[LJava/lang/Integer;\")\n        .equals(\"[[LJava.lang.Integer;\");\n\n    // public static String arglistFromJvm(String arglist)\n    assert UtilMDE.arglistFromJvm(\"()\").equals(\"()\");\n    assert UtilMDE.arglistFromJvm(\"(I)\").equals(\"(int)\");\n    assert UtilMDE.arglistFromJvm(\"(II)\").equals(\"(int, int)\");\n    assert UtilMDE.arglistFromJvm(\"(IJS)\").equals(\"(int, long, short)\");\n    assert UtilMDE.arglistFromJvm(\"(Ljava/lang/Integer;ILjava/lang/Integer;)\")\n        .equals(\"(java.lang.Integer, int, java.lang.Integer)\");\n    assert UtilMDE.arglistFromJvm(\"([I)\").equals(\"(int[])\");\n    assert UtilMDE.arglistFromJvm(\"([III)\").equals(\"(int[], int, int)\");\n    assert UtilMDE.arglistFromJvm(\"(I[[II)\").equals(\"(int, int[][], int)\");\n    assert UtilMDE.arglistFromJvm(\"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\")\n        .equals(\"(java.lang.Integer[], int, java.lang.Integer[][])\");\n\n    // More tests for type representation conversions.\n    // Table from Signature Checker manual.\n    checkTypeStrings(\"int\", \"int\", \"int\", \"I\");\n    checkTypeStrings(\"int[][]\", \"int[][]\", \"[[I\", \"[[I\");\n    checkTypeStrings(\"MyClass\", \"MyClass\", \"MyClass\", \"LMyClass;\", true);\n    checkTypeStrings(\"MyClass[]\", \"MyClass[]\", \"[LMyClass;\", \"[LMyClass;\", true);\n    checkTypeStrings(\n        \"java.lang.Integer\", \"java.lang.Integer\", \"java.lang.Integer\", \"Ljava/lang/Integer;\");\n    checkTypeStrings(\n        \"java.lang.Integer[]\",\n        \"java.lang.Integer[]\",\n        \"[Ljava.lang.Integer;\",\n        \"[Ljava/lang/Integer;\");\n    checkTypeStrings(\n        \"java.lang.Byte.ByteCache\",\n        \"java.lang.Byte$ByteCache\",\n        \"java.lang.Byte$ByteCache\",\n        \"Ljava/lang/Byte$ByteCache;\");\n    checkTypeStrings(\n        \"java.lang.Byte.ByteCache[]\",\n        \"java.lang.Byte$ByteCache[]\",\n        \"[Ljava.lang.Byte$ByteCache;\",\n        \"[Ljava/lang/Byte$ByteCache;\");\n\n    // public static void addToClasspath(String dir)\n    // public static final class WildcardFilter implements FilenameFilter\n    //   public WildcardFilter(String filename)\n    //   public boolean accept(File dir, String name)\n    // public static boolean canCreateAndWrite(File file)\n    // public static void writeObject(Object o, File file) throws IOException\n    // public static Object readObject(File file)\n    // public static File createTempDir(String prefix, String suffix)\n\n    // public Object incrementHashMap(HashMap hm, Object key, int count)\n\n    try {\n      assert UtilMDE.canCreateAndWrite(new File(\"TestPlume.java\"));\n\n      // This test fails if run by the superuser (who can overwrite\n      // any file).\n      if (!System.getProperty(\"user.name\").equals(\"root\")) {\n        File readOnly = new File(\"temp\");\n        readOnly.createNewFile();\n        readOnly.setReadOnly();\n        assert !UtilMDE.canCreateAndWrite(readOnly);\n        readOnly.delete();\n      }\n\n      assert UtilMDE.canCreateAndWrite(new File(\"temp\"));\n      assert !UtilMDE.canCreateAndWrite(new File(\"temp/temp\"));\n    } catch (IOException e) {\n      e.printStackTrace();\n      org.junit.Assert.fail(\"failure while testing UtilMDE.canCreateAndWrite(): \" + e.toString());\n    }\n\n    {\n      // These names are taken from APL notation, where iota creates an\n      // array of all the numbers up to its argument.\n      Vector<Integer> iota0 = new Vector<Integer>();\n      Vector<Integer> iota10 = new Vector<Integer>();\n      for (int i = 0; i < 10; i++) {\n        iota10.add(new Integer(i));\n      }\n      Vector<Integer> iota10_twice = new Vector<Integer>();\n      iota10_twice.addAll(iota10);\n      iota10_twice.addAll(iota10);\n      Vector<Integer> iota10_thrice = new Vector<Integer>();\n      iota10_thrice.addAll(iota10);\n      iota10_thrice.addAll(iota10);\n      iota10_thrice.addAll(iota10);\n\n      // public static class EnumerationIterator implements Iterator\n      // public static class IteratorEnumeration implements Enumeration\n\n      assert iota0.equals(toVector(iota0.iterator()));\n      assert iota0.equals(toVector(new UtilMDE.IteratorEnumeration<Integer>(iota0.iterator())));\n      assert iota0.equals(toVector(iota0.elements()));\n      assert iota0.equals(toVector(new UtilMDE.EnumerationIterator<Integer>(iota0.elements())));\n      assert iota10.equals(toVector(iota10.iterator()));\n      assert iota10.equals(toVector(new UtilMDE.IteratorEnumeration<Integer>(iota10.iterator())));\n      assert iota10.equals(toVector(iota10.elements()));\n      assert iota10.equals(toVector(new UtilMDE.EnumerationIterator<Integer>(iota10.elements())));\n\n      // public static class MergedIterator2 implements Iterator {\n      assert iota10_twice.equals(\n          toVector(new UtilMDE.MergedIterator2<Integer>(iota10.iterator(), iota10.iterator())));\n      assert iota10.equals(\n          toVector(new UtilMDE.MergedIterator2<Integer>(iota0.iterator(), iota10.iterator())));\n      assert iota10.equals(\n          toVector(new UtilMDE.MergedIterator2<Integer>(iota10.iterator(), iota0.iterator())));\n\n      // public static class MergedIterator implements Iterator {\n      Vector<Iterator<Integer>> iota10_iterator_thrice = new Vector<Iterator<Integer>>();\n      iota10_iterator_thrice.add(iota10.iterator());\n      iota10_iterator_thrice.add(iota10.iterator());\n      iota10_iterator_thrice.add(iota10.iterator());\n      assert iota10_thrice.equals(\n          toVector(new UtilMDE.MergedIterator<Integer>(iota10_iterator_thrice.iterator())));\n      Vector<Iterator<Integer>> iota10_iterator_twice_1 = new Vector<Iterator<Integer>>();\n      iota10_iterator_twice_1.add(iota0.iterator());\n      iota10_iterator_twice_1.add(iota10.iterator());\n      iota10_iterator_twice_1.add(iota10.iterator());\n      Vector<Iterator<Integer>> iota10_iterator_twice_2 = new Vector<Iterator<Integer>>();\n      iota10_iterator_twice_2.add(iota10.iterator());\n      iota10_iterator_twice_2.add(iota0.iterator());\n      iota10_iterator_twice_2.add(iota10.iterator());\n      Vector<Iterator<Integer>> iota10_iterator_twice_3 = new Vector<Iterator<Integer>>();\n      iota10_iterator_twice_3.add(iota10.iterator());\n      iota10_iterator_twice_3.add(iota10.iterator());\n      iota10_iterator_twice_3.add(iota0.iterator());\n      assert iota10_twice.equals(\n          toVector(new UtilMDE.MergedIterator<Integer>(iota10_iterator_twice_1.iterator())));\n      assert iota10_twice.equals(\n          toVector(new UtilMDE.MergedIterator<Integer>(iota10_iterator_twice_2.iterator())));\n      assert iota10_twice.equals(\n          toVector(new UtilMDE.MergedIterator<Integer>(iota10_iterator_twice_3.iterator())));\n\n      class OddFilter implements Filter<Integer> {\n        public OddFilter() {}\n\n        public boolean accept(Integer i) {\n          return i.intValue() % 2 != 0;\n        }\n      }\n\n      // public static final class FilteredIterator implements Iterator\n\n      Vector<Integer> iota10_odd = new Vector<Integer>();\n      for (int i = 0; i < iota10.size(); i++) {\n        if (i % 2 != 0) {\n          iota10_odd.add(new Integer(i));\n        }\n      }\n      assert iota10_odd.equals(\n          toVector(new UtilMDE.FilteredIterator<Integer>(iota10.iterator(), new OddFilter())));\n    }\n\n    // public static final class RemoveFirstAndLastIterator implements Iterator\n    {\n      Vector<Integer> iota5 = new Vector<Integer>();\n      for (int i = 0; i < 5; i++) {\n        iota5.add(new Integer(i));\n      }\n      Vector<Integer> iota5middle = new Vector<Integer>();\n      for (int i = 1; i < 4; i++) {\n        iota5middle.add(new Integer(i));\n      }\n      UtilMDE.RemoveFirstAndLastIterator<Integer> rfali =\n          new UtilMDE.RemoveFirstAndLastIterator<Integer>(iota5.iterator());\n      Vector<Integer> rfali_vector = toVector(rfali);\n      assert iota5middle.equals(rfali_vector);\n      assert rfali.getFirst().equals(new Integer(0));\n      assert rfali.getLast().equals(new Integer(4));\n    }\n\n    // public static ArrayList randomElements(Iterator itor, int num_elts)\n    // public static ArrayList randomElements(Iterator itor, int num_elts, Random random)\n\n    // Iterate through numbers from zero up to the argument (non-inclusive)\n    class IotaIterator implements Iterator<Integer> {\n      int i = 0;\n      int limit;\n\n      public IotaIterator(int limit) {\n        this.limit = limit;\n      }\n\n      @Override\n      public boolean hasNext() {\n        return i < limit;\n      }\n\n      @Override\n      public Integer next() {\n        if (!hasNext()) {\n          throw new NoSuchElementException();\n        }\n        return new Integer(i++);\n      }\n\n      @Override\n      public void remove() {\n        throw new UnsupportedOperationException();\n      }\n    }\n    {\n      // Typically, no progress reports are printed, because the loop\n      // finishes in well under 1 minute.  Users will see progress reports\n      // when this class is slowed down by instrumentation.\n      Calendar nextNotification = Calendar.getInstance();\n      nextNotification.add(Calendar.MINUTE, 1);\n      DateFormat df = new SimpleDateFormat();\n\n      int itor_size = 10;\n      int num_elts_limit = 12;\n      int tries = short_run ? 100 : 100000;\n      double ratio_limit = .02;\n      Random r = new Random(20020311);\n      // \"i++\" instead of \"i+=3\" here works, but is slow\n      for (int i = 1; i < num_elts_limit; i += 3) {\n        int[] totals = new int[num_elts_limit];\n        for (int j = 0; j < tries; j++) {\n          if (j % 100 == 0) {\n            Calendar now = Calendar.getInstance();\n            if (now.after(nextNotification)) {\n              System.out.printf(\n                  \"%s: iteration (%d,%d) out of (%d,%d)%n\",\n                  df.format(nextNotification.getTime()),\n                  i,\n                  j,\n                  num_elts_limit,\n                  tries);\n              nextNotification.add(Calendar.MINUTE, 1);\n            }\n          }\n          List<Integer> chosen = UtilMDE.randomElements(new IotaIterator(itor_size), i, r);\n          for (int m = 0; m < chosen.size(); m++) {\n            for (int n = m + 1; n < chosen.size(); n++) {\n              if (chosen.get(m).intValue() == chosen.get(n).intValue()) {\n                throw new Error(\"Duplicate at \" + m + \",\" + n);\n              }\n            }\n          }\n          for (int k = 0; k < chosen.size(); k++) {\n            totals[chosen.get(k).intValue()]++;\n          }\n        }\n        int i_truncated = Math.min(itor_size, i);\n        int grand_total = tries * i_truncated;\n        assert ArraysMDE.sum(totals) == grand_total : \"Totals = \" + ArraysMDE.sum(totals);\n        // System.out.print(\"chosen:\\t\");\n        for (int k = 0; k < num_elts_limit; k++) {\n          int this_total = totals[k];\n          int expected = tries * i_truncated / itor_size;\n          double ratio = (double) this_total / (double) expected;\n          // System.out.print(((k<10) ? \" \" : \"\") + k + \" \" + this_total + \"\\t\");\n          // System.out.print(\"\\nExp=\" + expected + \"\\tratio=\" + ratio + \"\\t\");\n          assert k >= itor_size || (ratio > ratio_limit && ratio < 1 / ratio_limit);\n        }\n        // System.out.println();\n      }\n    }\n\n    // public static <T> /*@Nullable*/ Integer incrementMap(Map<T,Integer> m, T key, int count) {\n    // public static <K,V> String mapToString(Map<K,V> m) {\n    // public static <K,V> void mapToString(Appendable sb, Map<K,V> m, String linePrefix) {\n    // public static <K extends Comparable<? super K>,V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(Map<K,V> m) {\n    // public static <K,V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(Map<K,V> m, Comparator<K> comparator) {\n\n    // public static Method methodForName(String methodname) throws ClassNotFoundException\n    //\n    // essentially I am just testing whether the return is erroneous\n    try {\n      assert null\n          != UtilMDE.methodForName(\n              \"plume.UtilMDE.methodForName(java.lang.String, java.lang.String, java.lang.Class[])\");\n      assert null\n          != UtilMDE.methodForName(\n              \"plume.UtilMDE.methodForName(java.lang.String,java.lang.String,java.lang.Class[])\");\n      assert null != UtilMDE.methodForName(\"java.lang.Math.min(int,int)\");\n    } catch (Exception e) {\n      e.printStackTrace();\n      throw new Error(e);\n    }\n    try {\n      java.lang.reflect.Method m = UtilMDE.methodForName(\"plume.UtilMDE.methodForName()\");\n      throw new Error(\"Didn't throw NoSuchMethodException\");\n    } catch (NoSuchMethodException e) {\n      // nothing to do; this is the expected case\n    } catch (Exception e) {\n      e.printStackTrace();\n      throw new Error(e);\n    }\n\n    // public static boolean propertyIsTrue(Properties p, String key)\n    // public static String appendProperty(Properties p, String key, String value)\n    // public static String setDefault(Properties p, String key, String value)\n    // public static void streamCopy(java.io.InputStream from, java.io.OutputStream to)\n\n    // public static String replaceString(String target, String oldStr, String newStr)\n\n    assert UtilMDE.replaceString(\"hello dolly well hello dolly\", \" \", \"  \")\n        .equals(\"hello  dolly  well  hello  dolly\");\n    assert UtilMDE.replaceString(\"  hello  dolly well hello dolly  \", \" \", \"  \")\n        .equals(\"    hello    dolly  well  hello  dolly    \");\n    assert UtilMDE.replaceString(\"hello dolly well hello dolly\", \"ll\", \"y\")\n        .equals(\"heyo doyy wey heyo doyy\");\n    assert UtilMDE.replaceString(\"hello dolly well hello dolly\", \"q\", \"yyy\")\n        .equals(\"hello dolly well hello dolly\");\n\n    // public static String[] split(String s, char delim)\n    // public static String[] split(String s, String delim)\n\n    assert Arrays.equals(UtilMDE.split(\"foo,bar,baz\", ','), new String[] {\"foo\", \"bar\", \"baz\"});\n    assert Arrays.equals(UtilMDE.split(\"foo\", ','), new String[] {\"foo\"});\n    assert Arrays.equals(UtilMDE.split(\"\", ','), new String[] {\"\"});\n    assert Arrays.equals(UtilMDE.split(\",foo,\", ','), new String[] {\"\", \"foo\", \"\"});\n    assert Arrays.equals(UtilMDE.split(\"foo,bar,baz\", \",\"), new String[] {\"foo\", \"bar\", \"baz\"});\n    assert Arrays.equals(UtilMDE.split(\"foo\", \",\"), new String[] {\"foo\"});\n    assert Arrays.equals(UtilMDE.split(\"\", \",\"), new String[] {\"\"});\n    assert Arrays.equals(UtilMDE.split(\",foo,\", \",\"), new String[] {\"\", \"foo\", \"\"});\n    assert Arrays.equals(UtilMDE.split(\"foo, bar, baz\", \", \"), new String[] {\"foo\", \"bar\", \"baz\"});\n    assert Arrays.equals(UtilMDE.split(\"foo\", \", \"), new String[] {\"foo\"});\n    assert Arrays.equals(UtilMDE.split(\"\", \", \"), new String[] {\"\"});\n    assert Arrays.equals(UtilMDE.split(\", foo, \", \", \"), new String[] {\"\", \"foo\", \"\"});\n\n    // public static String join(Object[] a, String delim)\n    // public static String join(Vector v, String delim)\n\n    assert UtilMDE.join(new String[] {\"foo\", \"bar\", \"baz\"}, \", \").equals(\"foo, bar, baz\");\n    assert UtilMDE.join(new String[] {\"foo\"}, \", \").equals(\"foo\");\n    assert UtilMDE.join(new String[] {}, \", \").equals(\"\");\n    assert UtilMDE.join(\n            new Integer[] {\n              new Integer(0), new Integer(1), new Integer(2), new Integer(3), new Integer(4)\n            },\n            \"\")\n        .equals(\"01234\");\n    Vector<Object> potpourri = new Vector<Object>();\n    potpourri.add(\"day\");\n    potpourri.add(new Integer(2));\n    potpourri.add(\"day\");\n    assert UtilMDE.join(potpourri, \" \").equals(\"day 2 day\");\n\n    // public static String escapeNonJava(String orig)\n    // public static String escapeNonJava(Character ch)\n\n    assert UtilMDE.escapeNonJava(\"foobar\").equals(\"foobar\");\n    assert UtilMDE.escapeNonJava(\"\").equals(\"\");\n    assert UtilMDE.escapeNonJava(\"\\\\\").equals(\"\\\\\\\\\");\n    assert UtilMDE.escapeNonJava(\"\\\\\\n\\r\\\"\").equals(\"\\\\\\\\\\\\n\\\\r\\\\\\\"\");\n    assert UtilMDE.escapeNonJava(\"split\\nlines\").equals(\"split\\\\nlines\");\n    assert UtilMDE.escapeNonJava(\"\\\\relax\").equals(\"\\\\\\\\relax\");\n    assert UtilMDE.escapeNonJava(\"\\\"hello\\\"\").equals(\"\\\\\\\"hello\\\\\\\"\");\n    assert UtilMDE.escapeNonJava(\"\\\"hello\\\" \\\"world\\\"\").equals(\"\\\\\\\"hello\\\\\\\" \\\\\\\"world\\\\\\\"\");\n\n    // public static String escapeNonASCII(String orig)\n\n    assert UtilMDE.escapeNonASCII(\"foobar\").equals(\"foobar\");\n    assert UtilMDE.escapeNonASCII(\"\").equals(\"\");\n    assert UtilMDE.escapeNonASCII(\"\\\\\").equals(\"\\\\\\\\\");\n    assert UtilMDE.escapeNonASCII(\"\\\\\\n\\r\\\"\").equals(\"\\\\\\\\\\\\n\\\\r\\\\\\\"\");\n    assert UtilMDE.escapeNonASCII(\"split\\nlines\").equals(\"split\\\\nlines\");\n    assert UtilMDE.escapeNonASCII(\"\\\\relax\").equals(\"\\\\\\\\relax\");\n    assert UtilMDE.escapeNonASCII(\"\\\"hello\\\"\").equals(\"\\\\\\\"hello\\\\\\\"\");\n    assert UtilMDE.escapeNonASCII(\"\\\"hello\\\" \\\"world\\\"\").equals(\"\\\\\\\"hello\\\\\\\" \\\\\\\"world\\\\\\\"\");\n    assert UtilMDE.escapeNonASCII(\"\\0\\1\\2\\7\\12\\70\\100\\111\\222\")\n        .equals(\"\\\\000\\\\001\\\\002\\\\007\\\\n8@I\\\\222\");\n    assert UtilMDE.escapeNonASCII(\"\\u0100\\u1000\\ucafe\\uffff\")\n        .equals(\"\\\\u0100\\\\u1000\\\\ucafe\\\\uffff\");\n\n    // private static String escapeNonASCII(char c)\n\n    // public static String unescapeNonJava(String orig)\n\n    assert UtilMDE.unescapeNonJava(\"foobar\").equals(\"foobar\");\n    assert UtilMDE.unescapeNonJava(\"\").equals(\"\");\n    assert UtilMDE.unescapeNonJava(\"\\\\\\\\\").equals(\"\\\\\");\n    assert UtilMDE.unescapeNonJava(\"\\\\\\\"\").equals(\"\\\"\");\n    assert UtilMDE.unescapeNonJava(\"\\\\n\").equals(\"\\n\"); // not lineSep\n    assert UtilMDE.unescapeNonJava(\"\\\\r\").equals(\"\\r\");\n    assert UtilMDE.unescapeNonJava(\"split\\\\nlines\").equals(\"split\\nlines\");\n    assert UtilMDE.unescapeNonJava(\"\\\\\\\\\\\\n\").equals(\"\\\\\\n\"); // not lineSep\n    assert UtilMDE.unescapeNonJava(\"\\\\n\\\\r\").equals(\"\\n\\r\"); // not lineSep\n    assert UtilMDE.unescapeNonJava(\"\\\\\\\\\\\\n\\\\r\\\\\\\"\").equals(\"\\\\\\n\\r\\\"\");\n    assert UtilMDE.unescapeNonJava(\"\\\\\\\\relax\").equals(\"\\\\relax\");\n    assert UtilMDE.unescapeNonJava(\"\\\\\\\"hello\\\\\\\"\").equals(\"\\\"hello\\\"\");\n    assert UtilMDE.unescapeNonJava(\"\\\\\\\"hello\\\\\\\" \\\\\\\"world\\\\\\\"\").equals(\"\\\"hello\\\" \\\"world\\\"\");\n    assert UtilMDE.unescapeNonJava(\"\\\\\").equals(\"\\\\\");\n    assert UtilMDE.unescapeNonJava(\"foo\\\\\").equals(\"foo\\\\\");\n    assert UtilMDE.unescapeNonJava(\"\\\\*abc\").equals(\"*abc\");\n    // Should add more tests here.\n\n    // Unfortunately, there isn't yet a unescapeNonASCII function.\n    // If implemented, it should have the following behavior:\n    // assert UtilMDE.unescapeNonASCII(\"\\\\115\").equals(\"M\");\n    // assert UtilMDE.unescapeNonASCII(\"\\\\115\\\\111\\\\124\").equals(\"MIT\");\n\n    // public static String removeWhitespaceAround(String arg, String delimiter)\n    // public static String removeWhitespaceAfter(String arg, String delimiter)\n    // public static String removeWhitespaceBefore(String arg, String delimiter)\n\n    assert UtilMDE.removeWhitespaceBefore(\"a,b\", \",\").equals(\"a,b\");\n    assert UtilMDE.removeWhitespaceBefore(\"a, b\", \",\").equals(\"a, b\");\n    assert UtilMDE.removeWhitespaceBefore(\"a ,b\", \",\").equals(\"a,b\");\n    assert UtilMDE.removeWhitespaceBefore(\"a , b\", \",\").equals(\"a, b\");\n    assert UtilMDE.removeWhitespaceBefore(\"ab=>cd\", \"=>\").equals(\"ab=>cd\");\n    assert UtilMDE.removeWhitespaceBefore(\"ab=> cd\", \"=>\").equals(\"ab=> cd\");\n    assert UtilMDE.removeWhitespaceBefore(\"ab =>cd\", \"=>\").equals(\"ab=>cd\");\n    assert UtilMDE.removeWhitespaceBefore(\"ab => cd\", \"=>\").equals(\"ab=> cd\");\n    assert UtilMDE.removeWhitespaceBefore(\"123cd\", \"123\").equals(\"123cd\");\n    assert UtilMDE.removeWhitespaceBefore(\" 123 cd\", \"123\").equals(\"123 cd\");\n    assert UtilMDE.removeWhitespaceBefore(\" 123cd\", \"123\").equals(\"123cd\");\n    assert UtilMDE.removeWhitespaceBefore(\"123 cd\", \"123\").equals(\"123 cd\");\n    assert UtilMDE.removeWhitespaceBefore(\"cd123\", \"123\").equals(\"cd123\");\n    assert UtilMDE.removeWhitespaceBefore(\"cd 123 \", \"123\").equals(\"cd123 \");\n    assert UtilMDE.removeWhitespaceBefore(\"cd123 \", \"123\").equals(\"cd123 \");\n    assert UtilMDE.removeWhitespaceBefore(\"cd 123\", \"123\").equals(\"cd123\");\n\n    assert UtilMDE.removeWhitespaceAfter(\"a,b\", \",\").equals(\"a,b\");\n    assert UtilMDE.removeWhitespaceAfter(\"a, b\", \",\").equals(\"a,b\");\n    assert UtilMDE.removeWhitespaceAfter(\"a ,b\", \",\").equals(\"a ,b\");\n    assert UtilMDE.removeWhitespaceAfter(\"a , b\", \",\").equals(\"a ,b\");\n    assert UtilMDE.removeWhitespaceAfter(\"ab=>cd\", \"=>\").equals(\"ab=>cd\");\n    assert UtilMDE.removeWhitespaceAfter(\"ab=> cd\", \"=>\").equals(\"ab=>cd\");\n    assert UtilMDE.removeWhitespaceAfter(\"ab =>cd\", \"=>\").equals(\"ab =>cd\");\n    assert UtilMDE.removeWhitespaceAfter(\"ab => cd\", \"=>\").equals(\"ab =>cd\");\n    assert UtilMDE.removeWhitespaceAfter(\"123cd\", \"123\").equals(\"123cd\");\n    assert UtilMDE.removeWhitespaceAfter(\" 123 cd\", \"123\").equals(\" 123cd\");\n    assert UtilMDE.removeWhitespaceAfter(\" 123cd\", \"123\").equals(\" 123cd\");\n    assert UtilMDE.removeWhitespaceAfter(\"123 cd\", \"123\").equals(\"123cd\");\n    assert UtilMDE.removeWhitespaceAfter(\"cd123\", \"123\").equals(\"cd123\");\n    assert UtilMDE.removeWhitespaceAfter(\"cd 123 \", \"123\").equals(\"cd 123\");\n    assert UtilMDE.removeWhitespaceAfter(\"cd123 \", \"123\").equals(\"cd123\");\n    assert UtilMDE.removeWhitespaceAfter(\"cd 123\", \"123\").equals(\"cd 123\");\n\n    assert UtilMDE.removeWhitespaceAround(\"a,b\", \",\").equals(\"a,b\");\n    assert UtilMDE.removeWhitespaceAround(\"a, b\", \",\").equals(\"a,b\");\n    assert UtilMDE.removeWhitespaceAround(\"a ,b\", \",\").equals(\"a,b\");\n    assert UtilMDE.removeWhitespaceAround(\"a , b\", \",\").equals(\"a,b\");\n    assert UtilMDE.removeWhitespaceAround(\"ab=>cd\", \"=>\").equals(\"ab=>cd\");\n    assert UtilMDE.removeWhitespaceAround(\"ab=> cd\", \"=>\").equals(\"ab=>cd\");\n    assert UtilMDE.removeWhitespaceAround(\"ab =>cd\", \"=>\").equals(\"ab=>cd\");\n    assert UtilMDE.removeWhitespaceAround(\"ab => cd\", \"=>\").equals(\"ab=>cd\");\n    assert UtilMDE.removeWhitespaceAround(\"123cd\", \"123\").equals(\"123cd\");\n    assert UtilMDE.removeWhitespaceAround(\" 123 cd\", \"123\").equals(\"123cd\");\n    assert UtilMDE.removeWhitespaceAround(\" 123cd\", \"123\").equals(\"123cd\");\n    assert UtilMDE.removeWhitespaceAround(\"123 cd\", \"123\").equals(\"123cd\");\n    assert UtilMDE.removeWhitespaceAround(\"cd123\", \"123\").equals(\"cd123\");\n    assert UtilMDE.removeWhitespaceAround(\"cd 123 \", \"123\").equals(\"cd123\");\n    assert UtilMDE.removeWhitespaceAround(\"cd123 \", \"123\").equals(\"cd123\");\n    assert UtilMDE.removeWhitespaceAround(\"cd 123\", \"123\").equals(\"cd123\");\n\n    // public static String nplural(int n, String noun)\n\n    assert UtilMDE.nplural(0, \"fuss\").equals(\"0 fusses\");\n    assert UtilMDE.nplural(1, \"fuss\").equals(\"1 fuss\");\n    assert UtilMDE.nplural(2, \"fuss\").equals(\"2 fusses\");\n    assert UtilMDE.nplural(0, \"fox\").equals(\"0 foxes\");\n    assert UtilMDE.nplural(1, \"fox\").equals(\"1 fox\");\n    assert UtilMDE.nplural(2, \"fox\").equals(\"2 foxes\");\n    assert UtilMDE.nplural(0, \"fish\").equals(\"0 fishes\");\n    assert UtilMDE.nplural(1, \"fish\").equals(\"1 fish\");\n    assert UtilMDE.nplural(2, \"fish\").equals(\"2 fishes\");\n    assert UtilMDE.nplural(0, \"fletch\").equals(\"0 fletches\");\n    assert UtilMDE.nplural(1, \"fletch\").equals(\"1 fletch\");\n    assert UtilMDE.nplural(2, \"fletch\").equals(\"2 fletches\");\n    assert UtilMDE.nplural(0, \"fund\").equals(\"0 funds\");\n    assert UtilMDE.nplural(1, \"fund\").equals(\"1 fund\");\n    assert UtilMDE.nplural(2, \"fund\").equals(\"2 funds\");\n    assert UtilMDE.nplural(0, \"f-stop\").equals(\"0 f-stops\");\n    assert UtilMDE.nplural(1, \"f-stop\").equals(\"1 f-stop\");\n    assert UtilMDE.nplural(2, \"f-stop\").equals(\"2 f-stops\");\n\n    // public static String rpad(String s, int length)\n    // public static String rpad(int num, int length)\n    // public static String rpad(double num, int length)\n\n    assert UtilMDE.rpad(\"\", 5).equals(\"     \");\n    assert UtilMDE.rpad(\"abcd\", 5).equals(\"abcd \");\n    assert UtilMDE.rpad(\"abcde\", 5).equals(\"abcde\");\n    assert UtilMDE.rpad(\"abcdef\", 5).equals(\"abcde\");\n    assert UtilMDE.rpad(\"abcde ghij\", 5).equals(\"abcde\");\n    assert UtilMDE.rpad(10, 5).equals(\"10   \");\n    assert UtilMDE.rpad(3.14, 5).equals(\"3.14 \");\n\n    // public static class NullableStringComparator\n    //   public int compare(Object o1, Object o2)\n\n    // public static int count(String s, int ch)\n    // public static int count(String s, String sub)\n\n    assert UtilMDE.count(\"abcde\", 'a') == 1;\n    assert UtilMDE.count(\"abcde\", 'c') == 1;\n    assert UtilMDE.count(\"abcde\", 'e') == 1;\n    assert UtilMDE.count(\"abcde\", 'z') == 0;\n    assert UtilMDE.count(\"abacadaea\", 'a') == 5;\n    assert UtilMDE.count(\"aaa aea\", 'a') == 5;\n    assert UtilMDE.count(\"daeaaa\", 'a') == 4;\n\n    // This will be easy to write tests for, when I get around to it.\n    // public static Vector tokens(String str, String delim, boolean returnTokens)\n    // public static Vector tokens(String str, String delim)\n    // public static Vector tokens(String str)\n\n    // public static List sortList (List l, Comparator c)\n    // public static <T> List<T> removeDuplicates(List<T> l) {\n\n    List<Integer> l123 = new ArrayList<Integer>();\n    l123.add(1);\n    l123.add(2);\n    l123.add(3);\n    List<Integer> l123123 = new ArrayList<Integer>();\n    l123123.add(1);\n    l123123.add(2);\n    l123123.add(3);\n    l123123.add(1);\n    l123123.add(2);\n    l123123.add(3);\n    List<Integer> l12223 = new ArrayList<Integer>();\n    l12223.add(1);\n    l12223.add(2);\n    l12223.add(2);\n    l12223.add(2);\n    l12223.add(3);\n    List<Integer> l1123 = new ArrayList<Integer>();\n    l1123.add(1);\n    l1123.add(1);\n    l1123.add(2);\n    l1123.add(3);\n    List<Integer> l1233 = new ArrayList<Integer>();\n    l1233.add(1);\n    l1233.add(1);\n    l1233.add(2);\n    l1233.add(3);\n\n    assert UtilMDE.removeDuplicates(l123).equals(l123);\n    assert UtilMDE.removeDuplicates(l123123).equals(l123);\n    assert UtilMDE.removeDuplicates(l12223).equals(l123);\n    assert UtilMDE.removeDuplicates(l1123).equals(l123);\n    assert UtilMDE.removeDuplicates(l1233).equals(l123);\n\n    // public boolean deepEquals(Object o1, Object o2)\n\n    boolean[] zatft1 = new boolean[] {true, false, true};\n    boolean[] zatft2 = new boolean[] {true, false, true};\n    boolean[] zatff = new boolean[] {true, false, false};\n    assert !zatft1.equals(zatft2);\n    assert UtilMDE.deepEquals(zatft1, zatft2);\n    assert !zatft1.equals(zatff);\n    assert !UtilMDE.deepEquals(zatft1, zatff);\n\n    List<Object> l1 = new ArrayList<Object>();\n    List<Object> l2 = new ArrayList<Object>();\n    List<Object> l3 = new ArrayList<Object>();\n    l1.add(l1);\n    l2.add(l2);\n    l3.add(l3);\n    l1.add(zatft1);\n    l2.add(zatft2);\n    l3.add(zatff);\n    // Don't test .equals because it suffers infinite recursion.\n    // assert ! l1.equals(l2);\n    // assert ! l1.equals(l3);\n    // assert ! l2.equals(l3);\n    assert UtilMDE.deepEquals(l1, l2);\n    assert !UtilMDE.deepEquals(l1, l3);\n    assert !UtilMDE.deepEquals(l2, l3);\n\n    // This is tested by the tokens methods.\n    // public static Vector makeVector(Enumeration e)\n\n    Locale.setDefault(Locale.US);\n    assert UtilMDE.abbreviateNumber(5).equals(\"5.00\");\n    assert UtilMDE.abbreviateNumber(5000).equals(\"5.00K\");\n    assert UtilMDE.abbreviateNumber(5000000).equals(\"5.00M\");\n    assert UtilMDE.abbreviateNumber(1000000000).equals(\"1.00G\");\n    assert UtilMDE.abbreviateNumber(1).equals(\"1.00\");\n    assert UtilMDE.abbreviateNumber(12).equals(\"12.0\");\n    assert UtilMDE.abbreviateNumber(123).equals(\"123\");\n    assert UtilMDE.abbreviateNumber(1234).equals(\"1.23K\");\n    assert UtilMDE.abbreviateNumber(12345).equals(\"12.3K\");\n    assert UtilMDE.abbreviateNumber(123456).equals(\"123K\");\n    assert UtilMDE.abbreviateNumber(1234567).equals(\"1.23M\");\n    assert UtilMDE.abbreviateNumber(12345678).equals(\"12.3M\");\n    assert UtilMDE.abbreviateNumber(123456789).equals(\"123M\");\n    assert UtilMDE.abbreviateNumber(1234567890).equals(\"1.23G\");\n    assert UtilMDE.abbreviateNumber(9).equals(\"9.00\");\n    assert UtilMDE.abbreviateNumber(98).equals(\"98.0\");\n    assert UtilMDE.abbreviateNumber(987).equals(\"987\");\n    assert UtilMDE.abbreviateNumber(9876).equals(\"9.88K\");\n    assert UtilMDE.abbreviateNumber(98765).equals(\"98.8K\");\n    assert UtilMDE.abbreviateNumber(987654).equals(\"988K\");\n    assert UtilMDE.abbreviateNumber(9876543).equals(\"9.88M\");\n    assert UtilMDE.abbreviateNumber(98765432).equals(\"98.8M\");\n    assert UtilMDE.abbreviateNumber(987654321).equals(\"988M\");\n    assert UtilMDE.abbreviateNumber(9876543210L).equals(\"9.88G\");\n  }\n\n  @Test\n  public void testTestUtilMDE() {\n    int[] a = new int[] {3, 4, 5};\n    assert_arrays_equals(int_iterator_array(int_array_iterator(a)), a);\n  }\n\n  @Test\n  public void testWeakHasherMap() {}\n\n  /**\n   * These tests could be much more thorough.  Basically all that is tested\n   * is that identity is used rather than a normal hash.  The tests will\n   * fail however, if WeakHashMap is swapped for WeakIdentityHashMap.\n   */\n  @Test\n  public void testWeakIdentityHashMap() {\n\n    String s1 = \"one\";\n    String s2 = \"two\";\n    String s3 = \"three\";\n\n    WeakIdentityHashMap<String, Integer> m = new WeakIdentityHashMap<String, Integer>();\n    // WeakHashMap<String,Integer> m = new WeakHashMap<String,Integer>();\n\n    m.put(s1, 1);\n    m.put(s2, 2);\n    m.put(s3, 3);\n\n    String s1a = new String(s1);\n    String s2a = new String(s2);\n    String s3a = new String(s3);\n\n    m.put(s1a, 1);\n    m.put(s2a, 2);\n    m.put(s3a, 3);\n\n    assert m.get(s1) == 1;\n    assert m.get(s2) == 2;\n    assert m.get(s3) == 3;\n    assert m.get(s1a) == 1;\n    assert m.get(s2a) == 2;\n    assert m.get(s3a) == 3;\n\n    m.remove(s1);\n    m.remove(s2);\n    m.remove(s3);\n    assert m.get(s1) == null;\n    assert m.get(s2) == null;\n    assert m.get(s3) == null;\n    assert m.get(s1a) == 1;\n    assert m.get(s2a) == 2;\n    assert m.get(s3a) == 3;\n  }\n\n  @Test\n  public void testClassFileVersion() {\n    // public static double [] versionNumbers(InputStream is)\n    assert ClassFileVersion.versionNumbers(new ByteArrayInputStream(new byte[0])) == null;\n  }\n\n  /**\n   * Tests whether CountingPrintWriter\n   * counts the bytes printed, written for\n   * different types (boolean, int, float etc.).\n   */\n  @Test\n  public void testCountingPrintWriter() {\n    CountingPrintWriter c1 = new CountingPrintWriter(new CharArrayWriter());\n    c1.print(\"a\");\n    assert c1.getNumberOfPrintedBytes() == 1;\n    c1.print(1);\n    assert c1.getNumberOfPrintedBytes() == 2;\n    c1.print(true);\n    assert c1.getNumberOfPrintedBytes() == 6;\n    c1.print(1.00);\n    assert c1.getNumberOfPrintedBytes() == 9;\n    c1.write(\"a\");\n    c1.write(\"-\");\n    assert c1.getNumberOfPrintedBytes() == 9;\n    assert c1.getNumberOfWrittenBytes() == 22;\n    assert c1.getNumberOfPrintedChars() == 9;\n    c1.println(\"a b\");\n    String lineSep = System.getProperty(\"line.separator\");\n    int ls_len = lineSep.length();\n    assert c1.getNumberOfPrintedBytes() == (12 + ls_len);\n    assert c1.getNumberOfWrittenBytes() == (28);\n    assert c1.getNumberOfPrintedChars() == (12 + ls_len);\n    c1.print((String) null);\n    c1.print((Object) null);\n    c1.println((String) null);\n    // need to add assertions about what got printed.\n  }\n\n  /**\n   * Test the intering of subsequences as triples of the original\n   * sequence, the start and the end indices.\n   */\n  @Test\n  public void testSequenceAndIndices() {\n    int[] a1 = Intern.intern(new int[] {1, 2, 3, 4, 5, 6, 7});\n    int[] a2 = Intern.intern(new int[] {1, 2, 3, 4, 5, 6, 7});\n    int[] a3 = Intern.intern(new int[] {2, 3, 4, 5, 6, 7});\n    int i = 2;\n    int j = 4;\n    int k = 5;\n\n    int[] s1 = Intern.internSubsequence(a1, i, j);\n    int[] s2 = Intern.internSubsequence(a2, i, j);\n    int[] s3 = Intern.internSubsequence(a1, j, k);\n    int[] s4 = Intern.internSubsequence(a1, j, k);\n    int[] s5 = Intern.internSubsequence(a3, j - 1, k - 1);\n\n    assert a1 == a2;\n    assert s1 == s2;\n    assert s3 == s4;\n    assert s3 == s5;\n    assert ArraysMDE.isSubarray(s1, ArraysMDE.subarray(a1, i, j - i), 0);\n    assert ArraysMDE.isSubarray(ArraysMDE.subarray(a1, i, j - i), s1, 0);\n\n    long[] l1 = Intern.intern(new long[] {1, 2, 3, 4, 5, 6});\n    assert l1 == Intern.internSubsequence(l1, 0, l1.length);\n  }\n\n  // To do\n  // @Test\n  // public static void testFileIOException() {\n  // }\n\n  /**\n   * Test the comparison, indexof, and set equivalence calls in fuzzy\n   * float.\n   */\n  @Test\n  public void testFuzzyFloat() {\n\n    FuzzyFloat ff = new FuzzyFloat(0.0001);\n    double offset = 0.00007;\n    double offhigh = 1 + offset;\n    double offlow = 1 - offset;\n    double offhigh2 = 1 + 2 * offset;\n    double offlow2 = 1 - 2 * offset;\n\n    //test equality for a variety of postive and negative numbers\n    for (double d = -20000; d < 20000; d += 1000.36) {\n      assert ff.eq(d, d * offhigh);\n      assert ff.eq(d, d * offlow);\n      assert !ff.eq(d, d * offhigh2);\n      assert !ff.eq(d, d * offlow2);\n      assert !ff.ne(d, d * offhigh);\n      assert !ff.ne(d, d * offlow);\n      assert ff.ne(d, d * offhigh2);\n      assert ff.ne(d, d * offlow2);\n    }\n\n    //make sure nothing is equal to zero\n    assert ff.eq(0, Double.MIN_VALUE);\n    assert ff.eq(0, -Double.MIN_VALUE);\n    assert !ff.ne(0, Double.MIN_VALUE);\n    assert !ff.ne(0, -Double.MIN_VALUE);\n\n    //make sure that 0 equals 0\n    assert ff.eq(0, 0);\n    assert !ff.ne(0, 0);\n\n    //make sure that NaNs are not equal\n    assert !ff.eq(Double.NaN, Double.NaN);\n\n    //make sure that various unusual values are equal\n    assert ff.eq(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n    assert ff.eq(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);\n\n    //rudimentary checks on the comparison operators (since they all just\n    //use eq and ne anyway)\n    {\n      double d = 2563.789;\n      assert !ff.gt(d, d * offlow);\n      assert !ff.lt(d, d * offhigh);\n      assert ff.gt(d, d * offlow2);\n      assert ff.lt(d, d * offhigh2);\n      assert ff.gte(d, d * offhigh);\n      assert ff.lte(d, d * offlow);\n      assert !ff.gte(d, d * offhigh2);\n      assert !ff.lte(d, d * offlow2);\n    }\n\n    // public int indexOf (double[] a, double elt)\n    {\n      double[] a = new double[10];\n      for (int i = 0; i < a.length; i++) {\n        a[i] = i;\n      }\n      double[] a_copy = a.clone();\n      assert ff.indexOf(a, -1) == -1;\n      assert ff.indexOf(a, 0) == 0;\n      assert ff.indexOf(a, 7) == 7;\n      assert ff.indexOf(a, 9) == 9;\n      assert ff.indexOf(a, 10) == -1;\n      assert ff.indexOf(a, 20) == -1;\n      assert ff.indexOf(a, Double.MIN_VALUE) == 0;\n      assert ff.indexOf(a, 7 * offhigh) == 7;\n      assert ff.indexOf(a, 9 * offlow) == 9;\n      assert ff.indexOf(a, 7 * offhigh2) == -1;\n      assert ff.indexOf(a, 9 * offlow2) == -1;\n      assert_arrays_equals(a, a_copy);\n    }\n\n    // public int indexOf (double[] a, double[] sub)\n    {\n      double[] a = new double[10];\n      for (int i = 0; i < a.length; i++) {\n        a[i] = i;\n      }\n      double[] b = new double[] {};\n      double[] c = new double[] {a[0], a[1], a[2]};\n      double[] d = new double[] {a[1], a[2]};\n      double[] e = new double[] {a[2], a[3], a[4], a[5]};\n      double[] f = new double[] {a[7], a[8], a[9]};\n      double[] g = new double[] {a[7], 22, a[9]};\n      double[] h = new double[] {a[7], a[8], a[9], 10};\n\n      assert ff.indexOf(a, b) == 0;\n      assert ff.indexOf(a, c) == 0;\n      assert ff.indexOf(a, d) == 1;\n      assert ff.indexOf(a, e) == 2;\n      assert ff.indexOf(a, f) == 7;\n      assert ff.indexOf(a, g) == -1;\n      assert ff.indexOf(a, h) == -1;\n    }\n    {\n      double[] a = new double[10];\n      for (int i = 0; i < a.length; i++) {\n        a[i] = i;\n      }\n      double[] b = new double[] {};\n      double[] c = new double[] {a[0] * offlow, a[1] * offhigh, a[2] * offlow};\n      double[] d = new double[] {a[1] * offhigh, a[2] * offlow};\n      double[] e = new double[] {a[2], a[3], a[4] * offlow, a[5] * offhigh};\n      double[] f = new double[] {a[7], a[8] * offlow, a[9] * offhigh};\n      double[] g = new double[] {a[7], 22, a[9]};\n      double[] h = new double[] {a[7], a[8], a[9], 10};\n      double[] a_copy = a.clone();\n      double[] b_copy = b.clone();\n      double[] c_copy = c.clone();\n      double[] d_copy = d.clone();\n      double[] e_copy = e.clone();\n      double[] f_copy = f.clone();\n      double[] g_copy = g.clone();\n      double[] h_copy = h.clone();\n\n      assert ff.indexOf(a, b) == 0;\n      assert ff.indexOf(a, c) == 0;\n      assert ff.indexOf(a, d) == 1;\n      assert ff.indexOf(a, e) == 2;\n      assert ff.indexOf(a, f) == 7;\n      assert ff.indexOf(a, g) == -1;\n      assert ff.indexOf(a, h) == -1;\n\n      assert_arrays_equals(a, a_copy);\n      assert_arrays_equals(b, b_copy);\n      assert_arrays_equals(c, c_copy);\n      assert_arrays_equals(d, d_copy);\n      assert_arrays_equals(e, e_copy);\n      assert_arrays_equals(f, f_copy);\n      assert_arrays_equals(g, g_copy);\n      assert_arrays_equals(h, h_copy);\n    }\n\n    // public boolean isElemMatch (double[] a1, double[] a2)\n    {\n      double[] f1 = new double[10];\n      double[] f2 = new double[20];\n\n      for (int j = 0; j < 10; j++) {\n\n        initialize_f1_and_f2(j, f1, f2);\n\n        //make two elements off just a little\n        f2[7] = f2[7] * (1 + offset);\n        f2[8] = f2[8] * (1 - offset);\n\n        //test with each array the bigger one\n        if ((j % 2) == 0) {\n          assert ff.isElemMatch(f1, f2);\n        } else {\n          assert ff.isElemMatch(f2, f1);\n        }\n      }\n      for (int j = 0; j < 200; j++) {\n\n        initialize_f1_and_f2(j, f1, f2);\n\n        //make two elements off just a little\n        f2[7] = f2[7] * (1 + 2 * offset);\n        f2[8] = f2[8] * (1 - 2 * offset);\n\n        //test with each array the bigger one\n        double[] f1_copy = f1.clone();\n        double[] f2_copy = f2.clone();\n        if ((j % 2) == 0) {\n          assert !ff.isElemMatch(f1, f2);\n        } else {\n          assert !ff.isElemMatch(f2, f1);\n        }\n        assert_arrays_equals(f1, f1_copy);\n        assert_arrays_equals(f2, f2_copy);\n      }\n    }\n    {\n      double[] a = new double[] {2, 1, 0};\n      double[] b = new double[] {};\n      double[] c = new double[] {1, 1, 1, 1};\n      double[] d = new double[] {1};\n      assert !ff.isElemMatch(a, b);\n      assert !ff.isElemMatch(b, a);\n      assert ff.isElemMatch(c, d);\n      assert ff.isElemMatch(d, c);\n      assert ff.isElemMatch(b, b);\n    }\n\n    // public class DoubleArrayComparatorLexical implements Comparator\n    // public int compare(Object o1, Object o2)\n    {\n      Comparator<double[]> comparator = ff.new DoubleArrayComparatorLexical();\n      double[] a0 = new double[] {};\n      double[] a1 = new double[] {};\n      double[] a2 = new double[] {0, 1, 2, 3};\n      double[] a3 = new double[] {0, 1, 2, 3, 0};\n      double[] a4 = new double[] {0, 1, 2, 3, 4};\n      double[] a5 = new double[] {0, 1, 2, 3, 4};\n      double[] a6 = new double[] {0, 1, 5, 3, 4};\n      double[] a7 = new double[] {1, 2, 3, 4};\n      double[] a0_copy = a0.clone();\n      double[] a1_copy = a1.clone();\n      double[] a2_copy = a2.clone();\n      double[] a3_copy = a3.clone();\n      double[] a4_copy = a4.clone();\n      double[] a5_copy = a5.clone();\n      double[] a6_copy = a6.clone();\n      double[] a7_copy = a7.clone();\n\n      assert comparator.compare(a0, a1) == 0;\n      assert comparator.compare(a1, a0) == 0;\n      assert comparator.compare(a1, a2) < 0;\n      assert comparator.compare(a2, a1) > 0;\n      assert comparator.compare(a2, a3) < 0;\n      assert comparator.compare(a3, a2) > 0;\n      assert comparator.compare(a3, a4) < 0;\n      assert comparator.compare(a4, a3) > 0;\n      assert comparator.compare(a4, a5) == 0;\n      assert comparator.compare(a5, a4) == 0;\n      assert comparator.compare(a5, a6) < 0;\n      assert comparator.compare(a6, a5) > 0;\n      assert comparator.compare(a6, a7) < 0;\n      assert comparator.compare(a7, a6) > 0;\n      assert comparator.compare(a1, a4) < 0;\n      assert comparator.compare(a4, a1) > 0;\n      assert comparator.compare(a2, a4) < 0;\n      assert comparator.compare(a4, a2) > 0;\n      assert comparator.compare(a6, a4) > 0;\n      assert comparator.compare(a4, a6) < 0;\n      assert comparator.compare(a7, a4) > 0;\n      assert comparator.compare(a4, a7) < 0;\n\n      assert_arrays_equals(a0, a0_copy);\n      assert_arrays_equals(a1, a1_copy);\n      assert_arrays_equals(a2, a2_copy);\n      assert_arrays_equals(a3, a3_copy);\n      assert_arrays_equals(a4, a4_copy);\n      assert_arrays_equals(a5, a5_copy);\n      assert_arrays_equals(a6, a6_copy);\n      assert_arrays_equals(a7, a7_copy);\n    }\n\n    // public boolean FuzzyFloat.isSubset (double[] a1, double[] a2)\n    {\n      double[] f1 = new double[10];\n      double[] f2 = new double[20];\n\n      for (int j = 0; j < f2.length; j++) {\n        f2[j] = j;\n      }\n      for (int i = 0; i < f2.length - f1.length; i++) {\n\n        //fill up f1 with elements of f2\n        for (int j = 0; j < f1.length; j++) {\n          f1[j] = f2[i + j];\n        }\n\n        f1[5] = f2[i] * offhigh;\n\n        double[] f1_copy = f1.clone();\n        double[] f2_copy = f2.clone();\n\n        assert ff.isSubset(f1, f2);\n        assert_arrays_equals(f1, f1_copy);\n        assert_arrays_equals(f2, f2_copy);\n      }\n\n      double[] a1 = new double[] {1, 5, 10};\n      double[] a2 = new double[] {};\n      double[] a3 = new double[] {1};\n      double[] a4 = new double[] {10};\n      double[] a5 = new double[] {1, 10, 15, 20};\n      double[] a6 = new double[] {10, 10, 10, 10, 10, 1};\n\n      assert ff.isSubset(a2, a1);\n      assert !ff.isSubset(a1, a2);\n      assert !ff.isSubset(a1, a5);\n      assert ff.isSubset(a3, a1);\n      assert ff.isSubset(a4, a1);\n      assert ff.isSubset(a6, a1);\n      assert !ff.isSubset(a1, a6);\n    }\n  }\n\n  /** Initialize f2 to be the same as two copies of f1 */\n  @SuppressWarnings(\"index\") // length of f1 is exactly 10, length of f2 is exactly 20\n  void initialize_f1_and_f2(int j, double[] f1, double[] f2) {\n\n    //start two arrays out exactly equal\n    for (int i = 0; i < f1.length; i++) {\n      f1[i] = j + i * 10;\n      f2[i] = j + i * 10;\n    }\n\n    //fill out the second half of f2 with dup of f1\n    for (int i = 10; i < f2.length; i++) {\n      f2[i] = j + (i - 10) * 10;\n    }\n  }\n\n  /**\n   * Tests UtilMDE create_combinations routines.\n   */\n  @Test\n  public void test_create_combinations() {\n\n    // public static List create_combinations (int dims, int start, List objs)\n    Object a = new Object();\n    Object b = new Object();\n    Object c = new Object();\n    List<Object> a_list = Arrays.<Object>asList(new Object[] {a});\n    List<Object> b_list = Arrays.<Object>asList(new Object[] {b});\n    List<Object> c_list = Arrays.<Object>asList(new Object[] {c});\n    List<Object> aa = Arrays.<Object>asList(new Object[] {a, a});\n    List<Object> bb = Arrays.<Object>asList(new Object[] {b, b});\n    List<Object> cc = Arrays.<Object>asList(new Object[] {c, c});\n    List<Object> ab = Arrays.<Object>asList(new Object[] {a, b});\n    List<Object> ac = Arrays.<Object>asList(new Object[] {a, c});\n    List<Object> bc = Arrays.<Object>asList(new Object[] {b, c});\n\n    List<Object> abc = Arrays.asList(a, b, c);\n    List<List<Object>> combo1 = UtilMDE.create_combinations(1, 0, abc);\n    assert combo1.size() == 3;\n    assert combo1.contains(a_list);\n    assert combo1.contains(b_list);\n    assert combo1.contains(c_list);\n\n    List<List<Object>> combo2 = UtilMDE.create_combinations(2, 0, abc);\n    assert combo2.size() == 6;\n    assert combo2.contains(aa);\n    assert combo2.contains(ab);\n    assert combo2.contains(ac);\n    assert combo2.contains(bb);\n    assert combo2.contains(bc);\n    assert combo2.contains(cc);\n\n    // public static List create_combinations (int arity, int start, int cnt)\n    Integer i0 = new Integer(0);\n    Integer i1 = new Integer(1);\n    Integer i2 = new Integer(2);\n\n    List<ArrayList<Integer>> combo3 = UtilMDE.create_combinations(1, 0, 2);\n    assert combo3.size() == 3;\n    assert combo3.contains(Arrays.asList(new Integer[] {i0}));\n    assert combo3.contains(Arrays.asList(new Integer[] {i1}));\n    assert combo3.contains(Arrays.asList(new Integer[] {i2}));\n\n    List<ArrayList<Integer>> combo4 = UtilMDE.create_combinations(2, 0, 2);\n    assert combo4.size() == 6;\n    assert combo4.contains(Arrays.asList(new Integer[] {i0, i0}));\n    assert combo4.contains(Arrays.asList(new Integer[] {i0, i1}));\n    assert combo4.contains(Arrays.asList(new Integer[] {i0, i2}));\n    assert combo4.contains(Arrays.asList(new Integer[] {i1, i1}));\n    assert combo4.contains(Arrays.asList(new Integer[] {i1, i2}));\n    assert combo4.contains(Arrays.asList(new Integer[] {i2, i2}));\n  }\n\n  @Test\n  public void test_fullyQualifiedNameToSimpleName() {\n\n    assert UtilMDE.fullyQualifiedNameToSimpleName(\"java.lang.String\").equals(\"String\");\n    assert UtilMDE.fullyQualifiedNameToSimpleName(\"String\").equals(\"String\");\n  }\n\n  /**\n   * Test class for Options testing.\n   */\n  public static class TestOptions {\n\n    // TODO: test the @Unpublicized annotation and the usage() message.\n\n    @Option(\"list of patterns\")\n    public List<Pattern> lp = new ArrayList<Pattern>();\n\n    @Option(\"-a <filename> argument 1\")\n    public String arg1 = \"/tmp/foobar\";\n\n    @Option(\"argument 2\")\n    public /*@Nullable*/ String arg2;\n\n    @Option(\"-d double value\")\n    public double temperature;\n\n    @Option(\"-f the input file\")\n    public /*@Nullable*/ File input_file;\n\n    @Option(\"-b boolean\")\n    public boolean bool;\n\n    @Option(\"-i Integer\")\n    public /*@Nullable*/ Integer integer_reference;\n\n    @Option(\"list of doubles\")\n    public List<Double> ld = new ArrayList<Double>();\n\n    @Option(\"list with no default\")\n    public /*@Nullable*/ List<String> ls;\n  }\n\n  /**\n   * Test command line option parsing (Options).\n   * @throws ArgException if there is an illegal argument\n   */\n  @Test\n  public void testOptions() throws ArgException {\n\n    TestOptions t = new TestOptions();\n    Options options = new Options(\"test\", t);\n    options.parse(\n        new String[] {\n          \"--lp=foo\",\n          \"--lp\",\n          \"bar\",\n          \"-i\",\n          \"24\",\n          \"-d=37.8\",\n          \"-b\",\n          \"-b=false\",\n          \"--ld\",\n          \"34.6\",\n          \"--ld\",\n          \"17.8\",\n        });\n    assert t.lp.get(0).toString().equals(\"foo\");\n    assert t.lp.get(1).toString().equals(\"bar\");\n    assert t.integer_reference != null && t.integer_reference.intValue() == 24;\n    assert t.temperature == 37.8;\n    assert t.bool == false;\n    assert t.ld.get(0).doubleValue() == 34.6;\n    assert t.ld.get(1).doubleValue() == 17.8;\n\n    // Test non-options\n    t.bool = false;\n    String[] args = options.parse(new String[] {\"one\", \"two\", \"three\", \"-b\"});\n    assert args[0].equals(\"one\") : args[0];\n    assert args[1].equals(\"two\") : args[1];\n    assert args[2].equals(\"three\") : args[2];\n    assert t.bool;\n\n    // Test --\n    t.bool = false;\n    args = options.parse(new String[] {\"--\", \"one\", \"two\", \"-b\"});\n    assert args[0].equals(\"one\") : args[0];\n    assert args[1].equals(\"two\") : args[1];\n    assert args[2].equals(\"-b\") : args[2];\n    assert !t.bool;\n\n    // Test split_lists\n    t.ld.clear();\n    Options.split_lists = true;\n    args = options.parse(new String[] {\"--ld\", \"42.1 9.3 10.5\", \"--ld\", \"2.7\"});\n    assert args.length == 0;\n    assert t.ld.size() == 4;\n    assert t.ld.get(0).doubleValue() == 42.1;\n    assert t.ld.get(1).doubleValue() == 9.3;\n    assert t.ld.get(2).doubleValue() == 10.5;\n    assert t.ld.get(3).doubleValue() == 2.7;\n\n    // Test list with no default\n    args = options.parse(new String[] {\"--ls\", \"hello\", \"--ls\", \"world\"});\n    assert args.length == 0;\n    assert t.ls != null : \"@AssumeAssertion(nullness)\";\n    assert t.ls.size() == 2;\n    assert t.ls.get(0).equals(\"hello\");\n    assert t.ls.get(1).equals(\"world\");\n  }\n\n  /** Test class for option alias testing. */\n  public static class TestOptionsAliases {\n    @Option(\"-d Set the day\")\n    public String day = \"Friday\";\n\n    @Option(\n      value = \"-t Set the temperature\",\n      aliases = {\"-temp\"}\n    )\n    public double temperature = 42.0;\n\n    @Option(\n      value = \"Print the program version\",\n      aliases = {\"-v\", \"-version\", \"--version\"}\n    )\n    public boolean printVersion = false;\n  }\n\n  /**\n   * Test option aliases (Options).\n   * @throws ArgException if there is an illegal argument\n   */\n  @Test\n  public void testOptionsAliases() throws ArgException {\n    TestOptionsAliases t = new TestOptionsAliases();\n    Options options = new Options(\"test\", t);\n\n    options.parse(new String[] {\"-d\", \"Monday\", \"-temp\", \"-12.3\"});\n    assert t.day.equals(\"Monday\");\n    assert t.temperature == -12.3;\n    assert !t.printVersion;\n\n    options.parse(\"-d Monday -temp -12.3\");\n    assert t.day.equals(\"Monday\");\n    assert t.temperature == -12.3;\n    assert !t.printVersion;\n\n    options.parse(new String[] {\"-t\", \"21.7\", \"-version\"});\n    assert t.day.equals(\"Monday\");\n    assert t.temperature == 21.7;\n    assert t.printVersion;\n\n    options.parse(\"-t 21.7 -version\");\n    assert t.day.equals(\"Monday\");\n    assert t.temperature == 21.7;\n    assert t.printVersion;\n\n    t.printVersion = false;\n    options.parse(new String[] {\"--version\", \"-temp=-60.1\", \"--day\", \"Tuesday\"});\n    assert t.day.equals(\"Tuesday\");\n    assert t.temperature == -60.1;\n    assert t.printVersion;\n\n    t.printVersion = false;\n    options.parse(\"--version -temp=-60.1 --day Tuesday\");\n    assert t.day.equals(\"Tuesday\");\n    assert t.temperature == -60.1;\n    assert t.printVersion;\n  }\n\n  /** Test class for testing option groups. */\n  public static class TestOptionGroups1 {\n    @Option(\"-m Set the mass\")\n    public static int mass;\n\n    @OptionGroup(\"Coordinate options\")\n    @Option(\"-x Set the X coordinate\")\n    public static int x;\n\n    @Option(\"-y Set the Y coordinate\")\n    public static int y;\n\n    @Option(\"-z Set the Z coordinate\")\n    public static int z;\n  }\n\n  /** Test class for testing option groups. */\n  public static class TestOptionGroups2 {\n    @OptionGroup(\"General options\")\n    @Option(\n      value = \"-h Display help message\",\n      aliases = {\"-help\"}\n    )\n    public static boolean help = false;\n\n    @OptionGroup(value = \"Internal options\", unpublicized = true)\n    @Option(\"Set mu\")\n    public static double mu = 4902.7;\n\n    @Unpublicized\n    @Option(\"Set pi\")\n    public static double pi = 3.14;\n\n    @OptionGroup(\"Display options\")\n    @Option(\n      value = \"Use colors\",\n      aliases = {\"--colour\"}\n    )\n    public static boolean color = false;\n  }\n\n  /** Test class for testing option groups. */\n  public static class TestOptionGroups3 {\n    @OptionGroup(\"General options\")\n    @Option(\n      value = \"-h Display help message\",\n      aliases = {\"-help\"}\n    )\n    public static boolean help = false;\n\n    @OptionGroup(\"Internal options\")\n    @Unpublicized\n    @Option(\"Set mu\")\n    public static double mu = 4902.7;\n\n    @Unpublicized\n    @Option(\"Set pi\")\n    public static double pi = 3.14;\n\n    @OptionGroup(\"Display options\")\n    @Option(\n      value = \"Use colors\",\n      aliases = {\"--colour\"}\n    )\n    public static boolean color = false;\n  }\n\n  /**\n   * Test option groups (Options).\n   * @throws ArgException if there is an illegal argument\n   */\n  @Test\n  public void testOptionGroups() throws ArgException {\n    // TODO: The following two exception tests are not adequate.  There must be\n    // a better way to do these.\n    try {\n      Options options = new Options(\"test\", TestOptionGroups1.class);\n    } catch (Error e) {\n      assert e.getMessage() != null\n          && e.getMessage()\n                  .indexOf(\"missing @OptionGroup annotation on the first @Option-annotated field\")\n              > -1;\n    }\n\n    try {\n      Options options = new Options(\"test\", TestOptionGroups2.class, TestOptionGroups1.class);\n    } catch (Error e) {\n      assert e.getMessage() != null\n          && e.getMessage().indexOf(\"missing @OptionGroup annotation in field\") > -1;\n    }\n\n    Options options = new Options(\"test\", TestOptionGroups2.class);\n\n    assert options.usage().indexOf(\"General options\") > -1;\n    assert options.usage().indexOf(\"Display options\") > -1;\n    // \"Internal options\" is unpublicized so it should not occur in the default\n    // usage message.\n    assert options.usage().indexOf(\"Internal options\") == -1;\n\n    assert options.usage(\"Internal options\").indexOf(\"Set mu\") > -1;\n    // \"Set pi\" should not appear in the usage message for \"Internal options\"\n    // because it is marked with @Unpublicized.\n    assert options.usage(\"Internal options\").indexOf(\"Set pi\") == -1;\n\n    options.parse(new String[] {\"--colour\", \"--pi\", \"3.15\"});\n    assert TestOptionGroups2.color;\n    assert TestOptionGroups2.pi == 3.15;\n\n    options.parse(\"--colour --pi 3.15\");\n    assert TestOptionGroups2.color;\n    assert TestOptionGroups2.pi == 3.15;\n\n    // Test that an option group that contains only unpublicized options is not\n    // included in the usage message.\n    Options options2 = new Options(\"test\", TestOptionGroups3.class);\n    assert options.usage().indexOf(\"Internal options\") == -1;\n    // ...unless include_unpublicized is true.\n    assert options.usage(true).indexOf(\"Internal options\") > -1;\n  }\n\n  public static class TestOptionsEnums {\n    enum Compressor {\n      RLE,\n      SMART_RLE,\n      HUFFMAN\n    }\n\n    @Option(\"Set the first compression pass\")\n    public static /*@Nullable*/ Compressor firstPass;\n\n    @Option(\"Set the second compression pass\")\n    public static /*@Nullable*/ Compressor secondPass;\n  }\n\n  @Test\n  public void testOptionsEnums() throws ArgException {\n    Options options = new Options(\"test\", TestOptionsEnums.class);\n\n    options.parse(new String[] {\"--firstPass\", \"SMART_RLE\"});\n    assert TestOptionsEnums.firstPass == TestOptionsEnums.Compressor.SMART_RLE;\n    TestOptionsEnums.firstPass = TestOptionsEnums.Compressor.HUFFMAN;\n\n    options.parse(new String[] {\"--firstPass\", \"smart_rle\"});\n    assert TestOptionsEnums.firstPass == TestOptionsEnums.Compressor.SMART_RLE;\n    TestOptionsEnums.firstPass = TestOptionsEnums.Compressor.HUFFMAN;\n\n    options.parse(new String[] {\"--firstPass\", \"smart-rle\"});\n    assert TestOptionsEnums.firstPass == TestOptionsEnums.Compressor.SMART_RLE;\n\n    options.parse(new String[] {\"--firstPass\", \"rle\", \"--secondPass\", \"SMART-RLE\"});\n    assert TestOptionsEnums.firstPass == TestOptionsEnums.Compressor.RLE;\n    assert TestOptionsEnums.secondPass == TestOptionsEnums.Compressor.SMART_RLE;\n\n    options.parse(new String[] {\"--secondPass\", \"Huffman\"});\n    assert TestOptionsEnums.firstPass == TestOptionsEnums.Compressor.RLE;\n    assert TestOptionsEnums.secondPass == TestOptionsEnums.Compressor.HUFFMAN;\n  }\n\n  @Test\n  public void testOptionsEnumsFail() {\n    Options options = new Options(\"test\", TestOptionsEnums.class);\n    try {\n      // should fail: can not leave out _ or -\n      options.parse(new String[] {\"--firstPass\", \"smartrle\"});\n      org.junit.Assert.fail(\"Didn't throw ArgException as expected\");\n    } catch (ArgException e) {\n    }\n  }\n\n  @Test\n  public void testSplitLines() {\n\n    String str = \"one\\ntwo\\n\\rthree\\r\\nfour\\rfive\\n\\n\\nsix\\r\\n\\r\\n\\r\\n\";\n    String[] sa = UtilMDE.splitLines(str);\n    // for (String s : sa)\n    //   System.out.printf (\"'%s'%n\", s);\n    assert sa.length == 11;\n    assert sa[0].equals(\"one\");\n    assert sa[1].equals(\"two\");\n    assert sa[2].equals(\"three\");\n    assert sa[3].equals(\"four\");\n    assert sa[4].equals(\"five\");\n    assert sa[5].equals(\"\");\n    assert sa[6].equals(\"\");\n    assert sa[7].equals(\"six\");\n    assert sa[8].equals(\"\");\n    assert sa[9].equals(\"\");\n    assert sa[10].equals(\"\");\n  }\n\n  // Figure 1 from http://www.boost.org/libs/graph/doc/lengauer_tarjan_dominator.htm#fig:dominator-tree-example\n  private static /*@Nullable*/ Map<Integer, List</*@KeyFor(\"preds1\")*/ Integer>> preds1;\n  private static /*@Nullable*/ Map<Integer, List</*@KeyFor(\"succs1\")*/ Integer>> succs1;\n\n  @SuppressWarnings({\"keyfor\", \"nullness\"})\n  /*@EnsuresNonNull({\"preds1\", \"succs1\"})*/\n  private static void initializePreds1AndSucc1() {\n    if (preds1 != null) {\n      return;\n    }\n\n    preds1 = new LinkedHashMap<Integer, List<Integer>>();\n    succs1 = new LinkedHashMap<Integer, List<Integer>>();\n    for (int i = 0; i <= 7; i++) {\n      preds1.put(new Integer(i), new ArrayList<Integer>());\n      succs1.put(new Integer(i), new ArrayList<Integer>());\n    }\n    succs1.get(0).add(1);\n    preds1.get(1).add(0);\n    succs1.get(1).add(2);\n    preds1.get(2).add(1);\n    succs1.get(1).add(3);\n    preds1.get(3).add(1);\n    succs1.get(2).add(7);\n    preds1.get(7).add(2);\n    succs1.get(3).add(4);\n    preds1.get(4).add(3);\n    succs1.get(4).add(5);\n    preds1.get(5).add(4);\n    succs1.get(4).add(6);\n    preds1.get(6).add(4);\n    succs1.get(5).add(7);\n    preds1.get(7).add(5);\n    succs1.get(6).add(4);\n    preds1.get(4).add(6);\n  }\n\n  @SuppressWarnings(\"nullness\")\n  @Test\n  public void testGraphMDE() {\n\n    initializePreds1AndSucc1();\n\n    Map<Integer, List<Integer>> dom1post = GraphMDE.dominators(succs1);\n    assert dom1post.get(0).toString().equals(\"[7, 1, 0]\");\n    assert dom1post.get(1).toString().equals(\"[7, 1]\");\n    assert dom1post.get(2).toString().equals(\"[7, 2]\");\n    assert dom1post.get(3).toString().equals(\"[7, 5, 4, 3]\");\n    assert dom1post.get(4).toString().equals(\"[7, 5, 4]\");\n    assert dom1post.get(5).toString().equals(\"[7, 5]\");\n    assert dom1post.get(6).toString().equals(\"[7, 5, 4, 6]\");\n    assert dom1post.get(7).toString().equals(\"[7]\");\n\n    Map<Integer, List<Integer>> dom1pre = GraphMDE.dominators(preds1);\n    assert dom1pre.get(0).toString().equals(\"[0]\");\n    assert dom1pre.get(1).toString().equals(\"[0, 1]\");\n    assert dom1pre.get(2).toString().equals(\"[0, 1, 2]\");\n    assert dom1pre.get(3).toString().equals(\"[0, 1, 3]\");\n    assert dom1pre.get(4).toString().equals(\"[0, 1, 3, 4]\");\n    assert dom1pre.get(5).toString().equals(\"[0, 1, 3, 4, 5]\");\n    assert dom1pre.get(6).toString().equals(\"[0, 1, 3, 4, 6]\");\n    assert dom1pre.get(7).toString().equals(\"[0, 1, 7]\");\n\n    // I should add some more tests.\n\n  }\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10975,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "EntryReader",
  "javadocTag" : "@throws IOException if there is a problem reading the file",
  "methodJavadoc" : "    /**\n   * Returns the next entry (paragraph) in the file.  Entries are separated\n   * by blank lines unless the entry started with {@link #entry_start_re}\n   * (see {@link #set_entry_start_stop}).  If no more entries are\n   * available, returns null.\n   * @return the next entry (paragraph) in the file\n   * @throws IOException if there is a problem reading the file\n   */",
  "methodSourceCode" : "public /*@Nullable*/\nEntry get_entry() throws IOException{\n    // Skip any preceding blank lines\n    String line = readLine();\n    while ((line != null) && (line.trim().length() == 0)) {\n        line = readLine();\n    }\n    if (line == null) {\n        return (null);\n    }\n    StringBuilder body = new StringBuilder(10000);\n    Entry entry = null;\n    String filename = getFileName();\n    long line_number = getLineNumber();\n    // If first line matches entry_start_re, this is a long entry.\n    /*@Regex(1)*/\n    Matcher entry_match = null;\n    if (entry_start_re != null) {\n        entry_match = entry_start_re.matcher(line);\n    }\n    if ((entry_match != null) && entry_match.find()) {\n        assert entry_start_re != null : \"@AssumeAssertion(nullness): dependent: entry_match != null\";\n        assert entry_stop_re != null : \"@AssumeAssertion(nullness): dependent: entry_start_re != null\";\n        // Remove entry match from the line\n        if (entry_match.groupCount() > 0) {\n            @SuppressWarnings(// dependent: just checked that group 1 exists via groupCount(); https://code.google.com/p/checker-framework/issues/detail?id=291\n            \"nullness\")\n            String /*@NonNull*/\n            match_group_1 = entry_match.group(1);\n            line = entry_match.replaceFirst(match_group_1);\n        }\n        // Description is the first line\n        String description = line;\n        // Read until we find the termination of the entry\n        Matcher end_entry_match = entry_stop_re.matcher(line);\n        while ((line != null) && !entry_match.find() && !end_entry_match.find() && filename.equals(getFileName())) {\n            body.append(line);\n            body.append(lineSep);\n            line = readLine();\n            if (line == null) {\n                // end of file serves as entry terminator\n                break;\n            }\n            entry_match = entry_start_re.matcher(line);\n            end_entry_match = entry_stop_re.matcher(line);\n        }\n        // If this entry was terminated by the start of the next one,\n        // put that line back\n        if ((line != null) && (entry_match.find(0) || !filename.equals(getFileName()))) {\n            putback(line);\n        }\n        entry = new Entry(description, body.toString(), filename, line_number, false);\n    } else {\n        // blank-separated entry\n        String description = line;\n        // Read until we find another blank line\n        while ((line != null) && (line.trim().length() != 0) && filename.equals(getFileName())) {\n            body.append(line);\n            body.append(lineSep);\n            line = readLine();\n        }\n        // If this entry was terminated by the start of a new input file\n        // put that line back\n        if ((line != null) && !filename.equals(getFileName())) {\n            putback(line);\n        }\n        entry = new Entry(description, body.toString(), filename, line_number, true);\n    }\n    return (entry);\n}",
  "classJavadoc" : "/**\n * Class that reads \"entries\" from a file.  In the simplest case, entries\n * can be lines.  It supports:\n *   include files,\n *   comments, and\n *   multi-line entries (paragraphs).\n * The syntax of each of these is customizable.\n * <p>\n *\n * Example use:\n * <pre>\n *  // args are filename, comment regexp, include regexp\n *  try (EntryReader er = new EntryReader(filename, \"^#.*\", null)) {\n *    for (String line : er) {\n *      ...\n *    }\n *  } catch (IOException e) {\n *    System.err.println(\"Problem reading \" + filename + \": \" + e.getMessage());\n *    System.exit(2);\n *    throw new Error(\"This can't happen\"); // for definite assignment check\n *  }\n * </pre>\n *\n * @see #get_entry() and @see #set_entry_start_stop(String,String)\n */",
  "classSourceCode" : "package plume;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.io.Reader;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.CharBuffer;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.Stack;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/*>>>\nimport org.checkerframework.checker.lock.qual.*;\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.checker.regex.qual.*;\n*/\n\n// TODO:\n// EntryReader has a public concept of \"short entry\", but I don't think that\n// concept is logically part of EntryReader.  I think it would be better for\n// Lookup to make this decision itself, for instance by checking whether there\n// are any line separators in the entry that it gets back.\n//\n// Here are some useful features that EntryReader should have.\n//  * It should implement some unimplemented methods from LineNumberReader (see\n//    \"not yet implemented\" in this file).\n//  * It should have constructors that take an InputStream or Reader\n//    (in addition to the current BufferedReader, File, and String versions).\n//  * It should have a close method.\n//  * It should automatically close the underlying file/etc. when the\n//    iterator gets to the end (or the end is otherwise reached).\n\n/**\n * Class that reads \"entries\" from a file.  In the simplest case, entries\n * can be lines.  It supports:\n *   include files,\n *   comments, and\n *   multi-line entries (paragraphs).\n * The syntax of each of these is customizable.\n * <p>\n *\n * Example use:\n * <pre>\n *  // args are filename, comment regexp, include regexp\n *  try (EntryReader er = new EntryReader(filename, \"^#.*\", null)) {\n *    for (String line : er) {\n *      ...\n *    }\n *  } catch (IOException e) {\n *    System.err.println(\"Problem reading \" + filename + \": \" + e.getMessage());\n *    System.exit(2);\n *    throw new Error(\"This can't happen\"); // for definite assignment check\n *  }\n * </pre>\n *\n * @see #get_entry() and @see #set_entry_start_stop(String,String)\n */\npublic class EntryReader extends LineNumberReader implements Iterable<String>, Iterator<String> {\n\n  ///\n  /// User configuration variables\n  ///\n\n  /** Regular expression that specifies an include file. */\n  private final /*@Nullable*/ /*@Regex(1)*/ Pattern include_re;\n\n  /** Regular expression that matches a comment. */\n  private final /*@Nullable*/ Pattern comment_re;\n\n  /**\n   * Regular expression that starts a long entry.\n   * <p>\n   * If the first line of an entry matches this regexp, then the entry is\n   * terminated by:  entry_stop_re, another line that matches\n   * entry_start_re (even not following a newline), or the end of the\n   * current file.\n   * <p>\n   * Otherwise, the first line of an entry does NOT match this regexp (or\n   * the regexp is null), in which case the entry is terminated by a blank\n   * line or the end of the current file.\n   */\n  public /*@MonotonicNonNull*/ /*@Regex(1)*/ Pattern entry_start_re = null;\n\n  /**\n   * @see #entry_start_re\n   */\n  public /*@MonotonicNonNull*/ Pattern entry_stop_re = null;\n\n  ///\n  /// Internal implementation variables\n  ///\n\n  /** Stack of readers.  Used to support include files. */\n  private final Stack<FlnReader> readers = new Stack<FlnReader>();\n\n  /** Line that is pushed back to be reread. */\n  /*@Nullable*/ String pushback_line = null;\n\n  /** Platform-specific line separator. */\n  private static final String lineSep = System.getProperty(\"line.separator\");\n\n  ///\n  /// Helper classes\n  ///\n\n  /**\n   * Like LineNumberReader, but also has a filename field.\n   * \"FlnReader\" stands for \"Filename and Line Number Reader\".\n   */\n  private static class FlnReader extends LineNumberReader {\n    /** The file being read. */\n    public String filename;\n\n    /**\n     * Create a FlnReader.\n     * @param reader source from which to read entries\n     * @param filename file name corresponding to reader, for use in error messages.\n     *   Must be non-null; if there isn't a name, clients should provide a dummy value.\n     */\n    public FlnReader(Reader reader, String filename) {\n      super(reader);\n      this.filename = filename;\n    }\n\n    /**\n     * Create a FlnReader.\n     * @param filename file from which to read\n     */\n    public FlnReader(String filename) throws IOException {\n      super(UtilMDE.fileReader(filename));\n      this.filename = filename;\n    }\n  }\n\n  /** Descriptor for an entry (paragraph). */\n  public static class Entry {\n    /** First line of the entry. */\n    public String first_line;\n    /** Complete body of the entry including the first line. */\n    public String body;\n    /** True if this is a short entry (blank-line-separated). */\n    boolean short_entry;\n    /** Filename in which the entry was found. */\n    String filename;\n    /** Line number of first line of entry. */\n    long line_number;\n\n    /** Create an entry.\n     * @param first_line first line of the entry\n     * @param body complete body of the entry including the first line\n     * @param short_entry true if this is a short entry (blank-line-separated)\n     * @param filename filename in which the entry was found\n     * @param line_number line number of first line of entry\n     */\n    Entry(String first_line, String body, String filename, long line_number, boolean short_entry) {\n      this.first_line = first_line;\n      this.body = body;\n      this.filename = filename;\n      this.line_number = line_number;\n      this.short_entry = short_entry;\n    }\n\n    /**\n     * Return a substring of the entry body that matches the specified\n     * regular expression.  If no match is found, returns the first_line.\n     * @param re regex to match\n     * @return a substring that matches re\n     */\n    String get_description(/*@Nullable*/ Pattern re) {\n\n      if (re == null) {\n        return first_line;\n      }\n\n      Matcher descr = re.matcher(body);\n      if (descr.find()) {\n        return descr.group();\n      } else {\n        return first_line;\n      }\n    }\n  }\n\n  ///\n  /// Constructors\n  ///\n\n  /// Inputstream and charset constructors\n\n  /** Create a EntryReader that uses the given character set.\n   * @throws UnsupportedEncodingException if the charset encoding is not supported\n   * @param in source from which to read entries\n   * @param charsetName the character set to use\n   * @param filename non-null file name for stream being read\n   * @param comment_re_string regular expression that matches comments.\n   *                      Any text that matches comment_re is removed.\n   *                      A line that is entirely a comment is ignored.\n   * @param include_re_string regular expression that matches include directives.\n   *                      The expression should define one group that contains\n   *                      the include file name.\n   * @see #EntryReader(InputStream,String,String,String)\n   */\n  public EntryReader(\n      InputStream in,\n      String charsetName,\n      String filename,\n      /*@Nullable*/ /*@Regex*/ String comment_re_string,\n      /*@Nullable*/ /*@Regex(1)*/ String include_re_string)\n      throws UnsupportedEncodingException {\n    this(new InputStreamReader(in, charsetName), filename, comment_re_string, include_re_string);\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param in the InputStream\n   * @param charsetName the character set to use\n   * @param filename the file name\n   * @throws UnsupportedEncodingException if the charset encoding is not supported\n   * @see #EntryReader(InputStream,String,String,String)\n   */\n  public EntryReader(InputStream in, String charsetName, String filename)\n      throws UnsupportedEncodingException {\n    this(in, charsetName, filename, null, null);\n  }\n\n  /// Inputstream (no charset) constructors\n\n  /**\n   * Create a EntryReader.\n   *\n   *    @param in source from which to read entries\n   *    @param filename non-null file name for stream being read\n   *    @param comment_re_string regular expression that matches comments.\n   *                      Any text that matches comment_re is removed.\n   *                      A line that is entirely a comment is ignored.\n   *    @param include_re_string regular expression that matches include directives.\n   *                      The expression should define one group that contains\n   *                      the include file name.\n   */\n  public EntryReader(\n      InputStream in,\n      String filename,\n      /*@Nullable*/ /*@Regex*/ String comment_re_string,\n      /*@Nullable*/ /*@Regex(1)*/ String include_re_string) {\n    this(new InputStreamReader(in), filename, comment_re_string, include_re_string);\n  }\n\n  /**\n   * Create a EntryReader that uses the default character set and does not\n   * support comments or include directives.\n   * @param in the InputStream\n   * @param filename the file name\n   * @see #EntryReader(InputStream,String,String,String,String)\n   */\n  public EntryReader(InputStream in, String filename) {\n    this(in, filename, null, null);\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param in the InputStream\n   * @see #EntryReader(InputStream,String,String,String)\n   */\n  public EntryReader(InputStream in) {\n    this(in, \"(InputStream)\", null, null);\n  }\n\n  /** A dummy Reader to be used when null is not acceptable. */\n  private static class DummyReader extends Reader {\n    @Override\n    public void close(/*>>>@GuardSatisfied DummyReader this*/) {\n      // No error, because closing is OK if it appears in try-with-resources.\n      // Later maybe create two versions (with and without exception here).\n    }\n\n    @Override\n    public void mark(int readAheadLimit) {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public boolean markSupported() {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public int read() {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public int read(char[] cbuf) {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public int read(char[] cbuf, int off, int len) {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public int read(CharBuffer target) {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public boolean ready() {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public void reset() {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public long skip(long n) {\n      throw new Error(\"DummyReader\");\n    }\n  }\n\n  /**\n   * Create a EntryReader.\n   *\n   *    @param reader source from which to read entries\n   *    @param filename file name corresponding to reader, for use in error messages\n   *    @param comment_re_string regular expression that matches comments.\n   *                      Any text that matches comment_re is removed.\n   *                      A line that is entirely a comment is ignored\n   *    @param include_re_string regular expression that matches include directives.\n   *                      The expression should define one group that contains\n   *                      the include file name\n   */\n  public EntryReader(\n      Reader reader,\n      String filename,\n      /*@Nullable*/ /*@Regex*/ String comment_re_string,\n      /*@Nullable*/ /*@Regex(1)*/ String include_re_string) {\n    // we won't use superclass methods, but passing null as an argument\n    // leads to a NullPointerException.\n    super(new DummyReader());\n    readers.push(new FlnReader(reader, filename));\n    if (comment_re_string == null) {\n      comment_re = null;\n    } else {\n      comment_re = Pattern.compile(comment_re_string);\n    }\n    if (include_re_string == null) {\n      include_re = null;\n    } else {\n      include_re = Pattern.compile(include_re_string);\n    }\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param reader source from which to read entries\n   * @see #EntryReader(Reader,String,String,String)\n   */\n  public EntryReader(Reader reader) {\n    this(reader, reader.toString(), null, null);\n  }\n\n  /// File Constructors\n\n  /**\n   * Create an EntryReader.\n   *\n   *    @param file       initial file to read\n   *    @param comment_re regular expression that matches comments.\n   *                      Any text that matches comment_re is removed.\n   *                      A line that is entirely a comment is ignored.\n   *    @param include_re regular expression that matches include directives.\n   *                      The expression should define one group that contains\n   *                      the include file name.\n   * @throws IOException if there is a problem reading the file\n   */\n  public EntryReader(\n      File file,\n      /*@Nullable*/ /*@Regex*/ String comment_re,\n      /*@Nullable*/ /*@Regex(1)*/ String include_re)\n      throws IOException {\n    this(UtilMDE.fileReader(file), file.toString(), comment_re, include_re);\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param file the file to read\n   * @throws IOException if there is a problem reading the file\n   * @see #EntryReader(File,String,String)\n   */\n  public EntryReader(File file) throws IOException {\n    this(file, null, null);\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param file the file to read\n   * @param charsetName the character set to use\n   * @throws IOException if there is a problem reading the file\n   * @see #EntryReader(File,String,String)\n   */\n  public EntryReader(File file, String charsetName) throws IOException {\n    this(UtilMDE.fileInputStream(file), charsetName, file.toString(), null, null);\n  }\n\n  /// Filename constructors\n\n  /**\n   * Create a new EntryReader starting with the specified file.\n   *\n   *    @param filename   initial file to read\n   *    @param comment_re regular expression that matches comments.\n   *                      Any text that matches comment_re is removed.\n   *                      A line that is entirely a comment is ignored.\n   *    @param include_re regular expression that matches include directives.\n   *                      The expression should define one group that contains\n   *                      the include file name.\n   *\n   * @throws IOException if there is a problem reading the file\n   *\n   * @see #EntryReader(File,String,String)\n   */\n  public EntryReader(\n      String filename,\n      /*@Nullable*/ /*@Regex*/ String comment_re,\n      /*@Nullable*/ /*@Regex(1)*/ String include_re)\n      throws IOException {\n    this(new File(filename), comment_re, include_re);\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param filename source from which to read entries\n   * @throws IOException if there is a problem reading the file\n   * @see #EntryReader(String,String,String)\n   */\n  public EntryReader(String filename) throws IOException {\n    this(filename, null, null);\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param filename source from which to read entries\n   * @param charsetName the character set to use\n   * @throws IOException if there is a problem reading the file\n   * @see #EntryReader(String,String,String)\n   */\n  public EntryReader(String filename, String charsetName) throws IOException {\n    this(new FileInputStream(filename), charsetName, filename, null, null);\n  }\n\n  ///\n  /// Methods\n  ///\n\n  /**\n   * Read a line, ignoring comments and processing includes.  Note that\n   * a line that is completely a comment is completely ignored (and\n   * not returned as a blank line).  Returns null at end of file.\n   * @return the string that was read, or null at end of file\n   */\n  @Override\n  public /*@Nullable*/ String readLine() throws IOException {\n\n    // System.out.printf (\"Entering size = %d%n\", readers.size());\n\n    // If a line has been pushed back, return it instead\n    if (pushback_line != null) {\n      String line = pushback_line;\n      pushback_line = null;\n      return line;\n    }\n\n    String line = get_next_line();\n    if (comment_re != null) {\n      while (line != null) {\n        Matcher cmatch = comment_re.matcher(line);\n        if (cmatch.find()) {\n          line = cmatch.replaceFirst(\"\");\n          if (line.length() > 0) {\n            break;\n          }\n        } else {\n          break;\n        }\n        line = get_next_line();\n        // System.out.printf (\"get_next_line = %s%n\", line);\n      }\n    }\n\n    if (line == null) {\n      return null;\n    }\n\n    // Handle include files.  Non-absolute pathnames are relative\n    // to the including file (the current file)\n    if (include_re != null) {\n      Matcher m = include_re.matcher(line);\n      if (m.matches()) {\n        String filename_string = m.group(1);\n        if (filename_string == null) {\n          throw new Error(\n              String.format(\"include_re (%s) does not capture group 1 in %s\", include_re, line));\n        }\n        File filename = new File(UtilMDE.expandFilename(filename_string));\n        // System.out.printf (\"Trying to include filename %s%n\", filename);\n        if (!filename.isAbsolute()) {\n          FlnReader reader = readers.peek();\n          File current_filename = new File(reader.filename);\n          File current_parent = current_filename.getParentFile();\n          filename = new File(current_parent, filename.toString());\n          // System.out.printf (\"absolute filename = %s %s %s%n\",\n          //                     current_filename, current_parent, filename);\n        }\n        readers.push(new FlnReader(filename.getAbsolutePath()));\n        return readLine();\n      }\n    }\n\n    // System.out.printf (\"Returning [%d] '%s'%n\", readers.size(), line);\n    return (line);\n  }\n\n  /**\n   * Return a line-by-line iterator for this file.\n   * <p>\n   *\n   * <b>Warning:</b> This does not return a fresh iterator each time.  The\n   * iterator is a singleton, the same one is returned each time, and a new\n   * one can never be created after it is exhausted.\n   *\n   * @return a line-by-line iterator for this file\n   */\n  @Override\n  public Iterator<String> iterator() {\n    return this;\n  }\n\n  /**\n   * Returns whether or not there is another line to read.  Any IOExceptions\n   * are turned into errors (because the definition of hasNext() in Iterator\n   * doesn't throw any exceptions).\n   * @return whether there is another line to read\n   */\n  @Override\n  public boolean hasNext() {\n    if (pushback_line != null) {\n      return true;\n    }\n\n    String line = null;\n    try {\n      line = readLine();\n    } catch (IOException e) {\n      throw new Error(\"unexpected IOException: \", e);\n    }\n\n    if (line == null) {\n      return false;\n    }\n\n    putback(line);\n    return true;\n  }\n\n  /**\n   * Return the next line in the multi-file.\n   * @return the next line in the multi-file\n   * Throws NoSuchElementException at end of file\n   */\n  @Override\n  public String next() {\n    try {\n      String result = readLine();\n      if (result != null) {\n        return result;\n      } else {\n        throw new NoSuchElementException();\n      }\n    } catch (IOException e) {\n      throw new Error(\"unexpected IOException\", e);\n    }\n  }\n\n  /** remove() is not supported. */\n  @Override\n  public void remove() {\n    throw new UnsupportedOperationException(\"can't remove lines from file\");\n  }\n\n  /**\n   * Returns the next entry (paragraph) in the file.  Entries are separated\n   * by blank lines unless the entry started with {@link #entry_start_re}\n   * (see {@link #set_entry_start_stop}).  If no more entries are\n   * available, returns null.\n   * @return the next entry (paragraph) in the file\n   * @throws IOException if there is a problem reading the file\n   */\n  public /*@Nullable*/ Entry get_entry() throws IOException {\n\n    // Skip any preceding blank lines\n    String line = readLine();\n    while ((line != null) && (line.trim().length() == 0)) {\n      line = readLine();\n    }\n    if (line == null) {\n      return (null);\n    }\n\n    StringBuilder body = new StringBuilder(10000);\n    Entry entry = null;\n    String filename = getFileName();\n    long line_number = getLineNumber();\n\n    // If first line matches entry_start_re, this is a long entry.\n    /*@Regex(1)*/ Matcher entry_match = null;\n    if (entry_start_re != null) {\n      entry_match = entry_start_re.matcher(line);\n    }\n    if ((entry_match != null) && entry_match.find()) {\n      assert entry_start_re != null : \"@AssumeAssertion(nullness): dependent: entry_match != null\";\n      assert entry_stop_re != null\n          : \"@AssumeAssertion(nullness): dependent: entry_start_re != null\";\n\n      // Remove entry match from the line\n      if (entry_match.groupCount() > 0) {\n        @SuppressWarnings(\n            \"nullness\") // dependent: just checked that group 1 exists via groupCount(); https://code.google.com/p/checker-framework/issues/detail?id=291\n        /*@NonNull*/ String match_group_1 = entry_match.group(1);\n        line = entry_match.replaceFirst(match_group_1);\n      }\n\n      // Description is the first line\n      String description = line;\n\n      // Read until we find the termination of the entry\n      Matcher end_entry_match = entry_stop_re.matcher(line);\n      while ((line != null)\n          && !entry_match.find()\n          && !end_entry_match.find()\n          && filename.equals(getFileName())) {\n        body.append(line);\n        body.append(lineSep);\n        line = readLine();\n        if (line == null) {\n          break; // end of file serves as entry terminator\n        }\n        entry_match = entry_start_re.matcher(line);\n        end_entry_match = entry_stop_re.matcher(line);\n      }\n\n      // If this entry was terminated by the start of the next one,\n      // put that line back\n      if ((line != null) && (entry_match.find(0) || !filename.equals(getFileName()))) {\n        putback(line);\n      }\n\n      entry = new Entry(description, body.toString(), filename, line_number, false);\n\n    } else { // blank-separated entry\n\n      String description = line;\n\n      // Read until we find another blank line\n      while ((line != null) && (line.trim().length() != 0) && filename.equals(getFileName())) {\n        body.append(line);\n        body.append(lineSep);\n        line = readLine();\n      }\n\n      // If this entry was terminated by the start of a new input file\n      // put that line back\n      if ((line != null) && !filename.equals(getFileName())) {\n        putback(line);\n      }\n\n      entry = new Entry(description, body.toString(), filename, line_number, true);\n    }\n\n    return (entry);\n  }\n\n  /**\n   * Reads the next line from the current reader.  If EOF is encountered\n   * pop out to the next reader.  Returns null if there is no more input.\n   * @return next line from the reader, or null if there is no more input\n   */\n  private /*@Nullable*/ String get_next_line() throws IOException {\n\n    if (readers.size() == 0) {\n      return (null);\n    }\n\n    FlnReader ri1 = readers.peek();\n    String line = ri1.readLine();\n    while (line == null) {\n      readers.pop();\n      if (readers.empty()) {\n        return (null);\n      }\n      FlnReader ri2 = readers.peek();\n      line = ri2.readLine();\n    }\n    return (line);\n  }\n\n  /**\n   * Returns the current filename.\n   * @return the current filename\n   */\n  public String getFileName() {\n    FlnReader ri = readers.peek();\n    if (ri == null) {\n      throw new Error(\"Past end of input\");\n    }\n    return ri.filename;\n  }\n\n  /**\n   * Return the current line number in the current file.\n   * @return the current line number\n   */\n  @Override\n  public int getLineNumber() {\n    FlnReader ri = readers.peek();\n    if (ri == null) {\n      throw new Error(\"Past end of input\");\n    }\n    return ri.getLineNumber();\n  }\n\n  /** Set the current line number in the current file.\n   * @param lineNumber new line number for the current file\n   */\n  @Override\n  public void setLineNumber(int lineNumber) {\n    FlnReader ri = readers.peek();\n    if (ri == null) {\n      throw new Error(\"Past end of input\");\n    }\n    ri.setLineNumber(lineNumber);\n  }\n\n  /**\n   * Set the regular expressions for the start and stop of long\n   * entries (multiple lines that are read as a group by get_entry()).\n   * @param entry_start_re regular expression that starts a long entry\n   * @param entry_stop_re regular expression that ends a long entry\n   */\n  public void set_entry_start_stop(\n      /*@Regex(1)*/ String entry_start_re, /*@Regex*/ String entry_stop_re) {\n    this.entry_start_re = Pattern.compile(entry_start_re);\n    this.entry_stop_re = Pattern.compile(entry_stop_re);\n  }\n\n  /**\n   * Set the regular expressions for the start and stop of long\n   * entries (multiple lines that are read as a group by get_entry()).\n   * @param entry_start_re regular expression that starts a long entry\n   * @param entry_stop_re regular expression that ends a long entry\n   */\n  public void set_entry_start_stop(/*@Regex(1)*/ Pattern entry_start_re, Pattern entry_stop_re) {\n    this.entry_start_re = entry_start_re;\n    this.entry_stop_re = entry_stop_re;\n  }\n\n  /**\n   * Puts the specified line back in the input.  Only one line can be\n   * put back.\n   * @param line the line to be put back in the input\n   */\n  // TODO:  This would probably be better implemented with the \"mark\" mechanism\n  // of BufferedReader (which is also in LineNumberReader and FlnReader).\n  public void putback(String line) {\n    assert pushback_line == null\n        : \"push back '\" + line + \"' when '\" + pushback_line + \"' already back\";\n    pushback_line = line;\n  }\n\n  /** Mark the present position in the stream. */\n  @Override\n  public void mark(int readAheadLimit) {\n    throw new Error(\"not yet implemented\");\n  }\n  /** Read a single character. */\n  @Override\n  public int read() {\n    throw new Error(\"not yet implemented\");\n  }\n  /** Read characters into a portion of an array. */\n  @Override\n  public int read(char[] cbuf, int off, int len) {\n    throw new Error(\"not yet implemented\");\n  }\n  /** Reset the stream to the most recent mark. */\n  @Override\n  public void reset() {\n    throw new Error(\"not yet implemented\");\n  }\n  /** Skip characters. */\n  @Override\n  public long skip(long n) {\n    throw new Error(\"not yet implemented\");\n  }\n\n  /**\n   * Simple usage example.\n   * @param args command-line arguments: filename [comment_re [include_re]]\n   * @throws IOException if there is a problem reading a file\n   */\n  public static void main(String[] args) throws IOException {\n\n    if (args.length < 1 || args.length > 3) {\n      System.err.println(\n          \"EntryReader sample program requires 1-3 args: filename [comment_re [include_re]]\");\n      System.exit(1);\n    }\n    String filename = args[0];\n    String comment_re = null;\n    String include_re = null;\n    if (args.length >= 2) {\n      comment_re = args[1];\n      if (!RegexUtil.isRegex(comment_re)) {\n        System.err.println(\n            \"Error parsing comment regex \\\"\"\n                + comment_re\n                + \"\\\": \"\n                + RegexUtil.regexError(comment_re));\n        System.exit(1);\n      }\n    }\n    if (args.length >= 3) {\n      include_re = args[2];\n      if (!RegexUtil.isRegex(include_re, 1)) {\n        System.err.println(\n            \"Error parsing include regex \\\"\"\n                + include_re\n                + \"\\\": \"\n                + RegexUtil.regexError(include_re));\n        System.exit(1);\n      }\n    }\n    EntryReader reader = new EntryReader(filename, comment_re, include_re);\n\n    String line = reader.readLine();\n    while (line != null) {\n      System.out.printf(\"%s: %d: %s%n\", reader.getFileName(), reader.getLineNumber(), line);\n      line = reader.readLine();\n    }\n  }\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "transferTo", "java.io", "Reader", "public long transferTo(Writer arg0) throws IOException" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "iterator", "plume", "EntryReader", "public Iterator<String> iterator()" ], [ "getFileName", "plume", "EntryReader", "public String getFileName()" ], [ "readLine", "plume", "EntryReader", "public String readLine() throws IOException" ], [ "read", "plume", "EntryReader", "public int read()" ], [ "next", "plume", "EntryReader", "public String next()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "hasNext", "plume", "EntryReader", "public boolean hasNext()" ], [ "lines", "java.io", "BufferedReader", "public Stream<String> lines()" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "read", "plume", "EntryReader", "public int read(char[] cbuf, int off, int len)" ], [ "ready", "java.io", "BufferedReader", "public boolean ready() throws IOException" ], [ "read", "java.io", "Reader", "public int read(CharBuffer arg0) throws IOException" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "skip", "plume", "EntryReader", "public long skip(long n)" ], [ "read", "java.io", "Reader", "public int read(char[] arg0) throws IOException" ], [ "getLineNumber", "plume", "EntryReader", "public int getLineNumber()" ], [ "next", "java.util", "Iterator", "public abstract E next()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "readLine", "java.io", "BufferedReader", "String readLine(boolean arg0, boolean[] arg1) throws IOException" ], [ "markSupported", "java.io", "BufferedReader", "public boolean markSupported()" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "get_entry", "plume", "EntryReader", "public Entry get_entry() throws IOException" ], [ "get_description", "plume", "EntryReader.Entry", "String get_description(Pattern re)" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "entry_start_re", "plume", "EntryReader", "public Pattern entry_start_re = null;" ], [ "entry_stop_re", "plume", "EntryReader", "public Pattern entry_stop_re = null;" ], [ "pushback_line", "plume", "EntryReader", "String pushback_line = null;" ], [ "lock", "java.io", "Reader", "protected Object lock;" ], [ "first_line", "plume", "EntryReader.Entry", "public String first_line;" ], [ "body", "plume", "EntryReader.Entry", "public String body;" ], [ "short_entry", "plume", "EntryReader.Entry", "boolean short_entry;" ], [ "filename", "plume", "EntryReader.Entry", "String filename;" ], [ "line_number", "plume", "EntryReader.Entry", "long line_number;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10985,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "EntryReader",
  "javadocTag" : "@throws IOException if there is a problem reading a file",
  "methodJavadoc" : "    /**\n   * Simple usage example.\n   * @param args command-line arguments: filename [comment_re [include_re]]\n   * @throws IOException if there is a problem reading a file\n   */",
  "methodSourceCode" : "public static void main(String[] args) throws IOException{\n    if (args.length < 1 || args.length > 3) {\n        System.err.println(\"EntryReader sample program requires 1-3 args: filename [comment_re [include_re]]\");\n        System.exit(1);\n    }\n    String filename = args[0];\n    String comment_re = null;\n    String include_re = null;\n    if (args.length >= 2) {\n        comment_re = args[1];\n        if (!RegexUtil.isRegex(comment_re)) {\n            System.err.println(\"Error parsing comment regex \\\"\" + comment_re + \"\\\": \" + RegexUtil.regexError(comment_re));\n            System.exit(1);\n        }\n    }\n    if (args.length >= 3) {\n        include_re = args[2];\n        if (!RegexUtil.isRegex(include_re, 1)) {\n            System.err.println(\"Error parsing include regex \\\"\" + include_re + \"\\\": \" + RegexUtil.regexError(include_re));\n            System.exit(1);\n        }\n    }\n    EntryReader reader = new EntryReader(filename, comment_re, include_re);\n    String line = reader.readLine();\n    while (line != null) {\n        System.out.printf(\"%s: %d: %s%n\", reader.getFileName(), reader.getLineNumber(), line);\n        line = reader.readLine();\n    }\n}",
  "classJavadoc" : "/**\n * Class that reads \"entries\" from a file.  In the simplest case, entries\n * can be lines.  It supports:\n *   include files,\n *   comments, and\n *   multi-line entries (paragraphs).\n * The syntax of each of these is customizable.\n * <p>\n *\n * Example use:\n * <pre>\n *  // args are filename, comment regexp, include regexp\n *  try (EntryReader er = new EntryReader(filename, \"^#.*\", null)) {\n *    for (String line : er) {\n *      ...\n *    }\n *  } catch (IOException e) {\n *    System.err.println(\"Problem reading \" + filename + \": \" + e.getMessage());\n *    System.exit(2);\n *    throw new Error(\"This can't happen\"); // for definite assignment check\n *  }\n * </pre>\n *\n * @see #get_entry() and @see #set_entry_start_stop(String,String)\n */",
  "classSourceCode" : "package plume;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.io.Reader;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.CharBuffer;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.Stack;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/*>>>\nimport org.checkerframework.checker.lock.qual.*;\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.checker.regex.qual.*;\n*/\n\n// TODO:\n// EntryReader has a public concept of \"short entry\", but I don't think that\n// concept is logically part of EntryReader.  I think it would be better for\n// Lookup to make this decision itself, for instance by checking whether there\n// are any line separators in the entry that it gets back.\n//\n// Here are some useful features that EntryReader should have.\n//  * It should implement some unimplemented methods from LineNumberReader (see\n//    \"not yet implemented\" in this file).\n//  * It should have constructors that take an InputStream or Reader\n//    (in addition to the current BufferedReader, File, and String versions).\n//  * It should have a close method.\n//  * It should automatically close the underlying file/etc. when the\n//    iterator gets to the end (or the end is otherwise reached).\n\n/**\n * Class that reads \"entries\" from a file.  In the simplest case, entries\n * can be lines.  It supports:\n *   include files,\n *   comments, and\n *   multi-line entries (paragraphs).\n * The syntax of each of these is customizable.\n * <p>\n *\n * Example use:\n * <pre>\n *  // args are filename, comment regexp, include regexp\n *  try (EntryReader er = new EntryReader(filename, \"^#.*\", null)) {\n *    for (String line : er) {\n *      ...\n *    }\n *  } catch (IOException e) {\n *    System.err.println(\"Problem reading \" + filename + \": \" + e.getMessage());\n *    System.exit(2);\n *    throw new Error(\"This can't happen\"); // for definite assignment check\n *  }\n * </pre>\n *\n * @see #get_entry() and @see #set_entry_start_stop(String,String)\n */\npublic class EntryReader extends LineNumberReader implements Iterable<String>, Iterator<String> {\n\n  ///\n  /// User configuration variables\n  ///\n\n  /** Regular expression that specifies an include file. */\n  private final /*@Nullable*/ /*@Regex(1)*/ Pattern include_re;\n\n  /** Regular expression that matches a comment. */\n  private final /*@Nullable*/ Pattern comment_re;\n\n  /**\n   * Regular expression that starts a long entry.\n   * <p>\n   * If the first line of an entry matches this regexp, then the entry is\n   * terminated by:  entry_stop_re, another line that matches\n   * entry_start_re (even not following a newline), or the end of the\n   * current file.\n   * <p>\n   * Otherwise, the first line of an entry does NOT match this regexp (or\n   * the regexp is null), in which case the entry is terminated by a blank\n   * line or the end of the current file.\n   */\n  public /*@MonotonicNonNull*/ /*@Regex(1)*/ Pattern entry_start_re = null;\n\n  /**\n   * @see #entry_start_re\n   */\n  public /*@MonotonicNonNull*/ Pattern entry_stop_re = null;\n\n  ///\n  /// Internal implementation variables\n  ///\n\n  /** Stack of readers.  Used to support include files. */\n  private final Stack<FlnReader> readers = new Stack<FlnReader>();\n\n  /** Line that is pushed back to be reread. */\n  /*@Nullable*/ String pushback_line = null;\n\n  /** Platform-specific line separator. */\n  private static final String lineSep = System.getProperty(\"line.separator\");\n\n  ///\n  /// Helper classes\n  ///\n\n  /**\n   * Like LineNumberReader, but also has a filename field.\n   * \"FlnReader\" stands for \"Filename and Line Number Reader\".\n   */\n  private static class FlnReader extends LineNumberReader {\n    /** The file being read. */\n    public String filename;\n\n    /**\n     * Create a FlnReader.\n     * @param reader source from which to read entries\n     * @param filename file name corresponding to reader, for use in error messages.\n     *   Must be non-null; if there isn't a name, clients should provide a dummy value.\n     */\n    public FlnReader(Reader reader, String filename) {\n      super(reader);\n      this.filename = filename;\n    }\n\n    /**\n     * Create a FlnReader.\n     * @param filename file from which to read\n     */\n    public FlnReader(String filename) throws IOException {\n      super(UtilMDE.fileReader(filename));\n      this.filename = filename;\n    }\n  }\n\n  /** Descriptor for an entry (paragraph). */\n  public static class Entry {\n    /** First line of the entry. */\n    public String first_line;\n    /** Complete body of the entry including the first line. */\n    public String body;\n    /** True if this is a short entry (blank-line-separated). */\n    boolean short_entry;\n    /** Filename in which the entry was found. */\n    String filename;\n    /** Line number of first line of entry. */\n    long line_number;\n\n    /** Create an entry.\n     * @param first_line first line of the entry\n     * @param body complete body of the entry including the first line\n     * @param short_entry true if this is a short entry (blank-line-separated)\n     * @param filename filename in which the entry was found\n     * @param line_number line number of first line of entry\n     */\n    Entry(String first_line, String body, String filename, long line_number, boolean short_entry) {\n      this.first_line = first_line;\n      this.body = body;\n      this.filename = filename;\n      this.line_number = line_number;\n      this.short_entry = short_entry;\n    }\n\n    /**\n     * Return a substring of the entry body that matches the specified\n     * regular expression.  If no match is found, returns the first_line.\n     * @param re regex to match\n     * @return a substring that matches re\n     */\n    String get_description(/*@Nullable*/ Pattern re) {\n\n      if (re == null) {\n        return first_line;\n      }\n\n      Matcher descr = re.matcher(body);\n      if (descr.find()) {\n        return descr.group();\n      } else {\n        return first_line;\n      }\n    }\n  }\n\n  ///\n  /// Constructors\n  ///\n\n  /// Inputstream and charset constructors\n\n  /** Create a EntryReader that uses the given character set.\n   * @throws UnsupportedEncodingException if the charset encoding is not supported\n   * @param in source from which to read entries\n   * @param charsetName the character set to use\n   * @param filename non-null file name for stream being read\n   * @param comment_re_string regular expression that matches comments.\n   *                      Any text that matches comment_re is removed.\n   *                      A line that is entirely a comment is ignored.\n   * @param include_re_string regular expression that matches include directives.\n   *                      The expression should define one group that contains\n   *                      the include file name.\n   * @see #EntryReader(InputStream,String,String,String)\n   */\n  public EntryReader(\n      InputStream in,\n      String charsetName,\n      String filename,\n      /*@Nullable*/ /*@Regex*/ String comment_re_string,\n      /*@Nullable*/ /*@Regex(1)*/ String include_re_string)\n      throws UnsupportedEncodingException {\n    this(new InputStreamReader(in, charsetName), filename, comment_re_string, include_re_string);\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param in the InputStream\n   * @param charsetName the character set to use\n   * @param filename the file name\n   * @throws UnsupportedEncodingException if the charset encoding is not supported\n   * @see #EntryReader(InputStream,String,String,String)\n   */\n  public EntryReader(InputStream in, String charsetName, String filename)\n      throws UnsupportedEncodingException {\n    this(in, charsetName, filename, null, null);\n  }\n\n  /// Inputstream (no charset) constructors\n\n  /**\n   * Create a EntryReader.\n   *\n   *    @param in source from which to read entries\n   *    @param filename non-null file name for stream being read\n   *    @param comment_re_string regular expression that matches comments.\n   *                      Any text that matches comment_re is removed.\n   *                      A line that is entirely a comment is ignored.\n   *    @param include_re_string regular expression that matches include directives.\n   *                      The expression should define one group that contains\n   *                      the include file name.\n   */\n  public EntryReader(\n      InputStream in,\n      String filename,\n      /*@Nullable*/ /*@Regex*/ String comment_re_string,\n      /*@Nullable*/ /*@Regex(1)*/ String include_re_string) {\n    this(new InputStreamReader(in), filename, comment_re_string, include_re_string);\n  }\n\n  /**\n   * Create a EntryReader that uses the default character set and does not\n   * support comments or include directives.\n   * @param in the InputStream\n   * @param filename the file name\n   * @see #EntryReader(InputStream,String,String,String,String)\n   */\n  public EntryReader(InputStream in, String filename) {\n    this(in, filename, null, null);\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param in the InputStream\n   * @see #EntryReader(InputStream,String,String,String)\n   */\n  public EntryReader(InputStream in) {\n    this(in, \"(InputStream)\", null, null);\n  }\n\n  /** A dummy Reader to be used when null is not acceptable. */\n  private static class DummyReader extends Reader {\n    @Override\n    public void close(/*>>>@GuardSatisfied DummyReader this*/) {\n      // No error, because closing is OK if it appears in try-with-resources.\n      // Later maybe create two versions (with and without exception here).\n    }\n\n    @Override\n    public void mark(int readAheadLimit) {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public boolean markSupported() {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public int read() {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public int read(char[] cbuf) {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public int read(char[] cbuf, int off, int len) {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public int read(CharBuffer target) {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public boolean ready() {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public void reset() {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public long skip(long n) {\n      throw new Error(\"DummyReader\");\n    }\n  }\n\n  /**\n   * Create a EntryReader.\n   *\n   *    @param reader source from which to read entries\n   *    @param filename file name corresponding to reader, for use in error messages\n   *    @param comment_re_string regular expression that matches comments.\n   *                      Any text that matches comment_re is removed.\n   *                      A line that is entirely a comment is ignored\n   *    @param include_re_string regular expression that matches include directives.\n   *                      The expression should define one group that contains\n   *                      the include file name\n   */\n  public EntryReader(\n      Reader reader,\n      String filename,\n      /*@Nullable*/ /*@Regex*/ String comment_re_string,\n      /*@Nullable*/ /*@Regex(1)*/ String include_re_string) {\n    // we won't use superclass methods, but passing null as an argument\n    // leads to a NullPointerException.\n    super(new DummyReader());\n    readers.push(new FlnReader(reader, filename));\n    if (comment_re_string == null) {\n      comment_re = null;\n    } else {\n      comment_re = Pattern.compile(comment_re_string);\n    }\n    if (include_re_string == null) {\n      include_re = null;\n    } else {\n      include_re = Pattern.compile(include_re_string);\n    }\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param reader source from which to read entries\n   * @see #EntryReader(Reader,String,String,String)\n   */\n  public EntryReader(Reader reader) {\n    this(reader, reader.toString(), null, null);\n  }\n\n  /// File Constructors\n\n  /**\n   * Create an EntryReader.\n   *\n   *    @param file       initial file to read\n   *    @param comment_re regular expression that matches comments.\n   *                      Any text that matches comment_re is removed.\n   *                      A line that is entirely a comment is ignored.\n   *    @param include_re regular expression that matches include directives.\n   *                      The expression should define one group that contains\n   *                      the include file name.\n   * @throws IOException if there is a problem reading the file\n   */\n  public EntryReader(\n      File file,\n      /*@Nullable*/ /*@Regex*/ String comment_re,\n      /*@Nullable*/ /*@Regex(1)*/ String include_re)\n      throws IOException {\n    this(UtilMDE.fileReader(file), file.toString(), comment_re, include_re);\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param file the file to read\n   * @throws IOException if there is a problem reading the file\n   * @see #EntryReader(File,String,String)\n   */\n  public EntryReader(File file) throws IOException {\n    this(file, null, null);\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param file the file to read\n   * @param charsetName the character set to use\n   * @throws IOException if there is a problem reading the file\n   * @see #EntryReader(File,String,String)\n   */\n  public EntryReader(File file, String charsetName) throws IOException {\n    this(UtilMDE.fileInputStream(file), charsetName, file.toString(), null, null);\n  }\n\n  /// Filename constructors\n\n  /**\n   * Create a new EntryReader starting with the specified file.\n   *\n   *    @param filename   initial file to read\n   *    @param comment_re regular expression that matches comments.\n   *                      Any text that matches comment_re is removed.\n   *                      A line that is entirely a comment is ignored.\n   *    @param include_re regular expression that matches include directives.\n   *                      The expression should define one group that contains\n   *                      the include file name.\n   *\n   * @throws IOException if there is a problem reading the file\n   *\n   * @see #EntryReader(File,String,String)\n   */\n  public EntryReader(\n      String filename,\n      /*@Nullable*/ /*@Regex*/ String comment_re,\n      /*@Nullable*/ /*@Regex(1)*/ String include_re)\n      throws IOException {\n    this(new File(filename), comment_re, include_re);\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param filename source from which to read entries\n   * @throws IOException if there is a problem reading the file\n   * @see #EntryReader(String,String,String)\n   */\n  public EntryReader(String filename) throws IOException {\n    this(filename, null, null);\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param filename source from which to read entries\n   * @param charsetName the character set to use\n   * @throws IOException if there is a problem reading the file\n   * @see #EntryReader(String,String,String)\n   */\n  public EntryReader(String filename, String charsetName) throws IOException {\n    this(new FileInputStream(filename), charsetName, filename, null, null);\n  }\n\n  ///\n  /// Methods\n  ///\n\n  /**\n   * Read a line, ignoring comments and processing includes.  Note that\n   * a line that is completely a comment is completely ignored (and\n   * not returned as a blank line).  Returns null at end of file.\n   * @return the string that was read, or null at end of file\n   */\n  @Override\n  public /*@Nullable*/ String readLine() throws IOException {\n\n    // System.out.printf (\"Entering size = %d%n\", readers.size());\n\n    // If a line has been pushed back, return it instead\n    if (pushback_line != null) {\n      String line = pushback_line;\n      pushback_line = null;\n      return line;\n    }\n\n    String line = get_next_line();\n    if (comment_re != null) {\n      while (line != null) {\n        Matcher cmatch = comment_re.matcher(line);\n        if (cmatch.find()) {\n          line = cmatch.replaceFirst(\"\");\n          if (line.length() > 0) {\n            break;\n          }\n        } else {\n          break;\n        }\n        line = get_next_line();\n        // System.out.printf (\"get_next_line = %s%n\", line);\n      }\n    }\n\n    if (line == null) {\n      return null;\n    }\n\n    // Handle include files.  Non-absolute pathnames are relative\n    // to the including file (the current file)\n    if (include_re != null) {\n      Matcher m = include_re.matcher(line);\n      if (m.matches()) {\n        String filename_string = m.group(1);\n        if (filename_string == null) {\n          throw new Error(\n              String.format(\"include_re (%s) does not capture group 1 in %s\", include_re, line));\n        }\n        File filename = new File(UtilMDE.expandFilename(filename_string));\n        // System.out.printf (\"Trying to include filename %s%n\", filename);\n        if (!filename.isAbsolute()) {\n          FlnReader reader = readers.peek();\n          File current_filename = new File(reader.filename);\n          File current_parent = current_filename.getParentFile();\n          filename = new File(current_parent, filename.toString());\n          // System.out.printf (\"absolute filename = %s %s %s%n\",\n          //                     current_filename, current_parent, filename);\n        }\n        readers.push(new FlnReader(filename.getAbsolutePath()));\n        return readLine();\n      }\n    }\n\n    // System.out.printf (\"Returning [%d] '%s'%n\", readers.size(), line);\n    return (line);\n  }\n\n  /**\n   * Return a line-by-line iterator for this file.\n   * <p>\n   *\n   * <b>Warning:</b> This does not return a fresh iterator each time.  The\n   * iterator is a singleton, the same one is returned each time, and a new\n   * one can never be created after it is exhausted.\n   *\n   * @return a line-by-line iterator for this file\n   */\n  @Override\n  public Iterator<String> iterator() {\n    return this;\n  }\n\n  /**\n   * Returns whether or not there is another line to read.  Any IOExceptions\n   * are turned into errors (because the definition of hasNext() in Iterator\n   * doesn't throw any exceptions).\n   * @return whether there is another line to read\n   */\n  @Override\n  public boolean hasNext() {\n    if (pushback_line != null) {\n      return true;\n    }\n\n    String line = null;\n    try {\n      line = readLine();\n    } catch (IOException e) {\n      throw new Error(\"unexpected IOException: \", e);\n    }\n\n    if (line == null) {\n      return false;\n    }\n\n    putback(line);\n    return true;\n  }\n\n  /**\n   * Return the next line in the multi-file.\n   * @return the next line in the multi-file\n   * Throws NoSuchElementException at end of file\n   */\n  @Override\n  public String next() {\n    try {\n      String result = readLine();\n      if (result != null) {\n        return result;\n      } else {\n        throw new NoSuchElementException();\n      }\n    } catch (IOException e) {\n      throw new Error(\"unexpected IOException\", e);\n    }\n  }\n\n  /** remove() is not supported. */\n  @Override\n  public void remove() {\n    throw new UnsupportedOperationException(\"can't remove lines from file\");\n  }\n\n  /**\n   * Returns the next entry (paragraph) in the file.  Entries are separated\n   * by blank lines unless the entry started with {@link #entry_start_re}\n   * (see {@link #set_entry_start_stop}).  If no more entries are\n   * available, returns null.\n   * @return the next entry (paragraph) in the file\n   * @throws IOException if there is a problem reading the file\n   */\n  public /*@Nullable*/ Entry get_entry() throws IOException {\n\n    // Skip any preceding blank lines\n    String line = readLine();\n    while ((line != null) && (line.trim().length() == 0)) {\n      line = readLine();\n    }\n    if (line == null) {\n      return (null);\n    }\n\n    StringBuilder body = new StringBuilder(10000);\n    Entry entry = null;\n    String filename = getFileName();\n    long line_number = getLineNumber();\n\n    // If first line matches entry_start_re, this is a long entry.\n    /*@Regex(1)*/ Matcher entry_match = null;\n    if (entry_start_re != null) {\n      entry_match = entry_start_re.matcher(line);\n    }\n    if ((entry_match != null) && entry_match.find()) {\n      assert entry_start_re != null : \"@AssumeAssertion(nullness): dependent: entry_match != null\";\n      assert entry_stop_re != null\n          : \"@AssumeAssertion(nullness): dependent: entry_start_re != null\";\n\n      // Remove entry match from the line\n      if (entry_match.groupCount() > 0) {\n        @SuppressWarnings(\n            \"nullness\") // dependent: just checked that group 1 exists via groupCount(); https://code.google.com/p/checker-framework/issues/detail?id=291\n        /*@NonNull*/ String match_group_1 = entry_match.group(1);\n        line = entry_match.replaceFirst(match_group_1);\n      }\n\n      // Description is the first line\n      String description = line;\n\n      // Read until we find the termination of the entry\n      Matcher end_entry_match = entry_stop_re.matcher(line);\n      while ((line != null)\n          && !entry_match.find()\n          && !end_entry_match.find()\n          && filename.equals(getFileName())) {\n        body.append(line);\n        body.append(lineSep);\n        line = readLine();\n        if (line == null) {\n          break; // end of file serves as entry terminator\n        }\n        entry_match = entry_start_re.matcher(line);\n        end_entry_match = entry_stop_re.matcher(line);\n      }\n\n      // If this entry was terminated by the start of the next one,\n      // put that line back\n      if ((line != null) && (entry_match.find(0) || !filename.equals(getFileName()))) {\n        putback(line);\n      }\n\n      entry = new Entry(description, body.toString(), filename, line_number, false);\n\n    } else { // blank-separated entry\n\n      String description = line;\n\n      // Read until we find another blank line\n      while ((line != null) && (line.trim().length() != 0) && filename.equals(getFileName())) {\n        body.append(line);\n        body.append(lineSep);\n        line = readLine();\n      }\n\n      // If this entry was terminated by the start of a new input file\n      // put that line back\n      if ((line != null) && !filename.equals(getFileName())) {\n        putback(line);\n      }\n\n      entry = new Entry(description, body.toString(), filename, line_number, true);\n    }\n\n    return (entry);\n  }\n\n  /**\n   * Reads the next line from the current reader.  If EOF is encountered\n   * pop out to the next reader.  Returns null if there is no more input.\n   * @return next line from the reader, or null if there is no more input\n   */\n  private /*@Nullable*/ String get_next_line() throws IOException {\n\n    if (readers.size() == 0) {\n      return (null);\n    }\n\n    FlnReader ri1 = readers.peek();\n    String line = ri1.readLine();\n    while (line == null) {\n      readers.pop();\n      if (readers.empty()) {\n        return (null);\n      }\n      FlnReader ri2 = readers.peek();\n      line = ri2.readLine();\n    }\n    return (line);\n  }\n\n  /**\n   * Returns the current filename.\n   * @return the current filename\n   */\n  public String getFileName() {\n    FlnReader ri = readers.peek();\n    if (ri == null) {\n      throw new Error(\"Past end of input\");\n    }\n    return ri.filename;\n  }\n\n  /**\n   * Return the current line number in the current file.\n   * @return the current line number\n   */\n  @Override\n  public int getLineNumber() {\n    FlnReader ri = readers.peek();\n    if (ri == null) {\n      throw new Error(\"Past end of input\");\n    }\n    return ri.getLineNumber();\n  }\n\n  /** Set the current line number in the current file.\n   * @param lineNumber new line number for the current file\n   */\n  @Override\n  public void setLineNumber(int lineNumber) {\n    FlnReader ri = readers.peek();\n    if (ri == null) {\n      throw new Error(\"Past end of input\");\n    }\n    ri.setLineNumber(lineNumber);\n  }\n\n  /**\n   * Set the regular expressions for the start and stop of long\n   * entries (multiple lines that are read as a group by get_entry()).\n   * @param entry_start_re regular expression that starts a long entry\n   * @param entry_stop_re regular expression that ends a long entry\n   */\n  public void set_entry_start_stop(\n      /*@Regex(1)*/ String entry_start_re, /*@Regex*/ String entry_stop_re) {\n    this.entry_start_re = Pattern.compile(entry_start_re);\n    this.entry_stop_re = Pattern.compile(entry_stop_re);\n  }\n\n  /**\n   * Set the regular expressions for the start and stop of long\n   * entries (multiple lines that are read as a group by get_entry()).\n   * @param entry_start_re regular expression that starts a long entry\n   * @param entry_stop_re regular expression that ends a long entry\n   */\n  public void set_entry_start_stop(/*@Regex(1)*/ Pattern entry_start_re, Pattern entry_stop_re) {\n    this.entry_start_re = entry_start_re;\n    this.entry_stop_re = entry_stop_re;\n  }\n\n  /**\n   * Puts the specified line back in the input.  Only one line can be\n   * put back.\n   * @param line the line to be put back in the input\n   */\n  // TODO:  This would probably be better implemented with the \"mark\" mechanism\n  // of BufferedReader (which is also in LineNumberReader and FlnReader).\n  public void putback(String line) {\n    assert pushback_line == null\n        : \"push back '\" + line + \"' when '\" + pushback_line + \"' already back\";\n    pushback_line = line;\n  }\n\n  /** Mark the present position in the stream. */\n  @Override\n  public void mark(int readAheadLimit) {\n    throw new Error(\"not yet implemented\");\n  }\n  /** Read a single character. */\n  @Override\n  public int read() {\n    throw new Error(\"not yet implemented\");\n  }\n  /** Read characters into a portion of an array. */\n  @Override\n  public int read(char[] cbuf, int off, int len) {\n    throw new Error(\"not yet implemented\");\n  }\n  /** Reset the stream to the most recent mark. */\n  @Override\n  public void reset() {\n    throw new Error(\"not yet implemented\");\n  }\n  /** Skip characters. */\n  @Override\n  public long skip(long n) {\n    throw new Error(\"not yet implemented\");\n  }\n\n  /**\n   * Simple usage example.\n   * @param args command-line arguments: filename [comment_re [include_re]]\n   * @throws IOException if there is a problem reading a file\n   */\n  public static void main(String[] args) throws IOException {\n\n    if (args.length < 1 || args.length > 3) {\n      System.err.println(\n          \"EntryReader sample program requires 1-3 args: filename [comment_re [include_re]]\");\n      System.exit(1);\n    }\n    String filename = args[0];\n    String comment_re = null;\n    String include_re = null;\n    if (args.length >= 2) {\n      comment_re = args[1];\n      if (!RegexUtil.isRegex(comment_re)) {\n        System.err.println(\n            \"Error parsing comment regex \\\"\"\n                + comment_re\n                + \"\\\": \"\n                + RegexUtil.regexError(comment_re));\n        System.exit(1);\n      }\n    }\n    if (args.length >= 3) {\n      include_re = args[2];\n      if (!RegexUtil.isRegex(include_re, 1)) {\n        System.err.println(\n            \"Error parsing include regex \\\"\"\n                + include_re\n                + \"\\\": \"\n                + RegexUtil.regexError(include_re));\n        System.exit(1);\n      }\n    }\n    EntryReader reader = new EntryReader(filename, comment_re, include_re);\n\n    String line = reader.readLine();\n    while (line != null) {\n      System.out.printf(\"%s: %d: %s%n\", reader.getFileName(), reader.getLineNumber(), line);\n      line = reader.readLine();\n    }\n  }\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "args", "", "String[]" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "hasNext", "plume", "EntryReader", "public boolean hasNext()" ], [ "next", "plume", "EntryReader", "public String next()" ], [ "skip", "plume", "EntryReader", "public long skip(long n)" ], [ "read", "plume", "EntryReader", "public int read()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "markSupported", "java.io", "BufferedReader", "public boolean markSupported()" ], [ "ready", "java.io", "BufferedReader", "public boolean ready() throws IOException" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "readLine", "plume", "EntryReader", "public String readLine() throws IOException" ], [ "next", "java.util", "Iterator", "public abstract E next()" ], [ "iterator", "plume", "EntryReader", "public Iterator<String> iterator()" ], [ "getFileName", "plume", "EntryReader", "public String getFileName()" ], [ "read", "java.io", "Reader", "public int read(CharBuffer arg0) throws IOException" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "read", "plume", "EntryReader", "public int read(char[] cbuf, int off, int len)" ], [ "transferTo", "java.io", "Reader", "public long transferTo(Writer arg0) throws IOException" ], [ "read", "java.io", "Reader", "public int read(char[] arg0) throws IOException" ], [ "get_entry", "plume", "EntryReader", "public Entry get_entry() throws IOException" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "lines", "java.io", "BufferedReader", "public Stream<String> lines()" ], [ "readLine", "java.io", "BufferedReader", "String readLine(boolean arg0, boolean[] arg1) throws IOException" ], [ "getLineNumber", "plume", "EntryReader", "public int getLineNumber()" ], [ "equals", "", "java.lang.String[]", "public boolean equals(Object);" ], [ "toString", "", "java.lang.String[]", "public String toString()" ], [ "hashCode", "", "java.lang.String[]", "public native int hashCode()" ], [ "getClass", "", "java.lang.String[]", "public final native Class getClass();" ], [ "clone", "", "java.lang.String[]", "public T[] clone();" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "entry_start_re", "plume", "EntryReader", "public Pattern entry_start_re = null;" ], [ "entry_stop_re", "plume", "EntryReader", "public Pattern entry_stop_re = null;" ], [ "pushback_line", "plume", "EntryReader", "String pushback_line = null;" ], [ "lock", "java.io", "Reader", "protected Object lock;" ], [ "length", "java.lang", "String[]", "public final int length;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10994,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "EntryReader",
  "javadocTag" : "@throws UnsupportedEncodingException if the charset encoding is not supported",
  "methodJavadoc" : "    /** Create a EntryReader that does not support comments or include directives.\n   * @param in the InputStream\n   * @param charsetName the character set to use\n   * @param filename the file name\n   * @throws UnsupportedEncodingException if the charset encoding is not supported\n   * @see #EntryReader(InputStream,String,String,String)\n   */",
  "methodSourceCode" : "public EntryReader(InputStream in, String charsetName, String filename) throws UnsupportedEncodingException{\n    this(in, charsetName, filename, null, null);\n}",
  "classJavadoc" : "/**\n * Class that reads \"entries\" from a file.  In the simplest case, entries\n * can be lines.  It supports:\n *   include files,\n *   comments, and\n *   multi-line entries (paragraphs).\n * The syntax of each of these is customizable.\n * <p>\n *\n * Example use:\n * <pre>\n *  // args are filename, comment regexp, include regexp\n *  try (EntryReader er = new EntryReader(filename, \"^#.*\", null)) {\n *    for (String line : er) {\n *      ...\n *    }\n *  } catch (IOException e) {\n *    System.err.println(\"Problem reading \" + filename + \": \" + e.getMessage());\n *    System.exit(2);\n *    throw new Error(\"This can't happen\"); // for definite assignment check\n *  }\n * </pre>\n *\n * @see #get_entry() and @see #set_entry_start_stop(String,String)\n */",
  "classSourceCode" : "package plume;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.io.Reader;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.CharBuffer;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.Stack;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/*>>>\nimport org.checkerframework.checker.lock.qual.*;\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.checker.regex.qual.*;\n*/\n\n// TODO:\n// EntryReader has a public concept of \"short entry\", but I don't think that\n// concept is logically part of EntryReader.  I think it would be better for\n// Lookup to make this decision itself, for instance by checking whether there\n// are any line separators in the entry that it gets back.\n//\n// Here are some useful features that EntryReader should have.\n//  * It should implement some unimplemented methods from LineNumberReader (see\n//    \"not yet implemented\" in this file).\n//  * It should have constructors that take an InputStream or Reader\n//    (in addition to the current BufferedReader, File, and String versions).\n//  * It should have a close method.\n//  * It should automatically close the underlying file/etc. when the\n//    iterator gets to the end (or the end is otherwise reached).\n\n/**\n * Class that reads \"entries\" from a file.  In the simplest case, entries\n * can be lines.  It supports:\n *   include files,\n *   comments, and\n *   multi-line entries (paragraphs).\n * The syntax of each of these is customizable.\n * <p>\n *\n * Example use:\n * <pre>\n *  // args are filename, comment regexp, include regexp\n *  try (EntryReader er = new EntryReader(filename, \"^#.*\", null)) {\n *    for (String line : er) {\n *      ...\n *    }\n *  } catch (IOException e) {\n *    System.err.println(\"Problem reading \" + filename + \": \" + e.getMessage());\n *    System.exit(2);\n *    throw new Error(\"This can't happen\"); // for definite assignment check\n *  }\n * </pre>\n *\n * @see #get_entry() and @see #set_entry_start_stop(String,String)\n */\npublic class EntryReader extends LineNumberReader implements Iterable<String>, Iterator<String> {\n\n  ///\n  /// User configuration variables\n  ///\n\n  /** Regular expression that specifies an include file. */\n  private final /*@Nullable*/ /*@Regex(1)*/ Pattern include_re;\n\n  /** Regular expression that matches a comment. */\n  private final /*@Nullable*/ Pattern comment_re;\n\n  /**\n   * Regular expression that starts a long entry.\n   * <p>\n   * If the first line of an entry matches this regexp, then the entry is\n   * terminated by:  entry_stop_re, another line that matches\n   * entry_start_re (even not following a newline), or the end of the\n   * current file.\n   * <p>\n   * Otherwise, the first line of an entry does NOT match this regexp (or\n   * the regexp is null), in which case the entry is terminated by a blank\n   * line or the end of the current file.\n   */\n  public /*@MonotonicNonNull*/ /*@Regex(1)*/ Pattern entry_start_re = null;\n\n  /**\n   * @see #entry_start_re\n   */\n  public /*@MonotonicNonNull*/ Pattern entry_stop_re = null;\n\n  ///\n  /// Internal implementation variables\n  ///\n\n  /** Stack of readers.  Used to support include files. */\n  private final Stack<FlnReader> readers = new Stack<FlnReader>();\n\n  /** Line that is pushed back to be reread. */\n  /*@Nullable*/ String pushback_line = null;\n\n  /** Platform-specific line separator. */\n  private static final String lineSep = System.getProperty(\"line.separator\");\n\n  ///\n  /// Helper classes\n  ///\n\n  /**\n   * Like LineNumberReader, but also has a filename field.\n   * \"FlnReader\" stands for \"Filename and Line Number Reader\".\n   */\n  private static class FlnReader extends LineNumberReader {\n    /** The file being read. */\n    public String filename;\n\n    /**\n     * Create a FlnReader.\n     * @param reader source from which to read entries\n     * @param filename file name corresponding to reader, for use in error messages.\n     *   Must be non-null; if there isn't a name, clients should provide a dummy value.\n     */\n    public FlnReader(Reader reader, String filename) {\n      super(reader);\n      this.filename = filename;\n    }\n\n    /**\n     * Create a FlnReader.\n     * @param filename file from which to read\n     */\n    public FlnReader(String filename) throws IOException {\n      super(UtilMDE.fileReader(filename));\n      this.filename = filename;\n    }\n  }\n\n  /** Descriptor for an entry (paragraph). */\n  public static class Entry {\n    /** First line of the entry. */\n    public String first_line;\n    /** Complete body of the entry including the first line. */\n    public String body;\n    /** True if this is a short entry (blank-line-separated). */\n    boolean short_entry;\n    /** Filename in which the entry was found. */\n    String filename;\n    /** Line number of first line of entry. */\n    long line_number;\n\n    /** Create an entry.\n     * @param first_line first line of the entry\n     * @param body complete body of the entry including the first line\n     * @param short_entry true if this is a short entry (blank-line-separated)\n     * @param filename filename in which the entry was found\n     * @param line_number line number of first line of entry\n     */\n    Entry(String first_line, String body, String filename, long line_number, boolean short_entry) {\n      this.first_line = first_line;\n      this.body = body;\n      this.filename = filename;\n      this.line_number = line_number;\n      this.short_entry = short_entry;\n    }\n\n    /**\n     * Return a substring of the entry body that matches the specified\n     * regular expression.  If no match is found, returns the first_line.\n     * @param re regex to match\n     * @return a substring that matches re\n     */\n    String get_description(/*@Nullable*/ Pattern re) {\n\n      if (re == null) {\n        return first_line;\n      }\n\n      Matcher descr = re.matcher(body);\n      if (descr.find()) {\n        return descr.group();\n      } else {\n        return first_line;\n      }\n    }\n  }\n\n  ///\n  /// Constructors\n  ///\n\n  /// Inputstream and charset constructors\n\n  /** Create a EntryReader that uses the given character set.\n   * @throws UnsupportedEncodingException if the charset encoding is not supported\n   * @param in source from which to read entries\n   * @param charsetName the character set to use\n   * @param filename non-null file name for stream being read\n   * @param comment_re_string regular expression that matches comments.\n   *                      Any text that matches comment_re is removed.\n   *                      A line that is entirely a comment is ignored.\n   * @param include_re_string regular expression that matches include directives.\n   *                      The expression should define one group that contains\n   *                      the include file name.\n   * @see #EntryReader(InputStream,String,String,String)\n   */\n  public EntryReader(\n      InputStream in,\n      String charsetName,\n      String filename,\n      /*@Nullable*/ /*@Regex*/ String comment_re_string,\n      /*@Nullable*/ /*@Regex(1)*/ String include_re_string)\n      throws UnsupportedEncodingException {\n    this(new InputStreamReader(in, charsetName), filename, comment_re_string, include_re_string);\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param in the InputStream\n   * @param charsetName the character set to use\n   * @param filename the file name\n   * @throws UnsupportedEncodingException if the charset encoding is not supported\n   * @see #EntryReader(InputStream,String,String,String)\n   */\n  public EntryReader(InputStream in, String charsetName, String filename)\n      throws UnsupportedEncodingException {\n    this(in, charsetName, filename, null, null);\n  }\n\n  /// Inputstream (no charset) constructors\n\n  /**\n   * Create a EntryReader.\n   *\n   *    @param in source from which to read entries\n   *    @param filename non-null file name for stream being read\n   *    @param comment_re_string regular expression that matches comments.\n   *                      Any text that matches comment_re is removed.\n   *                      A line that is entirely a comment is ignored.\n   *    @param include_re_string regular expression that matches include directives.\n   *                      The expression should define one group that contains\n   *                      the include file name.\n   */\n  public EntryReader(\n      InputStream in,\n      String filename,\n      /*@Nullable*/ /*@Regex*/ String comment_re_string,\n      /*@Nullable*/ /*@Regex(1)*/ String include_re_string) {\n    this(new InputStreamReader(in), filename, comment_re_string, include_re_string);\n  }\n\n  /**\n   * Create a EntryReader that uses the default character set and does not\n   * support comments or include directives.\n   * @param in the InputStream\n   * @param filename the file name\n   * @see #EntryReader(InputStream,String,String,String,String)\n   */\n  public EntryReader(InputStream in, String filename) {\n    this(in, filename, null, null);\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param in the InputStream\n   * @see #EntryReader(InputStream,String,String,String)\n   */\n  public EntryReader(InputStream in) {\n    this(in, \"(InputStream)\", null, null);\n  }\n\n  /** A dummy Reader to be used when null is not acceptable. */\n  private static class DummyReader extends Reader {\n    @Override\n    public void close(/*>>>@GuardSatisfied DummyReader this*/) {\n      // No error, because closing is OK if it appears in try-with-resources.\n      // Later maybe create two versions (with and without exception here).\n    }\n\n    @Override\n    public void mark(int readAheadLimit) {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public boolean markSupported() {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public int read() {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public int read(char[] cbuf) {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public int read(char[] cbuf, int off, int len) {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public int read(CharBuffer target) {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public boolean ready() {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public void reset() {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public long skip(long n) {\n      throw new Error(\"DummyReader\");\n    }\n  }\n\n  /**\n   * Create a EntryReader.\n   *\n   *    @param reader source from which to read entries\n   *    @param filename file name corresponding to reader, for use in error messages\n   *    @param comment_re_string regular expression that matches comments.\n   *                      Any text that matches comment_re is removed.\n   *                      A line that is entirely a comment is ignored\n   *    @param include_re_string regular expression that matches include directives.\n   *                      The expression should define one group that contains\n   *                      the include file name\n   */\n  public EntryReader(\n      Reader reader,\n      String filename,\n      /*@Nullable*/ /*@Regex*/ String comment_re_string,\n      /*@Nullable*/ /*@Regex(1)*/ String include_re_string) {\n    // we won't use superclass methods, but passing null as an argument\n    // leads to a NullPointerException.\n    super(new DummyReader());\n    readers.push(new FlnReader(reader, filename));\n    if (comment_re_string == null) {\n      comment_re = null;\n    } else {\n      comment_re = Pattern.compile(comment_re_string);\n    }\n    if (include_re_string == null) {\n      include_re = null;\n    } else {\n      include_re = Pattern.compile(include_re_string);\n    }\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param reader source from which to read entries\n   * @see #EntryReader(Reader,String,String,String)\n   */\n  public EntryReader(Reader reader) {\n    this(reader, reader.toString(), null, null);\n  }\n\n  /// File Constructors\n\n  /**\n   * Create an EntryReader.\n   *\n   *    @param file       initial file to read\n   *    @param comment_re regular expression that matches comments.\n   *                      Any text that matches comment_re is removed.\n   *                      A line that is entirely a comment is ignored.\n   *    @param include_re regular expression that matches include directives.\n   *                      The expression should define one group that contains\n   *                      the include file name.\n   * @throws IOException if there is a problem reading the file\n   */\n  public EntryReader(\n      File file,\n      /*@Nullable*/ /*@Regex*/ String comment_re,\n      /*@Nullable*/ /*@Regex(1)*/ String include_re)\n      throws IOException {\n    this(UtilMDE.fileReader(file), file.toString(), comment_re, include_re);\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param file the file to read\n   * @throws IOException if there is a problem reading the file\n   * @see #EntryReader(File,String,String)\n   */\n  public EntryReader(File file) throws IOException {\n    this(file, null, null);\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param file the file to read\n   * @param charsetName the character set to use\n   * @throws IOException if there is a problem reading the file\n   * @see #EntryReader(File,String,String)\n   */\n  public EntryReader(File file, String charsetName) throws IOException {\n    this(UtilMDE.fileInputStream(file), charsetName, file.toString(), null, null);\n  }\n\n  /// Filename constructors\n\n  /**\n   * Create a new EntryReader starting with the specified file.\n   *\n   *    @param filename   initial file to read\n   *    @param comment_re regular expression that matches comments.\n   *                      Any text that matches comment_re is removed.\n   *                      A line that is entirely a comment is ignored.\n   *    @param include_re regular expression that matches include directives.\n   *                      The expression should define one group that contains\n   *                      the include file name.\n   *\n   * @throws IOException if there is a problem reading the file\n   *\n   * @see #EntryReader(File,String,String)\n   */\n  public EntryReader(\n      String filename,\n      /*@Nullable*/ /*@Regex*/ String comment_re,\n      /*@Nullable*/ /*@Regex(1)*/ String include_re)\n      throws IOException {\n    this(new File(filename), comment_re, include_re);\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param filename source from which to read entries\n   * @throws IOException if there is a problem reading the file\n   * @see #EntryReader(String,String,String)\n   */\n  public EntryReader(String filename) throws IOException {\n    this(filename, null, null);\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param filename source from which to read entries\n   * @param charsetName the character set to use\n   * @throws IOException if there is a problem reading the file\n   * @see #EntryReader(String,String,String)\n   */\n  public EntryReader(String filename, String charsetName) throws IOException {\n    this(new FileInputStream(filename), charsetName, filename, null, null);\n  }\n\n  ///\n  /// Methods\n  ///\n\n  /**\n   * Read a line, ignoring comments and processing includes.  Note that\n   * a line that is completely a comment is completely ignored (and\n   * not returned as a blank line).  Returns null at end of file.\n   * @return the string that was read, or null at end of file\n   */\n  @Override\n  public /*@Nullable*/ String readLine() throws IOException {\n\n    // System.out.printf (\"Entering size = %d%n\", readers.size());\n\n    // If a line has been pushed back, return it instead\n    if (pushback_line != null) {\n      String line = pushback_line;\n      pushback_line = null;\n      return line;\n    }\n\n    String line = get_next_line();\n    if (comment_re != null) {\n      while (line != null) {\n        Matcher cmatch = comment_re.matcher(line);\n        if (cmatch.find()) {\n          line = cmatch.replaceFirst(\"\");\n          if (line.length() > 0) {\n            break;\n          }\n        } else {\n          break;\n        }\n        line = get_next_line();\n        // System.out.printf (\"get_next_line = %s%n\", line);\n      }\n    }\n\n    if (line == null) {\n      return null;\n    }\n\n    // Handle include files.  Non-absolute pathnames are relative\n    // to the including file (the current file)\n    if (include_re != null) {\n      Matcher m = include_re.matcher(line);\n      if (m.matches()) {\n        String filename_string = m.group(1);\n        if (filename_string == null) {\n          throw new Error(\n              String.format(\"include_re (%s) does not capture group 1 in %s\", include_re, line));\n        }\n        File filename = new File(UtilMDE.expandFilename(filename_string));\n        // System.out.printf (\"Trying to include filename %s%n\", filename);\n        if (!filename.isAbsolute()) {\n          FlnReader reader = readers.peek();\n          File current_filename = new File(reader.filename);\n          File current_parent = current_filename.getParentFile();\n          filename = new File(current_parent, filename.toString());\n          // System.out.printf (\"absolute filename = %s %s %s%n\",\n          //                     current_filename, current_parent, filename);\n        }\n        readers.push(new FlnReader(filename.getAbsolutePath()));\n        return readLine();\n      }\n    }\n\n    // System.out.printf (\"Returning [%d] '%s'%n\", readers.size(), line);\n    return (line);\n  }\n\n  /**\n   * Return a line-by-line iterator for this file.\n   * <p>\n   *\n   * <b>Warning:</b> This does not return a fresh iterator each time.  The\n   * iterator is a singleton, the same one is returned each time, and a new\n   * one can never be created after it is exhausted.\n   *\n   * @return a line-by-line iterator for this file\n   */\n  @Override\n  public Iterator<String> iterator() {\n    return this;\n  }\n\n  /**\n   * Returns whether or not there is another line to read.  Any IOExceptions\n   * are turned into errors (because the definition of hasNext() in Iterator\n   * doesn't throw any exceptions).\n   * @return whether there is another line to read\n   */\n  @Override\n  public boolean hasNext() {\n    if (pushback_line != null) {\n      return true;\n    }\n\n    String line = null;\n    try {\n      line = readLine();\n    } catch (IOException e) {\n      throw new Error(\"unexpected IOException: \", e);\n    }\n\n    if (line == null) {\n      return false;\n    }\n\n    putback(line);\n    return true;\n  }\n\n  /**\n   * Return the next line in the multi-file.\n   * @return the next line in the multi-file\n   * Throws NoSuchElementException at end of file\n   */\n  @Override\n  public String next() {\n    try {\n      String result = readLine();\n      if (result != null) {\n        return result;\n      } else {\n        throw new NoSuchElementException();\n      }\n    } catch (IOException e) {\n      throw new Error(\"unexpected IOException\", e);\n    }\n  }\n\n  /** remove() is not supported. */\n  @Override\n  public void remove() {\n    throw new UnsupportedOperationException(\"can't remove lines from file\");\n  }\n\n  /**\n   * Returns the next entry (paragraph) in the file.  Entries are separated\n   * by blank lines unless the entry started with {@link #entry_start_re}\n   * (see {@link #set_entry_start_stop}).  If no more entries are\n   * available, returns null.\n   * @return the next entry (paragraph) in the file\n   * @throws IOException if there is a problem reading the file\n   */\n  public /*@Nullable*/ Entry get_entry() throws IOException {\n\n    // Skip any preceding blank lines\n    String line = readLine();\n    while ((line != null) && (line.trim().length() == 0)) {\n      line = readLine();\n    }\n    if (line == null) {\n      return (null);\n    }\n\n    StringBuilder body = new StringBuilder(10000);\n    Entry entry = null;\n    String filename = getFileName();\n    long line_number = getLineNumber();\n\n    // If first line matches entry_start_re, this is a long entry.\n    /*@Regex(1)*/ Matcher entry_match = null;\n    if (entry_start_re != null) {\n      entry_match = entry_start_re.matcher(line);\n    }\n    if ((entry_match != null) && entry_match.find()) {\n      assert entry_start_re != null : \"@AssumeAssertion(nullness): dependent: entry_match != null\";\n      assert entry_stop_re != null\n          : \"@AssumeAssertion(nullness): dependent: entry_start_re != null\";\n\n      // Remove entry match from the line\n      if (entry_match.groupCount() > 0) {\n        @SuppressWarnings(\n            \"nullness\") // dependent: just checked that group 1 exists via groupCount(); https://code.google.com/p/checker-framework/issues/detail?id=291\n        /*@NonNull*/ String match_group_1 = entry_match.group(1);\n        line = entry_match.replaceFirst(match_group_1);\n      }\n\n      // Description is the first line\n      String description = line;\n\n      // Read until we find the termination of the entry\n      Matcher end_entry_match = entry_stop_re.matcher(line);\n      while ((line != null)\n          && !entry_match.find()\n          && !end_entry_match.find()\n          && filename.equals(getFileName())) {\n        body.append(line);\n        body.append(lineSep);\n        line = readLine();\n        if (line == null) {\n          break; // end of file serves as entry terminator\n        }\n        entry_match = entry_start_re.matcher(line);\n        end_entry_match = entry_stop_re.matcher(line);\n      }\n\n      // If this entry was terminated by the start of the next one,\n      // put that line back\n      if ((line != null) && (entry_match.find(0) || !filename.equals(getFileName()))) {\n        putback(line);\n      }\n\n      entry = new Entry(description, body.toString(), filename, line_number, false);\n\n    } else { // blank-separated entry\n\n      String description = line;\n\n      // Read until we find another blank line\n      while ((line != null) && (line.trim().length() != 0) && filename.equals(getFileName())) {\n        body.append(line);\n        body.append(lineSep);\n        line = readLine();\n      }\n\n      // If this entry was terminated by the start of a new input file\n      // put that line back\n      if ((line != null) && !filename.equals(getFileName())) {\n        putback(line);\n      }\n\n      entry = new Entry(description, body.toString(), filename, line_number, true);\n    }\n\n    return (entry);\n  }\n\n  /**\n   * Reads the next line from the current reader.  If EOF is encountered\n   * pop out to the next reader.  Returns null if there is no more input.\n   * @return next line from the reader, or null if there is no more input\n   */\n  private /*@Nullable*/ String get_next_line() throws IOException {\n\n    if (readers.size() == 0) {\n      return (null);\n    }\n\n    FlnReader ri1 = readers.peek();\n    String line = ri1.readLine();\n    while (line == null) {\n      readers.pop();\n      if (readers.empty()) {\n        return (null);\n      }\n      FlnReader ri2 = readers.peek();\n      line = ri2.readLine();\n    }\n    return (line);\n  }\n\n  /**\n   * Returns the current filename.\n   * @return the current filename\n   */\n  public String getFileName() {\n    FlnReader ri = readers.peek();\n    if (ri == null) {\n      throw new Error(\"Past end of input\");\n    }\n    return ri.filename;\n  }\n\n  /**\n   * Return the current line number in the current file.\n   * @return the current line number\n   */\n  @Override\n  public int getLineNumber() {\n    FlnReader ri = readers.peek();\n    if (ri == null) {\n      throw new Error(\"Past end of input\");\n    }\n    return ri.getLineNumber();\n  }\n\n  /** Set the current line number in the current file.\n   * @param lineNumber new line number for the current file\n   */\n  @Override\n  public void setLineNumber(int lineNumber) {\n    FlnReader ri = readers.peek();\n    if (ri == null) {\n      throw new Error(\"Past end of input\");\n    }\n    ri.setLineNumber(lineNumber);\n  }\n\n  /**\n   * Set the regular expressions for the start and stop of long\n   * entries (multiple lines that are read as a group by get_entry()).\n   * @param entry_start_re regular expression that starts a long entry\n   * @param entry_stop_re regular expression that ends a long entry\n   */\n  public void set_entry_start_stop(\n      /*@Regex(1)*/ String entry_start_re, /*@Regex*/ String entry_stop_re) {\n    this.entry_start_re = Pattern.compile(entry_start_re);\n    this.entry_stop_re = Pattern.compile(entry_stop_re);\n  }\n\n  /**\n   * Set the regular expressions for the start and stop of long\n   * entries (multiple lines that are read as a group by get_entry()).\n   * @param entry_start_re regular expression that starts a long entry\n   * @param entry_stop_re regular expression that ends a long entry\n   */\n  public void set_entry_start_stop(/*@Regex(1)*/ Pattern entry_start_re, Pattern entry_stop_re) {\n    this.entry_start_re = entry_start_re;\n    this.entry_stop_re = entry_stop_re;\n  }\n\n  /**\n   * Puts the specified line back in the input.  Only one line can be\n   * put back.\n   * @param line the line to be put back in the input\n   */\n  // TODO:  This would probably be better implemented with the \"mark\" mechanism\n  // of BufferedReader (which is also in LineNumberReader and FlnReader).\n  public void putback(String line) {\n    assert pushback_line == null\n        : \"push back '\" + line + \"' when '\" + pushback_line + \"' already back\";\n    pushback_line = line;\n  }\n\n  /** Mark the present position in the stream. */\n  @Override\n  public void mark(int readAheadLimit) {\n    throw new Error(\"not yet implemented\");\n  }\n  /** Read a single character. */\n  @Override\n  public int read() {\n    throw new Error(\"not yet implemented\");\n  }\n  /** Read characters into a portion of an array. */\n  @Override\n  public int read(char[] cbuf, int off, int len) {\n    throw new Error(\"not yet implemented\");\n  }\n  /** Reset the stream to the most recent mark. */\n  @Override\n  public void reset() {\n    throw new Error(\"not yet implemented\");\n  }\n  /** Skip characters. */\n  @Override\n  public long skip(long n) {\n    throw new Error(\"not yet implemented\");\n  }\n\n  /**\n   * Simple usage example.\n   * @param args command-line arguments: filename [comment_re [include_re]]\n   * @throws IOException if there is a problem reading a file\n   */\n  public static void main(String[] args) throws IOException {\n\n    if (args.length < 1 || args.length > 3) {\n      System.err.println(\n          \"EntryReader sample program requires 1-3 args: filename [comment_re [include_re]]\");\n      System.exit(1);\n    }\n    String filename = args[0];\n    String comment_re = null;\n    String include_re = null;\n    if (args.length >= 2) {\n      comment_re = args[1];\n      if (!RegexUtil.isRegex(comment_re)) {\n        System.err.println(\n            \"Error parsing comment regex \\\"\"\n                + comment_re\n                + \"\\\": \"\n                + RegexUtil.regexError(comment_re));\n        System.exit(1);\n      }\n    }\n    if (args.length >= 3) {\n      include_re = args[2];\n      if (!RegexUtil.isRegex(include_re, 1)) {\n        System.err.println(\n            \"Error parsing include regex \\\"\"\n                + include_re\n                + \"\\\": \"\n                + RegexUtil.regexError(include_re));\n        System.exit(1);\n      }\n    }\n    EntryReader reader = new EntryReader(filename, comment_re, include_re);\n\n    String line = reader.readLine();\n    while (line != null) {\n      System.out.printf(\"%s: %d: %s%n\", reader.getFileName(), reader.getLineNumber(), line);\n      line = reader.readLine();\n    }\n  }\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "in", "java.io", "InputStream" ], [ "charsetName", "java.lang", "String" ], [ "filename", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "toString", "java.lang", "Object", "public String toString()" ], [ "readLine", "java.io", "BufferedReader", "String readLine(boolean arg0, boolean[] arg1) throws IOException" ], [ "read", "plume", "EntryReader", "public int read(char[] cbuf, int off, int len)" ], [ "skip", "plume", "EntryReader", "public long skip(long n)" ], [ "read", "java.io", "Reader", "public int read(CharBuffer arg0) throws IOException" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "ready", "java.io", "BufferedReader", "public boolean ready() throws IOException" ], [ "lines", "java.io", "BufferedReader", "public Stream<String> lines()" ], [ "transferTo", "java.io", "Reader", "public long transferTo(Writer arg0) throws IOException" ], [ "getLineNumber", "plume", "EntryReader", "public int getLineNumber()" ], [ "next", "plume", "EntryReader", "public String next()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "readLine", "plume", "EntryReader", "public String readLine() throws IOException" ], [ "iterator", "plume", "EntryReader", "public Iterator<String> iterator()" ], [ "read", "java.io", "Reader", "public int read(char[] arg0) throws IOException" ], [ "read", "plume", "EntryReader", "public int read()" ], [ "next", "java.util", "Iterator", "public abstract E next()" ], [ "get_entry", "plume", "EntryReader", "public Entry get_entry() throws IOException" ], [ "getFileName", "plume", "EntryReader", "public String getFileName()" ], [ "hasNext", "plume", "EntryReader", "public boolean hasNext()" ], [ "markSupported", "java.io", "BufferedReader", "public boolean markSupported()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "read", "java.io", "InputStream", "public int read(byte[] arg0) throws IOException" ], [ "markSupported", "java.io", "InputStream", "public boolean markSupported()" ], [ "available", "java.io", "InputStream", "public int available() throws IOException" ], [ "readAllBytes", "java.io", "InputStream", "public byte[] readAllBytes() throws IOException" ], [ "transferTo", "java.io", "InputStream", "public long transferTo(OutputStream arg0) throws IOException" ], [ "readNBytes", "java.io", "InputStream", "public byte[] readNBytes(int arg0) throws IOException" ], [ "read", "java.io", "InputStream", "public abstract int read() throws IOException" ], [ "skip", "java.io", "InputStream", "public long skip(long arg0) throws IOException" ], [ "read", "java.io", "InputStream", "public int read(byte[] arg0, int arg1, int arg2) throws IOException" ], [ "readNBytes", "java.io", "InputStream", "public int readNBytes(byte[] arg0, int arg1, int arg2) throws IOException" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "length", "java.lang", "String", "public int length()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "entry_start_re", "plume", "EntryReader", "public Pattern entry_start_re = null;" ], [ "entry_stop_re", "plume", "EntryReader", "public Pattern entry_stop_re = null;" ], [ "pushback_line", "plume", "EntryReader", "String pushback_line = null;" ], [ "lock", "java.io", "Reader", "protected Object lock;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 11000,
  "oracle" : ";",
  "oracleType" : "PRE",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "EntryReader",
  "javadocTag" : "@param filename the file name",
  "methodJavadoc" : "    /**\n   * Create a EntryReader that uses the default character set and does not\n   * support comments or include directives.\n   * @param in the InputStream\n   * @param filename the file name\n   * @see #EntryReader(InputStream,String,String,String,String)\n   */",
  "methodSourceCode" : "public EntryReader(InputStream in, String filename){\n    this(in, filename, null, null);\n}",
  "classJavadoc" : "/**\n * Class that reads \"entries\" from a file.  In the simplest case, entries\n * can be lines.  It supports:\n *   include files,\n *   comments, and\n *   multi-line entries (paragraphs).\n * The syntax of each of these is customizable.\n * <p>\n *\n * Example use:\n * <pre>\n *  // args are filename, comment regexp, include regexp\n *  try (EntryReader er = new EntryReader(filename, \"^#.*\", null)) {\n *    for (String line : er) {\n *      ...\n *    }\n *  } catch (IOException e) {\n *    System.err.println(\"Problem reading \" + filename + \": \" + e.getMessage());\n *    System.exit(2);\n *    throw new Error(\"This can't happen\"); // for definite assignment check\n *  }\n * </pre>\n *\n * @see #get_entry() and @see #set_entry_start_stop(String,String)\n */",
  "classSourceCode" : "package plume;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.io.Reader;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.CharBuffer;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.Stack;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/*>>>\nimport org.checkerframework.checker.lock.qual.*;\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.checker.regex.qual.*;\n*/\n\n// TODO:\n// EntryReader has a public concept of \"short entry\", but I don't think that\n// concept is logically part of EntryReader.  I think it would be better for\n// Lookup to make this decision itself, for instance by checking whether there\n// are any line separators in the entry that it gets back.\n//\n// Here are some useful features that EntryReader should have.\n//  * It should implement some unimplemented methods from LineNumberReader (see\n//    \"not yet implemented\" in this file).\n//  * It should have constructors that take an InputStream or Reader\n//    (in addition to the current BufferedReader, File, and String versions).\n//  * It should have a close method.\n//  * It should automatically close the underlying file/etc. when the\n//    iterator gets to the end (or the end is otherwise reached).\n\n/**\n * Class that reads \"entries\" from a file.  In the simplest case, entries\n * can be lines.  It supports:\n *   include files,\n *   comments, and\n *   multi-line entries (paragraphs).\n * The syntax of each of these is customizable.\n * <p>\n *\n * Example use:\n * <pre>\n *  // args are filename, comment regexp, include regexp\n *  try (EntryReader er = new EntryReader(filename, \"^#.*\", null)) {\n *    for (String line : er) {\n *      ...\n *    }\n *  } catch (IOException e) {\n *    System.err.println(\"Problem reading \" + filename + \": \" + e.getMessage());\n *    System.exit(2);\n *    throw new Error(\"This can't happen\"); // for definite assignment check\n *  }\n * </pre>\n *\n * @see #get_entry() and @see #set_entry_start_stop(String,String)\n */\npublic class EntryReader extends LineNumberReader implements Iterable<String>, Iterator<String> {\n\n  ///\n  /// User configuration variables\n  ///\n\n  /** Regular expression that specifies an include file. */\n  private final /*@Nullable*/ /*@Regex(1)*/ Pattern include_re;\n\n  /** Regular expression that matches a comment. */\n  private final /*@Nullable*/ Pattern comment_re;\n\n  /**\n   * Regular expression that starts a long entry.\n   * <p>\n   * If the first line of an entry matches this regexp, then the entry is\n   * terminated by:  entry_stop_re, another line that matches\n   * entry_start_re (even not following a newline), or the end of the\n   * current file.\n   * <p>\n   * Otherwise, the first line of an entry does NOT match this regexp (or\n   * the regexp is null), in which case the entry is terminated by a blank\n   * line or the end of the current file.\n   */\n  public /*@MonotonicNonNull*/ /*@Regex(1)*/ Pattern entry_start_re = null;\n\n  /**\n   * @see #entry_start_re\n   */\n  public /*@MonotonicNonNull*/ Pattern entry_stop_re = null;\n\n  ///\n  /// Internal implementation variables\n  ///\n\n  /** Stack of readers.  Used to support include files. */\n  private final Stack<FlnReader> readers = new Stack<FlnReader>();\n\n  /** Line that is pushed back to be reread. */\n  /*@Nullable*/ String pushback_line = null;\n\n  /** Platform-specific line separator. */\n  private static final String lineSep = System.getProperty(\"line.separator\");\n\n  ///\n  /// Helper classes\n  ///\n\n  /**\n   * Like LineNumberReader, but also has a filename field.\n   * \"FlnReader\" stands for \"Filename and Line Number Reader\".\n   */\n  private static class FlnReader extends LineNumberReader {\n    /** The file being read. */\n    public String filename;\n\n    /**\n     * Create a FlnReader.\n     * @param reader source from which to read entries\n     * @param filename file name corresponding to reader, for use in error messages.\n     *   Must be non-null; if there isn't a name, clients should provide a dummy value.\n     */\n    public FlnReader(Reader reader, String filename) {\n      super(reader);\n      this.filename = filename;\n    }\n\n    /**\n     * Create a FlnReader.\n     * @param filename file from which to read\n     */\n    public FlnReader(String filename) throws IOException {\n      super(UtilMDE.fileReader(filename));\n      this.filename = filename;\n    }\n  }\n\n  /** Descriptor for an entry (paragraph). */\n  public static class Entry {\n    /** First line of the entry. */\n    public String first_line;\n    /** Complete body of the entry including the first line. */\n    public String body;\n    /** True if this is a short entry (blank-line-separated). */\n    boolean short_entry;\n    /** Filename in which the entry was found. */\n    String filename;\n    /** Line number of first line of entry. */\n    long line_number;\n\n    /** Create an entry.\n     * @param first_line first line of the entry\n     * @param body complete body of the entry including the first line\n     * @param short_entry true if this is a short entry (blank-line-separated)\n     * @param filename filename in which the entry was found\n     * @param line_number line number of first line of entry\n     */\n    Entry(String first_line, String body, String filename, long line_number, boolean short_entry) {\n      this.first_line = first_line;\n      this.body = body;\n      this.filename = filename;\n      this.line_number = line_number;\n      this.short_entry = short_entry;\n    }\n\n    /**\n     * Return a substring of the entry body that matches the specified\n     * regular expression.  If no match is found, returns the first_line.\n     * @param re regex to match\n     * @return a substring that matches re\n     */\n    String get_description(/*@Nullable*/ Pattern re) {\n\n      if (re == null) {\n        return first_line;\n      }\n\n      Matcher descr = re.matcher(body);\n      if (descr.find()) {\n        return descr.group();\n      } else {\n        return first_line;\n      }\n    }\n  }\n\n  ///\n  /// Constructors\n  ///\n\n  /// Inputstream and charset constructors\n\n  /** Create a EntryReader that uses the given character set.\n   * @throws UnsupportedEncodingException if the charset encoding is not supported\n   * @param in source from which to read entries\n   * @param charsetName the character set to use\n   * @param filename non-null file name for stream being read\n   * @param comment_re_string regular expression that matches comments.\n   *                      Any text that matches comment_re is removed.\n   *                      A line that is entirely a comment is ignored.\n   * @param include_re_string regular expression that matches include directives.\n   *                      The expression should define one group that contains\n   *                      the include file name.\n   * @see #EntryReader(InputStream,String,String,String)\n   */\n  public EntryReader(\n      InputStream in,\n      String charsetName,\n      String filename,\n      /*@Nullable*/ /*@Regex*/ String comment_re_string,\n      /*@Nullable*/ /*@Regex(1)*/ String include_re_string)\n      throws UnsupportedEncodingException {\n    this(new InputStreamReader(in, charsetName), filename, comment_re_string, include_re_string);\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param in the InputStream\n   * @param charsetName the character set to use\n   * @param filename the file name\n   * @throws UnsupportedEncodingException if the charset encoding is not supported\n   * @see #EntryReader(InputStream,String,String,String)\n   */\n  public EntryReader(InputStream in, String charsetName, String filename)\n      throws UnsupportedEncodingException {\n    this(in, charsetName, filename, null, null);\n  }\n\n  /// Inputstream (no charset) constructors\n\n  /**\n   * Create a EntryReader.\n   *\n   *    @param in source from which to read entries\n   *    @param filename non-null file name for stream being read\n   *    @param comment_re_string regular expression that matches comments.\n   *                      Any text that matches comment_re is removed.\n   *                      A line that is entirely a comment is ignored.\n   *    @param include_re_string regular expression that matches include directives.\n   *                      The expression should define one group that contains\n   *                      the include file name.\n   */\n  public EntryReader(\n      InputStream in,\n      String filename,\n      /*@Nullable*/ /*@Regex*/ String comment_re_string,\n      /*@Nullable*/ /*@Regex(1)*/ String include_re_string) {\n    this(new InputStreamReader(in), filename, comment_re_string, include_re_string);\n  }\n\n  /**\n   * Create a EntryReader that uses the default character set and does not\n   * support comments or include directives.\n   * @param in the InputStream\n   * @param filename the file name\n   * @see #EntryReader(InputStream,String,String,String,String)\n   */\n  public EntryReader(InputStream in, String filename) {\n    this(in, filename, null, null);\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param in the InputStream\n   * @see #EntryReader(InputStream,String,String,String)\n   */\n  public EntryReader(InputStream in) {\n    this(in, \"(InputStream)\", null, null);\n  }\n\n  /** A dummy Reader to be used when null is not acceptable. */\n  private static class DummyReader extends Reader {\n    @Override\n    public void close(/*>>>@GuardSatisfied DummyReader this*/) {\n      // No error, because closing is OK if it appears in try-with-resources.\n      // Later maybe create two versions (with and without exception here).\n    }\n\n    @Override\n    public void mark(int readAheadLimit) {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public boolean markSupported() {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public int read() {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public int read(char[] cbuf) {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public int read(char[] cbuf, int off, int len) {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public int read(CharBuffer target) {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public boolean ready() {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public void reset() {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public long skip(long n) {\n      throw new Error(\"DummyReader\");\n    }\n  }\n\n  /**\n   * Create a EntryReader.\n   *\n   *    @param reader source from which to read entries\n   *    @param filename file name corresponding to reader, for use in error messages\n   *    @param comment_re_string regular expression that matches comments.\n   *                      Any text that matches comment_re is removed.\n   *                      A line that is entirely a comment is ignored\n   *    @param include_re_string regular expression that matches include directives.\n   *                      The expression should define one group that contains\n   *                      the include file name\n   */\n  public EntryReader(\n      Reader reader,\n      String filename,\n      /*@Nullable*/ /*@Regex*/ String comment_re_string,\n      /*@Nullable*/ /*@Regex(1)*/ String include_re_string) {\n    // we won't use superclass methods, but passing null as an argument\n    // leads to a NullPointerException.\n    super(new DummyReader());\n    readers.push(new FlnReader(reader, filename));\n    if (comment_re_string == null) {\n      comment_re = null;\n    } else {\n      comment_re = Pattern.compile(comment_re_string);\n    }\n    if (include_re_string == null) {\n      include_re = null;\n    } else {\n      include_re = Pattern.compile(include_re_string);\n    }\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param reader source from which to read entries\n   * @see #EntryReader(Reader,String,String,String)\n   */\n  public EntryReader(Reader reader) {\n    this(reader, reader.toString(), null, null);\n  }\n\n  /// File Constructors\n\n  /**\n   * Create an EntryReader.\n   *\n   *    @param file       initial file to read\n   *    @param comment_re regular expression that matches comments.\n   *                      Any text that matches comment_re is removed.\n   *                      A line that is entirely a comment is ignored.\n   *    @param include_re regular expression that matches include directives.\n   *                      The expression should define one group that contains\n   *                      the include file name.\n   * @throws IOException if there is a problem reading the file\n   */\n  public EntryReader(\n      File file,\n      /*@Nullable*/ /*@Regex*/ String comment_re,\n      /*@Nullable*/ /*@Regex(1)*/ String include_re)\n      throws IOException {\n    this(UtilMDE.fileReader(file), file.toString(), comment_re, include_re);\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param file the file to read\n   * @throws IOException if there is a problem reading the file\n   * @see #EntryReader(File,String,String)\n   */\n  public EntryReader(File file) throws IOException {\n    this(file, null, null);\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param file the file to read\n   * @param charsetName the character set to use\n   * @throws IOException if there is a problem reading the file\n   * @see #EntryReader(File,String,String)\n   */\n  public EntryReader(File file, String charsetName) throws IOException {\n    this(UtilMDE.fileInputStream(file), charsetName, file.toString(), null, null);\n  }\n\n  /// Filename constructors\n\n  /**\n   * Create a new EntryReader starting with the specified file.\n   *\n   *    @param filename   initial file to read\n   *    @param comment_re regular expression that matches comments.\n   *                      Any text that matches comment_re is removed.\n   *                      A line that is entirely a comment is ignored.\n   *    @param include_re regular expression that matches include directives.\n   *                      The expression should define one group that contains\n   *                      the include file name.\n   *\n   * @throws IOException if there is a problem reading the file\n   *\n   * @see #EntryReader(File,String,String)\n   */\n  public EntryReader(\n      String filename,\n      /*@Nullable*/ /*@Regex*/ String comment_re,\n      /*@Nullable*/ /*@Regex(1)*/ String include_re)\n      throws IOException {\n    this(new File(filename), comment_re, include_re);\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param filename source from which to read entries\n   * @throws IOException if there is a problem reading the file\n   * @see #EntryReader(String,String,String)\n   */\n  public EntryReader(String filename) throws IOException {\n    this(filename, null, null);\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param filename source from which to read entries\n   * @param charsetName the character set to use\n   * @throws IOException if there is a problem reading the file\n   * @see #EntryReader(String,String,String)\n   */\n  public EntryReader(String filename, String charsetName) throws IOException {\n    this(new FileInputStream(filename), charsetName, filename, null, null);\n  }\n\n  ///\n  /// Methods\n  ///\n\n  /**\n   * Read a line, ignoring comments and processing includes.  Note that\n   * a line that is completely a comment is completely ignored (and\n   * not returned as a blank line).  Returns null at end of file.\n   * @return the string that was read, or null at end of file\n   */\n  @Override\n  public /*@Nullable*/ String readLine() throws IOException {\n\n    // System.out.printf (\"Entering size = %d%n\", readers.size());\n\n    // If a line has been pushed back, return it instead\n    if (pushback_line != null) {\n      String line = pushback_line;\n      pushback_line = null;\n      return line;\n    }\n\n    String line = get_next_line();\n    if (comment_re != null) {\n      while (line != null) {\n        Matcher cmatch = comment_re.matcher(line);\n        if (cmatch.find()) {\n          line = cmatch.replaceFirst(\"\");\n          if (line.length() > 0) {\n            break;\n          }\n        } else {\n          break;\n        }\n        line = get_next_line();\n        // System.out.printf (\"get_next_line = %s%n\", line);\n      }\n    }\n\n    if (line == null) {\n      return null;\n    }\n\n    // Handle include files.  Non-absolute pathnames are relative\n    // to the including file (the current file)\n    if (include_re != null) {\n      Matcher m = include_re.matcher(line);\n      if (m.matches()) {\n        String filename_string = m.group(1);\n        if (filename_string == null) {\n          throw new Error(\n              String.format(\"include_re (%s) does not capture group 1 in %s\", include_re, line));\n        }\n        File filename = new File(UtilMDE.expandFilename(filename_string));\n        // System.out.printf (\"Trying to include filename %s%n\", filename);\n        if (!filename.isAbsolute()) {\n          FlnReader reader = readers.peek();\n          File current_filename = new File(reader.filename);\n          File current_parent = current_filename.getParentFile();\n          filename = new File(current_parent, filename.toString());\n          // System.out.printf (\"absolute filename = %s %s %s%n\",\n          //                     current_filename, current_parent, filename);\n        }\n        readers.push(new FlnReader(filename.getAbsolutePath()));\n        return readLine();\n      }\n    }\n\n    // System.out.printf (\"Returning [%d] '%s'%n\", readers.size(), line);\n    return (line);\n  }\n\n  /**\n   * Return a line-by-line iterator for this file.\n   * <p>\n   *\n   * <b>Warning:</b> This does not return a fresh iterator each time.  The\n   * iterator is a singleton, the same one is returned each time, and a new\n   * one can never be created after it is exhausted.\n   *\n   * @return a line-by-line iterator for this file\n   */\n  @Override\n  public Iterator<String> iterator() {\n    return this;\n  }\n\n  /**\n   * Returns whether or not there is another line to read.  Any IOExceptions\n   * are turned into errors (because the definition of hasNext() in Iterator\n   * doesn't throw any exceptions).\n   * @return whether there is another line to read\n   */\n  @Override\n  public boolean hasNext() {\n    if (pushback_line != null) {\n      return true;\n    }\n\n    String line = null;\n    try {\n      line = readLine();\n    } catch (IOException e) {\n      throw new Error(\"unexpected IOException: \", e);\n    }\n\n    if (line == null) {\n      return false;\n    }\n\n    putback(line);\n    return true;\n  }\n\n  /**\n   * Return the next line in the multi-file.\n   * @return the next line in the multi-file\n   * Throws NoSuchElementException at end of file\n   */\n  @Override\n  public String next() {\n    try {\n      String result = readLine();\n      if (result != null) {\n        return result;\n      } else {\n        throw new NoSuchElementException();\n      }\n    } catch (IOException e) {\n      throw new Error(\"unexpected IOException\", e);\n    }\n  }\n\n  /** remove() is not supported. */\n  @Override\n  public void remove() {\n    throw new UnsupportedOperationException(\"can't remove lines from file\");\n  }\n\n  /**\n   * Returns the next entry (paragraph) in the file.  Entries are separated\n   * by blank lines unless the entry started with {@link #entry_start_re}\n   * (see {@link #set_entry_start_stop}).  If no more entries are\n   * available, returns null.\n   * @return the next entry (paragraph) in the file\n   * @throws IOException if there is a problem reading the file\n   */\n  public /*@Nullable*/ Entry get_entry() throws IOException {\n\n    // Skip any preceding blank lines\n    String line = readLine();\n    while ((line != null) && (line.trim().length() == 0)) {\n      line = readLine();\n    }\n    if (line == null) {\n      return (null);\n    }\n\n    StringBuilder body = new StringBuilder(10000);\n    Entry entry = null;\n    String filename = getFileName();\n    long line_number = getLineNumber();\n\n    // If first line matches entry_start_re, this is a long entry.\n    /*@Regex(1)*/ Matcher entry_match = null;\n    if (entry_start_re != null) {\n      entry_match = entry_start_re.matcher(line);\n    }\n    if ((entry_match != null) && entry_match.find()) {\n      assert entry_start_re != null : \"@AssumeAssertion(nullness): dependent: entry_match != null\";\n      assert entry_stop_re != null\n          : \"@AssumeAssertion(nullness): dependent: entry_start_re != null\";\n\n      // Remove entry match from the line\n      if (entry_match.groupCount() > 0) {\n        @SuppressWarnings(\n            \"nullness\") // dependent: just checked that group 1 exists via groupCount(); https://code.google.com/p/checker-framework/issues/detail?id=291\n        /*@NonNull*/ String match_group_1 = entry_match.group(1);\n        line = entry_match.replaceFirst(match_group_1);\n      }\n\n      // Description is the first line\n      String description = line;\n\n      // Read until we find the termination of the entry\n      Matcher end_entry_match = entry_stop_re.matcher(line);\n      while ((line != null)\n          && !entry_match.find()\n          && !end_entry_match.find()\n          && filename.equals(getFileName())) {\n        body.append(line);\n        body.append(lineSep);\n        line = readLine();\n        if (line == null) {\n          break; // end of file serves as entry terminator\n        }\n        entry_match = entry_start_re.matcher(line);\n        end_entry_match = entry_stop_re.matcher(line);\n      }\n\n      // If this entry was terminated by the start of the next one,\n      // put that line back\n      if ((line != null) && (entry_match.find(0) || !filename.equals(getFileName()))) {\n        putback(line);\n      }\n\n      entry = new Entry(description, body.toString(), filename, line_number, false);\n\n    } else { // blank-separated entry\n\n      String description = line;\n\n      // Read until we find another blank line\n      while ((line != null) && (line.trim().length() != 0) && filename.equals(getFileName())) {\n        body.append(line);\n        body.append(lineSep);\n        line = readLine();\n      }\n\n      // If this entry was terminated by the start of a new input file\n      // put that line back\n      if ((line != null) && !filename.equals(getFileName())) {\n        putback(line);\n      }\n\n      entry = new Entry(description, body.toString(), filename, line_number, true);\n    }\n\n    return (entry);\n  }\n\n  /**\n   * Reads the next line from the current reader.  If EOF is encountered\n   * pop out to the next reader.  Returns null if there is no more input.\n   * @return next line from the reader, or null if there is no more input\n   */\n  private /*@Nullable*/ String get_next_line() throws IOException {\n\n    if (readers.size() == 0) {\n      return (null);\n    }\n\n    FlnReader ri1 = readers.peek();\n    String line = ri1.readLine();\n    while (line == null) {\n      readers.pop();\n      if (readers.empty()) {\n        return (null);\n      }\n      FlnReader ri2 = readers.peek();\n      line = ri2.readLine();\n    }\n    return (line);\n  }\n\n  /**\n   * Returns the current filename.\n   * @return the current filename\n   */\n  public String getFileName() {\n    FlnReader ri = readers.peek();\n    if (ri == null) {\n      throw new Error(\"Past end of input\");\n    }\n    return ri.filename;\n  }\n\n  /**\n   * Return the current line number in the current file.\n   * @return the current line number\n   */\n  @Override\n  public int getLineNumber() {\n    FlnReader ri = readers.peek();\n    if (ri == null) {\n      throw new Error(\"Past end of input\");\n    }\n    return ri.getLineNumber();\n  }\n\n  /** Set the current line number in the current file.\n   * @param lineNumber new line number for the current file\n   */\n  @Override\n  public void setLineNumber(int lineNumber) {\n    FlnReader ri = readers.peek();\n    if (ri == null) {\n      throw new Error(\"Past end of input\");\n    }\n    ri.setLineNumber(lineNumber);\n  }\n\n  /**\n   * Set the regular expressions for the start and stop of long\n   * entries (multiple lines that are read as a group by get_entry()).\n   * @param entry_start_re regular expression that starts a long entry\n   * @param entry_stop_re regular expression that ends a long entry\n   */\n  public void set_entry_start_stop(\n      /*@Regex(1)*/ String entry_start_re, /*@Regex*/ String entry_stop_re) {\n    this.entry_start_re = Pattern.compile(entry_start_re);\n    this.entry_stop_re = Pattern.compile(entry_stop_re);\n  }\n\n  /**\n   * Set the regular expressions for the start and stop of long\n   * entries (multiple lines that are read as a group by get_entry()).\n   * @param entry_start_re regular expression that starts a long entry\n   * @param entry_stop_re regular expression that ends a long entry\n   */\n  public void set_entry_start_stop(/*@Regex(1)*/ Pattern entry_start_re, Pattern entry_stop_re) {\n    this.entry_start_re = entry_start_re;\n    this.entry_stop_re = entry_stop_re;\n  }\n\n  /**\n   * Puts the specified line back in the input.  Only one line can be\n   * put back.\n   * @param line the line to be put back in the input\n   */\n  // TODO:  This would probably be better implemented with the \"mark\" mechanism\n  // of BufferedReader (which is also in LineNumberReader and FlnReader).\n  public void putback(String line) {\n    assert pushback_line == null\n        : \"push back '\" + line + \"' when '\" + pushback_line + \"' already back\";\n    pushback_line = line;\n  }\n\n  /** Mark the present position in the stream. */\n  @Override\n  public void mark(int readAheadLimit) {\n    throw new Error(\"not yet implemented\");\n  }\n  /** Read a single character. */\n  @Override\n  public int read() {\n    throw new Error(\"not yet implemented\");\n  }\n  /** Read characters into a portion of an array. */\n  @Override\n  public int read(char[] cbuf, int off, int len) {\n    throw new Error(\"not yet implemented\");\n  }\n  /** Reset the stream to the most recent mark. */\n  @Override\n  public void reset() {\n    throw new Error(\"not yet implemented\");\n  }\n  /** Skip characters. */\n  @Override\n  public long skip(long n) {\n    throw new Error(\"not yet implemented\");\n  }\n\n  /**\n   * Simple usage example.\n   * @param args command-line arguments: filename [comment_re [include_re]]\n   * @throws IOException if there is a problem reading a file\n   */\n  public static void main(String[] args) throws IOException {\n\n    if (args.length < 1 || args.length > 3) {\n      System.err.println(\n          \"EntryReader sample program requires 1-3 args: filename [comment_re [include_re]]\");\n      System.exit(1);\n    }\n    String filename = args[0];\n    String comment_re = null;\n    String include_re = null;\n    if (args.length >= 2) {\n      comment_re = args[1];\n      if (!RegexUtil.isRegex(comment_re)) {\n        System.err.println(\n            \"Error parsing comment regex \\\"\"\n                + comment_re\n                + \"\\\": \"\n                + RegexUtil.regexError(comment_re));\n        System.exit(1);\n      }\n    }\n    if (args.length >= 3) {\n      include_re = args[2];\n      if (!RegexUtil.isRegex(include_re, 1)) {\n        System.err.println(\n            \"Error parsing include regex \\\"\"\n                + include_re\n                + \"\\\": \"\n                + RegexUtil.regexError(include_re));\n        System.exit(1);\n      }\n    }\n    EntryReader reader = new EntryReader(filename, comment_re, include_re);\n\n    String line = reader.readLine();\n    while (line != null) {\n      System.out.printf(\"%s: %d: %s%n\", reader.getFileName(), reader.getLineNumber(), line);\n      line = reader.readLine();\n    }\n  }\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "in", "java.io", "InputStream" ], [ "filename", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "getFileName", "plume", "EntryReader", "public String getFileName()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "hasNext", "plume", "EntryReader", "public boolean hasNext()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "transferTo", "java.io", "Reader", "public long transferTo(Writer arg0) throws IOException" ], [ "get_entry", "plume", "EntryReader", "public Entry get_entry() throws IOException" ], [ "ready", "java.io", "BufferedReader", "public boolean ready() throws IOException" ], [ "skip", "plume", "EntryReader", "public long skip(long n)" ], [ "read", "plume", "EntryReader", "public int read(char[] cbuf, int off, int len)" ], [ "readLine", "java.io", "BufferedReader", "String readLine(boolean arg0, boolean[] arg1) throws IOException" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "next", "java.util", "Iterator", "public abstract E next()" ], [ "readLine", "plume", "EntryReader", "public String readLine() throws IOException" ], [ "read", "java.io", "Reader", "public int read(CharBuffer arg0) throws IOException" ], [ "getLineNumber", "plume", "EntryReader", "public int getLineNumber()" ], [ "iterator", "plume", "EntryReader", "public Iterator<String> iterator()" ], [ "read", "java.io", "Reader", "public int read(char[] arg0) throws IOException" ], [ "lines", "java.io", "BufferedReader", "public Stream<String> lines()" ], [ "markSupported", "java.io", "BufferedReader", "public boolean markSupported()" ], [ "next", "plume", "EntryReader", "public String next()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "read", "plume", "EntryReader", "public int read()" ], [ "read", "java.io", "InputStream", "public abstract int read() throws IOException" ], [ "transferTo", "java.io", "InputStream", "public long transferTo(OutputStream arg0) throws IOException" ], [ "available", "java.io", "InputStream", "public int available() throws IOException" ], [ "skip", "java.io", "InputStream", "public long skip(long arg0) throws IOException" ], [ "readNBytes", "java.io", "InputStream", "public byte[] readNBytes(int arg0) throws IOException" ], [ "readAllBytes", "java.io", "InputStream", "public byte[] readAllBytes() throws IOException" ], [ "markSupported", "java.io", "InputStream", "public boolean markSupported()" ], [ "read", "java.io", "InputStream", "public int read(byte[] arg0) throws IOException" ], [ "read", "java.io", "InputStream", "public int read(byte[] arg0, int arg1, int arg2) throws IOException" ], [ "readNBytes", "java.io", "InputStream", "public int readNBytes(byte[] arg0, int arg1, int arg2) throws IOException" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "length", "java.lang", "String", "public int length()" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "entry_start_re", "plume", "EntryReader", "public Pattern entry_start_re = null;" ], [ "entry_stop_re", "plume", "EntryReader", "public Pattern entry_stop_re = null;" ], [ "pushback_line", "plume", "EntryReader", "String pushback_line = null;" ], [ "lock", "java.io", "Reader", "protected Object lock;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 11006,
  "oracle" : ";",
  "oracleType" : "PRE",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "EntryReader",
  "javadocTag" : "@param reader source from which to read entries",
  "methodJavadoc" : "    /** Create a EntryReader that does not support comments or include directives.\n   * @param reader source from which to read entries\n   * @see #EntryReader(Reader,String,String,String)\n   */",
  "methodSourceCode" : "public EntryReader(Reader reader){\n    this(reader, reader.toString(), null, null);\n}",
  "classJavadoc" : "/**\n * Class that reads \"entries\" from a file.  In the simplest case, entries\n * can be lines.  It supports:\n *   include files,\n *   comments, and\n *   multi-line entries (paragraphs).\n * The syntax of each of these is customizable.\n * <p>\n *\n * Example use:\n * <pre>\n *  // args are filename, comment regexp, include regexp\n *  try (EntryReader er = new EntryReader(filename, \"^#.*\", null)) {\n *    for (String line : er) {\n *      ...\n *    }\n *  } catch (IOException e) {\n *    System.err.println(\"Problem reading \" + filename + \": \" + e.getMessage());\n *    System.exit(2);\n *    throw new Error(\"This can't happen\"); // for definite assignment check\n *  }\n * </pre>\n *\n * @see #get_entry() and @see #set_entry_start_stop(String,String)\n */",
  "classSourceCode" : "package plume;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.io.Reader;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.CharBuffer;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.Stack;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/*>>>\nimport org.checkerframework.checker.lock.qual.*;\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.checker.regex.qual.*;\n*/\n\n// TODO:\n// EntryReader has a public concept of \"short entry\", but I don't think that\n// concept is logically part of EntryReader.  I think it would be better for\n// Lookup to make this decision itself, for instance by checking whether there\n// are any line separators in the entry that it gets back.\n//\n// Here are some useful features that EntryReader should have.\n//  * It should implement some unimplemented methods from LineNumberReader (see\n//    \"not yet implemented\" in this file).\n//  * It should have constructors that take an InputStream or Reader\n//    (in addition to the current BufferedReader, File, and String versions).\n//  * It should have a close method.\n//  * It should automatically close the underlying file/etc. when the\n//    iterator gets to the end (or the end is otherwise reached).\n\n/**\n * Class that reads \"entries\" from a file.  In the simplest case, entries\n * can be lines.  It supports:\n *   include files,\n *   comments, and\n *   multi-line entries (paragraphs).\n * The syntax of each of these is customizable.\n * <p>\n *\n * Example use:\n * <pre>\n *  // args are filename, comment regexp, include regexp\n *  try (EntryReader er = new EntryReader(filename, \"^#.*\", null)) {\n *    for (String line : er) {\n *      ...\n *    }\n *  } catch (IOException e) {\n *    System.err.println(\"Problem reading \" + filename + \": \" + e.getMessage());\n *    System.exit(2);\n *    throw new Error(\"This can't happen\"); // for definite assignment check\n *  }\n * </pre>\n *\n * @see #get_entry() and @see #set_entry_start_stop(String,String)\n */\npublic class EntryReader extends LineNumberReader implements Iterable<String>, Iterator<String> {\n\n  ///\n  /// User configuration variables\n  ///\n\n  /** Regular expression that specifies an include file. */\n  private final /*@Nullable*/ /*@Regex(1)*/ Pattern include_re;\n\n  /** Regular expression that matches a comment. */\n  private final /*@Nullable*/ Pattern comment_re;\n\n  /**\n   * Regular expression that starts a long entry.\n   * <p>\n   * If the first line of an entry matches this regexp, then the entry is\n   * terminated by:  entry_stop_re, another line that matches\n   * entry_start_re (even not following a newline), or the end of the\n   * current file.\n   * <p>\n   * Otherwise, the first line of an entry does NOT match this regexp (or\n   * the regexp is null), in which case the entry is terminated by a blank\n   * line or the end of the current file.\n   */\n  public /*@MonotonicNonNull*/ /*@Regex(1)*/ Pattern entry_start_re = null;\n\n  /**\n   * @see #entry_start_re\n   */\n  public /*@MonotonicNonNull*/ Pattern entry_stop_re = null;\n\n  ///\n  /// Internal implementation variables\n  ///\n\n  /** Stack of readers.  Used to support include files. */\n  private final Stack<FlnReader> readers = new Stack<FlnReader>();\n\n  /** Line that is pushed back to be reread. */\n  /*@Nullable*/ String pushback_line = null;\n\n  /** Platform-specific line separator. */\n  private static final String lineSep = System.getProperty(\"line.separator\");\n\n  ///\n  /// Helper classes\n  ///\n\n  /**\n   * Like LineNumberReader, but also has a filename field.\n   * \"FlnReader\" stands for \"Filename and Line Number Reader\".\n   */\n  private static class FlnReader extends LineNumberReader {\n    /** The file being read. */\n    public String filename;\n\n    /**\n     * Create a FlnReader.\n     * @param reader source from which to read entries\n     * @param filename file name corresponding to reader, for use in error messages.\n     *   Must be non-null; if there isn't a name, clients should provide a dummy value.\n     */\n    public FlnReader(Reader reader, String filename) {\n      super(reader);\n      this.filename = filename;\n    }\n\n    /**\n     * Create a FlnReader.\n     * @param filename file from which to read\n     */\n    public FlnReader(String filename) throws IOException {\n      super(UtilMDE.fileReader(filename));\n      this.filename = filename;\n    }\n  }\n\n  /** Descriptor for an entry (paragraph). */\n  public static class Entry {\n    /** First line of the entry. */\n    public String first_line;\n    /** Complete body of the entry including the first line. */\n    public String body;\n    /** True if this is a short entry (blank-line-separated). */\n    boolean short_entry;\n    /** Filename in which the entry was found. */\n    String filename;\n    /** Line number of first line of entry. */\n    long line_number;\n\n    /** Create an entry.\n     * @param first_line first line of the entry\n     * @param body complete body of the entry including the first line\n     * @param short_entry true if this is a short entry (blank-line-separated)\n     * @param filename filename in which the entry was found\n     * @param line_number line number of first line of entry\n     */\n    Entry(String first_line, String body, String filename, long line_number, boolean short_entry) {\n      this.first_line = first_line;\n      this.body = body;\n      this.filename = filename;\n      this.line_number = line_number;\n      this.short_entry = short_entry;\n    }\n\n    /**\n     * Return a substring of the entry body that matches the specified\n     * regular expression.  If no match is found, returns the first_line.\n     * @param re regex to match\n     * @return a substring that matches re\n     */\n    String get_description(/*@Nullable*/ Pattern re) {\n\n      if (re == null) {\n        return first_line;\n      }\n\n      Matcher descr = re.matcher(body);\n      if (descr.find()) {\n        return descr.group();\n      } else {\n        return first_line;\n      }\n    }\n  }\n\n  ///\n  /// Constructors\n  ///\n\n  /// Inputstream and charset constructors\n\n  /** Create a EntryReader that uses the given character set.\n   * @throws UnsupportedEncodingException if the charset encoding is not supported\n   * @param in source from which to read entries\n   * @param charsetName the character set to use\n   * @param filename non-null file name for stream being read\n   * @param comment_re_string regular expression that matches comments.\n   *                      Any text that matches comment_re is removed.\n   *                      A line that is entirely a comment is ignored.\n   * @param include_re_string regular expression that matches include directives.\n   *                      The expression should define one group that contains\n   *                      the include file name.\n   * @see #EntryReader(InputStream,String,String,String)\n   */\n  public EntryReader(\n      InputStream in,\n      String charsetName,\n      String filename,\n      /*@Nullable*/ /*@Regex*/ String comment_re_string,\n      /*@Nullable*/ /*@Regex(1)*/ String include_re_string)\n      throws UnsupportedEncodingException {\n    this(new InputStreamReader(in, charsetName), filename, comment_re_string, include_re_string);\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param in the InputStream\n   * @param charsetName the character set to use\n   * @param filename the file name\n   * @throws UnsupportedEncodingException if the charset encoding is not supported\n   * @see #EntryReader(InputStream,String,String,String)\n   */\n  public EntryReader(InputStream in, String charsetName, String filename)\n      throws UnsupportedEncodingException {\n    this(in, charsetName, filename, null, null);\n  }\n\n  /// Inputstream (no charset) constructors\n\n  /**\n   * Create a EntryReader.\n   *\n   *    @param in source from which to read entries\n   *    @param filename non-null file name for stream being read\n   *    @param comment_re_string regular expression that matches comments.\n   *                      Any text that matches comment_re is removed.\n   *                      A line that is entirely a comment is ignored.\n   *    @param include_re_string regular expression that matches include directives.\n   *                      The expression should define one group that contains\n   *                      the include file name.\n   */\n  public EntryReader(\n      InputStream in,\n      String filename,\n      /*@Nullable*/ /*@Regex*/ String comment_re_string,\n      /*@Nullable*/ /*@Regex(1)*/ String include_re_string) {\n    this(new InputStreamReader(in), filename, comment_re_string, include_re_string);\n  }\n\n  /**\n   * Create a EntryReader that uses the default character set and does not\n   * support comments or include directives.\n   * @param in the InputStream\n   * @param filename the file name\n   * @see #EntryReader(InputStream,String,String,String,String)\n   */\n  public EntryReader(InputStream in, String filename) {\n    this(in, filename, null, null);\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param in the InputStream\n   * @see #EntryReader(InputStream,String,String,String)\n   */\n  public EntryReader(InputStream in) {\n    this(in, \"(InputStream)\", null, null);\n  }\n\n  /** A dummy Reader to be used when null is not acceptable. */\n  private static class DummyReader extends Reader {\n    @Override\n    public void close(/*>>>@GuardSatisfied DummyReader this*/) {\n      // No error, because closing is OK if it appears in try-with-resources.\n      // Later maybe create two versions (with and without exception here).\n    }\n\n    @Override\n    public void mark(int readAheadLimit) {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public boolean markSupported() {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public int read() {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public int read(char[] cbuf) {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public int read(char[] cbuf, int off, int len) {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public int read(CharBuffer target) {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public boolean ready() {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public void reset() {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public long skip(long n) {\n      throw new Error(\"DummyReader\");\n    }\n  }\n\n  /**\n   * Create a EntryReader.\n   *\n   *    @param reader source from which to read entries\n   *    @param filename file name corresponding to reader, for use in error messages\n   *    @param comment_re_string regular expression that matches comments.\n   *                      Any text that matches comment_re is removed.\n   *                      A line that is entirely a comment is ignored\n   *    @param include_re_string regular expression that matches include directives.\n   *                      The expression should define one group that contains\n   *                      the include file name\n   */\n  public EntryReader(\n      Reader reader,\n      String filename,\n      /*@Nullable*/ /*@Regex*/ String comment_re_string,\n      /*@Nullable*/ /*@Regex(1)*/ String include_re_string) {\n    // we won't use superclass methods, but passing null as an argument\n    // leads to a NullPointerException.\n    super(new DummyReader());\n    readers.push(new FlnReader(reader, filename));\n    if (comment_re_string == null) {\n      comment_re = null;\n    } else {\n      comment_re = Pattern.compile(comment_re_string);\n    }\n    if (include_re_string == null) {\n      include_re = null;\n    } else {\n      include_re = Pattern.compile(include_re_string);\n    }\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param reader source from which to read entries\n   * @see #EntryReader(Reader,String,String,String)\n   */\n  public EntryReader(Reader reader) {\n    this(reader, reader.toString(), null, null);\n  }\n\n  /// File Constructors\n\n  /**\n   * Create an EntryReader.\n   *\n   *    @param file       initial file to read\n   *    @param comment_re regular expression that matches comments.\n   *                      Any text that matches comment_re is removed.\n   *                      A line that is entirely a comment is ignored.\n   *    @param include_re regular expression that matches include directives.\n   *                      The expression should define one group that contains\n   *                      the include file name.\n   * @throws IOException if there is a problem reading the file\n   */\n  public EntryReader(\n      File file,\n      /*@Nullable*/ /*@Regex*/ String comment_re,\n      /*@Nullable*/ /*@Regex(1)*/ String include_re)\n      throws IOException {\n    this(UtilMDE.fileReader(file), file.toString(), comment_re, include_re);\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param file the file to read\n   * @throws IOException if there is a problem reading the file\n   * @see #EntryReader(File,String,String)\n   */\n  public EntryReader(File file) throws IOException {\n    this(file, null, null);\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param file the file to read\n   * @param charsetName the character set to use\n   * @throws IOException if there is a problem reading the file\n   * @see #EntryReader(File,String,String)\n   */\n  public EntryReader(File file, String charsetName) throws IOException {\n    this(UtilMDE.fileInputStream(file), charsetName, file.toString(), null, null);\n  }\n\n  /// Filename constructors\n\n  /**\n   * Create a new EntryReader starting with the specified file.\n   *\n   *    @param filename   initial file to read\n   *    @param comment_re regular expression that matches comments.\n   *                      Any text that matches comment_re is removed.\n   *                      A line that is entirely a comment is ignored.\n   *    @param include_re regular expression that matches include directives.\n   *                      The expression should define one group that contains\n   *                      the include file name.\n   *\n   * @throws IOException if there is a problem reading the file\n   *\n   * @see #EntryReader(File,String,String)\n   */\n  public EntryReader(\n      String filename,\n      /*@Nullable*/ /*@Regex*/ String comment_re,\n      /*@Nullable*/ /*@Regex(1)*/ String include_re)\n      throws IOException {\n    this(new File(filename), comment_re, include_re);\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param filename source from which to read entries\n   * @throws IOException if there is a problem reading the file\n   * @see #EntryReader(String,String,String)\n   */\n  public EntryReader(String filename) throws IOException {\n    this(filename, null, null);\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param filename source from which to read entries\n   * @param charsetName the character set to use\n   * @throws IOException if there is a problem reading the file\n   * @see #EntryReader(String,String,String)\n   */\n  public EntryReader(String filename, String charsetName) throws IOException {\n    this(new FileInputStream(filename), charsetName, filename, null, null);\n  }\n\n  ///\n  /// Methods\n  ///\n\n  /**\n   * Read a line, ignoring comments and processing includes.  Note that\n   * a line that is completely a comment is completely ignored (and\n   * not returned as a blank line).  Returns null at end of file.\n   * @return the string that was read, or null at end of file\n   */\n  @Override\n  public /*@Nullable*/ String readLine() throws IOException {\n\n    // System.out.printf (\"Entering size = %d%n\", readers.size());\n\n    // If a line has been pushed back, return it instead\n    if (pushback_line != null) {\n      String line = pushback_line;\n      pushback_line = null;\n      return line;\n    }\n\n    String line = get_next_line();\n    if (comment_re != null) {\n      while (line != null) {\n        Matcher cmatch = comment_re.matcher(line);\n        if (cmatch.find()) {\n          line = cmatch.replaceFirst(\"\");\n          if (line.length() > 0) {\n            break;\n          }\n        } else {\n          break;\n        }\n        line = get_next_line();\n        // System.out.printf (\"get_next_line = %s%n\", line);\n      }\n    }\n\n    if (line == null) {\n      return null;\n    }\n\n    // Handle include files.  Non-absolute pathnames are relative\n    // to the including file (the current file)\n    if (include_re != null) {\n      Matcher m = include_re.matcher(line);\n      if (m.matches()) {\n        String filename_string = m.group(1);\n        if (filename_string == null) {\n          throw new Error(\n              String.format(\"include_re (%s) does not capture group 1 in %s\", include_re, line));\n        }\n        File filename = new File(UtilMDE.expandFilename(filename_string));\n        // System.out.printf (\"Trying to include filename %s%n\", filename);\n        if (!filename.isAbsolute()) {\n          FlnReader reader = readers.peek();\n          File current_filename = new File(reader.filename);\n          File current_parent = current_filename.getParentFile();\n          filename = new File(current_parent, filename.toString());\n          // System.out.printf (\"absolute filename = %s %s %s%n\",\n          //                     current_filename, current_parent, filename);\n        }\n        readers.push(new FlnReader(filename.getAbsolutePath()));\n        return readLine();\n      }\n    }\n\n    // System.out.printf (\"Returning [%d] '%s'%n\", readers.size(), line);\n    return (line);\n  }\n\n  /**\n   * Return a line-by-line iterator for this file.\n   * <p>\n   *\n   * <b>Warning:</b> This does not return a fresh iterator each time.  The\n   * iterator is a singleton, the same one is returned each time, and a new\n   * one can never be created after it is exhausted.\n   *\n   * @return a line-by-line iterator for this file\n   */\n  @Override\n  public Iterator<String> iterator() {\n    return this;\n  }\n\n  /**\n   * Returns whether or not there is another line to read.  Any IOExceptions\n   * are turned into errors (because the definition of hasNext() in Iterator\n   * doesn't throw any exceptions).\n   * @return whether there is another line to read\n   */\n  @Override\n  public boolean hasNext() {\n    if (pushback_line != null) {\n      return true;\n    }\n\n    String line = null;\n    try {\n      line = readLine();\n    } catch (IOException e) {\n      throw new Error(\"unexpected IOException: \", e);\n    }\n\n    if (line == null) {\n      return false;\n    }\n\n    putback(line);\n    return true;\n  }\n\n  /**\n   * Return the next line in the multi-file.\n   * @return the next line in the multi-file\n   * Throws NoSuchElementException at end of file\n   */\n  @Override\n  public String next() {\n    try {\n      String result = readLine();\n      if (result != null) {\n        return result;\n      } else {\n        throw new NoSuchElementException();\n      }\n    } catch (IOException e) {\n      throw new Error(\"unexpected IOException\", e);\n    }\n  }\n\n  /** remove() is not supported. */\n  @Override\n  public void remove() {\n    throw new UnsupportedOperationException(\"can't remove lines from file\");\n  }\n\n  /**\n   * Returns the next entry (paragraph) in the file.  Entries are separated\n   * by blank lines unless the entry started with {@link #entry_start_re}\n   * (see {@link #set_entry_start_stop}).  If no more entries are\n   * available, returns null.\n   * @return the next entry (paragraph) in the file\n   * @throws IOException if there is a problem reading the file\n   */\n  public /*@Nullable*/ Entry get_entry() throws IOException {\n\n    // Skip any preceding blank lines\n    String line = readLine();\n    while ((line != null) && (line.trim().length() == 0)) {\n      line = readLine();\n    }\n    if (line == null) {\n      return (null);\n    }\n\n    StringBuilder body = new StringBuilder(10000);\n    Entry entry = null;\n    String filename = getFileName();\n    long line_number = getLineNumber();\n\n    // If first line matches entry_start_re, this is a long entry.\n    /*@Regex(1)*/ Matcher entry_match = null;\n    if (entry_start_re != null) {\n      entry_match = entry_start_re.matcher(line);\n    }\n    if ((entry_match != null) && entry_match.find()) {\n      assert entry_start_re != null : \"@AssumeAssertion(nullness): dependent: entry_match != null\";\n      assert entry_stop_re != null\n          : \"@AssumeAssertion(nullness): dependent: entry_start_re != null\";\n\n      // Remove entry match from the line\n      if (entry_match.groupCount() > 0) {\n        @SuppressWarnings(\n            \"nullness\") // dependent: just checked that group 1 exists via groupCount(); https://code.google.com/p/checker-framework/issues/detail?id=291\n        /*@NonNull*/ String match_group_1 = entry_match.group(1);\n        line = entry_match.replaceFirst(match_group_1);\n      }\n\n      // Description is the first line\n      String description = line;\n\n      // Read until we find the termination of the entry\n      Matcher end_entry_match = entry_stop_re.matcher(line);\n      while ((line != null)\n          && !entry_match.find()\n          && !end_entry_match.find()\n          && filename.equals(getFileName())) {\n        body.append(line);\n        body.append(lineSep);\n        line = readLine();\n        if (line == null) {\n          break; // end of file serves as entry terminator\n        }\n        entry_match = entry_start_re.matcher(line);\n        end_entry_match = entry_stop_re.matcher(line);\n      }\n\n      // If this entry was terminated by the start of the next one,\n      // put that line back\n      if ((line != null) && (entry_match.find(0) || !filename.equals(getFileName()))) {\n        putback(line);\n      }\n\n      entry = new Entry(description, body.toString(), filename, line_number, false);\n\n    } else { // blank-separated entry\n\n      String description = line;\n\n      // Read until we find another blank line\n      while ((line != null) && (line.trim().length() != 0) && filename.equals(getFileName())) {\n        body.append(line);\n        body.append(lineSep);\n        line = readLine();\n      }\n\n      // If this entry was terminated by the start of a new input file\n      // put that line back\n      if ((line != null) && !filename.equals(getFileName())) {\n        putback(line);\n      }\n\n      entry = new Entry(description, body.toString(), filename, line_number, true);\n    }\n\n    return (entry);\n  }\n\n  /**\n   * Reads the next line from the current reader.  If EOF is encountered\n   * pop out to the next reader.  Returns null if there is no more input.\n   * @return next line from the reader, or null if there is no more input\n   */\n  private /*@Nullable*/ String get_next_line() throws IOException {\n\n    if (readers.size() == 0) {\n      return (null);\n    }\n\n    FlnReader ri1 = readers.peek();\n    String line = ri1.readLine();\n    while (line == null) {\n      readers.pop();\n      if (readers.empty()) {\n        return (null);\n      }\n      FlnReader ri2 = readers.peek();\n      line = ri2.readLine();\n    }\n    return (line);\n  }\n\n  /**\n   * Returns the current filename.\n   * @return the current filename\n   */\n  public String getFileName() {\n    FlnReader ri = readers.peek();\n    if (ri == null) {\n      throw new Error(\"Past end of input\");\n    }\n    return ri.filename;\n  }\n\n  /**\n   * Return the current line number in the current file.\n   * @return the current line number\n   */\n  @Override\n  public int getLineNumber() {\n    FlnReader ri = readers.peek();\n    if (ri == null) {\n      throw new Error(\"Past end of input\");\n    }\n    return ri.getLineNumber();\n  }\n\n  /** Set the current line number in the current file.\n   * @param lineNumber new line number for the current file\n   */\n  @Override\n  public void setLineNumber(int lineNumber) {\n    FlnReader ri = readers.peek();\n    if (ri == null) {\n      throw new Error(\"Past end of input\");\n    }\n    ri.setLineNumber(lineNumber);\n  }\n\n  /**\n   * Set the regular expressions for the start and stop of long\n   * entries (multiple lines that are read as a group by get_entry()).\n   * @param entry_start_re regular expression that starts a long entry\n   * @param entry_stop_re regular expression that ends a long entry\n   */\n  public void set_entry_start_stop(\n      /*@Regex(1)*/ String entry_start_re, /*@Regex*/ String entry_stop_re) {\n    this.entry_start_re = Pattern.compile(entry_start_re);\n    this.entry_stop_re = Pattern.compile(entry_stop_re);\n  }\n\n  /**\n   * Set the regular expressions for the start and stop of long\n   * entries (multiple lines that are read as a group by get_entry()).\n   * @param entry_start_re regular expression that starts a long entry\n   * @param entry_stop_re regular expression that ends a long entry\n   */\n  public void set_entry_start_stop(/*@Regex(1)*/ Pattern entry_start_re, Pattern entry_stop_re) {\n    this.entry_start_re = entry_start_re;\n    this.entry_stop_re = entry_stop_re;\n  }\n\n  /**\n   * Puts the specified line back in the input.  Only one line can be\n   * put back.\n   * @param line the line to be put back in the input\n   */\n  // TODO:  This would probably be better implemented with the \"mark\" mechanism\n  // of BufferedReader (which is also in LineNumberReader and FlnReader).\n  public void putback(String line) {\n    assert pushback_line == null\n        : \"push back '\" + line + \"' when '\" + pushback_line + \"' already back\";\n    pushback_line = line;\n  }\n\n  /** Mark the present position in the stream. */\n  @Override\n  public void mark(int readAheadLimit) {\n    throw new Error(\"not yet implemented\");\n  }\n  /** Read a single character. */\n  @Override\n  public int read() {\n    throw new Error(\"not yet implemented\");\n  }\n  /** Read characters into a portion of an array. */\n  @Override\n  public int read(char[] cbuf, int off, int len) {\n    throw new Error(\"not yet implemented\");\n  }\n  /** Reset the stream to the most recent mark. */\n  @Override\n  public void reset() {\n    throw new Error(\"not yet implemented\");\n  }\n  /** Skip characters. */\n  @Override\n  public long skip(long n) {\n    throw new Error(\"not yet implemented\");\n  }\n\n  /**\n   * Simple usage example.\n   * @param args command-line arguments: filename [comment_re [include_re]]\n   * @throws IOException if there is a problem reading a file\n   */\n  public static void main(String[] args) throws IOException {\n\n    if (args.length < 1 || args.length > 3) {\n      System.err.println(\n          \"EntryReader sample program requires 1-3 args: filename [comment_re [include_re]]\");\n      System.exit(1);\n    }\n    String filename = args[0];\n    String comment_re = null;\n    String include_re = null;\n    if (args.length >= 2) {\n      comment_re = args[1];\n      if (!RegexUtil.isRegex(comment_re)) {\n        System.err.println(\n            \"Error parsing comment regex \\\"\"\n                + comment_re\n                + \"\\\": \"\n                + RegexUtil.regexError(comment_re));\n        System.exit(1);\n      }\n    }\n    if (args.length >= 3) {\n      include_re = args[2];\n      if (!RegexUtil.isRegex(include_re, 1)) {\n        System.err.println(\n            \"Error parsing include regex \\\"\"\n                + include_re\n                + \"\\\": \"\n                + RegexUtil.regexError(include_re));\n        System.exit(1);\n      }\n    }\n    EntryReader reader = new EntryReader(filename, comment_re, include_re);\n\n    String line = reader.readLine();\n    while (line != null) {\n      System.out.printf(\"%s: %d: %s%n\", reader.getFileName(), reader.getLineNumber(), line);\n      line = reader.readLine();\n    }\n  }\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "reader", "java.io", "Reader" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "readLine", "plume", "EntryReader", "public String readLine() throws IOException" ], [ "lines", "java.io", "BufferedReader", "public Stream<String> lines()" ], [ "readLine", "java.io", "BufferedReader", "String readLine(boolean arg0, boolean[] arg1) throws IOException" ], [ "getLineNumber", "plume", "EntryReader", "public int getLineNumber()" ], [ "read", "plume", "EntryReader", "public int read(char[] cbuf, int off, int len)" ], [ "read", "java.io", "Reader", "public int read(CharBuffer arg0) throws IOException" ], [ "hasNext", "plume", "EntryReader", "public boolean hasNext()" ], [ "read", "plume", "EntryReader", "public int read()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "skip", "plume", "EntryReader", "public long skip(long n)" ], [ "ready", "java.io", "BufferedReader", "public boolean ready() throws IOException" ], [ "next", "java.util", "Iterator", "public abstract E next()" ], [ "iterator", "plume", "EntryReader", "public Iterator<String> iterator()" ], [ "transferTo", "java.io", "Reader", "public long transferTo(Writer arg0) throws IOException" ], [ "read", "java.io", "Reader", "public int read(char[] arg0) throws IOException" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "markSupported", "java.io", "BufferedReader", "public boolean markSupported()" ], [ "next", "plume", "EntryReader", "public String next()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "getFileName", "plume", "EntryReader", "public String getFileName()" ], [ "get_entry", "plume", "EntryReader", "public Entry get_entry() throws IOException" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "ready", "java.io", "Reader", "public boolean ready() throws IOException" ], [ "skip", "java.io", "Reader", "public long skip(long arg0) throws IOException" ], [ "read", "java.io", "Reader", "public int read() throws IOException" ], [ "read", "java.io", "Reader", "public abstract int read(char[] arg0, int arg1, int arg2) throws IOException" ], [ "markSupported", "java.io", "Reader", "public boolean markSupported()" ], [ "read", "java.lang", "Readable", "public abstract int read(CharBuffer arg0) throws IOException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "entry_start_re", "plume", "EntryReader", "public Pattern entry_start_re = null;" ], [ "entry_stop_re", "plume", "EntryReader", "public Pattern entry_stop_re = null;" ], [ "pushback_line", "plume", "EntryReader", "String pushback_line = null;" ], [ "lock", "java.io", "Reader", "protected Object lock;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 11010,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "EntryReader",
  "javadocTag" : "@throws IOException if there is a problem reading the file",
  "methodJavadoc" : "    /**\n   * Create an EntryReader.\n   *\n   *    @param file       initial file to read\n   *    @param comment_re regular expression that matches comments.\n   *                      Any text that matches comment_re is removed.\n   *                      A line that is entirely a comment is ignored.\n   *    @param include_re regular expression that matches include directives.\n   *                      The expression should define one group that contains\n   *                      the include file name.\n   * @throws IOException if there is a problem reading the file\n   */",
  "methodSourceCode" : "public EntryReader(File file, /*@Nullable*/\n/*@Regex*/\nString comment_re, /*@Nullable*/\n/*@Regex(1)*/\nString include_re) throws IOException{\n    this(UtilMDE.fileReader(file), file.toString(), comment_re, include_re);\n}",
  "classJavadoc" : "/**\n * Class that reads \"entries\" from a file.  In the simplest case, entries\n * can be lines.  It supports:\n *   include files,\n *   comments, and\n *   multi-line entries (paragraphs).\n * The syntax of each of these is customizable.\n * <p>\n *\n * Example use:\n * <pre>\n *  // args are filename, comment regexp, include regexp\n *  try (EntryReader er = new EntryReader(filename, \"^#.*\", null)) {\n *    for (String line : er) {\n *      ...\n *    }\n *  } catch (IOException e) {\n *    System.err.println(\"Problem reading \" + filename + \": \" + e.getMessage());\n *    System.exit(2);\n *    throw new Error(\"This can't happen\"); // for definite assignment check\n *  }\n * </pre>\n *\n * @see #get_entry() and @see #set_entry_start_stop(String,String)\n */",
  "classSourceCode" : "package plume;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.io.Reader;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.CharBuffer;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.Stack;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/*>>>\nimport org.checkerframework.checker.lock.qual.*;\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.checker.regex.qual.*;\n*/\n\n// TODO:\n// EntryReader has a public concept of \"short entry\", but I don't think that\n// concept is logically part of EntryReader.  I think it would be better for\n// Lookup to make this decision itself, for instance by checking whether there\n// are any line separators in the entry that it gets back.\n//\n// Here are some useful features that EntryReader should have.\n//  * It should implement some unimplemented methods from LineNumberReader (see\n//    \"not yet implemented\" in this file).\n//  * It should have constructors that take an InputStream or Reader\n//    (in addition to the current BufferedReader, File, and String versions).\n//  * It should have a close method.\n//  * It should automatically close the underlying file/etc. when the\n//    iterator gets to the end (or the end is otherwise reached).\n\n/**\n * Class that reads \"entries\" from a file.  In the simplest case, entries\n * can be lines.  It supports:\n *   include files,\n *   comments, and\n *   multi-line entries (paragraphs).\n * The syntax of each of these is customizable.\n * <p>\n *\n * Example use:\n * <pre>\n *  // args are filename, comment regexp, include regexp\n *  try (EntryReader er = new EntryReader(filename, \"^#.*\", null)) {\n *    for (String line : er) {\n *      ...\n *    }\n *  } catch (IOException e) {\n *    System.err.println(\"Problem reading \" + filename + \": \" + e.getMessage());\n *    System.exit(2);\n *    throw new Error(\"This can't happen\"); // for definite assignment check\n *  }\n * </pre>\n *\n * @see #get_entry() and @see #set_entry_start_stop(String,String)\n */\npublic class EntryReader extends LineNumberReader implements Iterable<String>, Iterator<String> {\n\n  ///\n  /// User configuration variables\n  ///\n\n  /** Regular expression that specifies an include file. */\n  private final /*@Nullable*/ /*@Regex(1)*/ Pattern include_re;\n\n  /** Regular expression that matches a comment. */\n  private final /*@Nullable*/ Pattern comment_re;\n\n  /**\n   * Regular expression that starts a long entry.\n   * <p>\n   * If the first line of an entry matches this regexp, then the entry is\n   * terminated by:  entry_stop_re, another line that matches\n   * entry_start_re (even not following a newline), or the end of the\n   * current file.\n   * <p>\n   * Otherwise, the first line of an entry does NOT match this regexp (or\n   * the regexp is null), in which case the entry is terminated by a blank\n   * line or the end of the current file.\n   */\n  public /*@MonotonicNonNull*/ /*@Regex(1)*/ Pattern entry_start_re = null;\n\n  /**\n   * @see #entry_start_re\n   */\n  public /*@MonotonicNonNull*/ Pattern entry_stop_re = null;\n\n  ///\n  /// Internal implementation variables\n  ///\n\n  /** Stack of readers.  Used to support include files. */\n  private final Stack<FlnReader> readers = new Stack<FlnReader>();\n\n  /** Line that is pushed back to be reread. */\n  /*@Nullable*/ String pushback_line = null;\n\n  /** Platform-specific line separator. */\n  private static final String lineSep = System.getProperty(\"line.separator\");\n\n  ///\n  /// Helper classes\n  ///\n\n  /**\n   * Like LineNumberReader, but also has a filename field.\n   * \"FlnReader\" stands for \"Filename and Line Number Reader\".\n   */\n  private static class FlnReader extends LineNumberReader {\n    /** The file being read. */\n    public String filename;\n\n    /**\n     * Create a FlnReader.\n     * @param reader source from which to read entries\n     * @param filename file name corresponding to reader, for use in error messages.\n     *   Must be non-null; if there isn't a name, clients should provide a dummy value.\n     */\n    public FlnReader(Reader reader, String filename) {\n      super(reader);\n      this.filename = filename;\n    }\n\n    /**\n     * Create a FlnReader.\n     * @param filename file from which to read\n     */\n    public FlnReader(String filename) throws IOException {\n      super(UtilMDE.fileReader(filename));\n      this.filename = filename;\n    }\n  }\n\n  /** Descriptor for an entry (paragraph). */\n  public static class Entry {\n    /** First line of the entry. */\n    public String first_line;\n    /** Complete body of the entry including the first line. */\n    public String body;\n    /** True if this is a short entry (blank-line-separated). */\n    boolean short_entry;\n    /** Filename in which the entry was found. */\n    String filename;\n    /** Line number of first line of entry. */\n    long line_number;\n\n    /** Create an entry.\n     * @param first_line first line of the entry\n     * @param body complete body of the entry including the first line\n     * @param short_entry true if this is a short entry (blank-line-separated)\n     * @param filename filename in which the entry was found\n     * @param line_number line number of first line of entry\n     */\n    Entry(String first_line, String body, String filename, long line_number, boolean short_entry) {\n      this.first_line = first_line;\n      this.body = body;\n      this.filename = filename;\n      this.line_number = line_number;\n      this.short_entry = short_entry;\n    }\n\n    /**\n     * Return a substring of the entry body that matches the specified\n     * regular expression.  If no match is found, returns the first_line.\n     * @param re regex to match\n     * @return a substring that matches re\n     */\n    String get_description(/*@Nullable*/ Pattern re) {\n\n      if (re == null) {\n        return first_line;\n      }\n\n      Matcher descr = re.matcher(body);\n      if (descr.find()) {\n        return descr.group();\n      } else {\n        return first_line;\n      }\n    }\n  }\n\n  ///\n  /// Constructors\n  ///\n\n  /// Inputstream and charset constructors\n\n  /** Create a EntryReader that uses the given character set.\n   * @throws UnsupportedEncodingException if the charset encoding is not supported\n   * @param in source from which to read entries\n   * @param charsetName the character set to use\n   * @param filename non-null file name for stream being read\n   * @param comment_re_string regular expression that matches comments.\n   *                      Any text that matches comment_re is removed.\n   *                      A line that is entirely a comment is ignored.\n   * @param include_re_string regular expression that matches include directives.\n   *                      The expression should define one group that contains\n   *                      the include file name.\n   * @see #EntryReader(InputStream,String,String,String)\n   */\n  public EntryReader(\n      InputStream in,\n      String charsetName,\n      String filename,\n      /*@Nullable*/ /*@Regex*/ String comment_re_string,\n      /*@Nullable*/ /*@Regex(1)*/ String include_re_string)\n      throws UnsupportedEncodingException {\n    this(new InputStreamReader(in, charsetName), filename, comment_re_string, include_re_string);\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param in the InputStream\n   * @param charsetName the character set to use\n   * @param filename the file name\n   * @throws UnsupportedEncodingException if the charset encoding is not supported\n   * @see #EntryReader(InputStream,String,String,String)\n   */\n  public EntryReader(InputStream in, String charsetName, String filename)\n      throws UnsupportedEncodingException {\n    this(in, charsetName, filename, null, null);\n  }\n\n  /// Inputstream (no charset) constructors\n\n  /**\n   * Create a EntryReader.\n   *\n   *    @param in source from which to read entries\n   *    @param filename non-null file name for stream being read\n   *    @param comment_re_string regular expression that matches comments.\n   *                      Any text that matches comment_re is removed.\n   *                      A line that is entirely a comment is ignored.\n   *    @param include_re_string regular expression that matches include directives.\n   *                      The expression should define one group that contains\n   *                      the include file name.\n   */\n  public EntryReader(\n      InputStream in,\n      String filename,\n      /*@Nullable*/ /*@Regex*/ String comment_re_string,\n      /*@Nullable*/ /*@Regex(1)*/ String include_re_string) {\n    this(new InputStreamReader(in), filename, comment_re_string, include_re_string);\n  }\n\n  /**\n   * Create a EntryReader that uses the default character set and does not\n   * support comments or include directives.\n   * @param in the InputStream\n   * @param filename the file name\n   * @see #EntryReader(InputStream,String,String,String,String)\n   */\n  public EntryReader(InputStream in, String filename) {\n    this(in, filename, null, null);\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param in the InputStream\n   * @see #EntryReader(InputStream,String,String,String)\n   */\n  public EntryReader(InputStream in) {\n    this(in, \"(InputStream)\", null, null);\n  }\n\n  /** A dummy Reader to be used when null is not acceptable. */\n  private static class DummyReader extends Reader {\n    @Override\n    public void close(/*>>>@GuardSatisfied DummyReader this*/) {\n      // No error, because closing is OK if it appears in try-with-resources.\n      // Later maybe create two versions (with and without exception here).\n    }\n\n    @Override\n    public void mark(int readAheadLimit) {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public boolean markSupported() {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public int read() {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public int read(char[] cbuf) {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public int read(char[] cbuf, int off, int len) {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public int read(CharBuffer target) {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public boolean ready() {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public void reset() {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public long skip(long n) {\n      throw new Error(\"DummyReader\");\n    }\n  }\n\n  /**\n   * Create a EntryReader.\n   *\n   *    @param reader source from which to read entries\n   *    @param filename file name corresponding to reader, for use in error messages\n   *    @param comment_re_string regular expression that matches comments.\n   *                      Any text that matches comment_re is removed.\n   *                      A line that is entirely a comment is ignored\n   *    @param include_re_string regular expression that matches include directives.\n   *                      The expression should define one group that contains\n   *                      the include file name\n   */\n  public EntryReader(\n      Reader reader,\n      String filename,\n      /*@Nullable*/ /*@Regex*/ String comment_re_string,\n      /*@Nullable*/ /*@Regex(1)*/ String include_re_string) {\n    // we won't use superclass methods, but passing null as an argument\n    // leads to a NullPointerException.\n    super(new DummyReader());\n    readers.push(new FlnReader(reader, filename));\n    if (comment_re_string == null) {\n      comment_re = null;\n    } else {\n      comment_re = Pattern.compile(comment_re_string);\n    }\n    if (include_re_string == null) {\n      include_re = null;\n    } else {\n      include_re = Pattern.compile(include_re_string);\n    }\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param reader source from which to read entries\n   * @see #EntryReader(Reader,String,String,String)\n   */\n  public EntryReader(Reader reader) {\n    this(reader, reader.toString(), null, null);\n  }\n\n  /// File Constructors\n\n  /**\n   * Create an EntryReader.\n   *\n   *    @param file       initial file to read\n   *    @param comment_re regular expression that matches comments.\n   *                      Any text that matches comment_re is removed.\n   *                      A line that is entirely a comment is ignored.\n   *    @param include_re regular expression that matches include directives.\n   *                      The expression should define one group that contains\n   *                      the include file name.\n   * @throws IOException if there is a problem reading the file\n   */\n  public EntryReader(\n      File file,\n      /*@Nullable*/ /*@Regex*/ String comment_re,\n      /*@Nullable*/ /*@Regex(1)*/ String include_re)\n      throws IOException {\n    this(UtilMDE.fileReader(file), file.toString(), comment_re, include_re);\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param file the file to read\n   * @throws IOException if there is a problem reading the file\n   * @see #EntryReader(File,String,String)\n   */\n  public EntryReader(File file) throws IOException {\n    this(file, null, null);\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param file the file to read\n   * @param charsetName the character set to use\n   * @throws IOException if there is a problem reading the file\n   * @see #EntryReader(File,String,String)\n   */\n  public EntryReader(File file, String charsetName) throws IOException {\n    this(UtilMDE.fileInputStream(file), charsetName, file.toString(), null, null);\n  }\n\n  /// Filename constructors\n\n  /**\n   * Create a new EntryReader starting with the specified file.\n   *\n   *    @param filename   initial file to read\n   *    @param comment_re regular expression that matches comments.\n   *                      Any text that matches comment_re is removed.\n   *                      A line that is entirely a comment is ignored.\n   *    @param include_re regular expression that matches include directives.\n   *                      The expression should define one group that contains\n   *                      the include file name.\n   *\n   * @throws IOException if there is a problem reading the file\n   *\n   * @see #EntryReader(File,String,String)\n   */\n  public EntryReader(\n      String filename,\n      /*@Nullable*/ /*@Regex*/ String comment_re,\n      /*@Nullable*/ /*@Regex(1)*/ String include_re)\n      throws IOException {\n    this(new File(filename), comment_re, include_re);\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param filename source from which to read entries\n   * @throws IOException if there is a problem reading the file\n   * @see #EntryReader(String,String,String)\n   */\n  public EntryReader(String filename) throws IOException {\n    this(filename, null, null);\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param filename source from which to read entries\n   * @param charsetName the character set to use\n   * @throws IOException if there is a problem reading the file\n   * @see #EntryReader(String,String,String)\n   */\n  public EntryReader(String filename, String charsetName) throws IOException {\n    this(new FileInputStream(filename), charsetName, filename, null, null);\n  }\n\n  ///\n  /// Methods\n  ///\n\n  /**\n   * Read a line, ignoring comments and processing includes.  Note that\n   * a line that is completely a comment is completely ignored (and\n   * not returned as a blank line).  Returns null at end of file.\n   * @return the string that was read, or null at end of file\n   */\n  @Override\n  public /*@Nullable*/ String readLine() throws IOException {\n\n    // System.out.printf (\"Entering size = %d%n\", readers.size());\n\n    // If a line has been pushed back, return it instead\n    if (pushback_line != null) {\n      String line = pushback_line;\n      pushback_line = null;\n      return line;\n    }\n\n    String line = get_next_line();\n    if (comment_re != null) {\n      while (line != null) {\n        Matcher cmatch = comment_re.matcher(line);\n        if (cmatch.find()) {\n          line = cmatch.replaceFirst(\"\");\n          if (line.length() > 0) {\n            break;\n          }\n        } else {\n          break;\n        }\n        line = get_next_line();\n        // System.out.printf (\"get_next_line = %s%n\", line);\n      }\n    }\n\n    if (line == null) {\n      return null;\n    }\n\n    // Handle include files.  Non-absolute pathnames are relative\n    // to the including file (the current file)\n    if (include_re != null) {\n      Matcher m = include_re.matcher(line);\n      if (m.matches()) {\n        String filename_string = m.group(1);\n        if (filename_string == null) {\n          throw new Error(\n              String.format(\"include_re (%s) does not capture group 1 in %s\", include_re, line));\n        }\n        File filename = new File(UtilMDE.expandFilename(filename_string));\n        // System.out.printf (\"Trying to include filename %s%n\", filename);\n        if (!filename.isAbsolute()) {\n          FlnReader reader = readers.peek();\n          File current_filename = new File(reader.filename);\n          File current_parent = current_filename.getParentFile();\n          filename = new File(current_parent, filename.toString());\n          // System.out.printf (\"absolute filename = %s %s %s%n\",\n          //                     current_filename, current_parent, filename);\n        }\n        readers.push(new FlnReader(filename.getAbsolutePath()));\n        return readLine();\n      }\n    }\n\n    // System.out.printf (\"Returning [%d] '%s'%n\", readers.size(), line);\n    return (line);\n  }\n\n  /**\n   * Return a line-by-line iterator for this file.\n   * <p>\n   *\n   * <b>Warning:</b> This does not return a fresh iterator each time.  The\n   * iterator is a singleton, the same one is returned each time, and a new\n   * one can never be created after it is exhausted.\n   *\n   * @return a line-by-line iterator for this file\n   */\n  @Override\n  public Iterator<String> iterator() {\n    return this;\n  }\n\n  /**\n   * Returns whether or not there is another line to read.  Any IOExceptions\n   * are turned into errors (because the definition of hasNext() in Iterator\n   * doesn't throw any exceptions).\n   * @return whether there is another line to read\n   */\n  @Override\n  public boolean hasNext() {\n    if (pushback_line != null) {\n      return true;\n    }\n\n    String line = null;\n    try {\n      line = readLine();\n    } catch (IOException e) {\n      throw new Error(\"unexpected IOException: \", e);\n    }\n\n    if (line == null) {\n      return false;\n    }\n\n    putback(line);\n    return true;\n  }\n\n  /**\n   * Return the next line in the multi-file.\n   * @return the next line in the multi-file\n   * Throws NoSuchElementException at end of file\n   */\n  @Override\n  public String next() {\n    try {\n      String result = readLine();\n      if (result != null) {\n        return result;\n      } else {\n        throw new NoSuchElementException();\n      }\n    } catch (IOException e) {\n      throw new Error(\"unexpected IOException\", e);\n    }\n  }\n\n  /** remove() is not supported. */\n  @Override\n  public void remove() {\n    throw new UnsupportedOperationException(\"can't remove lines from file\");\n  }\n\n  /**\n   * Returns the next entry (paragraph) in the file.  Entries are separated\n   * by blank lines unless the entry started with {@link #entry_start_re}\n   * (see {@link #set_entry_start_stop}).  If no more entries are\n   * available, returns null.\n   * @return the next entry (paragraph) in the file\n   * @throws IOException if there is a problem reading the file\n   */\n  public /*@Nullable*/ Entry get_entry() throws IOException {\n\n    // Skip any preceding blank lines\n    String line = readLine();\n    while ((line != null) && (line.trim().length() == 0)) {\n      line = readLine();\n    }\n    if (line == null) {\n      return (null);\n    }\n\n    StringBuilder body = new StringBuilder(10000);\n    Entry entry = null;\n    String filename = getFileName();\n    long line_number = getLineNumber();\n\n    // If first line matches entry_start_re, this is a long entry.\n    /*@Regex(1)*/ Matcher entry_match = null;\n    if (entry_start_re != null) {\n      entry_match = entry_start_re.matcher(line);\n    }\n    if ((entry_match != null) && entry_match.find()) {\n      assert entry_start_re != null : \"@AssumeAssertion(nullness): dependent: entry_match != null\";\n      assert entry_stop_re != null\n          : \"@AssumeAssertion(nullness): dependent: entry_start_re != null\";\n\n      // Remove entry match from the line\n      if (entry_match.groupCount() > 0) {\n        @SuppressWarnings(\n            \"nullness\") // dependent: just checked that group 1 exists via groupCount(); https://code.google.com/p/checker-framework/issues/detail?id=291\n        /*@NonNull*/ String match_group_1 = entry_match.group(1);\n        line = entry_match.replaceFirst(match_group_1);\n      }\n\n      // Description is the first line\n      String description = line;\n\n      // Read until we find the termination of the entry\n      Matcher end_entry_match = entry_stop_re.matcher(line);\n      while ((line != null)\n          && !entry_match.find()\n          && !end_entry_match.find()\n          && filename.equals(getFileName())) {\n        body.append(line);\n        body.append(lineSep);\n        line = readLine();\n        if (line == null) {\n          break; // end of file serves as entry terminator\n        }\n        entry_match = entry_start_re.matcher(line);\n        end_entry_match = entry_stop_re.matcher(line);\n      }\n\n      // If this entry was terminated by the start of the next one,\n      // put that line back\n      if ((line != null) && (entry_match.find(0) || !filename.equals(getFileName()))) {\n        putback(line);\n      }\n\n      entry = new Entry(description, body.toString(), filename, line_number, false);\n\n    } else { // blank-separated entry\n\n      String description = line;\n\n      // Read until we find another blank line\n      while ((line != null) && (line.trim().length() != 0) && filename.equals(getFileName())) {\n        body.append(line);\n        body.append(lineSep);\n        line = readLine();\n      }\n\n      // If this entry was terminated by the start of a new input file\n      // put that line back\n      if ((line != null) && !filename.equals(getFileName())) {\n        putback(line);\n      }\n\n      entry = new Entry(description, body.toString(), filename, line_number, true);\n    }\n\n    return (entry);\n  }\n\n  /**\n   * Reads the next line from the current reader.  If EOF is encountered\n   * pop out to the next reader.  Returns null if there is no more input.\n   * @return next line from the reader, or null if there is no more input\n   */\n  private /*@Nullable*/ String get_next_line() throws IOException {\n\n    if (readers.size() == 0) {\n      return (null);\n    }\n\n    FlnReader ri1 = readers.peek();\n    String line = ri1.readLine();\n    while (line == null) {\n      readers.pop();\n      if (readers.empty()) {\n        return (null);\n      }\n      FlnReader ri2 = readers.peek();\n      line = ri2.readLine();\n    }\n    return (line);\n  }\n\n  /**\n   * Returns the current filename.\n   * @return the current filename\n   */\n  public String getFileName() {\n    FlnReader ri = readers.peek();\n    if (ri == null) {\n      throw new Error(\"Past end of input\");\n    }\n    return ri.filename;\n  }\n\n  /**\n   * Return the current line number in the current file.\n   * @return the current line number\n   */\n  @Override\n  public int getLineNumber() {\n    FlnReader ri = readers.peek();\n    if (ri == null) {\n      throw new Error(\"Past end of input\");\n    }\n    return ri.getLineNumber();\n  }\n\n  /** Set the current line number in the current file.\n   * @param lineNumber new line number for the current file\n   */\n  @Override\n  public void setLineNumber(int lineNumber) {\n    FlnReader ri = readers.peek();\n    if (ri == null) {\n      throw new Error(\"Past end of input\");\n    }\n    ri.setLineNumber(lineNumber);\n  }\n\n  /**\n   * Set the regular expressions for the start and stop of long\n   * entries (multiple lines that are read as a group by get_entry()).\n   * @param entry_start_re regular expression that starts a long entry\n   * @param entry_stop_re regular expression that ends a long entry\n   */\n  public void set_entry_start_stop(\n      /*@Regex(1)*/ String entry_start_re, /*@Regex*/ String entry_stop_re) {\n    this.entry_start_re = Pattern.compile(entry_start_re);\n    this.entry_stop_re = Pattern.compile(entry_stop_re);\n  }\n\n  /**\n   * Set the regular expressions for the start and stop of long\n   * entries (multiple lines that are read as a group by get_entry()).\n   * @param entry_start_re regular expression that starts a long entry\n   * @param entry_stop_re regular expression that ends a long entry\n   */\n  public void set_entry_start_stop(/*@Regex(1)*/ Pattern entry_start_re, Pattern entry_stop_re) {\n    this.entry_start_re = entry_start_re;\n    this.entry_stop_re = entry_stop_re;\n  }\n\n  /**\n   * Puts the specified line back in the input.  Only one line can be\n   * put back.\n   * @param line the line to be put back in the input\n   */\n  // TODO:  This would probably be better implemented with the \"mark\" mechanism\n  // of BufferedReader (which is also in LineNumberReader and FlnReader).\n  public void putback(String line) {\n    assert pushback_line == null\n        : \"push back '\" + line + \"' when '\" + pushback_line + \"' already back\";\n    pushback_line = line;\n  }\n\n  /** Mark the present position in the stream. */\n  @Override\n  public void mark(int readAheadLimit) {\n    throw new Error(\"not yet implemented\");\n  }\n  /** Read a single character. */\n  @Override\n  public int read() {\n    throw new Error(\"not yet implemented\");\n  }\n  /** Read characters into a portion of an array. */\n  @Override\n  public int read(char[] cbuf, int off, int len) {\n    throw new Error(\"not yet implemented\");\n  }\n  /** Reset the stream to the most recent mark. */\n  @Override\n  public void reset() {\n    throw new Error(\"not yet implemented\");\n  }\n  /** Skip characters. */\n  @Override\n  public long skip(long n) {\n    throw new Error(\"not yet implemented\");\n  }\n\n  /**\n   * Simple usage example.\n   * @param args command-line arguments: filename [comment_re [include_re]]\n   * @throws IOException if there is a problem reading a file\n   */\n  public static void main(String[] args) throws IOException {\n\n    if (args.length < 1 || args.length > 3) {\n      System.err.println(\n          \"EntryReader sample program requires 1-3 args: filename [comment_re [include_re]]\");\n      System.exit(1);\n    }\n    String filename = args[0];\n    String comment_re = null;\n    String include_re = null;\n    if (args.length >= 2) {\n      comment_re = args[1];\n      if (!RegexUtil.isRegex(comment_re)) {\n        System.err.println(\n            \"Error parsing comment regex \\\"\"\n                + comment_re\n                + \"\\\": \"\n                + RegexUtil.regexError(comment_re));\n        System.exit(1);\n      }\n    }\n    if (args.length >= 3) {\n      include_re = args[2];\n      if (!RegexUtil.isRegex(include_re, 1)) {\n        System.err.println(\n            \"Error parsing include regex \\\"\"\n                + include_re\n                + \"\\\": \"\n                + RegexUtil.regexError(include_re));\n        System.exit(1);\n      }\n    }\n    EntryReader reader = new EntryReader(filename, comment_re, include_re);\n\n    String line = reader.readLine();\n    while (line != null) {\n      System.out.printf(\"%s: %d: %s%n\", reader.getFileName(), reader.getLineNumber(), line);\n      line = reader.readLine();\n    }\n  }\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "file", "java.io", "File" ], [ "comment_re", "java.lang", "String" ], [ "include_re", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "read", "plume", "EntryReader", "public int read(char[] cbuf, int off, int len)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "next", "java.util", "Iterator", "public abstract E next()" ], [ "markSupported", "java.io", "BufferedReader", "public boolean markSupported()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "ready", "java.io", "BufferedReader", "public boolean ready() throws IOException" ], [ "read", "java.io", "Reader", "public int read(CharBuffer arg0) throws IOException" ], [ "lines", "java.io", "BufferedReader", "public Stream<String> lines()" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "read", "plume", "EntryReader", "public int read()" ], [ "getLineNumber", "plume", "EntryReader", "public int getLineNumber()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "next", "plume", "EntryReader", "public String next()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "read", "java.io", "Reader", "public int read(char[] arg0) throws IOException" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hasNext", "plume", "EntryReader", "public boolean hasNext()" ], [ "iterator", "plume", "EntryReader", "public Iterator<String> iterator()" ], [ "getFileName", "plume", "EntryReader", "public String getFileName()" ], [ "readLine", "plume", "EntryReader", "public String readLine() throws IOException" ], [ "get_entry", "plume", "EntryReader", "public Entry get_entry() throws IOException" ], [ "readLine", "java.io", "BufferedReader", "String readLine(boolean arg0, boolean[] arg1) throws IOException" ], [ "transferTo", "java.io", "Reader", "public long transferTo(Writer arg0) throws IOException" ], [ "skip", "plume", "EntryReader", "public long skip(long n)" ], [ "setWritable", "java.io", "File", "public boolean setWritable(boolean arg0)" ], [ "getName", "java.io", "File", "public String getName()" ], [ "getAbsoluteFile", "java.io", "File", "public File getAbsoluteFile()" ], [ "delete", "java.io", "File", "public boolean delete()" ], [ "exists", "java.io", "File", "public boolean exists()" ], [ "canWrite", "java.io", "File", "public boolean canWrite()" ], [ "setExecutable", "java.io", "File", "public boolean setExecutable(boolean arg0, boolean arg1)" ], [ "listFiles", "java.io", "File", "public File[] listFiles()" ], [ "listFiles", "java.io", "File", "public File[] listFiles(FileFilter arg0)" ], [ "toString", "java.io", "File", "public String toString()" ], [ "canExecute", "java.io", "File", "public boolean canExecute()" ], [ "setReadable", "java.io", "File", "public boolean setReadable(boolean arg0, boolean arg1)" ], [ "getPath", "java.io", "File", "public String getPath()" ], [ "isInvalid", "java.io", "File", "final boolean isInvalid()" ], [ "mkdir", "java.io", "File", "public boolean mkdir()" ], [ "getCanonicalFile", "java.io", "File", "public File getCanonicalFile() throws IOException" ], [ "setReadOnly", "java.io", "File", "public boolean setReadOnly()" ], [ "list", "java.io", "File", "public String[] list()" ], [ "toURL", "java.io", "File", "public URL toURL() throws MalformedURLException" ], [ "isHidden", "java.io", "File", "public boolean isHidden()" ], [ "toURI", "java.io", "File", "public URI toURI()" ], [ "listFiles", "java.io", "File", "public File[] listFiles(FilenameFilter arg0)" ], [ "getFreeSpace", "java.io", "File", "public long getFreeSpace()" ], [ "hashCode", "java.io", "File", "public int hashCode()" ], [ "setLastModified", "java.io", "File", "public boolean setLastModified(long arg0)" ], [ "isAbsolute", "java.io", "File", "public boolean isAbsolute()" ], [ "length", "java.io", "File", "public long length()" ], [ "getParent", "java.io", "File", "public String getParent()" ], [ "toPath", "java.io", "File", "public Path toPath()" ], [ "canRead", "java.io", "File", "public boolean canRead()" ], [ "renameTo", "java.io", "File", "public boolean renameTo(File arg0)" ], [ "setReadable", "java.io", "File", "public boolean setReadable(boolean arg0)" ], [ "compareTo", "java.io", "File", "public int compareTo(File arg0)" ], [ "createNewFile", "java.io", "File", "public boolean createNewFile() throws IOException" ], [ "setWritable", "java.io", "File", "public boolean setWritable(boolean arg0, boolean arg1)" ], [ "getTotalSpace", "java.io", "File", "public long getTotalSpace()" ], [ "getAbsolutePath", "java.io", "File", "public String getAbsolutePath()" ], [ "isFile", "java.io", "File", "public boolean isFile()" ], [ "list", "java.io", "File", "public String[] list(FilenameFilter arg0)" ], [ "setExecutable", "java.io", "File", "public boolean setExecutable(boolean arg0)" ], [ "getCanonicalPath", "java.io", "File", "public String getCanonicalPath() throws IOException" ], [ "mkdirs", "java.io", "File", "public boolean mkdirs()" ], [ "equals", "java.io", "File", "public boolean equals(Object arg0)" ], [ "getPrefixLength", "java.io", "File", "int getPrefixLength()" ], [ "getParentFile", "java.io", "File", "public File getParentFile()" ], [ "lastModified", "java.io", "File", "public long lastModified()" ], [ "getUsableSpace", "java.io", "File", "public long getUsableSpace()" ], [ "isDirectory", "java.io", "File", "public boolean isDirectory()" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "length", "java.lang", "String", "public int length()" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "entry_start_re", "plume", "EntryReader", "public Pattern entry_start_re = null;" ], [ "entry_stop_re", "plume", "EntryReader", "public Pattern entry_stop_re = null;" ], [ "pushback_line", "plume", "EntryReader", "String pushback_line = null;" ], [ "lock", "java.io", "Reader", "protected Object lock;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 11012,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "EntryReader",
  "javadocTag" : "@throws IOException if there is a problem reading the file",
  "methodJavadoc" : "    /** Create a EntryReader that does not support comments or include directives.\n   * @param file the file to read\n   * @throws IOException if there is a problem reading the file\n   * @see #EntryReader(File,String,String)\n   */",
  "methodSourceCode" : "public EntryReader(File file) throws IOException{\n    this(file, null, null);\n}",
  "classJavadoc" : "/**\n * Class that reads \"entries\" from a file.  In the simplest case, entries\n * can be lines.  It supports:\n *   include files,\n *   comments, and\n *   multi-line entries (paragraphs).\n * The syntax of each of these is customizable.\n * <p>\n *\n * Example use:\n * <pre>\n *  // args are filename, comment regexp, include regexp\n *  try (EntryReader er = new EntryReader(filename, \"^#.*\", null)) {\n *    for (String line : er) {\n *      ...\n *    }\n *  } catch (IOException e) {\n *    System.err.println(\"Problem reading \" + filename + \": \" + e.getMessage());\n *    System.exit(2);\n *    throw new Error(\"This can't happen\"); // for definite assignment check\n *  }\n * </pre>\n *\n * @see #get_entry() and @see #set_entry_start_stop(String,String)\n */",
  "classSourceCode" : "package plume;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.io.Reader;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.CharBuffer;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.Stack;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/*>>>\nimport org.checkerframework.checker.lock.qual.*;\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.checker.regex.qual.*;\n*/\n\n// TODO:\n// EntryReader has a public concept of \"short entry\", but I don't think that\n// concept is logically part of EntryReader.  I think it would be better for\n// Lookup to make this decision itself, for instance by checking whether there\n// are any line separators in the entry that it gets back.\n//\n// Here are some useful features that EntryReader should have.\n//  * It should implement some unimplemented methods from LineNumberReader (see\n//    \"not yet implemented\" in this file).\n//  * It should have constructors that take an InputStream or Reader\n//    (in addition to the current BufferedReader, File, and String versions).\n//  * It should have a close method.\n//  * It should automatically close the underlying file/etc. when the\n//    iterator gets to the end (or the end is otherwise reached).\n\n/**\n * Class that reads \"entries\" from a file.  In the simplest case, entries\n * can be lines.  It supports:\n *   include files,\n *   comments, and\n *   multi-line entries (paragraphs).\n * The syntax of each of these is customizable.\n * <p>\n *\n * Example use:\n * <pre>\n *  // args are filename, comment regexp, include regexp\n *  try (EntryReader er = new EntryReader(filename, \"^#.*\", null)) {\n *    for (String line : er) {\n *      ...\n *    }\n *  } catch (IOException e) {\n *    System.err.println(\"Problem reading \" + filename + \": \" + e.getMessage());\n *    System.exit(2);\n *    throw new Error(\"This can't happen\"); // for definite assignment check\n *  }\n * </pre>\n *\n * @see #get_entry() and @see #set_entry_start_stop(String,String)\n */\npublic class EntryReader extends LineNumberReader implements Iterable<String>, Iterator<String> {\n\n  ///\n  /// User configuration variables\n  ///\n\n  /** Regular expression that specifies an include file. */\n  private final /*@Nullable*/ /*@Regex(1)*/ Pattern include_re;\n\n  /** Regular expression that matches a comment. */\n  private final /*@Nullable*/ Pattern comment_re;\n\n  /**\n   * Regular expression that starts a long entry.\n   * <p>\n   * If the first line of an entry matches this regexp, then the entry is\n   * terminated by:  entry_stop_re, another line that matches\n   * entry_start_re (even not following a newline), or the end of the\n   * current file.\n   * <p>\n   * Otherwise, the first line of an entry does NOT match this regexp (or\n   * the regexp is null), in which case the entry is terminated by a blank\n   * line or the end of the current file.\n   */\n  public /*@MonotonicNonNull*/ /*@Regex(1)*/ Pattern entry_start_re = null;\n\n  /**\n   * @see #entry_start_re\n   */\n  public /*@MonotonicNonNull*/ Pattern entry_stop_re = null;\n\n  ///\n  /// Internal implementation variables\n  ///\n\n  /** Stack of readers.  Used to support include files. */\n  private final Stack<FlnReader> readers = new Stack<FlnReader>();\n\n  /** Line that is pushed back to be reread. */\n  /*@Nullable*/ String pushback_line = null;\n\n  /** Platform-specific line separator. */\n  private static final String lineSep = System.getProperty(\"line.separator\");\n\n  ///\n  /// Helper classes\n  ///\n\n  /**\n   * Like LineNumberReader, but also has a filename field.\n   * \"FlnReader\" stands for \"Filename and Line Number Reader\".\n   */\n  private static class FlnReader extends LineNumberReader {\n    /** The file being read. */\n    public String filename;\n\n    /**\n     * Create a FlnReader.\n     * @param reader source from which to read entries\n     * @param filename file name corresponding to reader, for use in error messages.\n     *   Must be non-null; if there isn't a name, clients should provide a dummy value.\n     */\n    public FlnReader(Reader reader, String filename) {\n      super(reader);\n      this.filename = filename;\n    }\n\n    /**\n     * Create a FlnReader.\n     * @param filename file from which to read\n     */\n    public FlnReader(String filename) throws IOException {\n      super(UtilMDE.fileReader(filename));\n      this.filename = filename;\n    }\n  }\n\n  /** Descriptor for an entry (paragraph). */\n  public static class Entry {\n    /** First line of the entry. */\n    public String first_line;\n    /** Complete body of the entry including the first line. */\n    public String body;\n    /** True if this is a short entry (blank-line-separated). */\n    boolean short_entry;\n    /** Filename in which the entry was found. */\n    String filename;\n    /** Line number of first line of entry. */\n    long line_number;\n\n    /** Create an entry.\n     * @param first_line first line of the entry\n     * @param body complete body of the entry including the first line\n     * @param short_entry true if this is a short entry (blank-line-separated)\n     * @param filename filename in which the entry was found\n     * @param line_number line number of first line of entry\n     */\n    Entry(String first_line, String body, String filename, long line_number, boolean short_entry) {\n      this.first_line = first_line;\n      this.body = body;\n      this.filename = filename;\n      this.line_number = line_number;\n      this.short_entry = short_entry;\n    }\n\n    /**\n     * Return a substring of the entry body that matches the specified\n     * regular expression.  If no match is found, returns the first_line.\n     * @param re regex to match\n     * @return a substring that matches re\n     */\n    String get_description(/*@Nullable*/ Pattern re) {\n\n      if (re == null) {\n        return first_line;\n      }\n\n      Matcher descr = re.matcher(body);\n      if (descr.find()) {\n        return descr.group();\n      } else {\n        return first_line;\n      }\n    }\n  }\n\n  ///\n  /// Constructors\n  ///\n\n  /// Inputstream and charset constructors\n\n  /** Create a EntryReader that uses the given character set.\n   * @throws UnsupportedEncodingException if the charset encoding is not supported\n   * @param in source from which to read entries\n   * @param charsetName the character set to use\n   * @param filename non-null file name for stream being read\n   * @param comment_re_string regular expression that matches comments.\n   *                      Any text that matches comment_re is removed.\n   *                      A line that is entirely a comment is ignored.\n   * @param include_re_string regular expression that matches include directives.\n   *                      The expression should define one group that contains\n   *                      the include file name.\n   * @see #EntryReader(InputStream,String,String,String)\n   */\n  public EntryReader(\n      InputStream in,\n      String charsetName,\n      String filename,\n      /*@Nullable*/ /*@Regex*/ String comment_re_string,\n      /*@Nullable*/ /*@Regex(1)*/ String include_re_string)\n      throws UnsupportedEncodingException {\n    this(new InputStreamReader(in, charsetName), filename, comment_re_string, include_re_string);\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param in the InputStream\n   * @param charsetName the character set to use\n   * @param filename the file name\n   * @throws UnsupportedEncodingException if the charset encoding is not supported\n   * @see #EntryReader(InputStream,String,String,String)\n   */\n  public EntryReader(InputStream in, String charsetName, String filename)\n      throws UnsupportedEncodingException {\n    this(in, charsetName, filename, null, null);\n  }\n\n  /// Inputstream (no charset) constructors\n\n  /**\n   * Create a EntryReader.\n   *\n   *    @param in source from which to read entries\n   *    @param filename non-null file name for stream being read\n   *    @param comment_re_string regular expression that matches comments.\n   *                      Any text that matches comment_re is removed.\n   *                      A line that is entirely a comment is ignored.\n   *    @param include_re_string regular expression that matches include directives.\n   *                      The expression should define one group that contains\n   *                      the include file name.\n   */\n  public EntryReader(\n      InputStream in,\n      String filename,\n      /*@Nullable*/ /*@Regex*/ String comment_re_string,\n      /*@Nullable*/ /*@Regex(1)*/ String include_re_string) {\n    this(new InputStreamReader(in), filename, comment_re_string, include_re_string);\n  }\n\n  /**\n   * Create a EntryReader that uses the default character set and does not\n   * support comments or include directives.\n   * @param in the InputStream\n   * @param filename the file name\n   * @see #EntryReader(InputStream,String,String,String,String)\n   */\n  public EntryReader(InputStream in, String filename) {\n    this(in, filename, null, null);\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param in the InputStream\n   * @see #EntryReader(InputStream,String,String,String)\n   */\n  public EntryReader(InputStream in) {\n    this(in, \"(InputStream)\", null, null);\n  }\n\n  /** A dummy Reader to be used when null is not acceptable. */\n  private static class DummyReader extends Reader {\n    @Override\n    public void close(/*>>>@GuardSatisfied DummyReader this*/) {\n      // No error, because closing is OK if it appears in try-with-resources.\n      // Later maybe create two versions (with and without exception here).\n    }\n\n    @Override\n    public void mark(int readAheadLimit) {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public boolean markSupported() {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public int read() {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public int read(char[] cbuf) {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public int read(char[] cbuf, int off, int len) {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public int read(CharBuffer target) {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public boolean ready() {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public void reset() {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public long skip(long n) {\n      throw new Error(\"DummyReader\");\n    }\n  }\n\n  /**\n   * Create a EntryReader.\n   *\n   *    @param reader source from which to read entries\n   *    @param filename file name corresponding to reader, for use in error messages\n   *    @param comment_re_string regular expression that matches comments.\n   *                      Any text that matches comment_re is removed.\n   *                      A line that is entirely a comment is ignored\n   *    @param include_re_string regular expression that matches include directives.\n   *                      The expression should define one group that contains\n   *                      the include file name\n   */\n  public EntryReader(\n      Reader reader,\n      String filename,\n      /*@Nullable*/ /*@Regex*/ String comment_re_string,\n      /*@Nullable*/ /*@Regex(1)*/ String include_re_string) {\n    // we won't use superclass methods, but passing null as an argument\n    // leads to a NullPointerException.\n    super(new DummyReader());\n    readers.push(new FlnReader(reader, filename));\n    if (comment_re_string == null) {\n      comment_re = null;\n    } else {\n      comment_re = Pattern.compile(comment_re_string);\n    }\n    if (include_re_string == null) {\n      include_re = null;\n    } else {\n      include_re = Pattern.compile(include_re_string);\n    }\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param reader source from which to read entries\n   * @see #EntryReader(Reader,String,String,String)\n   */\n  public EntryReader(Reader reader) {\n    this(reader, reader.toString(), null, null);\n  }\n\n  /// File Constructors\n\n  /**\n   * Create an EntryReader.\n   *\n   *    @param file       initial file to read\n   *    @param comment_re regular expression that matches comments.\n   *                      Any text that matches comment_re is removed.\n   *                      A line that is entirely a comment is ignored.\n   *    @param include_re regular expression that matches include directives.\n   *                      The expression should define one group that contains\n   *                      the include file name.\n   * @throws IOException if there is a problem reading the file\n   */\n  public EntryReader(\n      File file,\n      /*@Nullable*/ /*@Regex*/ String comment_re,\n      /*@Nullable*/ /*@Regex(1)*/ String include_re)\n      throws IOException {\n    this(UtilMDE.fileReader(file), file.toString(), comment_re, include_re);\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param file the file to read\n   * @throws IOException if there is a problem reading the file\n   * @see #EntryReader(File,String,String)\n   */\n  public EntryReader(File file) throws IOException {\n    this(file, null, null);\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param file the file to read\n   * @param charsetName the character set to use\n   * @throws IOException if there is a problem reading the file\n   * @see #EntryReader(File,String,String)\n   */\n  public EntryReader(File file, String charsetName) throws IOException {\n    this(UtilMDE.fileInputStream(file), charsetName, file.toString(), null, null);\n  }\n\n  /// Filename constructors\n\n  /**\n   * Create a new EntryReader starting with the specified file.\n   *\n   *    @param filename   initial file to read\n   *    @param comment_re regular expression that matches comments.\n   *                      Any text that matches comment_re is removed.\n   *                      A line that is entirely a comment is ignored.\n   *    @param include_re regular expression that matches include directives.\n   *                      The expression should define one group that contains\n   *                      the include file name.\n   *\n   * @throws IOException if there is a problem reading the file\n   *\n   * @see #EntryReader(File,String,String)\n   */\n  public EntryReader(\n      String filename,\n      /*@Nullable*/ /*@Regex*/ String comment_re,\n      /*@Nullable*/ /*@Regex(1)*/ String include_re)\n      throws IOException {\n    this(new File(filename), comment_re, include_re);\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param filename source from which to read entries\n   * @throws IOException if there is a problem reading the file\n   * @see #EntryReader(String,String,String)\n   */\n  public EntryReader(String filename) throws IOException {\n    this(filename, null, null);\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param filename source from which to read entries\n   * @param charsetName the character set to use\n   * @throws IOException if there is a problem reading the file\n   * @see #EntryReader(String,String,String)\n   */\n  public EntryReader(String filename, String charsetName) throws IOException {\n    this(new FileInputStream(filename), charsetName, filename, null, null);\n  }\n\n  ///\n  /// Methods\n  ///\n\n  /**\n   * Read a line, ignoring comments and processing includes.  Note that\n   * a line that is completely a comment is completely ignored (and\n   * not returned as a blank line).  Returns null at end of file.\n   * @return the string that was read, or null at end of file\n   */\n  @Override\n  public /*@Nullable*/ String readLine() throws IOException {\n\n    // System.out.printf (\"Entering size = %d%n\", readers.size());\n\n    // If a line has been pushed back, return it instead\n    if (pushback_line != null) {\n      String line = pushback_line;\n      pushback_line = null;\n      return line;\n    }\n\n    String line = get_next_line();\n    if (comment_re != null) {\n      while (line != null) {\n        Matcher cmatch = comment_re.matcher(line);\n        if (cmatch.find()) {\n          line = cmatch.replaceFirst(\"\");\n          if (line.length() > 0) {\n            break;\n          }\n        } else {\n          break;\n        }\n        line = get_next_line();\n        // System.out.printf (\"get_next_line = %s%n\", line);\n      }\n    }\n\n    if (line == null) {\n      return null;\n    }\n\n    // Handle include files.  Non-absolute pathnames are relative\n    // to the including file (the current file)\n    if (include_re != null) {\n      Matcher m = include_re.matcher(line);\n      if (m.matches()) {\n        String filename_string = m.group(1);\n        if (filename_string == null) {\n          throw new Error(\n              String.format(\"include_re (%s) does not capture group 1 in %s\", include_re, line));\n        }\n        File filename = new File(UtilMDE.expandFilename(filename_string));\n        // System.out.printf (\"Trying to include filename %s%n\", filename);\n        if (!filename.isAbsolute()) {\n          FlnReader reader = readers.peek();\n          File current_filename = new File(reader.filename);\n          File current_parent = current_filename.getParentFile();\n          filename = new File(current_parent, filename.toString());\n          // System.out.printf (\"absolute filename = %s %s %s%n\",\n          //                     current_filename, current_parent, filename);\n        }\n        readers.push(new FlnReader(filename.getAbsolutePath()));\n        return readLine();\n      }\n    }\n\n    // System.out.printf (\"Returning [%d] '%s'%n\", readers.size(), line);\n    return (line);\n  }\n\n  /**\n   * Return a line-by-line iterator for this file.\n   * <p>\n   *\n   * <b>Warning:</b> This does not return a fresh iterator each time.  The\n   * iterator is a singleton, the same one is returned each time, and a new\n   * one can never be created after it is exhausted.\n   *\n   * @return a line-by-line iterator for this file\n   */\n  @Override\n  public Iterator<String> iterator() {\n    return this;\n  }\n\n  /**\n   * Returns whether or not there is another line to read.  Any IOExceptions\n   * are turned into errors (because the definition of hasNext() in Iterator\n   * doesn't throw any exceptions).\n   * @return whether there is another line to read\n   */\n  @Override\n  public boolean hasNext() {\n    if (pushback_line != null) {\n      return true;\n    }\n\n    String line = null;\n    try {\n      line = readLine();\n    } catch (IOException e) {\n      throw new Error(\"unexpected IOException: \", e);\n    }\n\n    if (line == null) {\n      return false;\n    }\n\n    putback(line);\n    return true;\n  }\n\n  /**\n   * Return the next line in the multi-file.\n   * @return the next line in the multi-file\n   * Throws NoSuchElementException at end of file\n   */\n  @Override\n  public String next() {\n    try {\n      String result = readLine();\n      if (result != null) {\n        return result;\n      } else {\n        throw new NoSuchElementException();\n      }\n    } catch (IOException e) {\n      throw new Error(\"unexpected IOException\", e);\n    }\n  }\n\n  /** remove() is not supported. */\n  @Override\n  public void remove() {\n    throw new UnsupportedOperationException(\"can't remove lines from file\");\n  }\n\n  /**\n   * Returns the next entry (paragraph) in the file.  Entries are separated\n   * by blank lines unless the entry started with {@link #entry_start_re}\n   * (see {@link #set_entry_start_stop}).  If no more entries are\n   * available, returns null.\n   * @return the next entry (paragraph) in the file\n   * @throws IOException if there is a problem reading the file\n   */\n  public /*@Nullable*/ Entry get_entry() throws IOException {\n\n    // Skip any preceding blank lines\n    String line = readLine();\n    while ((line != null) && (line.trim().length() == 0)) {\n      line = readLine();\n    }\n    if (line == null) {\n      return (null);\n    }\n\n    StringBuilder body = new StringBuilder(10000);\n    Entry entry = null;\n    String filename = getFileName();\n    long line_number = getLineNumber();\n\n    // If first line matches entry_start_re, this is a long entry.\n    /*@Regex(1)*/ Matcher entry_match = null;\n    if (entry_start_re != null) {\n      entry_match = entry_start_re.matcher(line);\n    }\n    if ((entry_match != null) && entry_match.find()) {\n      assert entry_start_re != null : \"@AssumeAssertion(nullness): dependent: entry_match != null\";\n      assert entry_stop_re != null\n          : \"@AssumeAssertion(nullness): dependent: entry_start_re != null\";\n\n      // Remove entry match from the line\n      if (entry_match.groupCount() > 0) {\n        @SuppressWarnings(\n            \"nullness\") // dependent: just checked that group 1 exists via groupCount(); https://code.google.com/p/checker-framework/issues/detail?id=291\n        /*@NonNull*/ String match_group_1 = entry_match.group(1);\n        line = entry_match.replaceFirst(match_group_1);\n      }\n\n      // Description is the first line\n      String description = line;\n\n      // Read until we find the termination of the entry\n      Matcher end_entry_match = entry_stop_re.matcher(line);\n      while ((line != null)\n          && !entry_match.find()\n          && !end_entry_match.find()\n          && filename.equals(getFileName())) {\n        body.append(line);\n        body.append(lineSep);\n        line = readLine();\n        if (line == null) {\n          break; // end of file serves as entry terminator\n        }\n        entry_match = entry_start_re.matcher(line);\n        end_entry_match = entry_stop_re.matcher(line);\n      }\n\n      // If this entry was terminated by the start of the next one,\n      // put that line back\n      if ((line != null) && (entry_match.find(0) || !filename.equals(getFileName()))) {\n        putback(line);\n      }\n\n      entry = new Entry(description, body.toString(), filename, line_number, false);\n\n    } else { // blank-separated entry\n\n      String description = line;\n\n      // Read until we find another blank line\n      while ((line != null) && (line.trim().length() != 0) && filename.equals(getFileName())) {\n        body.append(line);\n        body.append(lineSep);\n        line = readLine();\n      }\n\n      // If this entry was terminated by the start of a new input file\n      // put that line back\n      if ((line != null) && !filename.equals(getFileName())) {\n        putback(line);\n      }\n\n      entry = new Entry(description, body.toString(), filename, line_number, true);\n    }\n\n    return (entry);\n  }\n\n  /**\n   * Reads the next line from the current reader.  If EOF is encountered\n   * pop out to the next reader.  Returns null if there is no more input.\n   * @return next line from the reader, or null if there is no more input\n   */\n  private /*@Nullable*/ String get_next_line() throws IOException {\n\n    if (readers.size() == 0) {\n      return (null);\n    }\n\n    FlnReader ri1 = readers.peek();\n    String line = ri1.readLine();\n    while (line == null) {\n      readers.pop();\n      if (readers.empty()) {\n        return (null);\n      }\n      FlnReader ri2 = readers.peek();\n      line = ri2.readLine();\n    }\n    return (line);\n  }\n\n  /**\n   * Returns the current filename.\n   * @return the current filename\n   */\n  public String getFileName() {\n    FlnReader ri = readers.peek();\n    if (ri == null) {\n      throw new Error(\"Past end of input\");\n    }\n    return ri.filename;\n  }\n\n  /**\n   * Return the current line number in the current file.\n   * @return the current line number\n   */\n  @Override\n  public int getLineNumber() {\n    FlnReader ri = readers.peek();\n    if (ri == null) {\n      throw new Error(\"Past end of input\");\n    }\n    return ri.getLineNumber();\n  }\n\n  /** Set the current line number in the current file.\n   * @param lineNumber new line number for the current file\n   */\n  @Override\n  public void setLineNumber(int lineNumber) {\n    FlnReader ri = readers.peek();\n    if (ri == null) {\n      throw new Error(\"Past end of input\");\n    }\n    ri.setLineNumber(lineNumber);\n  }\n\n  /**\n   * Set the regular expressions for the start and stop of long\n   * entries (multiple lines that are read as a group by get_entry()).\n   * @param entry_start_re regular expression that starts a long entry\n   * @param entry_stop_re regular expression that ends a long entry\n   */\n  public void set_entry_start_stop(\n      /*@Regex(1)*/ String entry_start_re, /*@Regex*/ String entry_stop_re) {\n    this.entry_start_re = Pattern.compile(entry_start_re);\n    this.entry_stop_re = Pattern.compile(entry_stop_re);\n  }\n\n  /**\n   * Set the regular expressions for the start and stop of long\n   * entries (multiple lines that are read as a group by get_entry()).\n   * @param entry_start_re regular expression that starts a long entry\n   * @param entry_stop_re regular expression that ends a long entry\n   */\n  public void set_entry_start_stop(/*@Regex(1)*/ Pattern entry_start_re, Pattern entry_stop_re) {\n    this.entry_start_re = entry_start_re;\n    this.entry_stop_re = entry_stop_re;\n  }\n\n  /**\n   * Puts the specified line back in the input.  Only one line can be\n   * put back.\n   * @param line the line to be put back in the input\n   */\n  // TODO:  This would probably be better implemented with the \"mark\" mechanism\n  // of BufferedReader (which is also in LineNumberReader and FlnReader).\n  public void putback(String line) {\n    assert pushback_line == null\n        : \"push back '\" + line + \"' when '\" + pushback_line + \"' already back\";\n    pushback_line = line;\n  }\n\n  /** Mark the present position in the stream. */\n  @Override\n  public void mark(int readAheadLimit) {\n    throw new Error(\"not yet implemented\");\n  }\n  /** Read a single character. */\n  @Override\n  public int read() {\n    throw new Error(\"not yet implemented\");\n  }\n  /** Read characters into a portion of an array. */\n  @Override\n  public int read(char[] cbuf, int off, int len) {\n    throw new Error(\"not yet implemented\");\n  }\n  /** Reset the stream to the most recent mark. */\n  @Override\n  public void reset() {\n    throw new Error(\"not yet implemented\");\n  }\n  /** Skip characters. */\n  @Override\n  public long skip(long n) {\n    throw new Error(\"not yet implemented\");\n  }\n\n  /**\n   * Simple usage example.\n   * @param args command-line arguments: filename [comment_re [include_re]]\n   * @throws IOException if there is a problem reading a file\n   */\n  public static void main(String[] args) throws IOException {\n\n    if (args.length < 1 || args.length > 3) {\n      System.err.println(\n          \"EntryReader sample program requires 1-3 args: filename [comment_re [include_re]]\");\n      System.exit(1);\n    }\n    String filename = args[0];\n    String comment_re = null;\n    String include_re = null;\n    if (args.length >= 2) {\n      comment_re = args[1];\n      if (!RegexUtil.isRegex(comment_re)) {\n        System.err.println(\n            \"Error parsing comment regex \\\"\"\n                + comment_re\n                + \"\\\": \"\n                + RegexUtil.regexError(comment_re));\n        System.exit(1);\n      }\n    }\n    if (args.length >= 3) {\n      include_re = args[2];\n      if (!RegexUtil.isRegex(include_re, 1)) {\n        System.err.println(\n            \"Error parsing include regex \\\"\"\n                + include_re\n                + \"\\\": \"\n                + RegexUtil.regexError(include_re));\n        System.exit(1);\n      }\n    }\n    EntryReader reader = new EntryReader(filename, comment_re, include_re);\n\n    String line = reader.readLine();\n    while (line != null) {\n      System.out.printf(\"%s: %d: %s%n\", reader.getFileName(), reader.getLineNumber(), line);\n      line = reader.readLine();\n    }\n  }\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "file", "java.io", "File" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "skip", "plume", "EntryReader", "public long skip(long n)" ], [ "read", "java.io", "Reader", "public int read(char[] arg0) throws IOException" ], [ "markSupported", "java.io", "BufferedReader", "public boolean markSupported()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "lines", "java.io", "BufferedReader", "public Stream<String> lines()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getLineNumber", "plume", "EntryReader", "public int getLineNumber()" ], [ "readLine", "java.io", "BufferedReader", "String readLine(boolean arg0, boolean[] arg1) throws IOException" ], [ "ready", "java.io", "BufferedReader", "public boolean ready() throws IOException" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "getFileName", "plume", "EntryReader", "public String getFileName()" ], [ "transferTo", "java.io", "Reader", "public long transferTo(Writer arg0) throws IOException" ], [ "read", "plume", "EntryReader", "public int read(char[] cbuf, int off, int len)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "hasNext", "plume", "EntryReader", "public boolean hasNext()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "read", "java.io", "Reader", "public int read(CharBuffer arg0) throws IOException" ], [ "readLine", "plume", "EntryReader", "public String readLine() throws IOException" ], [ "iterator", "plume", "EntryReader", "public Iterator<String> iterator()" ], [ "next", "java.util", "Iterator", "public abstract E next()" ], [ "get_entry", "plume", "EntryReader", "public Entry get_entry() throws IOException" ], [ "next", "plume", "EntryReader", "public String next()" ], [ "read", "plume", "EntryReader", "public int read()" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "delete", "java.io", "File", "public boolean delete()" ], [ "setReadOnly", "java.io", "File", "public boolean setReadOnly()" ], [ "getAbsoluteFile", "java.io", "File", "public File getAbsoluteFile()" ], [ "equals", "java.io", "File", "public boolean equals(Object arg0)" ], [ "listFiles", "java.io", "File", "public File[] listFiles(FilenameFilter arg0)" ], [ "getUsableSpace", "java.io", "File", "public long getUsableSpace()" ], [ "hashCode", "java.io", "File", "public int hashCode()" ], [ "isAbsolute", "java.io", "File", "public boolean isAbsolute()" ], [ "getCanonicalPath", "java.io", "File", "public String getCanonicalPath() throws IOException" ], [ "canRead", "java.io", "File", "public boolean canRead()" ], [ "createNewFile", "java.io", "File", "public boolean createNewFile() throws IOException" ], [ "setExecutable", "java.io", "File", "public boolean setExecutable(boolean arg0, boolean arg1)" ], [ "toURL", "java.io", "File", "public URL toURL() throws MalformedURLException" ], [ "getTotalSpace", "java.io", "File", "public long getTotalSpace()" ], [ "toPath", "java.io", "File", "public Path toPath()" ], [ "setWritable", "java.io", "File", "public boolean setWritable(boolean arg0)" ], [ "isDirectory", "java.io", "File", "public boolean isDirectory()" ], [ "setReadable", "java.io", "File", "public boolean setReadable(boolean arg0)" ], [ "setExecutable", "java.io", "File", "public boolean setExecutable(boolean arg0)" ], [ "getParentFile", "java.io", "File", "public File getParentFile()" ], [ "lastModified", "java.io", "File", "public long lastModified()" ], [ "getPrefixLength", "java.io", "File", "int getPrefixLength()" ], [ "getFreeSpace", "java.io", "File", "public long getFreeSpace()" ], [ "exists", "java.io", "File", "public boolean exists()" ], [ "length", "java.io", "File", "public long length()" ], [ "listFiles", "java.io", "File", "public File[] listFiles(FileFilter arg0)" ], [ "toURI", "java.io", "File", "public URI toURI()" ], [ "setLastModified", "java.io", "File", "public boolean setLastModified(long arg0)" ], [ "listFiles", "java.io", "File", "public File[] listFiles()" ], [ "getName", "java.io", "File", "public String getName()" ], [ "canWrite", "java.io", "File", "public boolean canWrite()" ], [ "toString", "java.io", "File", "public String toString()" ], [ "getAbsolutePath", "java.io", "File", "public String getAbsolutePath()" ], [ "getPath", "java.io", "File", "public String getPath()" ], [ "setReadable", "java.io", "File", "public boolean setReadable(boolean arg0, boolean arg1)" ], [ "list", "java.io", "File", "public String[] list()" ], [ "getParent", "java.io", "File", "public String getParent()" ], [ "isFile", "java.io", "File", "public boolean isFile()" ], [ "isInvalid", "java.io", "File", "final boolean isInvalid()" ], [ "list", "java.io", "File", "public String[] list(FilenameFilter arg0)" ], [ "compareTo", "java.io", "File", "public int compareTo(File arg0)" ], [ "renameTo", "java.io", "File", "public boolean renameTo(File arg0)" ], [ "canExecute", "java.io", "File", "public boolean canExecute()" ], [ "isHidden", "java.io", "File", "public boolean isHidden()" ], [ "mkdirs", "java.io", "File", "public boolean mkdirs()" ], [ "mkdir", "java.io", "File", "public boolean mkdir()" ], [ "setWritable", "java.io", "File", "public boolean setWritable(boolean arg0, boolean arg1)" ], [ "getCanonicalFile", "java.io", "File", "public File getCanonicalFile() throws IOException" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "entry_start_re", "plume", "EntryReader", "public Pattern entry_start_re = null;" ], [ "entry_stop_re", "plume", "EntryReader", "public Pattern entry_stop_re = null;" ], [ "pushback_line", "plume", "EntryReader", "String pushback_line = null;" ], [ "lock", "java.io", "Reader", "protected Object lock;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 11019,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "EntryReader",
  "javadocTag" : "@throws IOException if there is a problem reading the file",
  "methodJavadoc" : "    /**\n   * Create a new EntryReader starting with the specified file.\n   *\n   *    @param filename   initial file to read\n   *    @param comment_re regular expression that matches comments.\n   *                      Any text that matches comment_re is removed.\n   *                      A line that is entirely a comment is ignored.\n   *    @param include_re regular expression that matches include directives.\n   *                      The expression should define one group that contains\n   *                      the include file name.\n   *\n   * @throws IOException if there is a problem reading the file\n   *\n   * @see #EntryReader(File,String,String)\n   */",
  "methodSourceCode" : "public EntryReader(String filename, /*@Nullable*/\n/*@Regex*/\nString comment_re, /*@Nullable*/\n/*@Regex(1)*/\nString include_re) throws IOException{\n    this(new File(filename), comment_re, include_re);\n}",
  "classJavadoc" : "/**\n * Class that reads \"entries\" from a file.  In the simplest case, entries\n * can be lines.  It supports:\n *   include files,\n *   comments, and\n *   multi-line entries (paragraphs).\n * The syntax of each of these is customizable.\n * <p>\n *\n * Example use:\n * <pre>\n *  // args are filename, comment regexp, include regexp\n *  try (EntryReader er = new EntryReader(filename, \"^#.*\", null)) {\n *    for (String line : er) {\n *      ...\n *    }\n *  } catch (IOException e) {\n *    System.err.println(\"Problem reading \" + filename + \": \" + e.getMessage());\n *    System.exit(2);\n *    throw new Error(\"This can't happen\"); // for definite assignment check\n *  }\n * </pre>\n *\n * @see #get_entry() and @see #set_entry_start_stop(String,String)\n */",
  "classSourceCode" : "package plume;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.io.Reader;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.CharBuffer;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.Stack;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/*>>>\nimport org.checkerframework.checker.lock.qual.*;\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.checker.regex.qual.*;\n*/\n\n// TODO:\n// EntryReader has a public concept of \"short entry\", but I don't think that\n// concept is logically part of EntryReader.  I think it would be better for\n// Lookup to make this decision itself, for instance by checking whether there\n// are any line separators in the entry that it gets back.\n//\n// Here are some useful features that EntryReader should have.\n//  * It should implement some unimplemented methods from LineNumberReader (see\n//    \"not yet implemented\" in this file).\n//  * It should have constructors that take an InputStream or Reader\n//    (in addition to the current BufferedReader, File, and String versions).\n//  * It should have a close method.\n//  * It should automatically close the underlying file/etc. when the\n//    iterator gets to the end (or the end is otherwise reached).\n\n/**\n * Class that reads \"entries\" from a file.  In the simplest case, entries\n * can be lines.  It supports:\n *   include files,\n *   comments, and\n *   multi-line entries (paragraphs).\n * The syntax of each of these is customizable.\n * <p>\n *\n * Example use:\n * <pre>\n *  // args are filename, comment regexp, include regexp\n *  try (EntryReader er = new EntryReader(filename, \"^#.*\", null)) {\n *    for (String line : er) {\n *      ...\n *    }\n *  } catch (IOException e) {\n *    System.err.println(\"Problem reading \" + filename + \": \" + e.getMessage());\n *    System.exit(2);\n *    throw new Error(\"This can't happen\"); // for definite assignment check\n *  }\n * </pre>\n *\n * @see #get_entry() and @see #set_entry_start_stop(String,String)\n */\npublic class EntryReader extends LineNumberReader implements Iterable<String>, Iterator<String> {\n\n  ///\n  /// User configuration variables\n  ///\n\n  /** Regular expression that specifies an include file. */\n  private final /*@Nullable*/ /*@Regex(1)*/ Pattern include_re;\n\n  /** Regular expression that matches a comment. */\n  private final /*@Nullable*/ Pattern comment_re;\n\n  /**\n   * Regular expression that starts a long entry.\n   * <p>\n   * If the first line of an entry matches this regexp, then the entry is\n   * terminated by:  entry_stop_re, another line that matches\n   * entry_start_re (even not following a newline), or the end of the\n   * current file.\n   * <p>\n   * Otherwise, the first line of an entry does NOT match this regexp (or\n   * the regexp is null), in which case the entry is terminated by a blank\n   * line or the end of the current file.\n   */\n  public /*@MonotonicNonNull*/ /*@Regex(1)*/ Pattern entry_start_re = null;\n\n  /**\n   * @see #entry_start_re\n   */\n  public /*@MonotonicNonNull*/ Pattern entry_stop_re = null;\n\n  ///\n  /// Internal implementation variables\n  ///\n\n  /** Stack of readers.  Used to support include files. */\n  private final Stack<FlnReader> readers = new Stack<FlnReader>();\n\n  /** Line that is pushed back to be reread. */\n  /*@Nullable*/ String pushback_line = null;\n\n  /** Platform-specific line separator. */\n  private static final String lineSep = System.getProperty(\"line.separator\");\n\n  ///\n  /// Helper classes\n  ///\n\n  /**\n   * Like LineNumberReader, but also has a filename field.\n   * \"FlnReader\" stands for \"Filename and Line Number Reader\".\n   */\n  private static class FlnReader extends LineNumberReader {\n    /** The file being read. */\n    public String filename;\n\n    /**\n     * Create a FlnReader.\n     * @param reader source from which to read entries\n     * @param filename file name corresponding to reader, for use in error messages.\n     *   Must be non-null; if there isn't a name, clients should provide a dummy value.\n     */\n    public FlnReader(Reader reader, String filename) {\n      super(reader);\n      this.filename = filename;\n    }\n\n    /**\n     * Create a FlnReader.\n     * @param filename file from which to read\n     */\n    public FlnReader(String filename) throws IOException {\n      super(UtilMDE.fileReader(filename));\n      this.filename = filename;\n    }\n  }\n\n  /** Descriptor for an entry (paragraph). */\n  public static class Entry {\n    /** First line of the entry. */\n    public String first_line;\n    /** Complete body of the entry including the first line. */\n    public String body;\n    /** True if this is a short entry (blank-line-separated). */\n    boolean short_entry;\n    /** Filename in which the entry was found. */\n    String filename;\n    /** Line number of first line of entry. */\n    long line_number;\n\n    /** Create an entry.\n     * @param first_line first line of the entry\n     * @param body complete body of the entry including the first line\n     * @param short_entry true if this is a short entry (blank-line-separated)\n     * @param filename filename in which the entry was found\n     * @param line_number line number of first line of entry\n     */\n    Entry(String first_line, String body, String filename, long line_number, boolean short_entry) {\n      this.first_line = first_line;\n      this.body = body;\n      this.filename = filename;\n      this.line_number = line_number;\n      this.short_entry = short_entry;\n    }\n\n    /**\n     * Return a substring of the entry body that matches the specified\n     * regular expression.  If no match is found, returns the first_line.\n     * @param re regex to match\n     * @return a substring that matches re\n     */\n    String get_description(/*@Nullable*/ Pattern re) {\n\n      if (re == null) {\n        return first_line;\n      }\n\n      Matcher descr = re.matcher(body);\n      if (descr.find()) {\n        return descr.group();\n      } else {\n        return first_line;\n      }\n    }\n  }\n\n  ///\n  /// Constructors\n  ///\n\n  /// Inputstream and charset constructors\n\n  /** Create a EntryReader that uses the given character set.\n   * @throws UnsupportedEncodingException if the charset encoding is not supported\n   * @param in source from which to read entries\n   * @param charsetName the character set to use\n   * @param filename non-null file name for stream being read\n   * @param comment_re_string regular expression that matches comments.\n   *                      Any text that matches comment_re is removed.\n   *                      A line that is entirely a comment is ignored.\n   * @param include_re_string regular expression that matches include directives.\n   *                      The expression should define one group that contains\n   *                      the include file name.\n   * @see #EntryReader(InputStream,String,String,String)\n   */\n  public EntryReader(\n      InputStream in,\n      String charsetName,\n      String filename,\n      /*@Nullable*/ /*@Regex*/ String comment_re_string,\n      /*@Nullable*/ /*@Regex(1)*/ String include_re_string)\n      throws UnsupportedEncodingException {\n    this(new InputStreamReader(in, charsetName), filename, comment_re_string, include_re_string);\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param in the InputStream\n   * @param charsetName the character set to use\n   * @param filename the file name\n   * @throws UnsupportedEncodingException if the charset encoding is not supported\n   * @see #EntryReader(InputStream,String,String,String)\n   */\n  public EntryReader(InputStream in, String charsetName, String filename)\n      throws UnsupportedEncodingException {\n    this(in, charsetName, filename, null, null);\n  }\n\n  /// Inputstream (no charset) constructors\n\n  /**\n   * Create a EntryReader.\n   *\n   *    @param in source from which to read entries\n   *    @param filename non-null file name for stream being read\n   *    @param comment_re_string regular expression that matches comments.\n   *                      Any text that matches comment_re is removed.\n   *                      A line that is entirely a comment is ignored.\n   *    @param include_re_string regular expression that matches include directives.\n   *                      The expression should define one group that contains\n   *                      the include file name.\n   */\n  public EntryReader(\n      InputStream in,\n      String filename,\n      /*@Nullable*/ /*@Regex*/ String comment_re_string,\n      /*@Nullable*/ /*@Regex(1)*/ String include_re_string) {\n    this(new InputStreamReader(in), filename, comment_re_string, include_re_string);\n  }\n\n  /**\n   * Create a EntryReader that uses the default character set and does not\n   * support comments or include directives.\n   * @param in the InputStream\n   * @param filename the file name\n   * @see #EntryReader(InputStream,String,String,String,String)\n   */\n  public EntryReader(InputStream in, String filename) {\n    this(in, filename, null, null);\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param in the InputStream\n   * @see #EntryReader(InputStream,String,String,String)\n   */\n  public EntryReader(InputStream in) {\n    this(in, \"(InputStream)\", null, null);\n  }\n\n  /** A dummy Reader to be used when null is not acceptable. */\n  private static class DummyReader extends Reader {\n    @Override\n    public void close(/*>>>@GuardSatisfied DummyReader this*/) {\n      // No error, because closing is OK if it appears in try-with-resources.\n      // Later maybe create two versions (with and without exception here).\n    }\n\n    @Override\n    public void mark(int readAheadLimit) {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public boolean markSupported() {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public int read() {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public int read(char[] cbuf) {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public int read(char[] cbuf, int off, int len) {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public int read(CharBuffer target) {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public boolean ready() {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public void reset() {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public long skip(long n) {\n      throw new Error(\"DummyReader\");\n    }\n  }\n\n  /**\n   * Create a EntryReader.\n   *\n   *    @param reader source from which to read entries\n   *    @param filename file name corresponding to reader, for use in error messages\n   *    @param comment_re_string regular expression that matches comments.\n   *                      Any text that matches comment_re is removed.\n   *                      A line that is entirely a comment is ignored\n   *    @param include_re_string regular expression that matches include directives.\n   *                      The expression should define one group that contains\n   *                      the include file name\n   */\n  public EntryReader(\n      Reader reader,\n      String filename,\n      /*@Nullable*/ /*@Regex*/ String comment_re_string,\n      /*@Nullable*/ /*@Regex(1)*/ String include_re_string) {\n    // we won't use superclass methods, but passing null as an argument\n    // leads to a NullPointerException.\n    super(new DummyReader());\n    readers.push(new FlnReader(reader, filename));\n    if (comment_re_string == null) {\n      comment_re = null;\n    } else {\n      comment_re = Pattern.compile(comment_re_string);\n    }\n    if (include_re_string == null) {\n      include_re = null;\n    } else {\n      include_re = Pattern.compile(include_re_string);\n    }\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param reader source from which to read entries\n   * @see #EntryReader(Reader,String,String,String)\n   */\n  public EntryReader(Reader reader) {\n    this(reader, reader.toString(), null, null);\n  }\n\n  /// File Constructors\n\n  /**\n   * Create an EntryReader.\n   *\n   *    @param file       initial file to read\n   *    @param comment_re regular expression that matches comments.\n   *                      Any text that matches comment_re is removed.\n   *                      A line that is entirely a comment is ignored.\n   *    @param include_re regular expression that matches include directives.\n   *                      The expression should define one group that contains\n   *                      the include file name.\n   * @throws IOException if there is a problem reading the file\n   */\n  public EntryReader(\n      File file,\n      /*@Nullable*/ /*@Regex*/ String comment_re,\n      /*@Nullable*/ /*@Regex(1)*/ String include_re)\n      throws IOException {\n    this(UtilMDE.fileReader(file), file.toString(), comment_re, include_re);\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param file the file to read\n   * @throws IOException if there is a problem reading the file\n   * @see #EntryReader(File,String,String)\n   */\n  public EntryReader(File file) throws IOException {\n    this(file, null, null);\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param file the file to read\n   * @param charsetName the character set to use\n   * @throws IOException if there is a problem reading the file\n   * @see #EntryReader(File,String,String)\n   */\n  public EntryReader(File file, String charsetName) throws IOException {\n    this(UtilMDE.fileInputStream(file), charsetName, file.toString(), null, null);\n  }\n\n  /// Filename constructors\n\n  /**\n   * Create a new EntryReader starting with the specified file.\n   *\n   *    @param filename   initial file to read\n   *    @param comment_re regular expression that matches comments.\n   *                      Any text that matches comment_re is removed.\n   *                      A line that is entirely a comment is ignored.\n   *    @param include_re regular expression that matches include directives.\n   *                      The expression should define one group that contains\n   *                      the include file name.\n   *\n   * @throws IOException if there is a problem reading the file\n   *\n   * @see #EntryReader(File,String,String)\n   */\n  public EntryReader(\n      String filename,\n      /*@Nullable*/ /*@Regex*/ String comment_re,\n      /*@Nullable*/ /*@Regex(1)*/ String include_re)\n      throws IOException {\n    this(new File(filename), comment_re, include_re);\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param filename source from which to read entries\n   * @throws IOException if there is a problem reading the file\n   * @see #EntryReader(String,String,String)\n   */\n  public EntryReader(String filename) throws IOException {\n    this(filename, null, null);\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param filename source from which to read entries\n   * @param charsetName the character set to use\n   * @throws IOException if there is a problem reading the file\n   * @see #EntryReader(String,String,String)\n   */\n  public EntryReader(String filename, String charsetName) throws IOException {\n    this(new FileInputStream(filename), charsetName, filename, null, null);\n  }\n\n  ///\n  /// Methods\n  ///\n\n  /**\n   * Read a line, ignoring comments and processing includes.  Note that\n   * a line that is completely a comment is completely ignored (and\n   * not returned as a blank line).  Returns null at end of file.\n   * @return the string that was read, or null at end of file\n   */\n  @Override\n  public /*@Nullable*/ String readLine() throws IOException {\n\n    // System.out.printf (\"Entering size = %d%n\", readers.size());\n\n    // If a line has been pushed back, return it instead\n    if (pushback_line != null) {\n      String line = pushback_line;\n      pushback_line = null;\n      return line;\n    }\n\n    String line = get_next_line();\n    if (comment_re != null) {\n      while (line != null) {\n        Matcher cmatch = comment_re.matcher(line);\n        if (cmatch.find()) {\n          line = cmatch.replaceFirst(\"\");\n          if (line.length() > 0) {\n            break;\n          }\n        } else {\n          break;\n        }\n        line = get_next_line();\n        // System.out.printf (\"get_next_line = %s%n\", line);\n      }\n    }\n\n    if (line == null) {\n      return null;\n    }\n\n    // Handle include files.  Non-absolute pathnames are relative\n    // to the including file (the current file)\n    if (include_re != null) {\n      Matcher m = include_re.matcher(line);\n      if (m.matches()) {\n        String filename_string = m.group(1);\n        if (filename_string == null) {\n          throw new Error(\n              String.format(\"include_re (%s) does not capture group 1 in %s\", include_re, line));\n        }\n        File filename = new File(UtilMDE.expandFilename(filename_string));\n        // System.out.printf (\"Trying to include filename %s%n\", filename);\n        if (!filename.isAbsolute()) {\n          FlnReader reader = readers.peek();\n          File current_filename = new File(reader.filename);\n          File current_parent = current_filename.getParentFile();\n          filename = new File(current_parent, filename.toString());\n          // System.out.printf (\"absolute filename = %s %s %s%n\",\n          //                     current_filename, current_parent, filename);\n        }\n        readers.push(new FlnReader(filename.getAbsolutePath()));\n        return readLine();\n      }\n    }\n\n    // System.out.printf (\"Returning [%d] '%s'%n\", readers.size(), line);\n    return (line);\n  }\n\n  /**\n   * Return a line-by-line iterator for this file.\n   * <p>\n   *\n   * <b>Warning:</b> This does not return a fresh iterator each time.  The\n   * iterator is a singleton, the same one is returned each time, and a new\n   * one can never be created after it is exhausted.\n   *\n   * @return a line-by-line iterator for this file\n   */\n  @Override\n  public Iterator<String> iterator() {\n    return this;\n  }\n\n  /**\n   * Returns whether or not there is another line to read.  Any IOExceptions\n   * are turned into errors (because the definition of hasNext() in Iterator\n   * doesn't throw any exceptions).\n   * @return whether there is another line to read\n   */\n  @Override\n  public boolean hasNext() {\n    if (pushback_line != null) {\n      return true;\n    }\n\n    String line = null;\n    try {\n      line = readLine();\n    } catch (IOException e) {\n      throw new Error(\"unexpected IOException: \", e);\n    }\n\n    if (line == null) {\n      return false;\n    }\n\n    putback(line);\n    return true;\n  }\n\n  /**\n   * Return the next line in the multi-file.\n   * @return the next line in the multi-file\n   * Throws NoSuchElementException at end of file\n   */\n  @Override\n  public String next() {\n    try {\n      String result = readLine();\n      if (result != null) {\n        return result;\n      } else {\n        throw new NoSuchElementException();\n      }\n    } catch (IOException e) {\n      throw new Error(\"unexpected IOException\", e);\n    }\n  }\n\n  /** remove() is not supported. */\n  @Override\n  public void remove() {\n    throw new UnsupportedOperationException(\"can't remove lines from file\");\n  }\n\n  /**\n   * Returns the next entry (paragraph) in the file.  Entries are separated\n   * by blank lines unless the entry started with {@link #entry_start_re}\n   * (see {@link #set_entry_start_stop}).  If no more entries are\n   * available, returns null.\n   * @return the next entry (paragraph) in the file\n   * @throws IOException if there is a problem reading the file\n   */\n  public /*@Nullable*/ Entry get_entry() throws IOException {\n\n    // Skip any preceding blank lines\n    String line = readLine();\n    while ((line != null) && (line.trim().length() == 0)) {\n      line = readLine();\n    }\n    if (line == null) {\n      return (null);\n    }\n\n    StringBuilder body = new StringBuilder(10000);\n    Entry entry = null;\n    String filename = getFileName();\n    long line_number = getLineNumber();\n\n    // If first line matches entry_start_re, this is a long entry.\n    /*@Regex(1)*/ Matcher entry_match = null;\n    if (entry_start_re != null) {\n      entry_match = entry_start_re.matcher(line);\n    }\n    if ((entry_match != null) && entry_match.find()) {\n      assert entry_start_re != null : \"@AssumeAssertion(nullness): dependent: entry_match != null\";\n      assert entry_stop_re != null\n          : \"@AssumeAssertion(nullness): dependent: entry_start_re != null\";\n\n      // Remove entry match from the line\n      if (entry_match.groupCount() > 0) {\n        @SuppressWarnings(\n            \"nullness\") // dependent: just checked that group 1 exists via groupCount(); https://code.google.com/p/checker-framework/issues/detail?id=291\n        /*@NonNull*/ String match_group_1 = entry_match.group(1);\n        line = entry_match.replaceFirst(match_group_1);\n      }\n\n      // Description is the first line\n      String description = line;\n\n      // Read until we find the termination of the entry\n      Matcher end_entry_match = entry_stop_re.matcher(line);\n      while ((line != null)\n          && !entry_match.find()\n          && !end_entry_match.find()\n          && filename.equals(getFileName())) {\n        body.append(line);\n        body.append(lineSep);\n        line = readLine();\n        if (line == null) {\n          break; // end of file serves as entry terminator\n        }\n        entry_match = entry_start_re.matcher(line);\n        end_entry_match = entry_stop_re.matcher(line);\n      }\n\n      // If this entry was terminated by the start of the next one,\n      // put that line back\n      if ((line != null) && (entry_match.find(0) || !filename.equals(getFileName()))) {\n        putback(line);\n      }\n\n      entry = new Entry(description, body.toString(), filename, line_number, false);\n\n    } else { // blank-separated entry\n\n      String description = line;\n\n      // Read until we find another blank line\n      while ((line != null) && (line.trim().length() != 0) && filename.equals(getFileName())) {\n        body.append(line);\n        body.append(lineSep);\n        line = readLine();\n      }\n\n      // If this entry was terminated by the start of a new input file\n      // put that line back\n      if ((line != null) && !filename.equals(getFileName())) {\n        putback(line);\n      }\n\n      entry = new Entry(description, body.toString(), filename, line_number, true);\n    }\n\n    return (entry);\n  }\n\n  /**\n   * Reads the next line from the current reader.  If EOF is encountered\n   * pop out to the next reader.  Returns null if there is no more input.\n   * @return next line from the reader, or null if there is no more input\n   */\n  private /*@Nullable*/ String get_next_line() throws IOException {\n\n    if (readers.size() == 0) {\n      return (null);\n    }\n\n    FlnReader ri1 = readers.peek();\n    String line = ri1.readLine();\n    while (line == null) {\n      readers.pop();\n      if (readers.empty()) {\n        return (null);\n      }\n      FlnReader ri2 = readers.peek();\n      line = ri2.readLine();\n    }\n    return (line);\n  }\n\n  /**\n   * Returns the current filename.\n   * @return the current filename\n   */\n  public String getFileName() {\n    FlnReader ri = readers.peek();\n    if (ri == null) {\n      throw new Error(\"Past end of input\");\n    }\n    return ri.filename;\n  }\n\n  /**\n   * Return the current line number in the current file.\n   * @return the current line number\n   */\n  @Override\n  public int getLineNumber() {\n    FlnReader ri = readers.peek();\n    if (ri == null) {\n      throw new Error(\"Past end of input\");\n    }\n    return ri.getLineNumber();\n  }\n\n  /** Set the current line number in the current file.\n   * @param lineNumber new line number for the current file\n   */\n  @Override\n  public void setLineNumber(int lineNumber) {\n    FlnReader ri = readers.peek();\n    if (ri == null) {\n      throw new Error(\"Past end of input\");\n    }\n    ri.setLineNumber(lineNumber);\n  }\n\n  /**\n   * Set the regular expressions for the start and stop of long\n   * entries (multiple lines that are read as a group by get_entry()).\n   * @param entry_start_re regular expression that starts a long entry\n   * @param entry_stop_re regular expression that ends a long entry\n   */\n  public void set_entry_start_stop(\n      /*@Regex(1)*/ String entry_start_re, /*@Regex*/ String entry_stop_re) {\n    this.entry_start_re = Pattern.compile(entry_start_re);\n    this.entry_stop_re = Pattern.compile(entry_stop_re);\n  }\n\n  /**\n   * Set the regular expressions for the start and stop of long\n   * entries (multiple lines that are read as a group by get_entry()).\n   * @param entry_start_re regular expression that starts a long entry\n   * @param entry_stop_re regular expression that ends a long entry\n   */\n  public void set_entry_start_stop(/*@Regex(1)*/ Pattern entry_start_re, Pattern entry_stop_re) {\n    this.entry_start_re = entry_start_re;\n    this.entry_stop_re = entry_stop_re;\n  }\n\n  /**\n   * Puts the specified line back in the input.  Only one line can be\n   * put back.\n   * @param line the line to be put back in the input\n   */\n  // TODO:  This would probably be better implemented with the \"mark\" mechanism\n  // of BufferedReader (which is also in LineNumberReader and FlnReader).\n  public void putback(String line) {\n    assert pushback_line == null\n        : \"push back '\" + line + \"' when '\" + pushback_line + \"' already back\";\n    pushback_line = line;\n  }\n\n  /** Mark the present position in the stream. */\n  @Override\n  public void mark(int readAheadLimit) {\n    throw new Error(\"not yet implemented\");\n  }\n  /** Read a single character. */\n  @Override\n  public int read() {\n    throw new Error(\"not yet implemented\");\n  }\n  /** Read characters into a portion of an array. */\n  @Override\n  public int read(char[] cbuf, int off, int len) {\n    throw new Error(\"not yet implemented\");\n  }\n  /** Reset the stream to the most recent mark. */\n  @Override\n  public void reset() {\n    throw new Error(\"not yet implemented\");\n  }\n  /** Skip characters. */\n  @Override\n  public long skip(long n) {\n    throw new Error(\"not yet implemented\");\n  }\n\n  /**\n   * Simple usage example.\n   * @param args command-line arguments: filename [comment_re [include_re]]\n   * @throws IOException if there is a problem reading a file\n   */\n  public static void main(String[] args) throws IOException {\n\n    if (args.length < 1 || args.length > 3) {\n      System.err.println(\n          \"EntryReader sample program requires 1-3 args: filename [comment_re [include_re]]\");\n      System.exit(1);\n    }\n    String filename = args[0];\n    String comment_re = null;\n    String include_re = null;\n    if (args.length >= 2) {\n      comment_re = args[1];\n      if (!RegexUtil.isRegex(comment_re)) {\n        System.err.println(\n            \"Error parsing comment regex \\\"\"\n                + comment_re\n                + \"\\\": \"\n                + RegexUtil.regexError(comment_re));\n        System.exit(1);\n      }\n    }\n    if (args.length >= 3) {\n      include_re = args[2];\n      if (!RegexUtil.isRegex(include_re, 1)) {\n        System.err.println(\n            \"Error parsing include regex \\\"\"\n                + include_re\n                + \"\\\": \"\n                + RegexUtil.regexError(include_re));\n        System.exit(1);\n      }\n    }\n    EntryReader reader = new EntryReader(filename, comment_re, include_re);\n\n    String line = reader.readLine();\n    while (line != null) {\n      System.out.printf(\"%s: %d: %s%n\", reader.getFileName(), reader.getLineNumber(), line);\n      line = reader.readLine();\n    }\n  }\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "filename", "java.lang", "String" ], [ "comment_re", "java.lang", "String" ], [ "include_re", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "next", "java.util", "Iterator", "public abstract E next()" ], [ "getLineNumber", "plume", "EntryReader", "public int getLineNumber()" ], [ "skip", "plume", "EntryReader", "public long skip(long n)" ], [ "read", "java.io", "Reader", "public int read(char[] arg0) throws IOException" ], [ "ready", "java.io", "BufferedReader", "public boolean ready() throws IOException" ], [ "iterator", "plume", "EntryReader", "public Iterator<String> iterator()" ], [ "lines", "java.io", "BufferedReader", "public Stream<String> lines()" ], [ "markSupported", "java.io", "BufferedReader", "public boolean markSupported()" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "readLine", "java.io", "BufferedReader", "String readLine(boolean arg0, boolean[] arg1) throws IOException" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "get_entry", "plume", "EntryReader", "public Entry get_entry() throws IOException" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "read", "java.io", "Reader", "public int read(CharBuffer arg0) throws IOException" ], [ "getFileName", "plume", "EntryReader", "public String getFileName()" ], [ "read", "plume", "EntryReader", "public int read(char[] cbuf, int off, int len)" ], [ "hasNext", "plume", "EntryReader", "public boolean hasNext()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "readLine", "plume", "EntryReader", "public String readLine() throws IOException" ], [ "transferTo", "java.io", "Reader", "public long transferTo(Writer arg0) throws IOException" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "read", "plume", "EntryReader", "public int read()" ], [ "next", "plume", "EntryReader", "public String next()" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "length", "java.lang", "String", "public int length()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "entry_start_re", "plume", "EntryReader", "public Pattern entry_start_re = null;" ], [ "entry_stop_re", "plume", "EntryReader", "public Pattern entry_stop_re = null;" ], [ "pushback_line", "plume", "EntryReader", "String pushback_line = null;" ], [ "lock", "java.io", "Reader", "protected Object lock;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 11024,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "EntryReader",
  "javadocTag" : "@throws IOException if there is a problem reading the file",
  "methodJavadoc" : "    /** Create a EntryReader that does not support comments or include directives.\n   * @param filename source from which to read entries\n   * @param charsetName the character set to use\n   * @throws IOException if there is a problem reading the file\n   * @see #EntryReader(String,String,String)\n   */",
  "methodSourceCode" : "public EntryReader(String filename, String charsetName) throws IOException{\n    this(new FileInputStream(filename), charsetName, filename, null, null);\n}",
  "classJavadoc" : "/**\n * Class that reads \"entries\" from a file.  In the simplest case, entries\n * can be lines.  It supports:\n *   include files,\n *   comments, and\n *   multi-line entries (paragraphs).\n * The syntax of each of these is customizable.\n * <p>\n *\n * Example use:\n * <pre>\n *  // args are filename, comment regexp, include regexp\n *  try (EntryReader er = new EntryReader(filename, \"^#.*\", null)) {\n *    for (String line : er) {\n *      ...\n *    }\n *  } catch (IOException e) {\n *    System.err.println(\"Problem reading \" + filename + \": \" + e.getMessage());\n *    System.exit(2);\n *    throw new Error(\"This can't happen\"); // for definite assignment check\n *  }\n * </pre>\n *\n * @see #get_entry() and @see #set_entry_start_stop(String,String)\n */",
  "classSourceCode" : "package plume;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.io.Reader;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.CharBuffer;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.Stack;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/*>>>\nimport org.checkerframework.checker.lock.qual.*;\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.checker.regex.qual.*;\n*/\n\n// TODO:\n// EntryReader has a public concept of \"short entry\", but I don't think that\n// concept is logically part of EntryReader.  I think it would be better for\n// Lookup to make this decision itself, for instance by checking whether there\n// are any line separators in the entry that it gets back.\n//\n// Here are some useful features that EntryReader should have.\n//  * It should implement some unimplemented methods from LineNumberReader (see\n//    \"not yet implemented\" in this file).\n//  * It should have constructors that take an InputStream or Reader\n//    (in addition to the current BufferedReader, File, and String versions).\n//  * It should have a close method.\n//  * It should automatically close the underlying file/etc. when the\n//    iterator gets to the end (or the end is otherwise reached).\n\n/**\n * Class that reads \"entries\" from a file.  In the simplest case, entries\n * can be lines.  It supports:\n *   include files,\n *   comments, and\n *   multi-line entries (paragraphs).\n * The syntax of each of these is customizable.\n * <p>\n *\n * Example use:\n * <pre>\n *  // args are filename, comment regexp, include regexp\n *  try (EntryReader er = new EntryReader(filename, \"^#.*\", null)) {\n *    for (String line : er) {\n *      ...\n *    }\n *  } catch (IOException e) {\n *    System.err.println(\"Problem reading \" + filename + \": \" + e.getMessage());\n *    System.exit(2);\n *    throw new Error(\"This can't happen\"); // for definite assignment check\n *  }\n * </pre>\n *\n * @see #get_entry() and @see #set_entry_start_stop(String,String)\n */\npublic class EntryReader extends LineNumberReader implements Iterable<String>, Iterator<String> {\n\n  ///\n  /// User configuration variables\n  ///\n\n  /** Regular expression that specifies an include file. */\n  private final /*@Nullable*/ /*@Regex(1)*/ Pattern include_re;\n\n  /** Regular expression that matches a comment. */\n  private final /*@Nullable*/ Pattern comment_re;\n\n  /**\n   * Regular expression that starts a long entry.\n   * <p>\n   * If the first line of an entry matches this regexp, then the entry is\n   * terminated by:  entry_stop_re, another line that matches\n   * entry_start_re (even not following a newline), or the end of the\n   * current file.\n   * <p>\n   * Otherwise, the first line of an entry does NOT match this regexp (or\n   * the regexp is null), in which case the entry is terminated by a blank\n   * line or the end of the current file.\n   */\n  public /*@MonotonicNonNull*/ /*@Regex(1)*/ Pattern entry_start_re = null;\n\n  /**\n   * @see #entry_start_re\n   */\n  public /*@MonotonicNonNull*/ Pattern entry_stop_re = null;\n\n  ///\n  /// Internal implementation variables\n  ///\n\n  /** Stack of readers.  Used to support include files. */\n  private final Stack<FlnReader> readers = new Stack<FlnReader>();\n\n  /** Line that is pushed back to be reread. */\n  /*@Nullable*/ String pushback_line = null;\n\n  /** Platform-specific line separator. */\n  private static final String lineSep = System.getProperty(\"line.separator\");\n\n  ///\n  /// Helper classes\n  ///\n\n  /**\n   * Like LineNumberReader, but also has a filename field.\n   * \"FlnReader\" stands for \"Filename and Line Number Reader\".\n   */\n  private static class FlnReader extends LineNumberReader {\n    /** The file being read. */\n    public String filename;\n\n    /**\n     * Create a FlnReader.\n     * @param reader source from which to read entries\n     * @param filename file name corresponding to reader, for use in error messages.\n     *   Must be non-null; if there isn't a name, clients should provide a dummy value.\n     */\n    public FlnReader(Reader reader, String filename) {\n      super(reader);\n      this.filename = filename;\n    }\n\n    /**\n     * Create a FlnReader.\n     * @param filename file from which to read\n     */\n    public FlnReader(String filename) throws IOException {\n      super(UtilMDE.fileReader(filename));\n      this.filename = filename;\n    }\n  }\n\n  /** Descriptor for an entry (paragraph). */\n  public static class Entry {\n    /** First line of the entry. */\n    public String first_line;\n    /** Complete body of the entry including the first line. */\n    public String body;\n    /** True if this is a short entry (blank-line-separated). */\n    boolean short_entry;\n    /** Filename in which the entry was found. */\n    String filename;\n    /** Line number of first line of entry. */\n    long line_number;\n\n    /** Create an entry.\n     * @param first_line first line of the entry\n     * @param body complete body of the entry including the first line\n     * @param short_entry true if this is a short entry (blank-line-separated)\n     * @param filename filename in which the entry was found\n     * @param line_number line number of first line of entry\n     */\n    Entry(String first_line, String body, String filename, long line_number, boolean short_entry) {\n      this.first_line = first_line;\n      this.body = body;\n      this.filename = filename;\n      this.line_number = line_number;\n      this.short_entry = short_entry;\n    }\n\n    /**\n     * Return a substring of the entry body that matches the specified\n     * regular expression.  If no match is found, returns the first_line.\n     * @param re regex to match\n     * @return a substring that matches re\n     */\n    String get_description(/*@Nullable*/ Pattern re) {\n\n      if (re == null) {\n        return first_line;\n      }\n\n      Matcher descr = re.matcher(body);\n      if (descr.find()) {\n        return descr.group();\n      } else {\n        return first_line;\n      }\n    }\n  }\n\n  ///\n  /// Constructors\n  ///\n\n  /// Inputstream and charset constructors\n\n  /** Create a EntryReader that uses the given character set.\n   * @throws UnsupportedEncodingException if the charset encoding is not supported\n   * @param in source from which to read entries\n   * @param charsetName the character set to use\n   * @param filename non-null file name for stream being read\n   * @param comment_re_string regular expression that matches comments.\n   *                      Any text that matches comment_re is removed.\n   *                      A line that is entirely a comment is ignored.\n   * @param include_re_string regular expression that matches include directives.\n   *                      The expression should define one group that contains\n   *                      the include file name.\n   * @see #EntryReader(InputStream,String,String,String)\n   */\n  public EntryReader(\n      InputStream in,\n      String charsetName,\n      String filename,\n      /*@Nullable*/ /*@Regex*/ String comment_re_string,\n      /*@Nullable*/ /*@Regex(1)*/ String include_re_string)\n      throws UnsupportedEncodingException {\n    this(new InputStreamReader(in, charsetName), filename, comment_re_string, include_re_string);\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param in the InputStream\n   * @param charsetName the character set to use\n   * @param filename the file name\n   * @throws UnsupportedEncodingException if the charset encoding is not supported\n   * @see #EntryReader(InputStream,String,String,String)\n   */\n  public EntryReader(InputStream in, String charsetName, String filename)\n      throws UnsupportedEncodingException {\n    this(in, charsetName, filename, null, null);\n  }\n\n  /// Inputstream (no charset) constructors\n\n  /**\n   * Create a EntryReader.\n   *\n   *    @param in source from which to read entries\n   *    @param filename non-null file name for stream being read\n   *    @param comment_re_string regular expression that matches comments.\n   *                      Any text that matches comment_re is removed.\n   *                      A line that is entirely a comment is ignored.\n   *    @param include_re_string regular expression that matches include directives.\n   *                      The expression should define one group that contains\n   *                      the include file name.\n   */\n  public EntryReader(\n      InputStream in,\n      String filename,\n      /*@Nullable*/ /*@Regex*/ String comment_re_string,\n      /*@Nullable*/ /*@Regex(1)*/ String include_re_string) {\n    this(new InputStreamReader(in), filename, comment_re_string, include_re_string);\n  }\n\n  /**\n   * Create a EntryReader that uses the default character set and does not\n   * support comments or include directives.\n   * @param in the InputStream\n   * @param filename the file name\n   * @see #EntryReader(InputStream,String,String,String,String)\n   */\n  public EntryReader(InputStream in, String filename) {\n    this(in, filename, null, null);\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param in the InputStream\n   * @see #EntryReader(InputStream,String,String,String)\n   */\n  public EntryReader(InputStream in) {\n    this(in, \"(InputStream)\", null, null);\n  }\n\n  /** A dummy Reader to be used when null is not acceptable. */\n  private static class DummyReader extends Reader {\n    @Override\n    public void close(/*>>>@GuardSatisfied DummyReader this*/) {\n      // No error, because closing is OK if it appears in try-with-resources.\n      // Later maybe create two versions (with and without exception here).\n    }\n\n    @Override\n    public void mark(int readAheadLimit) {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public boolean markSupported() {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public int read() {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public int read(char[] cbuf) {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public int read(char[] cbuf, int off, int len) {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public int read(CharBuffer target) {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public boolean ready() {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public void reset() {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public long skip(long n) {\n      throw new Error(\"DummyReader\");\n    }\n  }\n\n  /**\n   * Create a EntryReader.\n   *\n   *    @param reader source from which to read entries\n   *    @param filename file name corresponding to reader, for use in error messages\n   *    @param comment_re_string regular expression that matches comments.\n   *                      Any text that matches comment_re is removed.\n   *                      A line that is entirely a comment is ignored\n   *    @param include_re_string regular expression that matches include directives.\n   *                      The expression should define one group that contains\n   *                      the include file name\n   */\n  public EntryReader(\n      Reader reader,\n      String filename,\n      /*@Nullable*/ /*@Regex*/ String comment_re_string,\n      /*@Nullable*/ /*@Regex(1)*/ String include_re_string) {\n    // we won't use superclass methods, but passing null as an argument\n    // leads to a NullPointerException.\n    super(new DummyReader());\n    readers.push(new FlnReader(reader, filename));\n    if (comment_re_string == null) {\n      comment_re = null;\n    } else {\n      comment_re = Pattern.compile(comment_re_string);\n    }\n    if (include_re_string == null) {\n      include_re = null;\n    } else {\n      include_re = Pattern.compile(include_re_string);\n    }\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param reader source from which to read entries\n   * @see #EntryReader(Reader,String,String,String)\n   */\n  public EntryReader(Reader reader) {\n    this(reader, reader.toString(), null, null);\n  }\n\n  /// File Constructors\n\n  /**\n   * Create an EntryReader.\n   *\n   *    @param file       initial file to read\n   *    @param comment_re regular expression that matches comments.\n   *                      Any text that matches comment_re is removed.\n   *                      A line that is entirely a comment is ignored.\n   *    @param include_re regular expression that matches include directives.\n   *                      The expression should define one group that contains\n   *                      the include file name.\n   * @throws IOException if there is a problem reading the file\n   */\n  public EntryReader(\n      File file,\n      /*@Nullable*/ /*@Regex*/ String comment_re,\n      /*@Nullable*/ /*@Regex(1)*/ String include_re)\n      throws IOException {\n    this(UtilMDE.fileReader(file), file.toString(), comment_re, include_re);\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param file the file to read\n   * @throws IOException if there is a problem reading the file\n   * @see #EntryReader(File,String,String)\n   */\n  public EntryReader(File file) throws IOException {\n    this(file, null, null);\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param file the file to read\n   * @param charsetName the character set to use\n   * @throws IOException if there is a problem reading the file\n   * @see #EntryReader(File,String,String)\n   */\n  public EntryReader(File file, String charsetName) throws IOException {\n    this(UtilMDE.fileInputStream(file), charsetName, file.toString(), null, null);\n  }\n\n  /// Filename constructors\n\n  /**\n   * Create a new EntryReader starting with the specified file.\n   *\n   *    @param filename   initial file to read\n   *    @param comment_re regular expression that matches comments.\n   *                      Any text that matches comment_re is removed.\n   *                      A line that is entirely a comment is ignored.\n   *    @param include_re regular expression that matches include directives.\n   *                      The expression should define one group that contains\n   *                      the include file name.\n   *\n   * @throws IOException if there is a problem reading the file\n   *\n   * @see #EntryReader(File,String,String)\n   */\n  public EntryReader(\n      String filename,\n      /*@Nullable*/ /*@Regex*/ String comment_re,\n      /*@Nullable*/ /*@Regex(1)*/ String include_re)\n      throws IOException {\n    this(new File(filename), comment_re, include_re);\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param filename source from which to read entries\n   * @throws IOException if there is a problem reading the file\n   * @see #EntryReader(String,String,String)\n   */\n  public EntryReader(String filename) throws IOException {\n    this(filename, null, null);\n  }\n\n  /** Create a EntryReader that does not support comments or include directives.\n   * @param filename source from which to read entries\n   * @param charsetName the character set to use\n   * @throws IOException if there is a problem reading the file\n   * @see #EntryReader(String,String,String)\n   */\n  public EntryReader(String filename, String charsetName) throws IOException {\n    this(new FileInputStream(filename), charsetName, filename, null, null);\n  }\n\n  ///\n  /// Methods\n  ///\n\n  /**\n   * Read a line, ignoring comments and processing includes.  Note that\n   * a line that is completely a comment is completely ignored (and\n   * not returned as a blank line).  Returns null at end of file.\n   * @return the string that was read, or null at end of file\n   */\n  @Override\n  public /*@Nullable*/ String readLine() throws IOException {\n\n    // System.out.printf (\"Entering size = %d%n\", readers.size());\n\n    // If a line has been pushed back, return it instead\n    if (pushback_line != null) {\n      String line = pushback_line;\n      pushback_line = null;\n      return line;\n    }\n\n    String line = get_next_line();\n    if (comment_re != null) {\n      while (line != null) {\n        Matcher cmatch = comment_re.matcher(line);\n        if (cmatch.find()) {\n          line = cmatch.replaceFirst(\"\");\n          if (line.length() > 0) {\n            break;\n          }\n        } else {\n          break;\n        }\n        line = get_next_line();\n        // System.out.printf (\"get_next_line = %s%n\", line);\n      }\n    }\n\n    if (line == null) {\n      return null;\n    }\n\n    // Handle include files.  Non-absolute pathnames are relative\n    // to the including file (the current file)\n    if (include_re != null) {\n      Matcher m = include_re.matcher(line);\n      if (m.matches()) {\n        String filename_string = m.group(1);\n        if (filename_string == null) {\n          throw new Error(\n              String.format(\"include_re (%s) does not capture group 1 in %s\", include_re, line));\n        }\n        File filename = new File(UtilMDE.expandFilename(filename_string));\n        // System.out.printf (\"Trying to include filename %s%n\", filename);\n        if (!filename.isAbsolute()) {\n          FlnReader reader = readers.peek();\n          File current_filename = new File(reader.filename);\n          File current_parent = current_filename.getParentFile();\n          filename = new File(current_parent, filename.toString());\n          // System.out.printf (\"absolute filename = %s %s %s%n\",\n          //                     current_filename, current_parent, filename);\n        }\n        readers.push(new FlnReader(filename.getAbsolutePath()));\n        return readLine();\n      }\n    }\n\n    // System.out.printf (\"Returning [%d] '%s'%n\", readers.size(), line);\n    return (line);\n  }\n\n  /**\n   * Return a line-by-line iterator for this file.\n   * <p>\n   *\n   * <b>Warning:</b> This does not return a fresh iterator each time.  The\n   * iterator is a singleton, the same one is returned each time, and a new\n   * one can never be created after it is exhausted.\n   *\n   * @return a line-by-line iterator for this file\n   */\n  @Override\n  public Iterator<String> iterator() {\n    return this;\n  }\n\n  /**\n   * Returns whether or not there is another line to read.  Any IOExceptions\n   * are turned into errors (because the definition of hasNext() in Iterator\n   * doesn't throw any exceptions).\n   * @return whether there is another line to read\n   */\n  @Override\n  public boolean hasNext() {\n    if (pushback_line != null) {\n      return true;\n    }\n\n    String line = null;\n    try {\n      line = readLine();\n    } catch (IOException e) {\n      throw new Error(\"unexpected IOException: \", e);\n    }\n\n    if (line == null) {\n      return false;\n    }\n\n    putback(line);\n    return true;\n  }\n\n  /**\n   * Return the next line in the multi-file.\n   * @return the next line in the multi-file\n   * Throws NoSuchElementException at end of file\n   */\n  @Override\n  public String next() {\n    try {\n      String result = readLine();\n      if (result != null) {\n        return result;\n      } else {\n        throw new NoSuchElementException();\n      }\n    } catch (IOException e) {\n      throw new Error(\"unexpected IOException\", e);\n    }\n  }\n\n  /** remove() is not supported. */\n  @Override\n  public void remove() {\n    throw new UnsupportedOperationException(\"can't remove lines from file\");\n  }\n\n  /**\n   * Returns the next entry (paragraph) in the file.  Entries are separated\n   * by blank lines unless the entry started with {@link #entry_start_re}\n   * (see {@link #set_entry_start_stop}).  If no more entries are\n   * available, returns null.\n   * @return the next entry (paragraph) in the file\n   * @throws IOException if there is a problem reading the file\n   */\n  public /*@Nullable*/ Entry get_entry() throws IOException {\n\n    // Skip any preceding blank lines\n    String line = readLine();\n    while ((line != null) && (line.trim().length() == 0)) {\n      line = readLine();\n    }\n    if (line == null) {\n      return (null);\n    }\n\n    StringBuilder body = new StringBuilder(10000);\n    Entry entry = null;\n    String filename = getFileName();\n    long line_number = getLineNumber();\n\n    // If first line matches entry_start_re, this is a long entry.\n    /*@Regex(1)*/ Matcher entry_match = null;\n    if (entry_start_re != null) {\n      entry_match = entry_start_re.matcher(line);\n    }\n    if ((entry_match != null) && entry_match.find()) {\n      assert entry_start_re != null : \"@AssumeAssertion(nullness): dependent: entry_match != null\";\n      assert entry_stop_re != null\n          : \"@AssumeAssertion(nullness): dependent: entry_start_re != null\";\n\n      // Remove entry match from the line\n      if (entry_match.groupCount() > 0) {\n        @SuppressWarnings(\n            \"nullness\") // dependent: just checked that group 1 exists via groupCount(); https://code.google.com/p/checker-framework/issues/detail?id=291\n        /*@NonNull*/ String match_group_1 = entry_match.group(1);\n        line = entry_match.replaceFirst(match_group_1);\n      }\n\n      // Description is the first line\n      String description = line;\n\n      // Read until we find the termination of the entry\n      Matcher end_entry_match = entry_stop_re.matcher(line);\n      while ((line != null)\n          && !entry_match.find()\n          && !end_entry_match.find()\n          && filename.equals(getFileName())) {\n        body.append(line);\n        body.append(lineSep);\n        line = readLine();\n        if (line == null) {\n          break; // end of file serves as entry terminator\n        }\n        entry_match = entry_start_re.matcher(line);\n        end_entry_match = entry_stop_re.matcher(line);\n      }\n\n      // If this entry was terminated by the start of the next one,\n      // put that line back\n      if ((line != null) && (entry_match.find(0) || !filename.equals(getFileName()))) {\n        putback(line);\n      }\n\n      entry = new Entry(description, body.toString(), filename, line_number, false);\n\n    } else { // blank-separated entry\n\n      String description = line;\n\n      // Read until we find another blank line\n      while ((line != null) && (line.trim().length() != 0) && filename.equals(getFileName())) {\n        body.append(line);\n        body.append(lineSep);\n        line = readLine();\n      }\n\n      // If this entry was terminated by the start of a new input file\n      // put that line back\n      if ((line != null) && !filename.equals(getFileName())) {\n        putback(line);\n      }\n\n      entry = new Entry(description, body.toString(), filename, line_number, true);\n    }\n\n    return (entry);\n  }\n\n  /**\n   * Reads the next line from the current reader.  If EOF is encountered\n   * pop out to the next reader.  Returns null if there is no more input.\n   * @return next line from the reader, or null if there is no more input\n   */\n  private /*@Nullable*/ String get_next_line() throws IOException {\n\n    if (readers.size() == 0) {\n      return (null);\n    }\n\n    FlnReader ri1 = readers.peek();\n    String line = ri1.readLine();\n    while (line == null) {\n      readers.pop();\n      if (readers.empty()) {\n        return (null);\n      }\n      FlnReader ri2 = readers.peek();\n      line = ri2.readLine();\n    }\n    return (line);\n  }\n\n  /**\n   * Returns the current filename.\n   * @return the current filename\n   */\n  public String getFileName() {\n    FlnReader ri = readers.peek();\n    if (ri == null) {\n      throw new Error(\"Past end of input\");\n    }\n    return ri.filename;\n  }\n\n  /**\n   * Return the current line number in the current file.\n   * @return the current line number\n   */\n  @Override\n  public int getLineNumber() {\n    FlnReader ri = readers.peek();\n    if (ri == null) {\n      throw new Error(\"Past end of input\");\n    }\n    return ri.getLineNumber();\n  }\n\n  /** Set the current line number in the current file.\n   * @param lineNumber new line number for the current file\n   */\n  @Override\n  public void setLineNumber(int lineNumber) {\n    FlnReader ri = readers.peek();\n    if (ri == null) {\n      throw new Error(\"Past end of input\");\n    }\n    ri.setLineNumber(lineNumber);\n  }\n\n  /**\n   * Set the regular expressions for the start and stop of long\n   * entries (multiple lines that are read as a group by get_entry()).\n   * @param entry_start_re regular expression that starts a long entry\n   * @param entry_stop_re regular expression that ends a long entry\n   */\n  public void set_entry_start_stop(\n      /*@Regex(1)*/ String entry_start_re, /*@Regex*/ String entry_stop_re) {\n    this.entry_start_re = Pattern.compile(entry_start_re);\n    this.entry_stop_re = Pattern.compile(entry_stop_re);\n  }\n\n  /**\n   * Set the regular expressions for the start and stop of long\n   * entries (multiple lines that are read as a group by get_entry()).\n   * @param entry_start_re regular expression that starts a long entry\n   * @param entry_stop_re regular expression that ends a long entry\n   */\n  public void set_entry_start_stop(/*@Regex(1)*/ Pattern entry_start_re, Pattern entry_stop_re) {\n    this.entry_start_re = entry_start_re;\n    this.entry_stop_re = entry_stop_re;\n  }\n\n  /**\n   * Puts the specified line back in the input.  Only one line can be\n   * put back.\n   * @param line the line to be put back in the input\n   */\n  // TODO:  This would probably be better implemented with the \"mark\" mechanism\n  // of BufferedReader (which is also in LineNumberReader and FlnReader).\n  public void putback(String line) {\n    assert pushback_line == null\n        : \"push back '\" + line + \"' when '\" + pushback_line + \"' already back\";\n    pushback_line = line;\n  }\n\n  /** Mark the present position in the stream. */\n  @Override\n  public void mark(int readAheadLimit) {\n    throw new Error(\"not yet implemented\");\n  }\n  /** Read a single character. */\n  @Override\n  public int read() {\n    throw new Error(\"not yet implemented\");\n  }\n  /** Read characters into a portion of an array. */\n  @Override\n  public int read(char[] cbuf, int off, int len) {\n    throw new Error(\"not yet implemented\");\n  }\n  /** Reset the stream to the most recent mark. */\n  @Override\n  public void reset() {\n    throw new Error(\"not yet implemented\");\n  }\n  /** Skip characters. */\n  @Override\n  public long skip(long n) {\n    throw new Error(\"not yet implemented\");\n  }\n\n  /**\n   * Simple usage example.\n   * @param args command-line arguments: filename [comment_re [include_re]]\n   * @throws IOException if there is a problem reading a file\n   */\n  public static void main(String[] args) throws IOException {\n\n    if (args.length < 1 || args.length > 3) {\n      System.err.println(\n          \"EntryReader sample program requires 1-3 args: filename [comment_re [include_re]]\");\n      System.exit(1);\n    }\n    String filename = args[0];\n    String comment_re = null;\n    String include_re = null;\n    if (args.length >= 2) {\n      comment_re = args[1];\n      if (!RegexUtil.isRegex(comment_re)) {\n        System.err.println(\n            \"Error parsing comment regex \\\"\"\n                + comment_re\n                + \"\\\": \"\n                + RegexUtil.regexError(comment_re));\n        System.exit(1);\n      }\n    }\n    if (args.length >= 3) {\n      include_re = args[2];\n      if (!RegexUtil.isRegex(include_re, 1)) {\n        System.err.println(\n            \"Error parsing include regex \\\"\"\n                + include_re\n                + \"\\\": \"\n                + RegexUtil.regexError(include_re));\n        System.exit(1);\n      }\n    }\n    EntryReader reader = new EntryReader(filename, comment_re, include_re);\n\n    String line = reader.readLine();\n    while (line != null) {\n      System.out.printf(\"%s: %d: %s%n\", reader.getFileName(), reader.getLineNumber(), line);\n      line = reader.readLine();\n    }\n  }\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "filename", "java.lang", "String" ], [ "charsetName", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "next", "plume", "EntryReader", "public String next()" ], [ "ready", "java.io", "BufferedReader", "public boolean ready() throws IOException" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getLineNumber", "plume", "EntryReader", "public int getLineNumber()" ], [ "read", "java.io", "Reader", "public int read(CharBuffer arg0) throws IOException" ], [ "skip", "plume", "EntryReader", "public long skip(long n)" ], [ "read", "plume", "EntryReader", "public int read(char[] cbuf, int off, int len)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getFileName", "plume", "EntryReader", "public String getFileName()" ], [ "markSupported", "java.io", "BufferedReader", "public boolean markSupported()" ], [ "read", "plume", "EntryReader", "public int read()" ], [ "lines", "java.io", "BufferedReader", "public Stream<String> lines()" ], [ "next", "java.util", "Iterator", "public abstract E next()" ], [ "iterator", "plume", "EntryReader", "public Iterator<String> iterator()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "get_entry", "plume", "EntryReader", "public Entry get_entry() throws IOException" ], [ "readLine", "java.io", "BufferedReader", "String readLine(boolean arg0, boolean[] arg1) throws IOException" ], [ "hasNext", "plume", "EntryReader", "public boolean hasNext()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "read", "java.io", "Reader", "public int read(char[] arg0) throws IOException" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "transferTo", "java.io", "Reader", "public long transferTo(Writer arg0) throws IOException" ], [ "readLine", "plume", "EntryReader", "public String readLine() throws IOException" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "length", "java.lang", "String", "public int length()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "entry_start_re", "plume", "EntryReader", "public Pattern entry_start_re = null;" ], [ "entry_stop_re", "plume", "EntryReader", "public Pattern entry_stop_re = null;" ], [ "pushback_line", "plume", "EntryReader", "String pushback_line = null;" ], [ "lock", "java.io", "Reader", "protected Object lock;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
} ]